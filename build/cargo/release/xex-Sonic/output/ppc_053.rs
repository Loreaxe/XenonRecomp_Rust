pub fn sub_825DD6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DD6D8 size=12
    let mut pc: u32 = 0x825DD6D8;
    'dispatch: loop {
        match pc {
            0x825DD6D8 => {
    //   block [0x825DD6D8..0x825DD6E4)
	// 825DD6D8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DD6DC: D02BD164  stfs f1, -0x2e9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-11932 as u32), tmp.u32 ) };
	// 825DD6E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DD6E8 size=12
    let mut pc: u32 = 0x825DD6E8;
    'dispatch: loop {
        match pc {
            0x825DD6E8 => {
    //   block [0x825DD6E8..0x825DD6F4)
	// 825DD6E8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DD6EC: C02BD164  lfs f1, -0x2e9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11932 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DD6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD6F8 size=16
    let mut pc: u32 = 0x825DD6F8;
    'dispatch: loop {
        match pc {
            0x825DD6F8 => {
    //   block [0x825DD6F8..0x825DD708)
	// 825DD6F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD6FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DD704: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD708 size=16
    let mut pc: u32 = 0x825DD708;
    'dispatch: loop {
        match pc {
            0x825DD708 => {
    //   block [0x825DD708..0x825DD718)
	// 825DD708: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD70C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DD714: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD718 size=88
    let mut pc: u32 = 0x825DD718;
    'dispatch: loop {
        match pc {
            0x825DD718 => {
    //   block [0x825DD718..0x825DD770)
	// 825DD718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD71C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD720: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD724: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD72C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD730: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DD734: 396BEDA4  addi r11, r11, -0x125c
	ctx.r[11].s64 = ctx.r[11].s64 + -4700;
	// 825DD738: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DD73C: 4182001C  beq 0x825dd758
	if ctx.cr[0].eq {
	pc = 0x825DD758; continue 'dispatch;
	}
	// 825DD740: 48AD7509  bl 0x830b4c48
	ctx.lr = 0x825DD744;
	sub_830B4C48(ctx, base);
	// 825DD744: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DD74C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DD750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DD754: 4E800421  bctrl
	ctx.lr = 0x825DD758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DD758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD75C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DD760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD76C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD770 size=8
    let mut pc: u32 = 0x825DD770;
    'dispatch: loop {
        match pc {
            0x825DD770 => {
    //   block [0x825DD770..0x825DD778)
	// 825DD770: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825DD774: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD778 size=8
    let mut pc: u32 = 0x825DD778;
    'dispatch: loop {
        match pc {
            0x825DD778 => {
    //   block [0x825DD778..0x825DD780)
	// 825DD778: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825DD77C: 4BCE2AEC  b 0x822c0268
	sub_822C0268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD780 size=4
    let mut pc: u32 = 0x825DD780;
    'dispatch: loop {
        match pc {
            0x825DD780 => {
    //   block [0x825DD780..0x825DD784)
	// 825DD780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD788 size=28
    let mut pc: u32 = 0x825DD788;
    'dispatch: loop {
        match pc {
            0x825DD788 => {
    //   block [0x825DD788..0x825DD7A4)
	// 825DD788: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DD78C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DD790: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825DD794: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 825DD798: 388AEE0C  addi r4, r10, -0x11f4
	ctx.r[4].s64 = ctx.r[10].s64 + -4596;
	// 825DD79C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825DD7A0: 48814928  b 0x82df20c8
	sub_82DF20C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD7A8 size=12
    let mut pc: u32 = 0x825DD7A8;
    'dispatch: loop {
        match pc {
            0x825DD7A8 => {
    //   block [0x825DD7A8..0x825DD7B4)
	// 825DD7A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DD7AC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825DD7B0: 488149D8  b 0x82df2188
	sub_82DF2188(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD7B8 size=68
    let mut pc: u32 = 0x825DD7B8;
    'dispatch: loop {
        match pc {
            0x825DD7B8 => {
    //   block [0x825DD7B8..0x825DD7FC)
	// 825DD7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD7C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD7C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD7C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD7CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD7D0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DD7D4: 396BED84  addi r11, r11, -0x127c
	ctx.r[11].s64 = ctx.r[11].s64 + -4732;
	// 825DD7D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DD7DC: 41820008  beq 0x825dd7e4
	if ctx.cr[0].eq {
	pc = 0x825DD7E4; continue 'dispatch;
	}
	// 825DD7E0: 4BCE2A89  bl 0x822c0268
	ctx.lr = 0x825DD7E4;
	sub_822C0268(ctx, base);
	// 825DD7E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD7E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DD7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD7F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD800 size=24
    let mut pc: u32 = 0x825DD800;
    'dispatch: loop {
        match pc {
            0x825DD800 => {
    //   block [0x825DD800..0x825DD818)
	// 825DD800: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD804: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825DD808: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 825DD80C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 825DD810: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD814: 486000D4  b 0x82bdd8e8
	sub_82BDD8E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD818 size=24
    let mut pc: u32 = 0x825DD818;
    'dispatch: loop {
        match pc {
            0x825DD818 => {
    //   block [0x825DD818..0x825DD830)
	// 825DD818: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD81C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825DD820: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 825DD824: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 825DD828: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD82C: 486000BC  b 0x82bdd8e8
	sub_82BDD8E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD830 size=212
    let mut pc: u32 = 0x825DD830;
    'dispatch: loop {
        match pc {
            0x825DD830 => {
    //   block [0x825DD830..0x825DD904)
	// 825DD830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD83C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD840: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825DD844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD848: 816A7DE8  lwz r11, 0x7de8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32232 as u32) ) } as u64;
	// 825DD84C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825DD850: 40820020  bne 0x825dd870
	if !ctx.cr[0].eq {
	pc = 0x825DD870; continue 'dispatch;
	}
	// 825DD854: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825DD858: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 825DD85C: 916A7DE8  stw r11, 0x7de8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32232 as u32), ctx.r[11].u32 ) };
	// 825DD860: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DD864: 38890718  addi r4, r9, 0x718
	ctx.r[4].s64 = ctx.r[9].s64 + 1816;
	// 825DD868: 386B7DE4  addi r3, r11, 0x7de4
	ctx.r[3].s64 = ctx.r[11].s64 + 32228;
	// 825DD86C: 4881BCC5  bl 0x82df9530
	ctx.lr = 0x825DD870;
	sub_82DF9530(ctx, base);
	// 825DD870: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DD874: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD878: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 825DD87C: 48830F3D  bl 0x82e0e7b8
	ctx.lr = 0x825DD880;
	sub_82E0E7B8(ctx, base);
	// 825DD880: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DD884: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 825DD888: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD88C: 48830F2D  bl 0x82e0e7b8
	ctx.lr = 0x825DD890;
	sub_82E0E7B8(ctx, base);
	// 825DD890: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DD894: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825DD898: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD89C: 48830F1D  bl 0x82e0e7b8
	ctx.lr = 0x825DD8A0;
	sub_82E0E7B8(ctx, base);
	// 825DD8A0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825DD8A4: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 825DD8A8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD8AC: 48830F0D  bl 0x82e0e7b8
	ctx.lr = 0x825DD8B0;
	sub_82E0E7B8(ctx, base);
	// 825DD8B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DD8B4: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 825DD8B8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD8BC: 48830EFD  bl 0x82e0e7b8
	ctx.lr = 0x825DD8C0;
	sub_82E0E7B8(ctx, base);
	// 825DD8C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DD8C4: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 825DD8C8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD8CC: 48830EED  bl 0x82e0e7b8
	ctx.lr = 0x825DD8D0;
	sub_82E0E7B8(ctx, base);
	// 825DD8D0: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 825DD8D4: 38800068  li r4, 0x68
	ctx.r[4].s64 = 104;
	// 825DD8D8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD8DC: 48830EDD  bl 0x82e0e7b8
	ctx.lr = 0x825DD8E0;
	sub_82E0E7B8(ctx, base);
	// 825DD8E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DD8E4: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 825DD8E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD8EC: 48830ECD  bl 0x82e0e7b8
	ctx.lr = 0x825DD8F0;
	sub_82E0E7B8(ctx, base);
	// 825DD8F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DD8F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD8F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD8FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD908 size=164
    let mut pc: u32 = 0x825DD908;
    'dispatch: loop {
        match pc {
            0x825DD908 => {
    //   block [0x825DD908..0x825DD9AC)
	// 825DD908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD914: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD91C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DD920: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DD924: 64C68000  oris r6, r6, 0x8000
	ctx.r[6].u64 = ctx.r[6].u64 | 2147483648;
	// 825DD928: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DD92C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD930: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD934: 486044D5  bl 0x82be1e08
	ctx.lr = 0x825DD938;
	sub_82BE1E08(ctx, base);
	// 825DD938: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 825DD93C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD940: 48830F51  bl 0x82e0e890
	ctx.lr = 0x825DD944;
	sub_82E0E890(ctx, base);
	// 825DD944: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 825DD948: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD94C: 48830F45  bl 0x82e0e890
	ctx.lr = 0x825DD950;
	sub_82E0E890(ctx, base);
	// 825DD950: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825DD954: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD958: 48830F39  bl 0x82e0e890
	ctx.lr = 0x825DD95C;
	sub_82E0E890(ctx, base);
	// 825DD95C: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 825DD960: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD964: 48830F2D  bl 0x82e0e890
	ctx.lr = 0x825DD968;
	sub_82E0E890(ctx, base);
	// 825DD968: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 825DD96C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD970: 48830F21  bl 0x82e0e890
	ctx.lr = 0x825DD974;
	sub_82E0E890(ctx, base);
	// 825DD974: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 825DD978: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD97C: 48830F15  bl 0x82e0e890
	ctx.lr = 0x825DD980;
	sub_82E0E890(ctx, base);
	// 825DD980: 38800068  li r4, 0x68
	ctx.r[4].s64 = 104;
	// 825DD984: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD988: 48830F09  bl 0x82e0e890
	ctx.lr = 0x825DD98C;
	sub_82E0E890(ctx, base);
	// 825DD98C: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 825DD990: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD994: 48830EFD  bl 0x82e0e890
	ctx.lr = 0x825DD998;
	sub_82E0E890(ctx, base);
	// 825DD998: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DD99C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD9A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD9B0 size=100
    let mut pc: u32 = 0x825DD9B0;
    'dispatch: loop {
        match pc {
            0x825DD9B0 => {
    //   block [0x825DD9B0..0x825DDA14)
	// 825DD9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD9B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DD9BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD9C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD9C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD9C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD9CC: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 825DD9D0: 396BEE4C  addi r11, r11, -0x11b4
	ctx.r[11].s64 = ctx.r[11].s64 + -4532;
	// 825DD9D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DD9D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DD9DC: 48AD44E5  bl 0x830b1ec0
	ctx.lr = 0x825DD9E0;
	sub_830B1EC0(ctx, base);
	// 825DD9E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD9E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DD9E8: 396BEDD8  addi r11, r11, -0x1228
	ctx.r[11].s64 = ctx.r[11].s64 + -4648;
	// 825DD9EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DD9F0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DD9F4: 48AD45A5  bl 0x830b1f98
	ctx.lr = 0x825DD9F8;
	sub_830B1F98(ctx, base);
	// 825DD9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DDA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DDA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DDA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DDA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DDA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DDA18 size=112
    let mut pc: u32 = 0x825DDA18;
    'dispatch: loop {
        match pc {
            0x825DDA18 => {
    //   block [0x825DDA18..0x825DDA88)
	// 825DDA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DDA20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DDA24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDA28: 48AD7221  bl 0x830b4c48
	ctx.lr = 0x825DDA2C;
	sub_830B4C48(ctx, base);
	// 825DDA2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DDA30: 38C000A5  li r6, 0xa5
	ctx.r[6].s64 = 165;
	// 825DDA34: 38ABD454  addi r5, r11, -0x2bac
	ctx.r[5].s64 = ctx.r[11].s64 + -11180;
	// 825DDA38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDA3C: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 825DDA40: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DDA44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DDA48: 4E800421  bctrl
	ctx.lr = 0x825DDA4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DDA4C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DDA50: 41820020  beq 0x825dda70
	if ctx.cr[0].eq {
	pc = 0x825DDA70; continue 'dispatch;
	}
	// 825DDA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDA58: 48AD42E9  bl 0x830b1d40
	ctx.lr = 0x825DDA5C;
	sub_830B1D40(ctx, base);
	// 825DDA5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DDA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDA64: 396BEDE4  addi r11, r11, -0x121c
	ctx.r[11].s64 = ctx.r[11].s64 + -4636;
	// 825DDA68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DDA6C: 48000008  b 0x825dda74
	pc = 0x825DDA74; continue 'dispatch;
	// 825DDA70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825DDA74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DDA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DDA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DDA80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DDA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DDA88 size=108
    let mut pc: u32 = 0x825DDA88;
    'dispatch: loop {
        match pc {
            0x825DDA88 => {
    //   block [0x825DDA88..0x825DDAF4)
	// 825DDA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DDA90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DDA94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDA98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DDA9C: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 825DDAA0: 41980020  blt cr6, 0x825ddac0
	if ctx.cr[6].lt {
	pc = 0x825DDAC0; continue 'dispatch;
	}
	// 825DDAA4: 409A003C  bne cr6, 0x825ddae0
	if !ctx.cr[6].eq {
	pc = 0x825DDAE0; continue 'dispatch;
	}
	// 825DDAA8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825DDAAC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDAB0: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 825DDAB4: 4BD07835  bl 0x822e52e8
	ctx.lr = 0x825DDAB8;
	sub_822E52E8(ctx, base);
	// 825DDAB8: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 825DDABC: 48000018  b 0x825ddad4
	pc = 0x825DDAD4; continue 'dispatch;
	// 825DDAC0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825DDAC4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDAC8: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 825DDACC: 4BD0781D  bl 0x822e52e8
	ctx.lr = 0x825DDAD0;
	sub_822E52E8(ctx, base);
	// 825DDAD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DDAD4: 3880004C  li r4, 0x4c
	ctx.r[4].s64 = 76;
	// 825DDAD8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDADC: 4BD0780D  bl 0x822e52e8
	ctx.lr = 0x825DDAE0;
	sub_822E52E8(ctx, base);
	// 825DDAE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DDAE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DDAE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DDAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DDAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DDAF8 size=268
    let mut pc: u32 = 0x825DDAF8;
    'dispatch: loop {
        match pc {
            0x825DDAF8 => {
    //   block [0x825DDAF8..0x825DDC04)
	// 825DDAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDAFC: 48BCA66D  bl 0x831a8168
	ctx.lr = 0x825DDB00;
	sub_831A8130(ctx, base);
	// 825DDB00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDB04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DDB08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DDB0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDB10: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDB14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDB18: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825DDB1C: 419A0010  beq cr6, 0x825ddb2c
	if ctx.cr[6].eq {
	pc = 0x825DDB2C; continue 'dispatch;
	}
	// 825DDB20: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825DDB24: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDB28: 485FADA9  bl 0x82bd88d0
	ctx.lr = 0x825DDB2C;
	sub_82BD88D0(ctx, base);
	// 825DDB2C: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 825DDB30: 41980010  blt cr6, 0x825ddb40
	if ctx.cr[6].lt {
	pc = 0x825DDB40; continue 'dispatch;
	}
	// 825DDB34: 409A001C  bne cr6, 0x825ddb50
	if !ctx.cr[6].eq {
	pc = 0x825DDB50; continue 'dispatch;
	}
	// 825DDB38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DDB3C: 48000008  b 0x825ddb44
	pc = 0x825DDB44; continue 'dispatch;
	// 825DDB40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DDB44: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 825DDB48: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDB4C: 4BD0779D  bl 0x822e52e8
	ctx.lr = 0x825DDB50;
	sub_822E52E8(ctx, base);
	// 825DDB50: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DDB54: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 825DDB58: 48820C89  bl 0x82dfe7e0
	ctx.lr = 0x825DDB5C;
	sub_82DFE7E0(ctx, base);
	// 825DDB5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDB60: 4182009C  beq 0x825ddbfc
	if ctx.cr[0].eq {
	pc = 0x825DDBFC; continue 'dispatch;
	}
	// 825DDB64: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825DDB68: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 825DDB6C: 48820C75  bl 0x82dfe7e0
	ctx.lr = 0x825DDB70;
	sub_82DFE7E0(ctx, base);
	// 825DDB70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDB74: 41820088  beq 0x825ddbfc
	if ctx.cr[0].eq {
	pc = 0x825DDBFC; continue 'dispatch;
	}
	// 825DDB78: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDB7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDB80: 48831041  bl 0x82e0ebc0
	ctx.lr = 0x825DDB84;
	sub_82E0EBC0(ctx, base);
	// 825DDB84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDB88: 48831129  bl 0x82e0ecb0
	ctx.lr = 0x825DDB8C;
	sub_82E0ECB0(ctx, base);
	// 825DDB8C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825DDB90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DDB94: 3BCB7DEC  addi r30, r11, 0x7dec
	ctx.r[30].s64 = ctx.r[11].s64 + 32236;
	// 825DDB98: 816A7DF0  lwz r11, 0x7df0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32240 as u32) ) } as u64;
	// 825DDB9C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825DDBA0: 4082001C  bne 0x825ddbbc
	if !ctx.cr[0].eq {
	pc = 0x825DDBBC; continue 'dispatch;
	}
	// 825DDBA4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825DDBA8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825DDBAC: 916A7DF0  stw r11, 0x7df0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32240 as u32), ctx.r[11].u32 ) };
	// 825DDBB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDBB4: 3889EE68  addi r4, r9, -0x1198
	ctx.r[4].s64 = ctx.r[9].s64 + -4504;
	// 825DDBB8: 4881B979  bl 0x82df9530
	ctx.lr = 0x825DDBBC;
	sub_82DF9530(ctx, base);
	// 825DDBBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825DDBC0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDBC4: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825DDBC8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDBCC: C08B08A4  lfs f4, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 825DDBD0: C02AD164  lfs f1, -0x2e9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11932 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DDBD4: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 825DDBD8: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 825DDBDC: 4883CA5D  bl 0x82e1a638
	ctx.lr = 0x825DDBE0;
	sub_82E1A638(ctx, base);
	// 825DDBE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DDBE4: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDBE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDBEC: 48830F3D  bl 0x82e0eb28
	ctx.lr = 0x825DDBF0;
	sub_82E0EB28(ctx, base);
	// 825DDBF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DDBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDBF8: 48831029  bl 0x82e0ec20
	ctx.lr = 0x825DDBFC;
	sub_82E0EC20(ctx, base);
	// 825DDBFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DDC00: 48BCA5B8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DDC08 size=356
    let mut pc: u32 = 0x825DDC08;
    'dispatch: loop {
        match pc {
            0x825DDC08 => {
    //   block [0x825DDC08..0x825DDD6C)
	// 825DDC08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDC0C: 48BCA55D  bl 0x831a8168
	ctx.lr = 0x825DDC10;
	sub_831A8130(ctx, base);
	// 825DDC10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDC14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DDC18: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DDC1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDC20: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDC24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDC28: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDC2C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825DDC30: 419A0010  beq cr6, 0x825ddc40
	if ctx.cr[6].eq {
	pc = 0x825DDC40; continue 'dispatch;
	}
	// 825DDC34: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825DDC38: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDC3C: 485FAC95  bl 0x82bd88d0
	ctx.lr = 0x825DDC40;
	sub_82BD88D0(ctx, base);
	// 825DDC40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DDC44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DDC48: 64C68000  oris r6, r6, 0x8000
	ctx.r[6].u64 = ctx.r[6].u64 | 2147483648;
	// 825DDC4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DDC50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDC54: 486041B5  bl 0x82be1e08
	ctx.lr = 0x825DDC58;
	sub_82BE1E08(ctx, base);
	// 825DDC58: 3CC04000  lis r6, 0x4000
	ctx.r[6].s64 = 1073741824;
	// 825DDC5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DDC60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DDC64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDC68: 486041A1  bl 0x82be1e08
	ctx.lr = 0x825DDC6C;
	sub_82BE1E08(ctx, base);
	// 825DDC6C: 3CC02000  lis r6, 0x2000
	ctx.r[6].s64 = 536870912;
	// 825DDC70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DDC74: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825DDC78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDC7C: 4860418D  bl 0x82be1e08
	ctx.lr = 0x825DDC80;
	sub_82BE1E08(ctx, base);
	// 825DDC80: 3CC01000  lis r6, 0x1000
	ctx.r[6].s64 = 268435456;
	// 825DDC84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DDC88: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DDC8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDC90: 48604179  bl 0x82be1e08
	ctx.lr = 0x825DDC94;
	sub_82BE1E08(ctx, base);
	// 825DDC94: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 825DDC98: 41980010  blt cr6, 0x825ddca8
	if ctx.cr[6].lt {
	pc = 0x825DDCA8; continue 'dispatch;
	}
	// 825DDC9C: 409A001C  bne cr6, 0x825ddcb8
	if !ctx.cr[6].eq {
	pc = 0x825DDCB8; continue 'dispatch;
	}
	// 825DDCA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DDCA4: 48000008  b 0x825ddcac
	pc = 0x825DDCAC; continue 'dispatch;
	// 825DDCA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DDCAC: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 825DDCB0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDCB4: 4BD07635  bl 0x822e52e8
	ctx.lr = 0x825DDCB8;
	sub_822E52E8(ctx, base);
	// 825DDCB8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DDCBC: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 825DDCC0: 48820B21  bl 0x82dfe7e0
	ctx.lr = 0x825DDCC4;
	sub_82DFE7E0(ctx, base);
	// 825DDCC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDCC8: 4182009C  beq 0x825ddd64
	if ctx.cr[0].eq {
	pc = 0x825DDD64; continue 'dispatch;
	}
	// 825DDCCC: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825DDCD0: 3B9F0038  addi r28, r31, 0x38
	ctx.r[28].s64 = ctx.r[31].s64 + 56;
	// 825DDCD4: 48820B0D  bl 0x82dfe7e0
	ctx.lr = 0x825DDCD8;
	sub_82DFE7E0(ctx, base);
	// 825DDCD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDCDC: 41820088  beq 0x825ddd64
	if ctx.cr[0].eq {
	pc = 0x825DDD64; continue 'dispatch;
	}
	// 825DDCE0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDCE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDCE8: 48830ED9  bl 0x82e0ebc0
	ctx.lr = 0x825DDCEC;
	sub_82E0EBC0(ctx, base);
	// 825DDCEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDCF0: 48830FC1  bl 0x82e0ecb0
	ctx.lr = 0x825DDCF4;
	sub_82E0ECB0(ctx, base);
	// 825DDCF4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825DDCF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DDCFC: 3BCB7DF4  addi r30, r11, 0x7df4
	ctx.r[30].s64 = ctx.r[11].s64 + 32244;
	// 825DDD00: 816A7DF8  lwz r11, 0x7df8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32248 as u32) ) } as u64;
	// 825DDD04: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825DDD08: 4082001C  bne 0x825ddd24
	if !ctx.cr[0].eq {
	pc = 0x825DDD24; continue 'dispatch;
	}
	// 825DDD0C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825DDD10: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825DDD14: 916A7DF8  stw r11, 0x7df8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32248 as u32), ctx.r[11].u32 ) };
	// 825DDD18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DDD1C: 3889EE68  addi r4, r9, -0x1198
	ctx.r[4].s64 = ctx.r[9].s64 + -4504;
	// 825DDD20: 4881B811  bl 0x82df9530
	ctx.lr = 0x825DDD24;
	sub_82DF9530(ctx, base);
	// 825DDD24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825DDD28: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDD2C: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825DDD30: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDD34: C08B08A4  lfs f4, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 825DDD38: C02AD164  lfs f1, -0x2e9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11932 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DDD3C: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 825DDD40: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 825DDD44: 4883C8F5  bl 0x82e1a638
	ctx.lr = 0x825DDD48;
	sub_82E1A638(ctx, base);
	// 825DDD48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DDD4C: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDD54: 48830DD5  bl 0x82e0eb28
	ctx.lr = 0x825DDD58;
	sub_82E0EB28(ctx, base);
	// 825DDD58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DDD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDD60: 48830EC1  bl 0x82e0ec20
	ctx.lr = 0x825DDD64;
	sub_82E0EC20(ctx, base);
	// 825DDD64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DDD68: 48BCA450  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DDD70 size=164
    let mut pc: u32 = 0x825DDD70;
    'dispatch: loop {
        match pc {
            0x825DDD70 => {
    //   block [0x825DDD70..0x825DDE14)
	// 825DDD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDD74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DDD78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DDD7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DDD80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDD84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DDD88: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 825DDD8C: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 825DDD90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDD94: 419A0008  beq cr6, 0x825ddd9c
	if ctx.cr[6].eq {
	pc = 0x825DDD9C; continue 'dispatch;
	}
	// 825DDD98: 4BCE2AF9  bl 0x822c0890
	ctx.lr = 0x825DDD9C;
	sub_822C0890(ctx, base);
	// 825DDD9C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDDA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDDA4: 419A0008  beq cr6, 0x825dddac
	if ctx.cr[6].eq {
	pc = 0x825DDDAC; continue 'dispatch;
	}
	// 825DDDA8: 4BCE2AE9  bl 0x822c0890
	ctx.lr = 0x825DDDAC;
	sub_822C0890(ctx, base);
	// 825DDDAC: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825DDDB0: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 825DDDB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDDB8: 419A0008  beq cr6, 0x825dddc0
	if ctx.cr[6].eq {
	pc = 0x825DDDC0; continue 'dispatch;
	}
	// 825DDDBC: 4BCE2AD5  bl 0x822c0890
	ctx.lr = 0x825DDDC0;
	sub_822C0890(ctx, base);
	// 825DDDC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDDC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDDC8: 419A0008  beq cr6, 0x825dddd0
	if ctx.cr[6].eq {
	pc = 0x825DDDD0; continue 'dispatch;
	}
	// 825DDDCC: 4BCE2AC5  bl 0x822c0890
	ctx.lr = 0x825DDDD0;
	sub_822C0890(ctx, base);
	// 825DDDD0: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 825DDDD4: 488354C5  bl 0x82e13298
	ctx.lr = 0x825DDDD8;
	sub_82E13298(ctx, base);
	// 825DDDD8: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825DDDDC: 488354BD  bl 0x82e13298
	ctx.lr = 0x825DDDE0;
	sub_82E13298(ctx, base);
	// 825DDDE0: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DDDE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDDE8: 419A0008  beq cr6, 0x825dddf0
	if ctx.cr[6].eq {
	pc = 0x825DDDF0; continue 'dispatch;
	}
	// 825DDDEC: 4BCE2AA5  bl 0x822c0890
	ctx.lr = 0x825DDDF0;
	sub_822C0890(ctx, base);
	// 825DDDF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DDDF4: 396BEDA4  addi r11, r11, -0x125c
	ctx.r[11].s64 = ctx.r[11].s64 + -4700;
	// 825DDDF8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DDDFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DDE00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DDE04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DDE08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DDE0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DDE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DDE18 size=12
    let mut pc: u32 = 0x825DDE18;
    'dispatch: loop {
        match pc {
            0x825DDE18 => {
    //   block [0x825DDE18..0x825DDE24)
	// 825DDE18: 3C602E44  lis r3, 0x2e44
	ctx.r[3].s64 = 776208384;
	// 825DDE1C: 6063584C  ori r3, r3, 0x584c
	ctx.r[3].u64 = ctx.r[3].u64 | 22604;
	// 825DDE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DDE28 size=92
    let mut pc: u32 = 0x825DDE28;
    'dispatch: loop {
        match pc {
            0x825DDE28 => {
    //   block [0x825DDE28..0x825DDE84)
	// 825DDE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DDE30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DDE34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DDE38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DDE40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DDE44: 48001215  bl 0x825df058
	ctx.lr = 0x825DDE48;
	sub_825DF058(ctx, base);
	// 825DDE48: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDE4C: 4182001C  beq 0x825dde68
	if ctx.cr[0].eq {
	pc = 0x825DDE68; continue 'dispatch;
	}
	// 825DDE50: 48AD6DF9  bl 0x830b4c48
	ctx.lr = 0x825DDE54;
	sub_830B4C48(ctx, base);
	// 825DDE54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDE58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DDE5C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDE60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DDE64: 4E800421  bctrl
	ctx.lr = 0x825DDE68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DDE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DDE6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DDE70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DDE74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DDE78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DDE7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DDE80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DDE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DDE88 size=600
    let mut pc: u32 = 0x825DDE88;
    'dispatch: loop {
        match pc {
            0x825DDE88 => {
    //   block [0x825DDE88..0x825DE0E0)
	// 825DDE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DDE8C: 48BCA2CD  bl 0x831a8158
	ctx.lr = 0x825DDE90;
	sub_831A8130(ctx, base);
	// 825DDE90: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DDE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DDE98: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DDE9C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825DDEA0: 392AEEF4  addi r9, r10, -0x110c
	ctx.r[9].s64 = ctx.r[10].s64 + -4364;
	// 825DDEA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DDEA8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DDEAC: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 825DDEB0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DDEB4: 3B190004  addi r24, r25, 4
	ctx.r[24].s64 = ctx.r[25].s64 + 4;
	// 825DDEB8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDEBC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DDEC0: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDEC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DDEC8: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825DDECC: 419A0024  beq cr6, 0x825ddef0
	if ctx.cr[6].eq {
	pc = 0x825DDEF0; continue 'dispatch;
	}
	// 825DDED0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825DDED4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825DDED8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DDEDC: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825DDEE0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825DDEE4: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DDEE8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DDEEC: 4082FFE8  bne 0x825dded4
	if !ctx.cr[0].eq {
	pc = 0x825DDED4; continue 'dispatch;
	}
	// 825DDEF0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825DDEF4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825DDEF8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825DDEFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DDF00: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825DDF04: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 825DDF08: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825DDF0C: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
	// 825DDF10: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825DDF14: 3B5F0018  addi r26, r31, 0x18
	ctx.r[26].s64 = ctx.r[31].s64 + 24;
	// 825DDF18: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 825DDF1C: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 825DDF20: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825DDF24: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825DDF28: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825DDF2C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825DDF30: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825DDF34: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 825DDF38: 4884CBB1  bl 0x82e2aae8
	ctx.lr = 0x825DDF3C;
	sub_82E2AAE8(ctx, base);
	// 825DDF3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DDF40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DDF44: 3B8BEEEC  addi r28, r11, -0x1114
	ctx.r[28].s64 = ctx.r[11].s64 + -4372;
	// 825DDF48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DDF4C: 48815ABD  bl 0x82df3a08
	ctx.lr = 0x825DDF50;
	sub_82DF3A08(ctx, base);
	// 825DDF50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DDF54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DDF58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825DDF5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DDF60: 48850A01  bl 0x82e2e960
	ctx.lr = 0x825DDF64;
	sub_82E2E960(ctx, base);
	// 825DDF64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DDF68: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825DDF6C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DDF70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDF74: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825DDF78: 4BCE64E9  bl 0x822c4460
	ctx.lr = 0x825DDF7C;
	sub_822C4460(ctx, base);
	// 825DDF7C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825DDF80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDF84: 419A0008  beq cr6, 0x825ddf8c
	if ctx.cr[6].eq {
	pc = 0x825DDF8C; continue 'dispatch;
	}
	// 825DDF88: 4BCE2909  bl 0x822c0890
	ctx.lr = 0x825DDF8C;
	sub_822C0890(ctx, base);
	// 825DDF8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DDF90: 48815499  bl 0x82df3428
	ctx.lr = 0x825DDF94;
	sub_82DF3428(ctx, base);
	// 825DDF94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DDF98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DDF9C: 48815A6D  bl 0x82df3a08
	ctx.lr = 0x825DDFA0;
	sub_82DF3A08(ctx, base);
	// 825DDFA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DDFA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DDFA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825DDFAC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825DDFB0: 48850861  bl 0x82e2e810
	ctx.lr = 0x825DDFB4;
	sub_82E2E810(ctx, base);
	// 825DDFB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DDFB8: 395F0028  addi r10, r31, 0x28
	ctx.r[10].s64 = ctx.r[31].s64 + 40;
	// 825DDFBC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DDFC0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825DDFC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDFC8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825DDFCC: 4BCE6495  bl 0x822c4460
	ctx.lr = 0x825DDFD0;
	sub_822C4460(ctx, base);
	// 825DDFD0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825DDFD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DDFD8: 419A0008  beq cr6, 0x825ddfe0
	if ctx.cr[6].eq {
	pc = 0x825DDFE0; continue 'dispatch;
	}
	// 825DDFDC: 4BCE28B5  bl 0x822c0890
	ctx.lr = 0x825DDFE0;
	sub_822C0890(ctx, base);
	// 825DDFE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DDFE4: 48815445  bl 0x82df3428
	ctx.lr = 0x825DDFE8;
	sub_82DF3428(ctx, base);
	// 825DDFE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DDFEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DDFF0: 3BABEEE0  addi r29, r11, -0x1120
	ctx.r[29].s64 = ctx.r[11].s64 + -4384;
	// 825DDFF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DDFF8: 48815A11  bl 0x82df3a08
	ctx.lr = 0x825DDFFC;
	sub_82DF3A08(ctx, base);
	// 825DDFFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DE000: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DE004: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825DE008: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DE00C: 48850955  bl 0x82e2e960
	ctx.lr = 0x825DE010;
	sub_82E2E960(ctx, base);
	// 825DE010: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DE014: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825DE018: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DE01C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE020: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE024: 4BCE643D  bl 0x822c4460
	ctx.lr = 0x825DE028;
	sub_822C4460(ctx, base);
	// 825DE028: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825DE02C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DE030: 419A0008  beq cr6, 0x825de038
	if ctx.cr[6].eq {
	pc = 0x825DE038; continue 'dispatch;
	}
	// 825DE034: 4BCE285D  bl 0x822c0890
	ctx.lr = 0x825DE038;
	sub_822C0890(ctx, base);
	// 825DE038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE03C: 488153ED  bl 0x82df3428
	ctx.lr = 0x825DE040;
	sub_82DF3428(ctx, base);
	// 825DE040: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DE044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE048: 488159C1  bl 0x82df3a08
	ctx.lr = 0x825DE04C;
	sub_82DF3A08(ctx, base);
	// 825DE04C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DE050: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DE054: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825DE058: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825DE05C: 488507B5  bl 0x82e2e810
	ctx.lr = 0x825DE060;
	sub_82E2E810(ctx, base);
	// 825DE060: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DE064: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 825DE068: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DE06C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825DE070: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE074: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825DE078: 4BCE63E9  bl 0x822c4460
	ctx.lr = 0x825DE07C;
	sub_822C4460(ctx, base);
	// 825DE07C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825DE080: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DE084: 419A0008  beq cr6, 0x825de08c
	if ctx.cr[6].eq {
	pc = 0x825DE08C; continue 'dispatch;
	}
	// 825DE088: 4BCE2809  bl 0x822c0890
	ctx.lr = 0x825DE08C;
	sub_822C0890(ctx, base);
	// 825DE08C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE090: 48815399  bl 0x82df3428
	ctx.lr = 0x825DE094;
	sub_82DF3428(ctx, base);
	// 825DE094: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE098: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825DE09C: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE0A0: 388BEEB0  addi r4, r11, -0x1150
	ctx.r[4].s64 = ctx.r[11].s64 + -4432;
	// 825DE0A4: 488310C5  bl 0x82e0f168
	ctx.lr = 0x825DE0A8;
	sub_82E0F168(ctx, base);
	// 825DE0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE0AC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825DE0B0: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE0B4: 388BEE8C  addi r4, r11, -0x1174
	ctx.r[4].s64 = ctx.r[11].s64 + -4468;
	// 825DE0B8: 488310B1  bl 0x82e0f168
	ctx.lr = 0x825DE0BC;
	sub_82E0F168(ctx, base);
	// 825DE0BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DE0C0: 4884CA41  bl 0x82e2ab00
	ctx.lr = 0x825DE0C4;
	sub_82E2AB00(ctx, base);
	// 825DE0C4: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE0C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DE0CC: 419A0008  beq cr6, 0x825de0d4
	if ctx.cr[6].eq {
	pc = 0x825DE0D4; continue 'dispatch;
	}
	// 825DE0D0: 4BCE27C1  bl 0x822c0890
	ctx.lr = 0x825DE0D4;
	sub_822C0890(ctx, base);
	// 825DE0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE0D8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825DE0DC: 48BCA0CC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE0E0 size=92
    let mut pc: u32 = 0x825DE0E0;
    'dispatch: loop {
        match pc {
            0x825DE0E0 => {
    //   block [0x825DE0E0..0x825DE13C)
	// 825DE0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE0E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE0EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE0F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE0F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE0F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE0FC: 4BFFFC75  bl 0x825ddd70
	ctx.lr = 0x825DE100;
	sub_825DDD70(ctx, base);
	// 825DE100: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE104: 4182001C  beq 0x825de120
	if ctx.cr[0].eq {
	pc = 0x825DE120; continue 'dispatch;
	}
	// 825DE108: 48AD6B41  bl 0x830b4c48
	ctx.lr = 0x825DE10C;
	sub_830B4C48(ctx, base);
	// 825DE10C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DE114: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DE118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DE11C: 4E800421  bctrl
	ctx.lr = 0x825DE120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DE120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE140 size=84
    let mut pc: u32 = 0x825DE140;
    'dispatch: loop {
        match pc {
            0x825DE140 => {
    //   block [0x825DE140..0x825DE194)
	// 825DE140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE14C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE154: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE158: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825DE15C: 396BEF28  addi r11, r11, -0x10d8
	ctx.r[11].s64 = ctx.r[11].s64 + -4312;
	// 825DE160: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DE164: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE168: 388A9BC9  addi r4, r10, -0x6437
	ctx.r[4].s64 = ctx.r[10].s64 + -25655;
	// 825DE16C: 4BCE775D  bl 0x822c58c8
	ctx.lr = 0x825DE170;
	sub_822C58C8(ctx, base);
	// 825DE170: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE178: 396BEF38  addi r11, r11, -0x10c8
	ctx.r[11].s64 = ctx.r[11].s64 + -4296;
	// 825DE17C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE180: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DE184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE18C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE198 size=100
    let mut pc: u32 = 0x825DE198;
    'dispatch: loop {
        match pc {
            0x825DE198 => {
    //   block [0x825DE198..0x825DE1FC)
	// 825DE198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE1A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE1B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE1B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE1B8: 396BEF28  addi r11, r11, -0x10d8
	ctx.r[11].s64 = ctx.r[11].s64 + -4312;
	// 825DE1BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DE1C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE1C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DE1C8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DE1CC: 4BCE6B15  bl 0x822c4ce0
	ctx.lr = 0x825DE1D0;
	sub_822C4CE0(ctx, base);
	// 825DE1D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE1D4: 4182000C  beq 0x825de1e0
	if ctx.cr[0].eq {
	pc = 0x825DE1E0; continue 'dispatch;
	}
	// 825DE1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE1DC: 4BCE208D  bl 0x822c0268
	ctx.lr = 0x825DE1E0;
	sub_822C0268(ctx, base);
	// 825DE1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE1F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE200 size=480
    let mut pc: u32 = 0x825DE200;
    'dispatch: loop {
        match pc {
            0x825DE200 => {
    //   block [0x825DE200..0x825DE3E0)
	// 825DE200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE204: 48BC9F69  bl 0x831a816c
	ctx.lr = 0x825DE208;
	sub_831A8130(ctx, base);
	// 825DE208: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 825DE20C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825DE210: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE214: 3FE08335  lis r31, -0x7ccb
	ctx.r[31].s64 = -2093678592;
	// 825DE218: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825DE21C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DE220: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 825DE224: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DE228: 3BCB7E34  addi r30, r11, 0x7e34
	ctx.r[30].s64 = ctx.r[11].s64 + 32308;
	// 825DE22C: 817F7E74  lwz r11, 0x7e74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32372 as u32) ) } as u64;
	// 825DE230: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DE234: 40820060  bne 0x825de294
	if !ctx.cr[0].eq {
	pc = 0x825DE294; continue 'dispatch;
	}
	// 825DE238: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE23C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825DE240: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE244: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE248: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DE24C: 917F7E74  stw r11, 0x7e74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32372 as u32), ctx.r[11].u32 ) };
	// 825DE250: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825DE254: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825DE258: 419A0024  beq cr6, 0x825de27c
	if ctx.cr[6].eq {
	pc = 0x825DE27C; continue 'dispatch;
	}
	// 825DE25C: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 825DE260: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DE264: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DE268: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DE26C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DE270: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DE274: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DE278: 4082FFE8  bne 0x825de260
	if !ctx.cr[0].eq {
	pc = 0x825DE260; continue 'dispatch;
	}
	// 825DE27C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DE284: 4BFFFC05  bl 0x825dde88
	ctx.lr = 0x825DE288;
	sub_825DDE88(ctx, base);
	// 825DE288: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 825DE28C: 386BF7C8  addi r3, r11, -0x838
	ctx.r[3].s64 = ctx.r[11].s64 + -2104;
	// 825DE290: 48BCA249  bl 0x831a84d8
	ctx.lr = 0x825DE294;
	sub_831A84D8(ctx, base);
	// 825DE294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE298: 48ADA859  bl 0x830b8af0
	ctx.lr = 0x825DE29C;
	sub_830B8AF0(ctx, base);
	// 825DE29C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DE2A0: 3BCB7E30  addi r30, r11, 0x7e30
	ctx.r[30].s64 = ctx.r[11].s64 + 32304;
	// 825DE2A4: 817F7E74  lwz r11, 0x7e74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32372 as u32) ) } as u64;
	// 825DE2A8: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DE2AC: 40820024  bne 0x825de2d0
	if !ctx.cr[0].eq {
	pc = 0x825DE2D0; continue 'dispatch;
	}
	// 825DE2B0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DE2B4: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 825DE2B8: 394AEDF0  addi r10, r10, -0x1210
	ctx.r[10].s64 = ctx.r[10].s64 + -4624;
	// 825DE2BC: 917F7E74  stw r11, 0x7e74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32372 as u32), ctx.r[11].u32 ) };
	// 825DE2C0: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 825DE2C4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DE2C8: 386BF7B0  addi r3, r11, -0x850
	ctx.r[3].s64 = ctx.r[11].s64 + -2128;
	// 825DE2CC: 48BCA20D  bl 0x831a84d8
	ctx.lr = 0x825DE2D0;
	sub_831A84D8(ctx, base);
	// 825DE2D0: 48AD6979  bl 0x830b4c48
	ctx.lr = 0x825DE2D4;
	sub_830B4C48(ctx, base);
	// 825DE2D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DE2D8: 4082000C  bne 0x825de2e4
	if !ctx.cr[0].eq {
	pc = 0x825DE2E4; continue 'dispatch;
	}
	// 825DE2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE2E0: 48AD6941  bl 0x830b4c20
	ctx.lr = 0x825DE2E4;
	sub_830B4C20(ctx, base);
	// 825DE2E4: 48ADA17D  bl 0x830b8460
	ctx.lr = 0x825DE2E8;
	sub_830B8460(ctx, base);
	// 825DE2E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DE2EC: 3BCB7E10  addi r30, r11, 0x7e10
	ctx.r[30].s64 = ctx.r[11].s64 + 32272;
	// 825DE2F0: 817F7E74  lwz r11, 0x7e74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32372 as u32) ) } as u64;
	// 825DE2F4: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DE2F8: 40820020  bne 0x825de318
	if !ctx.cr[0].eq {
	pc = 0x825DE318; continue 'dispatch;
	}
	// 825DE2FC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 825DE300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE304: 917F7E74  stw r11, 0x7e74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32372 as u32), ctx.r[11].u32 ) };
	// 825DE308: 4BFFFE39  bl 0x825de140
	ctx.lr = 0x825DE30C;
	sub_825DE140(ctx, base);
	// 825DE30C: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 825DE310: 386BF7D8  addi r3, r11, -0x828
	ctx.r[3].s64 = ctx.r[11].s64 + -2088;
	// 825DE314: 48BCA1C5  bl 0x831a84d8
	ctx.lr = 0x825DE318;
	sub_831A84D8(ctx, base);
	// 825DE318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE31C: 48ADA94D  bl 0x830b8c68
	ctx.lr = 0x825DE320;
	sub_830B8C68(ctx, base);
	// 825DE320: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825DE324: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825DE328: 48ADA049  bl 0x830b8370
	ctx.lr = 0x825DE32C;
	sub_830B8370(ctx, base);
	// 825DE32C: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 825DE330: 3D604E59  lis r11, 0x4e59
	ctx.r[11].s64 = 1314455552;
	// 825DE334: 3D208339  lis r9, -0x7cc7
	ctx.r[9].s64 = -2093416448;
	// 825DE338: 616B4946  ori r11, r11, 0x4946
	ctx.r[11].u64 = ctx.r[11].u64 | 18758;
	// 825DE33C: 3D008339  lis r8, -0x7cc7
	ctx.r[8].s64 = -2093416448;
	// 825DE340: 916ABD00  stw r11, -0x4300(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17152 as u32), ctx.r[11].u32 ) };
	// 825DE344: 3D604E45  lis r11, 0x4e45
	ctx.r[11].s64 = 1313144832;
	// 825DE348: 3D404E58  lis r10, 0x4e58
	ctx.r[10].s64 = 1314390016;
	// 825DE34C: 616B4E44  ori r11, r11, 0x4e44
	ctx.r[11].u64 = ctx.r[11].u64 | 20036;
	// 825DE350: 614A544C  ori r10, r10, 0x544c
	ctx.r[10].u64 = ctx.r[10].u64 | 21580;
	// 825DE354: 9169BD08  stw r11, -0x42f8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-17144 as u32), ctx.r[11].u32 ) };
	// 825DE358: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 825DE35C: 3D204E4F  lis r9, 0x4e4f
	ctx.r[9].s64 = 1313800192;
	// 825DE360: 9148BD10  stw r10, -0x42f0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-17136 as u32), ctx.r[10].u32 ) };
	// 825DE364: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825DE368: 61294630  ori r9, r9, 0x4630
	ctx.r[9].u64 = ctx.r[9].u64 | 17968;
	// 825DE36C: 3BCA7DFC  addi r30, r10, 0x7dfc
	ctx.r[30].s64 = ctx.r[10].s64 + 32252;
	// 825DE370: 912BBCF4  stw r9, -0x430c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17164 as u32), ctx.r[9].u32 ) };
	// 825DE374: 817F7E74  lwz r11, 0x7e74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32372 as u32) ) } as u64;
	// 825DE378: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DE37C: 4082003C  bne 0x825de3b8
	if !ctx.cr[0].eq {
	pc = 0x825DE3B8; continue 'dispatch;
	}
	// 825DE380: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 825DE384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE388: 917F7E74  stw r11, 0x7e74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32372 as u32), ctx.r[11].u32 ) };
	// 825DE38C: 4BFFF625  bl 0x825dd9b0
	ctx.lr = 0x825DE390;
	sub_825DD9B0(ctx, base);
	// 825DE390: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DE394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DE398: 394AEE70  addi r10, r10, -0x1190
	ctx.r[10].s64 = ctx.r[10].s64 + -4496;
	// 825DE39C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825DE3A0: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DE3A4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DE3A8: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 825DE3AC: 913E0010  stw r9, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 825DE3B0: 386BF7A0  addi r3, r11, -0x860
	ctx.r[3].s64 = ctx.r[11].s64 + -2144;
	// 825DE3B4: 48BCA125  bl 0x831a84d8
	ctx.lr = 0x825DE3B8;
	sub_831A84D8(ctx, base);
	// 825DE3B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE3BC: 48ADA64D  bl 0x830b8a08
	ctx.lr = 0x825DE3C0;
	sub_830B8A08(ctx, base);
	// 825DE3C0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE3C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DE3C8: 419A0008  beq cr6, 0x825de3d0
	if ctx.cr[6].eq {
	pc = 0x825DE3D0; continue 'dispatch;
	}
	// 825DE3CC: 4BCE24C5  bl 0x822c0890
	ctx.lr = 0x825DE3D0;
	sub_822C0890(ctx, base);
	// 825DE3D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DE3D4: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825DE3D8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825DE3DC: 48BC9DE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE3E0 size=112
    let mut pc: u32 = 0x825DE3E0;
    'dispatch: loop {
        match pc {
            0x825DE3E0 => {
    //   block [0x825DE3E0..0x825DE450)
	// 825DE3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE3E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE3EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE3F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE3F4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DE3F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE3FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE404: 388BD468  addi r4, r11, -0x2b98
	ctx.r[4].s64 = ctx.r[11].s64 + -11160;
	// 825DE408: 48815601  bl 0x82df3a08
	ctx.lr = 0x825DE40C;
	sub_82DF3A08(ctx, base);
	// 825DE40C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DE410: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DE414: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DE418: 480013E9  bl 0x825df800
	ctx.lr = 0x825DE41C;
	sub_825DF800(ctx, base);
	// 825DE41C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DE420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE424: 48824015  bl 0x82e02438
	ctx.lr = 0x825DE428;
	sub_82E02438(ctx, base);
	// 825DE428: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DE42C: 48814FFD  bl 0x82df3428
	ctx.lr = 0x825DE430;
	sub_82DF3428(ctx, base);
	// 825DE430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE434: 48814FF5  bl 0x82df3428
	ctx.lr = 0x825DE438;
	sub_82DF3428(ctx, base);
	// 825DE438: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE43C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE440: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE444: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE44C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE450 size=84
    let mut pc: u32 = 0x825DE450;
    'dispatch: loop {
        match pc {
            0x825DE450 => {
    //   block [0x825DE450..0x825DE4A4)
	// 825DE450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE45C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE468: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE46C: 48AD3A55  bl 0x830b1ec0
	ctx.lr = 0x825DE470;
	sub_830B1EC0(ctx, base);
	// 825DE470: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DE474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE478: 396BD3F0  addi r11, r11, -0x2c10
	ctx.r[11].s64 = ctx.r[11].s64 + -11280;
	// 825DE47C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DE480: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE484: 48AD3C2D  bl 0x830b20b0
	ctx.lr = 0x825DE488;
	sub_830B20B0(ctx, base);
	// 825DE488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE48C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE4A8 size=100
    let mut pc: u32 = 0x825DE4A8;
    'dispatch: loop {
        match pc {
            0x825DE4A8 => {
    //   block [0x825DE4A8..0x825DE50C)
	// 825DE4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE4B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE4BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE4C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE4C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DE4C8: 396BEF48  addi r11, r11, -0x10b8
	ctx.r[11].s64 = ctx.r[11].s64 + -4280;
	// 825DE4CC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DE4D0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825DE4D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE4D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE4DC: 48AD39FD  bl 0x830b1ed8
	ctx.lr = 0x825DE4E0;
	sub_830B1ED8(ctx, base);
	// 825DE4E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE4E4: 4182000C  beq 0x825de4f0
	if ctx.cr[0].eq {
	pc = 0x825DE4F0; continue 'dispatch;
	}
	// 825DE4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE4EC: 4BCE1D7D  bl 0x822c0268
	ctx.lr = 0x825DE4F0;
	sub_822C0268(ctx, base);
	// 825DE4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE4F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE4F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE4FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE500: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE510 size=112
    let mut pc: u32 = 0x825DE510;
    'dispatch: loop {
        match pc {
            0x825DE510 => {
    //   block [0x825DE510..0x825DE580)
	// 825DE510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE51C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE520: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 825DE524: 48AD3A05  bl 0x830b1f28
	ctx.lr = 0x825DE528;
	sub_830B1F28(ctx, base);
	// 825DE528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DE52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE530: 48AD6831  bl 0x830b4d60
	ctx.lr = 0x825DE534;
	sub_830B4D60(ctx, base);
	// 825DE534: 48AD39F5  bl 0x830b1f28
	ctx.lr = 0x825DE538;
	sub_830B1F28(ctx, base);
	// 825DE538: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE53C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE540: 48AD3999  bl 0x830b1ed8
	ctx.lr = 0x825DE544;
	sub_830B1ED8(ctx, base);
	// 825DE544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DE548: 419A0020  beq cr6, 0x825de568
	if ctx.cr[6].eq {
	pc = 0x825DE568; continue 'dispatch;
	}
	// 825DE54C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DE550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DE554: 419A0014  beq cr6, 0x825de568
	if ctx.cr[6].eq {
	pc = 0x825DE568; continue 'dispatch;
	}
	// 825DE558: 48820289  bl 0x82dfe7e0
	ctx.lr = 0x825DE55C;
	sub_82DFE7E0(ctx, base);
	// 825DE55C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825DE564: 41820008  beq 0x825de56c
	if ctx.cr[0].eq {
	pc = 0x825DE56C; continue 'dispatch;
	}
	// 825DE568: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825DE56C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE578: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE57C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE580 size=128
    let mut pc: u32 = 0x825DE580;
    'dispatch: loop {
        match pc {
            0x825DE580 => {
    //   block [0x825DE580..0x825DE600)
	// 825DE580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE584: 48BC9BE9  bl 0x831a816c
	ctx.lr = 0x825DE588;
	sub_831A8130(ctx, base);
	// 825DE588: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE58C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE590: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DE594: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 825DE598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE59C: 48AD39E5  bl 0x830b1f80
	ctx.lr = 0x825DE5A0;
	sub_830B1F80(ctx, base);
	// 825DE5A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DE5A4: 4082000C  bne 0x825de5b0
	if !ctx.cr[0].eq {
	pc = 0x825DE5B0; continue 'dispatch;
	}
	// 825DE5A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825DE5AC: 4800004C  b 0x825de5f8
	pc = 0x825DE5F8; continue 'dispatch;
	// 825DE5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE5B4: 4882022D  bl 0x82dfe7e0
	ctx.lr = 0x825DE5B8;
	sub_82DFE7E0(ctx, base);
	// 825DE5B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE5BC: 4182FFEC  beq 0x825de5a8
	if ctx.cr[0].eq {
	pc = 0x825DE5A8; continue 'dispatch;
	}
	// 825DE5C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE5C4: 48AD3965  bl 0x830b1f28
	ctx.lr = 0x825DE5C8;
	sub_830B1F28(ctx, base);
	// 825DE5C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DE5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE5D0: 48AD6791  bl 0x830b4d60
	ctx.lr = 0x825DE5D4;
	sub_830B4D60(ctx, base);
	// 825DE5D4: 48AD3955  bl 0x830b1f28
	ctx.lr = 0x825DE5D8;
	sub_830B1F28(ctx, base);
	// 825DE5D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE5E0: 48AD38F9  bl 0x830b1ed8
	ctx.lr = 0x825DE5E4;
	sub_830B1ED8(ctx, base);
	// 825DE5E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DE5E8: 419AFFC0  beq cr6, 0x825de5a8
	if ctx.cr[6].eq {
	pc = 0x825DE5A8; continue 'dispatch;
	}
	// 825DE5EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DE5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE5F4: 48000CD5  bl 0x825df2c8
	ctx.lr = 0x825DE5F8;
	sub_825DF2C8(ctx, base);
	// 825DE5F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DE5FC: 48BC9BC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE600 size=120
    let mut pc: u32 = 0x825DE600;
    'dispatch: loop {
        match pc {
            0x825DE600 => {
    //   block [0x825DE600..0x825DE678)
	// 825DE600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE618: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE61C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 825DE620: 396BEF48  addi r11, r11, -0x10b8
	ctx.r[11].s64 = ctx.r[11].s64 + -4280;
	// 825DE624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE628: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE62C: 48AD3895  bl 0x830b1ec0
	ctx.lr = 0x825DE630;
	sub_830B1EC0(ctx, base);
	// 825DE630: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE638: 396BEDD8  addi r11, r11, -0x1228
	ctx.r[11].s64 = ctx.r[11].s64 + -4648;
	// 825DE63C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DE640: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DE644: 48AD3955  bl 0x830b1f98
	ctx.lr = 0x825DE648;
	sub_830B1F98(ctx, base);
	// 825DE648: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DE64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE650: 48AD3A61  bl 0x830b20b0
	ctx.lr = 0x825DE654;
	sub_830B20B0(ctx, base);
	// 825DE654: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DE658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE65C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DE660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE66C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE678 size=148
    let mut pc: u32 = 0x825DE678;
    'dispatch: loop {
        match pc {
            0x825DE678 => {
    //   block [0x825DE678..0x825DE70C)
	// 825DE678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE67C: 48BC9AF1  bl 0x831a816c
	ctx.lr = 0x825DE680;
	sub_831A8130(ctx, base);
	// 825DE680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE688: 48820111  bl 0x82dfe798
	ctx.lr = 0x825DE68C;
	sub_82DFE798(ctx, base);
	// 825DE68C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE690: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 825DE694: 396BEF54  addi r11, r11, -0x10ac
	ctx.r[11].s64 = ctx.r[11].s64 + -4268;
	// 825DE698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE69C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE6A0: 48AD3821  bl 0x830b1ec0
	ctx.lr = 0x825DE6A4;
	sub_830B1EC0(ctx, base);
	// 825DE6A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DE6A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DE6AC: 396BD3F0  addi r11, r11, -0x2c10
	ctx.r[11].s64 = ctx.r[11].s64 + -11280;
	// 825DE6B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE6B4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DE6B8: 48AD38E1  bl 0x830b1f98
	ctx.lr = 0x825DE6BC;
	sub_830B1F98(ctx, base);
	// 825DE6BC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DE6C0: 806B16D4  lwz r3, 0x16d4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5844 as u32) ) } as u64;
	// 825DE6C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE6C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE6CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DE6D0: 4E800421  bctrl
	ctx.lr = 0x825DE6D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DE6D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DE6D8: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 825DE6DC: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 825DE6E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DE6E4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 825DE6E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE6EC: 4BCF0DF5  bl 0x822cf4e0
	ctx.lr = 0x825DE6F0;
	sub_822CF4E0(ctx, base);
	// 825DE6F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DE6F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DE6F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE6FC: 4BCE1905  bl 0x822c0000
	ctx.lr = 0x825DE700;
	sub_822C0000(ctx, base);
	// 825DE700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE708: 48BC9AB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE710 size=84
    let mut pc: u32 = 0x825DE710;
    'dispatch: loop {
        match pc {
            0x825DE710 => {
    //   block [0x825DE710..0x825DE764)
	// 825DE710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE71C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE720: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE724: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DE728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DE72C: 419A0008  beq cr6, 0x825de734
	if ctx.cr[6].eq {
	pc = 0x825DE734; continue 'dispatch;
	}
	// 825DE730: 4BCE2161  bl 0x822c0890
	ctx.lr = 0x825DE734;
	sub_822C0890(ctx, base);
	// 825DE734: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825DE738: 48AD37A1  bl 0x830b1ed8
	ctx.lr = 0x825DE73C;
	sub_830B1ED8(ctx, base);
	// 825DE73C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DE740: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DE744: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 825DE748: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE74C: 48814CDD  bl 0x82df3428
	ctx.lr = 0x825DE750;
	sub_82DF3428(ctx, base);
	// 825DE750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DE754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE75C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE768 size=76
    let mut pc: u32 = 0x825DE768;
    'dispatch: loop {
        match pc {
            0x825DE768 => {
    //   block [0x825DE768..0x825DE7B4)
	// 825DE768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE784: 4BFFFF8D  bl 0x825de710
	ctx.lr = 0x825DE788;
	sub_825DE710(ctx, base);
	// 825DE788: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE78C: 4182000C  beq 0x825de798
	if ctx.cr[0].eq {
	pc = 0x825DE798; continue 'dispatch;
	}
	// 825DE790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE794: 48813C45  bl 0x82df23d8
	ctx.lr = 0x825DE798;
	sub_82DF23D8(ctx, base);
	// 825DE798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE79C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE7A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE7AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE7B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE7B8 size=100
    let mut pc: u32 = 0x825DE7B8;
    'dispatch: loop {
        match pc {
            0x825DE7B8 => {
    //   block [0x825DE7B8..0x825DE81C)
	// 825DE7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE7BC: 48BC99B1  bl 0x831a816c
	ctx.lr = 0x825DE7C0;
	sub_831A8130(ctx, base);
	// 825DE7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE7C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DE7C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DE7CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE7D0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE7D4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE7D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE7DC: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DE7E0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE7E4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DE7E8: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DE7EC: 419A0028  beq cr6, 0x825de814
	if ctx.cr[6].eq {
	pc = 0x825DE814; continue 'dispatch;
	}
	// 825DE7F0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DE7F4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE7F8: 48AD36E1  bl 0x830b1ed8
	ctx.lr = 0x825DE7FC;
	sub_830B1ED8(ctx, base);
	// 825DE7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE800: 4BCE1A69  bl 0x822c0268
	ctx.lr = 0x825DE804;
	sub_822C0268(ctx, base);
	// 825DE804: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE808: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825DE80C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DE810: 409AFFE0  bne cr6, 0x825de7f0
	if !ctx.cr[6].eq {
	pc = 0x825DE7F0; continue 'dispatch;
	}
	// 825DE814: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE818: 48BC99A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE820 size=144
    let mut pc: u32 = 0x825DE820;
    'dispatch: loop {
        match pc {
            0x825DE820 => {
    //   block [0x825DE820..0x825DE8B0)
	// 825DE820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE82C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE838: 4BFFFDC9  bl 0x825de600
	ctx.lr = 0x825DE83C;
	sub_825DE600(ctx, base);
	// 825DE83C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE840: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 825DE844: 396BEF60  addi r11, r11, -0x10a0
	ctx.r[11].s64 = ctx.r[11].s64 + -4256;
	// 825DE848: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE84C: 4BE3FFBD  bl 0x8241e808
	ctx.lr = 0x825DE850;
	sub_8241E808(ctx, base);
	// 825DE850: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825DE854: 4BE3FFB5  bl 0x8241e808
	ctx.lr = 0x825DE858;
	sub_8241E808(ctx, base);
	// 825DE858: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 825DE85C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE860: 48AD3661  bl 0x830b1ec0
	ctx.lr = 0x825DE864;
	sub_830B1EC0(ctx, base);
	// 825DE864: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DE868: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DE86C: 396BE544  addi r11, r11, -0x1abc
	ctx.r[11].s64 = ctx.r[11].s64 + -6844;
	// 825DE870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE874: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825DE878: 48AD3721  bl 0x830b1f98
	ctx.lr = 0x825DE87C;
	sub_830B1F98(ctx, base);
	// 825DE87C: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825DE880: 4BE40239  bl 0x8241eab8
	ctx.lr = 0x825DE884;
	sub_8241EAB8(ctx, base);
	// 825DE884: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 825DE888: 4BE40231  bl 0x8241eab8
	ctx.lr = 0x825DE88C;
	sub_8241EAB8(ctx, base);
	// 825DE88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE890: 48AD6411  bl 0x830b4ca0
	ctx.lr = 0x825DE894;
	sub_830B4CA0(ctx, base);
	// 825DE894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE898: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE89C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE8A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE8A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE8A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE8AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE8B0 size=92
    let mut pc: u32 = 0x825DE8B0;
    'dispatch: loop {
        match pc {
            0x825DE8B0 => {
    //   block [0x825DE8B0..0x825DE90C)
	// 825DE8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DE8B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DE8BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DE8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE8C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE8C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE8CC: 48AD779D  bl 0x830b6068
	ctx.lr = 0x825DE8D0;
	sub_830B6068(ctx, base);
	// 825DE8D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE8D4: 4182001C  beq 0x825de8f0
	if ctx.cr[0].eq {
	pc = 0x825DE8F0; continue 'dispatch;
	}
	// 825DE8D8: 48AD6371  bl 0x830b4c48
	ctx.lr = 0x825DE8DC;
	sub_830B4C48(ctx, base);
	// 825DE8DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE8E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DE8E4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DE8E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DE8EC: 4E800421  bctrl
	ctx.lr = 0x825DE8F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DE8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE8F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE8F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DE8FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DE900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DE904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE910 size=136
    let mut pc: u32 = 0x825DE910;
    'dispatch: loop {
        match pc {
            0x825DE910 => {
    //   block [0x825DE910..0x825DE998)
	// 825DE910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE914: 48BC9859  bl 0x831a816c
	ctx.lr = 0x825DE918;
	sub_831A8130(ctx, base);
	// 825DE918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE91C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE920: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DE924: 4BFFFCDD  bl 0x825de600
	ctx.lr = 0x825DE928;
	sub_825DE600(ctx, base);
	// 825DE928: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE92C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 825DE930: 396BEF60  addi r11, r11, -0x10a0
	ctx.r[11].s64 = ctx.r[11].s64 + -4256;
	// 825DE934: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DE938: 4BE3FED1  bl 0x8241e808
	ctx.lr = 0x825DE93C;
	sub_8241E808(ctx, base);
	// 825DE93C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825DE940: 4BE3FEC9  bl 0x8241e808
	ctx.lr = 0x825DE944;
	sub_8241E808(ctx, base);
	// 825DE944: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 825DE948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE94C: 48AD3575  bl 0x830b1ec0
	ctx.lr = 0x825DE950;
	sub_830B1EC0(ctx, base);
	// 825DE950: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DE954: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DE958: 396BE544  addi r11, r11, -0x1abc
	ctx.r[11].s64 = ctx.r[11].s64 + -6844;
	// 825DE95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DE960: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825DE964: 48AD3635  bl 0x830b1f98
	ctx.lr = 0x825DE968;
	sub_830B1F98(ctx, base);
	// 825DE968: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825DE96C: 4BE4014D  bl 0x8241eab8
	ctx.lr = 0x825DE970;
	sub_8241EAB8(ctx, base);
	// 825DE970: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 825DE974: 4BE40145  bl 0x8241eab8
	ctx.lr = 0x825DE978;
	sub_8241EAB8(ctx, base);
	// 825DE978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE97C: 48AD6325  bl 0x830b4ca0
	ctx.lr = 0x825DE980;
	sub_830B4CA0(ctx, base);
	// 825DE980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE984: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DE988: 48AD6851  bl 0x830b51d8
	ctx.lr = 0x825DE98C;
	sub_830B51D8(ctx, base);
	// 825DE98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DE990: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DE994: 48BC9828  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE998 size=212
    let mut pc: u32 = 0x825DE998;
    'dispatch: loop {
        match pc {
            0x825DE998 => {
    //   block [0x825DE998..0x825DEA6C)
	// 825DE998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE99C: 48BC97D1  bl 0x831a816c
	ctx.lr = 0x825DE9A0;
	sub_831A8130(ctx, base);
	// 825DE9A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE9A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DE9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE9AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DE9B0: 80860000  lwz r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE9B4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DE9B8: 483364B9  bl 0x82914e70
	ctx.lr = 0x825DE9BC;
	sub_82914E70(ctx, base);
	// 825DE9BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DE9C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DE9C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DE9C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DE9CC: 4BFFEAAD  bl 0x825dd478
	ctx.lr = 0x825DE9D0;
	sub_825DD478(ctx, base);
	// 825DE9D0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DE9D4: 4881FE95  bl 0x82dfe868
	ctx.lr = 0x825DE9D8;
	sub_82DFE868(ctx, base);
	// 825DE9D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE9DC: 40820078  bne 0x825dea54
	if !ctx.cr[0].eq {
	pc = 0x825DEA54; continue 'dispatch;
	}
	// 825DE9E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DE9E4: 419A0070  beq cr6, 0x825dea54
	if ctx.cr[6].eq {
	pc = 0x825DEA54; continue 'dispatch;
	}
	// 825DE9E8: 48AD6261  bl 0x830b4c48
	ctx.lr = 0x825DE9EC;
	sub_830B4C48(ctx, base);
	// 825DE9EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DE9F0: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 825DE9F4: 38ABEF68  addi r5, r11, -0x1098
	ctx.r[5].s64 = ctx.r[11].s64 + -4248;
	// 825DE9F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE9FC: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 825DEA00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DEA04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DEA08: 4E800421  bctrl
	ctx.lr = 0x825DEA0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DEA0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DEA10: 41820010  beq 0x825dea20
	if ctx.cr[0].eq {
	pc = 0x825DEA20; continue 'dispatch;
	}
	// 825DEA14: 4BFFFE0D  bl 0x825de820
	ctx.lr = 0x825DEA18;
	sub_825DE820(ctx, base);
	// 825DEA18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DEA1C: 48000008  b 0x825dea24
	pc = 0x825DEA24; continue 'dispatch;
	// 825DEA20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DEA24: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DEA28: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825DEA2C: 48AD3685  bl 0x830b20b0
	ctx.lr = 0x825DEA30;
	sub_830B20B0(ctx, base);
	// 825DEA30: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DEA34: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825DEA38: 48AD34F1  bl 0x830b1f28
	ctx.lr = 0x825DEA3C;
	sub_830B1F28(ctx, base);
	// 825DEA3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DEA40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DEA44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DEA48: 48AD6BE1  bl 0x830b5628
	ctx.lr = 0x825DEA4C;
	sub_830B5628(ctx, base);
	// 825DEA4C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DEA50: 4881FE09  bl 0x82dfe858
	ctx.lr = 0x825DEA54;
	sub_82DFE858(ctx, base);
	// 825DEA54: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DEA58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DEA5C: 419A0008  beq cr6, 0x825dea64
	if ctx.cr[6].eq {
	pc = 0x825DEA64; continue 'dispatch;
	}
	// 825DEA60: 4BCE1E31  bl 0x822c0890
	ctx.lr = 0x825DEA64;
	sub_822C0890(ctx, base);
	// 825DEA64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DEA68: 48BC9754  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEA70 size=208
    let mut pc: u32 = 0x825DEA70;
    'dispatch: loop {
        match pc {
            0x825DEA70 => {
    //   block [0x825DEA70..0x825DEB40)
	// 825DEA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEA74: 48BC96F9  bl 0x831a816c
	ctx.lr = 0x825DEA78;
	sub_831A8130(ctx, base);
	// 825DEA78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEA7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DEA80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DEA84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DEA88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DEA8C: 3BCBEF68  addi r30, r11, -0x1098
	ctx.r[30].s64 = ctx.r[11].s64 + -4248;
	// 825DEA90: 419A0038  beq cr6, 0x825deac8
	if ctx.cr[6].eq {
	pc = 0x825DEAC8; continue 'dispatch;
	}
	// 825DEA94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DEA98: 4881FD49  bl 0x82dfe7e0
	ctx.lr = 0x825DEA9C;
	sub_82DFE7E0(ctx, base);
	// 825DEA9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DEAA0: 40820028  bne 0x825deac8
	if !ctx.cr[0].eq {
	pc = 0x825DEAC8; continue 'dispatch;
	}
	// 825DEAA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DEAA8: 4BF0BFE1  bl 0x824eaa88
	ctx.lr = 0x825DEAAC;
	sub_824EAA88(ctx, base);
	// 825DEAAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DEAB0: 38C00051  li r6, 0x51
	ctx.r[6].s64 = 81;
	// 825DEAB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEAB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DEABC: 4BD198C5  bl 0x822f8380
	ctx.lr = 0x825DEAC0;
	sub_822F8380(ctx, base);
	// 825DEAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DEAC4: 488131CD  bl 0x82df1c90
	ctx.lr = 0x825DEAC8;
	sub_82DF1C90(ctx, base);
	// 825DEAC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DEACC: 38C00053  li r6, 0x53
	ctx.r[6].s64 = 83;
	// 825DEAD0: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 825DEAD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DEAD8: 4881AD61  bl 0x82df9838
	ctx.lr = 0x825DEADC;
	sub_82DF9838(ctx, base);
	// 825DEADC: 48AD616D  bl 0x830b4c48
	ctx.lr = 0x825DEAE0;
	sub_830B4C48(ctx, base);
	// 825DEAE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEAE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DEAE8: 38C00054  li r6, 0x54
	ctx.r[6].s64 = 84;
	// 825DEAEC: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 825DEAF0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DEAF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DEAF8: 4E800421  bctrl
	ctx.lr = 0x825DEAFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DEAFC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825DEB00: 41820020  beq 0x825deb20
	if ctx.cr[0].eq {
	pc = 0x825DEB20; continue 'dispatch;
	}
	// 825DEB04: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825DEB08: 48AD3421  bl 0x830b1f28
	ctx.lr = 0x825DEB0C;
	sub_830B1F28(ctx, base);
	// 825DEB0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DEB10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DEB14: 4BFFFDFD  bl 0x825de910
	ctx.lr = 0x825DEB18;
	sub_825DE910(ctx, base);
	// 825DEB18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DEB1C: 48000008  b 0x825deb24
	pc = 0x825DEB24; continue 'dispatch;
	// 825DEB20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DEB24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DEB28: 4BFFF929  bl 0x825de450
	ctx.lr = 0x825DEB2C;
	sub_825DE450(ctx, base);
	// 825DEB2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DEB30: 4BCF0AD1  bl 0x822cf600
	ctx.lr = 0x825DEB34;
	sub_822CF600(ctx, base);
	// 825DEB34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DEB38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DEB3C: 48BC9680  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEB40 size=84
    let mut pc: u32 = 0x825DEB40;
    'dispatch: loop {
        match pc {
            0x825DEB40 => {
    //   block [0x825DEB40..0x825DEB94)
	// 825DEB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DEB48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DEB4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DEB50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DEB58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DEB5C: 48AD3365  bl 0x830b1ec0
	ctx.lr = 0x825DEB60;
	sub_830B1EC0(ctx, base);
	// 825DEB60: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DEB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DEB68: 396BE544  addi r11, r11, -0x1abc
	ctx.r[11].s64 = ctx.r[11].s64 + -6844;
	// 825DEB6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DEB70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEB74: 48AD353D  bl 0x830b20b0
	ctx.lr = 0x825DEB78;
	sub_830B20B0(ctx, base);
	// 825DEB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DEB7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DEB80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DEB84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DEB88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DEB8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DEB90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEB98 size=152
    let mut pc: u32 = 0x825DEB98;
    'dispatch: loop {
        match pc {
            0x825DEB98 => {
    //   block [0x825DEB98..0x825DEC30)
	// 825DEB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DEBA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DEBA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DEBA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DEBB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DEBB4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DEBB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DEBBC: 419A005C  beq cr6, 0x825dec18
	if ctx.cr[6].eq {
	pc = 0x825DEC18; continue 'dispatch;
	}
	// 825DEBC0: 4881FC21  bl 0x82dfe7e0
	ctx.lr = 0x825DEBC4;
	sub_82DFE7E0(ctx, base);
	// 825DEBC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DEBC8: 41820050  beq 0x825dec18
	if ctx.cr[0].eq {
	pc = 0x825DEC18; continue 'dispatch;
	}
	// 825DEBCC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DEBD0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DEBD4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DEBD8: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825DEBDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825DEBE0: 419A0038  beq cr6, 0x825dec18
	if ctx.cr[6].eq {
	pc = 0x825DEC18; continue 'dispatch;
	}
	// 825DEBE4: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DEBE8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DEBEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DEBF0: 419A0028  beq cr6, 0x825dec18
	if ctx.cr[6].eq {
	pc = 0x825DEC18; continue 'dispatch;
	}
	// 825DEBF4: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825DEBF8: 48AD9F09  bl 0x830b8b00
	ctx.lr = 0x825DEBFC;
	sub_830B8B00(ctx, base);
	// 825DEBFC: 482211F5  bl 0x827ffdf0
	ctx.lr = 0x825DEC00;
	sub_827FFDF0(ctx, base);
	// 825DEC00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DEC04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DEC08: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DEC0C: 64C68000  oris r6, r6, 0x8000
	ctx.r[6].u64 = ctx.r[6].u64 | 2147483648;
	// 825DEC10: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEC14: 486031F5  bl 0x82be1e08
	ctx.lr = 0x825DEC18;
	sub_82BE1E08(ctx, base);
	// 825DEC18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DEC1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DEC20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DEC24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DEC28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DEC2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEC30 size=128
    let mut pc: u32 = 0x825DEC30;
    'dispatch: loop {
        match pc {
            0x825DEC30 => {
    //   block [0x825DEC30..0x825DECB0)
	// 825DEC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEC34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DEC38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEC3C: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 825DEC40: 41980030  blt cr6, 0x825dec70
	if ctx.cr[6].lt {
	pc = 0x825DEC70; continue 'dispatch;
	}
	// 825DEC44: 409A005C  bne cr6, 0x825deca0
	if !ctx.cr[6].eq {
	pc = 0x825DECA0; continue 'dispatch;
	}
	// 825DEC48: 48AD9EB9  bl 0x830b8b00
	ctx.lr = 0x825DEC4C;
	sub_830B8B00(ctx, base);
	// 825DEC4C: 482211A5  bl 0x827ffdf0
	ctx.lr = 0x825DEC50;
	sub_827FFDF0(ctx, base);
	// 825DEC50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DEC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DEC58: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEC5C: 485F60C5  bl 0x82bd4d20
	ctx.lr = 0x825DEC60;
	sub_82BD4D20(ctx, base);
	// 825DEC60: 48AD9EA1  bl 0x830b8b00
	ctx.lr = 0x825DEC64;
	sub_830B8B00(ctx, base);
	// 825DEC64: 4822118D  bl 0x827ffdf0
	ctx.lr = 0x825DEC68;
	sub_827FFDF0(ctx, base);
	// 825DEC68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DEC6C: 48000028  b 0x825dec94
	pc = 0x825DEC94; continue 'dispatch;
	// 825DEC70: 48AD9E91  bl 0x830b8b00
	ctx.lr = 0x825DEC74;
	sub_830B8B00(ctx, base);
	// 825DEC74: 4822117D  bl 0x827ffdf0
	ctx.lr = 0x825DEC78;
	sub_827FFDF0(ctx, base);
	// 825DEC78: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DEC7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DEC80: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEC84: 485F609D  bl 0x82bd4d20
	ctx.lr = 0x825DEC88;
	sub_82BD4D20(ctx, base);
	// 825DEC88: 48AD9E79  bl 0x830b8b00
	ctx.lr = 0x825DEC8C;
	sub_830B8B00(ctx, base);
	// 825DEC8C: 48221165  bl 0x827ffdf0
	ctx.lr = 0x825DEC90;
	sub_827FFDF0(ctx, base);
	// 825DEC90: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DEC94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DEC98: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEC9C: 485F5EDD  bl 0x82bd4b78
	ctx.lr = 0x825DECA0;
	sub_82BD4B78(ctx, base);
	// 825DECA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DECA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DECA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DECAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DECB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DECB0 size=196
    let mut pc: u32 = 0x825DECB0;
    'dispatch: loop {
        match pc {
            0x825DECB0 => {
    //   block [0x825DECB0..0x825DED74)
	// 825DECB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DECB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DECB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DECBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DECC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DECC4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DECC8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825DECCC: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 825DECD0: 41980020  blt cr6, 0x825decf0
	if ctx.cr[6].lt {
	pc = 0x825DECF0; continue 'dispatch;
	}
	// 825DECD4: 409A0040  bne cr6, 0x825ded14
	if !ctx.cr[6].eq {
	pc = 0x825DED14; continue 'dispatch;
	}
	// 825DECD8: 48AD9E29  bl 0x830b8b00
	ctx.lr = 0x825DECDC;
	sub_830B8B00(ctx, base);
	// 825DECDC: 48221115  bl 0x827ffdf0
	ctx.lr = 0x825DECE0;
	sub_827FFDF0(ctx, base);
	// 825DECE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DECE4: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 825DECE8: 53CA5CEA  rlwimi r10, r30, 0xb, 0x13, 0x15
	ctx.r[10].u64 = (((ctx.r[30].u32).rotate_left(11) as u64) & 0x0000000000001C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE3FF);
	// 825DECEC: 48000018  b 0x825ded04
	pc = 0x825DED04; continue 'dispatch;
	// 825DECF0: 48AD9E11  bl 0x830b8b00
	ctx.lr = 0x825DECF4;
	sub_830B8B00(ctx, base);
	// 825DECF4: 482210FD  bl 0x827ffdf0
	ctx.lr = 0x825DECF8;
	sub_827FFDF0(ctx, base);
	// 825DECF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DECFC: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 825DED00: 554A05A4  rlwinm r10, r10, 0, 0x16, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825DED04: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 825DED08: E94B0018  ld r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 825DED0C: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 825DED10: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 825DED14: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 825DED18: 41980020  blt cr6, 0x825ded38
	if ctx.cr[6].lt {
	pc = 0x825DED38; continue 'dispatch;
	}
	// 825DED1C: 409A0040  bne cr6, 0x825ded5c
	if !ctx.cr[6].eq {
	pc = 0x825DED5C; continue 'dispatch;
	}
	// 825DED20: 48AD9DE1  bl 0x830b8b00
	ctx.lr = 0x825DED24;
	sub_830B8B00(ctx, base);
	// 825DED24: 482210CD  bl 0x827ffdf0
	ctx.lr = 0x825DED28;
	sub_827FFDF0(ctx, base);
	// 825DED28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DED2C: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 825DED30: 53CA7424  rlwimi r10, r30, 0xe, 0x10, 0x12
	ctx.r[10].u64 = (((ctx.r[30].u32).rotate_left(14) as u64) & 0x000000000000E000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF1FFF);
	// 825DED34: 48000018  b 0x825ded4c
	pc = 0x825DED4C; continue 'dispatch;
	// 825DED38: 48AD9DC9  bl 0x830b8b00
	ctx.lr = 0x825DED3C;
	sub_830B8B00(ctx, base);
	// 825DED3C: 482210B5  bl 0x827ffdf0
	ctx.lr = 0x825DED40;
	sub_827FFDF0(ctx, base);
	// 825DED40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DED44: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 825DED48: 554A04DE  rlwinm r10, r10, 0, 0x13, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825DED4C: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 825DED50: E94B0018  ld r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 825DED54: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 825DED58: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 825DED5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DED60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DED64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DED68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DED6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DED70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DED78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DED78 size=196
    let mut pc: u32 = 0x825DED78;
    'dispatch: loop {
        match pc {
            0x825DED78 => {
    //   block [0x825DED78..0x825DEE3C)
	// 825DED78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DED7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DED80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DED84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DED88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DED8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DED90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DED94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DED98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DED9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEDA0: 4BCE1B99  bl 0x822c0938
	ctx.lr = 0x825DEDA4;
	sub_822C0938(ctx, base);
	// 825DEDA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DEDA8: 41820028  beq 0x825dedd0
	if ctx.cr[0].eq {
	pc = 0x825DEDD0; continue 'dispatch;
	}
	// 825DEDAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DEDB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825DEDB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DEDB8: 392BEFA4  addi r9, r11, -0x105c
	ctx.r[9].s64 = ctx.r[11].s64 + -4188;
	// 825DEDBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DEDC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DEDC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DEDC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DEDCC: 48000008  b 0x825dedd4
	pc = 0x825DEDD4; continue 'dispatch;
	// 825DEDD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DEDD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DEDDC: 409A0044  bne cr6, 0x825dee20
	if !ctx.cr[6].eq {
	pc = 0x825DEE20; continue 'dispatch;
	}
	// 825DEDE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DEDE4: 419A001C  beq cr6, 0x825dee00
	if ctx.cr[6].eq {
	pc = 0x825DEE00; continue 'dispatch;
	}
	// 825DEDE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEDEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DEDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DEDF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEDF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DEDFC: 4E800421  bctrl
	ctx.lr = 0x825DEE00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DEE00: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DEE04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DEE08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DEE0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825DEE10: 816BD370  lwz r11, -0x2c90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11408 as u32) ) } as u64;
	// 825DEE14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DEE18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DEE1C: 4BCE11E5  bl 0x822c0000
	ctx.lr = 0x825DEE20;
	sub_822C0000(ctx, base);
	// 825DEE20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DEE24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DEE28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DEE2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DEE30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DEE34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DEE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEE40 size=196
    let mut pc: u32 = 0x825DEE40;
    'dispatch: loop {
        match pc {
            0x825DEE40 => {
    //   block [0x825DEE40..0x825DEF04)
	// 825DEE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DEE48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DEE4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DEE50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEE54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DEE58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DEE5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DEE60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DEE64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEE68: 4BCE1AD1  bl 0x822c0938
	ctx.lr = 0x825DEE6C;
	sub_822C0938(ctx, base);
	// 825DEE6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DEE70: 41820028  beq 0x825dee98
	if ctx.cr[0].eq {
	pc = 0x825DEE98; continue 'dispatch;
	}
	// 825DEE74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DEE78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825DEE7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DEE80: 392BEFB8  addi r9, r11, -0x1048
	ctx.r[9].s64 = ctx.r[11].s64 + -4168;
	// 825DEE84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DEE88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DEE8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DEE90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DEE94: 48000008  b 0x825dee9c
	pc = 0x825DEE9C; continue 'dispatch;
	// 825DEE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DEE9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEEA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DEEA4: 409A0044  bne cr6, 0x825deee8
	if !ctx.cr[6].eq {
	pc = 0x825DEEE8; continue 'dispatch;
	}
	// 825DEEA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DEEAC: 419A001C  beq cr6, 0x825deec8
	if ctx.cr[6].eq {
	pc = 0x825DEEC8; continue 'dispatch;
	}
	// 825DEEB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEEB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DEEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DEEBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEEC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DEEC4: 4E800421  bctrl
	ctx.lr = 0x825DEEC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DEEC8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DEECC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DEED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DEED4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825DEED8: 816BD370  lwz r11, -0x2c90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11408 as u32) ) } as u64;
	// 825DEEDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DEEE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DEEE4: 4BCE111D  bl 0x822c0000
	ctx.lr = 0x825DEEE8;
	sub_822C0000(ctx, base);
	// 825DEEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DEEEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DEEF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DEEF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DEEF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DEEFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DEF00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEF08 size=196
    let mut pc: u32 = 0x825DEF08;
    'dispatch: loop {
        match pc {
            0x825DEF08 => {
    //   block [0x825DEF08..0x825DEFCC)
	// 825DEF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEF0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DEF10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DEF14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DEF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEF1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DEF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DEF24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DEF28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DEF2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEF30: 4BCE1A09  bl 0x822c0938
	ctx.lr = 0x825DEF34;
	sub_822C0938(ctx, base);
	// 825DEF34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DEF38: 41820028  beq 0x825def60
	if ctx.cr[0].eq {
	pc = 0x825DEF60; continue 'dispatch;
	}
	// 825DEF3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DEF40: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825DEF44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DEF48: 392BEFCC  addi r9, r11, -0x1034
	ctx.r[9].s64 = ctx.r[11].s64 + -4148;
	// 825DEF4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DEF50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DEF54: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DEF58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DEF5C: 48000008  b 0x825def64
	pc = 0x825DEF64; continue 'dispatch;
	// 825DEF60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DEF64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DEF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DEF6C: 409A0044  bne cr6, 0x825defb0
	if !ctx.cr[6].eq {
	pc = 0x825DEFB0; continue 'dispatch;
	}
	// 825DEF70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DEF74: 419A001C  beq cr6, 0x825def90
	if ctx.cr[6].eq {
	pc = 0x825DEF90; continue 'dispatch;
	}
	// 825DEF78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEF7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DEF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DEF84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEF88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DEF8C: 4E800421  bctrl
	ctx.lr = 0x825DEF90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DEF90: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DEF94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DEF98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DEF9C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825DEFA0: 816BD370  lwz r11, -0x2c90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11408 as u32) ) } as u64;
	// 825DEFA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DEFA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DEFAC: 4BCE1055  bl 0x822c0000
	ctx.lr = 0x825DEFB0;
	sub_822C0000(ctx, base);
	// 825DEFB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DEFB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DEFB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DEFBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DEFC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DEFC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DEFC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DEFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DEFD0 size=132
    let mut pc: u32 = 0x825DEFD0;
    'dispatch: loop {
        match pc {
            0x825DEFD0 => {
    //   block [0x825DEFD0..0x825DF054)
	// 825DEFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DEFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DEFD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DEFDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DEFE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DEFE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DEFE8: 396B7E78  addi r11, r11, 0x7e78
	ctx.r[11].s64 = ctx.r[11].s64 + 32376;
	// 825DEFEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DEFF0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DEFF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DEFF8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DEFFC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DF000: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DF004: 419A0024  beq cr6, 0x825df028
	if ctx.cr[6].eq {
	pc = 0x825DF028; continue 'dispatch;
	}
	// 825DF008: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825DF00C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825DF010: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DF014: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825DF018: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825DF01C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DF020: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DF024: 4082FFE8  bne 0x825df00c
	if !ctx.cr[0].eq {
	pc = 0x825DF00C; continue 'dispatch;
	}
	// 825DF028: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF02C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 825DF030: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825DF034: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DF038: 4BCE5429  bl 0x822c4460
	ctx.lr = 0x825DF03C;
	sub_822C4460(ctx, base);
	// 825DF03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF040: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DF044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DF048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DF04C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DF050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF058 size=76
    let mut pc: u32 = 0x825DF058;
    'dispatch: loop {
        match pc {
            0x825DF058 => {
    //   block [0x825DF058..0x825DF0A4)
	// 825DF058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DF060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DF064: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF06C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DF070: 396BEE70  addi r11, r11, -0x1190
	ctx.r[11].s64 = ctx.r[11].s64 + -4496;
	// 825DF074: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DF078: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DF07C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF080: 419A0008  beq cr6, 0x825df088
	if ctx.cr[6].eq {
	pc = 0x825DF088; continue 'dispatch;
	}
	// 825DF084: 4BCE180D  bl 0x822c0890
	ctx.lr = 0x825DF088;
	sub_822C0890(ctx, base);
	// 825DF088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF08C: 48AD9485  bl 0x830b8510
	ctx.lr = 0x825DF090;
	sub_830B8510(ctx, base);
	// 825DF090: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DF094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DF098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DF09C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DF0A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF0A8 size=148
    let mut pc: u32 = 0x825DF0A8;
    'dispatch: loop {
        match pc {
            0x825DF0A8 => {
    //   block [0x825DF0A8..0x825DF13C)
	// 825DF0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DF0B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DF0B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DF0B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF0BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DF0C0: 48AD5B89  bl 0x830b4c48
	ctx.lr = 0x825DF0C4;
	sub_830B4C48(ctx, base);
	// 825DF0C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DF0C8: 38C00094  li r6, 0x94
	ctx.r[6].s64 = 148;
	// 825DF0CC: 38ABEFDC  addi r5, r11, -0x1024
	ctx.r[5].s64 = ctx.r[11].s64 + -4132;
	// 825DF0D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF0D4: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 825DF0D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF0DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DF0E0: 4E800421  bctrl
	ctx.lr = 0x825DF0E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DF0E4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DF0E8: 4182002C  beq 0x825df114
	if ctx.cr[0].eq {
	pc = 0x825DF114; continue 'dispatch;
	}
	// 825DF0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF0F0: 4BFFE8C1  bl 0x825dd9b0
	ctx.lr = 0x825DF0F4;
	sub_825DD9B0(ctx, base);
	// 825DF0F4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DF0F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DF0FC: 394AEE70  addi r10, r10, -0x1190
	ctx.r[10].s64 = ctx.r[10].s64 + -4496;
	// 825DF100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DF104: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DF108: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DF10C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825DF110: 48000008  b 0x825df118
	pc = 0x825DF118; continue 'dispatch;
	// 825DF114: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DF118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF11C: 4BFFFA25  bl 0x825deb40
	ctx.lr = 0x825DF120;
	sub_825DEB40(ctx, base);
	// 825DF120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DF128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DF12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DF130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DF134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DF138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF140 size=112
    let mut pc: u32 = 0x825DF140;
    'dispatch: loop {
        match pc {
            0x825DF140 => {
    //   block [0x825DF140..0x825DF1B0)
	// 825DF140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DF148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DF14C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DF150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF154: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DF158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF15C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825DF160: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF164: 4BFFFCDD  bl 0x825dee40
	ctx.lr = 0x825DF168;
	sub_825DEE40(ctx, base);
	// 825DF168: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DF16C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DF170: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF174: 4BCE0E8D  bl 0x822c0000
	ctx.lr = 0x825DF178;
	sub_822C0000(ctx, base);
	// 825DF178: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DF17C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DF180: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DF184: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF18C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DF190: 419A0008  beq cr6, 0x825df198
	if ctx.cr[6].eq {
	pc = 0x825DF198; continue 'dispatch;
	}
	// 825DF194: 4BCE16FD  bl 0x822c0890
	ctx.lr = 0x825DF198;
	sub_822C0890(ctx, base);
	// 825DF198: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DF19C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DF1A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DF1A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DF1A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DF1AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF1B0 size=112
    let mut pc: u32 = 0x825DF1B0;
    'dispatch: loop {
        match pc {
            0x825DF1B0 => {
    //   block [0x825DF1B0..0x825DF220)
	// 825DF1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF1B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DF1B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DF1BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DF1C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF1C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DF1C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF1CC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825DF1D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF1D4: 4BFFFD35  bl 0x825def08
	ctx.lr = 0x825DF1D8;
	sub_825DEF08(ctx, base);
	// 825DF1D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DF1DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DF1E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF1E4: 4BCE0E1D  bl 0x822c0000
	ctx.lr = 0x825DF1E8;
	sub_822C0000(ctx, base);
	// 825DF1E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DF1EC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DF1F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DF1F4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF1F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF1FC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DF200: 419A0008  beq cr6, 0x825df208
	if ctx.cr[6].eq {
	pc = 0x825DF208; continue 'dispatch;
	}
	// 825DF204: 4BCE168D  bl 0x822c0890
	ctx.lr = 0x825DF208;
	sub_822C0890(ctx, base);
	// 825DF208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DF20C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DF210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DF214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DF218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DF21C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF220 size=164
    let mut pc: u32 = 0x825DF220;
    'dispatch: loop {
        match pc {
            0x825DF220 => {
    //   block [0x825DF220..0x825DF2C4)
	// 825DF220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF224: 48BC8F49  bl 0x831a816c
	ctx.lr = 0x825DF228;
	sub_831A8130(ctx, base);
	// 825DF228: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF22C: 3D60822D  lis r11, -0x7dd3
	ctx.r[11].s64 = -2110980096;
	// 825DF230: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF234: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DF238: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DF23C: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 825DF240: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825DF244: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825DF248: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DF24C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DF250: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825DF254: 4881F6A5  bl 0x82dfe8f8
	ctx.lr = 0x825DF258;
	sub_82DFE8F8(ctx, base);
	// 825DF258: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825DF25C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825DF260: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DF264: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DF268: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DF26C: 4882262D  bl 0x82e01898
	ctx.lr = 0x825DF270;
	sub_82E01898(ctx, base);
	// 825DF270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF274: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DF278: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF27C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DF280: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DF284: 419A0024  beq cr6, 0x825df2a8
	if ctx.cr[6].eq {
	pc = 0x825DF2A8; continue 'dispatch;
	}
	// 825DF288: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DF28C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DF290: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DF294: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DF298: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DF29C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DF2A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DF2A4: 4082FFE8  bne 0x825df28c
	if !ctx.cr[0].eq {
	pc = 0x825DF28C; continue 'dispatch;
	}
	// 825DF2A8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DF2AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF2B0: 419A0008  beq cr6, 0x825df2b8
	if ctx.cr[6].eq {
	pc = 0x825DF2B8; continue 'dispatch;
	}
	// 825DF2B4: 4BCE15DD  bl 0x822c0890
	ctx.lr = 0x825DF2B8;
	sub_822C0890(ctx, base);
	// 825DF2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF2BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DF2C0: 48BC8EFC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF2C8 size=176
    let mut pc: u32 = 0x825DF2C8;
    'dispatch: loop {
        match pc {
            0x825DF2C8 => {
    //   block [0x825DF2C8..0x825DF378)
	// 825DF2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF2CC: 48BC8E99  bl 0x831a8164
	ctx.lr = 0x825DF2D0;
	sub_831A8130(ctx, base);
	// 825DF2D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF2D4: 83A3000C  lwz r29, 0xc(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF2D8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825DF2DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825DF2E0: 409A000C  bne cr6, 0x825df2ec
	if !ctx.cr[6].eq {
	pc = 0x825DF2EC; continue 'dispatch;
	}
	// 825DF2E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825DF2E8: 48000088  b 0x825df370
	pc = 0x825DF370; continue 'dispatch;
	// 825DF2EC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DF2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DF2F4: 419A0010  beq cr6, 0x825df304
	if ctx.cr[6].eq {
	pc = 0x825DF304; continue 'dispatch;
	}
	// 825DF2F8: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DF2FC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825DF300: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825DF304: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DF308: 40990064  ble cr6, 0x825df36c
	if !ctx.cr[6].gt {
	pc = 0x825DF36C; continue 'dispatch;
	}
	// 825DF30C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825DF310: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 825DF314: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DF318: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DF31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF320: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF324: 7FEBF02E  lwzx r31, r11, r30
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DF328: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF32C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 825DF330: 4BFFFEF1  bl 0x825df220
	ctx.lr = 0x825DF334;
	sub_825DF220(ctx, base);
	// 825DF334: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DF338: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 825DF33C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DF340: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825DF344: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF348: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DF34C: 4BCE5115  bl 0x822c4460
	ctx.lr = 0x825DF350;
	sub_822C4460(ctx, base);
	// 825DF350: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DF354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF358: 419A0008  beq cr6, 0x825df360
	if ctx.cr[6].eq {
	pc = 0x825DF360; continue 'dispatch;
	}
	// 825DF35C: 4BCE1535  bl 0x822c0890
	ctx.lr = 0x825DF360;
	sub_822C0890(ctx, base);
	// 825DF360: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825DF364: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825DF368: 4082FFAC  bne 0x825df314
	if !ctx.cr[0].eq {
	pc = 0x825DF314; continue 'dispatch;
	}
	// 825DF36C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825DF370: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DF374: 48BC8E40  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF378 size=224
    let mut pc: u32 = 0x825DF378;
    'dispatch: loop {
        match pc {
            0x825DF378 => {
    //   block [0x825DF378..0x825DF458)
	// 825DF378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF37C: 48BC8DED  bl 0x831a8168
	ctx.lr = 0x825DF380;
	sub_831A8130(ctx, base);
	// 825DF380: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF384: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 825DF388: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825DF38C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 825DF390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF394: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DF398: 4099000C  ble cr6, 0x825df3a4
	if !ctx.cr[6].gt {
	pc = 0x825DF3A4; continue 'dispatch;
	}
	// 825DF39C: 485D8985  bl 0x82bb7d20
	ctx.lr = 0x825DF3A0;
	sub_82BB7D20(ctx, base);
	// 825DF3A0: 480000B0  b 0x825df450
	pc = 0x825DF450; continue 'dispatch;
	// 825DF3A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF3A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DF3AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DF3B0: 409A000C  bne cr6, 0x825df3bc
	if !ctx.cr[6].eq {
	pc = 0x825DF3BC; continue 'dispatch;
	}
	// 825DF3B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825DF3B8: 48000010  b 0x825df3c8
	pc = 0x825DF3C8; continue 'dispatch;
	// 825DF3BC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF3C0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825DF3C4: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825DF3C8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825DF3CC: 40980084  bge cr6, 0x825df450
	if !ctx.cr[6].lt {
	pc = 0x825DF450; continue 'dispatch;
	}
	// 825DF3D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DF3D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DF3D8: 4801B759  bl 0x825fab30
	ctx.lr = 0x825DF3DC;
	sub_825FAB30(ctx, base);
	// 825DF3DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DF3E0: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DF3E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DF3E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF3EC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825DF3F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DF3F4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF3F8: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825DF3FC: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DF400: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DF404: 484A4F15  bl 0x82a84318
	ctx.lr = 0x825DF408;
	sub_82A84318(ctx, base);
	// 825DF408: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF40C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF410: 419A0024  beq cr6, 0x825df434
	if ctx.cr[6].eq {
	pc = 0x825DF434; continue 'dispatch;
	}
	// 825DF414: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF418: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DF41C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF420: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825DF424: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825DF428: 481F2F21  bl 0x827d2348
	ctx.lr = 0x825DF42C;
	sub_827D2348(ctx, base);
	// 825DF42C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF430: 4BCE0E39  bl 0x822c0268
	ctx.lr = 0x825DF434;
	sub_822C0268(ctx, base);
	// 825DF434: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DF438: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825DF43C: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DF440: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825DF444: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825DF448: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DF44C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DF450: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DF454: 48BC8D64  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF458 size=936
    let mut pc: u32 = 0x825DF458;
    'dispatch: loop {
        match pc {
            0x825DF458 => {
    //   block [0x825DF458..0x825DF800)
	// 825DF458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF45C: 48BC8CED  bl 0x831a8148
	ctx.lr = 0x825DF460;
	sub_831A8130(ctx, base);
	// 825DF460: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF464: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 825DF468: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF46C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825DF470: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825DF474: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 825DF478: 816BBD00  lwz r11, -0x4300(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17152 as u32) ) } as u64;
	// 825DF47C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DF480: 409A00B0  bne cr6, 0x825df530
	if !ctx.cr[6].eq {
	pc = 0x825DF530; continue 'dispatch;
	}
	// 825DF484: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF488: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DF48C: 7FEB2214  add r31, r11, r4
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825DF490: 83A40008  lwz r29, 8(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF494: 7C8A2214  add r4, r10, r4
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 825DF498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF49C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825DF4A0: 48AD9B31  bl 0x830b8fd0
	ctx.lr = 0x825DF4A4;
	sub_830B8FD0(ctx, base);
	// 825DF4A4: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825DF4A8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825DF4AC: 40990084  ble cr6, 0x825df530
	if !ctx.cr[6].gt {
	pc = 0x825DF530; continue 'dispatch;
	}
	// 825DF4B0: 3F408339  lis r26, -0x7cc7
	ctx.r[26].s64 = -2093416448;
	// 825DF4B4: 3F608339  lis r27, -0x7cc7
	ctx.r[27].s64 = -2093416448;
	// 825DF4B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF4BC: 815BBD10  lwz r10, -0x42f0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17136 as u32) ) } as u64;
	// 825DF4C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DF4C4: 409A0010  bne cr6, 0x825df4d4
	if !ctx.cr[6].eq {
	pc = 0x825DF4D4; continue 'dispatch;
	}
	// 825DF4C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF4CC: 7EEBE214  add r23, r11, r28
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 825DF4D0: 48000010  b 0x825df4e0
	pc = 0x825DF4E0; continue 'dispatch;
	// 825DF4D4: 815ABD08  lwz r10, -0x42f8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-17144 as u32) ) } as u64;
	// 825DF4D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DF4DC: 419A0054  beq cr6, 0x825df530
	if ctx.cr[6].eq {
	pc = 0x825DF530; continue 'dispatch;
	}
	// 825DF4E0: 48AD9621  bl 0x830b8b00
	ctx.lr = 0x825DF4E4;
	sub_830B8B00(ctx, base);
	// 825DF4E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF4E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF4EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DF4F0: 4E800421  bctrl
	ctx.lr = 0x825DF4F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DF4F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF4F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825DF4FC: 41820020  beq 0x825df51c
	if ctx.cr[0].eq {
	pc = 0x825DF51C; continue 'dispatch;
	}
	// 825DF500: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825DF504: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF508: 7D684670  srawi r8, r11, 8
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 8) as i64;
	// 825DF50C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 825DF510: 5128401E  rlwimi r8, r9, 8, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 825DF514: 550B002E  rlwinm r11, r8, 0, 0, 0x17
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 825DF518: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825DF51C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DF520: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825DF524: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 825DF528: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825DF52C: 4198FF8C  blt cr6, 0x825df4b8
	if ctx.cr[6].lt {
	pc = 0x825DF4B8; continue 'dispatch;
	}
	// 825DF530: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DF534: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DF538: 3A8BEFDC  addi r20, r11, -0x1024
	ctx.r[20].s64 = ctx.r[11].s64 + -4132;
	// 825DF53C: 38A000AD  li r5, 0xad
	ctx.r[5].s64 = 173;
	// 825DF540: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 825DF544: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 825DF548: 48812EA1  bl 0x82df23e8
	ctx.lr = 0x825DF54C;
	sub_82DF23E8(ctx, base);
	// 825DF54C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DF550: 41820010  beq 0x825df560
	if ctx.cr[0].eq {
	pc = 0x825DF560; continue 'dispatch;
	}
	// 825DF554: 48849CC5  bl 0x82e29218
	ctx.lr = 0x825DF558;
	sub_82E29218(ctx, base);
	// 825DF558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DF55C: 48000008  b 0x825df564
	pc = 0x825DF564; continue 'dispatch;
	// 825DF560: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825DF564: 3879000C  addi r3, r25, 0xc
	ctx.r[3].s64 = ctx.r[25].s64 + 12;
	// 825DF568: 4BFFFBD9  bl 0x825df140
	ctx.lr = 0x825DF56C;
	sub_825DF140(ctx, base);
	// 825DF56C: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF570: 82D9000C  lwz r22, 0xc(r25)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF574: 3B96000C  addi r28, r22, 0xc
	ctx.r[28].s64 = ctx.r[22].s64 + 12;
	// 825DF578: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DF57C: 4BFFFDFD  bl 0x825df378
	ctx.lr = 0x825DF580;
	sub_825DF378(ctx, base);
	// 825DF580: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF584: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 825DF588: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DF58C: 40990260  ble cr6, 0x825df7ec
	if !ctx.cr[6].gt {
	pc = 0x825DF7EC; continue 'dispatch;
	}
	// 825DF590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DF594: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 825DF598: 3EA08335  lis r21, -0x7ccb
	ctx.r[21].s64 = -2093678592;
	// 825DF59C: 3F408212  lis r26, -0x7dee
	ctx.r[26].s64 = -2112749568;
	// 825DF5A0: 3B6BF018  addi r27, r11, -0xfe8
	ctx.r[27].s64 = ctx.r[11].s64 + -4072;
	// 825DF5A4: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF5A8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 825DF5AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DF5B0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 825DF5B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DF5BC: 419A0140  beq cr6, 0x825df6fc
	if ctx.cr[6].eq {
	pc = 0x825DF6FC; continue 'dispatch;
	}
	// 825DF5C0: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 825DF5C4: 48812E25  bl 0x82df23e8
	ctx.lr = 0x825DF5C8;
	sub_82DF23E8(ctx, base);
	// 825DF5C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DF5CC: 41820010  beq 0x825df5dc
	if ctx.cr[0].eq {
	pc = 0x825DF5DC; continue 'dispatch;
	}
	// 825DF5D0: 4BD05F79  bl 0x822e5548
	ctx.lr = 0x825DF5D4;
	sub_822E5548(ctx, base);
	// 825DF5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF5D8: 48000008  b 0x825df5e0
	pc = 0x825DF5E0; continue 'dispatch;
	// 825DF5DC: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 825DF5E0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825DF5E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DF5E8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825DF5EC: 4BFFF78D  bl 0x825ded78
	ctx.lr = 0x825DF5F0;
	sub_825DED78(ctx, base);
	// 825DF5F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DF5F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DF5F8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825DF5FC: 4BCE0A05  bl 0x822c0000
	ctx.lr = 0x825DF600;
	sub_822C0000(ctx, base);
	// 825DF600: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF608: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825DF60C: 488143FD  bl 0x82df3a08
	ctx.lr = 0x825DF610;
	sub_82DF3A08(ctx, base);
	// 825DF610: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825DF614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF618: 48814D61  bl 0x82df4378
	ctx.lr = 0x825DF61C;
	sub_82DF4378(ctx, base);
	// 825DF61C: 817AB230  lwz r11, -0x4dd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825DF620: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825DF624: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DF628: 419A0028  beq cr6, 0x825df650
	if ctx.cr[6].eq {
	pc = 0x825DF650; continue 'dispatch;
	}
	// 825DF62C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DF630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DF634: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF638: 48814F31  bl 0x82df4568
	ctx.lr = 0x825DF63C;
	sub_82DF4568(ctx, base);
	// 825DF63C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DF640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF644: 4881458D  bl 0x82df3bd0
	ctx.lr = 0x825DF648;
	sub_82DF3BD0(ctx, base);
	// 825DF648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF64C: 48813DDD  bl 0x82df3428
	ctx.lr = 0x825DF650;
	sub_82DF3428(ctx, base);
	// 825DF650: 80957E78  lwz r4, 0x7e78(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(32376 as u32) ) } as u64;
	// 825DF654: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DF658: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825DF65C: 419A006C  beq cr6, 0x825df6c8
	if ctx.cr[6].eq {
	pc = 0x825DF6C8; continue 'dispatch;
	}
	// 825DF660: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825DF664: 4884B485  bl 0x82e2aae8
	ctx.lr = 0x825DF668;
	sub_82E2AAE8(ctx, base);
	// 825DF668: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DF66C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DF670: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825DF674: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DF678: 4884C569  bl 0x82e2bbe0
	ctx.lr = 0x825DF67C;
	sub_82E2BBE0(ctx, base);
	// 825DF67C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DF680: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 825DF684: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DF688: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825DF68C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF690: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DF694: 4BCE4DCD  bl 0x822c4460
	ctx.lr = 0x825DF698;
	sub_822C4460(ctx, base);
	// 825DF698: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825DF69C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF6A0: 419A0008  beq cr6, 0x825df6a8
	if ctx.cr[6].eq {
	pc = 0x825DF6A8; continue 'dispatch;
	}
	// 825DF6A4: 4BCE11ED  bl 0x822c0890
	ctx.lr = 0x825DF6A8;
	sub_822C0890(ctx, base);
	// 825DF6A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF6AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DF6B0: 419A0010  beq cr6, 0x825df6c0
	if ctx.cr[6].eq {
	pc = 0x825DF6C0; continue 'dispatch;
	}
	// 825DF6B4: 3880003D  li r4, 0x3d
	ctx.r[4].s64 = 61;
	// 825DF6B8: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825DF6BC: 48AE8425  bl 0x830c7ae0
	ctx.lr = 0x825DF6C0;
	sub_830C7AE0(ctx, base);
	// 825DF6C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825DF6C4: 4884B43D  bl 0x82e2ab00
	ctx.lr = 0x825DF6C8;
	sub_82E2AB00(ctx, base);
	// 825DF6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF6CC: 4881F18D  bl 0x82dfe858
	ctx.lr = 0x825DF6D0;
	sub_82DFE858(ctx, base);
	// 825DF6D0: 9B1F0014  stb r24, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[24].u8 ) };
	// 825DF6D4: 931F0018  stw r24, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 825DF6D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825DF6DC: 931F001C  stw r24, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[24].u32 ) };
	// 825DF6E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DF6E4: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 825DF6E8: 4BCF6851  bl 0x822d5f38
	ctx.lr = 0x825DF6EC;
	sub_822D5F38(ctx, base);
	// 825DF6EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF6F0: 48813D39  bl 0x82df3428
	ctx.lr = 0x825DF6F4;
	sub_82DF3428(ctx, base);
	// 825DF6F4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DF6F8: 480000D4  b 0x825df7cc
	pc = 0x825DF7CC; continue 'dispatch;
	// 825DF6FC: 38A000DD  li r5, 0xdd
	ctx.r[5].s64 = 221;
	// 825DF700: 48812CE9  bl 0x82df23e8
	ctx.lr = 0x825DF704;
	sub_82DF23E8(ctx, base);
	// 825DF704: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DF708: 41820010  beq 0x825df718
	if ctx.cr[0].eq {
	pc = 0x825DF718; continue 'dispatch;
	}
	// 825DF70C: 4BD05E3D  bl 0x822e5548
	ctx.lr = 0x825DF710;
	sub_822E5548(ctx, base);
	// 825DF710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF714: 48000008  b 0x825df71c
	pc = 0x825DF71C; continue 'dispatch;
	// 825DF718: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 825DF71C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825DF720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DF724: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825DF728: 4BFFF651  bl 0x825ded78
	ctx.lr = 0x825DF72C;
	sub_825DED78(ctx, base);
	// 825DF72C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DF730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DF734: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825DF738: 4BCE08C9  bl 0x822c0000
	ctx.lr = 0x825DF73C;
	sub_822C0000(ctx, base);
	// 825DF73C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 825DF740: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DF744: 38A000DF  li r5, 0xdf
	ctx.r[5].s64 = 223;
	// 825DF748: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825DF74C: 48812C9D  bl 0x82df23e8
	ctx.lr = 0x825DF750;
	sub_82DF23E8(ctx, base);
	// 825DF750: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DF754: 41820010  beq 0x825df764
	if ctx.cr[0].eq {
	pc = 0x825DF764; continue 'dispatch;
	}
	// 825DF758: 4BCEB709  bl 0x822cae60
	ctx.lr = 0x825DF75C;
	sub_822CAE60(ctx, base);
	// 825DF75C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DF760: 48000008  b 0x825df768
	pc = 0x825DF768; continue 'dispatch;
	// 825DF764: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825DF768: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825DF76C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825DF770: 4BFFFA41  bl 0x825df1b0
	ctx.lr = 0x825DF774;
	sub_825DF1B0(ctx, base);
	// 825DF774: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF778: 48AD9389  bl 0x830b8b00
	ctx.lr = 0x825DF77C;
	sub_830B8B00(ctx, base);
	// 825DF77C: 48220675  bl 0x827ffdf0
	ctx.lr = 0x825DF780;
	sub_827FFDF0(ctx, base);
	// 825DF780: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF784: 38DE000C  addi r6, r30, 0xc
	ctx.r[6].s64 = ctx.r[30].s64 + 12;
	// 825DF788: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF78C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825DF790: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF794: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF798: 4861A6F1  bl 0x82bf9e88
	ctx.lr = 0x825DF79C;
	sub_82BF9E88(ctx, base);
	// 825DF79C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF7A0: 4881F0B9  bl 0x82dfe858
	ctx.lr = 0x825DF7A4;
	sub_82DFE858(ctx, base);
	// 825DF7A4: 9B1F0014  stb r24, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[24].u8 ) };
	// 825DF7A8: 931F0018  stw r24, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 825DF7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF7B0: 931F001C  stw r24, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[24].u32 ) };
	// 825DF7B4: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 825DF7B8: 4881F0A1  bl 0x82dfe858
	ctx.lr = 0x825DF7BC;
	sub_82DFE858(ctx, base);
	// 825DF7BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825DF7C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DF7C4: 4BCF6775  bl 0x822d5f38
	ctx.lr = 0x825DF7C8;
	sub_822D5F38(ctx, base);
	// 825DF7C8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825DF7CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DF7D0: 419A0008  beq cr6, 0x825df7d8
	if ctx.cr[6].eq {
	pc = 0x825DF7D8; continue 'dispatch;
	}
	// 825DF7D4: 4BCE10BD  bl 0x822c0890
	ctx.lr = 0x825DF7D8;
	sub_822C0890(ctx, base);
	// 825DF7D8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF7DC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825DF7E0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825DF7E4: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DF7E8: 4198FDBC  blt cr6, 0x825df5a4
	if ctx.cr[6].lt {
	pc = 0x825DF5A4; continue 'dispatch;
	}
	// 825DF7EC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825DF7F0: 4881F069  bl 0x82dfe858
	ctx.lr = 0x825DF7F4;
	sub_82DFE858(ctx, base);
	// 825DF7F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825DF7F8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825DF7FC: 48BC899C  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF800 size=132
    let mut pc: u32 = 0x825DF800;
    'dispatch: loop {
        match pc {
            0x825DF800 => {
    //   block [0x825DF800..0x825DF884)
	// 825DF800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF804: 48BC8965  bl 0x831a8168
	ctx.lr = 0x825DF808;
	sub_831A8130(ctx, base);
	// 825DF808: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DF814: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DF818: 488138D9  bl 0x82df30f0
	ctx.lr = 0x825DF81C;
	sub_82DF30F0(ctx, base);
	// 825DF81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF820: 48813C11  bl 0x82df3430
	ctx.lr = 0x825DF824;
	sub_82DF3430(ctx, base);
	// 825DF824: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DF828: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DF82C: 48813C05  bl 0x82df3430
	ctx.lr = 0x825DF830;
	sub_82DF3430(ctx, base);
	// 825DF830: 7D7C1A14  add r11, r28, r3
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 825DF834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF838: 388B0006  addi r4, r11, 6
	ctx.r[4].s64 = ctx.r[11].s64 + 6;
	// 825DF83C: 48AE82A5  bl 0x830c7ae0
	ctx.lr = 0x825DF840;
	sub_830C7AE0(ctx, base);
	// 825DF840: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DF844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF848: 388BF01C  addi r4, r11, -0xfe4
	ctx.r[4].s64 = ctx.r[11].s64 + -4068;
	// 825DF84C: 48813D2D  bl 0x82df3578
	ctx.lr = 0x825DF850;
	sub_82DF3578(ctx, base);
	// 825DF850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DF858: 48813E81  bl 0x82df36d8
	ctx.lr = 0x825DF85C;
	sub_82DF36D8(ctx, base);
	// 825DF85C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DF860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF864: 388B9FD8  addi r4, r11, -0x6028
	ctx.r[4].s64 = ctx.r[11].s64 + -24616;
	// 825DF868: 48813D11  bl 0x82df3578
	ctx.lr = 0x825DF86C;
	sub_82DF3578(ctx, base);
	// 825DF86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF870: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DF874: 48813E65  bl 0x82df36d8
	ctx.lr = 0x825DF878;
	sub_82DF36D8(ctx, base);
	// 825DF878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF87C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DF880: 48BC8938  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF888 size=76
    let mut pc: u32 = 0x825DF888;
    'dispatch: loop {
        match pc {
            0x825DF888 => {
    //   block [0x825DF888..0x825DF8D4)
	// 825DF888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF88C: 48BC88E1  bl 0x831a816c
	ctx.lr = 0x825DF890;
	sub_831A8130(ctx, base);
	// 825DF890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DF898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF89C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF8A0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DF8A4: 4881390D  bl 0x82df31b0
	ctx.lr = 0x825DF8A8;
	sub_82DF31B0(ctx, base);
	// 825DF8A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DF8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF8B0: 48AD2FF9  bl 0x830b28a8
	ctx.lr = 0x825DF8B4;
	sub_830B28A8(ctx, base);
	// 825DF8B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DF8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF8BC: 48503A85  bl 0x82ae3340
	ctx.lr = 0x825DF8C0;
	sub_82AE3340(ctx, base);
	// 825DF8C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF8C4: 48813B65  bl 0x82df3428
	ctx.lr = 0x825DF8C8;
	sub_82DF3428(ctx, base);
	// 825DF8C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825DF8CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DF8D0: 48BC88EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF8D8 size=100
    let mut pc: u32 = 0x825DF8D8;
    'dispatch: loop {
        match pc {
            0x825DF8D8 => {
    //   block [0x825DF8D8..0x825DF93C)
	// 825DF8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF8DC: 48BC8891  bl 0x831a816c
	ctx.lr = 0x825DF8E0;
	sub_831A8130(ctx, base);
	// 825DF8E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF8E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DF8E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF8EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DF8F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF8F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825DF8F8: 48814309  bl 0x82df3c00
	ctx.lr = 0x825DF8FC;
	sub_82DF3C00(ctx, base);
	// 825DF8FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825DF900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF904: 488142FD  bl 0x82df3c00
	ctx.lr = 0x825DF908;
	sub_82DF3C00(ctx, base);
	// 825DF908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF90C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DF910: 488142F1  bl 0x82df3c00
	ctx.lr = 0x825DF914;
	sub_82DF3C00(ctx, base);
	// 825DF914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DF918: 48813B11  bl 0x82df3428
	ctx.lr = 0x825DF91C;
	sub_82DF3428(ctx, base);
	// 825DF91C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825DF920: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF924: 48813B05  bl 0x82df3428
	ctx.lr = 0x825DF928;
	sub_82DF3428(ctx, base);
	// 825DF928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DF92C: 48813AFD  bl 0x82df3428
	ctx.lr = 0x825DF930;
	sub_82DF3428(ctx, base);
	// 825DF930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF934: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DF938: 48BC8884  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF940 size=124
    let mut pc: u32 = 0x825DF940;
    'dispatch: loop {
        match pc {
            0x825DF940 => {
    //   block [0x825DF940..0x825DF9BC)
	// 825DF940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF944: 48BC8821  bl 0x831a8164
	ctx.lr = 0x825DF948;
	sub_831A8130(ctx, base);
	// 825DF948: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF94C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825DF950: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825DF954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF958: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DF95C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DF960: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DF964: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DF968: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 825DF96C: 48814295  bl 0x82df3c00
	ctx.lr = 0x825DF970;
	sub_82DF3C00(ctx, base);
	// 825DF970: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825DF974: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF978: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DF97C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DF980: 4BFFFF59  bl 0x825df8d8
	ctx.lr = 0x825DF984;
	sub_825DF8D8(ctx, base);
	// 825DF984: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825DF988: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DF98C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DF990: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DF994: 4881426D  bl 0x82df3c00
	ctx.lr = 0x825DF998;
	sub_82DF3C00(ctx, base);
	// 825DF998: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF99C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DF9A0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DF9A4: 48813A85  bl 0x82df3428
	ctx.lr = 0x825DF9A8;
	sub_82DF3428(ctx, base);
	// 825DF9A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DF9AC: 48813A7D  bl 0x82df3428
	ctx.lr = 0x825DF9B0;
	sub_82DF3428(ctx, base);
	// 825DF9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF9B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DF9B8: 48BC87FC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF9C0 size=84
    let mut pc: u32 = 0x825DF9C0;
    'dispatch: loop {
        match pc {
            0x825DF9C0 => {
    //   block [0x825DF9C0..0x825DFA14)
	// 825DF9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF9C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DF9C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DF9CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DF9D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF9D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DF9D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF9DC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825DF9E0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DF9E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF9E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DF9EC: 48814215  bl 0x82df3c00
	ctx.lr = 0x825DF9F0;
	sub_82DF3C00(ctx, base);
	// 825DF9F0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DF9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF9F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DF9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DFA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DFA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DFA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DFA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DFA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFA18 size=84
    let mut pc: u32 = 0x825DFA18;
    'dispatch: loop {
        match pc {
            0x825DFA18 => {
    //   block [0x825DFA18..0x825DFA6C)
	// 825DFA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DFA20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DFA24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DFA28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFA2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFA30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DFA34: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DFA38: 396BF028  addi r11, r11, -0xfd8
	ctx.r[11].s64 = ctx.r[11].s64 + -4056;
	// 825DFA3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFA40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DFA44: 4BFFFF7D  bl 0x825df9c0
	ctx.lr = 0x825DFA48;
	sub_825DF9C0(ctx, base);
	// 825DFA48: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825DFA4C: 488139DD  bl 0x82df3428
	ctx.lr = 0x825DFA50;
	sub_82DF3428(ctx, base);
	// 825DFA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFA54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DFA58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DFA5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DFA60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DFA64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DFA68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFA70 size=72
    let mut pc: u32 = 0x825DFA70;
    'dispatch: loop {
        match pc {
            0x825DFA70 => {
    //   block [0x825DFA70..0x825DFAB8)
	// 825DFA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFA74: 48BC86F9  bl 0x831a816c
	ctx.lr = 0x825DFA78;
	sub_831A8130(ctx, base);
	// 825DFA78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFA80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFA84: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DFA88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DFA8C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825DFA90: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DFA94: 4881416D  bl 0x82df3c00
	ctx.lr = 0x825DFA98;
	sub_82DF3C00(ctx, base);
	// 825DFA98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DFA9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DFAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DFAA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DFAA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DFAAC: 4E800421  bctrl
	ctx.lr = 0x825DFAB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DFAB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DFAB4: 48BC8708  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFAB8 size=92
    let mut pc: u32 = 0x825DFAB8;
    'dispatch: loop {
        match pc {
            0x825DFAB8 => {
    //   block [0x825DFAB8..0x825DFB14)
	// 825DFAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DFAC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DFAC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DFAC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFAD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFAD4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DFAD8: 48813951  bl 0x82df3428
	ctx.lr = 0x825DFADC;
	sub_82DF3428(ctx, base);
	// 825DFADC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DFAE0: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DFAE4: 396BD408  addi r11, r11, -0x2bf8
	ctx.r[11].s64 = ctx.r[11].s64 + -11256;
	// 825DFAE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DFAEC: 4182000C  beq 0x825dfaf8
	if ctx.cr[0].eq {
	pc = 0x825DFAF8; continue 'dispatch;
	}
	// 825DFAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFAF4: 4BCE0775  bl 0x822c0268
	ctx.lr = 0x825DFAF8;
	sub_822C0268(ctx, base);
	// 825DFAF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFAFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DFB00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DFB04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DFB08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DFB0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DFB10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFB18 size=192
    let mut pc: u32 = 0x825DFB18;
    'dispatch: loop {
        match pc {
            0x825DFB18 => {
    //   block [0x825DFB18..0x825DFBD8)
	// 825DFB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFB1C: 48BC864D  bl 0x831a8168
	ctx.lr = 0x825DFB20;
	sub_831A8130(ctx, base);
	// 825DFB20: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFB24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFB28: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DFB2C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825DFB30: 83DF006C  lwz r30, 0x6c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 825DFB34: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 825DFB38: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825DFB3C: 4BCE0DFD  bl 0x822c0938
	ctx.lr = 0x825DFB40;
	sub_822C0938(ctx, base);
	// 825DFB40: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825DFB44: 41820024  beq 0x825dfb68
	if ctx.cr[0].eq {
	pc = 0x825DFB68; continue 'dispatch;
	}
	// 825DFB48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DFB4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825DFB50: 4BFFFE71  bl 0x825df9c0
	ctx.lr = 0x825DFB54;
	sub_825DF9C0(ctx, base);
	// 825DFB54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DFB58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DFB5C: 4BFFFEBD  bl 0x825dfa18
	ctx.lr = 0x825DFB60;
	sub_825DFA18(ctx, base);
	// 825DFB60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DFB64: 48000008  b 0x825dfb6c
	pc = 0x825DFB6C; continue 'dispatch;
	// 825DFB68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825DFB6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DFB70: 4BD2D6A1  bl 0x8230d210
	ctx.lr = 0x825DFB74;
	sub_8230D210(ctx, base);
	// 825DFB74: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825DFB78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DFB7C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825DFB80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DFB84: 4BD2D6E5  bl 0x8230d268
	ctx.lr = 0x825DFB88;
	sub_8230D268(ctx, base);
	// 825DFB88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DFB8C: 48AD234D  bl 0x830b1ed8
	ctx.lr = 0x825DFB90;
	sub_830B1ED8(ctx, base);
	// 825DFB90: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825DFB94: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825DFB98: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825DFB9C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825DFBA0: 4BD2D6C9  bl 0x8230d268
	ctx.lr = 0x825DFBA4;
	sub_8230D268(ctx, base);
	// 825DFBA4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825DFBA8: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 825DFBAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DFBB0: 4BD2E379  bl 0x8230df28
	ctx.lr = 0x825DFBB4;
	sub_8230DF28(ctx, base);
	// 825DFBB4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825DFBB8: 48AD2321  bl 0x830b1ed8
	ctx.lr = 0x825DFBBC;
	sub_830B1ED8(ctx, base);
	// 825DFBBC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825DFBC0: 48AD2319  bl 0x830b1ed8
	ctx.lr = 0x825DFBC4;
	sub_830B1ED8(ctx, base);
	// 825DFBC4: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 825DFBC8: 48813861  bl 0x82df3428
	ctx.lr = 0x825DFBCC;
	sub_82DF3428(ctx, base);
	// 825DFBCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DFBD0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825DFBD4: 48BC85E4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFBD8 size=100
    let mut pc: u32 = 0x825DFBD8;
    'dispatch: loop {
        match pc {
            0x825DFBD8 => {
    //   block [0x825DFBD8..0x825DFC3C)
	// 825DFBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFBDC: 48BC8591  bl 0x831a816c
	ctx.lr = 0x825DFBE0;
	sub_831A8130(ctx, base);
	// 825DFBE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFBE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFBE8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DFBEC: 48AD233D  bl 0x830b1f28
	ctx.lr = 0x825DFBF0;
	sub_830B1F28(ctx, base);
	// 825DFBF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DFBF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DFBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DFBFC: 48814005  bl 0x82df3c00
	ctx.lr = 0x825DFC00;
	sub_82DF3C00(ctx, base);
	// 825DFC00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DFC04: 3D40825E  lis r10, -0x7da2
	ctx.r[10].s64 = -2107768832;
	// 825DFC08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825DFC0C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825DFC10: 388AF888  addi r4, r10, -0x778
	ctx.r[4].s64 = ctx.r[10].s64 + -1912;
	// 825DFC14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DFC18: 88AB7E80  lbz r5, 0x7e80(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32384 as u32) ) } as u64;
	// 825DFC1C: 4BFFFD25  bl 0x825df940
	ctx.lr = 0x825DFC20;
	sub_825DF940(ctx, base);
	// 825DFC20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DFC24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DFC28: 4BFFFEF1  bl 0x825dfb18
	ctx.lr = 0x825DFC2C;
	sub_825DFB18(ctx, base);
	// 825DFC2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DFC30: 488137F9  bl 0x82df3428
	ctx.lr = 0x825DFC34;
	sub_82DF3428(ctx, base);
	// 825DFC34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DFC38: 48BC8584  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DFC40 size=268
    let mut pc: u32 = 0x825DFC40;
    'dispatch: loop {
        match pc {
            0x825DFC40 => {
    //   block [0x825DFC40..0x825DFD4C)
	// 825DFC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFC44: 48BC851D  bl 0x831a8160
	ctx.lr = 0x825DFC48;
	sub_831A8130(ctx, base);
	// 825DFC48: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFC4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFC50: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825DFC54: 3B9F00C0  addi r28, r31, 0xc0
	ctx.r[28].s64 = ctx.r[31].s64 + 192;
	// 825DFC58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DFC5C: 48AD2325  bl 0x830b1f80
	ctx.lr = 0x825DFC60;
	sub_830B1F80(ctx, base);
	// 825DFC60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DFC64: 418200E0  beq 0x825dfd44
	if ctx.cr[0].eq {
	pc = 0x825DFD44; continue 'dispatch;
	}
	// 825DFC68: 897F00CC  lbz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 825DFC6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825DFC70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DFC74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DFC78: 4182007C  beq 0x825dfcf4
	if ctx.cr[0].eq {
	pc = 0x825DFCF4; continue 'dispatch;
	}
	// 825DFC7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DFC80: 4BF0AE09  bl 0x824eaa88
	ctx.lr = 0x825DFC84;
	sub_824EAA88(ctx, base);
	// 825DFC84: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFC88: 4BF093A9  bl 0x824e9030
	ctx.lr = 0x825DFC8C;
	sub_824E9030(ctx, base);
	// 825DFC8C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825DFC90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DFC94: 48811FFD  bl 0x82df1c90
	ctx.lr = 0x825DFC98;
	sub_82DF1C90(ctx, base);
	// 825DFC98: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DFC9C: 897F00CD  lbz r11, 0xcd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(205 as u32) ) } as u64;
	// 825DFCA0: 4182002C  beq 0x825dfccc
	if ctx.cr[0].eq {
	pc = 0x825DFCCC; continue 'dispatch;
	}
	// 825DFCA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DFCA8: 4182004C  beq 0x825dfcf4
	if ctx.cr[0].eq {
	pc = 0x825DFCF4; continue 'dispatch;
	}
	// 825DFCAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DFCB0: 4BF0ADD9  bl 0x824eaa88
	ctx.lr = 0x825DFCB4;
	sub_824EAA88(ctx, base);
	// 825DFCB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFCB8: 4BF09119  bl 0x824e8dd0
	ctx.lr = 0x825DFCBC;
	sub_824E8DD0(ctx, base);
	// 825DFCBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DFCC0: 48811FD1  bl 0x82df1c90
	ctx.lr = 0x825DFCC4;
	sub_82DF1C90(ctx, base);
	// 825DFCC4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825DFCC8: 48000028  b 0x825dfcf0
	pc = 0x825DFCF0; continue 'dispatch;
	// 825DFCCC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DFCD0: 40820024  bne 0x825dfcf4
	if !ctx.cr[0].eq {
	pc = 0x825DFCF4; continue 'dispatch;
	}
	// 825DFCD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DFCD8: 4BF0ADB1  bl 0x824eaa88
	ctx.lr = 0x825DFCDC;
	sub_824EAA88(ctx, base);
	// 825DFCDC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFCE0: 4BF09219  bl 0x824e8ef8
	ctx.lr = 0x825DFCE4;
	sub_824E8EF8(ctx, base);
	// 825DFCE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DFCE8: 48811FA9  bl 0x82df1c90
	ctx.lr = 0x825DFCEC;
	sub_82DF1C90(ctx, base);
	// 825DFCEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DFCF0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825DFCF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DFCF8: 48AD2231  bl 0x830b1f28
	ctx.lr = 0x825DFCFC;
	sub_830B1F28(ctx, base);
	// 825DFCFC: C03B0000  lfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DFD00: 48AD69E1  bl 0x830b66e0
	ctx.lr = 0x825DFD04;
	sub_830B66E0(ctx, base);
	// 825DFD04: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DFD08: 4182003C  beq 0x825dfd44
	if ctx.cr[0].eq {
	pc = 0x825DFD44; continue 'dispatch;
	}
	// 825DFD0C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DFD10: 4182001C  beq 0x825dfd2c
	if ctx.cr[0].eq {
	pc = 0x825DFD2C; continue 'dispatch;
	}
	// 825DFD14: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825DFD18: 4BF0AD71  bl 0x824eaa88
	ctx.lr = 0x825DFD1C;
	sub_824EAA88(ctx, base);
	// 825DFD1C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFD20: 4BF091D9  bl 0x824e8ef8
	ctx.lr = 0x825DFD24;
	sub_824E8EF8(ctx, base);
	// 825DFD24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825DFD28: 48000018  b 0x825dfd40
	pc = 0x825DFD40; continue 'dispatch;
	// 825DFD2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DFD30: 4BF0AD59  bl 0x824eaa88
	ctx.lr = 0x825DFD34;
	sub_824EAA88(ctx, base);
	// 825DFD34: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFD38: 4BF09099  bl 0x824e8dd0
	ctx.lr = 0x825DFD3C;
	sub_824E8DD0(ctx, base);
	// 825DFD3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DFD40: 48811F51  bl 0x82df1c90
	ctx.lr = 0x825DFD44;
	sub_82DF1C90(ctx, base);
	// 825DFD44: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825DFD48: 48BC8468  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFD50 size=100
    let mut pc: u32 = 0x825DFD50;
    'dispatch: loop {
        match pc {
            0x825DFD50 => {
    //   block [0x825DFD50..0x825DFDB4)
	// 825DFD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DFD58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DFD5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DFD60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFD64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFD68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFD6C: 4883216D  bl 0x82e11ed8
	ctx.lr = 0x825DFD70;
	sub_82E11ED8(ctx, base);
	// 825DFD70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DFD74: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DFD78: 396BF034  addi r11, r11, -0xfcc
	ctx.r[11].s64 = ctx.r[11].s64 + -4044;
	// 825DFD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DFD80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DFD84: 4BEBA02D  bl 0x82499db0
	ctx.lr = 0x825DFD88;
	sub_82499DB0(ctx, base);
	// 825DFD88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DFD8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DFD90: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825DFD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFD98: 995F0015  stb r10, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 825DFD9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DFDA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DFDA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DFDA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DFDAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DFDB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFDB8 size=88
    let mut pc: u32 = 0x825DFDB8;
    'dispatch: loop {
        match pc {
            0x825DFDB8 => {
    //   block [0x825DFDB8..0x825DFE10)
	// 825DFDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DFDC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DFDC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DFDC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFDCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFDD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFDD4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DFDD8: 48AD2101  bl 0x830b1ed8
	ctx.lr = 0x825DFDDC;
	sub_830B1ED8(ctx, base);
	// 825DFDDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFDE0: 48832111  bl 0x82e11ef0
	ctx.lr = 0x825DFDE4;
	sub_82E11EF0(ctx, base);
	// 825DFDE4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DFDE8: 4182000C  beq 0x825dfdf4
	if ctx.cr[0].eq {
	pc = 0x825DFDF4; continue 'dispatch;
	}
	// 825DFDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFDF0: 488125E9  bl 0x82df23d8
	ctx.lr = 0x825DFDF4;
	sub_82DF23D8(ctx, base);
	// 825DFDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFDF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DFDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DFE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DFE04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DFE08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DFE0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DFE10 size=152
    let mut pc: u32 = 0x825DFE10;
    'dispatch: loop {
        match pc {
            0x825DFE10 => {
    //   block [0x825DFE10..0x825DFEA8)
	// 825DFE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFE14: 48BC8359  bl 0x831a816c
	ctx.lr = 0x825DFE18;
	sub_831A8130(ctx, base);
	// 825DFE18: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825DFE1C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFE20: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825DFE24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DFE28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DFE2C: 3BEB7E84  addi r31, r11, 0x7e84
	ctx.r[31].s64 = ctx.r[11].s64 + 32388;
	// 825DFE30: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DFE34: 816A7E88  lwz r11, 0x7e88(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32392 as u32) ) } as u64;
	// 825DFE38: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825DFE3C: 4082001C  bne 0x825dfe58
	if !ctx.cr[0].eq {
	pc = 0x825DFE58; continue 'dispatch;
	}
	// 825DFE40: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825DFE44: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825DFE48: 916A7E88  stw r11, 0x7e88(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32392 as u32), ctx.r[11].u32 ) };
	// 825DFE4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFE50: 38899428  addi r4, r9, -0x6bd8
	ctx.r[4].s64 = ctx.r[9].s64 + -27608;
	// 825DFE54: 488196DD  bl 0x82df9530
	ctx.lr = 0x825DFE58;
	sub_82DF9530(ctx, base);
	// 825DFE58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFE5C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825DFE60: 409A003C  bne cr6, 0x825dfe9c
	if !ctx.cr[6].eq {
	pc = 0x825DFE9C; continue 'dispatch;
	}
	// 825DFE64: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 825DFE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFE6C: 48AD2115  bl 0x830b1f80
	ctx.lr = 0x825DFE70;
	sub_830B1F80(ctx, base);
	// 825DFE70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DFE74: 41820028  beq 0x825dfe9c
	if ctx.cr[0].eq {
	pc = 0x825DFE9C; continue 'dispatch;
	}
	// 825DFE78: 4BFFD871  bl 0x825dd6e8
	ctx.lr = 0x825DFE7C;
	sub_825DD6E8(ctx, base);
	// 825DFE7C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825DFE80: C03D0010  lfs f1, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DFE84: 4BFFD855  bl 0x825dd6d8
	ctx.lr = 0x825DFE88;
	sub_825DD6D8(ctx, base);
	// 825DFE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFE8C: 48AD209D  bl 0x830b1f28
	ctx.lr = 0x825DFE90;
	sub_830B1F28(ctx, base);
	// 825DFE90: 48AD5431  bl 0x830b52c0
	ctx.lr = 0x825DFE94;
	sub_830B52C0(ctx, base);
	// 825DFE94: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825DFE98: 4BFFD841  bl 0x825dd6d8
	ctx.lr = 0x825DFE9C;
	sub_825DD6D8(ctx, base);
	// 825DFE9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DFEA0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825DFEA4: 48BC8318  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFEA8 size=24
    let mut pc: u32 = 0x825DFEA8;
    'dispatch: loop {
        match pc {
            0x825DFEA8 => {
    //   block [0x825DFEA8..0x825DFEC0)
	// 825DFEA8: 816300D0  lwz r11, 0xd0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 825DFEAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DFEB0: 994300CC  stb r10, 0xcc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[10].u8 ) };
	// 825DFEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFEB8: 994300CD  stb r10, 0xcd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(205 as u32), ctx.r[10].u8 ) };
	// 825DFEBC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFEC0 size=12
    let mut pc: u32 = 0x825DFEC0;
    'dispatch: loop {
        match pc {
            0x825DFEC0 => {
    //   block [0x825DFEC0..0x825DFECC)
	// 825DFEC0: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825DFEC4: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 825DFEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFED0 size=28
    let mut pc: u32 = 0x825DFED0;
    'dispatch: loop {
        match pc {
            0x825DFED0 => {
    //   block [0x825DFED0..0x825DFEEC)
	// 825DFED0: 816300D0  lwz r11, 0xd0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 825DFED4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825DFED8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DFEDC: 992300CC  stb r9, 0xcc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[9].u8 ) };
	// 825DFEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFEE4: 994300CD  stb r10, 0xcd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(205 as u32), ctx.r[10].u8 ) };
	// 825DFEE8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFEEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFEEC size=12
    let mut pc: u32 = 0x825DFEEC;
    'dispatch: loop {
        match pc {
            0x825DFEEC => {
    //   block [0x825DFEEC..0x825DFEF8)
	// 825DFEEC: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 825DFEF0: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 825DFEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFEF8 size=196
    let mut pc: u32 = 0x825DFEF8;
    'dispatch: loop {
        match pc {
            0x825DFEF8 => {
    //   block [0x825DFEF8..0x825DFFBC)
	// 825DFEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DFF00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DFF04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DFF08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFF0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DFF10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DFF14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DFF18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DFF1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DFF20: 4BCE0A19  bl 0x822c0938
	ctx.lr = 0x825DFF24;
	sub_822C0938(ctx, base);
	// 825DFF24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DFF28: 41820028  beq 0x825dff50
	if ctx.cr[0].eq {
	pc = 0x825DFF50; continue 'dispatch;
	}
	// 825DFF2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DFF30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825DFF34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DFF38: 392BF044  addi r9, r11, -0xfbc
	ctx.r[9].s64 = ctx.r[11].s64 + -4028;
	// 825DFF3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DFF40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DFF44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DFF48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DFF4C: 48000008  b 0x825dff54
	pc = 0x825DFF54; continue 'dispatch;
	// 825DFF50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DFF54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DFF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFF5C: 409A0044  bne cr6, 0x825dffa0
	if !ctx.cr[6].eq {
	pc = 0x825DFFA0; continue 'dispatch;
	}
	// 825DFF60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DFF64: 419A001C  beq cr6, 0x825dff80
	if ctx.cr[6].eq {
	pc = 0x825DFF80; continue 'dispatch;
	}
	// 825DFF68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFF6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DFF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFF74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFF78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DFF7C: 4E800421  bctrl
	ctx.lr = 0x825DFF80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DFF80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DFF84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DFF88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DFF8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825DFF90: 816BD598  lwz r11, -0x2a68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10856 as u32) ) } as u64;
	// 825DFF94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DFF98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DFF9C: 4BCE0065  bl 0x822c0000
	ctx.lr = 0x825DFFA0;
	sub_822C0000(ctx, base);
	// 825DFFA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DFFA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DFFA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DFFAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DFFB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DFFB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DFFB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DFFC0 size=156
    let mut pc: u32 = 0x825DFFC0;
    'dispatch: loop {
        match pc {
            0x825DFFC0 => {
    //   block [0x825DFFC0..0x825E005C)
	// 825DFFC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFFC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DFFC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DFFCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DFFD0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825DFFD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFFD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFFDC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825DFFE0: 4BF31111  bl 0x825110f0
	ctx.lr = 0x825DFFE4;
	sub_825110F0(ctx, base);
	// 825DFFE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DFFE8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DFFEC: 396BF06C  addi r11, r11, -0xf94
	ctx.r[11].s64 = ctx.r[11].s64 + -3988;
	// 825DFFF0: 394AF058  addi r10, r10, -0xfa8
	ctx.r[10].s64 = ctx.r[10].s64 + -4008;
	// 825DFFF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DFFF8: 3BDF00C0  addi r30, r31, 0xc0
	ctx.r[30].s64 = ctx.r[31].s64 + 192;
	// 825DFFFC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E0000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0004: 48AD1EBD  bl 0x830b1ec0
	ctx.lr = 0x825E0008;
	sub_830B1EC0(ctx, base);
	// 825E0008: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E000C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E0010: 396BD3F0  addi r11, r11, -0x2c10
	ctx.r[11].s64 = ctx.r[11].s64 + -11280;
	// 825E0014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0018: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825E001C: 48AD1F7D  bl 0x830b1f98
	ctx.lr = 0x825E0020;
	sub_830B1F98(ctx, base);
	// 825E0020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0028: D3FF00C8  stfs f31, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 825E002C: 997F00CC  stb r11, 0xcc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 825E0030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0034: 995F00CD  stb r10, 0xcd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(205 as u32), ctx.r[10].u8 ) };
	// 825E0038: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825E003C: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 825E0040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E0048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E004C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825E0050: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0060 size=8
    let mut pc: u32 = 0x825E0060;
    'dispatch: loop {
        match pc {
            0x825E0060 => {
    //   block [0x825E0060..0x825E0068)
	// 825E0060: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E0064: 48000004  b 0x825e0068
	sub_825E0068(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0068 size=104
    let mut pc: u32 = 0x825E0068;
    'dispatch: loop {
        match pc {
            0x825E0068 => {
    //   block [0x825E0068..0x825E00D0)
	// 825E0068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E006C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E007C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E0080: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E0084: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825E0088: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E008C: 419A0008  beq cr6, 0x825e0094
	if ctx.cr[6].eq {
	pc = 0x825E0094; continue 'dispatch;
	}
	// 825E0090: 4BCE0801  bl 0x822c0890
	ctx.lr = 0x825E0094;
	sub_822C0890(ctx, base);
	// 825E0094: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825E0098: 48AD1E41  bl 0x830b1ed8
	ctx.lr = 0x825E009C;
	sub_830B1ED8(ctx, base);
	// 825E009C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E00A0: 4BF310F9  bl 0x82511198
	ctx.lr = 0x825E00A4;
	sub_82511198(ctx, base);
	// 825E00A4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E00A8: 4182000C  beq 0x825e00b4
	if ctx.cr[0].eq {
	pc = 0x825E00B4; continue 'dispatch;
	}
	// 825E00AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E00B0: 48812329  bl 0x82df23d8
	ctx.lr = 0x825E00B4;
	sub_82DF23D8(ctx, base);
	// 825E00B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E00B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E00BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E00C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E00C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E00C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E00CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E00D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E00D0 size=144
    let mut pc: u32 = 0x825E00D0;
    'dispatch: loop {
        match pc {
            0x825E00D0 => {
    //   block [0x825E00D0..0x825E0160)
	// 825E00D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E00D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E00D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E00DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E00E0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825E00E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E00E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E00EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825E00F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E00F4: 4BF30FFD  bl 0x825110f0
	ctx.lr = 0x825E00F8;
	sub_825110F0(ctx, base);
	// 825E00F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E00FC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E0100: 396BF06C  addi r11, r11, -0xf94
	ctx.r[11].s64 = ctx.r[11].s64 + -3988;
	// 825E0104: 394AF058  addi r10, r10, -0xfa8
	ctx.r[10].s64 = ctx.r[10].s64 + -4008;
	// 825E0108: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E010C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E0110: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E0114: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825E0118: 4BEB9C99  bl 0x82499db0
	ctx.lr = 0x825E011C;
	sub_82499DB0(ctx, base);
	// 825E011C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0120: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0124: D3FF00C8  stfs f31, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 825E0128: 997F00CC  stb r11, 0xcc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 825E012C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0130: 995F00CD  stb r10, 0xcd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(205 as u32), ctx.r[10].u8 ) };
	// 825E0134: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825E0138: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 825E013C: 48AD1D9D  bl 0x830b1ed8
	ctx.lr = 0x825E0140;
	sub_830B1ED8(ctx, base);
	// 825E0140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E014C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E0150: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825E0154: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E015C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0160 size=112
    let mut pc: u32 = 0x825E0160;
    'dispatch: loop {
        match pc {
            0x825E0160 => {
    //   block [0x825E0160..0x825E01D0)
	// 825E0160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E016C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0174: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E0178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E017C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825E0180: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E0184: 4BFFFD75  bl 0x825dfef8
	ctx.lr = 0x825E0188;
	sub_825DFEF8(ctx, base);
	// 825E0188: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E018C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E0190: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E0194: 4BCDFE6D  bl 0x822c0000
	ctx.lr = 0x825E0198;
	sub_822C0000(ctx, base);
	// 825E0198: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E019C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E01A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E01A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E01A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E01AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E01B0: 419A0008  beq cr6, 0x825e01b8
	if ctx.cr[6].eq {
	pc = 0x825E01B8; continue 'dispatch;
	}
	// 825E01B4: 4BCE06DD  bl 0x822c0890
	ctx.lr = 0x825E01B8;
	sub_822C0890(ctx, base);
	// 825E01B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E01BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E01C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E01C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E01C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E01CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E01D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E01D0 size=380
    let mut pc: u32 = 0x825E01D0;
    'dispatch: loop {
        match pc {
            0x825E01D0 => {
    //   block [0x825E01D0..0x825E034C)
	// 825E01D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E01D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E01D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E01DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E01E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E01E4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 825E01E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E01EC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E01F0: 4BF2F181  bl 0x8250f370
	ctx.lr = 0x825E01F4;
	sub_8250F370(ctx, base);
	// 825E01F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E01F8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825E01FC: 409A0008  bne cr6, 0x825e0204
	if !ctx.cr[6].eq {
	pc = 0x825E0204; continue 'dispatch;
	}
	// 825E0200: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E0204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0208: 4BF28599  bl 0x825087a0
	ctx.lr = 0x825E020C;
	sub_825087A0(ctx, base);
	// 825E020C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E0210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0214: 808BE258  lwz r4, -0x1da8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7592 as u32) ) } as u64;
	// 825E0218: 488137F1  bl 0x82df3a08
	ctx.lr = 0x825E021C;
	sub_82DF3A08(ctx, base);
	// 825E021C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E0220: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E0224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0228: 4BF28559  bl 0x82508780
	ctx.lr = 0x825E022C;
	sub_82508780(ctx, base);
	// 825E022C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0230: 488131F9  bl 0x82df3428
	ctx.lr = 0x825E0234;
	sub_82DF3428(ctx, base);
	// 825E0234: 3BDF00C0  addi r30, r31, 0xc0
	ctx.r[30].s64 = ctx.r[31].s64 + 192;
	// 825E0238: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E023C: 48AD1D45  bl 0x830b1f80
	ctx.lr = 0x825E0240;
	sub_830B1F80(ctx, base);
	// 825E0240: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0244: 418200F0  beq 0x825e0334
	if ctx.cr[0].eq {
	pc = 0x825E0334; continue 'dispatch;
	}
	// 825E0248: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E024C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E0250: 388BF094  addi r4, r11, -0xf6c
	ctx.r[4].s64 = ctx.r[11].s64 + -3948;
	// 825E0254: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 825E0258: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825E025C: 4881218D  bl 0x82df23e8
	ctx.lr = 0x825E0260;
	sub_82DF23E8(ctx, base);
	// 825E0260: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0264: 41820014  beq 0x825e0278
	if ctx.cr[0].eq {
	pc = 0x825E0278; continue 'dispatch;
	}
	// 825E0268: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E026C: 4BFFFAE5  bl 0x825dfd50
	ctx.lr = 0x825E0270;
	sub_825DFD50(ctx, base);
	// 825E0270: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E0274: 48000008  b 0x825e027c
	pc = 0x825E027C; continue 'dispatch;
	// 825E0278: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E027C: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 825E0280: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0284: 4BFFFEDD  bl 0x825e0160
	ctx.lr = 0x825E0288;
	sub_825E0160(ctx, base);
	// 825E0288: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825E028C: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 825E0290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E0294: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825E0298: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825E029C: 419A0024  beq cr6, 0x825e02c0
	if ctx.cr[6].eq {
	pc = 0x825E02C0; continue 'dispatch;
	}
	// 825E02A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E02A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E02A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E02AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E02B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E02B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E02B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E02BC: 4082FFE8  bne 0x825e02a4
	if !ctx.cr[0].eq {
	pc = 0x825E02A4; continue 'dispatch;
	}
	// 825E02C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E02C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E02C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E02CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E02D0: 808B7090  lwz r4, 0x7090(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28816 as u32) ) } as u64;
	// 825E02D4: 4BF30725  bl 0x825109f8
	ctx.lr = 0x825E02D8;
	sub_825109F8(ctx, base);
	// 825E02D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E02DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E02E0: 419A0008  beq cr6, 0x825e02e8
	if ctx.cr[6].eq {
	pc = 0x825E02E8; continue 'dispatch;
	}
	// 825E02E4: 4BCE05AD  bl 0x822c0890
	ctx.lr = 0x825E02E8;
	sub_822C0890(ctx, base);
	// 825E02E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E02EC: C01F00C8  lfs f0, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E02F0: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825E02F4: 897F00CC  lbz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 825E02F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E02FC: 41820038  beq 0x825e0334
	if ctx.cr[0].eq {
	pc = 0x825E0334; continue 'dispatch;
	}
	// 825E0300: 897F00CD  lbz r11, 0xcd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(205 as u32) ) } as u64;
	// 825E0304: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0308: 41820018  beq 0x825e0320
	if ctx.cr[0].eq {
	pc = 0x825E0320; continue 'dispatch;
	}
	// 825E030C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825E0314: 996A0014  stb r11, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825E0318: 996A0015  stb r11, 0x15(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 825E031C: 48000018  b 0x825e0334
	pc = 0x825E0334; continue 'dispatch;
	// 825E0320: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0324: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0328: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825E032C: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825E0330: 992B0015  stb r9, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 825E0334: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E0338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E033C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E0340: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0350 size=248
    let mut pc: u32 = 0x825E0350;
    'dispatch: loop {
        match pc {
            0x825E0350 => {
    //   block [0x825E0350..0x825E0448)
	// 825E0350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E035C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0364: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E0368: 3BFE00C0  addi r31, r30, 0xc0
	ctx.r[31].s64 = ctx.r[30].s64 + 192;
	// 825E036C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0370: 48AD1CB9  bl 0x830b2028
	ctx.lr = 0x825E0374;
	sub_830B2028(ctx, base);
	// 825E0374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0378: 48AD1C09  bl 0x830b1f80
	ctx.lr = 0x825E037C;
	sub_830B1F80(ctx, base);
	// 825E037C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0380: 418200B0  beq 0x825e0430
	if ctx.cr[0].eq {
	pc = 0x825E0430; continue 'dispatch;
	}
	// 825E0384: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0388: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E038C: 388BF094  addi r4, r11, -0xf6c
	ctx.r[4].s64 = ctx.r[11].s64 + -3948;
	// 825E0390: 38A00087  li r5, 0x87
	ctx.r[5].s64 = 135;
	// 825E0394: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825E0398: 48812051  bl 0x82df23e8
	ctx.lr = 0x825E039C;
	sub_82DF23E8(ctx, base);
	// 825E039C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E03A0: 41820014  beq 0x825e03b4
	if ctx.cr[0].eq {
	pc = 0x825E03B4; continue 'dispatch;
	}
	// 825E03A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E03A8: 4BFFF9A9  bl 0x825dfd50
	ctx.lr = 0x825E03AC;
	sub_825DFD50(ctx, base);
	// 825E03AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E03B0: 48000008  b 0x825e03b8
	pc = 0x825E03B8; continue 'dispatch;
	// 825E03B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E03B8: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 825E03BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E03C0: 4BFFFDA1  bl 0x825e0160
	ctx.lr = 0x825E03C4;
	sub_825E0160(ctx, base);
	// 825E03C4: 817E00D4  lwz r11, 0xd4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 825E03C8: 815E00D0  lwz r10, 0xd0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825E03CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E03D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E03D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E03D8: 419A0024  beq cr6, 0x825e03fc
	if ctx.cr[6].eq {
	pc = 0x825E03FC; continue 'dispatch;
	}
	// 825E03DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E03E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E03E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E03E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E03EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E03F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E03F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E03F8: 4082FFE8  bne 0x825e03e0
	if !ctx.cr[0].eq {
	pc = 0x825E03E0; continue 'dispatch;
	}
	// 825E03FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E0400: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E0404: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E0408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E040C: 808B7090  lwz r4, 0x7090(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28816 as u32) ) } as u64;
	// 825E0410: 4BF305E9  bl 0x825109f8
	ctx.lr = 0x825E0414;
	sub_825109F8(ctx, base);
	// 825E0414: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E0418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E041C: 419A0008  beq cr6, 0x825e0424
	if ctx.cr[6].eq {
	pc = 0x825E0424; continue 'dispatch;
	}
	// 825E0420: 4BCE0471  bl 0x822c0890
	ctx.lr = 0x825E0424;
	sub_822C0890(ctx, base);
	// 825E0424: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0428: C01E00C8  lfs f0, 0xc8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E042C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825E0430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E0438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E043C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0448 size=12
    let mut pc: u32 = 0x825E0448;
    'dispatch: loop {
        match pc {
            0x825E0448 => {
    //   block [0x825E0448..0x825E0454)
	// 825E0448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825E044C: 996300EC  stb r11, 0xec(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 825E0450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0458 size=12
    let mut pc: u32 = 0x825E0458;
    'dispatch: loop {
        match pc {
            0x825E0458 => {
    //   block [0x825E0458..0x825E0464)
	// 825E0458: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E045C: 996300EC  stb r11, 0xec(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 825E0460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0468 size=92
    let mut pc: u32 = 0x825E0468;
    'dispatch: loop {
        match pc {
            0x825E0468 => {
    //   block [0x825E0468..0x825E04C4)
	// 825E0468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E046C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E047C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E0480: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E0484: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E0488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E048C: 80BE0160  lwz r5, 0x160(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 825E0490: 4BF28771  bl 0x82508c00
	ctx.lr = 0x825E0494;
	sub_82508C00(ctx, base);
	// 825E0494: 80BE0170  lwz r5, 0x170(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 825E0498: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825E049C: 419A0010  beq cr6, 0x825e04ac
	if ctx.cr[6].eq {
	pc = 0x825E04AC; continue 'dispatch;
	}
	// 825E04A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E04A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E04A8: 4BF28759  bl 0x82508c00
	ctx.lr = 0x825E04AC;
	sub_82508C00(ctx, base);
	// 825E04AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E04B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E04B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E04B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E04BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E04C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E04C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E04C8 size=160
    let mut pc: u32 = 0x825E04C8;
    'dispatch: loop {
        match pc {
            0x825E04C8 => {
    //   block [0x825E04C8..0x825E0568)
	// 825E04C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E04CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E04D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E04D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E04D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E04DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E04E0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825E04E4: 4BF31675  bl 0x82511b58
	ctx.lr = 0x825E04E8;
	sub_82511B58(ctx, base);
	// 825E04E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E04EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E04F0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E04F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E04F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E04FC: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0500: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825E0504: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825E0508: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E050C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825E0510: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0514: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825E0518: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E051C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0520: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E0524: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825E0528: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825E052C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825E0530: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825E0534: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825E0538: 4889B961  bl 0x82e7be98
	ctx.lr = 0x825E053C;
	sub_82E7BE98(ctx, base);
	// 825E053C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E0540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0544: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E0548: 4889B801  bl 0x82e7bd48
	ctx.lr = 0x825E054C;
	sub_82E7BD48(ctx, base);
	// 825E054C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0550: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825E0554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E0558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E055C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0568 size=120
    let mut pc: u32 = 0x825E0568;
    'dispatch: loop {
        match pc {
            0x825E0568 => {
    //   block [0x825E0568..0x825E05E0)
	// 825E0568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E056C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0574: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0578: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E057C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E0580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E0584: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825E0588: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E058C: C1AAF1A0  lfs f13, -0xe60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-3680 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E0590: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825E0594: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825E0598: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825E059C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825E05A0: 4BF315B9  bl 0x82511b58
	ctx.lr = 0x825E05A4;
	sub_82511B58(ctx, base);
	// 825E05A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E05A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E05AC: 4889B8ED  bl 0x82e7be98
	ctx.lr = 0x825E05B0;
	sub_82E7BE98(ctx, base);
	// 825E05B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E05B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E05B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E05BC: 4889B78D  bl 0x82e7bd48
	ctx.lr = 0x825E05C0;
	sub_82E7BD48(ctx, base);
	// 825E05C0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E05E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E05E0 size=196
    let mut pc: u32 = 0x825E05E0;
    'dispatch: loop {
        match pc {
            0x825E05E0 => {
    //   block [0x825E05E0..0x825E06A4)
	// 825E05E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E05E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E05E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E05EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E05F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E05F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E05F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E05FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E0600: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E0604: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0608: 4BCE0331  bl 0x822c0938
	ctx.lr = 0x825E060C;
	sub_822C0938(ctx, base);
	// 825E060C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0610: 41820028  beq 0x825e0638
	if ctx.cr[0].eq {
	pc = 0x825E0638; continue 'dispatch;
	}
	// 825E0614: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0618: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E061C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0620: 392BF1B8  addi r9, r11, -0xe48
	ctx.r[9].s64 = ctx.r[11].s64 + -3656;
	// 825E0624: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E0628: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E062C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E0630: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E0634: 48000008  b 0x825e063c
	pc = 0x825E063C; continue 'dispatch;
	// 825E0638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E063C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E0644: 409A0044  bne cr6, 0x825e0688
	if !ctx.cr[6].eq {
	pc = 0x825E0688; continue 'dispatch;
	}
	// 825E0648: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E064C: 419A001C  beq cr6, 0x825e0668
	if ctx.cr[6].eq {
	pc = 0x825E0668; continue 'dispatch;
	}
	// 825E0650: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0654: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E0658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E065C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0660: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E0664: 4E800421  bctrl
	ctx.lr = 0x825E0668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E0668: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E066C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E0670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0674: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E0678: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E067C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E0680: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E0684: 4BCDF97D  bl 0x822c0000
	ctx.lr = 0x825E0688;
	sub_822C0000(ctx, base);
	// 825E0688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E068C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E0694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E0698: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E069C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E06A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E06A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E06A8 size=196
    let mut pc: u32 = 0x825E06A8;
    'dispatch: loop {
        match pc {
            0x825E06A8 => {
    //   block [0x825E06A8..0x825E076C)
	// 825E06A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E06AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E06B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E06B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E06B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E06BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E06C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E06C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E06C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E06CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E06D0: 4BCE0269  bl 0x822c0938
	ctx.lr = 0x825E06D4;
	sub_822C0938(ctx, base);
	// 825E06D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E06D8: 41820028  beq 0x825e0700
	if ctx.cr[0].eq {
	pc = 0x825E0700; continue 'dispatch;
	}
	// 825E06DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E06E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E06E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E06E8: 392BF1E0  addi r9, r11, -0xe20
	ctx.r[9].s64 = ctx.r[11].s64 + -3616;
	// 825E06EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E06F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E06F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E06F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E06FC: 48000008  b 0x825e0704
	pc = 0x825E0704; continue 'dispatch;
	// 825E0700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0704: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E070C: 409A0044  bne cr6, 0x825e0750
	if !ctx.cr[6].eq {
	pc = 0x825E0750; continue 'dispatch;
	}
	// 825E0710: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E0714: 419A001C  beq cr6, 0x825e0730
	if ctx.cr[6].eq {
	pc = 0x825E0730; continue 'dispatch;
	}
	// 825E0718: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E071C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E0720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0724: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E0728: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E072C: 4E800421  bctrl
	ctx.lr = 0x825E0730;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E0730: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E0734: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E0738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E073C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E0740: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E0744: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E0748: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E074C: 4BCDF8B5  bl 0x822c0000
	ctx.lr = 0x825E0750;
	sub_822C0000(ctx, base);
	// 825E0750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E075C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E0760: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0770 size=196
    let mut pc: u32 = 0x825E0770;
    'dispatch: loop {
        match pc {
            0x825E0770 => {
    //   block [0x825E0770..0x825E0834)
	// 825E0770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E077C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E0788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E078C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E0790: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E0794: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0798: 4BCE01A1  bl 0x822c0938
	ctx.lr = 0x825E079C;
	sub_822C0938(ctx, base);
	// 825E079C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E07A0: 41820028  beq 0x825e07c8
	if ctx.cr[0].eq {
	pc = 0x825E07C8; continue 'dispatch;
	}
	// 825E07A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E07A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E07AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E07B0: 392BF1F4  addi r9, r11, -0xe0c
	ctx.r[9].s64 = ctx.r[11].s64 + -3596;
	// 825E07B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E07B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E07BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E07C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E07C4: 48000008  b 0x825e07cc
	pc = 0x825E07CC; continue 'dispatch;
	// 825E07C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E07CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E07D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E07D4: 409A0044  bne cr6, 0x825e0818
	if !ctx.cr[6].eq {
	pc = 0x825E0818; continue 'dispatch;
	}
	// 825E07D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E07DC: 419A001C  beq cr6, 0x825e07f8
	if ctx.cr[6].eq {
	pc = 0x825E07F8; continue 'dispatch;
	}
	// 825E07E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E07E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E07E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E07EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E07F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E07F4: 4E800421  bctrl
	ctx.lr = 0x825E07F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E07F8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E07FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E0800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0804: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E0808: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E080C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E0810: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E0814: 4BCDF7ED  bl 0x822c0000
	ctx.lr = 0x825E0818;
	sub_822C0000(ctx, base);
	// 825E0818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E081C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E0824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E0828: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E082C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0838 size=196
    let mut pc: u32 = 0x825E0838;
    'dispatch: loop {
        match pc {
            0x825E0838 => {
    //   block [0x825E0838..0x825E08FC)
	// 825E0838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E083C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E084C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E0850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0854: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E0858: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E085C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0860: 4BCE00D9  bl 0x822c0938
	ctx.lr = 0x825E0864;
	sub_822C0938(ctx, base);
	// 825E0864: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0868: 41820028  beq 0x825e0890
	if ctx.cr[0].eq {
	pc = 0x825E0890; continue 'dispatch;
	}
	// 825E086C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0870: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E0874: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0878: 392BF208  addi r9, r11, -0xdf8
	ctx.r[9].s64 = ctx.r[11].s64 + -3576;
	// 825E087C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E0880: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E0884: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E0888: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E088C: 48000008  b 0x825e0894
	pc = 0x825E0894; continue 'dispatch;
	// 825E0890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0894: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E089C: 409A0044  bne cr6, 0x825e08e0
	if !ctx.cr[6].eq {
	pc = 0x825E08E0; continue 'dispatch;
	}
	// 825E08A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E08A4: 419A001C  beq cr6, 0x825e08c0
	if ctx.cr[6].eq {
	pc = 0x825E08C0; continue 'dispatch;
	}
	// 825E08A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E08AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E08B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E08B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E08B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E08BC: 4E800421  bctrl
	ctx.lr = 0x825E08C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E08C0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E08C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E08C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E08CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E08D0: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E08D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E08D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E08DC: 4BCDF725  bl 0x822c0000
	ctx.lr = 0x825E08E0;
	sub_822C0000(ctx, base);
	// 825E08E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E08E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E08E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E08EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E08F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E08F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E08F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0900 size=196
    let mut pc: u32 = 0x825E0900;
    'dispatch: loop {
        match pc {
            0x825E0900 => {
    //   block [0x825E0900..0x825E09C4)
	// 825E0900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E090C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E0918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E091C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E0920: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E0924: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0928: 4BCE0011  bl 0x822c0938
	ctx.lr = 0x825E092C;
	sub_822C0938(ctx, base);
	// 825E092C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E0930: 41820028  beq 0x825e0958
	if ctx.cr[0].eq {
	pc = 0x825E0958; continue 'dispatch;
	}
	// 825E0934: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0938: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E093C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0940: 392BF21C  addi r9, r11, -0xde4
	ctx.r[9].s64 = ctx.r[11].s64 + -3556;
	// 825E0944: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E0948: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E094C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E0950: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E0954: 48000008  b 0x825e095c
	pc = 0x825E095C; continue 'dispatch;
	// 825E0958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E095C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E0964: 409A0044  bne cr6, 0x825e09a8
	if !ctx.cr[6].eq {
	pc = 0x825E09A8; continue 'dispatch;
	}
	// 825E0968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E096C: 419A001C  beq cr6, 0x825e0988
	if ctx.cr[6].eq {
	pc = 0x825E0988; continue 'dispatch;
	}
	// 825E0970: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0974: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E0978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E097C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E0984: 4E800421  bctrl
	ctx.lr = 0x825E0988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E0988: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E098C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E0990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0994: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E0998: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E099C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E09A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E09A4: 4BCDF65D  bl 0x822c0000
	ctx.lr = 0x825E09A8;
	sub_822C0000(ctx, base);
	// 825E09A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E09AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E09B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E09B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E09B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E09BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E09C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E09C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E09C8 size=196
    let mut pc: u32 = 0x825E09C8;
    'dispatch: loop {
        match pc {
            0x825E09C8 => {
    //   block [0x825E09C8..0x825E0A8C)
	// 825E09C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E09CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E09D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E09D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E09D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E09DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E09E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E09E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E09E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E09EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E09F0: 4BCDFF49  bl 0x822c0938
	ctx.lr = 0x825E09F4;
	sub_822C0938(ctx, base);
	// 825E09F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E09F8: 41820028  beq 0x825e0a20
	if ctx.cr[0].eq {
	pc = 0x825E0A20; continue 'dispatch;
	}
	// 825E09FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0A00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E0A04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0A08: 392BF230  addi r9, r11, -0xdd0
	ctx.r[9].s64 = ctx.r[11].s64 + -3536;
	// 825E0A0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E0A10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E0A14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E0A18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E0A1C: 48000008  b 0x825e0a24
	pc = 0x825E0A24; continue 'dispatch;
	// 825E0A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0A24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E0A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E0A2C: 409A0044  bne cr6, 0x825e0a70
	if !ctx.cr[6].eq {
	pc = 0x825E0A70; continue 'dispatch;
	}
	// 825E0A30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E0A34: 419A001C  beq cr6, 0x825e0a50
	if ctx.cr[6].eq {
	pc = 0x825E0A50; continue 'dispatch;
	}
	// 825E0A38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0A3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E0A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0A44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0A48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E0A4C: 4E800421  bctrl
	ctx.lr = 0x825E0A50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E0A50: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E0A54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E0A58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0A5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E0A60: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E0A64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E0A68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E0A6C: 4BCDF595  bl 0x822c0000
	ctx.lr = 0x825E0A70;
	sub_822C0000(ctx, base);
	// 825E0A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E0A74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E0A78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E0A7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E0A80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E0A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E0A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0A90 size=96
    let mut pc: u32 = 0x825E0A90;
    'dispatch: loop {
        match pc {
            0x825E0A90 => {
    //   block [0x825E0A90..0x825E0AF0)
	// 825E0A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0A98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0A9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E0AA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E0AAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E0AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E0AB4: 4BFFFAB5  bl 0x825e0568
	ctx.lr = 0x825E0AB8;
	sub_825E0568(ctx, base);
	// 825E0AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0ABC: 4BF3102D  bl 0x82511ae8
	ctx.lr = 0x825E0AC0;
	sub_82511AE8(ctx, base);
	// 825E0AC0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E0AC4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E0AC8: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825E0ACC: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0AF0 size=460
    let mut pc: u32 = 0x825E0AF0;
    'dispatch: loop {
        match pc {
            0x825E0AF0 => {
    //   block [0x825E0AF0..0x825E0CBC)
	// 825E0AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0B00: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825E0B04: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825E0B08: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0CC0 size=436
    let mut pc: u32 = 0x825E0CC0;
    'dispatch: loop {
        match pc {
            0x825E0CC0 => {
    //   block [0x825E0CC0..0x825E0E74)
	// 825E0CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0CC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0CCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0CD0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825E0CD4: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0CD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E0CDC: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825E0CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E0CE4: 419A0174  beq cr6, 0x825e0e58
	if ctx.cr[6].eq {
	pc = 0x825E0E58; continue 'dispatch;
	}
	// 825E0CE8: 4BF30E01  bl 0x82511ae8
	ctx.lr = 0x825E0CEC;
	sub_82511AE8(ctx, base);
	// 825E0CEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E0CF0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E0CF4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E0CF8: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825E0CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0D00: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E0D04: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0D08: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E0D0C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825E0D10: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825E0D14: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825E0D18: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0E78 size=360
    let mut pc: u32 = 0x825E0E78;
    'dispatch: loop {
        match pc {
            0x825E0E78 => {
    //   block [0x825E0E78..0x825E0FE0)
	// 825E0E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0E80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0E84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0E88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E0E90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E0E94: 4BF3149D  bl 0x82512330
	ctx.lr = 0x825E0E98;
	sub_82512330(ctx, base);
	// 825E0E98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0E9C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825E0EA0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825E0EA4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E0EA8: 4887CA29  bl 0x82e5d8d0
	ctx.lr = 0x825E0EAC;
	sub_82E5D8D0(ctx, base);
	// 825E0EAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E0EB0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E0EB4: 396BF1A8  addi r11, r11, -0xe58
	ctx.r[11].s64 = ctx.r[11].s64 + -3672;
	// 825E0EB8: 394AF314  addi r10, r10, -0xcec
	ctx.r[10].s64 = ctx.r[10].s64 + -3308;
	// 825E0EBC: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825E0EC0: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825E0EC4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E0EC8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E0ECC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E0ED0: 3929F2F0  addi r9, r9, -0xd10
	ctx.r[9].s64 = ctx.r[9].s64 + -3344;
	// 825E0ED4: 3947F304  addi r10, r7, -0xcfc
	ctx.r[10].s64 = ctx.r[7].s64 + -3324;
	// 825E0ED8: 3908F2A4  addi r8, r8, -0xd5c
	ctx.r[8].s64 = ctx.r[8].s64 + -3420;
	// 825E0EDC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E0EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0EE4: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 825E0EE8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825E0EEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E0EF0: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 825E0EF4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825E0EF8: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 825E0EFC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E0F00: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 825E0F04: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 825E0F08: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 825E0F0C: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 825E0F10: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 825E0F14: 3CA08338  lis r5, -0x7cc8
	ctx.r[5].s64 = -2093481984;
	// 825E0F18: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 825E0F1C: C00AE848  lfs f0, -0x17b8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6072 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0F20: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 825E0F24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E0F28: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 825E0F2C: C1A9D5B8  lfs f13, -0x2a48(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E0F30: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 825E0F34: 38A56910  addi r5, r5, 0x6910
	ctx.r[5].s64 = ctx.r[5].s64 + 26896;
	// 825E0F38: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 825E0F3C: C188D7BC  lfs f12, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E0F40: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 825E0F44: C1676218  lfs f11, 0x6218(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(25112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825E0F48: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825E0F4C: 392001C0  li r9, 0x1c0
	ctx.r[9].s64 = 448;
	// 825E0F50: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 825E0F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0F58: 917F017C  stw r11, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 825E0F5C: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 825E0F60: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 825E0F64: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 825E0F68: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 825E0F6C: C0069524  lfs f0, -0x6adc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0F70: 997F01A0  stb r11, 0x1a0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u8 ) };
	// 825E0F74: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825E0F78: 997F01A1  stb r11, 0x1a1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(417 as u32), ctx.r[11].u8 ) };
	// 825E0F7C: D19F0194  stfs f12, 0x194(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 825E0F80: 995F01A2  stb r10, 0x1a2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(418 as u32), ctx.r[10].u8 ) };
	// 825E0F84: D17F0198  stfs f11, 0x198(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 825E0F88: 995F01A3  stb r10, 0x1a3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(419 as u32), ctx.r[10].u8 ) };
	// 825E0F8C: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 825E0F90: 997F01A4  stb r11, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 825E0F94: 997F01A5  stb r11, 0x1a5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(421 as u32), ctx.r[11].u8 ) };
	// 825E0F98: 997F01A6  stb r11, 0x1a6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(422 as u32), ctx.r[11].u8 ) };
	// 825E0F9C: 997F01AC  stb r11, 0x1ac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u8 ) };
	// 825E0FA0: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 825E0FA4: 917F01B4  stw r11, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 825E0FA8: 997F01B8  stb r11, 0x1b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u8 ) };
	// 825E0FAC: 995F01B9  stb r10, 0x1b9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(441 as u32), ctx.r[10].u8 ) };
	// 825E0FB0: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0FE0 size=8
    let mut pc: u32 = 0x825E0FE0;
    'dispatch: loop {
        match pc {
            0x825E0FE0 => {
    //   block [0x825E0FE0..0x825E0FE8)
	// 825E0FE0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E0FE4: 4800043C  b 0x825e1420
	sub_825E1420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0FE8 size=8
    let mut pc: u32 = 0x825E0FE8;
    'dispatch: loop {
        match pc {
            0x825E0FE8 => {
    //   block [0x825E0FE8..0x825E0FF0)
	// 825E0FE8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825E0FEC: 48000434  b 0x825e1420
	sub_825E1420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0FF0 size=8
    let mut pc: u32 = 0x825E0FF0;
    'dispatch: loop {
        match pc {
            0x825E0FF0 => {
    //   block [0x825E0FF0..0x825E0FF8)
	// 825E0FF0: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 825E0FF4: 4800042C  b 0x825e1420
	sub_825E1420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0FF8 size=344
    let mut pc: u32 = 0x825E0FF8;
    'dispatch: loop {
        match pc {
            0x825E0FF8 => {
    //   block [0x825E0FF8..0x825E1150)
	// 825E0FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0FFC: 48BC7171  bl 0x831a816c
	ctx.lr = 0x825E1000;
	sub_831A8130(ctx, base);
	// 825E1000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E1004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E1008: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E100C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E1010: 396BF314  addi r11, r11, -0xcec
	ctx.r[11].s64 = ctx.r[11].s64 + -3308;
	// 825E1014: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E1018: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E101C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E1020: 394AF2F0  addi r10, r10, -0xd10
	ctx.r[10].s64 = ctx.r[10].s64 + -3344;
	// 825E1024: 3968F304  addi r11, r8, -0xcfc
	ctx.r[11].s64 = ctx.r[8].s64 + -3324;
	// 825E1028: 3929F2A4  addi r9, r9, -0xd5c
	ctx.r[9].s64 = ctx.r[9].s64 + -3420;
	// 825E102C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E1030: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825E1034: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825E1038: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825E103C: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 825E1040: 815F0148  lwz r10, 0x148(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 825E1044: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 825E1048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E104C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E1050: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E1054: 419A0024  beq cr6, 0x825e1078
	if ctx.cr[6].eq {
	pc = 0x825E1078; continue 'dispatch;
	}
	// 825E1058: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E105C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E1060: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E1064: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E1068: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E106C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E1070: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E1074: 4082FFE8  bne 0x825e105c
	if !ctx.cr[0].eq {
	pc = 0x825E105C; continue 'dispatch;
	}
	// 825E1078: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E107C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E1080: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E1084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E1088: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E108C: 4BF2F035  bl 0x825100c0
	ctx.lr = 0x825E1090;
	sub_825100C0(ctx, base);
	// 825E1090: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E1094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E1098: 419A0008  beq cr6, 0x825e10a0
	if ctx.cr[6].eq {
	pc = 0x825E10A0; continue 'dispatch;
	}
	// 825E109C: 4BCDF7F5  bl 0x822c0890
	ctx.lr = 0x825E10A0;
	sub_822C0890(ctx, base);
	// 825E10A0: 807F01B4  lwz r3, 0x1b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 825E10A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E10A8: 419A0008  beq cr6, 0x825e10b0
	if ctx.cr[6].eq {
	pc = 0x825E10B0; continue 'dispatch;
	}
	// 825E10AC: 4BCDF7E5  bl 0x822c0890
	ctx.lr = 0x825E10B0;
	sub_822C0890(ctx, base);
	// 825E10B0: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 825E10B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E10B8: 419A0008  beq cr6, 0x825e10c0
	if ctx.cr[6].eq {
	pc = 0x825E10C0; continue 'dispatch;
	}
	// 825E10BC: 4BCDF7D5  bl 0x822c0890
	ctx.lr = 0x825E10C0;
	sub_822C0890(ctx, base);
	// 825E10C0: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 825E10C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E10C8: 419A0008  beq cr6, 0x825e10d0
	if ctx.cr[6].eq {
	pc = 0x825E10D0; continue 'dispatch;
	}
	// 825E10CC: 4BCDF7C5  bl 0x822c0890
	ctx.lr = 0x825E10D0;
	sub_822C0890(ctx, base);
	// 825E10D0: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 825E10D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E10D8: 419A0008  beq cr6, 0x825e10e0
	if ctx.cr[6].eq {
	pc = 0x825E10E0; continue 'dispatch;
	}
	// 825E10DC: 4BCDF7B5  bl 0x822c0890
	ctx.lr = 0x825E10E0;
	sub_822C0890(ctx, base);
	// 825E10E0: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 825E10E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E10E8: 419A0008  beq cr6, 0x825e10f0
	if ctx.cr[6].eq {
	pc = 0x825E10F0; continue 'dispatch;
	}
	// 825E10EC: 4BCDF7A5  bl 0x822c0890
	ctx.lr = 0x825E10F0;
	sub_822C0890(ctx, base);
	// 825E10F0: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 825E10F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E10F8: 419A0008  beq cr6, 0x825e1100
	if ctx.cr[6].eq {
	pc = 0x825E1100; continue 'dispatch;
	}
	// 825E10FC: 4BCDF795  bl 0x822c0890
	ctx.lr = 0x825E1100;
	sub_822C0890(ctx, base);
	// 825E1100: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 825E1104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E1108: 419A0008  beq cr6, 0x825e1110
	if ctx.cr[6].eq {
	pc = 0x825E1110; continue 'dispatch;
	}
	// 825E110C: 4BCDF785  bl 0x822c0890
	ctx.lr = 0x825E1110;
	sub_822C0890(ctx, base);
	// 825E1110: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 825E1114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E1118: 419A0008  beq cr6, 0x825e1120
	if ctx.cr[6].eq {
	pc = 0x825E1120; continue 'dispatch;
	}
	// 825E111C: 4BCDF775  bl 0x822c0890
	ctx.lr = 0x825E1120;
	sub_822C0890(ctx, base);
	// 825E1120: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 825E1124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E1128: 419A0008  beq cr6, 0x825e1130
	if ctx.cr[6].eq {
	pc = 0x825E1130; continue 'dispatch;
	}
	// 825E112C: 4BCDF765  bl 0x822c0890
	ctx.lr = 0x825E1130;
	sub_822C0890(ctx, base);
	// 825E1130: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E1134: 4887C715  bl 0x82e5d848
	ctx.lr = 0x825E1138;
	sub_82E5D848(ctx, base);
	// 825E1138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E113C: 481C651D  bl 0x827a7658
	ctx.lr = 0x825E1140;
	sub_827A7658(ctx, base);
	// 825E1140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E1144: 4BD6E20D  bl 0x8234f350
	ctx.lr = 0x825E1148;
	sub_8234F350(ctx, base);
	// 825E1148: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E114C: 48BC7070  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E1150 size=408
    let mut pc: u32 = 0x825E1150;
    'dispatch: loop {
        match pc {
            0x825E1150 => {
    //   block [0x825E1150..0x825E12E8)
	// 825E1150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E1154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E1158: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E115C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E1160: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E1164: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E1168: 48B73499  bl 0x83154600
	ctx.lr = 0x825E116C;
	sub_83154600(ctx, base);
	// 825E116C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E1170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1174: 488785ED  bl 0x82e59760
	ctx.lr = 0x825E1178;
	sub_82E59760(ctx, base);
	// 825E1178: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E117C: C00BC5F0  lfs f0, -0x3a10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E1180: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E1184: 48BC7C45  bl 0x831a8dc8
	ctx.lr = 0x825E1188;
	sub_831A8DC8(ctx, base);
	// 825E1188: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825E118C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E1190: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E1194: 83FF01B0  lwz r31, 0x1b0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 825E1198: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E119C: C04B08A8  lfs f2, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E11A0: C00A0140  lfs f0, 0x140(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E11A4: EC2D103A  fmadds f1, f13, f0, f2
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[2].f64) as f32) as f64);
	// 825E11A8: FC600890  fmr f3, f1
	ctx.f[3].f64 = ctx.f[1].f64;
	// 825E11AC: 4889ADC5  bl 0x82e7bf70
	ctx.lr = 0x825E11B0;
	sub_82E7BF70(ctx, base);
	// 825E11B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E11B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E11B8: 488320A9  bl 0x82e13260
	ctx.lr = 0x825E11BC;
	sub_82E13260(ctx, base);
	// 825E11BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E11C0: 488785A1  bl 0x82e59760
	ctx.lr = 0x825E11C4;
	sub_82E59760(ctx, base);
	// 825E11C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E11C8: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 825E11CC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825E11D0: C00B9C28  lfs f0, -0x63d8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E11D4: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E11D8: C1AADFAC  lfs f13, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E11DC: C009A1C4  lfs f0, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E11E0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E11E4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825E11E8: 409900E8  ble cr6, 0x825e12d0
	if !ctx.cr[6].gt {
	pc = 0x825E12D0; continue 'dispatch;
	}
	// 825E11EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E11F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E11F4: 388BF350  addi r4, r11, -0xcb0
	ctx.r[4].s64 = ctx.r[11].s64 + -3248;
	// 825E11F8: 38A0018C  li r5, 0x18c
	ctx.r[5].s64 = 396;
	// 825E11FC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825E1200: 488111E9  bl 0x82df23e8
	ctx.lr = 0x825E1204;
	sub_82DF23E8(ctx, base);
	// 825E1204: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E1208: 4182001C  beq 0x825e1224
	if ctx.cr[0].eq {
	pc = 0x825E1224; continue 'dispatch;
	}
	// 825E120C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E1210: 4887B719  bl 0x82e5c928
	ctx.lr = 0x825E1214;
	sub_82E5C928(ctx, base);
	// 825E1214: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1218: 396BF26C  addi r11, r11, -0xd94
	ctx.r[11].s64 = ctx.r[11].s64 + -3476;
	// 825E121C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E1220: 48000008  b 0x825e1228
	pc = 0x825E1228; continue 'dispatch;
	// 825E1224: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E1228: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E122C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E1230: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1234: 4BFFF53D  bl 0x825e0770
	ctx.lr = 0x825E1238;
	sub_825E0770(ctx, base);
	// 825E1238: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E123C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E1240: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1244: 4BCDEDBD  bl 0x822c0000
	ctx.lr = 0x825E1248;
	sub_822C0000(ctx, base);
	// 825E1248: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E124C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E1250: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E1254: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825E1258: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E125C: 419A0024  beq cr6, 0x825e1280
	if ctx.cr[6].eq {
	pc = 0x825E1280; continue 'dispatch;
	}
	// 825E1260: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825E1264: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E1268: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E126C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E1270: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E1274: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E1278: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E127C: 4082FFE8  bne 0x825e1264
	if !ctx.cr[0].eq {
	pc = 0x825E1264; continue 'dispatch;
	}
	// 825E1280: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E1284: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E1288: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E128C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E1290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E1294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E1298: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E129C: 4887D625  bl 0x82e5e8c0
	ctx.lr = 0x825E12A0;
	sub_82E5E8C0(ctx, base);
	// 825E12A0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E12A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E12A8: 419A0008  beq cr6, 0x825e12b0
	if ctx.cr[6].eq {
	pc = 0x825E12B0; continue 'dispatch;
	}
	// 825E12AC: 4BCDF5E5  bl 0x822c0890
	ctx.lr = 0x825E12B0;
	sub_822C0890(ctx, base);
	// 825E12B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E12B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E12B8: 419A0008  beq cr6, 0x825e12c0
	if ctx.cr[6].eq {
	pc = 0x825E12C0; continue 'dispatch;
	}
	// 825E12BC: 4BCDF5D5  bl 0x822c0890
	ctx.lr = 0x825E12C0;
	sub_822C0890(ctx, base);
	// 825E12C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E12C4: 419A000C  beq cr6, 0x825e12d0
	if ctx.cr[6].eq {
	pc = 0x825E12D0; continue 'dispatch;
	}
	// 825E12C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E12CC: 4BCDF5C5  bl 0x822c0890
	ctx.lr = 0x825E12D0;
	sub_822C0890(ctx, base);
	// 825E12D0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825E12D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E12D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E12DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E12E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E12E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E12E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E12E8 size=180
    let mut pc: u32 = 0x825E12E8;
    'dispatch: loop {
        match pc {
            0x825E12E8 => {
    //   block [0x825E12E8..0x825E139C)
	// 825E12E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E12EC: 48BC6E6D  bl 0x831a8158
	ctx.lr = 0x825E12F0;
	sub_831A8130(ctx, base);
	// 825E12F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E12F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E12F8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825E12FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E1300: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E1304: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825E1308: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E130C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825E1310: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825E1314: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825E1318: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825E131C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825E1320: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825E1324: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 825E1328: 488110C1  bl 0x82df23e8
	ctx.lr = 0x825E132C;
	sub_82DF23E8(ctx, base);
	// 825E132C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E1330: 41820038  beq 0x825e1368
	if ctx.cr[0].eq {
	pc = 0x825E1368; continue 'dispatch;
	}
	// 825E1334: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E1338: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E133C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E1340: 89590000  lbz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E1344: 893A0000  lbz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E1348: C05C0000  lfs f2, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E134C: 891B0000  lbz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E1350: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E1354: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E1358: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 825E135C: 48574A4D  bl 0x82b55da8
	ctx.lr = 0x825E1360;
	sub_82B55DA8(ctx, base);
	// 825E1360: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E1364: 48000008  b 0x825e136c
	pc = 0x825E136C; continue 'dispatch;
	// 825E1368: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E136C: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E1370: 3BD80004  addi r30, r24, 4
	ctx.r[30].s64 = ctx.r[24].s64 + 4;
	// 825E1374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E1378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E137C: 4BDB1535  bl 0x823928b0
	ctx.lr = 0x825E1380;
	sub_823928B0(ctx, base);
	// 825E1380: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E1384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E1388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E138C: 4BCDEC75  bl 0x822c0000
	ctx.lr = 0x825E1390;
	sub_822C0000(ctx, base);
	// 825E1390: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825E1394: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825E1398: 48BC6E10  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E13A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E13A0 size=124
    let mut pc: u32 = 0x825E13A0;
    'dispatch: loop {
        match pc {
            0x825E13A0 => {
    //   block [0x825E13A0..0x825E141C)
	// 825E13A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E13A4: 48BC6DC9  bl 0x831a816c
	ctx.lr = 0x825E13A8;
	sub_831A8130(ctx, base);
	// 825E13A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E13AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E13B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E13B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E13B8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825E13BC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825E13C0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 825E13C4: 48811025  bl 0x82df23e8
	ctx.lr = 0x825E13C8;
	sub_82DF23E8(ctx, base);
	// 825E13C8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E13CC: 4182001C  beq 0x825e13e8
	if ctx.cr[0].eq {
	pc = 0x825E13E8; continue 'dispatch;
	}
	// 825E13D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E13D4: 488782CD  bl 0x82e596a0
	ctx.lr = 0x825E13D8;
	sub_82E596A0(ctx, base);
	// 825E13D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E13DC: 396BF29C  addi r11, r11, -0xd64
	ctx.r[11].s64 = ctx.r[11].s64 + -3428;
	// 825E13E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E13E4: 48000008  b 0x825e13ec
	pc = 0x825E13EC; continue 'dispatch;
	// 825E13E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E13EC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E13F0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825E13F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E13F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E13FC: 4BFFF5CD  bl 0x825e09c8
	ctx.lr = 0x825E1400;
	sub_825E09C8(ctx, base);
	// 825E1400: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E1404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E1408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E140C: 4BCDEBF5  bl 0x822c0000
	ctx.lr = 0x825E1410;
	sub_822C0000(ctx, base);
	// 825E1410: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E1414: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E1418: 48BC6DA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E1420 size=76
    let mut pc: u32 = 0x825E1420;
    'dispatch: loop {
        match pc {
            0x825E1420 => {
    //   block [0x825E1420..0x825E146C)
	// 825E1420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E1424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E1428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E142C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E1430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E1434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E1438: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E143C: 4BFFFBBD  bl 0x825e0ff8
	ctx.lr = 0x825E1440;
	sub_825E0FF8(ctx, base);
	// 825E1440: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E1444: 4182000C  beq 0x825e1450
	if ctx.cr[0].eq {
	pc = 0x825E1450; continue 'dispatch;
	}
	// 825E1448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E144C: 48810F8D  bl 0x82df23d8
	ctx.lr = 0x825E1450;
	sub_82DF23D8(ctx, base);
	// 825E1450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E1454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E1458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E145C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E1460: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E1464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E1468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E1470 size=1212
    let mut pc: u32 = 0x825E1470;
    'dispatch: loop {
        match pc {
            0x825E1470 => {
    //   block [0x825E1470..0x825E192C)
	// 825E1470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E1474: 48BC6CF5  bl 0x831a8168
	ctx.lr = 0x825E1478;
	sub_831A8130(ctx, base);
	// 825E1478: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825E147C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825E1480: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825E1484: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E1488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E148C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E1490: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825E1494: C1BF0198  lfs f13, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1498: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E149C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825E14A0: 40990478  ble cr6, 0x825e1918
	if !ctx.cr[6].gt {
	pc = 0x825E1918; continue 'dispatch;
	}
	// 825E14A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E14A8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E14AC: 4BF30C6D  bl 0x82512118
	ctx.lr = 0x825E14B0;
	sub_82512118(ctx, base);
	// 825E14B0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E14B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E14B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E14BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E14C0: 4E800421  bctrl
	ctx.lr = 0x825E14C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E14C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E14C8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825E14CC: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825E14D0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825E14D4: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 825E14D8: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	// 825E14DC: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 825E14E0: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E14E4: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E14E8: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 825E14EC: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 825E14F0: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E14F4: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E14F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E1930 size=180
    let mut pc: u32 = 0x825E1930;
    'dispatch: loop {
        match pc {
            0x825E1930 => {
    //   block [0x825E1930..0x825E19E4)
	// 825E1930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E1934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E1938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E193C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E1940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E1944: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E1948: 4BDF1FC1  bl 0x823d3908
	ctx.lr = 0x825E194C;
	sub_823D3908(ctx, base);
	// 825E194C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E1950: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E1954: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E1958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E195C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E1960: 419A0024  beq cr6, 0x825e1984
	if ctx.cr[6].eq {
	pc = 0x825E1984; continue 'dispatch;
	}
	// 825E1964: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E1968: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E196C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E1970: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E1974: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E1978: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E197C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E1980: 4082FFE8  bne 0x825e1968
	if !ctx.cr[0].eq {
	pc = 0x825E1968; continue 'dispatch;
	}
	// 825E1984: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E1988: 80DF0094  lwz r6, 0x94(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825E198C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E1990: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825E1994: 388AF350  addi r4, r10, -0xcb0
	ctx.r[4].s64 = ctx.r[10].s64 + -3248;
	// 825E1998: 38A001C1  li r5, 0x1c1
	ctx.r[5].s64 = 449;
	// 825E199C: 387FFF44  addi r3, r31, -0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + -188;
	// 825E19A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E19A4: 4887709D  bl 0x82e58a40
	ctx.lr = 0x825E19A8;
	sub_82E58A40(ctx, base);
	// 825E19A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E19AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E19B0: 419A0008  beq cr6, 0x825e19b8
	if ctx.cr[6].eq {
	pc = 0x825E19B8; continue 'dispatch;
	}
	// 825E19B4: 4BCDEEDD  bl 0x822c0890
	ctx.lr = 0x825E19B8;
	sub_822C0890(ctx, base);
	// 825E19B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E19BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E19C0: 419A0008  beq cr6, 0x825e19c8
	if ctx.cr[6].eq {
	pc = 0x825E19C8; continue 'dispatch;
	}
	// 825E19C4: 4BCDEECD  bl 0x822c0890
	ctx.lr = 0x825E19C8;
	sub_822C0890(ctx, base);
	// 825E19C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E19CC: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825E19D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E19D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E19D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E19DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E19E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E19E8 size=1848
    let mut pc: u32 = 0x825E19E8;
    'dispatch: loop {
        match pc {
            0x825E19E8 => {
    //   block [0x825E19E8..0x825E2120)
	// 825E19E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E19EC: 48BC677D  bl 0x831a8168
	ctx.lr = 0x825E19F0;
	sub_831A8130(ctx, base);
	// 825E19F0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825E19F4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825E19F8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825E19FC: 9421FC20  stwu r1, -0x3e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-992 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E1A00: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825E1A04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1A08: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825E1A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E1A10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E1A14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1A18: 388BF620  addi r4, r11, -0x9e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2528;
	// 825E1A1C: 48811FED  bl 0x82df3a08
	ctx.lr = 0x825E1A20;
	sub_82DF3A08(ctx, base);
	// 825E1A20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1A24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1A28: 388BF614  addi r4, r11, -0x9ec
	ctx.r[4].s64 = ctx.r[11].s64 + -2540;
	// 825E1A2C: 48811FDD  bl 0x82df3a08
	ctx.lr = 0x825E1A30;
	sub_82DF3A08(ctx, base);
	// 825E1A30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E1A34: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E1A38: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E1A3C: 38BF00A8  addi r5, r31, 0xa8
	ctx.r[5].s64 = ctx.r[31].s64 + 168;
	// 825E1A40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1A44: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825E1A48: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 825E1A4C: C3AA9F64  lfs f29, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825E1A50: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825E1A54: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E1A58: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825E1A5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E1A60: 4BFC1849  bl 0x825a32a8
	ctx.lr = 0x825E1A64;
	sub_825A32A8(ctx, base);
	// 825E1A64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1A6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1A70: 4BFBFD01  bl 0x825a1770
	ctx.lr = 0x825E1A74;
	sub_825A1770(ctx, base);
	// 825E1A74: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 825E1A78: 488119B1  bl 0x82df3428
	ctx.lr = 0x825E1A7C;
	sub_82DF3428(ctx, base);
	// 825E1A7C: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 825E1A80: 4BCE7239  bl 0x822c8cb8
	ctx.lr = 0x825E1A84;
	sub_822C8CB8(ctx, base);
	// 825E1A84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1A88: 488119A1  bl 0x82df3428
	ctx.lr = 0x825E1A8C;
	sub_82DF3428(ctx, base);
	// 825E1A8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1A90: 48811999  bl 0x82df3428
	ctx.lr = 0x825E1A94;
	sub_82DF3428(ctx, base);
	// 825E1A94: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825E1A98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1A9C: 388B9214  addi r4, r11, -0x6dec
	ctx.r[4].s64 = ctx.r[11].s64 + -28140;
	// 825E1AA0: 48811F69  bl 0x82df3a08
	ctx.lr = 0x825E1AA4;
	sub_82DF3A08(ctx, base);
	// 825E1AA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E1AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1AAC: 388B34B0  addi r4, r11, 0x34b0
	ctx.r[4].s64 = ctx.r[11].s64 + 13488;
	// 825E1AB0: 48811F59  bl 0x82df3a08
	ctx.lr = 0x825E1AB4;
	sub_82DF3A08(ctx, base);
	// 825E1AB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E1AB8: 38BF00AC  addi r5, r31, 0xac
	ctx.r[5].s64 = ctx.r[31].s64 + 172;
	// 825E1ABC: FC40E890  fmr f2, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825E1AC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1AC4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E1AC8: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 825E1ACC: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E1AD0: 4BFC17D9  bl 0x825a32a8
	ctx.lr = 0x825E1AD4;
	sub_825A32A8(ctx, base);
	// 825E1AD4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1ADC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1AE0: 4BFBFC91  bl 0x825a1770
	ctx.lr = 0x825E1AE4;
	sub_825A1770(ctx, base);
	// 825E1AE4: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 825E1AE8: 48811941  bl 0x82df3428
	ctx.lr = 0x825E1AEC;
	sub_82DF3428(ctx, base);
	// 825E1AEC: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 825E1AF0: 4BCE71C9  bl 0x822c8cb8
	ctx.lr = 0x825E1AF4;
	sub_822C8CB8(ctx, base);
	// 825E1AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1AF8: 48811931  bl 0x82df3428
	ctx.lr = 0x825E1AFC;
	sub_82DF3428(ctx, base);
	// 825E1AFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1B00: 48811929  bl 0x82df3428
	ctx.lr = 0x825E1B04;
	sub_82DF3428(ctx, base);
	// 825E1B04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1B08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1B0C: 388BF5FC  addi r4, r11, -0xa04
	ctx.r[4].s64 = ctx.r[11].s64 + -2564;
	// 825E1B10: 48811EF9  bl 0x82df3a08
	ctx.lr = 0x825E1B14;
	sub_82DF3A08(ctx, base);
	// 825E1B14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1B1C: 388BF5E4  addi r4, r11, -0xa1c
	ctx.r[4].s64 = ctx.r[11].s64 + -2588;
	// 825E1B20: 48811EE9  bl 0x82df3a08
	ctx.lr = 0x825E1B24;
	sub_82DF3A08(ctx, base);
	// 825E1B24: 38BF00B0  addi r5, r31, 0xb0
	ctx.r[5].s64 = ctx.r[31].s64 + 176;
	// 825E1B28: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1B2C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825E1B30: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 825E1B34: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825E1B38: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E1B3C: 4BFC176D  bl 0x825a32a8
	ctx.lr = 0x825E1B40;
	sub_825A32A8(ctx, base);
	// 825E1B40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1B48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1B4C: 4BFBFC25  bl 0x825a1770
	ctx.lr = 0x825E1B50;
	sub_825A1770(ctx, base);
	// 825E1B50: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 825E1B54: 488118D5  bl 0x82df3428
	ctx.lr = 0x825E1B58;
	sub_82DF3428(ctx, base);
	// 825E1B58: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 825E1B5C: 4BCE715D  bl 0x822c8cb8
	ctx.lr = 0x825E1B60;
	sub_822C8CB8(ctx, base);
	// 825E1B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1B64: 488118C5  bl 0x82df3428
	ctx.lr = 0x825E1B68;
	sub_82DF3428(ctx, base);
	// 825E1B68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1B6C: 488118BD  bl 0x82df3428
	ctx.lr = 0x825E1B70;
	sub_82DF3428(ctx, base);
	// 825E1B70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1B74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1B78: 388BF5D0  addi r4, r11, -0xa30
	ctx.r[4].s64 = ctx.r[11].s64 + -2608;
	// 825E1B7C: 48811E8D  bl 0x82df3a08
	ctx.lr = 0x825E1B80;
	sub_82DF3A08(ctx, base);
	// 825E1B80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1B88: 388BF5C0  addi r4, r11, -0xa40
	ctx.r[4].s64 = ctx.r[11].s64 + -2624;
	// 825E1B8C: 48811E7D  bl 0x82df3a08
	ctx.lr = 0x825E1B90;
	sub_82DF3A08(ctx, base);
	// 825E1B90: 38BF00BC  addi r5, r31, 0xbc
	ctx.r[5].s64 = ctx.r[31].s64 + 188;
	// 825E1B94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1B98: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 825E1B9C: 4BFC14B5  bl 0x825a3050
	ctx.lr = 0x825E1BA0;
	sub_825A3050(ctx, base);
	// 825E1BA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1BA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1BA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1BAC: 4BFC05DD  bl 0x825a2188
	ctx.lr = 0x825E1BB0;
	sub_825A2188(ctx, base);
	// 825E1BB0: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 825E1BB4: 48811875  bl 0x82df3428
	ctx.lr = 0x825E1BB8;
	sub_82DF3428(ctx, base);
	// 825E1BB8: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 825E1BBC: 4BCE70FD  bl 0x822c8cb8
	ctx.lr = 0x825E1BC0;
	sub_822C8CB8(ctx, base);
	// 825E1BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1BC4: 48811865  bl 0x82df3428
	ctx.lr = 0x825E1BC8;
	sub_82DF3428(ctx, base);
	// 825E1BC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1BCC: 4881185D  bl 0x82df3428
	ctx.lr = 0x825E1BD0;
	sub_82DF3428(ctx, base);
	// 825E1BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1BD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1BD8: 388BF5A4  addi r4, r11, -0xa5c
	ctx.r[4].s64 = ctx.r[11].s64 + -2652;
	// 825E1BDC: 48811E2D  bl 0x82df3a08
	ctx.lr = 0x825E1BE0;
	sub_82DF3A08(ctx, base);
	// 825E1BE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1BE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1BE8: 388BF598  addi r4, r11, -0xa68
	ctx.r[4].s64 = ctx.r[11].s64 + -2664;
	// 825E1BEC: 48811E1D  bl 0x82df3a08
	ctx.lr = 0x825E1BF0;
	sub_82DF3A08(ctx, base);
	// 825E1BF0: 38BF00BD  addi r5, r31, 0xbd
	ctx.r[5].s64 = ctx.r[31].s64 + 189;
	// 825E1BF4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1BF8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E1BFC: 4BFC1455  bl 0x825a3050
	ctx.lr = 0x825E1C00;
	sub_825A3050(ctx, base);
	// 825E1C00: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1C04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1C08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1C0C: 4BFC057D  bl 0x825a2188
	ctx.lr = 0x825E1C10;
	sub_825A2188(ctx, base);
	// 825E1C10: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825E1C14: 48811815  bl 0x82df3428
	ctx.lr = 0x825E1C18;
	sub_82DF3428(ctx, base);
	// 825E1C18: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825E1C1C: 4BCE709D  bl 0x822c8cb8
	ctx.lr = 0x825E1C20;
	sub_822C8CB8(ctx, base);
	// 825E1C20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1C24: 48811805  bl 0x82df3428
	ctx.lr = 0x825E1C28;
	sub_82DF3428(ctx, base);
	// 825E1C28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1C2C: 488117FD  bl 0x82df3428
	ctx.lr = 0x825E1C30;
	sub_82DF3428(ctx, base);
	// 825E1C30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1C34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1C38: 388BF584  addi r4, r11, -0xa7c
	ctx.r[4].s64 = ctx.r[11].s64 + -2684;
	// 825E1C3C: 48811DCD  bl 0x82df3a08
	ctx.lr = 0x825E1C40;
	sub_82DF3A08(ctx, base);
	// 825E1C40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1C44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1C48: 388BF56C  addi r4, r11, -0xa94
	ctx.r[4].s64 = ctx.r[11].s64 + -2708;
	// 825E1C4C: 48811DBD  bl 0x82df3a08
	ctx.lr = 0x825E1C50;
	sub_82DF3A08(ctx, base);
	// 825E1C50: 38BF00BE  addi r5, r31, 0xbe
	ctx.r[5].s64 = ctx.r[31].s64 + 190;
	// 825E1C54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1C58: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 825E1C5C: 4BFC13F5  bl 0x825a3050
	ctx.lr = 0x825E1C60;
	sub_825A3050(ctx, base);
	// 825E1C60: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1C64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1C6C: 4BFC051D  bl 0x825a2188
	ctx.lr = 0x825E1C70;
	sub_825A2188(ctx, base);
	// 825E1C70: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 825E1C74: 488117B5  bl 0x82df3428
	ctx.lr = 0x825E1C78;
	sub_82DF3428(ctx, base);
	// 825E1C78: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 825E1C7C: 4BCE703D  bl 0x822c8cb8
	ctx.lr = 0x825E1C80;
	sub_822C8CB8(ctx, base);
	// 825E1C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1C84: 488117A5  bl 0x82df3428
	ctx.lr = 0x825E1C88;
	sub_82DF3428(ctx, base);
	// 825E1C88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1C8C: 4881179D  bl 0x82df3428
	ctx.lr = 0x825E1C90;
	sub_82DF3428(ctx, base);
	// 825E1C90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1C94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1C98: 388BF544  addi r4, r11, -0xabc
	ctx.r[4].s64 = ctx.r[11].s64 + -2748;
	// 825E1C9C: 48811D6D  bl 0x82df3a08
	ctx.lr = 0x825E1CA0;
	sub_82DF3A08(ctx, base);
	// 825E1CA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1CA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1CA8: 388BF524  addi r4, r11, -0xadc
	ctx.r[4].s64 = ctx.r[11].s64 + -2780;
	// 825E1CAC: 48811D5D  bl 0x82df3a08
	ctx.lr = 0x825E1CB0;
	sub_82DF3A08(ctx, base);
	// 825E1CB0: 38BF00BF  addi r5, r31, 0xbf
	ctx.r[5].s64 = ctx.r[31].s64 + 191;
	// 825E1CB4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1CB8: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 825E1CBC: 4BFC1395  bl 0x825a3050
	ctx.lr = 0x825E1CC0;
	sub_825A3050(ctx, base);
	// 825E1CC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1CC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1CCC: 4BFC04BD  bl 0x825a2188
	ctx.lr = 0x825E1CD0;
	sub_825A2188(ctx, base);
	// 825E1CD0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825E1CD4: 48811755  bl 0x82df3428
	ctx.lr = 0x825E1CD8;
	sub_82DF3428(ctx, base);
	// 825E1CD8: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825E1CDC: 4BCE6FDD  bl 0x822c8cb8
	ctx.lr = 0x825E1CE0;
	sub_822C8CB8(ctx, base);
	// 825E1CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1CE4: 48811745  bl 0x82df3428
	ctx.lr = 0x825E1CE8;
	sub_82DF3428(ctx, base);
	// 825E1CE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1CEC: 4881173D  bl 0x82df3428
	ctx.lr = 0x825E1CF0;
	sub_82DF3428(ctx, base);
	// 825E1CF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1CF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1CF8: 388BF50C  addi r4, r11, -0xaf4
	ctx.r[4].s64 = ctx.r[11].s64 + -2804;
	// 825E1CFC: 48811D0D  bl 0x82df3a08
	ctx.lr = 0x825E1D00;
	sub_82DF3A08(ctx, base);
	// 825E1D00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1D04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1D08: 388BF4F8  addi r4, r11, -0xb08
	ctx.r[4].s64 = ctx.r[11].s64 + -2824;
	// 825E1D0C: 48811CFD  bl 0x82df3a08
	ctx.lr = 0x825E1D10;
	sub_82DF3A08(ctx, base);
	// 825E1D10: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825E1D14: 38BF00C4  addi r5, r31, 0xc4
	ctx.r[5].s64 = ctx.r[31].s64 + 196;
	// 825E1D18: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825E1D1C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1D20: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E1D24: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 825E1D28: C04B6218  lfs f2, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E1D2C: 4BFC157D  bl 0x825a32a8
	ctx.lr = 0x825E1D30;
	sub_825A32A8(ctx, base);
	// 825E1D30: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1D34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1D38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1D3C: 4BFBFA35  bl 0x825a1770
	ctx.lr = 0x825E1D40;
	sub_825A1770(ctx, base);
	// 825E1D40: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 825E1D44: 488116E5  bl 0x82df3428
	ctx.lr = 0x825E1D48;
	sub_82DF3428(ctx, base);
	// 825E1D48: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 825E1D4C: 4BCE6F6D  bl 0x822c8cb8
	ctx.lr = 0x825E1D50;
	sub_822C8CB8(ctx, base);
	// 825E1D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1D54: 488116D5  bl 0x82df3428
	ctx.lr = 0x825E1D58;
	sub_82DF3428(ctx, base);
	// 825E1D58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1D5C: 488116CD  bl 0x82df3428
	ctx.lr = 0x825E1D60;
	sub_82DF3428(ctx, base);
	// 825E1D60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1D64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1D68: 388BF4D4  addi r4, r11, -0xb2c
	ctx.r[4].s64 = ctx.r[11].s64 + -2860;
	// 825E1D6C: 48811C9D  bl 0x82df3a08
	ctx.lr = 0x825E1D70;
	sub_82DF3A08(ctx, base);
	// 825E1D70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1D78: 388BF4C8  addi r4, r11, -0xb38
	ctx.r[4].s64 = ctx.r[11].s64 + -2872;
	// 825E1D7C: 48811C8D  bl 0x82df3a08
	ctx.lr = 0x825E1D80;
	sub_82DF3A08(ctx, base);
	// 825E1D80: 38BF00C2  addi r5, r31, 0xc2
	ctx.r[5].s64 = ctx.r[31].s64 + 194;
	// 825E1D84: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1D88: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 825E1D8C: 4BFC12C5  bl 0x825a3050
	ctx.lr = 0x825E1D90;
	sub_825A3050(ctx, base);
	// 825E1D90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1D94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1D9C: 4BFC03ED  bl 0x825a2188
	ctx.lr = 0x825E1DA0;
	sub_825A2188(ctx, base);
	// 825E1DA0: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 825E1DA4: 48811685  bl 0x82df3428
	ctx.lr = 0x825E1DA8;
	sub_82DF3428(ctx, base);
	// 825E1DA8: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 825E1DAC: 4BCE6F0D  bl 0x822c8cb8
	ctx.lr = 0x825E1DB0;
	sub_822C8CB8(ctx, base);
	// 825E1DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1DB4: 48811675  bl 0x82df3428
	ctx.lr = 0x825E1DB8;
	sub_82DF3428(ctx, base);
	// 825E1DB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1DBC: 4881166D  bl 0x82df3428
	ctx.lr = 0x825E1DC0;
	sub_82DF3428(ctx, base);
	// 825E1DC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1DC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1DC8: 388BF4B0  addi r4, r11, -0xb50
	ctx.r[4].s64 = ctx.r[11].s64 + -2896;
	// 825E1DCC: 48811C3D  bl 0x82df3a08
	ctx.lr = 0x825E1DD0;
	sub_82DF3A08(ctx, base);
	// 825E1DD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1DD8: 388BF49C  addi r4, r11, -0xb64
	ctx.r[4].s64 = ctx.r[11].s64 + -2916;
	// 825E1DDC: 48811C2D  bl 0x82df3a08
	ctx.lr = 0x825E1DE0;
	sub_82DF3A08(ctx, base);
	// 825E1DE0: 38BF00D4  addi r5, r31, 0xd4
	ctx.r[5].s64 = ctx.r[31].s64 + 212;
	// 825E1DE4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1DE8: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825E1DEC: 4BFC1265  bl 0x825a3050
	ctx.lr = 0x825E1DF0;
	sub_825A3050(ctx, base);
	// 825E1DF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1DF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1DF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1DFC: 4BFC038D  bl 0x825a2188
	ctx.lr = 0x825E1E00;
	sub_825A2188(ctx, base);
	// 825E1E00: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 825E1E04: 48811625  bl 0x82df3428
	ctx.lr = 0x825E1E08;
	sub_82DF3428(ctx, base);
	// 825E1E08: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 825E1E0C: 4BCE6EAD  bl 0x822c8cb8
	ctx.lr = 0x825E1E10;
	sub_822C8CB8(ctx, base);
	// 825E1E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1E14: 48811615  bl 0x82df3428
	ctx.lr = 0x825E1E18;
	sub_82DF3428(ctx, base);
	// 825E1E18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1E1C: 4881160D  bl 0x82df3428
	ctx.lr = 0x825E1E20;
	sub_82DF3428(ctx, base);
	// 825E1E20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1E24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1E28: 388BF48C  addi r4, r11, -0xb74
	ctx.r[4].s64 = ctx.r[11].s64 + -2932;
	// 825E1E2C: 48811BDD  bl 0x82df3a08
	ctx.lr = 0x825E1E30;
	sub_82DF3A08(ctx, base);
	// 825E1E30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1E34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1E38: 388BF470  addi r4, r11, -0xb90
	ctx.r[4].s64 = ctx.r[11].s64 + -2960;
	// 825E1E3C: 48811BCD  bl 0x82df3a08
	ctx.lr = 0x825E1E40;
	sub_82DF3A08(ctx, base);
	// 825E1E40: 38BF00D5  addi r5, r31, 0xd5
	ctx.r[5].s64 = ctx.r[31].s64 + 213;
	// 825E1E44: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1E48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E1E4C: 4BFC1205  bl 0x825a3050
	ctx.lr = 0x825E1E50;
	sub_825A3050(ctx, base);
	// 825E1E50: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1E54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1E5C: 4BFC032D  bl 0x825a2188
	ctx.lr = 0x825E1E60;
	sub_825A2188(ctx, base);
	// 825E1E60: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E1E64: 488115C5  bl 0x82df3428
	ctx.lr = 0x825E1E68;
	sub_82DF3428(ctx, base);
	// 825E1E68: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E1E6C: 4BCE6E4D  bl 0x822c8cb8
	ctx.lr = 0x825E1E70;
	sub_822C8CB8(ctx, base);
	// 825E1E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1E74: 488115B5  bl 0x82df3428
	ctx.lr = 0x825E1E78;
	sub_82DF3428(ctx, base);
	// 825E1E78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1E7C: 488115AD  bl 0x82df3428
	ctx.lr = 0x825E1E80;
	sub_82DF3428(ctx, base);
	// 825E1E80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1E84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E1E88: 388BF350  addi r4, r11, -0xcb0
	ctx.r[4].s64 = ctx.r[11].s64 + -3248;
	// 825E1E8C: 38A001DC  li r5, 0x1dc
	ctx.r[5].s64 = 476;
	// 825E1E90: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 825E1E94: 4BCDE545  bl 0x822c03d8
	ctx.lr = 0x825E1E98;
	sub_822C03D8(ctx, base);
	// 825E1E98: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825E1E9C: 41820034  beq 0x825e1ed0
	if ctx.cr[0].eq {
	pc = 0x825E1ED0; continue 'dispatch;
	}
	// 825E1EA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1EA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1EA8: 388BF464  addi r4, r11, -0xb9c
	ctx.r[4].s64 = ctx.r[11].s64 + -2972;
	// 825E1EAC: 48811B5D  bl 0x82df3a08
	ctx.lr = 0x825E1EB0;
	sub_82DF3A08(ctx, base);
	// 825E1EB0: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 825E1EB4: 38BF00DC  addi r5, r31, 0xdc
	ctx.r[5].s64 = ctx.r[31].s64 + 220;
	// 825E1EB8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1EBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E1EC0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825E1EC4: 4BFC7635  bl 0x825a94f8
	ctx.lr = 0x825E1EC8;
	sub_825A94F8(ctx, base);
	// 825E1EC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E1ECC: 48000008  b 0x825e1ed4
	pc = 0x825E1ED4; continue 'dispatch;
	// 825E1ED0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825E1ED4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1EDC: 388BF454  addi r4, r11, -0xbac
	ctx.r[4].s64 = ctx.r[11].s64 + -2988;
	// 825E1EE0: 48811B29  bl 0x82df3a08
	ctx.lr = 0x825E1EE4;
	sub_82DF3A08(ctx, base);
	// 825E1EE4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825E1EE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E1EEC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E1EF0: 4BFC58F9  bl 0x825a77e8
	ctx.lr = 0x825E1EF4;
	sub_825A77E8(ctx, base);
	// 825E1EF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E1EF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E1EFC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E1F00: 4BCDE101  bl 0x822c0000
	ctx.lr = 0x825E1F04;
	sub_822C0000(ctx, base);
	// 825E1F04: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E1F08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1F0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1F10: 4BFC0201  bl 0x825a2110
	ctx.lr = 0x825E1F14;
	sub_825A2110(ctx, base);
	// 825E1F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1F18: 48811511  bl 0x82df3428
	ctx.lr = 0x825E1F1C;
	sub_82DF3428(ctx, base);
	// 825E1F1C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E1F20: 4182000C  beq 0x825e1f2c
	if ctx.cr[0].eq {
	pc = 0x825E1F2C; continue 'dispatch;
	}
	// 825E1F24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1F28: 48811501  bl 0x82df3428
	ctx.lr = 0x825E1F2C;
	sub_82DF3428(ctx, base);
	// 825E1F2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1F30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1F34: 388BF448  addi r4, r11, -0xbb8
	ctx.r[4].s64 = ctx.r[11].s64 + -3000;
	// 825E1F38: 48811AD1  bl 0x82df3a08
	ctx.lr = 0x825E1F3C;
	sub_82DF3A08(ctx, base);
	// 825E1F3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1F44: 388BF43C  addi r4, r11, -0xbc4
	ctx.r[4].s64 = ctx.r[11].s64 + -3012;
	// 825E1F48: 48811AC1  bl 0x82df3a08
	ctx.lr = 0x825E1F4C;
	sub_82DF3A08(ctx, base);
	// 825E1F4C: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 825E1F50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1F54: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 825E1F58: 4BFC10F9  bl 0x825a3050
	ctx.lr = 0x825E1F5C;
	sub_825A3050(ctx, base);
	// 825E1F5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1F60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1F68: 4BFC0221  bl 0x825a2188
	ctx.lr = 0x825E1F6C;
	sub_825A2188(ctx, base);
	// 825E1F6C: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 825E1F70: 488114B9  bl 0x82df3428
	ctx.lr = 0x825E1F74;
	sub_82DF3428(ctx, base);
	// 825E1F74: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 825E1F78: 4BCE6D41  bl 0x822c8cb8
	ctx.lr = 0x825E1F7C;
	sub_822C8CB8(ctx, base);
	// 825E1F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1F80: 488114A9  bl 0x82df3428
	ctx.lr = 0x825E1F84;
	sub_82DF3428(ctx, base);
	// 825E1F84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1F88: 488114A1  bl 0x82df3428
	ctx.lr = 0x825E1F8C;
	sub_82DF3428(ctx, base);
	// 825E1F8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1F90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1F94: 388BF42C  addi r4, r11, -0xbd4
	ctx.r[4].s64 = ctx.r[11].s64 + -3028;
	// 825E1F98: 48811A71  bl 0x82df3a08
	ctx.lr = 0x825E1F9C;
	sub_82DF3A08(ctx, base);
	// 825E1F9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1FA4: 388BF424  addi r4, r11, -0xbdc
	ctx.r[4].s64 = ctx.r[11].s64 + -3036;
	// 825E1FA8: 48811A61  bl 0x82df3a08
	ctx.lr = 0x825E1FAC;
	sub_82DF3A08(ctx, base);
	// 825E1FAC: 38BF00C1  addi r5, r31, 0xc1
	ctx.r[5].s64 = ctx.r[31].s64 + 193;
	// 825E1FB0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E1FB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E1FB8: 4BFC1099  bl 0x825a3050
	ctx.lr = 0x825E1FBC;
	sub_825A3050(ctx, base);
	// 825E1FBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E1FC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E1FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E1FC8: 4BFC01C1  bl 0x825a2188
	ctx.lr = 0x825E1FCC;
	sub_825A2188(ctx, base);
	// 825E1FCC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E1FD0: 48811459  bl 0x82df3428
	ctx.lr = 0x825E1FD4;
	sub_82DF3428(ctx, base);
	// 825E1FD4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825E1FD8: 4BCE6CE1  bl 0x822c8cb8
	ctx.lr = 0x825E1FDC;
	sub_822C8CB8(ctx, base);
	// 825E1FDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E1FE0: 48811449  bl 0x82df3428
	ctx.lr = 0x825E1FE4;
	sub_82DF3428(ctx, base);
	// 825E1FE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1FE8: 48811441  bl 0x82df3428
	ctx.lr = 0x825E1FEC;
	sub_82DF3428(ctx, base);
	// 825E1FEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E1FF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E1FF4: 388BF414  addi r4, r11, -0xbec
	ctx.r[4].s64 = ctx.r[11].s64 + -3052;
	// 825E1FF8: 48811A11  bl 0x82df3a08
	ctx.lr = 0x825E1FFC;
	sub_82DF3A08(ctx, base);
	// 825E1FFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2004: 388BF3FC  addi r4, r11, -0xc04
	ctx.r[4].s64 = ctx.r[11].s64 + -3076;
	// 825E2008: 48811A01  bl 0x82df3a08
	ctx.lr = 0x825E200C;
	sub_82DF3A08(ctx, base);
	// 825E200C: 38BF00ED  addi r5, r31, 0xed
	ctx.r[5].s64 = ctx.r[31].s64 + 237;
	// 825E2010: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E2014: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825E2018: 4BFC1039  bl 0x825a3050
	ctx.lr = 0x825E201C;
	sub_825A3050(ctx, base);
	// 825E201C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E2020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2028: 4BFC0161  bl 0x825a2188
	ctx.lr = 0x825E202C;
	sub_825A2188(ctx, base);
	// 825E202C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825E2030: 488113F9  bl 0x82df3428
	ctx.lr = 0x825E2034;
	sub_82DF3428(ctx, base);
	// 825E2034: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825E2038: 4BCE6C81  bl 0x822c8cb8
	ctx.lr = 0x825E203C;
	sub_822C8CB8(ctx, base);
	// 825E203C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2040: 488113E9  bl 0x82df3428
	ctx.lr = 0x825E2044;
	sub_82DF3428(ctx, base);
	// 825E2044: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E2048: 488113E1  bl 0x82df3428
	ctx.lr = 0x825E204C;
	sub_82DF3428(ctx, base);
	// 825E204C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2050: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E2054: 388BF3E4  addi r4, r11, -0xc1c
	ctx.r[4].s64 = ctx.r[11].s64 + -3100;
	// 825E2058: 488119B1  bl 0x82df3a08
	ctx.lr = 0x825E205C;
	sub_82DF3A08(ctx, base);
	// 825E205C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2064: 388BF3D0  addi r4, r11, -0xc30
	ctx.r[4].s64 = ctx.r[11].s64 + -3120;
	// 825E2068: 488119A1  bl 0x82df3a08
	ctx.lr = 0x825E206C;
	sub_82DF3A08(ctx, base);
	// 825E206C: 38BF00C0  addi r5, r31, 0xc0
	ctx.r[5].s64 = ctx.r[31].s64 + 192;
	// 825E2070: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E2074: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825E2078: 4BFC0FD9  bl 0x825a3050
	ctx.lr = 0x825E207C;
	sub_825A3050(ctx, base);
	// 825E207C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E2080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2088: 4BFC0101  bl 0x825a2188
	ctx.lr = 0x825E208C;
	sub_825A2188(ctx, base);
	// 825E208C: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825E2090: 48811399  bl 0x82df3428
	ctx.lr = 0x825E2094;
	sub_82DF3428(ctx, base);
	// 825E2094: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825E2098: 4BCE6C21  bl 0x822c8cb8
	ctx.lr = 0x825E209C;
	sub_822C8CB8(ctx, base);
	// 825E209C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E20A0: 48811389  bl 0x82df3428
	ctx.lr = 0x825E20A4;
	sub_82DF3428(ctx, base);
	// 825E20A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E20A8: 48811381  bl 0x82df3428
	ctx.lr = 0x825E20AC;
	sub_82DF3428(ctx, base);
	// 825E20AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E20B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E20B4: 388BF3C0  addi r4, r11, -0xc40
	ctx.r[4].s64 = ctx.r[11].s64 + -3136;
	// 825E20B8: 48811951  bl 0x82df3a08
	ctx.lr = 0x825E20BC;
	sub_82DF3A08(ctx, base);
	// 825E20BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E20C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E20C4: 388BF3B0  addi r4, r11, -0xc50
	ctx.r[4].s64 = ctx.r[11].s64 + -3152;
	// 825E20C8: 48811941  bl 0x82df3a08
	ctx.lr = 0x825E20CC;
	sub_82DF3A08(ctx, base);
	// 825E20CC: 38BF00EE  addi r5, r31, 0xee
	ctx.r[5].s64 = ctx.r[31].s64 + 238;
	// 825E20D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E20D4: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 825E20D8: 4BFC0F79  bl 0x825a3050
	ctx.lr = 0x825E20DC;
	sub_825A3050(ctx, base);
	// 825E20DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E20E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E20E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E20E8: 4BFC00A1  bl 0x825a2188
	ctx.lr = 0x825E20EC;
	sub_825A2188(ctx, base);
	// 825E20EC: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 825E20F0: 48811339  bl 0x82df3428
	ctx.lr = 0x825E20F4;
	sub_82DF3428(ctx, base);
	// 825E20F4: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 825E20F8: 4BCE6BC1  bl 0x822c8cb8
	ctx.lr = 0x825E20FC;
	sub_822C8CB8(ctx, base);
	// 825E20FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2100: 48811329  bl 0x82df3428
	ctx.lr = 0x825E2104;
	sub_82DF3428(ctx, base);
	// 825E2104: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E2108: 48811321  bl 0x82df3428
	ctx.lr = 0x825E210C;
	sub_82DF3428(ctx, base);
	// 825E210C: 382103E0  addi r1, r1, 0x3e0
	ctx.r[1].s64 = ctx.r[1].s64 + 992;
	// 825E2110: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825E2114: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825E2118: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825E211C: 48BC609C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E2120 size=320
    let mut pc: u32 = 0x825E2120;
    'dispatch: loop {
        match pc {
            0x825E2120 => {
    //   block [0x825E2120..0x825E2260)
	// 825E2120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2124: 48BC6045  bl 0x831a8168
	ctx.lr = 0x825E2128;
	sub_831A8130(ctx, base);
	// 825E2128: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E212C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E2130: 897F01B8  lbz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 825E2134: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2138: 41820120  beq 0x825e2258
	if ctx.cr[0].eq {
	pc = 0x825E2258; continue 'dispatch;
	}
	// 825E213C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E2140: 4BFFF261  bl 0x825e13a0
	ctx.lr = 0x825E2144;
	sub_825E13A0(ctx, base);
	// 825E2144: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E2148: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E214C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825E2150: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825E2154: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825E2158: 419A0024  beq cr6, 0x825e217c
	if ctx.cr[6].eq {
	pc = 0x825E217C; continue 'dispatch;
	}
	// 825E215C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825E2160: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E2164: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2168: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E216C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E2170: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E2174: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2178: 4082FFE8  bne 0x825e2160
	if !ctx.cr[0].eq {
	pc = 0x825E2160; continue 'dispatch;
	}
	// 825E217C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2180: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E2184: 4BF2D345  bl 0x8250f4c8
	ctx.lr = 0x825E2188;
	sub_8250F4C8(ctx, base);
	// 825E2188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E218C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2190: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E2194: 409A0008  bne cr6, 0x825e219c
	if !ctx.cr[6].eq {
	pc = 0x825E219C; continue 'dispatch;
	}
	// 825E2198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E219C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E21A0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 825E21A4: 4BF26875  bl 0x82508a18
	ctx.lr = 0x825E21A8;
	sub_82508A18(ctx, base);
	// 825E21A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E21AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E21B0: 388BF350  addi r4, r11, -0xcb0
	ctx.r[4].s64 = ctx.r[11].s64 + -3248;
	// 825E21B4: 38A0021A  li r5, 0x21a
	ctx.r[5].s64 = 538;
	// 825E21B8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825E21BC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825E21C0: 48874E29  bl 0x82e56fe8
	ctx.lr = 0x825E21C4;
	sub_82E56FE8(ctx, base);
	// 825E21C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E21C8: 4880FAC9  bl 0x82df1c90
	ctx.lr = 0x825E21CC;
	sub_82DF1C90(ctx, base);
	// 825E21CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E21D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E21D4: 419A0008  beq cr6, 0x825e21dc
	if ctx.cr[6].eq {
	pc = 0x825E21DC; continue 'dispatch;
	}
	// 825E21D8: 4BCDE6B9  bl 0x822c0890
	ctx.lr = 0x825E21DC;
	sub_822C0890(ctx, base);
	// 825E21DC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825E21E0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825E21E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E21E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E21EC: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E2260 size=344
    let mut pc: u32 = 0x825E2260;
    'dispatch: loop {
        match pc {
            0x825E2260 => {
    //   block [0x825E2260..0x825E23B8)
	// 825E2260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E2268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E226C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E2270: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E2274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E2278: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E227C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E2280: 4BF2D249  bl 0x8250f4c8
	ctx.lr = 0x825E2284;
	sub_8250F4C8(ctx, base);
	// 825E2284: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E228C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E2290: 409A0008  bne cr6, 0x825e2298
	if !ctx.cr[6].eq {
	pc = 0x825E2298; continue 'dispatch;
	}
	// 825E2294: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E2298: 4BF26291  bl 0x82508528
	ctx.lr = 0x825E229C;
	sub_82508528(ctx, base);
	// 825E229C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E22A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E22A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E22A8: 48848841  bl 0x82e2aae8
	ctx.lr = 0x825E22AC;
	sub_82E2AAE8(ctx, base);
	// 825E22AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E22B0: 4880F9E1  bl 0x82df1c90
	ctx.lr = 0x825E22B4;
	sub_82DF1C90(ctx, base);
	// 825E22B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E22B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E22BC: 388BF628  addi r4, r11, -0x9d8
	ctx.r[4].s64 = ctx.r[11].s64 + -2520;
	// 825E22C0: 48811749  bl 0x82df3a08
	ctx.lr = 0x825E22C4;
	sub_82DF3A08(ctx, base);
	// 825E22C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E22C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E22CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E22D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E22D4: 4884CB9D  bl 0x82e2ee70
	ctx.lr = 0x825E22D8;
	sub_82E2EE70(ctx, base);
	// 825E22D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E22DC: 4881114D  bl 0x82df3428
	ctx.lr = 0x825E22E0;
	sub_82DF3428(ctx, base);
	// 825E22E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E22E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E22E8: 419A00A0  beq cr6, 0x825e2388
	if ctx.cr[6].eq {
	pc = 0x825E2388; continue 'dispatch;
	}
	// 825E22EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E22F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E22F4: 388BF350  addi r4, r11, -0xcb0
	ctx.r[4].s64 = ctx.r[11].s64 + -3248;
	// 825E22F8: 38A0024D  li r5, 0x24d
	ctx.r[5].s64 = 589;
	// 825E22FC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E2300: 488100E9  bl 0x82df23e8
	ctx.lr = 0x825E2304;
	sub_82DF23E8(ctx, base);
	// 825E2304: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2308: 41820014  beq 0x825e231c
	if ctx.cr[0].eq {
	pc = 0x825E231C; continue 'dispatch;
	}
	// 825E230C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825E2310: 48834581  bl 0x82e16890
	ctx.lr = 0x825E2314;
	sub_82E16890(ctx, base);
	// 825E2314: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E2318: 48000008  b 0x825e2320
	pc = 0x825E2320; continue 'dispatch;
	// 825E231C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2320: 3BFE0150  addi r31, r30, 0x150
	ctx.r[31].s64 = ctx.r[30].s64 + 336;
	// 825E2324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2328: 4BD7B049  bl 0x8235d370
	ctx.lr = 0x825E232C;
	sub_8235D370(ctx, base);
	// 825E232C: 817E0164  lwz r11, 0x164(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 825E2330: 815E0160  lwz r10, 0x160(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 825E2334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2338: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E233C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E2340: 419A0024  beq cr6, 0x825e2364
	if ctx.cr[6].eq {
	pc = 0x825E2364; continue 'dispatch;
	}
	// 825E2344: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E2348: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E234C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2350: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E2354: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E2358: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E235C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2360: 4082FFE8  bne 0x825e2348
	if !ctx.cr[0].eq {
	pc = 0x825E2348; continue 'dispatch;
	}
	// 825E2364: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2368: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E236C: 48832D45  bl 0x82e150b0
	ctx.lr = 0x825E2370;
	sub_82E150B0(ctx, base);
	// 825E2370: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E2374: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E2378: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E237C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2380: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E2384: 4BF2E7D5  bl 0x82510b58
	ctx.lr = 0x825E2388;
	sub_82510B58(ctx, base);
	// 825E2388: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E238C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E2390: 419A0008  beq cr6, 0x825e2398
	if ctx.cr[6].eq {
	pc = 0x825E2398; continue 'dispatch;
	}
	// 825E2394: 4BCDE4FD  bl 0x822c0890
	ctx.lr = 0x825E2398;
	sub_822C0890(ctx, base);
	// 825E2398: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E239C: 48848765  bl 0x82e2ab00
	ctx.lr = 0x825E23A0;
	sub_82E2AB00(ctx, base);
	// 825E23A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825E23A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E23A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E23AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E23B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E23B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E23B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E23B8 size=520
    let mut pc: u32 = 0x825E23B8;
    'dispatch: loop {
        match pc {
            0x825E23B8 => {
    //   block [0x825E23B8..0x825E25C0)
	// 825E23B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E23BC: 48BC5DAD  bl 0x831a8168
	ctx.lr = 0x825E23C0;
	sub_831A8130(ctx, base);
	// 825E23C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E23C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E23C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E23CC: 3B8BF350  addi r28, r11, -0xcb0
	ctx.r[28].s64 = ctx.r[11].s64 + -3248;
	// 825E23D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E23D4: 38A00257  li r5, 0x257
	ctx.r[5].s64 = 599;
	// 825E23D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E23DC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E23E0: 48810009  bl 0x82df23e8
	ctx.lr = 0x825E23E4;
	sub_82DF23E8(ctx, base);
	// 825E23E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E23E8: 41820018  beq 0x825e2400
	if ctx.cr[0].eq {
	pc = 0x825E2400; continue 'dispatch;
	}
	// 825E23EC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E23F0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825E23F4: 48830CFD  bl 0x82e130f0
	ctx.lr = 0x825E23F8;
	sub_82E130F0(ctx, base);
	// 825E23F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E23FC: 48000008  b 0x825e2404
	pc = 0x825E2404; continue 'dispatch;
	// 825E2400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2404: 3BBF0170  addi r29, r31, 0x170
	ctx.r[29].s64 = ctx.r[31].s64 + 368;
	// 825E2408: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E240C: 4BCFF945  bl 0x822e1d50
	ctx.lr = 0x825E2410;
	sub_822E1D50(ctx, base);
	// 825E2410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2414: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E2418: 83DF0170  lwz r30, 0x170(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825E241C: 4BF2D0AD  bl 0x8250f4c8
	ctx.lr = 0x825E2420;
	sub_8250F4C8(ctx, base);
	// 825E2420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2428: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E242C: 409A0008  bne cr6, 0x825e2434
	if !ctx.cr[6].eq {
	pc = 0x825E2434; continue 'dispatch;
	}
	// 825E2430: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E2434: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E2438: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E243C: 4BF26765  bl 0x82508ba0
	ctx.lr = 0x825E2440;
	sub_82508BA0(ctx, base);
	// 825E2440: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E2444: 4880F84D  bl 0x82df1c90
	ctx.lr = 0x825E2448;
	sub_82DF1C90(ctx, base);
	// 825E2448: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E244C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E2450: 4BF2D079  bl 0x8250f4c8
	ctx.lr = 0x825E2454;
	sub_8250F4C8(ctx, base);
	// 825E2454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E245C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E2460: 409A0008  bne cr6, 0x825e2468
	if !ctx.cr[6].eq {
	pc = 0x825E2468; continue 'dispatch;
	}
	// 825E2464: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E2468: 4BF260C1  bl 0x82508528
	ctx.lr = 0x825E246C;
	sub_82508528(ctx, base);
	// 825E246C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E2470: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E2474: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2478: 48848671  bl 0x82e2aae8
	ctx.lr = 0x825E247C;
	sub_82E2AAE8(ctx, base);
	// 825E247C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E2480: 4880F811  bl 0x82df1c90
	ctx.lr = 0x825E2484;
	sub_82DF1C90(ctx, base);
	// 825E2484: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E248C: 388BF650  addi r4, r11, -0x9b0
	ctx.r[4].s64 = ctx.r[11].s64 + -2480;
	// 825E2490: 48811579  bl 0x82df3a08
	ctx.lr = 0x825E2494;
	sub_82DF3A08(ctx, base);
	// 825E2494: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E2498: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E249C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E24A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E24A4: 4884C9CD  bl 0x82e2ee70
	ctx.lr = 0x825E24A8;
	sub_82E2EE70(ctx, base);
	// 825E24A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E24AC: 48810F7D  bl 0x82df3428
	ctx.lr = 0x825E24B0;
	sub_82DF3428(ctx, base);
	// 825E24B0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E24B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E24B8: 419A009C  beq cr6, 0x825e2554
	if ctx.cr[6].eq {
	pc = 0x825E2554; continue 'dispatch;
	}
	// 825E24BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E24C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E24C4: 38A0025E  li r5, 0x25e
	ctx.r[5].s64 = 606;
	// 825E24C8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E24CC: 4880FF1D  bl 0x82df23e8
	ctx.lr = 0x825E24D0;
	sub_82DF23E8(ctx, base);
	// 825E24D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E24D4: 41820014  beq 0x825e24e8
	if ctx.cr[0].eq {
	pc = 0x825E24E8; continue 'dispatch;
	}
	// 825E24D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825E24DC: 488343B5  bl 0x82e16890
	ctx.lr = 0x825E24E0;
	sub_82E16890(ctx, base);
	// 825E24E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E24E4: 48000008  b 0x825e24ec
	pc = 0x825E24EC; continue 'dispatch;
	// 825E24E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E24EC: 3BDF0168  addi r30, r31, 0x168
	ctx.r[30].s64 = ctx.r[31].s64 + 360;
	// 825E24F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E24F4: 4BD7AE7D  bl 0x8235d370
	ctx.lr = 0x825E24F8;
	sub_8235D370(ctx, base);
	// 825E24F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E24FC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2504: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E2508: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E250C: 419A0024  beq cr6, 0x825e2530
	if ctx.cr[6].eq {
	pc = 0x825E2530; continue 'dispatch;
	}
	// 825E2510: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E2514: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E2518: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E251C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E2520: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E2524: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E2528: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E252C: 4082FFE8  bne 0x825e2514
	if !ctx.cr[0].eq {
	pc = 0x825E2514; continue 'dispatch;
	}
	// 825E2530: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2534: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2538: 48832B79  bl 0x82e150b0
	ctx.lr = 0x825E253C;
	sub_82E150B0(ctx, base);
	// 825E253C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E2540: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E2544: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E2548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E254C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E2550: 4BF2E609  bl 0x82510b58
	ctx.lr = 0x825E2554;
	sub_82510B58(ctx, base);
	// 825E2554: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2558: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E255C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2560: 38AAF638  addi r5, r10, -0x9c8
	ctx.r[5].s64 = ctx.r[10].s64 + -2504;
	// 825E2564: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E2568: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825E256C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E2570: 4E800421  bctrl
	ctx.lr = 0x825E2574;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E2574: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E2578: 395F0184  addi r10, r31, 0x184
	ctx.r[10].s64 = ctx.r[31].s64 + 388;
	// 825E257C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825E2580: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825E2584: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2588: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 825E258C: 4BCE1ED5  bl 0x822c4460
	ctx.lr = 0x825E2590;
	sub_822C4460(ctx, base);
	// 825E2590: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E2594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E2598: 419A0008  beq cr6, 0x825e25a0
	if ctx.cr[6].eq {
	pc = 0x825E25A0; continue 'dispatch;
	}
	// 825E259C: 4BCDE2F5  bl 0x822c0890
	ctx.lr = 0x825E25A0;
	sub_822C0890(ctx, base);
	// 825E25A0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E25A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E25A8: 419A0008  beq cr6, 0x825e25b0
	if ctx.cr[6].eq {
	pc = 0x825E25B0; continue 'dispatch;
	}
	// 825E25AC: 4BCDE2E5  bl 0x822c0890
	ctx.lr = 0x825E25B0;
	sub_822C0890(ctx, base);
	// 825E25B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E25B4: 4884854D  bl 0x82e2ab00
	ctx.lr = 0x825E25B8;
	sub_82E2AB00(ctx, base);
	// 825E25B8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825E25BC: 48BC5BFC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E25C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E25C0 size=220
    let mut pc: u32 = 0x825E25C0;
    'dispatch: loop {
        match pc {
            0x825E25C0 => {
    //   block [0x825E25C0..0x825E269C)
	// 825E25C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E25C4: 48BC5BA5  bl 0x831a8168
	ctx.lr = 0x825E25C8;
	sub_831A8130(ctx, base);
	// 825E25C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E25CC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825E25D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E25D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E25D8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825E25DC: 41820038  beq 0x825e2614
	if ctx.cr[0].eq {
	pc = 0x825E2614; continue 'dispatch;
	}
	// 825E25E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E25E4: 48BC73A5  bl 0x831a9988
	ctx.lr = 0x825E25E8;
	sub_831A9988(ctx, base);
	// 825E25E8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825E25EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E25F0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825E25F4: 48BC5B05  bl 0x831a80f8
	ctx.lr = 0x825E25F8;
	sub_831A80F8(ctx, base);
	// 825E25F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E25FC: 41820018  beq 0x825e2614
	if ctx.cr[0].eq {
	pc = 0x825E2614; continue 'dispatch;
	}
	// 825E2600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2604: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E2608: 4BFFEE69  bl 0x825e1470
	ctx.lr = 0x825E260C;
	sub_825E1470(ctx, base);
	// 825E260C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825E2610: 48000084  b 0x825e2694
	pc = 0x825E2694; continue 'dispatch;
	// 825E2614: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E2618: 419A006C  beq cr6, 0x825e2684
	if ctx.cr[6].eq {
	pc = 0x825E2684; continue 'dispatch;
	}
	// 825E261C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2620: 48BC7369  bl 0x831a9988
	ctx.lr = 0x825E2624;
	sub_831A9988(ctx, base);
	// 825E2624: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E2628: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E262C: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 825E2630: 48BC5AC9  bl 0x831a80f8
	ctx.lr = 0x825E2634;
	sub_831A80F8(ctx, base);
	// 825E2634: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E2638: 41820014  beq 0x825e264c
	if ctx.cr[0].eq {
	pc = 0x825E264C; continue 'dispatch;
	}
	// 825E263C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2640: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E2644: 480DFEA5  bl 0x826c24e8
	ctx.lr = 0x825E2648;
	sub_826C24E8(ctx, base);
	// 825E2648: 4BFFFFC4  b 0x825e260c
	pc = 0x825E260C; continue 'dispatch;
	// 825E264C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E2650: 419A0034  beq cr6, 0x825e2684
	if ctx.cr[6].eq {
	pc = 0x825E2684; continue 'dispatch;
	}
	// 825E2654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2658: 48BC7331  bl 0x831a9988
	ctx.lr = 0x825E265C;
	sub_831A9988(ctx, base);
	// 825E265C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E2660: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E2664: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 825E2668: 48BC5A91  bl 0x831a80f8
	ctx.lr = 0x825E266C;
	sub_831A80F8(ctx, base);
	// 825E266C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E2670: 41820014  beq 0x825e2684
	if ctx.cr[0].eq {
	pc = 0x825E2684; continue 'dispatch;
	}
	// 825E2674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2678: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E267C: 4BFFE415  bl 0x825e0a90
	ctx.lr = 0x825E2680;
	sub_825E0A90(ctx, base);
	// 825E2680: 4BFFFF8C  b 0x825e260c
	pc = 0x825E260C; continue 'dispatch;
	// 825E2684: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E2688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E268C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2690: 4BF2FF89  bl 0x82512618
	ctx.lr = 0x825E2694;
	sub_82512618(ctx, base);
	// 825E2694: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E2698: 48BC5B20  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E26A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E26A0 size=1400
    let mut pc: u32 = 0x825E26A0;
    'dispatch: loop {
        match pc {
            0x825E26A0 => {
    //   block [0x825E26A0..0x825E2C18)
	// 825E26A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E26A4: 48BC5AB5  bl 0x831a8158
	ctx.lr = 0x825E26A8;
	sub_831A8130(ctx, base);
	// 825E26A8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825E26AC: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E26B0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825E26B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E26B8: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 825E26BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E26C0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825E26C4: 4BF2F315  bl 0x825119d8
	ctx.lr = 0x825E26C8;
	sub_825119D8(ctx, base);
	// 825E26C8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E26CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E26D0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825E26D4: 48811335  bl 0x82df3a08
	ctx.lr = 0x825E26D8;
	sub_82DF3A08(ctx, base);
	// 825E26D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E26DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E26E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E26E4: 4BF2609D  bl 0x82508780
	ctx.lr = 0x825E26E8;
	sub_82508780(ctx, base);
	// 825E26E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E26EC: 48810D3D  bl 0x82df3428
	ctx.lr = 0x825E26F0;
	sub_82DF3428(ctx, base);
	// 825E26F0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E26F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E26F8: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825E26FC: 4881130D  bl 0x82df3a08
	ctx.lr = 0x825E2700;
	sub_82DF3A08(ctx, base);
	// 825E2700: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E2704: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E270C: 4BF26075  bl 0x82508780
	ctx.lr = 0x825E2710;
	sub_82508780(ctx, base);
	// 825E2710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2714: 48810D15  bl 0x82df3428
	ctx.lr = 0x825E2718;
	sub_82DF3428(ctx, base);
	// 825E2718: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E271C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825E2720: 409A0008  bne cr6, 0x825e2728
	if !ctx.cr[6].eq {
	pc = 0x825E2728; continue 'dispatch;
	}
	// 825E2724: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E272C: 4BF26075  bl 0x825087a0
	ctx.lr = 0x825E2730;
	sub_825087A0(ctx, base);
	// 825E2730: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2734: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E2738: 3B2BF350  addi r25, r11, -0xcb0
	ctx.r[25].s64 = ctx.r[11].s64 + -3248;
	// 825E273C: 38A000B7  li r5, 0xb7
	ctx.r[5].s64 = 183;
	// 825E2740: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825E2744: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E2748: 4880FCA1  bl 0x82df23e8
	ctx.lr = 0x825E274C;
	sub_82DF23E8(ctx, base);
	// 825E274C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E2750: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2754: 3B6B6880  addi r27, r11, 0x6880
	ctx.r[27].s64 = ctx.r[11].s64 + 26752;
	// 825E2758: 41820014  beq 0x825e276c
	if ctx.cr[0].eq {
	pc = 0x825E276C; continue 'dispatch;
	}
	// 825E275C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825E2760: 48830991  bl 0x82e130f0
	ctx.lr = 0x825E2764;
	sub_82E130F0(ctx, base);
	// 825E2764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E2768: 48000008  b 0x825e2770
	pc = 0x825E2770; continue 'dispatch;
	// 825E276C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2770: 3B9F01B0  addi r28, r31, 0x1b0
	ctx.r[28].s64 = ctx.r[31].s64 + 432;
	// 825E2774: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E2778: 4BCFF5D9  bl 0x822e1d50
	ctx.lr = 0x825E277C;
	sub_822E1D50(ctx, base);
	// 825E277C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2780: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E2784: 83BF01B0  lwz r29, 0x1b0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 825E2788: 4BF2F991  bl 0x82512118
	ctx.lr = 0x825E278C;
	sub_82512118(ctx, base);
	// 825E278C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E2790: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2794: 4883069D  bl 0x82e12e30
	ctx.lr = 0x825E2798;
	sub_82E12E30(ctx, base);
	// 825E2798: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E279C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E27A0: 419A0008  beq cr6, 0x825e27a8
	if ctx.cr[6].eq {
	pc = 0x825E27A8; continue 'dispatch;
	}
	// 825E27A4: 4BCDE0ED  bl 0x822c0890
	ctx.lr = 0x825E27A8;
	sub_822C0890(ctx, base);
	// 825E27A8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825E27AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E27B0: 38A000BA  li r5, 0xba
	ctx.r[5].s64 = 186;
	// 825E27B4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E27B8: 4880FC31  bl 0x82df23e8
	ctx.lr = 0x825E27BC;
	sub_82DF23E8(ctx, base);
	// 825E27BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E27C0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825E27C4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E27C8: 41820030  beq 0x825e27f8
	if ctx.cr[0].eq {
	pc = 0x825E27F8; continue 'dispatch;
	}
	// 825E27CC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825E27D0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825E27D4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E27D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E27DC: C04B2534  lfs f2, 0x2534(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9524 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E27E0: 48899839  bl 0x82e7c018
	ctx.lr = 0x825E27E4;
	sub_82E7C018(ctx, base);
	// 825E27E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E27E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E27EC: 48830905  bl 0x82e130f0
	ctx.lr = 0x825E27F0;
	sub_82E130F0(ctx, base);
	// 825E27F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E27F4: 48000008  b 0x825e27fc
	pc = 0x825E27FC; continue 'dispatch;
	// 825E27F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E27FC: 387F0158  addi r3, r31, 0x158
	ctx.r[3].s64 = ctx.r[31].s64 + 344;
	// 825E2800: 4BCFF551  bl 0x822e1d50
	ctx.lr = 0x825E2804;
	sub_822E1D50(ctx, base);
	// 825E2804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2808: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E280C: 83BF0158  lwz r29, 0x158(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825E2810: 4BF2F909  bl 0x82512118
	ctx.lr = 0x825E2814;
	sub_82512118(ctx, base);
	// 825E2814: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E2818: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E281C: 48830615  bl 0x82e12e30
	ctx.lr = 0x825E2820;
	sub_82E12E30(ctx, base);
	// 825E2820: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E2824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E2828: 419A0008  beq cr6, 0x825e2830
	if ctx.cr[6].eq {
	pc = 0x825E2830; continue 'dispatch;
	}
	// 825E282C: 4BCDE065  bl 0x822c0890
	ctx.lr = 0x825E2830;
	sub_822C0890(ctx, base);
	// 825E2830: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825E2834: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E2838: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 825E283C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E2840: 4880FBA9  bl 0x82df23e8
	ctx.lr = 0x825E2844;
	sub_82DF23E8(ctx, base);
	// 825E2844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2848: 41820014  beq 0x825e285c
	if ctx.cr[0].eq {
	pc = 0x825E285C; continue 'dispatch;
	}
	// 825E284C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825E2850: 488308A1  bl 0x82e130f0
	ctx.lr = 0x825E2854;
	sub_82E130F0(ctx, base);
	// 825E2854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E2858: 48000008  b 0x825e2860
	pc = 0x825E2860; continue 'dispatch;
	// 825E285C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2860: 387F0160  addi r3, r31, 0x160
	ctx.r[3].s64 = ctx.r[31].s64 + 352;
	// 825E2864: 4BCFF4ED  bl 0x822e1d50
	ctx.lr = 0x825E2868;
	sub_822E1D50(ctx, base);
	// 825E2868: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E286C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2870: 80BF0160  lwz r5, 0x160(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 825E2874: 4BF2632D  bl 0x82508ba0
	ctx.lr = 0x825E2878;
	sub_82508BA0(ctx, base);
	// 825E2878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E287C: 4BFFE275  bl 0x825e0af0
	ctx.lr = 0x825E2880;
	sub_825E0AF0(ctx, base);
	// 825E2880: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E2884: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2888: 48848261  bl 0x82e2aae8
	ctx.lr = 0x825E288C;
	sub_82E2AAE8(ctx, base);
	// 825E288C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E2890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2894: 3BABD648  addi r29, r11, -0x29b8
	ctx.r[29].s64 = ctx.r[11].s64 + -10680;
	// 825E2898: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825E289C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825E28A0: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825E28A4: 48811165  bl 0x82df3a08
	ctx.lr = 0x825E28A8;
	sub_82DF3A08(ctx, base);
	// 825E28A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E28AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E28B0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E28B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E28B8: 4884C5B9  bl 0x82e2ee70
	ctx.lr = 0x825E28BC;
	sub_82E2EE70(ctx, base);
	// 825E28BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E28C0: 48810B69  bl 0x82df3428
	ctx.lr = 0x825E28C4;
	sub_82DF3428(ctx, base);
	// 825E28C4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E28C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E28CC: 419A00D0  beq cr6, 0x825e299c
	if ctx.cr[6].eq {
	pc = 0x825E299C; continue 'dispatch;
	}
	// 825E28D0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825E28D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E28D8: 38A000C7  li r5, 0xc7
	ctx.r[5].s64 = 199;
	// 825E28DC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E28E0: 4880FB09  bl 0x82df23e8
	ctx.lr = 0x825E28E4;
	sub_82DF23E8(ctx, base);
	// 825E28E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E28E8: 41820014  beq 0x825e28fc
	if ctx.cr[0].eq {
	pc = 0x825E28FC; continue 'dispatch;
	}
	// 825E28EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E28F0: 48833FA1  bl 0x82e16890
	ctx.lr = 0x825E28F4;
	sub_82E16890(ctx, base);
	// 825E28F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E28F8: 48000008  b 0x825e2900
	pc = 0x825E2900; continue 'dispatch;
	// 825E28FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2900: 3BDF0148  addi r30, r31, 0x148
	ctx.r[30].s64 = ctx.r[31].s64 + 328;
	// 825E2904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2908: 4BD7AA69  bl 0x8235d370
	ctx.lr = 0x825E290C;
	sub_8235D370(ctx, base);
	// 825E290C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E2910: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2918: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E291C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E2920: 419A0024  beq cr6, 0x825e2944
	if ctx.cr[6].eq {
	pc = 0x825E2944; continue 'dispatch;
	}
	// 825E2924: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E2928: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E292C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2930: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E2934: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E2938: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E293C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2940: 4082FFE8  bne 0x825e2928
	if !ctx.cr[0].eq {
	pc = 0x825E2928; continue 'dispatch;
	}
	// 825E2944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2948: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E294C: 48832765  bl 0x82e150b0
	ctx.lr = 0x825E2950;
	sub_82E150B0(ctx, base);
	// 825E2950: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825E2954: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825E2958: 41980014  blt cr6, 0x825e296c
	if ctx.cr[6].lt {
	pc = 0x825E296C; continue 'dispatch;
	}
	// 825E295C: 409A0028  bne cr6, 0x825e2984
	if !ctx.cr[6].eq {
	pc = 0x825E2984; continue 'dispatch;
	}
	// 825E2960: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2964: C04BF678  lfs f2, -0x988(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2440 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E2968: 4800000C  b 0x825e2974
	pc = 0x825E2974; continue 'dispatch;
	// 825E296C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E2970: C04B74AC  lfs f2, 0x74ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29868 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E2974: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E2978: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E297C: C02A7DF0  lfs f1, 0x7df0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32240 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E2980: 488326A9  bl 0x82e15028
	ctx.lr = 0x825E2984;
	sub_82E15028(ctx, base);
	// 825E2984: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E2988: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E298C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E2990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2994: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E2998: 4BF2E1C1  bl 0x82510b58
	ctx.lr = 0x825E299C;
	sub_82510B58(ctx, base);
	// 825E299C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E29A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E29A4: 419A0008  beq cr6, 0x825e29ac
	if ctx.cr[6].eq {
	pc = 0x825E29AC; continue 'dispatch;
	}
	// 825E29A8: 4BCDDEE9  bl 0x822c0890
	ctx.lr = 0x825E29AC;
	sub_822C0890(ctx, base);
	// 825E29AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E29B0: 48848151  bl 0x82e2ab00
	ctx.lr = 0x825E29B4;
	sub_82E2AB00(ctx, base);
	// 825E29B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E29B8: 4BF300E1  bl 0x82512a98
	ctx.lr = 0x825E29BC;
	sub_82512A98(ctx, base);
	// 825E29BC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E29C0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825E29C4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825E29C8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825E29CC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825E29D0: 488BDD61  bl 0x82ea0730
	ctx.lr = 0x825E29D4;
	sub_82EA0730(ctx, base);
	// 825E29D4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825E29D8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E29DC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825E29E0: C02AC664  lfs f1, -0x399c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E29E4: 4893780D  bl 0x82f1a1f0
	ctx.lr = 0x825E29E8;
	sub_82F1A1F0(ctx, base);
	// 825E29E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E29EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E29F0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825E29F4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E29F8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E29FC: C04BD5B8  lfs f2, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E2A00: 48899619  bl 0x82e7c018
	ctx.lr = 0x825E2A04;
	sub_82E7C018(ctx, base);
	// 825E2A04: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825E2A08: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825E2A0C: 419A000C  beq cr6, 0x825e2a18
	if ctx.cr[6].eq {
	pc = 0x825E2A18; continue 'dispatch;
	}
	// 825E2A10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2A14: 4BD05835  bl 0x822e8248
	ctx.lr = 0x825E2A18;
	sub_822E8248(ctx, base);
	// 825E2A18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2A20: 388BF670  addi r4, r11, -0x990
	ctx.r[4].s64 = ctx.r[11].s64 + -2448;
	// 825E2A24: 48816B0D  bl 0x82df9530
	ctx.lr = 0x825E2A28;
	sub_82DF9530(ctx, base);
	// 825E2A28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E2A2C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 825E2A30: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E2A34: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E2A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E2A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2A40: 80CB6894  lwz r6, 0x6894(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26772 as u32) ) } as u64;
	// 825E2A44: 4BF306AD  bl 0x825130f0
	ctx.lr = 0x825E2A48;
	sub_825130F0(ctx, base);
	// 825E2A48: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E2A4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E2A50: 419A0008  beq cr6, 0x825e2a58
	if ctx.cr[6].eq {
	pc = 0x825E2A58; continue 'dispatch;
	}
	// 825E2A54: 4BD05815  bl 0x822e8268
	ctx.lr = 0x825E2A58;
	sub_822E8268(ctx, base);
	// 825E2A58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825E2A5C: 419A000C  beq cr6, 0x825e2a68
	if ctx.cr[6].eq {
	pc = 0x825E2A68; continue 'dispatch;
	}
	// 825E2A60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2A64: 4BD05805  bl 0x822e8268
	ctx.lr = 0x825E2A68;
	sub_822E8268(ctx, base);
	// 825E2A68: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E2A6C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825E2A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2A74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E2A78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E2A7C: 4E800421  bctrl
	ctx.lr = 0x825E2A80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E2A80: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825E2A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2A88: 419A015C  beq cr6, 0x825e2be4
	if ctx.cr[6].eq {
	pc = 0x825E2BE4; continue 'dispatch;
	}
	// 825E2A8C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825E2A90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E2A94: 38A000E9  li r5, 0xe9
	ctx.r[5].s64 = 233;
	// 825E2A98: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 825E2A9C: 4880F94D  bl 0x82df23e8
	ctx.lr = 0x825E2AA0;
	sub_82DF23E8(ctx, base);
	// 825E2AA0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825E2AA4: 41820048  beq 0x825e2aec
	if ctx.cr[0].eq {
	pc = 0x825E2AEC; continue 'dispatch;
	}
	// 825E2AA8: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825E2AAC: 395D0010  addi r10, r29, 0x10
	ctx.r[10].s64 = ctx.r[29].s64 + 16;
	// 825E2AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2AB4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825E2AB8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825E2ABC: 48810F4D  bl 0x82df3a08
	ctx.lr = 0x825E2AC0;
	sub_82DF3A08(ctx, base);
	// 825E2AC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2AC4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E2AC8: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 825E2ACC: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 825E2AD0: 4BF2C9F9  bl 0x8250f4c8
	ctx.lr = 0x825E2AD4;
	sub_8250F4C8(ctx, base);
	// 825E2AD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E2AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2ADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E2AE0: 485D1121  bl 0x82bb3c00
	ctx.lr = 0x825E2AE4;
	sub_82BB3C00(ctx, base);
	// 825E2AE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E2AE8: 48000008  b 0x825e2af0
	pc = 0x825E2AF0; continue 'dispatch;
	// 825E2AEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E2AF0: 3BDF017C  addi r30, r31, 0x17c
	ctx.r[30].s64 = ctx.r[31].s64 + 380;
	// 825E2AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2AF8: 4BD7A8E9  bl 0x8235d3e0
	ctx.lr = 0x825E2AFC;
	sub_8235D3E0(ctx, base);
	// 825E2AFC: 570B07BD  rlwinm. r11, r24, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E2B00: 41820010  beq 0x825e2b10
	if ctx.cr[0].eq {
	pc = 0x825E2B10; continue 'dispatch;
	}
	// 825E2B04: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E2B08: 571807FA  rlwinm r24, r24, 0, 0x1f, 0x1d
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825E2B0C: 4880F185  bl 0x82df1c90
	ctx.lr = 0x825E2B10;
	sub_82DF1C90(ctx, base);
	// 825E2B10: 570B07FF  clrlwi. r11, r24, 0x1f
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E2B14: 4182000C  beq 0x825e2b20
	if ctx.cr[0].eq {
	pc = 0x825E2B20; continue 'dispatch;
	}
	// 825E2B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2B1C: 4881090D  bl 0x82df3428
	ctx.lr = 0x825E2B20;
	sub_82DF3428(ctx, base);
	// 825E2B20: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825E2B24: 395D0010  addi r10, r29, 0x10
	ctx.r[10].s64 = ctx.r[29].s64 + 16;
	// 825E2B28: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E2B2C: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 825E2B30: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825E2B34: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825E2B38: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825E2B3C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E2B40: 38E7F3AC  addi r7, r7, -0xc54
	ctx.r[7].s64 = ctx.r[7].s64 + -3156;
	// 825E2B44: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E2B48: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825E2B4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E2B50: C0089534  lfs f0, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E2B54: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 825E2B58: D1A10098  stfs f13, 0x98(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825E2B5C: 90C1009C  stw r6, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[6].u32 ) };
	// 825E2B60: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 825E2B64: 994100AC  stb r10, 0xac(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[10].u8 ) };
	// 825E2B68: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 825E2B6C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825E2B70: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825E2B74: 4881BD55  bl 0x82dfe8c8
	ctx.lr = 0x825E2B78;
	sub_82DFE8C8(ctx, base);
	// 825E2B78: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E2B7C: 4881BD4D  bl 0x82dfe8c8
	ctx.lr = 0x825E2B80;
	sub_82DFE8C8(ctx, base);
	// 825E2B80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825E2B84: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825E2B88: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2B8C: 485D23D5  bl 0x82bb4f60
	ctx.lr = 0x825E2B90;
	sub_82BB4F60(ctx, base);
	// 825E2B90: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E2B94: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E2B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2B9C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825E2BA0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825E2BA4: 419A0024  beq cr6, 0x825e2bc8
	if ctx.cr[6].eq {
	pc = 0x825E2BC8; continue 'dispatch;
	}
	// 825E2BA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E2BAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E2BB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2BB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E2BB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E2BBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E2BC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E2BC4: 4082FFE8  bne 0x825e2bac
	if !ctx.cr[0].eq {
	pc = 0x825E2BAC; continue 'dispatch;
	}
	// 825E2BC8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E2BCC: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 825E2BD0: 488323A1  bl 0x82e14f70
	ctx.lr = 0x825E2BD4;
	sub_82E14F70(ctx, base);
	// 825E2BD4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E2BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E2BDC: 419A0008  beq cr6, 0x825e2be4
	if ctx.cr[6].eq {
	pc = 0x825E2BE4; continue 'dispatch;
	}
	// 825E2BE0: 4BCDDCB1  bl 0x822c0890
	ctx.lr = 0x825E2BE4;
	sub_822C0890(ctx, base);
	// 825E2BE4: 897F01A5  lbz r11, 0x1a5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(421 as u32) ) } as u64;
	// 825E2BE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2BEC: 4182000C  beq 0x825e2bf8
	if ctx.cr[0].eq {
	pc = 0x825E2BF8; continue 'dispatch;
	}
	// 825E2BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2BF4: 4BFFF66D  bl 0x825e2260
	ctx.lr = 0x825E2BF8;
	sub_825E2260(ctx, base);
	// 825E2BF8: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825E2BFC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825E2C00: 409A000C  bne cr6, 0x825e2c0c
	if !ctx.cr[6].eq {
	pc = 0x825E2C0C; continue 'dispatch;
	}
	// 825E2C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2C08: 4BFFF7B1  bl 0x825e23b8
	ctx.lr = 0x825E2C0C;
	sub_825E23B8(ctx, base);
	// 825E2C0C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825E2C10: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825E2C14: 48BC5594  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E2C18 size=392
    let mut pc: u32 = 0x825E2C18;
    'dispatch: loop {
        match pc {
            0x825E2C18 => {
    //   block [0x825E2C18..0x825E2DA0)
	// 825E2C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2C1C: 48BC554D  bl 0x831a8168
	ctx.lr = 0x825E2C20;
	sub_831A8130(ctx, base);
	// 825E2C20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E2C24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E2C28: 897E01D0  lbz r11, 0x1d0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(464 as u32) ) } as u64;
	// 825E2C2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2C30: 41820008  beq 0x825e2c38
	if ctx.cr[0].eq {
	pc = 0x825E2C38; continue 'dispatch;
	}
	// 825E2C34: 4BFFF4ED  bl 0x825e2120
	ctx.lr = 0x825E2C38;
	sub_825E2120(ctx, base);
	// 825E2C38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2C3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E2C40: 3B8BF350  addi r28, r11, -0xcb0
	ctx.r[28].s64 = ctx.r[11].s64 + -3248;
	// 825E2C44: 38A00201  li r5, 0x201
	ctx.r[5].s64 = 513;
	// 825E2C48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E2C4C: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825E2C50: 4880F799  bl 0x82df23e8
	ctx.lr = 0x825E2C54;
	sub_82DF23E8(ctx, base);
	// 825E2C54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E2C58: 4182001C  beq 0x825e2c74
	if ctx.cr[0].eq {
	pc = 0x825E2C74; continue 'dispatch;
	}
	// 825E2C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2C60: 48876A21  bl 0x82e59680
	ctx.lr = 0x825E2C64;
	sub_82E59680(ctx, base);
	// 825E2C64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2C68: 396BF294  addi r11, r11, -0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + -3436;
	// 825E2C6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E2C70: 48000008  b 0x825e2c78
	pc = 0x825E2C78; continue 'dispatch;
	// 825E2C74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E2C78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E2C7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2C80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E2C84: 4BFFDC7D  bl 0x825e0900
	ctx.lr = 0x825E2C88;
	sub_825E0900(ctx, base);
	// 825E2C88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E2C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E2C90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E2C94: 4BCDD36D  bl 0x822c0000
	ctx.lr = 0x825E2C98;
	sub_822C0000(ctx, base);
	// 825E2C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2C9C: 4BF2EE4D  bl 0x82511ae8
	ctx.lr = 0x825E2CA0;
	sub_82511AE8(ctx, base);
	// 825E2CA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E2CA4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E2CA8: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825E2CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2CB0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E2DA0 size=168
    let mut pc: u32 = 0x825E2DA0;
    'dispatch: loop {
        match pc {
            0x825E2DA0 => {
    //   block [0x825E2DA0..0x825E2E48)
	// 825E2DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E2DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E2DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E2DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E2DB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E2DB8: 897E00C1  lbz r11, 0xc1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(193 as u32) ) } as u64;
	// 825E2DBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2DC0: 4182001C  beq 0x825e2ddc
	if ctx.cr[0].eq {
	pc = 0x825E2DDC; continue 'dispatch;
	}
	// 825E2DC4: 815E006C  lwz r10, 0x6c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E2DC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E2DCC: 409A0010  bne cr6, 0x825e2ddc
	if !ctx.cr[6].eq {
	pc = 0x825E2DDC; continue 'dispatch;
	}
	// 825E2DD0: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 825E2DD4: 4BFFF48D  bl 0x825e2260
	ctx.lr = 0x825E2DD8;
	sub_825E2260(ctx, base);
	// 825E2DD8: 48000050  b 0x825e2e28
	pc = 0x825E2E28; continue 'dispatch;
	// 825E2DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2DE0: 409A0048  bne cr6, 0x825e2e28
	if !ctx.cr[6].eq {
	pc = 0x825E2E28; continue 'dispatch;
	}
	// 825E2DE4: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E2DE8: 3BFE006C  addi r31, r30, 0x6c
	ctx.r[31].s64 = ctx.r[30].s64 + 108;
	// 825E2DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2DF0: 419A0038  beq cr6, 0x825e2e28
	if ctx.cr[6].eq {
	pc = 0x825E2E28; continue 'dispatch;
	}
	// 825E2DF4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E2DF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E2DFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E2E00: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 825E2E04: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E2E08: 4BF2D3E9  bl 0x825101f0
	ctx.lr = 0x825E2E0C;
	sub_825101F0(ctx, base);
	// 825E2E0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E2E10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E2E14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E2E18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E2E1C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825E2E20: 419A0008  beq cr6, 0x825e2e28
	if ctx.cr[6].eq {
	pc = 0x825E2E28; continue 'dispatch;
	}
	// 825E2E24: 4BCDDA6D  bl 0x822c0890
	ctx.lr = 0x825E2E28;
	sub_822C0890(ctx, base);
	// 825E2E28: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 825E2E2C: 4BFFDCC5  bl 0x825e0af0
	ctx.lr = 0x825E2E30;
	sub_825E0AF0(ctx, base);
	// 825E2E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E2E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E2E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E2E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E2E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E2E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E2E48 size=184
    let mut pc: u32 = 0x825E2E48;
    'dispatch: loop {
        match pc {
            0x825E2E48 => {
    //   block [0x825E2E48..0x825E2F00)
	// 825E2E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E2E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E2E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E2E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E2E5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E2E60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E2E64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E2E68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E2E6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E2E70: 4BCDDAC9  bl 0x822c0938
	ctx.lr = 0x825E2E74;
	sub_822C0938(ctx, base);
	// 825E2E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E2E78: 41820028  beq 0x825e2ea0
	if ctx.cr[0].eq {
	pc = 0x825E2EA0; continue 'dispatch;
	}
	// 825E2E7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E2E80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E2E84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E2E88: 392BF1CC  addi r9, r11, -0xe34
	ctx.r[9].s64 = ctx.r[11].s64 + -3636;
	// 825E2E8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E2E90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E2E94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E2E98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E2E9C: 48000008  b 0x825e2ea4
	pc = 0x825E2EA4; continue 'dispatch;
	// 825E2EA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E2EA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E2EA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E2EAC: 409A0038  bne cr6, 0x825e2ee4
	if !ctx.cr[6].eq {
	pc = 0x825E2EE4; continue 'dispatch;
	}
	// 825E2EB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E2EB4: 419A0010  beq cr6, 0x825e2ec4
	if ctx.cr[6].eq {
	pc = 0x825E2EC4; continue 'dispatch;
	}
	// 825E2EB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E2EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E2EC0: 4BF45939  bl 0x825287f8
	ctx.lr = 0x825E2EC4;
	sub_825287F8(ctx, base);
	// 825E2EC4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E2EC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E2ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E2ED0: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E2ED4: 816BD678  lwz r11, -0x2988(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10632 as u32) ) } as u64;
	// 825E2ED8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E2EDC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E2EE0: 4BCDD121  bl 0x822c0000
	ctx.lr = 0x825E2EE4;
	sub_822C0000(ctx, base);
	// 825E2EE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E2EE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E2EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E2EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E2EF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E2EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E2EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E2F00 size=440
    let mut pc: u32 = 0x825E2F00;
    'dispatch: loop {
        match pc {
            0x825E2F00 => {
    //   block [0x825E2F00..0x825E30B8)
	// 825E2F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2F04: 48BC5269  bl 0x831a816c
	ctx.lr = 0x825E2F08;
	sub_831A8130(ctx, base);
	// 825E2F08: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E30B8 size=288
    let mut pc: u32 = 0x825E30B8;
    'dispatch: loop {
        match pc {
            0x825E30B8 => {
    //   block [0x825E30B8..0x825E31D8)
	// 825E30B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E30BC: 48BC50A5  bl 0x831a8160
	ctx.lr = 0x825E30C0;
	sub_831A8130(ctx, base);
	// 825E30C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E30C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E30C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E30CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E30D0: 388BF350  addi r4, r11, -0xcb0
	ctx.r[4].s64 = ctx.r[11].s64 + -3248;
	// 825E30D4: 38A001B2  li r5, 0x1b2
	ctx.r[5].s64 = 434;
	// 825E30D8: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825E30DC: 4880F30D  bl 0x82df23e8
	ctx.lr = 0x825E30E0;
	sub_82DF23E8(ctx, base);
	// 825E30E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E30E4: 41820014  beq 0x825e30f8
	if ctx.cr[0].eq {
	pc = 0x825E30F8; continue 'dispatch;
	}
	// 825E30E8: C03C00C4  lfs f1, 0xc4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E30EC: 4816DBED  bl 0x82750cd8
	ctx.lr = 0x825E30F0;
	sub_82750CD8(ctx, base);
	// 825E30F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E30F4: 48000008  b 0x825e30fc
	pc = 0x825E30FC; continue 'dispatch;
	// 825E30F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E30FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E3100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3104: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3108: 4BFFD731  bl 0x825e0838
	ctx.lr = 0x825E310C;
	sub_825E0838(ctx, base);
	// 825E310C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3114: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3118: 4BCDCEE9  bl 0x822c0000
	ctx.lr = 0x825E311C;
	sub_822C0000(ctx, base);
	// 825E311C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E3120: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E3124: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3128: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825E312C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E3130: 419A0024  beq cr6, 0x825e3154
	if ctx.cr[6].eq {
	pc = 0x825E3154; continue 'dispatch;
	}
	// 825E3134: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3138: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E313C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3140: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E3144: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E3148: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E314C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3150: 4082FFE8  bne 0x825e3138
	if !ctx.cr[0].eq {
	pc = 0x825E3138; continue 'dispatch;
	}
	// 825E3154: 3BFCFF1C  addi r31, r28, -0xe4
	ctx.r[31].s64 = ctx.r[28].s64 + -228;
	// 825E3158: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E315C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3160: 4BF2C369  bl 0x8250f4c8
	ctx.lr = 0x825E3164;
	sub_8250F4C8(ctx, base);
	// 825E3164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E3168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E316C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825E3170: 409A0008  bne cr6, 0x825e3178
	if !ctx.cr[6].eq {
	pc = 0x825E3178; continue 'dispatch;
	}
	// 825E3174: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E3178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E317C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E3180: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 825E3184: 4BF2C395  bl 0x8250f518
	ctx.lr = 0x825E3188;
	sub_8250F518(ctx, base);
	// 825E3188: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E318C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3190: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825E3194: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825E3198: 4BF2A371  bl 0x8250d508
	ctx.lr = 0x825E319C;
	sub_8250D508(ctx, base);
	// 825E319C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E31A0: 4880EAF1  bl 0x82df1c90
	ctx.lr = 0x825E31A4;
	sub_82DF1C90(ctx, base);
	// 825E31A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E31A8: 4880EAE9  bl 0x82df1c90
	ctx.lr = 0x825E31AC;
	sub_82DF1C90(ctx, base);
	// 825E31AC: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 825E31B0: 48A25E09  bl 0x83008fb8
	ctx.lr = 0x825E31B4;
	sub_83008FB8(ctx, base);
	// 825E31B4: 907C0094  stw r3, 0x94(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 825E31B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E31BC: 4BFFFA5D  bl 0x825e2c18
	ctx.lr = 0x825E31C0;
	sub_825E2C18(ctx, base);
	// 825E31C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E31C4: 419A000C  beq cr6, 0x825e31d0
	if ctx.cr[6].eq {
	pc = 0x825E31D0; continue 'dispatch;
	}
	// 825E31C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E31CC: 4BCDD6C5  bl 0x822c0890
	ctx.lr = 0x825E31D0;
	sub_822C0890(ctx, base);
	// 825E31D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825E31D4: 48BC4FDC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E31D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E31D8 size=468
    let mut pc: u32 = 0x825E31D8;
    'dispatch: loop {
        match pc {
            0x825E31D8 => {
    //   block [0x825E31D8..0x825E33AC)
	// 825E31D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E31DC: 48BC4F8D  bl 0x831a8168
	ctx.lr = 0x825E31E0;
	sub_831A8130(ctx, base);
	// 825E31E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E31E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E31E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E31EC: 3BCBF350  addi r30, r11, -0xcb0
	ctx.r[30].s64 = ctx.r[11].s64 + -3248;
	// 825E31F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E31F4: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 825E31F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E31FC: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 825E3200: 4880F1E9  bl 0x82df23e8
	ctx.lr = 0x825E3204;
	sub_82DF23E8(ctx, base);
	// 825E3204: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3208: 41820014  beq 0x825e321c
	if ctx.cr[0].eq {
	pc = 0x825E321C; continue 'dispatch;
	}
	// 825E320C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E3210: 4BFFDC69  bl 0x825e0e78
	ctx.lr = 0x825E3214;
	sub_825E0E78(ctx, base);
	// 825E3214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3218: 48000008  b 0x825e3220
	pc = 0x825E3220; continue 'dispatch;
	// 825E321C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E3220: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E3224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3228: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E322C: 4BFFD3B5  bl 0x825e05e0
	ctx.lr = 0x825E3230;
	sub_825E05E0(ctx, base);
	// 825E3230: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3238: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E323C: 4BCDCDC5  bl 0x822c0000
	ctx.lr = 0x825E3240;
	sub_822C0000(ctx, base);
	// 825E3240: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E3244: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E3248: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 825E324C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825E3250: 4BCDD189  bl 0x822c03d8
	ctx.lr = 0x825E3254;
	sub_822C03D8(ctx, base);
	// 825E3254: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E3258: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E325C: 418200A0  beq 0x825e32fc
	if ctx.cr[0].eq {
	pc = 0x825E32FC; continue 'dispatch;
	}
	// 825E3260: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E3264: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E3268: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E326C: 409A0008  bne cr6, 0x825e3274
	if !ctx.cr[6].eq {
	pc = 0x825E3274; continue 'dispatch;
	}
	// 825E3270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3274: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E3278: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E327C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E3280: 419A0024  beq cr6, 0x825e32a4
	if ctx.cr[6].eq {
	pc = 0x825E32A4; continue 'dispatch;
	}
	// 825E3284: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3288: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E328C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3290: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E3294: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E3298: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E329C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E32A0: 4082FFE8  bne 0x825e3288
	if !ctx.cr[0].eq {
	pc = 0x825E3288; continue 'dispatch;
	}
	// 825E32A4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825E32A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E32AC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825E32B0: 419A0024  beq cr6, 0x825e32d4
	if ctx.cr[6].eq {
	pc = 0x825E32D4; continue 'dispatch;
	}
	// 825E32B4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E32B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E32BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E32C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E32C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E32C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E32CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E32D0: 4082FFE8  bne 0x825e32b8
	if !ctx.cr[0].eq {
	pc = 0x825E32B8; continue 'dispatch;
	}
	// 825E32D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E32D8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825E32DC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825E32E0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825E32E4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825E32E8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E32EC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E32F0: 481B5C41  bl 0x82798f30
	ctx.lr = 0x825E32F4;
	sub_82798F30(ctx, base);
	// 825E32F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E32F8: 48000008  b 0x825e3300
	pc = 0x825E3300; continue 'dispatch;
	// 825E32FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E3300: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E3304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3308: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E330C: 4BFFFB3D  bl 0x825e2e48
	ctx.lr = 0x825E3310;
	sub_825E2E48(ctx, base);
	// 825E3310: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E331C: 4BCDCCE5  bl 0x822c0000
	ctx.lr = 0x825E3320;
	sub_822C0000(ctx, base);
	// 825E3320: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E3324: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E3328: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E332C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E3330: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 825E3334: 916A0038  stw r11, 0x38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825E3338: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E333C: 4BCDD09D  bl 0x822c03d8
	ctx.lr = 0x825E3340;
	sub_822C03D8(ctx, base);
	// 825E3340: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3344: 41820014  beq 0x825e3358
	if ctx.cr[0].eq {
	pc = 0x825E3358; continue 'dispatch;
	}
	// 825E3348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E334C: 481B5E3D  bl 0x82799188
	ctx.lr = 0x825E3350;
	sub_82799188(ctx, base);
	// 825E3350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3354: 48000008  b 0x825e335c
	pc = 0x825E335C; continue 'dispatch;
	// 825E3358: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E335C: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E3360: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825E3364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3368: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E336C: 4BFB48E5  bl 0x82597c50
	ctx.lr = 0x825E3370;
	sub_82597C50(ctx, base);
	// 825E3370: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E337C: 4BCDCC85  bl 0x822c0000
	ctx.lr = 0x825E3380;
	sub_822C0000(ctx, base);
	// 825E3380: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E3384: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3388: 419A0008  beq cr6, 0x825e3390
	if ctx.cr[6].eq {
	pc = 0x825E3390; continue 'dispatch;
	}
	// 825E338C: 4BCDD505  bl 0x822c0890
	ctx.lr = 0x825E3390;
	sub_822C0890(ctx, base);
	// 825E3390: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3394: 419A000C  beq cr6, 0x825e33a0
	if ctx.cr[6].eq {
	pc = 0x825E33A0; continue 'dispatch;
	}
	// 825E3398: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E339C: 4BCDD4F5  bl 0x822c0890
	ctx.lr = 0x825E33A0;
	sub_822C0890(ctx, base);
	// 825E33A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E33A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825E33A8: 48BC4E10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E33B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E33B0 size=468
    let mut pc: u32 = 0x825E33B0;
    'dispatch: loop {
        match pc {
            0x825E33B0 => {
    //   block [0x825E33B0..0x825E3584)
	// 825E33B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E33B4: 48BC4DB5  bl 0x831a8168
	ctx.lr = 0x825E33B8;
	sub_831A8130(ctx, base);
	// 825E33B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E33BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E33C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E33C4: 3BCBF350  addi r30, r11, -0xcb0
	ctx.r[30].s64 = ctx.r[11].s64 + -3248;
	// 825E33C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E33CC: 38A00062  li r5, 0x62
	ctx.r[5].s64 = 98;
	// 825E33D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E33D4: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 825E33D8: 4880F011  bl 0x82df23e8
	ctx.lr = 0x825E33DC;
	sub_82DF23E8(ctx, base);
	// 825E33DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E33E0: 41820014  beq 0x825e33f4
	if ctx.cr[0].eq {
	pc = 0x825E33F4; continue 'dispatch;
	}
	// 825E33E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E33E8: 4BFFDA91  bl 0x825e0e78
	ctx.lr = 0x825E33EC;
	sub_825E0E78(ctx, base);
	// 825E33EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E33F0: 48000008  b 0x825e33f8
	pc = 0x825E33F8; continue 'dispatch;
	// 825E33F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E33F8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E33FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3400: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E3404: 4BFFD1DD  bl 0x825e05e0
	ctx.lr = 0x825E3408;
	sub_825E05E0(ctx, base);
	// 825E3408: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E340C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3410: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E3414: 4BCDCBED  bl 0x822c0000
	ctx.lr = 0x825E3418;
	sub_822C0000(ctx, base);
	// 825E3418: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E341C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E3420: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 825E3424: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825E3428: 4BCDCFB1  bl 0x822c03d8
	ctx.lr = 0x825E342C;
	sub_822C03D8(ctx, base);
	// 825E342C: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E3430: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3434: 418200A0  beq 0x825e34d4
	if ctx.cr[0].eq {
	pc = 0x825E34D4; continue 'dispatch;
	}
	// 825E3438: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E343C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E3440: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E3444: 409A0008  bne cr6, 0x825e344c
	if !ctx.cr[6].eq {
	pc = 0x825E344C; continue 'dispatch;
	}
	// 825E3448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E344C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E3450: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3454: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E3458: 419A0024  beq cr6, 0x825e347c
	if ctx.cr[6].eq {
	pc = 0x825E347C; continue 'dispatch;
	}
	// 825E345C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3460: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E3464: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3468: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E346C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E3470: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E3474: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3478: 4082FFE8  bne 0x825e3460
	if !ctx.cr[0].eq {
	pc = 0x825E3460; continue 'dispatch;
	}
	// 825E347C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825E3480: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3484: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825E3488: 419A0024  beq cr6, 0x825e34ac
	if ctx.cr[6].eq {
	pc = 0x825E34AC; continue 'dispatch;
	}
	// 825E348C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3490: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E3494: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3498: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E349C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E34A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E34A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E34A8: 4082FFE8  bne 0x825e3490
	if !ctx.cr[0].eq {
	pc = 0x825E3490; continue 'dispatch;
	}
	// 825E34AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E34B0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825E34B4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825E34B8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825E34BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825E34C0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E34C4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E34C8: 481B5A69  bl 0x82798f30
	ctx.lr = 0x825E34CC;
	sub_82798F30(ctx, base);
	// 825E34CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E34D0: 48000008  b 0x825e34d8
	pc = 0x825E34D8; continue 'dispatch;
	// 825E34D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E34D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E34DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E34E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E34E4: 4BFFF965  bl 0x825e2e48
	ctx.lr = 0x825E34E8;
	sub_825E2E48(ctx, base);
	// 825E34E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E34EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E34F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E34F4: 4BCDCB0D  bl 0x822c0000
	ctx.lr = 0x825E34F8;
	sub_822C0000(ctx, base);
	// 825E34F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E34FC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E3500: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E3504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E3508: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 825E350C: 916A0038  stw r11, 0x38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825E3510: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E3514: 4BCDCEC5  bl 0x822c03d8
	ctx.lr = 0x825E3518;
	sub_822C03D8(ctx, base);
	// 825E3518: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E351C: 41820014  beq 0x825e3530
	if ctx.cr[0].eq {
	pc = 0x825E3530; continue 'dispatch;
	}
	// 825E3520: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E3524: 481B5C65  bl 0x82799188
	ctx.lr = 0x825E3528;
	sub_82799188(ctx, base);
	// 825E3528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E352C: 48000008  b 0x825e3534
	pc = 0x825E3534; continue 'dispatch;
	// 825E3530: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E3534: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E3538: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825E353C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3544: 4BFB470D  bl 0x82597c50
	ctx.lr = 0x825E3548;
	sub_82597C50(ctx, base);
	// 825E3548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E354C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3554: 4BCDCAAD  bl 0x822c0000
	ctx.lr = 0x825E3558;
	sub_822C0000(ctx, base);
	// 825E3558: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E355C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3560: 419A0008  beq cr6, 0x825e3568
	if ctx.cr[6].eq {
	pc = 0x825E3568; continue 'dispatch;
	}
	// 825E3564: 4BCDD32D  bl 0x822c0890
	ctx.lr = 0x825E3568;
	sub_822C0890(ctx, base);
	// 825E3568: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E356C: 419A000C  beq cr6, 0x825e3578
	if ctx.cr[6].eq {
	pc = 0x825E3578; continue 'dispatch;
	}
	// 825E3570: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E3574: 4BCDD31D  bl 0x822c0890
	ctx.lr = 0x825E3578;
	sub_822C0890(ctx, base);
	// 825E3578: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E357C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825E3580: 48BC4C38  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E3588 size=468
    let mut pc: u32 = 0x825E3588;
    'dispatch: loop {
        match pc {
            0x825E3588 => {
    //   block [0x825E3588..0x825E375C)
	// 825E3588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E358C: 48BC4BDD  bl 0x831a8168
	ctx.lr = 0x825E3590;
	sub_831A8130(ctx, base);
	// 825E3590: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3594: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3598: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E359C: 3BCBF350  addi r30, r11, -0xcb0
	ctx.r[30].s64 = ctx.r[11].s64 + -3248;
	// 825E35A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E35A4: 38A0006A  li r5, 0x6a
	ctx.r[5].s64 = 106;
	// 825E35A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E35AC: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 825E35B0: 4880EE39  bl 0x82df23e8
	ctx.lr = 0x825E35B4;
	sub_82DF23E8(ctx, base);
	// 825E35B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E35B8: 41820014  beq 0x825e35cc
	if ctx.cr[0].eq {
	pc = 0x825E35CC; continue 'dispatch;
	}
	// 825E35BC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825E35C0: 4BFFD8B9  bl 0x825e0e78
	ctx.lr = 0x825E35C4;
	sub_825E0E78(ctx, base);
	// 825E35C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E35C8: 48000008  b 0x825e35d0
	pc = 0x825E35D0; continue 'dispatch;
	// 825E35CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E35D0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E35D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E35D8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E35DC: 4BFFD005  bl 0x825e05e0
	ctx.lr = 0x825E35E0;
	sub_825E05E0(ctx, base);
	// 825E35E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E35E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E35E8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E35EC: 4BCDCA15  bl 0x822c0000
	ctx.lr = 0x825E35F0;
	sub_822C0000(ctx, base);
	// 825E35F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E35F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E35F8: 38A0006B  li r5, 0x6b
	ctx.r[5].s64 = 107;
	// 825E35FC: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825E3600: 4BCDCDD9  bl 0x822c03d8
	ctx.lr = 0x825E3604;
	sub_822C03D8(ctx, base);
	// 825E3604: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E3608: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E360C: 418200A0  beq 0x825e36ac
	if ctx.cr[0].eq {
	pc = 0x825E36AC; continue 'dispatch;
	}
	// 825E3610: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E3614: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E3618: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E361C: 409A0008  bne cr6, 0x825e3624
	if !ctx.cr[6].eq {
	pc = 0x825E3624; continue 'dispatch;
	}
	// 825E3620: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E3628: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E362C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E3630: 419A0024  beq cr6, 0x825e3654
	if ctx.cr[6].eq {
	pc = 0x825E3654; continue 'dispatch;
	}
	// 825E3634: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3638: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E363C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3640: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E3644: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E3648: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E364C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3650: 4082FFE8  bne 0x825e3638
	if !ctx.cr[0].eq {
	pc = 0x825E3638; continue 'dispatch;
	}
	// 825E3654: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825E3658: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E365C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825E3660: 419A0024  beq cr6, 0x825e3684
	if ctx.cr[6].eq {
	pc = 0x825E3684; continue 'dispatch;
	}
	// 825E3664: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3668: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E366C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3670: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E3674: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E3678: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E367C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3680: 4082FFE8  bne 0x825e3668
	if !ctx.cr[0].eq {
	pc = 0x825E3668; continue 'dispatch;
	}
	// 825E3684: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E3688: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825E368C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E3690: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825E3694: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825E3698: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E369C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E36A0: 481B5891  bl 0x82798f30
	ctx.lr = 0x825E36A4;
	sub_82798F30(ctx, base);
	// 825E36A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E36A8: 48000008  b 0x825e36b0
	pc = 0x825E36B0; continue 'dispatch;
	// 825E36AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E36B0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E36B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E36B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E36BC: 4BFFF78D  bl 0x825e2e48
	ctx.lr = 0x825E36C0;
	sub_825E2E48(ctx, base);
	// 825E36C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E36C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E36C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E36CC: 4BCDC935  bl 0x822c0000
	ctx.lr = 0x825E36D0;
	sub_822C0000(ctx, base);
	// 825E36D0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E36D4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E36D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E36DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E36E0: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 825E36E4: 916A0038  stw r11, 0x38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825E36E8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E36EC: 4BCDCCED  bl 0x822c03d8
	ctx.lr = 0x825E36F0;
	sub_822C03D8(ctx, base);
	// 825E36F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E36F4: 41820014  beq 0x825e3708
	if ctx.cr[0].eq {
	pc = 0x825E3708; continue 'dispatch;
	}
	// 825E36F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E36FC: 481B5A8D  bl 0x82799188
	ctx.lr = 0x825E3700;
	sub_82799188(ctx, base);
	// 825E3700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3704: 48000008  b 0x825e370c
	pc = 0x825E370C; continue 'dispatch;
	// 825E3708: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E370C: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E3710: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825E3714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E371C: 4BFB4535  bl 0x82597c50
	ctx.lr = 0x825E3720;
	sub_82597C50(ctx, base);
	// 825E3720: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E372C: 4BCDC8D5  bl 0x822c0000
	ctx.lr = 0x825E3730;
	sub_822C0000(ctx, base);
	// 825E3730: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E3734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3738: 419A0008  beq cr6, 0x825e3740
	if ctx.cr[6].eq {
	pc = 0x825E3740; continue 'dispatch;
	}
	// 825E373C: 4BCDD155  bl 0x822c0890
	ctx.lr = 0x825E3740;
	sub_822C0890(ctx, base);
	// 825E3740: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3744: 419A000C  beq cr6, 0x825e3750
	if ctx.cr[6].eq {
	pc = 0x825E3750; continue 'dispatch;
	}
	// 825E3748: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E374C: 4BCDD145  bl 0x822c0890
	ctx.lr = 0x825E3750;
	sub_822C0890(ctx, base);
	// 825E3750: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E3754: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825E3758: 48BC4A60  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E3760 size=468
    let mut pc: u32 = 0x825E3760;
    'dispatch: loop {
        match pc {
            0x825E3760 => {
    //   block [0x825E3760..0x825E3934)
	// 825E3760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3764: 48BC4A05  bl 0x831a8168
	ctx.lr = 0x825E3768;
	sub_831A8130(ctx, base);
	// 825E3768: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E376C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3770: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E3774: 3BCBF350  addi r30, r11, -0xcb0
	ctx.r[30].s64 = ctx.r[11].s64 + -3248;
	// 825E3778: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E377C: 38A00072  li r5, 0x72
	ctx.r[5].s64 = 114;
	// 825E3780: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E3784: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 825E3788: 4880EC61  bl 0x82df23e8
	ctx.lr = 0x825E378C;
	sub_82DF23E8(ctx, base);
	// 825E378C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3790: 41820014  beq 0x825e37a4
	if ctx.cr[0].eq {
	pc = 0x825E37A4; continue 'dispatch;
	}
	// 825E3794: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825E3798: 4BFFD6E1  bl 0x825e0e78
	ctx.lr = 0x825E379C;
	sub_825E0E78(ctx, base);
	// 825E379C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E37A0: 48000008  b 0x825e37a8
	pc = 0x825E37A8; continue 'dispatch;
	// 825E37A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E37A8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E37AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E37B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E37B4: 4BFFCE2D  bl 0x825e05e0
	ctx.lr = 0x825E37B8;
	sub_825E05E0(ctx, base);
	// 825E37B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E37BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E37C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E37C4: 4BCDC83D  bl 0x822c0000
	ctx.lr = 0x825E37C8;
	sub_822C0000(ctx, base);
	// 825E37C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E37CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E37D0: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825E37D4: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825E37D8: 4BCDCC01  bl 0x822c03d8
	ctx.lr = 0x825E37DC;
	sub_822C03D8(ctx, base);
	// 825E37DC: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E37E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E37E4: 418200A0  beq 0x825e3884
	if ctx.cr[0].eq {
	pc = 0x825E3884; continue 'dispatch;
	}
	// 825E37E8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E37EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E37F0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E37F4: 409A0008  bne cr6, 0x825e37fc
	if !ctx.cr[6].eq {
	pc = 0x825E37FC; continue 'dispatch;
	}
	// 825E37F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E37FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E3800: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3804: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E3808: 419A0024  beq cr6, 0x825e382c
	if ctx.cr[6].eq {
	pc = 0x825E382C; continue 'dispatch;
	}
	// 825E380C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3810: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E3814: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3818: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E381C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E3820: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E3824: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3828: 4082FFE8  bne 0x825e3810
	if !ctx.cr[0].eq {
	pc = 0x825E3810; continue 'dispatch;
	}
	// 825E382C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825E3830: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E3834: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825E3838: 419A0024  beq cr6, 0x825e385c
	if ctx.cr[6].eq {
	pc = 0x825E385C; continue 'dispatch;
	}
	// 825E383C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E3840: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E3844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3848: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E384C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E3850: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E3854: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E3858: 4082FFE8  bne 0x825e3840
	if !ctx.cr[0].eq {
	pc = 0x825E3840; continue 'dispatch;
	}
	// 825E385C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E3860: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825E3864: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E3868: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825E386C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825E3870: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E3874: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E3878: 481B56B9  bl 0x82798f30
	ctx.lr = 0x825E387C;
	sub_82798F30(ctx, base);
	// 825E387C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3880: 48000008  b 0x825e3888
	pc = 0x825E3888; continue 'dispatch;
	// 825E3884: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E3888: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E388C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3890: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3894: 4BFFF5B5  bl 0x825e2e48
	ctx.lr = 0x825E3898;
	sub_825E2E48(ctx, base);
	// 825E3898: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E389C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E38A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E38A4: 4BCDC75D  bl 0x822c0000
	ctx.lr = 0x825E38A8;
	sub_822C0000(ctx, base);
	// 825E38A8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E38AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E38B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E38B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E38B8: 38A00075  li r5, 0x75
	ctx.r[5].s64 = 117;
	// 825E38BC: 916A0038  stw r11, 0x38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825E38C0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E38C4: 4BCDCB15  bl 0x822c03d8
	ctx.lr = 0x825E38C8;
	sub_822C03D8(ctx, base);
	// 825E38C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E38CC: 41820014  beq 0x825e38e0
	if ctx.cr[0].eq {
	pc = 0x825E38E0; continue 'dispatch;
	}
	// 825E38D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E38D4: 481B58B5  bl 0x82799188
	ctx.lr = 0x825E38D8;
	sub_82799188(ctx, base);
	// 825E38D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E38DC: 48000008  b 0x825e38e4
	pc = 0x825E38E4; continue 'dispatch;
	// 825E38E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E38E4: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E38E8: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825E38EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E38F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E38F4: 4BFB435D  bl 0x82597c50
	ctx.lr = 0x825E38F8;
	sub_82597C50(ctx, base);
	// 825E38F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E38FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3904: 4BCDC6FD  bl 0x822c0000
	ctx.lr = 0x825E3908;
	sub_822C0000(ctx, base);
	// 825E3908: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E390C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3910: 419A0008  beq cr6, 0x825e3918
	if ctx.cr[6].eq {
	pc = 0x825E3918; continue 'dispatch;
	}
	// 825E3914: 4BCDCF7D  bl 0x822c0890
	ctx.lr = 0x825E3918;
	sub_822C0890(ctx, base);
	// 825E3918: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E391C: 419A000C  beq cr6, 0x825e3928
	if ctx.cr[6].eq {
	pc = 0x825E3928; continue 'dispatch;
	}
	// 825E3920: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E3924: 4BCDCF6D  bl 0x822c0890
	ctx.lr = 0x825E3928;
	sub_822C0890(ctx, base);
	// 825E3928: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E392C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825E3930: 48BC4888  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E3938 size=12
    let mut pc: u32 = 0x825E3938;
    'dispatch: loop {
        match pc {
            0x825E3938 => {
    //   block [0x825E3938..0x825E3944)
	// 825E3938: 80630118  lwz r3, 0x118(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 825E393C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3940: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3944(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E3944 size=8
    let mut pc: u32 = 0x825E3944;
    'dispatch: loop {
        match pc {
            0x825E3944 => {
    //   block [0x825E3944..0x825E394C)
	// 825E3944: 481B4BFC  b 0x82798540
	sub_82798540(ctx, base);
	return;
	// 825E3948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3950 size=196
    let mut pc: u32 = 0x825E3950;
    'dispatch: loop {
        match pc {
            0x825E3950 => {
    //   block [0x825E3950..0x825E3A14)
	// 825E3950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E395C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E3968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E396C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E3970: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E3974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3978: 4BCDCFC1  bl 0x822c0938
	ctx.lr = 0x825E397C;
	sub_822C0938(ctx, base);
	// 825E397C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3980: 41820028  beq 0x825e39a8
	if ctx.cr[0].eq {
	pc = 0x825E39A8; continue 'dispatch;
	}
	// 825E3984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3988: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E398C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E3990: 392BF69C  addi r9, r11, -0x964
	ctx.r[9].s64 = ctx.r[11].s64 + -2404;
	// 825E3994: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E3998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E399C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E39A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E39A4: 48000008  b 0x825e39ac
	pc = 0x825E39AC; continue 'dispatch;
	// 825E39A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E39AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E39B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E39B4: 409A0044  bne cr6, 0x825e39f8
	if !ctx.cr[6].eq {
	pc = 0x825E39F8; continue 'dispatch;
	}
	// 825E39B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E39BC: 419A001C  beq cr6, 0x825e39d8
	if ctx.cr[6].eq {
	pc = 0x825E39D8; continue 'dispatch;
	}
	// 825E39C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E39C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E39C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E39CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E39D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E39D4: 4E800421  bctrl
	ctx.lr = 0x825E39D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E39D8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E39DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E39E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E39E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E39E8: 816BDA24  lwz r11, -0x25dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9692 as u32) ) } as u64;
	// 825E39EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E39F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E39F4: 4BCDC60D  bl 0x822c0000
	ctx.lr = 0x825E39F8;
	sub_822C0000(ctx, base);
	// 825E39F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E39FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3A08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3A18 size=172
    let mut pc: u32 = 0x825E3A18;
    'dispatch: loop {
        match pc {
            0x825E3A18 => {
    //   block [0x825E3A18..0x825E3AC4)
	// 825E3A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E3A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3A2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E3A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3A34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E3A38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E3A3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3A40: 4BCDCEF9  bl 0x822c0938
	ctx.lr = 0x825E3A44;
	sub_822C0938(ctx, base);
	// 825E3A44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3A48: 41820028  beq 0x825e3a70
	if ctx.cr[0].eq {
	pc = 0x825E3A70; continue 'dispatch;
	}
	// 825E3A4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3A50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E3A54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E3A58: 392BF6B0  addi r9, r11, -0x950
	ctx.r[9].s64 = ctx.r[11].s64 + -2384;
	// 825E3A5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E3A60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E3A64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E3A68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E3A6C: 48000008  b 0x825e3a74
	pc = 0x825E3A74; continue 'dispatch;
	// 825E3A70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3A74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E3A7C: 409A002C  bne cr6, 0x825e3aa8
	if !ctx.cr[6].eq {
	pc = 0x825E3AA8; continue 'dispatch;
	}
	// 825E3A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E3A84: 4BCDC7E5  bl 0x822c0268
	ctx.lr = 0x825E3A88;
	sub_822C0268(ctx, base);
	// 825E3A88: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E3A8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E3A90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E3A94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E3A98: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E3A9C: 816BDA24  lwz r11, -0x25dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9692 as u32) ) } as u64;
	// 825E3AA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E3AA4: 4BCDC55D  bl 0x822c0000
	ctx.lr = 0x825E3AA8;
	sub_822C0000(ctx, base);
	// 825E3AA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3AAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3AB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3AC8 size=196
    let mut pc: u32 = 0x825E3AC8;
    'dispatch: loop {
        match pc {
            0x825E3AC8 => {
    //   block [0x825E3AC8..0x825E3B8C)
	// 825E3AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E3AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3AD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3ADC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E3AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3AE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E3AE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E3AEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3AF0: 4BCDCE49  bl 0x822c0938
	ctx.lr = 0x825E3AF4;
	sub_822C0938(ctx, base);
	// 825E3AF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3AF8: 41820028  beq 0x825e3b20
	if ctx.cr[0].eq {
	pc = 0x825E3B20; continue 'dispatch;
	}
	// 825E3AFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3B00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E3B04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E3B08: 392BF6C4  addi r9, r11, -0x93c
	ctx.r[9].s64 = ctx.r[11].s64 + -2364;
	// 825E3B0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E3B10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E3B14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E3B18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E3B1C: 48000008  b 0x825e3b24
	pc = 0x825E3B24; continue 'dispatch;
	// 825E3B20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3B24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E3B2C: 409A0044  bne cr6, 0x825e3b70
	if !ctx.cr[6].eq {
	pc = 0x825E3B70; continue 'dispatch;
	}
	// 825E3B30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E3B34: 419A001C  beq cr6, 0x825e3b50
	if ctx.cr[6].eq {
	pc = 0x825E3B50; continue 'dispatch;
	}
	// 825E3B38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E3B3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E3B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E3B44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E3B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E3B4C: 4E800421  bctrl
	ctx.lr = 0x825E3B50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E3B50: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E3B54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E3B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E3B5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E3B60: 816BDA24  lwz r11, -0x25dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9692 as u32) ) } as u64;
	// 825E3B64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E3B68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E3B6C: 4BCDC495  bl 0x822c0000
	ctx.lr = 0x825E3B70;
	sub_822C0000(ctx, base);
	// 825E3B70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3B74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3B80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3B90 size=172
    let mut pc: u32 = 0x825E3B90;
    'dispatch: loop {
        match pc {
            0x825E3B90 => {
    //   block [0x825E3B90..0x825E3C3C)
	// 825E3B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E3B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3BA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E3BA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3BAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E3BB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E3BB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3BB8: 4BCDCD81  bl 0x822c0938
	ctx.lr = 0x825E3BBC;
	sub_822C0938(ctx, base);
	// 825E3BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3BC0: 41820028  beq 0x825e3be8
	if ctx.cr[0].eq {
	pc = 0x825E3BE8; continue 'dispatch;
	}
	// 825E3BC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3BC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E3BCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E3BD0: 392BF6D8  addi r9, r11, -0x928
	ctx.r[9].s64 = ctx.r[11].s64 + -2344;
	// 825E3BD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E3BD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E3BDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E3BE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E3BE4: 48000008  b 0x825e3bec
	pc = 0x825E3BEC; continue 'dispatch;
	// 825E3BE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3BEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E3BF4: 409A002C  bne cr6, 0x825e3c20
	if !ctx.cr[6].eq {
	pc = 0x825E3C20; continue 'dispatch;
	}
	// 825E3BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E3BFC: 4BCDC66D  bl 0x822c0268
	ctx.lr = 0x825E3C00;
	sub_822C0268(ctx, base);
	// 825E3C00: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E3C04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E3C08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E3C0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E3C10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E3C14: 816BDA24  lwz r11, -0x25dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9692 as u32) ) } as u64;
	// 825E3C18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E3C1C: 4BCDC3E5  bl 0x822c0000
	ctx.lr = 0x825E3C20;
	sub_822C0000(ctx, base);
	// 825E3C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3C24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3C28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3C2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3C30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3C34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E3C40 size=164
    let mut pc: u32 = 0x825E3C40;
    'dispatch: loop {
        match pc {
            0x825E3C40 => {
    //   block [0x825E3C40..0x825E3CE4)
	// 825E3C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3C48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3C4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3C50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3C54: 4BF2E60D  bl 0x82512260
	ctx.lr = 0x825E3C58;
	sub_82512260(ctx, base);
	// 825E3C58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3C5C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E3C60: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825E3C64: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E3C68: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E3C6C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E3C70: 394AF74C  addi r10, r10, -0x8b4
	ctx.r[10].s64 = ctx.r[10].s64 + -2228;
	// 825E3C74: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825E3C78: 3929F738  addi r9, r9, -0x8c8
	ctx.r[9].s64 = ctx.r[9].s64 + -2248;
	// 825E3C7C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E3C80: 3908F6EC  addi r8, r8, -0x914
	ctx.r[8].s64 = ctx.r[8].s64 + -2324;
	// 825E3C84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3C88: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E3C8C: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825E3C90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E3C94: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825E3C98: C00708A4  lfs f0, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E3C9C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825E3CA0: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 825E3CA4: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 825E3CA8: 997F00F1  stb r11, 0xf1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(241 as u32), ctx.r[11].u8 ) };
	// 825E3CAC: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 825E3CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E3CB4: 995F0104  stb r10, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 825E3CB8: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825E3CBC: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 825E3CC0: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 825E3CC4: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 825E3CC8: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 825E3CCC: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825E3CD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E3CD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3CD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E3CE8 size=8
    let mut pc: u32 = 0x825E3CE8;
    'dispatch: loop {
        match pc {
            0x825E3CE8 => {
    //   block [0x825E3CE8..0x825E3CF0)
	// 825E3CE8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E3CEC: 4800041C  b 0x825e4108
	sub_825E4108(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E3CF0 size=8
    let mut pc: u32 = 0x825E3CF0;
    'dispatch: loop {
        match pc {
            0x825E3CF0 => {
    //   block [0x825E3CF0..0x825E3CF8)
	// 825E3CF0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825E3CF4: 48000414  b 0x825e4108
	sub_825E4108(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E3CF8 size=164
    let mut pc: u32 = 0x825E3CF8;
    'dispatch: loop {
        match pc {
            0x825E3CF8 => {
    //   block [0x825E3CF8..0x825E3D9C)
	// 825E3CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3D04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3D0C: 4BF2E625  bl 0x82512330
	ctx.lr = 0x825E3D10;
	sub_82512330(ctx, base);
	// 825E3D10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3D14: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E3D18: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825E3D1C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E3D20: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E3D24: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E3D28: 394AF74C  addi r10, r10, -0x8b4
	ctx.r[10].s64 = ctx.r[10].s64 + -2228;
	// 825E3D2C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825E3D30: 3929F738  addi r9, r9, -0x8c8
	ctx.r[9].s64 = ctx.r[9].s64 + -2248;
	// 825E3D34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E3D38: 3908F6EC  addi r8, r8, -0x914
	ctx.r[8].s64 = ctx.r[8].s64 + -2324;
	// 825E3D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E3D40: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E3D44: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825E3D48: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E3D4C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825E3D50: C00708A4  lfs f0, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E3D54: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825E3D58: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 825E3D5C: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 825E3D60: 997F00F1  stb r11, 0xf1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(241 as u32), ctx.r[11].u8 ) };
	// 825E3D64: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 825E3D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E3D6C: 995F0104  stb r10, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 825E3D70: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825E3D74: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 825E3D78: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 825E3D7C: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 825E3D80: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 825E3D84: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825E3D88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E3D8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3D90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3D94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3DA0 size=168
    let mut pc: u32 = 0x825E3DA0;
    'dispatch: loop {
        match pc {
            0x825E3DA0 => {
    //   block [0x825E3DA0..0x825E3E48)
	// 825E3DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E3DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3DB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3DB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3DBC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E3DC0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E3DC4: 396BF74C  addi r11, r11, -0x8b4
	ctx.r[11].s64 = ctx.r[11].s64 + -2228;
	// 825E3DC8: 394AF738  addi r10, r10, -0x8c8
	ctx.r[10].s64 = ctx.r[10].s64 + -2248;
	// 825E3DCC: 3929F6EC  addi r9, r9, -0x914
	ctx.r[9].s64 = ctx.r[9].s64 + -2324;
	// 825E3DD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3DD4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E3DD8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825E3DDC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825E3DE0: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 825E3DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3DE8: 419A0008  beq cr6, 0x825e3df0
	if ctx.cr[6].eq {
	pc = 0x825E3DF0; continue 'dispatch;
	}
	// 825E3DEC: 4BCDCAA5  bl 0x822c0890
	ctx.lr = 0x825E3DF0;
	sub_822C0890(ctx, base);
	// 825E3DF0: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825E3DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3DF8: 419A0008  beq cr6, 0x825e3e00
	if ctx.cr[6].eq {
	pc = 0x825E3E00; continue 'dispatch;
	}
	// 825E3DFC: 4BCDCA95  bl 0x822c0890
	ctx.lr = 0x825E3E00;
	sub_822C0890(ctx, base);
	// 825E3E00: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 825E3E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3E08: 419A0008  beq cr6, 0x825e3e10
	if ctx.cr[6].eq {
	pc = 0x825E3E10; continue 'dispatch;
	}
	// 825E3E0C: 4BCDCA85  bl 0x822c0890
	ctx.lr = 0x825E3E10;
	sub_822C0890(ctx, base);
	// 825E3E10: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E3E14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3E18: 419A0008  beq cr6, 0x825e3e20
	if ctx.cr[6].eq {
	pc = 0x825E3E20; continue 'dispatch;
	}
	// 825E3E1C: 4BCDCA75  bl 0x822c0890
	ctx.lr = 0x825E3E20;
	sub_822C0890(ctx, base);
	// 825E3E20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3E24: 481C3835  bl 0x827a7658
	ctx.lr = 0x825E3E28;
	sub_827A7658(ctx, base);
	// 825E3E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E3E2C: 4BD6B525  bl 0x8234f350
	ctx.lr = 0x825E3E30;
	sub_8234F350(ctx, base);
	// 825E3E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3E48 size=112
    let mut pc: u32 = 0x825E3E48;
    'dispatch: loop {
        match pc {
            0x825E3E48 => {
    //   block [0x825E3E48..0x825E3EB8)
	// 825E3E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E3E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3E5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E3E60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3E64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825E3E68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3E6C: 4BFFFBAD  bl 0x825e3a18
	ctx.lr = 0x825E3E70;
	sub_825E3A18(ctx, base);
	// 825E3E70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E3E74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E3E78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3E7C: 4BCDC185  bl 0x822c0000
	ctx.lr = 0x825E3E80;
	sub_822C0000(ctx, base);
	// 825E3E80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E3E84: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E3E88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3E8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E3E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3E94: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E3E98: 419A0008  beq cr6, 0x825e3ea0
	if ctx.cr[6].eq {
	pc = 0x825E3EA0; continue 'dispatch;
	}
	// 825E3E9C: 4BCDC9F5  bl 0x822c0890
	ctx.lr = 0x825E3EA0;
	sub_822C0890(ctx, base);
	// 825E3EA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3EA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3EA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3EAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3EB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3EB8 size=120
    let mut pc: u32 = 0x825E3EB8;
    'dispatch: loop {
        match pc {
            0x825E3EB8 => {
    //   block [0x825E3EB8..0x825E3F30)
	// 825E3EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3EBC: 48BC42B1  bl 0x831a816c
	ctx.lr = 0x825E3EC0;
	sub_831A8130(ctx, base);
	// 825E3EC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3EC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E3EC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E3ECC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E3ED0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E3ED4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825E3ED8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825E3EDC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825E3EE0: 4880E509  bl 0x82df23e8
	ctx.lr = 0x825E3EE4;
	sub_82DF23E8(ctx, base);
	// 825E3EE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3EE8: 41820014  beq 0x825e3efc
	if ctx.cr[0].eq {
	pc = 0x825E3EFC; continue 'dispatch;
	}
	// 825E3EEC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E3EF0: 48571A81  bl 0x82b55970
	ctx.lr = 0x825E3EF4;
	sub_82B55970(ctx, base);
	// 825E3EF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3EF8: 48000008  b 0x825e3f00
	pc = 0x825E3F00; continue 'dispatch;
	// 825E3EFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E3F00: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E3F04: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825E3F08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3F0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3F10: 4BFFFBB9  bl 0x825e3ac8
	ctx.lr = 0x825E3F14;
	sub_825E3AC8(ctx, base);
	// 825E3F14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3F18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3F20: 4BCDC0E1  bl 0x822c0000
	ctx.lr = 0x825E3F24;
	sub_822C0000(ctx, base);
	// 825E3F24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E3F28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3F2C: 48BC4290  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3F30 size=112
    let mut pc: u32 = 0x825E3F30;
    'dispatch: loop {
        match pc {
            0x825E3F30 => {
    //   block [0x825E3F30..0x825E3FA0)
	// 825E3F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E3F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E3F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E3F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E3F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3F4C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825E3F50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3F54: 4BFFFC3D  bl 0x825e3b90
	ctx.lr = 0x825E3F58;
	sub_825E3B90(ctx, base);
	// 825E3F58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E3F5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E3F60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E3F64: 4BCDC09D  bl 0x822c0000
	ctx.lr = 0x825E3F68;
	sub_822C0000(ctx, base);
	// 825E3F68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E3F6C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E3F70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E3F74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E3F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E3F7C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E3F80: 419A0008  beq cr6, 0x825e3f88
	if ctx.cr[6].eq {
	pc = 0x825E3F88; continue 'dispatch;
	}
	// 825E3F84: 4BCDC90D  bl 0x822c0890
	ctx.lr = 0x825E3F88;
	sub_822C0890(ctx, base);
	// 825E3F88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E3F8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E3F90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E3F94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E3F98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E3F9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E3FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E3FA0 size=112
    let mut pc: u32 = 0x825E3FA0;
    'dispatch: loop {
        match pc {
            0x825E3FA0 => {
    //   block [0x825E3FA0..0x825E4010)
	// 825E3FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E3FA4: 48BC41C9  bl 0x831a816c
	ctx.lr = 0x825E3FA8;
	sub_831A8130(ctx, base);
	// 825E3FA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E3FAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E3FB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E3FB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E3FB8: 388BF788  addi r4, r11, -0x878
	ctx.r[4].s64 = ctx.r[11].s64 + -2168;
	// 825E3FBC: 38A0004A  li r5, 0x4a
	ctx.r[5].s64 = 74;
	// 825E3FC0: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 825E3FC4: 4880E425  bl 0x82df23e8
	ctx.lr = 0x825E3FC8;
	sub_82DF23E8(ctx, base);
	// 825E3FC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E3FCC: 41820010  beq 0x825e3fdc
	if ctx.cr[0].eq {
	pc = 0x825E3FDC; continue 'dispatch;
	}
	// 825E3FD0: 4BFFFD29  bl 0x825e3cf8
	ctx.lr = 0x825E3FD4;
	sub_825E3CF8(ctx, base);
	// 825E3FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E3FD8: 48000008  b 0x825e3fe0
	pc = 0x825E3FE0; continue 'dispatch;
	// 825E3FDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E3FE0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E3FE4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825E3FE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E3FF0: 4BFFF961  bl 0x825e3950
	ctx.lr = 0x825E3FF4;
	sub_825E3950(ctx, base);
	// 825E3FF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E3FF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E3FFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4000: 4BCDC001  bl 0x822c0000
	ctx.lr = 0x825E4004;
	sub_822C0000(ctx, base);
	// 825E4004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E4008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E400C: 48BC41B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E4010 size=248
    let mut pc: u32 = 0x825E4010;
    'dispatch: loop {
        match pc {
            0x825E4010 => {
    //   block [0x825E4010..0x825E4108)
	// 825E4010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E4014: 48BC4151  bl 0x831a8164
	ctx.lr = 0x825E4018;
	sub_831A8130(ctx, base);
	// 825E4018: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E401C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4020: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E4024: 3BCBF788  addi r30, r11, -0x878
	ctx.r[30].s64 = ctx.r[11].s64 + -2168;
	// 825E4028: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E402C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825E4030: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825E4034: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4038: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 825E403C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E4040: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 825E4044: 4880E3A5  bl 0x82df23e8
	ctx.lr = 0x825E4048;
	sub_82DF23E8(ctx, base);
	// 825E4048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E404C: 41820018  beq 0x825e4064
	if ctx.cr[0].eq {
	pc = 0x825E4064; continue 'dispatch;
	}
	// 825E4050: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E4054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4058: 4BFFFBE9  bl 0x825e3c40
	ctx.lr = 0x825E405C;
	sub_825E3C40(ctx, base);
	// 825E405C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4060: 48000008  b 0x825e4068
	pc = 0x825E4068; continue 'dispatch;
	// 825E4064: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E4068: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E406C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E4074: 4BFFF8DD  bl 0x825e3950
	ctx.lr = 0x825E4078;
	sub_825E3950(ctx, base);
	// 825E4078: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E407C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4080: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E4084: 4BCDBF7D  bl 0x822c0000
	ctx.lr = 0x825E4088;
	sub_822C0000(ctx, base);
	// 825E4088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E408C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4090: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 825E4094: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825E4098: 4BCDC341  bl 0x822c03d8
	ctx.lr = 0x825E409C;
	sub_822C03D8(ctx, base);
	// 825E409C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E40A0: 41820014  beq 0x825e40b4
	if ctx.cr[0].eq {
	pc = 0x825E40B4; continue 'dispatch;
	}
	// 825E40A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825E40A8: 481B44C9  bl 0x82798570
	ctx.lr = 0x825E40AC;
	sub_82798570(ctx, base);
	// 825E40AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E40B0: 48000008  b 0x825e40b8
	pc = 0x825E40B8; continue 'dispatch;
	// 825E40B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E40B8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E40BC: 387F0118  addi r3, r31, 0x118
	ctx.r[3].s64 = ctx.r[31].s64 + 280;
	// 825E40C0: 4BFFFD89  bl 0x825e3e48
	ctx.lr = 0x825E40C4;
	sub_825E3E48(ctx, base);
	// 825E40C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E40C8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E40CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E40D0: 907C0004  stw r3, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825E40D4: 419A0028  beq cr6, 0x825e40fc
	if ctx.cr[6].eq {
	pc = 0x825E40FC; continue 'dispatch;
	}
	// 825E40D8: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825E40DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E40E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E40E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E40E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E40EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E40F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E40F4: 4082FFE8  bne 0x825e40dc
	if !ctx.cr[0].eq {
	pc = 0x825E40DC; continue 'dispatch;
	}
	// 825E40F8: 4BCDC799  bl 0x822c0890
	ctx.lr = 0x825E40FC;
	sub_822C0890(ctx, base);
	// 825E40FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E4100: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825E4104: 48BC40B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E4108 size=76
    let mut pc: u32 = 0x825E4108;
    'dispatch: loop {
        match pc {
            0x825E4108 => {
    //   block [0x825E4108..0x825E4154)
	// 825E4108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E410C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E4110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E4114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E4118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E411C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4120: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E4124: 4BFFFC7D  bl 0x825e3da0
	ctx.lr = 0x825E4128;
	sub_825E3DA0(ctx, base);
	// 825E4128: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E412C: 4182000C  beq 0x825e4138
	if ctx.cr[0].eq {
	pc = 0x825E4138; continue 'dispatch;
	}
	// 825E4130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4134: 4880E2A5  bl 0x82df23d8
	ctx.lr = 0x825E4138;
	sub_82DF23D8(ctx, base);
	// 825E4138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E413C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E4140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E4144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E4148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E414C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E4150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E4158 size=364
    let mut pc: u32 = 0x825E4158;
    'dispatch: loop {
        match pc {
            0x825E4158 => {
    //   block [0x825E4158..0x825E42C4)
	// 825E4158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E415C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E4160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E4164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E4168: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E416C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4174: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E4178: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E417C: 388BF824  addi r4, r11, -0x7dc
	ctx.r[4].s64 = ctx.r[11].s64 + -2012;
	// 825E4180: 4880F889  bl 0x82df3a08
	ctx.lr = 0x825E4184;
	sub_82DF3A08(ctx, base);
	// 825E4184: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E418C: 388BF81C  addi r4, r11, -0x7e4
	ctx.r[4].s64 = ctx.r[11].s64 + -2020;
	// 825E4190: 4880F879  bl 0x82df3a08
	ctx.lr = 0x825E4194;
	sub_82DF3A08(ctx, base);
	// 825E4194: 38BF000D  addi r5, r31, 0xd
	ctx.r[5].s64 = ctx.r[31].s64 + 13;
	// 825E4198: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E419C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E41A0: 4BFBEEB1  bl 0x825a3050
	ctx.lr = 0x825E41A4;
	sub_825A3050(ctx, base);
	// 825E41A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E41A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E41AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E41B0: 4BFBDFD9  bl 0x825a2188
	ctx.lr = 0x825E41B4;
	sub_825A2188(ctx, base);
	// 825E41B4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E41B8: 4880F271  bl 0x82df3428
	ctx.lr = 0x825E41BC;
	sub_82DF3428(ctx, base);
	// 825E41BC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E41C0: 4BCE4AF9  bl 0x822c8cb8
	ctx.lr = 0x825E41C4;
	sub_822C8CB8(ctx, base);
	// 825E41C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E41C8: 4880F261  bl 0x82df3428
	ctx.lr = 0x825E41CC;
	sub_82DF3428(ctx, base);
	// 825E41CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E41D0: 4880F259  bl 0x82df3428
	ctx.lr = 0x825E41D4;
	sub_82DF3428(ctx, base);
	// 825E41D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E41D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E41DC: 388BF80C  addi r4, r11, -0x7f4
	ctx.r[4].s64 = ctx.r[11].s64 + -2036;
	// 825E41E0: 4880F829  bl 0x82df3a08
	ctx.lr = 0x825E41E4;
	sub_82DF3A08(ctx, base);
	// 825E41E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E41E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E41EC: 388BF800  addi r4, r11, -0x800
	ctx.r[4].s64 = ctx.r[11].s64 + -2048;
	// 825E41F0: 4880F819  bl 0x82df3a08
	ctx.lr = 0x825E41F4;
	sub_82DF3A08(ctx, base);
	// 825E41F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E41F8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E41FC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E4200: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 825E4204: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E4208: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E420C: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E4210: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E4214: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E4218: 4BFBF091  bl 0x825a32a8
	ctx.lr = 0x825E421C;
	sub_825A32A8(ctx, base);
	// 825E421C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E4220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4224: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E4228: 4BFBD549  bl 0x825a1770
	ctx.lr = 0x825E422C;
	sub_825A1770(ctx, base);
	// 825E422C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825E4230: 4880F1F9  bl 0x82df3428
	ctx.lr = 0x825E4234;
	sub_82DF3428(ctx, base);
	// 825E4234: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825E4238: 4BCE4A81  bl 0x822c8cb8
	ctx.lr = 0x825E423C;
	sub_822C8CB8(ctx, base);
	// 825E423C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E4240: 4880F1E9  bl 0x82df3428
	ctx.lr = 0x825E4244;
	sub_82DF3428(ctx, base);
	// 825E4244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4248: 4880F1E1  bl 0x82df3428
	ctx.lr = 0x825E424C;
	sub_82DF3428(ctx, base);
	// 825E424C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4254: 388BF7E4  addi r4, r11, -0x81c
	ctx.r[4].s64 = ctx.r[11].s64 + -2076;
	// 825E4258: 4880F7B1  bl 0x82df3a08
	ctx.lr = 0x825E425C;
	sub_82DF3A08(ctx, base);
	// 825E425C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E4264: 388BF7CC  addi r4, r11, -0x834
	ctx.r[4].s64 = ctx.r[11].s64 + -2100;
	// 825E4268: 4880F7A1  bl 0x82df3a08
	ctx.lr = 0x825E426C;
	sub_82DF3A08(ctx, base);
	// 825E426C: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825E4270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E4274: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E4278: 4BFBEDD9  bl 0x825a3050
	ctx.lr = 0x825E427C;
	sub_825A3050(ctx, base);
	// 825E427C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E4280: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E4284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4288: 4BFBDF01  bl 0x825a2188
	ctx.lr = 0x825E428C;
	sub_825A2188(ctx, base);
	// 825E428C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E4290: 4880F199  bl 0x82df3428
	ctx.lr = 0x825E4294;
	sub_82DF3428(ctx, base);
	// 825E4294: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825E4298: 4BCE4A21  bl 0x822c8cb8
	ctx.lr = 0x825E429C;
	sub_822C8CB8(ctx, base);
	// 825E429C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E42A0: 4880F189  bl 0x82df3428
	ctx.lr = 0x825E42A4;
	sub_82DF3428(ctx, base);
	// 825E42A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E42A8: 4880F181  bl 0x82df3428
	ctx.lr = 0x825E42AC;
	sub_82DF3428(ctx, base);
	// 825E42AC: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825E42B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E42B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E42B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E42BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E42C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E42C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E42C8 size=1176
    let mut pc: u32 = 0x825E42C8;
    'dispatch: loop {
        match pc {
            0x825E42C8 => {
    //   block [0x825E42C8..0x825E4760)
	// 825E42C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E42CC: 48BC3E95  bl 0x831a8160
	ctx.lr = 0x825E42D0;
	sub_831A8130(ctx, base);
	// 825E42D0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825E42D4: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E42D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E42DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E42E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E42E4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825E42E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E42EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E42F0: 4BFFFBC9  bl 0x825e3eb8
	ctx.lr = 0x825E42F4;
	sub_825E3EB8(ctx, base);
	// 825E42F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E42F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E42FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E4300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E4304: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825E4308: 419A0024  beq cr6, 0x825e432c
	if ctx.cr[6].eq {
	pc = 0x825E432C; continue 'dispatch;
	}
	// 825E430C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E4310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E4314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4318: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E431C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E4320: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E4324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4328: 4082FFE8  bne 0x825e4310
	if !ctx.cr[0].eq {
	pc = 0x825E4310; continue 'dispatch;
	}
	// 825E432C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4330: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E4334: 3B8BF788  addi r28, r11, -0x878
	ctx.r[28].s64 = ctx.r[11].s64 + -2168;
	// 825E4338: 3BBE0028  addi r29, r30, 0x28
	ctx.r[29].s64 = ctx.r[30].s64 + 40;
	// 825E433C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825E4340: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E4344: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E4348: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825E434C: 38A0014D  li r5, 0x14d
	ctx.r[5].s64 = 333;
	// 825E4350: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E4354: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E4358: 488746E9  bl 0x82e58a40
	ctx.lr = 0x825E435C;
	sub_82E58A40(ctx, base);
	// 825E435C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E4360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4364: 419A0008  beq cr6, 0x825e436c
	if ctx.cr[6].eq {
	pc = 0x825E436C; continue 'dispatch;
	}
	// 825E4368: 4BCDC529  bl 0x822c0890
	ctx.lr = 0x825E436C;
	sub_822C0890(ctx, base);
	// 825E436C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E4370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4374: 419A0008  beq cr6, 0x825e437c
	if ctx.cr[6].eq {
	pc = 0x825E437C; continue 'dispatch;
	}
	// 825E4378: 4BCDC519  bl 0x822c0890
	ctx.lr = 0x825E437C;
	sub_822C0890(ctx, base);
	// 825E437C: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 825E4380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4384: 4BF2B6CD  bl 0x8250fa50
	ctx.lr = 0x825E4388;
	sub_8250FA50(ctx, base);
	// 825E4388: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825E438C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E4390: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E4394: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825E4398: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 825E439C: 38AB9BC9  addi r5, r11, -0x6437
	ctx.r[5].s64 = ctx.r[11].s64 + -25655;
	// 825E43A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825E43A4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E43A8: 48379DC1  bl 0x8295e168
	ctx.lr = 0x825E43AC;
	sub_8295E168(ctx, base);
	// 825E43AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E43B0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825E43B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E43B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E43BC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825E43C0: 419A0024  beq cr6, 0x825e43e4
	if ctx.cr[6].eq {
	pc = 0x825E43E4; continue 'dispatch;
	}
	// 825E43C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E43C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E43CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E43D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E43D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E43D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E43DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E43E0: 4082FFE8  bne 0x825e43c8
	if !ctx.cr[0].eq {
	pc = 0x825E43C8; continue 'dispatch;
	}
	// 825E43E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E43E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E43EC: 4BF2B0DD  bl 0x8250f4c8
	ctx.lr = 0x825E43F0;
	sub_8250F4C8(ctx, base);
	// 825E43F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E43F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E43F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E43FC: 409A0008  bne cr6, 0x825e4404
	if !ctx.cr[6].eq {
	pc = 0x825E4404; continue 'dispatch;
	}
	// 825E4400: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E4404: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 825E4408: 4BF24A59  bl 0x82508e60
	ctx.lr = 0x825E440C;
	sub_82508E60(ctx, base);
	// 825E440C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E4410: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E4414: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E4418: 38A00151  li r5, 0x151
	ctx.r[5].s64 = 337;
	// 825E441C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E4420: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825E4424: 4887461D  bl 0x82e58a40
	ctx.lr = 0x825E4428;
	sub_82E58A40(ctx, base);
	// 825E4428: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E442C: 4880D865  bl 0x82df1c90
	ctx.lr = 0x825E4430;
	sub_82DF1C90(ctx, base);
	// 825E4430: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E4434: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4438: 419A0008  beq cr6, 0x825e4440
	if ctx.cr[6].eq {
	pc = 0x825E4440; continue 'dispatch;
	}
	// 825E443C: 4BCDC455  bl 0x822c0890
	ctx.lr = 0x825E4440;
	sub_822C0890(ctx, base);
	// 825E4440: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825E4444: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4448: 419A0008  beq cr6, 0x825e4450
	if ctx.cr[6].eq {
	pc = 0x825E4450; continue 'dispatch;
	}
	// 825E444C: 4BCDC445  bl 0x822c0890
	ctx.lr = 0x825E4450;
	sub_822C0890(ctx, base);
	// 825E4450: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E4454: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825E4458: 4BF2AED9  bl 0x8250f330
	ctx.lr = 0x825E445C;
	sub_8250F330(ctx, base);
	// 825E445C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E4460: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E4464: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4468: 4BF06E59  bl 0x824eb2c0
	ctx.lr = 0x825E446C;
	sub_824EB2C0(ctx, base);
	// 825E446C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4470: 4BF32AB9  bl 0x82516f28
	ctx.lr = 0x825E4474;
	sub_82516F28(ctx, base);
	// 825E4474: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825E4478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E447C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E4480: 419A000C  beq cr6, 0x825e448c
	if ctx.cr[6].eq {
	pc = 0x825E448C; continue 'dispatch;
	}
	// 825E4484: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825E4488: 4BCDC409  bl 0x822c0890
	ctx.lr = 0x825E448C;
	sub_822C0890(ctx, base);
	// 825E448C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825E4490: 4880D801  bl 0x82df1c90
	ctx.lr = 0x825E4494;
	sub_82DF1C90(ctx, base);
	// 825E4494: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4498: 41820084  beq 0x825e451c
	if ctx.cr[0].eq {
	pc = 0x825E451C; continue 'dispatch;
	}
	// 825E449C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E44A0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825E44A4: 4BF2AE8D  bl 0x8250f330
	ctx.lr = 0x825E44A8;
	sub_8250F330(ctx, base);
	// 825E44A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E44AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E44B0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E44B4: 4BF06E0D  bl 0x824eb2c0
	ctx.lr = 0x825E44B8;
	sub_824EB2C0(ctx, base);
	// 825E44B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E44BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E44C0: 4BF32239  bl 0x825166f8
	ctx.lr = 0x825E44C4;
	sub_825166F8(ctx, base);
	// 825E44C4: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825E44C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E44CC: 419A0008  beq cr6, 0x825e44d4
	if ctx.cr[6].eq {
	pc = 0x825E44D4; continue 'dispatch;
	}
	// 825E44D0: 4BCDC3C1  bl 0x822c0890
	ctx.lr = 0x825E44D4;
	sub_822C0890(ctx, base);
	// 825E44D4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825E44D8: 4880D7B9  bl 0x82df1c90
	ctx.lr = 0x825E44DC;
	sub_82DF1C90(ctx, base);
	// 825E44DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E44E0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E44E4: 4BF2AE4D  bl 0x8250f330
	ctx.lr = 0x825E44E8;
	sub_8250F330(ctx, base);
	// 825E44E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E44EC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825E44F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E44F4: 4BF06DCD  bl 0x824eb2c0
	ctx.lr = 0x825E44F8;
	sub_824EB2C0(ctx, base);
	// 825E44F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E44FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4500: 4BF33BE9  bl 0x825180e8
	ctx.lr = 0x825E4504;
	sub_825180E8(ctx, base);
	// 825E4504: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825E4508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E450C: 419A0008  beq cr6, 0x825e4514
	if ctx.cr[6].eq {
	pc = 0x825E4514; continue 'dispatch;
	}
	// 825E4510: 4BCDC381  bl 0x822c0890
	ctx.lr = 0x825E4514;
	sub_822C0890(ctx, base);
	// 825E4514: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E4518: 4880D779  bl 0x82df1c90
	ctx.lr = 0x825E451C;
	sub_82DF1C90(ctx, base);
	// 825E451C: 897E00F1  lbz r11, 0xf1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(241 as u32) ) } as u64;
	// 825E4520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4524: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E4528: 41820054  beq 0x825e457c
	if ctx.cr[0].eq {
	pc = 0x825E457C; continue 'dispatch;
	}
	// 825E452C: 809E00FC  lwz r4, 0xfc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 825E4530: 4BF2E5D9  bl 0x82512b08
	ctx.lr = 0x825E4534;
	sub_82512B08(ctx, base);
	// 825E4534: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E4538: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E453C: 38BE00E8  addi r5, r30, 0xe8
	ctx.r[5].s64 = ctx.r[30].s64 + 232;
	// 825E4540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4544: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E4548: 4BF2BCA9  bl 0x825101f0
	ctx.lr = 0x825E454C;
	sub_825101F0(ctx, base);
	// 825E454C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4550: 4BF2D681  bl 0x82511bd0
	ctx.lr = 0x825E4554;
	sub_82511BD0(ctx, base);
	// 825E4554: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E4558: C1BE00F4  lfs f13, 0xf4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E455C: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E4560: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825E4564: 4198000C  blt cr6, 0x825e4570
	if ctx.cr[6].lt {
	pc = 0x825E4570; continue 'dispatch;
	}
	// 825E4568: 937E0100  stw r27, 0x100(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[27].u32 ) };
	// 825E456C: 48000014  b 0x825e4580
	pc = 0x825E4580; continue 'dispatch;
	// 825E4570: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E4574: 917E0100  stw r11, 0x100(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 825E4578: 48000008  b 0x825e4580
	pc = 0x825E4580; continue 'dispatch;
	// 825E457C: 4BF2C055  bl 0x825105d0
	ctx.lr = 0x825E4580;
	sub_825105D0(ctx, base);
	// 825E4580: 4BF0ECB9  bl 0x824f3238
	ctx.lr = 0x825E4584;
	sub_824F3238(ctx, base);
	// 825E4584: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4588: 418201CC  beq 0x825e4754
	if ctx.cr[0].eq {
	pc = 0x825E4754; continue 'dispatch;
	}
	// 825E458C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E4590: 4BD254B9  bl 0x82309a48
	ctx.lr = 0x825E4594;
	sub_82309A48(ctx, base);
	// 825E4594: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E4598: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E459C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825E45A0: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 825E45A4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 825E45A8: 419A0024  beq cr6, 0x825e45cc
	if ctx.cr[6].eq {
	pc = 0x825E45CC; continue 'dispatch;
	}
	// 825E45AC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 825E45B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E45B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E45B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E45BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E45C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E45C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E45C8: 4082FFE8  bne 0x825e45b0
	if !ctx.cr[0].eq {
	pc = 0x825E45B0; continue 'dispatch;
	}
	// 825E45CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E45D0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825E45D4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825E45D8: 38A0016D  li r5, 0x16d
	ctx.r[5].s64 = 365;
	// 825E45DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E45E0: 48872A09  bl 0x82e56fe8
	ctx.lr = 0x825E45E4;
	sub_82E56FE8(ctx, base);
	// 825E45E4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E45E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E45EC: 419A0008  beq cr6, 0x825e45f4
	if ctx.cr[6].eq {
	pc = 0x825E45F4; continue 'dispatch;
	}
	// 825E45F0: 4BCDC2A1  bl 0x822c0890
	ctx.lr = 0x825E45F4;
	sub_822C0890(ctx, base);
	// 825E45F4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825E45F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E45FC: 409A0148  bne cr6, 0x825e4744
	if !ctx.cr[6].eq {
	pc = 0x825E4744; continue 'dispatch;
	}
	// 825E4600: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E4604: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4608: 38A0016F  li r5, 0x16f
	ctx.r[5].s64 = 367;
	// 825E460C: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 825E4610: 4880DDD9  bl 0x82df23e8
	ctx.lr = 0x825E4614;
	sub_82DF23E8(ctx, base);
	// 825E4614: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E4618: 41820014  beq 0x825e462c
	if ctx.cr[0].eq {
	pc = 0x825E462C; continue 'dispatch;
	}
	// 825E461C: 3880002F  li r4, 0x2f
	ctx.r[4].s64 = 47;
	// 825E4620: 480A7AB1  bl 0x8268c0d0
	ctx.lr = 0x825E4624;
	sub_8268C0D0(ctx, base);
	// 825E4624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4628: 48000008  b 0x825e4630
	pc = 0x825E4630; continue 'dispatch;
	// 825E462C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E4630: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E4634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4638: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E463C: 4BD22FBD  bl 0x823075f8
	ctx.lr = 0x825E4640;
	sub_823075F8(ctx, base);
	// 825E4640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E4644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4648: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E464C: 4BCDB9B5  bl 0x822c0000
	ctx.lr = 0x825E4650;
	sub_822C0000(ctx, base);
	// 825E4650: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E4654: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E4658: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E465C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825E4660: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 825E4664: 419A0024  beq cr6, 0x825e4688
	if ctx.cr[6].eq {
	pc = 0x825E4688; continue 'dispatch;
	}
	// 825E4668: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E466C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E4670: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4674: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E4678: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E467C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E4680: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4684: 4082FFE8  bne 0x825e466c
	if !ctx.cr[0].eq {
	pc = 0x825E466C; continue 'dispatch;
	}
	// 825E4688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E468C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E4690: 4BF2AE39  bl 0x8250f4c8
	ctx.lr = 0x825E4694;
	sub_8250F4C8(ctx, base);
	// 825E4694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E469C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 825E46A0: 409A0008  bne cr6, 0x825e46a8
	if !ctx.cr[6].eq {
	pc = 0x825E46A8; continue 'dispatch;
	}
	// 825E46A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E46A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E46AC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825E46B0: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 825E46B4: 4BF2AE65  bl 0x8250f518
	ctx.lr = 0x825E46B8;
	sub_8250F518(ctx, base);
	// 825E46B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E46BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E46C0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825E46C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E46C8: 4BF28E41  bl 0x8250d508
	ctx.lr = 0x825E46CC;
	sub_8250D508(ctx, base);
	// 825E46CC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E46D0: 4880D5C1  bl 0x82df1c90
	ctx.lr = 0x825E46D4;
	sub_82DF1C90(ctx, base);
	// 825E46D4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825E46D8: 4880D5B9  bl 0x82df1c90
	ctx.lr = 0x825E46DC;
	sub_82DF1C90(ctx, base);
	// 825E46DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E46E0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825E46E4: 4BF2ADE5  bl 0x8250f4c8
	ctx.lr = 0x825E46E8;
	sub_8250F4C8(ctx, base);
	// 825E46E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E46EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E46F0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E46F4: 409A0008  bne cr6, 0x825e46fc
	if !ctx.cr[6].eq {
	pc = 0x825E46FC; continue 'dispatch;
	}
	// 825E46F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E46FC: 4BF23E1D  bl 0x82508518
	ctx.lr = 0x825E4700;
	sub_82508518(ctx, base);
	// 825E4700: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E4704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4708: C00BCF44  lfs f0, -0x30bc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E470C: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E4710: 4BF2D3D9  bl 0x82511ae8
	ctx.lr = 0x825E4714;
	sub_82511AE8(ctx, base);
	// 825E4714: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4718: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E471C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E4720: 480A7729  bl 0x8268be48
	ctx.lr = 0x825E4724;
	sub_8268BE48(ctx, base);
	// 825E4724: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825E4728: 4880D569  bl 0x82df1c90
	ctx.lr = 0x825E472C;
	sub_82DF1C90(ctx, base);
	// 825E472C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E4730: 480A75F9  bl 0x8268bd28
	ctx.lr = 0x825E4734;
	sub_8268BD28(ctx, base);
	// 825E4734: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4738: 419A000C  beq cr6, 0x825e4744
	if ctx.cr[6].eq {
	pc = 0x825E4744; continue 'dispatch;
	}
	// 825E473C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E4740: 4BCDC151  bl 0x822c0890
	ctx.lr = 0x825E4744;
	sub_822C0890(ctx, base);
	// 825E4744: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825E4748: 419A000C  beq cr6, 0x825e4754
	if ctx.cr[6].eq {
	pc = 0x825E4754; continue 'dispatch;
	}
	// 825E474C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E4750: 4BCDC141  bl 0x822c0890
	ctx.lr = 0x825E4754;
	sub_822C0890(ctx, base);
	// 825E4754: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825E4758: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825E475C: 48BC3A54  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E4760 size=440
    let mut pc: u32 = 0x825E4760;
    'dispatch: loop {
        match pc {
            0x825E4760 => {
    //   block [0x825E4760..0x825E4918)
	// 825E4760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E4764: 48BC3A05  bl 0x831a8168
	ctx.lr = 0x825E4768;
	sub_831A8130(ctx, base);
	// 825E4768: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E476C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4770: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E4774: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825E4778: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825E477C: 80AB6730  lwz r5, 0x6730(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26416 as u32) ) } as u64;
	// 825E4780: 4BF2D559  bl 0x82511cd8
	ctx.lr = 0x825E4784;
	sub_82511CD8(ctx, base);
	// 825E4784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4788: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825E478C: 4BF2E37D  bl 0x82512b08
	ctx.lr = 0x825E4790;
	sub_82512B08(ctx, base);
	// 825E4790: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4794: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825E4798: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825E479C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825E47A0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825E47A4: 488BBF8D  bl 0x82ea0730
	ctx.lr = 0x825E47A8;
	sub_82EA0730(ctx, base);
	// 825E47A8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825E47AC: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825E47B0: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825E47B4: C02A7BC8  lfs f1, 0x7bc8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E47B8: 48935A39  bl 0x82f1a1f0
	ctx.lr = 0x825E47BC;
	sub_82F1A1F0(ctx, base);
	// 825E47BC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825E47C0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825E47C4: 4182000C  beq 0x825e47d0
	if ctx.cr[0].eq {
	pc = 0x825E47D0; continue 'dispatch;
	}
	// 825E47C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E47CC: 4BD03A7D  bl 0x822e8248
	ctx.lr = 0x825E47D0;
	sub_822E8248(ctx, base);
	// 825E47D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E47D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E47D8: 388BD970  addi r4, r11, -0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + -9872;
	// 825E47DC: 48814D55  bl 0x82df9530
	ctx.lr = 0x825E47E0;
	sub_82DF9530(ctx, base);
	// 825E47E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E47E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E47E8: 4BF2D931  bl 0x82512118
	ctx.lr = 0x825E47EC;
	sub_82512118(ctx, base);
	// 825E47EC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E47F0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825E47F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E47F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E47FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4800: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 825E4804: 4BF2E8F5  bl 0x825130f8
	ctx.lr = 0x825E4808;
	sub_825130F8(ctx, base);
	// 825E4808: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E480C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4810: 419A0008  beq cr6, 0x825e4818
	if ctx.cr[6].eq {
	pc = 0x825E4818; continue 'dispatch;
	}
	// 825E4814: 4BD03A55  bl 0x822e8268
	ctx.lr = 0x825E4818;
	sub_822E8268(ctx, base);
	// 825E4818: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825E481C: 419A000C  beq cr6, 0x825e4828
	if ctx.cr[6].eq {
	pc = 0x825E4828; continue 'dispatch;
	}
	// 825E4820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4824: 4BD03A45  bl 0x822e8268
	ctx.lr = 0x825E4828;
	sub_822E8268(ctx, base);
	// 825E4828: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E482C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4830: 388BF788  addi r4, r11, -0x878
	ctx.r[4].s64 = ctx.r[11].s64 + -2168;
	// 825E4834: 38A001BB  li r5, 0x1bb
	ctx.r[5].s64 = 443;
	// 825E4838: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825E483C: 4BCDBB9D  bl 0x822c03d8
	ctx.lr = 0x825E4840;
	sub_822C03D8(ctx, base);
	// 825E4840: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E4844: 41820010  beq 0x825e4854
	if ctx.cr[0].eq {
	pc = 0x825E4854; continue 'dispatch;
	}
	// 825E4848: 481CE991  bl 0x827b31d8
	ctx.lr = 0x825E484C;
	sub_827B31D8(ctx, base);
	// 825E484C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4850: 48000008  b 0x825e4858
	pc = 0x825E4858; continue 'dispatch;
	// 825E4854: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E4858: 3BDF0108  addi r30, r31, 0x108
	ctx.r[30].s64 = ctx.r[31].s64 + 264;
	// 825E485C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4860: 4BFFF6D1  bl 0x825e3f30
	ctx.lr = 0x825E4864;
	sub_825E3F30(ctx, base);
	// 825E4864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4868: 839F0108  lwz r28, 0x108(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E486C: 4BF2D27D  bl 0x82511ae8
	ctx.lr = 0x825E4870;
	sub_82511AE8(ctx, base);
	// 825E4870: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4874: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E4878: 481CE9E1  bl 0x827b3258
	ctx.lr = 0x825E487C;
	sub_827B3258(ctx, base);
	// 825E487C: 389D0020  addi r4, r29, 0x20
	ctx.r[4].s64 = ctx.r[29].s64 + 32;
	// 825E4880: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E4884: 481CE9E5  bl 0x827b3268
	ctx.lr = 0x825E4888;
	sub_827B3268(ctx, base);
	// 825E4888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825E488C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4890: 997F0110  stb r11, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u8 ) };
	// 825E4894: 897D0040  lbz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 825E4898: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E489C: 41820060  beq 0x825e48fc
	if ctx.cr[0].eq {
	pc = 0x825E48FC; continue 'dispatch;
	}
	// 825E48A0: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E4918 size=124
    let mut pc: u32 = 0x825E4918;
    'dispatch: loop {
        match pc {
            0x825E4918 => {
    //   block [0x825E4918..0x825E4994)
	// 825E4918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E491C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E4920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E4924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E4928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E492C: 81630118  lwz r11, 0x118(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 825E4930: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E4934: 3BC30118  addi r30, r3, 0x118
	ctx.r[30].s64 = ctx.r[3].s64 + 280;
	// 825E4938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E493C: 409A0040  bne cr6, 0x825e497c
	if !ctx.cr[6].eq {
	pc = 0x825E497C; continue 'dispatch;
	}
	// 825E4940: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4944: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4948: 388BF788  addi r4, r11, -0x878
	ctx.r[4].s64 = ctx.r[11].s64 + -2168;
	// 825E494C: 38A001E2  li r5, 0x1e2
	ctx.r[5].s64 = 482;
	// 825E4950: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825E4954: 4BCDBA85  bl 0x822c03d8
	ctx.lr = 0x825E4958;
	sub_822C03D8(ctx, base);
	// 825E4958: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E495C: 41820014  beq 0x825e4970
	if ctx.cr[0].eq {
	pc = 0x825E4970; continue 'dispatch;
	}
	// 825E4960: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825E4964: 481B3C0D  bl 0x82798570
	ctx.lr = 0x825E4968;
	sub_82798570(ctx, base);
	// 825E4968: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E496C: 48000008  b 0x825e4974
	pc = 0x825E4974; continue 'dispatch;
	// 825E4970: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E4974: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4978: 4BFFF4D1  bl 0x825e3e48
	ctx.lr = 0x825E497C;
	sub_825E3E48(ctx, base);
	// 825E497C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E4980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E4984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E4988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E498C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E4990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E4998 size=312
    let mut pc: u32 = 0x825E4998;
    'dispatch: loop {
        match pc {
            0x825E4998 => {
    //   block [0x825E4998..0x825E4AD0)
	// 825E4998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E499C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E49A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E49A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E49A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E49AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E49B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E49B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E49B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E49BC: 4BF2AB0D  bl 0x8250f4c8
	ctx.lr = 0x825E49C0;
	sub_8250F4C8(ctx, base);
	// 825E49C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E49C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E49C8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825E49CC: 409A0008  bne cr6, 0x825e49d4
	if !ctx.cr[6].eq {
	pc = 0x825E49D4; continue 'dispatch;
	}
	// 825E49D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E49D4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E49D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E49DC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825E49E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E49E4: 485624BD  bl 0x82b46ea0
	ctx.lr = 0x825E49E8;
	sub_82B46EA0(ctx, base);
	// 825E49E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E49EC: 4880D2A5  bl 0x82df1c90
	ctx.lr = 0x825E49F0;
	sub_82DF1C90(ctx, base);
	// 825E49F0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E49F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E49F8: 419A0020  beq cr6, 0x825e4a18
	if ctx.cr[6].eq {
	pc = 0x825E4A18; continue 'dispatch;
	}
	// 825E49FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4A00: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E4A04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825E4A08: 388AF844  addi r4, r10, -0x7bc
	ctx.r[4].s64 = ctx.r[10].s64 + -1980;
	// 825E4A0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E4A10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E4A14: 4E800421  bctrl
	ctx.lr = 0x825E4A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E4A18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4A20: 388BF834  addi r4, r11, -0x7cc
	ctx.r[4].s64 = ctx.r[11].s64 + -1996;
	// 825E4A24: 4880EFE5  bl 0x82df3a08
	ctx.lr = 0x825E4A28;
	sub_82DF3A08(ctx, base);
	// 825E4A28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4A2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E4A30: 4BF2AA99  bl 0x8250f4c8
	ctx.lr = 0x825E4A34;
	sub_8250F4C8(ctx, base);
	// 825E4A34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E4A3C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825E4A40: 409A0008  bne cr6, 0x825e4a48
	if !ctx.cr[6].eq {
	pc = 0x825E4A48; continue 'dispatch;
	}
	// 825E4A44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E4A48: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E4A4C: 4BF25F05  bl 0x8250a950
	ctx.lr = 0x825E4A50;
	sub_8250A950(ctx, base);
	// 825E4A50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E4A58: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 825E4A5C: 409A0008  bne cr6, 0x825e4a64
	if !ctx.cr[6].eq {
	pc = 0x825E4A64; continue 'dispatch;
	}
	// 825E4A60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E4A64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E4A68: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E4A6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E4A70: 389F0120  addi r4, r31, 0x120
	ctx.r[4].s64 = ctx.r[31].s64 + 288;
	// 825E4A74: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E4A78: 481EF729  bl 0x827d41a0
	ctx.lr = 0x825E4A7C;
	sub_827D41A0(ctx, base);
	// 825E4A7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E4A80: 4880D211  bl 0x82df1c90
	ctx.lr = 0x825E4A84;
	sub_82DF1C90(ctx, base);
	// 825E4A84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E4A88: 4880D209  bl 0x82df1c90
	ctx.lr = 0x825E4A8C;
	sub_82DF1C90(ctx, base);
	// 825E4A8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4A90: 4880E999  bl 0x82df3428
	ctx.lr = 0x825E4A94;
	sub_82DF3428(ctx, base);
	// 825E4A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4A98: 48A23691  bl 0x83008128
	ctx.lr = 0x825E4A9C;
	sub_83008128(ctx, base);
	// 825E4A9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4AA4: 4BFFF825  bl 0x825e42c8
	ctx.lr = 0x825E4AA8;
	sub_825E42C8(ctx, base);
	// 825E4AA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E4AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4AB0: 419A0008  beq cr6, 0x825e4ab8
	if ctx.cr[6].eq {
	pc = 0x825E4AB8; continue 'dispatch;
	}
	// 825E4AB4: 4BCDBDDD  bl 0x822c0890
	ctx.lr = 0x825E4AB8;
	sub_822C0890(ctx, base);
	// 825E4AB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825E4ABC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E4AC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E4AC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E4AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E4ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E4AD0 size=444
    let mut pc: u32 = 0x825E4AD0;
    'dispatch: loop {
        match pc {
            0x825E4AD0 => {
    //   block [0x825E4AD0..0x825E4C8C)
	// 825E4AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E4AD4: 48BC3695  bl 0x831a8168
	ctx.lr = 0x825E4AD8;
	sub_831A8130(ctx, base);
	// 825E4AD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E4ADC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825E4AE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E4AE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E4AE8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825E4AEC: 41820038  beq 0x825e4b24
	if ctx.cr[0].eq {
	pc = 0x825E4B24; continue 'dispatch;
	}
	// 825E4AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4AF4: 48BC4E95  bl 0x831a9988
	ctx.lr = 0x825E4AF8;
	sub_831A9988(ctx, base);
	// 825E4AF8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825E4AFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4B00: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825E4B04: 48BC35F5  bl 0x831a80f8
	ctx.lr = 0x825E4B08;
	sub_831A80F8(ctx, base);
	// 825E4B08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4B0C: 41820018  beq 0x825e4b24
	if ctx.cr[0].eq {
	pc = 0x825E4B24; continue 'dispatch;
	}
	// 825E4B10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4B14: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4B18: 4BFFFE81  bl 0x825e4998
	ctx.lr = 0x825E4B1C;
	sub_825E4998(ctx, base);
	// 825E4B1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825E4B20: 48000164  b 0x825e4c84
	pc = 0x825E4C84; continue 'dispatch;
	// 825E4B24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4B28: 419A014C  beq cr6, 0x825e4c74
	if ctx.cr[6].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4B30: 48BC4E59  bl 0x831a9988
	ctx.lr = 0x825E4B34;
	sub_831A9988(ctx, base);
	// 825E4B34: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E4B38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4B3C: 386BDBCC  addi r3, r11, -0x2434
	ctx.r[3].s64 = ctx.r[11].s64 + -9268;
	// 825E4B40: 48BC35B9  bl 0x831a80f8
	ctx.lr = 0x825E4B44;
	sub_831A80F8(ctx, base);
	// 825E4B44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4B48: 41820014  beq 0x825e4b5c
	if ctx.cr[0].eq {
	pc = 0x825E4B5C; continue 'dispatch;
	}
	// 825E4B4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4B50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4B54: 480DD995  bl 0x826c24e8
	ctx.lr = 0x825E4B58;
	sub_826C24E8(ctx, base);
	// 825E4B58: 4BFFFFC4  b 0x825e4b1c
	pc = 0x825E4B1C; continue 'dispatch;
	// 825E4B5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4B60: 419A0114  beq cr6, 0x825e4c74
	if ctx.cr[6].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4B68: 48BC4E21  bl 0x831a9988
	ctx.lr = 0x825E4B6C;
	sub_831A9988(ctx, base);
	// 825E4B6C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E4B70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4B74: 386BDB94  addi r3, r11, -0x246c
	ctx.r[3].s64 = ctx.r[11].s64 + -9324;
	// 825E4B78: 48BC3581  bl 0x831a80f8
	ctx.lr = 0x825E4B7C;
	sub_831A80F8(ctx, base);
	// 825E4B7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4B80: 41820014  beq 0x825e4b94
	if ctx.cr[0].eq {
	pc = 0x825E4B94; continue 'dispatch;
	}
	// 825E4B84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4B88: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4B8C: 48036B6D  bl 0x8261b6f8
	ctx.lr = 0x825E4B90;
	sub_8261B6F8(ctx, base);
	// 825E4B90: 4BFFFF8C  b 0x825e4b1c
	pc = 0x825E4B1C; continue 'dispatch;
	// 825E4B94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4B98: 419A00DC  beq cr6, 0x825e4c74
	if ctx.cr[6].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4BA0: 48BC4DE9  bl 0x831a9988
	ctx.lr = 0x825E4BA4;
	sub_831A9988(ctx, base);
	// 825E4BA4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E4BA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4BAC: 386BDB68  addi r3, r11, -0x2498
	ctx.r[3].s64 = ctx.r[11].s64 + -9368;
	// 825E4BB0: 48BC3549  bl 0x831a80f8
	ctx.lr = 0x825E4BB4;
	sub_831A80F8(ctx, base);
	// 825E4BB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4BB8: 41820014  beq 0x825e4bcc
	if ctx.cr[0].eq {
	pc = 0x825E4BCC; continue 'dispatch;
	}
	// 825E4BBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4BC0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4BC4: 4BFFFB9D  bl 0x825e4760
	ctx.lr = 0x825E4BC8;
	sub_825E4760(ctx, base);
	// 825E4BC8: 4BFFFF54  b 0x825e4b1c
	pc = 0x825E4B1C; continue 'dispatch;
	// 825E4BCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4BD0: 419A00A4  beq cr6, 0x825e4c74
	if ctx.cr[6].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4BD8: 48BC4DB1  bl 0x831a9988
	ctx.lr = 0x825E4BDC;
	sub_831A9988(ctx, base);
	// 825E4BDC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825E4BE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4BE4: 386B6E8C  addi r3, r11, 0x6e8c
	ctx.r[3].s64 = ctx.r[11].s64 + 28300;
	// 825E4BE8: 48BC3511  bl 0x831a80f8
	ctx.lr = 0x825E4BEC;
	sub_831A80F8(ctx, base);
	// 825E4BEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4BF0: 41820014  beq 0x825e4c04
	if ctx.cr[0].eq {
	pc = 0x825E4C04; continue 'dispatch;
	}
	// 825E4BF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4BF8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4BFC: 4BFFFD1D  bl 0x825e4918
	ctx.lr = 0x825E4C00;
	sub_825E4918(ctx, base);
	// 825E4C00: 4BFFFF1C  b 0x825e4b1c
	pc = 0x825E4B1C; continue 'dispatch;
	// 825E4C04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4C08: 419A006C  beq cr6, 0x825e4c74
	if ctx.cr[6].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4C10: 48BC4D79  bl 0x831a9988
	ctx.lr = 0x825E4C14;
	sub_831A9988(ctx, base);
	// 825E4C14: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825E4C18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4C1C: 386B6E5C  addi r3, r11, 0x6e5c
	ctx.r[3].s64 = ctx.r[11].s64 + 28252;
	// 825E4C20: 48BC34D9  bl 0x831a80f8
	ctx.lr = 0x825E4C24;
	sub_831A80F8(ctx, base);
	// 825E4C24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4C28: 41820014  beq 0x825e4c3c
	if ctx.cr[0].eq {
	pc = 0x825E4C3C; continue 'dispatch;
	}
	// 825E4C2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4C30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4C34: 4BFFED05  bl 0x825e3938
	ctx.lr = 0x825E4C38;
	sub_825E3938(ctx, base);
	// 825E4C38: 4BFFFEE4  b 0x825e4b1c
	pc = 0x825E4B1C; continue 'dispatch;
	// 825E4C3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4C40: 419A0034  beq cr6, 0x825e4c74
	if ctx.cr[6].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4C48: 48BC4D41  bl 0x831a9988
	ctx.lr = 0x825E4C4C;
	sub_831A9988(ctx, base);
	// 825E4C4C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E4C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4C54: 386BD788  addi r3, r11, -0x2878
	ctx.r[3].s64 = ctx.r[11].s64 + -10360;
	// 825E4C58: 48BC34A1  bl 0x831a80f8
	ctx.lr = 0x825E4C5C;
	sub_831A80F8(ctx, base);
	// 825E4C5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4C60: 41820014  beq 0x825e4c74
	if ctx.cr[0].eq {
	pc = 0x825E4C74; continue 'dispatch;
	}
	// 825E4C64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4C68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E4C6C: 48527B35  bl 0x82b0c7a0
	ctx.lr = 0x825E4C70;
	sub_82B0C7A0(ctx, base);
	// 825E4C70: 4BFFFEAC  b 0x825e4b1c
	pc = 0x825E4B1C; continue 'dispatch;
	// 825E4C74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E4C78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4C80: 4BF2D999  bl 0x82512618
	ctx.lr = 0x825E4C84;
	sub_82512618(ctx, base);
	// 825E4C84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E4C88: 48BC3530  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E4C90 size=424
    let mut pc: u32 = 0x825E4C90;
    'dispatch: loop {
        match pc {
            0x825E4C90 => {
    //   block [0x825E4C90..0x825E4E38)
	// 825E4C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E4C94: 48BC34D1  bl 0x831a8164
	ctx.lr = 0x825E4C98;
	sub_831A8130(ctx, base);
	// 825E4C98: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E4C9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4CA0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E4CA4: 3BCBF788  addi r30, r11, -0x878
	ctx.r[30].s64 = ctx.r[11].s64 + -2168;
	// 825E4CA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825E4CAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4CB0: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 825E4CB4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825E4CB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E4CBC: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 825E4CC0: 4880D729  bl 0x82df23e8
	ctx.lr = 0x825E4CC4;
	sub_82DF23E8(ctx, base);
	// 825E4CC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E4CC8: 41820010  beq 0x825e4cd8
	if ctx.cr[0].eq {
	pc = 0x825E4CD8; continue 'dispatch;
	}
	// 825E4CCC: 4BFFF02D  bl 0x825e3cf8
	ctx.lr = 0x825E4CD0;
	sub_825E3CF8(ctx, base);
	// 825E4CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4CD4: 48000008  b 0x825e4cdc
	pc = 0x825E4CDC; continue 'dispatch;
	// 825E4CD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E4CDC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E4CE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4CE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E4CE8: 4BFFEC69  bl 0x825e3950
	ctx.lr = 0x825E4CEC;
	sub_825E3950(ctx, base);
	// 825E4CEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E4CF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4CF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E4CF8: 4BCDB309  bl 0x822c0000
	ctx.lr = 0x825E4CFC;
	sub_822C0000(ctx, base);
	// 825E4CFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E4D00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4D04: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 825E4D08: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E4D0C: 4BCDB6CD  bl 0x822c03d8
	ctx.lr = 0x825E4D10;
	sub_822C03D8(ctx, base);
	// 825E4D10: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E4D14: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E4D18: 418200B4  beq 0x825e4dcc
	if ctx.cr[0].eq {
	pc = 0x825E4DCC; continue 'dispatch;
	}
	// 825E4D1C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E4D20: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825E4D24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E4D28: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E4D2C: 409A0008  bne cr6, 0x825e4d34
	if !ctx.cr[6].eq {
	pc = 0x825E4D34; continue 'dispatch;
	}
	// 825E4D30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E4D34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E4D38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4D3C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825E4D40: 419A0024  beq cr6, 0x825e4d64
	if ctx.cr[6].eq {
	pc = 0x825E4D64; continue 'dispatch;
	}
	// 825E4D44: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E4D48: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E4D4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4D50: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E4D54: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E4D58: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E4D5C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4D60: 4082FFE8  bne 0x825e4d48
	if !ctx.cr[0].eq {
	pc = 0x825E4D48; continue 'dispatch;
	}
	// 825E4D64: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E4D68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4D6C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E4D70: 419A0024  beq cr6, 0x825e4d94
	if ctx.cr[6].eq {
	pc = 0x825E4D94; continue 'dispatch;
	}
	// 825E4D74: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E4D78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E4D7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4D80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E4D84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E4D88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E4D8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E4D90: 4082FFE8  bne 0x825e4d78
	if !ctx.cr[0].eq {
	pc = 0x825E4D78; continue 'dispatch;
	}
	// 825E4D94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E4D98: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825E4D9C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E4DA0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825E4DA4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E4DA8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E4DAC: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E4DB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E4DB4: 481B417D  bl 0x82798f30
	ctx.lr = 0x825E4DB8;
	sub_82798F30(ctx, base);
	// 825E4DB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4DC0: 481B68A9  bl 0x8279b668
	ctx.lr = 0x825E4DC4;
	sub_8279B668(ctx, base);
	// 825E4DC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E4DC8: 48000008  b 0x825e4dd0
	pc = 0x825E4DD0; continue 'dispatch;
	// 825E4DCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E4DD0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E4DD4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825E4DD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4DE0: 4BFB2E71  bl 0x82597c50
	ctx.lr = 0x825E4DE4;
	sub_82597C50(ctx, base);
	// 825E4DE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E4DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E4DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4DF0: 4BCDB211  bl 0x822c0000
	ctx.lr = 0x825E4DF4;
	sub_822C0000(ctx, base);
	// 825E4DF4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4DF8: 41820024  beq 0x825e4e1c
	if ctx.cr[0].eq {
	pc = 0x825E4E1C; continue 'dispatch;
	}
	// 825E4DFC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E4E00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4E04: 419A0008  beq cr6, 0x825e4e0c
	if ctx.cr[6].eq {
	pc = 0x825E4E0C; continue 'dispatch;
	}
	// 825E4E08: 4BCDBA89  bl 0x822c0890
	ctx.lr = 0x825E4E0C;
	sub_822C0890(ctx, base);
	// 825E4E0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E4E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4E14: 419A0008  beq cr6, 0x825e4e1c
	if ctx.cr[6].eq {
	pc = 0x825E4E1C; continue 'dispatch;
	}
	// 825E4E18: 4BCDBA79  bl 0x822c0890
	ctx.lr = 0x825E4E1C;
	sub_822C0890(ctx, base);
	// 825E4E1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E4E20: 419A000C  beq cr6, 0x825e4e2c
	if ctx.cr[6].eq {
	pc = 0x825E4E2C; continue 'dispatch;
	}
	// 825E4E24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E4E28: 4BCDBA69  bl 0x822c0890
	ctx.lr = 0x825E4E2C;
	sub_822C0890(ctx, base);
	// 825E4E2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E4E30: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825E4E34: 48BC3380  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E4E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E4E38 size=1016
    let mut pc: u32 = 0x825E4E38;
    'dispatch: loop {
        match pc {
            0x825E4E38 => {
    //   block [0x825E4E38..0x825E5230)
	// 825E4E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E4E3C: 48BC3319  bl 0x831a8154
	ctx.lr = 0x825E4E40;
	sub_831A8130(ctx, base);
	// 825E4E40: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E4E44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E4E48: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825E4E4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E4E50: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E4E54: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825E4E58: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825E4E5C: 4BF2A4D5  bl 0x8250f330
	ctx.lr = 0x825E4E60;
	sub_8250F330(ctx, base);
	// 825E4E60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E4E64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E4E68: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4E6C: 4BF06455  bl 0x824eb2c0
	ctx.lr = 0x825E4E70;
	sub_824EB2C0(ctx, base);
	// 825E4E70: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4E74: 4BF31ED5  bl 0x82516d48
	ctx.lr = 0x825E4E78;
	sub_82516D48(ctx, base);
	// 825E4E78: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E4E7C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E4E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E4E84: 419A000C  beq cr6, 0x825e4e90
	if ctx.cr[6].eq {
	pc = 0x825E4E90; continue 'dispatch;
	}
	// 825E4E88: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825E4E8C: 4BCDBA05  bl 0x822c0890
	ctx.lr = 0x825E4E90;
	sub_822C0890(ctx, base);
	// 825E4E90: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E4E94: 4880CDFD  bl 0x82df1c90
	ctx.lr = 0x825E4E98;
	sub_82DF1C90(ctx, base);
	// 825E4E98: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E4E9C: 4082038C  bne 0x825e5228
	if !ctx.cr[0].eq {
	pc = 0x825E5228; continue 'dispatch;
	}
	// 825E4EA0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E4EA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E4EA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E4EAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4EB0: 4BF2CB29  bl 0x825119d8
	ctx.lr = 0x825E4EB4;
	sub_825119D8(ctx, base);
	// 825E4EB4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E4EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4EBC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825E4EC0: 4880EB49  bl 0x82df3a08
	ctx.lr = 0x825E4EC4;
	sub_82DF3A08(ctx, base);
	// 825E4EC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E4EC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E4ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4ED0: 4BF238B1  bl 0x82508780
	ctx.lr = 0x825E4ED4;
	sub_82508780(ctx, base);
	// 825E4ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4ED8: 4880E551  bl 0x82df3428
	ctx.lr = 0x825E4EDC;
	sub_82DF3428(ctx, base);
	// 825E4EDC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825E4EE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825E4EE4: 3B9E0028  addi r28, r30, 0x28
	ctx.r[28].s64 = ctx.r[30].s64 + 40;
	// 825E4EE8: 409A0008  bne cr6, 0x825e4ef0
	if !ctx.cr[6].eq {
	pc = 0x825E4EF0; continue 'dispatch;
	}
	// 825E4EEC: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 825E4EF0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E4EF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4EF8: 808BD068  lwz r4, -0x2f98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12184 as u32) ) } as u64;
	// 825E4EFC: 4880EB0D  bl 0x82df3a08
	ctx.lr = 0x825E4F00;
	sub_82DF3A08(ctx, base);
	// 825E4F00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E4F04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E4F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4F0C: 4BF238E5  bl 0x825087f0
	ctx.lr = 0x825E4F10;
	sub_825087F0(ctx, base);
	// 825E4F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4F14: 4880E515  bl 0x82df3428
	ctx.lr = 0x825E4F18;
	sub_82DF3428(ctx, base);
	// 825E4F18: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E4F1C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E4F20: 48845BC9  bl 0x82e2aae8
	ctx.lr = 0x825E4F24;
	sub_82E2AAE8(ctx, base);
	// 825E4F24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4F2C: 388BF67C  addi r4, r11, -0x984
	ctx.r[4].s64 = ctx.r[11].s64 + -2436;
	// 825E4F30: 4880EAD9  bl 0x82df3a08
	ctx.lr = 0x825E4F34;
	sub_82DF3A08(ctx, base);
	// 825E4F34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4F38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E4F3C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E4F40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E4F44: 48849F2D  bl 0x82e2ee70
	ctx.lr = 0x825E4F48;
	sub_82E2EE70(ctx, base);
	// 825E4F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4F4C: 4880E4DD  bl 0x82df3428
	ctx.lr = 0x825E4F50;
	sub_82DF3428(ctx, base);
	// 825E4F50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E4F54: 3B0BF788  addi r24, r11, -0x878
	ctx.r[24].s64 = ctx.r[11].s64 + -2168;
	// 825E4F58: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E4F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E4F60: 419A0074  beq cr6, 0x825e4fd4
	if ctx.cr[6].eq {
	pc = 0x825E4FD4; continue 'dispatch;
	}
	// 825E4F64: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825E4F68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E4F6C: 38A0009C  li r5, 0x9c
	ctx.r[5].s64 = 156;
	// 825E4F70: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E4F74: 4880D475  bl 0x82df23e8
	ctx.lr = 0x825E4F78;
	sub_82DF23E8(ctx, base);
	// 825E4F78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E4F7C: 41820014  beq 0x825e4f90
	if ctx.cr[0].eq {
	pc = 0x825E4F90; continue 'dispatch;
	}
	// 825E4F80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E4F84: 4883190D  bl 0x82e16890
	ctx.lr = 0x825E4F88;
	sub_82E16890(ctx, base);
	// 825E4F88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4F8C: 48000008  b 0x825e4f94
	pc = 0x825E4F94; continue 'dispatch;
	// 825E4F90: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825E4F94: 3BFE00E8  addi r31, r30, 0xe8
	ctx.r[31].s64 = ctx.r[30].s64 + 232;
	// 825E4F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E4F9C: 4BD783D5  bl 0x8235d370
	ctx.lr = 0x825E4FA0;
	sub_8235D370(ctx, base);
	// 825E4FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E4FA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E4FA8: 83BE00E8  lwz r29, 0xe8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E4FAC: 4BF2D16D  bl 0x82512118
	ctx.lr = 0x825E4FB0;
	sub_82512118(ctx, base);
	// 825E4FB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E4FB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E4FB8: 488300F9  bl 0x82e150b0
	ctx.lr = 0x825E4FBC;
	sub_82E150B0(ctx, base);
	// 825E4FBC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E4FC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E4FC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E4FC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4FCC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E4FD0: 4BF2BB89  bl 0x82510b58
	ctx.lr = 0x825E4FD4;
	sub_82510B58(ctx, base);
	// 825E4FD4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E4FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E4FDC: 419A0008  beq cr6, 0x825e4fe4
	if ctx.cr[6].eq {
	pc = 0x825E4FE4; continue 'dispatch;
	}
	// 825E4FE0: 4BCDB8B1  bl 0x822c0890
	ctx.lr = 0x825E4FE4;
	sub_822C0890(ctx, base);
	// 825E4FE4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E4FE8: 48845B19  bl 0x82e2ab00
	ctx.lr = 0x825E4FEC;
	sub_82E2AB00(ctx, base);
	// 825E4FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E4FF0: 4BF2DAA9  bl 0x82512a98
	ctx.lr = 0x825E4FF4;
	sub_82512A98(ctx, base);
	// 825E4FF4: 3FE08335  lis r31, -0x7ccb
	ctx.r[31].s64 = -2093678592;
	// 825E4FF8: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 825E4FFC: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 825E5000: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 825E5004: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 825E5008: 817F7E94  lwz r11, 0x7e94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32404 as u32) ) } as u64;
	// 825E500C: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825E5010: 4082004C  bne 0x825e505c
	if !ctx.cr[0].eq {
	pc = 0x825E505C; continue 'dispatch;
	}
	// 825E5014: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825E5018: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E501C: 917F7E94  stw r11, 0x7e94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32404 as u32), ctx.r[11].u32 ) };
	// 825E5020: 4BCFFEA1  bl 0x822e4ec0
	ctx.lr = 0x825E5024;
	sub_822E4EC0(ctx, base);
	// 825E5024: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E5028: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E502C: 80DB67D0  lwz r6, 0x67d0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26576 as u32) ) } as u64;
	// 825E5030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5034: 80BC68A8  lwz r5, 0x68a8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26792 as u32) ) } as u64;
	// 825E5038: 808B68A4  lwz r4, 0x68a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26788 as u32) ) } as u64;
	// 825E503C: 4BD127DD  bl 0x822f7818
	ctx.lr = 0x825E5040;
	sub_822F7818(ctx, base);
	// 825E5040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E5044: 807D6730  lwz r3, 0x6730(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26416 as u32) ) } as u64;
	// 825E5048: E8BA0000  ld r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825E504C: E88B0000  ld r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825E5050: 4BEA7321  bl 0x8248c370
	ctx.lr = 0x825E5054;
	sub_8248C370(ctx, base);
	// 825E5054: 817F7E94  lwz r11, 0x7e94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32404 as u32) ) } as u64;
	// 825E5058: 90797E90  stw r3, 0x7e90(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(32400 as u32), ctx.r[3].u32 ) };
	// 825E505C: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825E5060: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 825E5064: 40820040  bne 0x825e50a4
	if !ctx.cr[0].eq {
	pc = 0x825E50A4; continue 'dispatch;
	}
	// 825E5068: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 825E506C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E5070: 917F7E94  stw r11, 0x7e94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32404 as u32), ctx.r[11].u32 ) };
	// 825E5074: 4BCFFE4D  bl 0x822e4ec0
	ctx.lr = 0x825E5078;
	sub_822E4EC0(ctx, base);
	// 825E5078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E507C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5080: 80BB67D0  lwz r5, 0x67d0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26576 as u32) ) } as u64;
	// 825E5084: 809C68A8  lwz r4, 0x68a8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26792 as u32) ) } as u64;
	// 825E5088: 4BD12719  bl 0x822f77a0
	ctx.lr = 0x825E508C;
	sub_822F77A0(ctx, base);
	// 825E508C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E5090: 807D6730  lwz r3, 0x6730(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26416 as u32) ) } as u64;
	// 825E5094: E8BF0000  ld r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 825E5098: E88B0000  ld r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825E509C: 4BEA72D5  bl 0x8248c370
	ctx.lr = 0x825E50A0;
	sub_8248C370(ctx, base);
	// 825E50A0: 907A7E8C  stw r3, 0x7e8c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32396 as u32), ctx.r[3].u32 ) };
	// 825E50A4: 897E0104  lbz r11, 0x104(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) } as u64;
	// 825E50A8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825E50AC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825E50B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E50B4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E50B8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825E50BC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825E50C0: 41820060  beq 0x825e5120
	if ctx.cr[0].eq {
	pc = 0x825E5120; continue 'dispatch;
	}
	// 825E50C4: 488BB66D  bl 0x82ea0730
	ctx.lr = 0x825E50C8;
	sub_82EA0730(ctx, base);
	// 825E50C8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825E50CC: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825E50D0: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825E50D4: C02A7BC8  lfs f1, 0x7bc8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E50D8: 48935119  bl 0x82f1a1f0
	ctx.lr = 0x825E50DC;
	sub_82F1A1F0(ctx, base);
	// 825E50DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E50E0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E50E4: 4182000C  beq 0x825e50f0
	if ctx.cr[0].eq {
	pc = 0x825E50F0; continue 'dispatch;
	}
	// 825E50E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E50EC: 4BD0315D  bl 0x822e8248
	ctx.lr = 0x825E50F0;
	sub_822E8248(ctx, base);
	// 825E50F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E50F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E50F8: 388BD970  addi r4, r11, -0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + -9872;
	// 825E50FC: 48814435  bl 0x82df9530
	ctx.lr = 0x825E5100;
	sub_82DF9530(ctx, base);
	// 825E5100: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E5104: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E5108: 80D97E90  lwz r6, 0x7e90(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32400 as u32) ) } as u64;
	// 825E510C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E5110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5114: 4BF2DFD5  bl 0x825130e8
	ctx.lr = 0x825E5118;
	sub_825130E8(ctx, base);
	// 825E5118: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E511C: 4800005C  b 0x825e5178
	pc = 0x825E5178; continue 'dispatch;
	// 825E5120: 488BB611  bl 0x82ea0730
	ctx.lr = 0x825E5124;
	sub_82EA0730(ctx, base);
	// 825E5124: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825E5128: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825E512C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825E5130: C02A7BC8  lfs f1, 0x7bc8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E5134: 489350BD  bl 0x82f1a1f0
	ctx.lr = 0x825E5138;
	sub_82F1A1F0(ctx, base);
	// 825E5138: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E513C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825E5140: 4182000C  beq 0x825e514c
	if ctx.cr[0].eq {
	pc = 0x825E514C; continue 'dispatch;
	}
	// 825E5144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5148: 4BD03101  bl 0x822e8248
	ctx.lr = 0x825E514C;
	sub_822E8248(ctx, base);
	// 825E514C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E5150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5154: 388BD970  addi r4, r11, -0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + -9872;
	// 825E5158: 488143D9  bl 0x82df9530
	ctx.lr = 0x825E515C;
	sub_82DF9530(ctx, base);
	// 825E515C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E5160: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 825E5164: 80DA7E8C  lwz r6, 0x7e8c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32396 as u32) ) } as u64;
	// 825E5168: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E516C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5170: 4BF2DF79  bl 0x825130e8
	ctx.lr = 0x825E5174;
	sub_825130E8(ctx, base);
	// 825E5174: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E5178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E517C: 907E00FC  stw r3, 0xfc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(252 as u32), ctx.r[3].u32 ) };
	// 825E5180: 419A000C  beq cr6, 0x825e518c
	if ctx.cr[6].eq {
	pc = 0x825E518C; continue 'dispatch;
	}
	// 825E5184: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825E5188: 4BD030E1  bl 0x822e8268
	ctx.lr = 0x825E518C;
	sub_822E8268(ctx, base);
	// 825E518C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E5190: 419A000C  beq cr6, 0x825e519c
	if ctx.cr[6].eq {
	pc = 0x825E519C; continue 'dispatch;
	}
	// 825E5194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5198: 4BD030D1  bl 0x822e8268
	ctx.lr = 0x825E519C;
	sub_822E8268(ctx, base);
	// 825E519C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825E51A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E51A4: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 825E51A8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E51AC: 4880D23D  bl 0x82df23e8
	ctx.lr = 0x825E51B0;
	sub_82DF23E8(ctx, base);
	// 825E51B0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E51B4: 41820034  beq 0x825e51e8
	if ctx.cr[0].eq {
	pc = 0x825E51E8; continue 'dispatch;
	}
	// 825E51B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E51BC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E51C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E51C4: C06B08A4  lfs f3, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E51C8: C04A9530  lfs f2, -0x6ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E51CC: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 825E51D0: 48896E49  bl 0x82e7c018
	ctx.lr = 0x825E51D4;
	sub_82E7C018(ctx, base);
	// 825E51D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E51D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E51DC: 4882DF15  bl 0x82e130f0
	ctx.lr = 0x825E51E0;
	sub_82E130F0(ctx, base);
	// 825E51E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E51E4: 48000008  b 0x825e51ec
	pc = 0x825E51EC; continue 'dispatch;
	// 825E51E8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825E51EC: 387E0120  addi r3, r30, 0x120
	ctx.r[3].s64 = ctx.r[30].s64 + 288;
	// 825E51F0: 4BCFCB61  bl 0x822e1d50
	ctx.lr = 0x825E51F4;
	sub_822E1D50(ctx, base);
	// 825E51F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E51F8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E51FC: 83FE0120  lwz r31, 0x120(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825E5200: 4BF2CF19  bl 0x82512118
	ctx.lr = 0x825E5204;
	sub_82512118(ctx, base);
	// 825E5204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E5208: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E520C: 4882DC25  bl 0x82e12e30
	ctx.lr = 0x825E5210;
	sub_82E12E30(ctx, base);
	// 825E5210: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E5214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5218: 419A0008  beq cr6, 0x825e5220
	if ctx.cr[6].eq {
	pc = 0x825E5220; continue 'dispatch;
	}
	// 825E521C: 4BCDB675  bl 0x822c0890
	ctx.lr = 0x825E5220;
	sub_822C0890(ctx, base);
	// 825E5220: 9AFE0110  stb r23, 0x110(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), ctx.r[23].u8 ) };
	// 825E5224: 92FE0114  stw r23, 0x114(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(276 as u32), ctx.r[23].u32 ) };
	// 825E5228: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825E522C: 48BC2F78  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E5230 size=1248
    let mut pc: u32 = 0x825E5230;
    'dispatch: loop {
        match pc {
            0x825E5230 => {
    //   block [0x825E5230..0x825E5710)
	// 825E5230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5234: 48BC2F35  bl 0x831a8168
	ctx.lr = 0x825E5238;
	sub_831A8130(ctx, base);
	// 825E5238: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825E523C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5244: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825E5248: 4BF2B4C1  bl 0x82510708
	ctx.lr = 0x825E524C;
	sub_82510708(ctx, base);
	// 825E524C: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 825E5250: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825E5254: 41980244  blt cr6, 0x825e5498
	if ctx.cr[6].lt {
	pc = 0x825E5498; continue 'dispatch;
	}
	// 825E5258: 409A04AC  bne cr6, 0x825e5704
	if !ctx.cr[6].eq {
	pc = 0x825E5704; continue 'dispatch;
	}
	// 825E525C: 897F00F1  lbz r11, 0xf1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(241 as u32) ) } as u64;
	// 825E5260: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E5264: 418204A0  beq 0x825e5704
	if ctx.cr[0].eq {
	pc = 0x825E5704; continue 'dispatch;
	}
	// 825E5268: C1BF00F8  lfs f13, 0xf8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E526C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E5270: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825E5274: C1BF00F4  lfs f13, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E5278: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 825E527C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825E5280: 41980484  blt cr6, 0x825e5704
	if ctx.cr[6].lt {
	pc = 0x825E5704; continue 'dispatch;
	}
	// 825E5284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E5288: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E528C: 4BF2A23D  bl 0x8250f4c8
	ctx.lr = 0x825E5290;
	sub_8250F4C8(ctx, base);
	// 825E5290: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5294: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825E5298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E529C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E52A0: 409A0008  bne cr6, 0x825e52a8
	if !ctx.cr[6].eq {
	pc = 0x825E52A8; continue 'dispatch;
	}
	// 825E52A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E52A8: 4BF23281  bl 0x82508528
	ctx.lr = 0x825E52AC;
	sub_82508528(ctx, base);
	// 825E52AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E52B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E52B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E52B8: 48845831  bl 0x82e2aae8
	ctx.lr = 0x825E52BC;
	sub_82E2AAE8(ctx, base);
	// 825E52BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E52C0: 4880C9D1  bl 0x82df1c90
	ctx.lr = 0x825E52C4;
	sub_82DF1C90(ctx, base);
	// 825E52C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E52C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E52CC: 388BF67C  addi r4, r11, -0x984
	ctx.r[4].s64 = ctx.r[11].s64 + -2436;
	// 825E52D0: 4880E739  bl 0x82df3a08
	ctx.lr = 0x825E52D4;
	sub_82DF3A08(ctx, base);
	// 825E52D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E52D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E52DC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E52E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E52E4: 48849B8D  bl 0x82e2ee70
	ctx.lr = 0x825E52E8;
	sub_82E2EE70(ctx, base);
	// 825E52E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E52EC: 4880E13D  bl 0x82df3428
	ctx.lr = 0x825E52F0;
	sub_82DF3428(ctx, base);
	// 825E52F0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E52F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E52F8: 419A0078  beq cr6, 0x825e5370
	if ctx.cr[6].eq {
	pc = 0x825E5370; continue 'dispatch;
	}
	// 825E52FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E5300: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E5304: 388BF788  addi r4, r11, -0x878
	ctx.r[4].s64 = ctx.r[11].s64 + -2168;
	// 825E5308: 38A0010B  li r5, 0x10b
	ctx.r[5].s64 = 267;
	// 825E530C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E5310: 4880D0D9  bl 0x82df23e8
	ctx.lr = 0x825E5314;
	sub_82DF23E8(ctx, base);
	// 825E5314: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E5318: 41820014  beq 0x825e532c
	if ctx.cr[0].eq {
	pc = 0x825E532C; continue 'dispatch;
	}
	// 825E531C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E5320: 48831571  bl 0x82e16890
	ctx.lr = 0x825E5324;
	sub_82E16890(ctx, base);
	// 825E5324: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E5328: 48000008  b 0x825e5330
	pc = 0x825E5330; continue 'dispatch;
	// 825E532C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E5330: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 825E5334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5338: 4BD78039  bl 0x8235d370
	ctx.lr = 0x825E533C;
	sub_8235D370(ctx, base);
	// 825E533C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E5340: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825E5344: 83BF00E8  lwz r29, 0xe8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E5348: 4BF2CDD1  bl 0x82512118
	ctx.lr = 0x825E534C;
	sub_82512118(ctx, base);
	// 825E534C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E5350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E5354: 4882FD5D  bl 0x82e150b0
	ctx.lr = 0x825E5358;
	sub_82E150B0(ctx, base);
	// 825E5358: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E535C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E5360: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E5364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5368: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E536C: 4BF2B7ED  bl 0x82510b58
	ctx.lr = 0x825E5370;
	sub_82510B58(ctx, base);
	// 825E5370: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E5374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5378: 419A0008  beq cr6, 0x825e5380
	if ctx.cr[6].eq {
	pc = 0x825E5380; continue 'dispatch;
	}
	// 825E537C: 4BCDB515  bl 0x822c0890
	ctx.lr = 0x825E5380;
	sub_822C0890(ctx, base);
	// 825E5380: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E5384: 4884577D  bl 0x82e2ab00
	ctx.lr = 0x825E5388;
	sub_82E2AB00(ctx, base);
	// 825E5388: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825E538C: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 825E5390: 816A7E9C  lwz r11, 0x7e9c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32412 as u32) ) } as u64;
	// 825E5394: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825E5398: 40820054  bne 0x825e53ec
	if !ctx.cr[0].eq {
	pc = 0x825E53EC; continue 'dispatch;
	}
	// 825E539C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825E53A0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825E53A4: 916A7E9C  stw r11, 0x7e9c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32412 as u32), ctx.r[11].u32 ) };
	// 825E53A8: 4BCFFB19  bl 0x822e4ec0
	ctx.lr = 0x825E53AC;
	sub_822E4EC0(ctx, base);
	// 825E53AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E53B0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825E53B4: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 825E53B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E53BC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825E53C0: 80CB67D0  lwz r6, 0x67d0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26576 as u32) ) } as u64;
	// 825E53C4: 80AA68A8  lwz r5, 0x68a8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26792 as u32) ) } as u64;
	// 825E53C8: 808968A4  lwz r4, 0x68a4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26788 as u32) ) } as u64;
	// 825E53CC: 4BD1244D  bl 0x822f7818
	ctx.lr = 0x825E53D0;
	sub_822F7818(ctx, base);
	// 825E53D0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825E53D4: E8BD0000  ld r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 825E53D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E53DC: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825E53E0: 806B6730  lwz r3, 0x6730(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26416 as u32) ) } as u64;
	// 825E53E4: 4BEA6F8D  bl 0x8248c370
	ctx.lr = 0x825E53E8;
	sub_8248C370(ctx, base);
	// 825E53E8: 907E7E98  stw r3, 0x7e98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32408 as u32), ctx.r[3].u32 ) };
	// 825E53EC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E53F0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825E53F4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825E53F8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825E53FC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825E5400: 488BB331  bl 0x82ea0730
	ctx.lr = 0x825E5404;
	sub_82EA0730(ctx, base);
	// 825E5404: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825E5408: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825E540C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825E5410: C02A7BC8  lfs f1, 0x7bc8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E5414: 48934DDD  bl 0x82f1a1f0
	ctx.lr = 0x825E5418;
	sub_82F1A1F0(ctx, base);
	// 825E5418: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825E541C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825E5420: 4182000C  beq 0x825e542c
	if ctx.cr[0].eq {
	pc = 0x825E542C; continue 'dispatch;
	}
	// 825E5424: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E5428: 4BD02E21  bl 0x822e8248
	ctx.lr = 0x825E542C;
	sub_822E8248(ctx, base);
	// 825E542C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E5430: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E5434: 388BD970  addi r4, r11, -0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + -9872;
	// 825E5438: 488140F9  bl 0x82df9530
	ctx.lr = 0x825E543C;
	sub_82DF9530(ctx, base);
	// 825E543C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E5440: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825E5444: 80DE7E98  lwz r6, 0x7e98(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32408 as u32) ) } as u64;
	// 825E5448: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825E544C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5450: 4BF2DC99  bl 0x825130e8
	ctx.lr = 0x825E5454;
	sub_825130E8(ctx, base);
	// 825E5454: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E5458: 907F00FC  stw r3, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[3].u32 ) };
	// 825E545C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5460: 419A000C  beq cr6, 0x825e546c
	if ctx.cr[6].eq {
	pc = 0x825E546C; continue 'dispatch;
	}
	// 825E5464: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825E5468: 4BD02E01  bl 0x822e8268
	ctx.lr = 0x825E546C;
	sub_822E8268(ctx, base);
	// 825E546C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E5470: 419A000C  beq cr6, 0x825e547c
	if ctx.cr[6].eq {
	pc = 0x825E547C; continue 'dispatch;
	}
	// 825E5474: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E5478: 4BD02DF1  bl 0x822e8268
	ctx.lr = 0x825E547C;
	sub_822E8268(ctx, base);
	// 825E547C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E5480: 9B9F0110  stb r28, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[28].u8 ) };
	// 825E5484: 939F0114  stw r28, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[28].u32 ) };
	// 825E5488: 939F0100  stw r28, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[28].u32 ) };
	// 825E548C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E5490: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 825E5494: 48000270  b 0x825e5704
	pc = 0x825E5704; continue 'dispatch;
	// 825E5498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E549C: 4BF2C64D  bl 0x82511ae8
	ctx.lr = 0x825E54A0;
	sub_82511AE8(ctx, base);
	// 825E54A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E54A4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E54A8: 4BF2A021  bl 0x8250f4c8
	ctx.lr = 0x825E54AC;
	sub_8250F4C8(ctx, base);
	// 825E54AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E54B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825E54B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E54B8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E54BC: 409A0008  bne cr6, 0x825e54c4
	if !ctx.cr[6].eq {
	pc = 0x825E54C4; continue 'dispatch;
	}
	// 825E54C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E54C4: 4BF23055  bl 0x82508518
	ctx.lr = 0x825E54C8;
	sub_82508518(ctx, base);
	// 825E54C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E54CC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825E54D0: C00BCF44  lfs f0, -0x30bc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E54D4: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E54D8: 4880C7B9  bl 0x82df1c90
	ctx.lr = 0x825E54DC;
	sub_82DF1C90(ctx, base);
	// 825E54DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E54E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E54E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E54E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825E54EC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825E54F0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E54F4: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E54F8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825E54FC: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825E5500: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825E5504: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825E5508: 48897739  bl 0x82e7cc40
	ctx.lr = 0x825E550C;
	sub_82E7CC40(ctx, base);
	// 825E550C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E5510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5514: 4BF2C5DD  bl 0x82511af0
	ctx.lr = 0x825E5518;
	sub_82511AF0(ctx, base);
	// 825E5518: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E551C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5520: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E5524: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825E5528: 4BF2C871  bl 0x82511d98
	ctx.lr = 0x825E552C;
	sub_82511D98(ctx, base);
	// 825E552C: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825E5530: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E5534: 41820180  beq 0x825e56b4
	if ctx.cr[0].eq {
	pc = 0x825E56B4; continue 'dispatch;
	}
	// 825E5538: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825E553C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5540: 419A00AC  beq cr6, 0x825e55ec
	if ctx.cr[6].eq {
	pc = 0x825E55EC; continue 'dispatch;
	}
	// 825E5544: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825E5548: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E554C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825E5550: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E5554: 4BD37C7D  bl 0x8231d1d0
	ctx.lr = 0x825E5558;
	sub_8231D1D0(ctx, base);
	// 825E5558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E555C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825E5560: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5568: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825E556C: 419A0024  beq cr6, 0x825e5590
	if ctx.cr[6].eq {
	pc = 0x825E5590; continue 'dispatch;
	}
	// 825E5570: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E5574: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E5578: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E557C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E5580: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E5584: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E5588: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E558C: 4082FFE8  bne 0x825e5574
	if !ctx.cr[0].eq {
	pc = 0x825E5574; continue 'dispatch;
	}
	// 825E5590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E5594: 80DF0114  lwz r6, 0x114(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825E5598: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 825E559C: 388BF788  addi r4, r11, -0x878
	ctx.r[4].s64 = ctx.r[11].s64 + -2168;
	// 825E55A0: 38A000DD  li r5, 0xdd
	ctx.r[5].s64 = 221;
	// 825E55A4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825E55A8: 48871A41  bl 0x82e56fe8
	ctx.lr = 0x825E55AC;
	sub_82E56FE8(ctx, base);
	// 825E55AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E55B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E55B4: 419A0008  beq cr6, 0x825e55bc
	if ctx.cr[6].eq {
	pc = 0x825E55BC; continue 'dispatch;
	}
	// 825E55B8: 4BCDB2D9  bl 0x822c0890
	ctx.lr = 0x825E55BC;
	sub_822C0890(ctx, base);
	// 825E55BC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825E55C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E55C4: 419A0008  beq cr6, 0x825e55cc
	if ctx.cr[6].eq {
	pc = 0x825E55CC; continue 'dispatch;
	}
	// 825E55C8: 4BCDB2C9  bl 0x822c0890
	ctx.lr = 0x825E55CC;
	sub_822C0890(ctx, base);
	// 825E55CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E55D0: C1A100B4  lfs f13, 0xb4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E55D4: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E55D8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825E55DC: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E55E0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825E55E4: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 825E55E8: 48000018  b 0x825e5600
	pc = 0x825E5600; continue 'dispatch;
	// 825E55EC: 83DF0108  lwz r30, 0x108(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E55F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E55F4: 4820A145  bl 0x827ef738
	ctx.lr = 0x825E55F8;
	sub_827EF738(ctx, base);
	// 825E55F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E55FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5600: 481CDC69  bl 0x827b3268
	ctx.lr = 0x825E5604;
	sub_827B3268(ctx, base);
	// 825E5604: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E5608: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E560C: 481CDC85  bl 0x827b3290
	ctx.lr = 0x825E5610;
	sub_827B3290(ctx, base);
	// 825E5610: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E5614: 4BCDA9ED  bl 0x822c0000
	ctx.lr = 0x825E5618;
	sub_822C0000(ctx, base);
	// 825E5618: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E561C: 4BCDA9E5  bl 0x822c0000
	ctx.lr = 0x825E5620;
	sub_822C0000(ctx, base);
	// 825E5620: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E5624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5628: 4BF2C459  bl 0x82511a80
	ctx.lr = 0x825E562C;
	sub_82511A80(ctx, base);
	// 825E562C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825E5630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5634: 409A00D0  bne cr6, 0x825e5704
	if !ctx.cr[6].eq {
	pc = 0x825E5704; continue 'dispatch;
	}
	// 825E5638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E563C: 83DF0108  lwz r30, 0x108(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825E5640: 4BF2C4A9  bl 0x82511ae8
	ctx.lr = 0x825E5644;
	sub_82511AE8(ctx, base);
	// 825E5644: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E5648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E564C: 4820A0ED  bl 0x827ef738
	ctx.lr = 0x825E5650;
	sub_827EF738(ctx, base);
	// 825E5650: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E5654: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E5658: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5710 size=48
    let mut pc: u32 = 0x825E5710;
    'dispatch: loop {
        match pc {
            0x825E5710 => {
    //   block [0x825E5710..0x825E5740)
	// 825E5710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5718: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E571C: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 825E5720: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825E5724: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E5728: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E572C: 4BECFAAD  bl 0x824b51d8
	ctx.lr = 0x825E5730;
	sub_824B51D8(ctx, base);
	// 825E5730: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E5734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E573C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5740 size=136
    let mut pc: u32 = 0x825E5740;
    'dispatch: loop {
        match pc {
            0x825E5740 => {
    //   block [0x825E5740..0x825E57C8)
	// 825E5740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5748: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E574C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5750: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5754: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E5758: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E575C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825E5760: 409A0020  bne cr6, 0x825e5780
	if !ctx.cr[6].eq {
	pc = 0x825E5780; continue 'dispatch;
	}
	// 825E5764: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E5768: 419A0048  beq cr6, 0x825e57b0
	if ctx.cr[6].eq {
	pc = 0x825E57B0; continue 'dispatch;
	}
	// 825E576C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5770: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E5774: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5778: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825E577C: 48000034  b 0x825e57b0
	pc = 0x825E57B0; continue 'dispatch;
	// 825E5780: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825E5784: 419A002C  beq cr6, 0x825e57b0
	if ctx.cr[6].eq {
	pc = 0x825E57B0; continue 'dispatch;
	}
	// 825E5788: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E578C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5790: 388BDC08  addi r4, r11, -0x23f8
	ctx.r[4].s64 = ctx.r[11].s64 + -9208;
	// 825E5794: 48BC2965  bl 0x831a80f8
	ctx.lr = 0x825E5798;
	sub_831A80F8(ctx, base);
	// 825E5798: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E579C: 4182000C  beq 0x825e57a8
	if ctx.cr[0].eq {
	pc = 0x825E57A8; continue 'dispatch;
	}
	// 825E57A0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825E57A4: 4800000C  b 0x825e57b0
	pc = 0x825E57B0; continue 'dispatch;
	// 825E57A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E57AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E57B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E57B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E57B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E57BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E57C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E57C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E57C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E57C8 size=108
    let mut pc: u32 = 0x825E57C8;
    'dispatch: loop {
        match pc {
            0x825E57C8 => {
    //   block [0x825E57C8..0x825E5834)
	// 825E57C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E57CC: 48BC29A1  bl 0x831a816c
	ctx.lr = 0x825E57D0;
	sub_831A8130(ctx, base);
	// 825E57D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E57D4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E57D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E57DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E57E0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E57E4: 41820038  beq 0x825e581c
	if ctx.cr[0].eq {
	pc = 0x825E581C; continue 'dispatch;
	}
	// 825E57E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E57EC: 48BC419D  bl 0x831a9988
	ctx.lr = 0x825E57F0;
	sub_831A9988(ctx, base);
	// 825E57F0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E57F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E57F8: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 825E57FC: 48BC28FD  bl 0x831a80f8
	ctx.lr = 0x825E5800;
	sub_831A80F8(ctx, base);
	// 825E5800: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E5804: 41820018  beq 0x825e581c
	if ctx.cr[0].eq {
	pc = 0x825E581C; continue 'dispatch;
	}
	// 825E5808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E580C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 825E5810: 480854E1  bl 0x8266acf0
	ctx.lr = 0x825E5814;
	sub_8266ACF0(ctx, base);
	// 825E5814: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825E5818: 48000014  b 0x825e582c
	pc = 0x825E582C; continue 'dispatch;
	// 825E581C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E5820: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E5824: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E5828: 4BF2CDF1  bl 0x82512618
	ctx.lr = 0x825E582C;
	sub_82512618(ctx, base);
	// 825E582C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E5830: 48BC298C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E5838 size=224
    let mut pc: u32 = 0x825E5838;
    'dispatch: loop {
        match pc {
            0x825E5838 => {
    //   block [0x825E5838..0x825E5918)
	// 825E5838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E583C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5848: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E584C: 78AB0020  clrldi r11, r5, 0x20
	ctx.r[11].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 825E5850: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E5854: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825E5858: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825E585C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825E5860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E5864: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825E5868: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E586C: C19E00F8  lfs f12, 0xf8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E5870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5874: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825E5878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E587C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825E5880: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825E5884: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E5888: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825E588C: 4BF2C2CD  bl 0x82511b58
	ctx.lr = 0x825E5890;
	sub_82511B58(ctx, base);
	// 825E5890: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E5894: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E5898: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E589C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E58A0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825E58A4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E58A8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825E58AC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E58B0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825E58B4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E58B8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825E58BC: 488965DD  bl 0x82e7be98
	ctx.lr = 0x825E58C0;
	sub_82E7BE98(ctx, base);
	// 825E58C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E58C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E58C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E58CC: 488963FD  bl 0x82e7bcc8
	ctx.lr = 0x825E58D0;
	sub_82E7BCC8(ctx, base);
	// 825E58D0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825E58D4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825E58D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E58DC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5918 size=196
    let mut pc: u32 = 0x825E5918;
    'dispatch: loop {
        match pc {
            0x825E5918 => {
    //   block [0x825E5918..0x825E59DC)
	// 825E5918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E591C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E592C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E5930: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E5934: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E5938: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E593C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E5940: 4BCDAFF9  bl 0x822c0938
	ctx.lr = 0x825E5944;
	sub_822C0938(ctx, base);
	// 825E5944: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E5948: 41820028  beq 0x825e5970
	if ctx.cr[0].eq {
	pc = 0x825E5970; continue 'dispatch;
	}
	// 825E594C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E5950: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E5954: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E5958: 392BF854  addi r9, r11, -0x7ac
	ctx.r[9].s64 = ctx.r[11].s64 + -1964;
	// 825E595C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E5960: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E5964: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E5968: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E596C: 48000008  b 0x825e5974
	pc = 0x825E5974; continue 'dispatch;
	// 825E5970: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E5974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E5978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E597C: 409A0044  bne cr6, 0x825e59c0
	if !ctx.cr[6].eq {
	pc = 0x825E59C0; continue 'dispatch;
	}
	// 825E5980: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E5984: 419A001C  beq cr6, 0x825e59a0
	if ctx.cr[6].eq {
	pc = 0x825E59A0; continue 'dispatch;
	}
	// 825E5988: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E598C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E5990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5994: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E599C: 4E800421  bctrl
	ctx.lr = 0x825E59A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E59A0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E59A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E59A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E59AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E59B0: 816BDC04  lwz r11, -0x23fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9212 as u32) ) } as u64;
	// 825E59B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E59B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E59BC: 4BCDA645  bl 0x822c0000
	ctx.lr = 0x825E59C0;
	sub_822C0000(ctx, base);
	// 825E59C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E59C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E59C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E59CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E59D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E59D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E59D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E59E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E59E0 size=72
    let mut pc: u32 = 0x825E59E0;
    'dispatch: loop {
        match pc {
            0x825E59E0 => {
    //   block [0x825E59E0..0x825E5A28)
	// 825E59E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E59E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E59E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E59EC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825E59F0: 419A001C  beq cr6, 0x825e5a0c
	if ctx.cr[6].eq {
	pc = 0x825E5A0C; continue 'dispatch;
	}
	// 825E59F4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E59F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E59FC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825E5A00: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E5A04: 4BFFFD3D  bl 0x825e5740
	ctx.lr = 0x825E5A08;
	sub_825E5740(ctx, base);
	// 825E5A08: 48000010  b 0x825e5a18
	pc = 0x825E5A18; continue 'dispatch;
	// 825E5A0C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E5A10: 396BDC08  addi r11, r11, -0x23f8
	ctx.r[11].s64 = ctx.r[11].s64 + -9208;
	// 825E5A14: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E5A18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E5A1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5A20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5A28 size=132
    let mut pc: u32 = 0x825E5A28;
    'dispatch: loop {
        match pc {
            0x825E5A28 => {
    //   block [0x825E5A28..0x825E5AAC)
	// 825E5A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5A30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5A34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5A3C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E5A48: 4E800421  bctrl
	ctx.lr = 0x825E5A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E5A4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5A50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E5A54: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5A5C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825E5A60: 419A0024  beq cr6, 0x825e5a84
	if ctx.cr[6].eq {
	pc = 0x825E5A84; continue 'dispatch;
	}
	// 825E5A64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E5A68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E5A6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5A70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E5A74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E5A78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E5A7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5A80: 4082FFE8  bne 0x825e5a68
	if !ctx.cr[0].eq {
	pc = 0x825E5A68; continue 'dispatch;
	}
	// 825E5A84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E5A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5A8C: 419A0008  beq cr6, 0x825e5a94
	if ctx.cr[6].eq {
	pc = 0x825E5A94; continue 'dispatch;
	}
	// 825E5A90: 4BCDAE01  bl 0x822c0890
	ctx.lr = 0x825E5A94;
	sub_822C0890(ctx, base);
	// 825E5A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5A98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E5A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E5AB0 size=220
    let mut pc: u32 = 0x825E5AB0;
    'dispatch: loop {
        match pc {
            0x825E5AB0 => {
    //   block [0x825E5AB0..0x825E5B8C)
	// 825E5AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5AB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5ABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5AC0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5AC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E5AC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5ACC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E5AD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5AD4: 388B7C1C  addi r4, r11, 0x7c1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31772;
	// 825E5AD8: 4880DF31  bl 0x82df3a08
	ctx.lr = 0x825E5ADC;
	sub_82DF3A08(ctx, base);
	// 825E5ADC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825E5AE0: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 825E5AE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825E5AE8: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825E5AEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E5AF0: 4BFBD8B9  bl 0x825a33a8
	ctx.lr = 0x825E5AF4;
	sub_825A33A8(ctx, base);
	// 825E5AF4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E5AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5AFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E5B00: 4BFBC3D9  bl 0x825a1ed8
	ctx.lr = 0x825E5B04;
	sub_825A1ED8(ctx, base);
	// 825E5B04: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825E5B08: 4880D921  bl 0x82df3428
	ctx.lr = 0x825E5B0C;
	sub_82DF3428(ctx, base);
	// 825E5B0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E5B10: 4BCE31A9  bl 0x822c8cb8
	ctx.lr = 0x825E5B14;
	sub_822C8CB8(ctx, base);
	// 825E5B14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5B18: 4880D911  bl 0x82df3428
	ctx.lr = 0x825E5B1C;
	sub_82DF3428(ctx, base);
	// 825E5B1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E5B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5B24: 388BC014  addi r4, r11, -0x3fec
	ctx.r[4].s64 = ctx.r[11].s64 + -16364;
	// 825E5B28: 4880DEE1  bl 0x82df3a08
	ctx.lr = 0x825E5B2C;
	sub_82DF3A08(ctx, base);
	// 825E5B2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E5B30: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E5B34: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 825E5B38: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E5B3C: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E5B40: C04A959C  lfs f2, -0x6a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E5B44: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 825E5B48: 4BFBD669  bl 0x825a31b0
	ctx.lr = 0x825E5B4C;
	sub_825A31B0(ctx, base);
	// 825E5B4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E5B50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E5B54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5B58: 4BFBBC19  bl 0x825a1770
	ctx.lr = 0x825E5B5C;
	sub_825A1770(ctx, base);
	// 825E5B5C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825E5B60: 4880D8C9  bl 0x82df3428
	ctx.lr = 0x825E5B64;
	sub_82DF3428(ctx, base);
	// 825E5B64: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E5B68: 4BCE3151  bl 0x822c8cb8
	ctx.lr = 0x825E5B6C;
	sub_822C8CB8(ctx, base);
	// 825E5B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5B70: 4880D8B9  bl 0x82df3428
	ctx.lr = 0x825E5B74;
	sub_82DF3428(ctx, base);
	// 825E5B74: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825E5B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5B80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E5B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5B90 size=80
    let mut pc: u32 = 0x825E5B90;
    'dispatch: loop {
        match pc {
            0x825E5B90 => {
    //   block [0x825E5B90..0x825E5BE0)
	// 825E5B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5B98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5B9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5BA0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E5BA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E5BA8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825E5BAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E5BB0: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 825E5BB4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825E5BB8: 38860004  addi r4, r6, 4
	ctx.r[4].s64 = ctx.r[6].s64 + 4;
	// 825E5BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5BC0: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E5BC4: 4BFFFE65  bl 0x825e5a28
	ctx.lr = 0x825E5BC8;
	sub_825E5A28(ctx, base);
	// 825E5BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5BCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E5BD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5BD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5BD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5BE0 size=136
    let mut pc: u32 = 0x825E5BE0;
    'dispatch: loop {
        match pc {
            0x825E5BE0 => {
    //   block [0x825E5BE0..0x825E5C68)
	// 825E5BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5BF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E5BFC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E5C00: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E5C04: 396BF8CC  addi r11, r11, -0x734
	ctx.r[11].s64 = ctx.r[11].s64 + -1844;
	// 825E5C08: 394AF8B8  addi r10, r10, -0x748
	ctx.r[10].s64 = ctx.r[10].s64 + -1864;
	// 825E5C0C: 3929F86C  addi r9, r9, -0x794
	ctx.r[9].s64 = ctx.r[9].s64 + -1940;
	// 825E5C10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E5C14: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E5C18: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825E5C1C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825E5C20: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825E5C24: 4BE42A5D  bl 0x82428680
	ctx.lr = 0x825E5C28;
	sub_82428680(ctx, base);
	// 825E5C28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E5C2C: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E5C30: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825E5C34: 4880C555  bl 0x82df2188
	ctx.lr = 0x825E5C38;
	sub_82DF2188(ctx, base);
	// 825E5C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E5C3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5C40: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825E5C44: 481C1A15  bl 0x827a7658
	ctx.lr = 0x825E5C48;
	sub_827A7658(ctx, base);
	// 825E5C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5C4C: 4BD69705  bl 0x8234f350
	ctx.lr = 0x825E5C50;
	sub_8234F350(ctx, base);
	// 825E5C50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E5C54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5C58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5C5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E5C60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5C64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E5C68 size=8
    let mut pc: u32 = 0x825E5C68;
    'dispatch: loop {
        match pc {
            0x825E5C68 => {
    //   block [0x825E5C68..0x825E5C70)
	// 825E5C68: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E5C6C: 480002D4  b 0x825e5f40
	sub_825E5F40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E5C70 size=8
    let mut pc: u32 = 0x825E5C70;
    'dispatch: loop {
        match pc {
            0x825E5C70 => {
    //   block [0x825E5C70..0x825E5C78)
	// 825E5C70: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825E5C74: 480002CC  b 0x825e5f40
	sub_825E5F40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E5C78 size=308
    let mut pc: u32 = 0x825E5C78;
    'dispatch: loop {
        match pc {
            0x825E5C78 => {
    //   block [0x825E5C78..0x825E5DAC)
	// 825E5C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5C88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5C90: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E5C94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5C98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825E5C9C: 419A00F8  beq cr6, 0x825e5d94
	if ctx.cr[6].eq {
	pc = 0x825E5D94; continue 'dispatch;
	}
	// 825E5CA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5CA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E5CA8: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E5CAC: 4BDEDC5D  bl 0x823d3908
	ctx.lr = 0x825E5CB0;
	sub_823D3908(ctx, base);
	// 825E5CB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5CB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E5CB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5CC0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825E5CC4: 419A0024  beq cr6, 0x825e5ce8
	if ctx.cr[6].eq {
	pc = 0x825E5CE8; continue 'dispatch;
	}
	// 825E5CC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E5CCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E5CD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5CD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E5CD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E5CDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E5CE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5CE4: 4082FFE8  bne 0x825e5ccc
	if !ctx.cr[0].eq {
	pc = 0x825E5CCC; continue 'dispatch;
	}
	// 825E5CE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E5CEC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E5CF0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825E5CF4: 388AF908  addi r4, r10, -0x6f8
	ctx.r[4].s64 = ctx.r[10].s64 + -1784;
	// 825E5CF8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825E5CFC: 38A000A4  li r5, 0xa4
	ctx.r[5].s64 = 164;
	// 825E5D00: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E5D04: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825E5D08: 48872D39  bl 0x82e58a40
	ctx.lr = 0x825E5D0C;
	sub_82E58A40(ctx, base);
	// 825E5D0C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E5D10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5D14: 419A0008  beq cr6, 0x825e5d1c
	if ctx.cr[6].eq {
	pc = 0x825E5D1C; continue 'dispatch;
	}
	// 825E5D18: 4BCDAB79  bl 0x822c0890
	ctx.lr = 0x825E5D1C;
	sub_822C0890(ctx, base);
	// 825E5D1C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E5D20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5D24: 419A0008  beq cr6, 0x825e5d2c
	if ctx.cr[6].eq {
	pc = 0x825E5D2C; continue 'dispatch;
	}
	// 825E5D28: 4BCDAB69  bl 0x822c0890
	ctx.lr = 0x825E5D2C;
	sub_822C0890(ctx, base);
	// 825E5D2C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E5D30: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 825E5D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E5D38: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5D3C: 4BD055F5  bl 0x822eb330
	ctx.lr = 0x825E5D40;
	sub_822EB330(ctx, base);
	// 825E5D40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E5D44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E5D48: 4BF29781  bl 0x8250f4c8
	ctx.lr = 0x825E5D4C;
	sub_8250F4C8(ctx, base);
	// 825E5D4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5D54: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825E5D58: 409A0008  bne cr6, 0x825e5d60
	if !ctx.cr[6].eq {
	pc = 0x825E5D60; continue 'dispatch;
	}
	// 825E5D5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E5D60: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E5D64: 4BF24865  bl 0x8250a5c8
	ctx.lr = 0x825E5D68;
	sub_8250A5C8(ctx, base);
	// 825E5D68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5D70: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 825E5D74: 409A0008  bne cr6, 0x825e5d7c
	if !ctx.cr[6].eq {
	pc = 0x825E5D7C; continue 'dispatch;
	}
	// 825E5D78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E5D7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E5D80: 481C4029  bl 0x827a9da8
	ctx.lr = 0x825E5D84;
	sub_827A9DA8(ctx, base);
	// 825E5D84: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E5D88: 4880BF09  bl 0x82df1c90
	ctx.lr = 0x825E5D8C;
	sub_82DF1C90(ctx, base);
	// 825E5D8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E5D90: 4880BF01  bl 0x82df1c90
	ctx.lr = 0x825E5D94;
	sub_82DF1C90(ctx, base);
	// 825E5D94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825E5D98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5D9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5DA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E5DA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5DA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5DB0 size=348
    let mut pc: u32 = 0x825E5DB0;
    'dispatch: loop {
        match pc {
            0x825E5DB0 => {
    //   block [0x825E5DB0..0x825E5F0C)
	// 825E5DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5DB4: 48BC23B1  bl 0x831a8164
	ctx.lr = 0x825E5DB8;
	sub_831A8130(ctx, base);
	// 825E5DB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5DBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E5DC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E5DC4: 817C00EC  lwz r11, 0xec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E5DC8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5DCC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825E5DD0: 419A0134  beq cr6, 0x825e5f04
	if ctx.cr[6].eq {
	pc = 0x825E5F04; continue 'dispatch;
	}
	// 825E5DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E5DD8: 3B7C0028  addi r27, r28, 0x28
	ctx.r[27].s64 = ctx.r[28].s64 + 40;
	// 825E5DDC: 3BABF908  addi r29, r11, -0x6f8
	ctx.r[29].s64 = ctx.r[11].s64 + -1784;
	// 825E5DE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E5DE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E5DE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E5DEC: 4BFFFA4D  bl 0x825e5838
	ctx.lr = 0x825E5DF0;
	sub_825E5838(ctx, base);
	// 825E5DF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E5DF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E5DF8: 4BD8ECE1  bl 0x82374ad8
	ctx.lr = 0x825E5DFC;
	sub_82374AD8(ctx, base);
	// 825E5DFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5E00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E5E04: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5E0C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E5E10: 419A0024  beq cr6, 0x825e5e34
	if ctx.cr[6].eq {
	pc = 0x825E5E34; continue 'dispatch;
	}
	// 825E5E14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E5E18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E5E1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5E20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E5E24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E5E28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E5E2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5E30: 4082FFE8  bne 0x825e5e18
	if !ctx.cr[0].eq {
	pc = 0x825E5E18; continue 'dispatch;
	}
	// 825E5E34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E5E38: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E5E3C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825E5E40: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 825E5E44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E5E48: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825E5E4C: 4887119D  bl 0x82e56fe8
	ctx.lr = 0x825E5E50;
	sub_82E56FE8(ctx, base);
	// 825E5E50: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E5E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5E58: 419A0008  beq cr6, 0x825e5e60
	if ctx.cr[6].eq {
	pc = 0x825E5E60; continue 'dispatch;
	}
	// 825E5E5C: 4BCDAA35  bl 0x822c0890
	ctx.lr = 0x825E5E60;
	sub_822C0890(ctx, base);
	// 825E5E60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E5E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5E68: 419A0008  beq cr6, 0x825e5e70
	if ctx.cr[6].eq {
	pc = 0x825E5E70; continue 'dispatch;
	}
	// 825E5E6C: 4BCDAA25  bl 0x822c0890
	ctx.lr = 0x825E5E70;
	sub_822C0890(ctx, base);
	// 825E5E70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E5E74: 4BF2BCE5  bl 0x82511b58
	ctx.lr = 0x825E5E78;
	sub_82511B58(ctx, base);
	// 825E5E78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E5E7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E5E80: 4BE7A5A9  bl 0x82460428
	ctx.lr = 0x825E5E84;
	sub_82460428(ctx, base);
	// 825E5E84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5E88: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E5E8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E5E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5E94: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825E5E98: 419A0024  beq cr6, 0x825e5ebc
	if ctx.cr[6].eq {
	pc = 0x825E5EBC; continue 'dispatch;
	}
	// 825E5E9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E5EA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E5EA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5EA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E5EAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E5EB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E5EB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E5EB8: 4082FFE8  bne 0x825e5ea0
	if !ctx.cr[0].eq {
	pc = 0x825E5EA0; continue 'dispatch;
	}
	// 825E5EBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E5EC0: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E5EC4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825E5EC8: 38A000B7  li r5, 0xb7
	ctx.r[5].s64 = 183;
	// 825E5ECC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E5ED0: 48871119  bl 0x82e56fe8
	ctx.lr = 0x825E5ED4;
	sub_82E56FE8(ctx, base);
	// 825E5ED4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E5ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5EDC: 419A0008  beq cr6, 0x825e5ee4
	if ctx.cr[6].eq {
	pc = 0x825E5EE4; continue 'dispatch;
	}
	// 825E5EE0: 4BCDA9B1  bl 0x822c0890
	ctx.lr = 0x825E5EE4;
	sub_822C0890(ctx, base);
	// 825E5EE4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E5EE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E5EEC: 419A0008  beq cr6, 0x825e5ef4
	if ctx.cr[6].eq {
	pc = 0x825E5EF4; continue 'dispatch;
	}
	// 825E5EF0: 4BCDA9A1  bl 0x822c0890
	ctx.lr = 0x825E5EF4;
	sub_822C0890(ctx, base);
	// 825E5EF4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E5EF8: 817C00EC  lwz r11, 0xec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E5EFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825E5F00: 409AFEE0  bne cr6, 0x825e5de0
	if !ctx.cr[6].eq {
	pc = 0x825E5DE0; continue 'dispatch;
	}
	// 825E5F04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825E5F08: 48BC22AC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5F10 size=48
    let mut pc: u32 = 0x825E5F10;
    'dispatch: loop {
        match pc {
            0x825E5F10 => {
    //   block [0x825E5F10..0x825E5F40)
	// 825E5F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5F18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5F1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5F24: 4BFFFC6D  bl 0x825e5b90
	ctx.lr = 0x825E5F28;
	sub_825E5B90(ctx, base);
	// 825E5F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5F2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E5F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5F38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5F40 size=76
    let mut pc: u32 = 0x825E5F40;
    'dispatch: loop {
        match pc {
            0x825E5F40 => {
    //   block [0x825E5F40..0x825E5F8C)
	// 825E5F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E5F58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E5F5C: 4BFFFC85  bl 0x825e5be0
	ctx.lr = 0x825E5F60;
	sub_825E5BE0(ctx, base);
	// 825E5F60: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E5F64: 4182000C  beq 0x825e5f70
	if ctx.cr[0].eq {
	pc = 0x825E5F70; continue 'dispatch;
	}
	// 825E5F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5F6C: 4880C46D  bl 0x82df23d8
	ctx.lr = 0x825E5F70;
	sub_82DF23D8(ctx, base);
	// 825E5F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E5F74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E5F78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5F7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5F80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E5F84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E5F90 size=88
    let mut pc: u32 = 0x825E5F90;
    'dispatch: loop {
        match pc {
            0x825E5F90 => {
    //   block [0x825E5F90..0x825E5FE8)
	// 825E5F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E5F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5FA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E5FA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E5FAC: 817E00F4  lwz r11, 0xf4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E5FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E5FB4: 4099001C  ble cr6, 0x825e5fd0
	if !ctx.cr[6].gt {
	pc = 0x825E5FD0; continue 'dispatch;
	}
	// 825E5FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E5FBC: 4BFFFCBD  bl 0x825e5c78
	ctx.lr = 0x825E5FC0;
	sub_825E5C78(ctx, base);
	// 825E5FC0: 817E00F4  lwz r11, 0xf4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E5FC4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825E5FC8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825E5FCC: 4198FFEC  blt cr6, 0x825e5fb8
	if ctx.cr[6].lt {
	pc = 0x825E5FB8; continue 'dispatch;
	}
	// 825E5FD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E5FD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E5FD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E5FDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E5FE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E5FE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E5FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E5FE8 size=152
    let mut pc: u32 = 0x825E5FE8;
    'dispatch: loop {
        match pc {
            0x825E5FE8 => {
    //   block [0x825E5FE8..0x825E6080)
	// 825E5FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E5FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E5FF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E5FF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E5FF8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E5FFC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825E6000: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 825E6004: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825E6008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E600C: 4BF2C255  bl 0x82512260
	ctx.lr = 0x825E6010;
	sub_82512260(ctx, base);
	// 825E6010: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6014: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E6018: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825E601C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E6020: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E6024: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E6028: 394AF8CC  addi r10, r10, -0x734
	ctx.r[10].s64 = ctx.r[10].s64 + -1844;
	// 825E602C: 3929F8B8  addi r9, r9, -0x748
	ctx.r[9].s64 = ctx.r[9].s64 + -1864;
	// 825E6030: 3968F86C  addi r11, r8, -0x794
	ctx.r[11].s64 = ctx.r[8].s64 + -1940;
	// 825E6034: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E6038: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E603C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825E6040: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E6044: 4BE80495  bl 0x824664d8
	ctx.lr = 0x825E6048;
	sub_824664D8(ctx, base);
	// 825E6048: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825E604C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E6050: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 825E6054: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825E6058: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 825E605C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6060: 913F00F4  stw r9, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 825E6064: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6068: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 825E606C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E6070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E607C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E6080 size=472
    let mut pc: u32 = 0x825E6080;
    'dispatch: loop {
        match pc {
            0x825E6080 => {
    //   block [0x825E6080..0x825E6258)
	// 825E6080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6084: 48BC20E1  bl 0x831a8164
	ctx.lr = 0x825E6088;
	sub_831A8130(ctx, base);
	// 825E6088: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E608C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6090: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E6094: 3BCBF908  addi r30, r11, -0x6f8
	ctx.r[30].s64 = ctx.r[11].s64 + -1784;
	// 825E6098: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825E609C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E60A0: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 825E60A4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825E60A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E60AC: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 825E60B0: 4880C339  bl 0x82df23e8
	ctx.lr = 0x825E60B4;
	sub_82DF23E8(ctx, base);
	// 825E60B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E60B8: 41820010  beq 0x825e60c8
	if ctx.cr[0].eq {
	pc = 0x825E60C8; continue 'dispatch;
	}
	// 825E60BC: 4BFFFF2D  bl 0x825e5fe8
	ctx.lr = 0x825E60C0;
	sub_825E5FE8(ctx, base);
	// 825E60C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E60C4: 48000008  b 0x825e60cc
	pc = 0x825E60CC; continue 'dispatch;
	// 825E60C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E60CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E60D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E60D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E60D8: 4BFFF841  bl 0x825e5918
	ctx.lr = 0x825E60DC;
	sub_825E5918(ctx, base);
	// 825E60DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E60E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E60E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E60E8: 4BCD9F19  bl 0x822c0000
	ctx.lr = 0x825E60EC;
	sub_822C0000(ctx, base);
	// 825E60EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E60F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E60F4: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 825E60F8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E60FC: 4BCDA2DD  bl 0x822c03d8
	ctx.lr = 0x825E6100;
	sub_822C03D8(ctx, base);
	// 825E6100: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E6104: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E6108: 418200E4  beq 0x825e61ec
	if ctx.cr[0].eq {
	pc = 0x825E61EC; continue 'dispatch;
	}
	// 825E610C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E6110: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E6114: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E6118: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825E611C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E6120: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6124: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E6128: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E612C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825E6130: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825E6134: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825E6138: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825E613C: 409A0008  bne cr6, 0x825e6144
	if !ctx.cr[6].eq {
	pc = 0x825E6144; continue 'dispatch;
	}
	// 825E6140: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E6144: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E6148: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E614C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825E6150: 419A0024  beq cr6, 0x825e6174
	if ctx.cr[6].eq {
	pc = 0x825E6174; continue 'dispatch;
	}
	// 825E6154: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E6158: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E615C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6160: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E6164: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E6168: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E616C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6170: 4082FFE8  bne 0x825e6158
	if !ctx.cr[0].eq {
	pc = 0x825E6158; continue 'dispatch;
	}
	// 825E6174: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E6178: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E617C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E6180: 419A0024  beq cr6, 0x825e61a4
	if ctx.cr[6].eq {
	pc = 0x825E61A4; continue 'dispatch;
	}
	// 825E6184: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E6188: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E618C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6190: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E6194: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E6198: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E619C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E61A0: 4082FFE8  bne 0x825e6188
	if !ctx.cr[0].eq {
	pc = 0x825E6188; continue 'dispatch;
	}
	// 825E61A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E61A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E61AC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E61B0: C02B1A38  lfs f1, 0x1a38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E61B4: 48896A8D  bl 0x82e7cc40
	ctx.lr = 0x825E61B8;
	sub_82E7CC40(ctx, base);
	// 825E61B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E61BC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E61C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E61C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E61C8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E61CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E61D0: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E61D4: 481B2D5D  bl 0x82798f30
	ctx.lr = 0x825E61D8;
	sub_82798F30(ctx, base);
	// 825E61D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E61DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E61E0: 481B5489  bl 0x8279b668
	ctx.lr = 0x825E61E4;
	sub_8279B668(ctx, base);
	// 825E61E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E61E8: 48000008  b 0x825e61f0
	pc = 0x825E61F0; continue 'dispatch;
	// 825E61EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E61F0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E61F4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825E61F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E61FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E6200: 4BFB1A51  bl 0x82597c50
	ctx.lr = 0x825E6204;
	sub_82597C50(ctx, base);
	// 825E6204: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E6208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E620C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E6210: 4BCD9DF1  bl 0x822c0000
	ctx.lr = 0x825E6214;
	sub_822C0000(ctx, base);
	// 825E6214: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E6218: 41820024  beq 0x825e623c
	if ctx.cr[0].eq {
	pc = 0x825E623C; continue 'dispatch;
	}
	// 825E621C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825E6220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6224: 419A0008  beq cr6, 0x825e622c
	if ctx.cr[6].eq {
	pc = 0x825E622C; continue 'dispatch;
	}
	// 825E6228: 4BCDA669  bl 0x822c0890
	ctx.lr = 0x825E622C;
	sub_822C0890(ctx, base);
	// 825E622C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825E6230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6234: 419A0008  beq cr6, 0x825e623c
	if ctx.cr[6].eq {
	pc = 0x825E623C; continue 'dispatch;
	}
	// 825E6238: 4BCDA659  bl 0x822c0890
	ctx.lr = 0x825E623C;
	sub_822C0890(ctx, base);
	// 825E623C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E6240: 419A000C  beq cr6, 0x825e624c
	if ctx.cr[6].eq {
	pc = 0x825E624C; continue 'dispatch;
	}
	// 825E6244: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E6248: 4BCDA649  bl 0x822c0890
	ctx.lr = 0x825E624C;
	sub_822C0890(ctx, base);
	// 825E624C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E6250: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825E6254: 48BC1F60  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6258 size=128
    let mut pc: u32 = 0x825E6258;
    'dispatch: loop {
        match pc {
            0x825E6258 => {
    //   block [0x825E6258..0x825E62D8)
	// 825E6258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E625C: 48BC1F11  bl 0x831a816c
	ctx.lr = 0x825E6260;
	sub_831A8130(ctx, base);
	// 825E6260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6264: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825E6268: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E626C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E6270: 3BEB7EA0  addi r31, r11, 0x7ea0
	ctx.r[31].s64 = ctx.r[11].s64 + 32416;
	// 825E6274: 816A7EA8  lwz r11, 0x7ea8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32424 as u32) ) } as u64;
	// 825E6278: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825E627C: 40820024  bne 0x825e62a0
	if !ctx.cr[0].eq {
	pc = 0x825E62A0; continue 'dispatch;
	}
	// 825E6280: 3D20825E  lis r9, -0x7da2
	ctx.r[9].s64 = -2107768832;
	// 825E6284: 3D00825E  lis r8, -0x7da2
	ctx.r[8].s64 = -2107768832;
	// 825E6288: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825E628C: 39295F10  addi r9, r9, 0x5f10
	ctx.r[9].s64 = ctx.r[9].s64 + 24336;
	// 825E6290: 390859E0  addi r8, r8, 0x59e0
	ctx.r[8].s64 = ctx.r[8].s64 + 23008;
	// 825E6294: 916A7EA8  stw r11, 0x7ea8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32424 as u32), ctx.r[11].u32 ) };
	// 825E6298: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825E629C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825E62A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E62A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825E62A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E62AC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825E62B0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825E62B4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E62B8: 4BFEC669  bl 0x825d2920
	ctx.lr = 0x825E62BC;
	sub_825D2920(ctx, base);
	// 825E62BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E62C0: 4182000C  beq 0x825e62cc
	if ctx.cr[0].eq {
	pc = 0x825E62CC; continue 'dispatch;
	}
	// 825E62C4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E62C8: 48000008  b 0x825e62d0
	pc = 0x825E62D0; continue 'dispatch;
	// 825E62CC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825E62D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E62D4: 48BC1EE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E62D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E62D8 size=536
    let mut pc: u32 = 0x825E62D8;
    'dispatch: loop {
        match pc {
            0x825E62D8 => {
    //   block [0x825E62D8..0x825E64F0)
	// 825E62D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E62DC: 48BC1E85  bl 0x831a8160
	ctx.lr = 0x825E62E0;
	sub_831A8130(ctx, base);
	// 825E62E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E62E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E62E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E62EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E62F0: 80BF00F0  lwz r5, 0xf0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 825E62F4: 4BFFF545  bl 0x825e5838
	ctx.lr = 0x825E62F8;
	sub_825E5838(ctx, base);
	// 825E62F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E62FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E6300: 388BF908  addi r4, r11, -0x6f8
	ctx.r[4].s64 = ctx.r[11].s64 + -1784;
	// 825E6304: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 825E6308: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 825E630C: 4880C0DD  bl 0x82df23e8
	ctx.lr = 0x825E6310;
	sub_82DF23E8(ctx, base);
	// 825E6310: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825E6314: 41820024  beq 0x825e6338
	if ctx.cr[0].eq {
	pc = 0x825E6338; continue 'dispatch;
	}
	// 825E6318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E631C: 4BF2B83D  bl 0x82511b58
	ctx.lr = 0x825E6320;
	sub_82511B58(ctx, base);
	// 825E6320: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E6324: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825E6328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E632C: 4BFFD915  bl 0x825e3c40
	ctx.lr = 0x825E6330;
	sub_825E3C40(ctx, base);
	// 825E6330: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E6334: 48000008  b 0x825e633c
	pc = 0x825E633C; continue 'dispatch;
	// 825E6338: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E633C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825E6340: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E6344: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E6348: 4BFFD609  bl 0x825e3950
	ctx.lr = 0x825E634C;
	sub_825E3950(ctx, base);
	// 825E634C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E6350: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E6354: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E6358: 4BCD9CA9  bl 0x822c0000
	ctx.lr = 0x825E635C;
	sub_822C0000(ctx, base);
	// 825E635C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E6360: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E6364: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E6368: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825E636C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825E6370: 419A0024  beq cr6, 0x825e6394
	if ctx.cr[6].eq {
	pc = 0x825E6394; continue 'dispatch;
	}
	// 825E6374: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E6378: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E637C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6380: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E6384: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E6388: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E638C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6390: 4082FFE8  bne 0x825e6378
	if !ctx.cr[0].eq {
	pc = 0x825E6378; continue 'dispatch;
	}
	// 825E6394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E6398: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E639C: 4BF2912D  bl 0x8250f4c8
	ctx.lr = 0x825E63A0;
	sub_8250F4C8(ctx, base);
	// 825E63A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E63A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E63A8: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825E63AC: 409A0008  bne cr6, 0x825e63b4
	if !ctx.cr[6].eq {
	pc = 0x825E63B4; continue 'dispatch;
	}
	// 825E63B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E63B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E63B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E63BC: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 825E63C0: 4BF29159  bl 0x8250f518
	ctx.lr = 0x825E63C4;
	sub_8250F518(ctx, base);
	// 825E63C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E63C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E63CC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825E63D0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825E63D4: 4BF27135  bl 0x8250d508
	ctx.lr = 0x825E63D8;
	sub_8250D508(ctx, base);
	// 825E63D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E63DC: 4880B8B5  bl 0x82df1c90
	ctx.lr = 0x825E63E0;
	sub_82DF1C90(ctx, base);
	// 825E63E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E63E4: 4880B8AD  bl 0x82df1c90
	ctx.lr = 0x825E63E8;
	sub_82DF1C90(ctx, base);
	// 825E63E8: 3BBD0028  addi r29, r29, 0x28
	ctx.r[29].s64 = ctx.r[29].s64 + 40;
	// 825E63EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E63F0: 48A22BC9  bl 0x83008fb8
	ctx.lr = 0x825E63F4;
	sub_83008FB8(ctx, base);
	// 825E63F4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825E63F8: 837F00EC  lwz r27, 0xec(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E63FC: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 825E6400: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825E6404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E6408: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825E640C: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E6410: 4BF738F1  bl 0x82559d00
	ctx.lr = 0x825E6414;
	sub_82559D00(ctx, base);
	// 825E6414: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E6418: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E641C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E6420: 485E39D9  bl 0x82bc9df8
	ctx.lr = 0x825E6424;
	sub_82BC9DF8(ctx, base);
	// 825E6424: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825E6428: 935B0004  stw r26, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825E642C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E6430: 396B3FA0  addi r11, r11, 0x3fa0
	ctx.r[11].s64 = ctx.r[11].s64 + 16288;
	// 825E6434: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E6438: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E643C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825E6440: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E6444: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 825E6448: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 825E644C: 4BFFFE0D  bl 0x825e6258
	ctx.lr = 0x825E6450;
	sub_825E6258(ctx, base);
	// 825E6450: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E6454: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E6458: 4BF29071  bl 0x8250f4c8
	ctx.lr = 0x825E645C;
	sub_8250F4C8(ctx, base);
	// 825E645C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E6464: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825E6468: 409A0008  bne cr6, 0x825e6470
	if !ctx.cr[6].eq {
	pc = 0x825E6470; continue 'dispatch;
	}
	// 825E646C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E6470: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E6474: 4BF24155  bl 0x8250a5c8
	ctx.lr = 0x825E6478;
	sub_8250A5C8(ctx, base);
	// 825E6478: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E647C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E6480: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 825E6484: 409A0008  bne cr6, 0x825e648c
	if !ctx.cr[6].eq {
	pc = 0x825E648C; continue 'dispatch;
	}
	// 825E6488: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E648C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6490: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 825E6494: 4BF2B6C5  bl 0x82511b58
	ctx.lr = 0x825E6498;
	sub_82511B58(ctx, base);
	// 825E6498: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E649C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E64A0: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 825E64A4: 48A22B15  bl 0x83008fb8
	ctx.lr = 0x825E64A8;
	sub_83008FB8(ctx, base);
	// 825E64A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E64AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E64B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E64B4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825E64B8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825E64BC: 481C5FCD  bl 0x827ac488
	ctx.lr = 0x825E64C0;
	sub_827AC488(ctx, base);
	// 825E64C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E64C4: 4880B7CD  bl 0x82df1c90
	ctx.lr = 0x825E64C8;
	sub_82DF1C90(ctx, base);
	// 825E64C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E64CC: 4880B7C5  bl 0x82df1c90
	ctx.lr = 0x825E64D0;
	sub_82DF1C90(ctx, base);
	// 825E64D0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E64D4: 4BCE27E5  bl 0x822c8cb8
	ctx.lr = 0x825E64D8;
	sub_822C8CB8(ctx, base);
	// 825E64D8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E64DC: 419A000C  beq cr6, 0x825e64e8
	if ctx.cr[6].eq {
	pc = 0x825E64E8; continue 'dispatch;
	}
	// 825E64E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E64E4: 4BCDA3AD  bl 0x822c0890
	ctx.lr = 0x825E64E8;
	sub_822C0890(ctx, base);
	// 825E64E8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825E64EC: 48BC1CC4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E64F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E64F0 size=160
    let mut pc: u32 = 0x825E64F0;
    'dispatch: loop {
        match pc {
            0x825E64F0 => {
    //   block [0x825E64F0..0x825E6590)
	// 825E64F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E64F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E64F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E64FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E6500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E6508: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E650C: 4BF2B4CD  bl 0x825119d8
	ctx.lr = 0x825E6510;
	sub_825119D8(ctx, base);
	// 825E6510: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E6514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6518: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825E651C: 4880D4ED  bl 0x82df3a08
	ctx.lr = 0x825E6520;
	sub_82DF3A08(ctx, base);
	// 825E6520: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E6524: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E6528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E652C: 4BF22255  bl 0x82508780
	ctx.lr = 0x825E6530;
	sub_82508780(ctx, base);
	// 825E6530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6534: 4880CEF5  bl 0x82df3428
	ctx.lr = 0x825E6538;
	sub_82DF3428(ctx, base);
	// 825E6538: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E653C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825E6540: 409A0008  bne cr6, 0x825e6548
	if !ctx.cr[6].eq {
	pc = 0x825E6548; continue 'dispatch;
	}
	// 825E6544: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E6548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E654C: 4BF22255  bl 0x825087a0
	ctx.lr = 0x825E6550;
	sub_825087A0(ctx, base);
	// 825E6550: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E6554: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E6558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E655C: 4099001C  ble cr6, 0x825e6578
	if !ctx.cr[6].gt {
	pc = 0x825E6578; continue 'dispatch;
	}
	// 825E6560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6564: 4BFFFD75  bl 0x825e62d8
	ctx.lr = 0x825E6568;
	sub_825E62D8(ctx, base);
	// 825E6568: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E656C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825E6570: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825E6574: 4198FFEC  blt cr6, 0x825e6560
	if ctx.cr[6].lt {
	pc = 0x825E6560; continue 'dispatch;
	}
	// 825E6578: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E657C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6580: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6584: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E6588: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E658C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6590 size=144
    let mut pc: u32 = 0x825E6590;
    'dispatch: loop {
        match pc {
            0x825E6590 => {
    //   block [0x825E6590..0x825E6620)
	// 825E6590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E6598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E659C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E65A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E65A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E65A8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E65AC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E65B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825E65B4: 40980020  bge cr6, 0x825e65d4
	if !ctx.cr[6].lt {
	pc = 0x825E65D4; continue 'dispatch;
	}
	// 825E65B8: 3BDFFF1C  addi r30, r31, -0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + -228;
	// 825E65BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E65C0: 4BFFFD19  bl 0x825e62d8
	ctx.lr = 0x825E65C4;
	sub_825E62D8(ctx, base);
	// 825E65C4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E65C8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E65CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825E65D0: 4198FFEC  blt cr6, 0x825e65bc
	if ctx.cr[6].lt {
	pc = 0x825E65BC; continue 'dispatch;
	}
	// 825E65D4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E65D8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E65DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825E65E0: 40990020  ble cr6, 0x825e6600
	if !ctx.cr[6].gt {
	pc = 0x825E6600; continue 'dispatch;
	}
	// 825E65E4: 3BDFFF1C  addi r30, r31, -0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + -228;
	// 825E65E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E65EC: 4BFFF68D  bl 0x825e5c78
	ctx.lr = 0x825E65F0;
	sub_825E5C78(ctx, base);
	// 825E65F0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E65F4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E65F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825E65FC: 4199FFEC  bgt cr6, 0x825e65e8
	if ctx.cr[6].gt {
	pc = 0x825E65E8; continue 'dispatch;
	}
	// 825E6600: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 825E6604: 4BFFF7AD  bl 0x825e5db0
	ctx.lr = 0x825E6608;
	sub_825E5DB0(ctx, base);
	// 825E6608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E660C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6614: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E6618: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E661C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6620 size=108
    let mut pc: u32 = 0x825E6620;
    'dispatch: loop {
        match pc {
            0x825E6620 => {
    //   block [0x825E6620..0x825E668C)
	// 825E6620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6624: 48BC1B49  bl 0x831a816c
	ctx.lr = 0x825E6628;
	sub_831A8130(ctx, base);
	// 825E6628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E662C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E6630: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E6634: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E6638: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E663C: 41820038  beq 0x825e6674
	if ctx.cr[0].eq {
	pc = 0x825E6674; continue 'dispatch;
	}
	// 825E6640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6644: 48BC3345  bl 0x831a9988
	ctx.lr = 0x825E6648;
	sub_831A9988(ctx, base);
	// 825E6648: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825E664C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E6650: 386B5A88  addi r3, r11, 0x5a88
	ctx.r[3].s64 = ctx.r[11].s64 + 23176;
	// 825E6654: 48BC1AA5  bl 0x831a80f8
	ctx.lr = 0x825E6658;
	sub_831A80F8(ctx, base);
	// 825E6658: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E665C: 41820018  beq 0x825e6674
	if ctx.cr[0].eq {
	pc = 0x825E6674; continue 'dispatch;
	}
	// 825E6660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E6664: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 825E6668: 48526139  bl 0x82b0c7a0
	ctx.lr = 0x825E666C;
	sub_82B0C7A0(ctx, base);
	// 825E666C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825E6670: 48000014  b 0x825e6684
	pc = 0x825E6684; continue 'dispatch;
	// 825E6674: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E6678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E667C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E6680: 4BF2BF99  bl 0x82512618
	ctx.lr = 0x825E6684;
	sub_82512618(ctx, base);
	// 825E6684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E6688: 48BC1B34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E6690 size=816
    let mut pc: u32 = 0x825E6690;
    'dispatch: loop {
        match pc {
            0x825E6690 => {
    //   block [0x825E6690..0x825E69C0)
	// 825E6690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6694: 48BC1ACD  bl 0x831a8160
	ctx.lr = 0x825E6698;
	sub_831A8130(ctx, base);
	// 825E6698: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 825E669C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825E66A0: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E69C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E69C0 size=144
    let mut pc: u32 = 0x825E69C0;
    'dispatch: loop {
        match pc {
            0x825E69C0 => {
    //   block [0x825E69C0..0x825E6A50)
	// 825E69C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E69C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E69C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E69CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E69D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E69D4: 4BF2B95D  bl 0x82512330
	ctx.lr = 0x825E69D8;
	sub_82512330(ctx, base);
	// 825E69D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E69DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E69E0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E69E4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825E69E8: 394AF98C  addi r10, r10, -0x674
	ctx.r[10].s64 = ctx.r[10].s64 + -1652;
	// 825E69EC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E69F0: 3929F974  addi r9, r9, -0x68c
	ctx.r[9].s64 = ctx.r[9].s64 + -1676;
	// 825E69F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E69F8: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 825E69FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E6A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6A04: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E6A08: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6A0C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825E6A10: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 825E6A14: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 825E6A18: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 825E6A1C: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 825E6A20: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 825E6A24: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 825E6A28: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 825E6A2C: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 825E6A30: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 825E6A34: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 825E6A38: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 825E6A3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E6A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6A48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E6A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E6A50 size=8
    let mut pc: u32 = 0x825E6A50;
    'dispatch: loop {
        match pc {
            0x825E6A50 => {
    //   block [0x825E6A50..0x825E6A58)
	// 825E6A50: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E6A54: 48000054  b 0x825e6aa8
	sub_825E6AA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6A58 size=80
    let mut pc: u32 = 0x825E6A58;
    'dispatch: loop {
        match pc {
            0x825E6A58 => {
    //   block [0x825E6A58..0x825E6AA8)
	// 825E6A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E6A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E6A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E6A6C: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825E6A70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6A74: 419A0008  beq cr6, 0x825e6a7c
	if ctx.cr[6].eq {
	pc = 0x825E6A7C; continue 'dispatch;
	}
	// 825E6A78: 4BCD9E19  bl 0x822c0890
	ctx.lr = 0x825E6A7C;
	sub_822C0890(ctx, base);
	// 825E6A7C: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825E6A80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6A84: 419A0008  beq cr6, 0x825e6a8c
	if ctx.cr[6].eq {
	pc = 0x825E6A8C; continue 'dispatch;
	}
	// 825E6A88: 4BCD9E09  bl 0x822c0890
	ctx.lr = 0x825E6A8C;
	sub_822C0890(ctx, base);
	// 825E6A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6A90: 4BD688C1  bl 0x8234f350
	ctx.lr = 0x825E6A94;
	sub_8234F350(ctx, base);
	// 825E6A94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E6A98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6A9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6AA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E6AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6AA8 size=76
    let mut pc: u32 = 0x825E6AA8;
    'dispatch: loop {
        match pc {
            0x825E6AA8 => {
    //   block [0x825E6AA8..0x825E6AF4)
	// 825E6AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E6AB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E6AB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E6AB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E6AC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E6AC4: 4BFFFF95  bl 0x825e6a58
	ctx.lr = 0x825E6AC8;
	sub_825E6A58(ctx, base);
	// 825E6AC8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E6ACC: 4182000C  beq 0x825e6ad8
	if ctx.cr[0].eq {
	pc = 0x825E6AD8; continue 'dispatch;
	}
	// 825E6AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6AD4: 4880B905  bl 0x82df23d8
	ctx.lr = 0x825E6AD8;
	sub_82DF23D8(ctx, base);
	// 825E6AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6ADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E6AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6AE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E6AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E6AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E6AF8 size=808
    let mut pc: u32 = 0x825E6AF8;
    'dispatch: loop {
        match pc {
            0x825E6AF8 => {
    //   block [0x825E6AF8..0x825E6E20)
	// 825E6AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6AFC: 48BC1665  bl 0x831a8160
	ctx.lr = 0x825E6B00;
	sub_831A8130(ctx, base);
	// 825E6B00: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825E6B04: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6B08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E6B0C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825E6B10: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825E6B14: 4BF2AEC5  bl 0x825119d8
	ctx.lr = 0x825E6B18;
	sub_825119D8(ctx, base);
	// 825E6B18: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E6B1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6B20: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825E6B24: 4880CEE5  bl 0x82df3a08
	ctx.lr = 0x825E6B28;
	sub_82DF3A08(ctx, base);
	// 825E6B28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E6B2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E6B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6B34: 4BF21C4D  bl 0x82508780
	ctx.lr = 0x825E6B38;
	sub_82508780(ctx, base);
	// 825E6B38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6B3C: 4880C8ED  bl 0x82df3428
	ctx.lr = 0x825E6B40;
	sub_82DF3428(ctx, base);
	// 825E6B40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825E6B44: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 825E6B48: 409A0008  bne cr6, 0x825e6b50
	if !ctx.cr[6].eq {
	pc = 0x825E6B50; continue 'dispatch;
	}
	// 825E6B4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E6B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6B54: 4BF21C4D  bl 0x825087a0
	ctx.lr = 0x825E6B58;
	sub_825087A0(ctx, base);
	// 825E6B58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E6B5C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E6B60: 4BF287D1  bl 0x8250f330
	ctx.lr = 0x825E6B64;
	sub_8250F330(ctx, base);
	// 825E6B64: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6B68: 4BF020E1  bl 0x824e8c48
	ctx.lr = 0x825E6B6C;
	sub_824E8C48(ctx, base);
	// 825E6B6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6B70: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E6B74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E6B78: 4E800421  bctrl
	ctx.lr = 0x825E6B7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E6B7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825E6B80: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E6B84: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825E6B88: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825E6B8C: 4880B105  bl 0x82df1c90
	ctx.lr = 0x825E6B90;
	sub_82DF1C90(ctx, base);
	// 825E6B90: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E6B94: 41820010  beq 0x825e6ba4
	if ctx.cr[0].eq {
	pc = 0x825E6BA4; continue 'dispatch;
	}
	// 825E6B98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E6B9C: C00BC65C  lfs f0, -0x39a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14756 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6BA0: D01E00E4  stfs f0, 0xe4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 825E6BA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6BA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E6BAC: 3B8BF9C8  addi r28, r11, -0x638
	ctx.r[28].s64 = ctx.r[11].s64 + -1592;
	// 825E6BB0: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 825E6BB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E6BB8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E6BBC: 4880B82D  bl 0x82df23e8
	ctx.lr = 0x825E6BC0;
	sub_82DF23E8(ctx, base);
	// 825E6BC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E6BC4: 41820018  beq 0x825e6bdc
	if ctx.cr[0].eq {
	pc = 0x825E6BDC; continue 'dispatch;
	}
	// 825E6BC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E6BCC: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825E6BD0: 4882C521  bl 0x82e130f0
	ctx.lr = 0x825E6BD4;
	sub_82E130F0(ctx, base);
	// 825E6BD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E6BD8: 48000008  b 0x825e6be0
	pc = 0x825E6BE0; continue 'dispatch;
	// 825E6BDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E6BE0: 3BBE0110  addi r29, r30, 0x110
	ctx.r[29].s64 = ctx.r[30].s64 + 272;
	// 825E6BE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E6BE8: 4BCFB169  bl 0x822e1d50
	ctx.lr = 0x825E6BEC;
	sub_822E1D50(ctx, base);
	// 825E6BEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E6BF0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E6BF4: 83FE0110  lwz r31, 0x110(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 825E6BF8: 4BF2B521  bl 0x82512118
	ctx.lr = 0x825E6BFC;
	sub_82512118(ctx, base);
	// 825E6BFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E6C00: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6C04: 4882C22D  bl 0x82e12e30
	ctx.lr = 0x825E6C08;
	sub_82E12E30(ctx, base);
	// 825E6C08: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825E6C0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6C10: 419A0008  beq cr6, 0x825e6c18
	if ctx.cr[6].eq {
	pc = 0x825E6C18; continue 'dispatch;
	}
	// 825E6C14: 4BCD9C7D  bl 0x822c0890
	ctx.lr = 0x825E6C18;
	sub_822C0890(ctx, base);
	// 825E6C18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E6C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E6C20: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 825E6C24: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825E6C28: 4880B7C1  bl 0x82df23e8
	ctx.lr = 0x825E6C2C;
	sub_82DF23E8(ctx, base);
	// 825E6C2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6C30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E6C34: 3B6BF960  addi r27, r11, -0x6a0
	ctx.r[27].s64 = ctx.r[11].s64 + -1696;
	// 825E6C38: 4182002C  beq 0x825e6c64
	if ctx.cr[0].eq {
	pc = 0x825E6C64; continue 'dispatch;
	}
	// 825E6C3C: C07BFFFC  lfs f3, -4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E6C40: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825E6C44: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 825E6C48: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 825E6C4C: 48895325  bl 0x82e7bf70
	ctx.lr = 0x825E6C50;
	sub_82E7BF70(ctx, base);
	// 825E6C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E6C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6C58: 4882C499  bl 0x82e130f0
	ctx.lr = 0x825E6C5C;
	sub_82E130F0(ctx, base);
	// 825E6C5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E6C60: 48000008  b 0x825e6c68
	pc = 0x825E6C68; continue 'dispatch;
	// 825E6C64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E6C68: 3BFE0118  addi r31, r30, 0x118
	ctx.r[31].s64 = ctx.r[30].s64 + 280;
	// 825E6C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6C70: 4BCFB0E1  bl 0x822e1d50
	ctx.lr = 0x825E6C74;
	sub_822E1D50(ctx, base);
	// 825E6C74: 809E0118  lwz r4, 0x118(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 825E6C78: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6C7C: 4882C1B5  bl 0x82e12e30
	ctx.lr = 0x825E6C80;
	sub_82E12E30(ctx, base);
	// 825E6C80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E6C84: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6C88: 48843E61  bl 0x82e2aae8
	ctx.lr = 0x825E6C8C;
	sub_82E2AAE8(ctx, base);
	// 825E6C8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6C94: 388BF67C  addi r4, r11, -0x984
	ctx.r[4].s64 = ctx.r[11].s64 + -2436;
	// 825E6C98: 4880CD71  bl 0x82df3a08
	ctx.lr = 0x825E6C9C;
	sub_82DF3A08(ctx, base);
	// 825E6C9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E6CA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E6CA4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E6CA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E6CAC: 488481C5  bl 0x82e2ee70
	ctx.lr = 0x825E6CB0;
	sub_82E2EE70(ctx, base);
	// 825E6CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6CB4: 4880C775  bl 0x82df3428
	ctx.lr = 0x825E6CB8;
	sub_82DF3428(ctx, base);
	// 825E6CB8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E6CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E6CC0: 419A00C0  beq cr6, 0x825e6d80
	if ctx.cr[6].eq {
	pc = 0x825E6D80; continue 'dispatch;
	}
	// 825E6CC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E6CC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E6CCC: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 825E6CD0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E6CD4: 4880B715  bl 0x82df23e8
	ctx.lr = 0x825E6CD8;
	sub_82DF23E8(ctx, base);
	// 825E6CD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E6CDC: 41820014  beq 0x825e6cf0
	if ctx.cr[0].eq {
	pc = 0x825E6CF0; continue 'dispatch;
	}
	// 825E6CE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E6CE4: 4882FBAD  bl 0x82e16890
	ctx.lr = 0x825E6CE8;
	sub_82E16890(ctx, base);
	// 825E6CE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E6CEC: 48000008  b 0x825e6cf4
	pc = 0x825E6CF4; continue 'dispatch;
	// 825E6CF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825E6CF4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825E6CF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E6CFC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E6D00: 4BD723B9  bl 0x823590b8
	ctx.lr = 0x825E6D04;
	sub_823590B8(ctx, base);
	// 825E6D04: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E6D08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E6D0C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E6D10: 4BCD92F1  bl 0x822c0000
	ctx.lr = 0x825E6D14;
	sub_822C0000(ctx, base);
	// 825E6D14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E6D18: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E6D20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E6D24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E6D28: 419A0024  beq cr6, 0x825e6d4c
	if ctx.cr[6].eq {
	pc = 0x825E6D4C; continue 'dispatch;
	}
	// 825E6D2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E6D30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E6D34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6D38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E6D3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E6D40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E6D44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E6D48: 4082FFE8  bne 0x825e6d30
	if !ctx.cr[0].eq {
	pc = 0x825E6D30; continue 'dispatch;
	}
	// 825E6D4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E6D50: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E6D54: 4882E35D  bl 0x82e150b0
	ctx.lr = 0x825E6D58;
	sub_82E150B0(ctx, base);
	// 825E6D58: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E6D5C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E6D60: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E6D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E6D68: 808B7070  lwz r4, 0x7070(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28784 as u32) ) } as u64;
	// 825E6D6C: 4BF29DED  bl 0x82510b58
	ctx.lr = 0x825E6D70;
	sub_82510B58(ctx, base);
	// 825E6D70: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E6D74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6D78: 419A0008  beq cr6, 0x825e6d80
	if ctx.cr[6].eq {
	pc = 0x825E6D80; continue 'dispatch;
	}
	// 825E6D7C: 4BCD9B15  bl 0x822c0890
	ctx.lr = 0x825E6D80;
	sub_822C0890(ctx, base);
	// 825E6D80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E6D84: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E6D88: 4BF285A9  bl 0x8250f330
	ctx.lr = 0x825E6D8C;
	sub_8250F330(ctx, base);
	// 825E6D8C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E6D90: 4BF02AC1  bl 0x824e9850
	ctx.lr = 0x825E6D94;
	sub_824E9850(ctx, base);
	// 825E6D94: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E6D98: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825E6D9C: 4880AEF5  bl 0x82df1c90
	ctx.lr = 0x825E6DA0;
	sub_82DF1C90(ctx, base);
	// 825E6DA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E6DA4: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6DA8: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 825E6DAC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825E6DB0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825E6DB4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825E6DB8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6DBC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825E6DC0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825E6DC4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825E6DC8: C1A99450  lfs f13, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E6DCC: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E6DD0: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 825E6DD4: EC206378  fmsubs f1, f0, f13, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 825E6DD8: 48895C71  bl 0x82e7ca48
	ctx.lr = 0x825E6DDC;
	sub_82E7CA48(ctx, base);
	// 825E6DDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E6DE0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825E6DE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E6DE8: 48894EE1  bl 0x82e7bcc8
	ctx.lr = 0x825E6DEC;
	sub_82E7BCC8(ctx, base);
	// 825E6DEC: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825E6DF0: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 825E6DF4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E6DF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E6DFC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E6E20 size=240
    let mut pc: u32 = 0x825E6E20;
    'dispatch: loop {
        match pc {
            0x825E6E20 => {
    //   block [0x825E6E20..0x825E6F10)
	// 825E6E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E6E28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E6E2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E6E30: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6F10 size=172
    let mut pc: u32 = 0x825E6F10;
    'dispatch: loop {
        match pc {
            0x825E6F10 => {
    //   block [0x825E6F10..0x825E6FBC)
	// 825E6F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E6F18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E6F1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E6F20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6F24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E6F28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E6F2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E6F30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E6F34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E6F38: 4BCD9A01  bl 0x822c0938
	ctx.lr = 0x825E6F3C;
	sub_822C0938(ctx, base);
	// 825E6F3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E6F40: 41820028  beq 0x825e6f68
	if ctx.cr[0].eq {
	pc = 0x825E6F68; continue 'dispatch;
	}
	// 825E6F44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6F48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E6F4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E6F50: 392BFA10  addi r9, r11, -0x5f0
	ctx.r[9].s64 = ctx.r[11].s64 + -1520;
	// 825E6F54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E6F58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E6F5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E6F60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E6F64: 48000008  b 0x825e6f6c
	pc = 0x825E6F6C; continue 'dispatch;
	// 825E6F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E6F6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E6F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E6F74: 409A002C  bne cr6, 0x825e6fa0
	if !ctx.cr[6].eq {
	pc = 0x825E6FA0; continue 'dispatch;
	}
	// 825E6F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E6F7C: 4880B45D  bl 0x82df23d8
	ctx.lr = 0x825E6F80;
	sub_82DF23D8(ctx, base);
	// 825E6F80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E6F84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E6F88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E6F8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E6F90: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E6F94: 816BDCFC  lwz r11, -0x2304(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8964 as u32) ) } as u64;
	// 825E6F98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E6F9C: 4BCD9065  bl 0x822c0000
	ctx.lr = 0x825E6FA0;
	sub_822C0000(ctx, base);
	// 825E6FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E6FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E6FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E6FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E6FB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E6FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E6FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E6FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E6FC0 size=196
    let mut pc: u32 = 0x825E6FC0;
    'dispatch: loop {
        match pc {
            0x825E6FC0 => {
    //   block [0x825E6FC0..0x825E7084)
	// 825E6FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E6FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E6FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E6FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E6FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E6FD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E6FD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E6FDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E6FE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E6FE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E6FE8: 4BCD9951  bl 0x822c0938
	ctx.lr = 0x825E6FEC;
	sub_822C0938(ctx, base);
	// 825E6FEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E6FF0: 41820028  beq 0x825e7018
	if ctx.cr[0].eq {
	pc = 0x825E7018; continue 'dispatch;
	}
	// 825E6FF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E6FF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E6FFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E7000: 392BFA24  addi r9, r11, -0x5dc
	ctx.r[9].s64 = ctx.r[11].s64 + -1500;
	// 825E7004: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E7008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E700C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E7010: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E7014: 48000008  b 0x825e701c
	pc = 0x825E701C; continue 'dispatch;
	// 825E7018: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E701C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E7020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7024: 409A0044  bne cr6, 0x825e7068
	if !ctx.cr[6].eq {
	pc = 0x825E7068; continue 'dispatch;
	}
	// 825E7028: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E702C: 419A001C  beq cr6, 0x825e7048
	if ctx.cr[6].eq {
	pc = 0x825E7048; continue 'dispatch;
	}
	// 825E7030: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7034: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E7038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E703C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E7044: 4E800421  bctrl
	ctx.lr = 0x825E7048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E7048: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E704C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E7050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7054: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E7058: 816BDCFC  lwz r11, -0x2304(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8964 as u32) ) } as u64;
	// 825E705C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E7060: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E7064: 4BCD8F9D  bl 0x822c0000
	ctx.lr = 0x825E7068;
	sub_822C0000(ctx, base);
	// 825E7068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E706C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E7070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E7074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E7078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E707C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E7080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E7088 size=172
    let mut pc: u32 = 0x825E7088;
    'dispatch: loop {
        match pc {
            0x825E7088 => {
    //   block [0x825E7088..0x825E7134)
	// 825E7088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E708C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E7090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E7094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E7098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E709C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E70A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E70A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E70A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E70AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E70B0: 4BCD9889  bl 0x822c0938
	ctx.lr = 0x825E70B4;
	sub_822C0938(ctx, base);
	// 825E70B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E70B8: 41820028  beq 0x825e70e0
	if ctx.cr[0].eq {
	pc = 0x825E70E0; continue 'dispatch;
	}
	// 825E70BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E70C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E70C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E70C8: 392BFA38  addi r9, r11, -0x5c8
	ctx.r[9].s64 = ctx.r[11].s64 + -1480;
	// 825E70CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E70D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E70D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E70D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E70DC: 48000008  b 0x825e70e4
	pc = 0x825E70E4; continue 'dispatch;
	// 825E70E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E70E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E70E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E70EC: 409A002C  bne cr6, 0x825e7118
	if !ctx.cr[6].eq {
	pc = 0x825E7118; continue 'dispatch;
	}
	// 825E70F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E70F4: 4880B2E5  bl 0x82df23d8
	ctx.lr = 0x825E70F8;
	sub_82DF23D8(ctx, base);
	// 825E70F8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E70FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E7100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7104: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E7108: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E710C: 816BDCFC  lwz r11, -0x2304(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8964 as u32) ) } as u64;
	// 825E7110: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E7114: 4BCD8EED  bl 0x822c0000
	ctx.lr = 0x825E7118;
	sub_822C0000(ctx, base);
	// 825E7118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E711C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E7120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E7124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E7128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E712C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E7130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E7138 size=172
    let mut pc: u32 = 0x825E7138;
    'dispatch: loop {
        match pc {
            0x825E7138 => {
    //   block [0x825E7138..0x825E71E4)
	// 825E7138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E713C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E7140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E7144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E7148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E714C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E7150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E7154: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E7158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E715C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E7160: 4BCD97D9  bl 0x822c0938
	ctx.lr = 0x825E7164;
	sub_822C0938(ctx, base);
	// 825E7164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E7168: 41820028  beq 0x825e7190
	if ctx.cr[0].eq {
	pc = 0x825E7190; continue 'dispatch;
	}
	// 825E716C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E7170: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E7174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E7178: 392BFA4C  addi r9, r11, -0x5b4
	ctx.r[9].s64 = ctx.r[11].s64 + -1460;
	// 825E717C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E7180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E7184: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E7188: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E718C: 48000008  b 0x825e7194
	pc = 0x825E7194; continue 'dispatch;
	// 825E7190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E7194: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E7198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E719C: 409A002C  bne cr6, 0x825e71c8
	if !ctx.cr[6].eq {
	pc = 0x825E71C8; continue 'dispatch;
	}
	// 825E71A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E71A4: 4880B235  bl 0x82df23d8
	ctx.lr = 0x825E71A8;
	sub_82DF23D8(ctx, base);
	// 825E71A8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E71AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E71B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E71B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E71B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E71BC: 816BDCFC  lwz r11, -0x2304(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8964 as u32) ) } as u64;
	// 825E71C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E71C4: 4BCD8E3D  bl 0x822c0000
	ctx.lr = 0x825E71C8;
	sub_822C0000(ctx, base);
	// 825E71C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E71CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E71D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E71D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E71D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E71DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E71E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E71E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E71E8 size=196
    let mut pc: u32 = 0x825E71E8;
    'dispatch: loop {
        match pc {
            0x825E71E8 => {
    //   block [0x825E71E8..0x825E72AC)
	// 825E71E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E71EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E71F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E71F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E71F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E71FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E7200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E7204: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E7208: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E720C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E7210: 4BCD9729  bl 0x822c0938
	ctx.lr = 0x825E7214;
	sub_822C0938(ctx, base);
	// 825E7214: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E7218: 41820028  beq 0x825e7240
	if ctx.cr[0].eq {
	pc = 0x825E7240; continue 'dispatch;
	}
	// 825E721C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E7220: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E7224: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E7228: 392BFA60  addi r9, r11, -0x5a0
	ctx.r[9].s64 = ctx.r[11].s64 + -1440;
	// 825E722C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E7230: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E7234: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E7238: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E723C: 48000008  b 0x825e7244
	pc = 0x825E7244; continue 'dispatch;
	// 825E7240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E7244: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E7248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E724C: 409A0044  bne cr6, 0x825e7290
	if !ctx.cr[6].eq {
	pc = 0x825E7290; continue 'dispatch;
	}
	// 825E7250: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E7254: 419A001C  beq cr6, 0x825e7270
	if ctx.cr[6].eq {
	pc = 0x825E7270; continue 'dispatch;
	}
	// 825E7258: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E725C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E7260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7264: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E726C: 4E800421  bctrl
	ctx.lr = 0x825E7270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E7270: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E7274: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E7278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E727C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E7280: 816BDCFC  lwz r11, -0x2304(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8964 as u32) ) } as u64;
	// 825E7284: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E7288: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E728C: 4BCD8D75  bl 0x822c0000
	ctx.lr = 0x825E7290;
	sub_822C0000(ctx, base);
	// 825E7290: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E7298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E729C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E72A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E72A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E72A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E72B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E72B0 size=216
    let mut pc: u32 = 0x825E72B0;
    'dispatch: loop {
        match pc {
            0x825E72B0 => {
    //   block [0x825E72B0..0x825E7388)
	// 825E72B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E72B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E72B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E72BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E72C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E72C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E72C8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825E72CC: 4BF2AF95  bl 0x82512260
	ctx.lr = 0x825E72D0;
	sub_82512260(ctx, base);
	// 825E72D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E72D4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E72D8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825E72DC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E72E0: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E72E4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E72E8: 394AFAD4  addi r10, r10, -0x52c
	ctx.r[10].s64 = ctx.r[10].s64 + -1324;
	// 825E72EC: 3929FAC0  addi r9, r9, -0x540
	ctx.r[9].s64 = ctx.r[9].s64 + -1344;
	// 825E72F0: 3908FA74  addi r8, r8, -0x58c
	ctx.r[8].s64 = ctx.r[8].s64 + -1420;
	// 825E72F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E72F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E72FC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E7300: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825E7304: 395F00F8  addi r10, r31, 0xf8
	ctx.r[10].s64 = ctx.r[31].s64 + 248;
	// 825E7308: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825E730C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825E7310: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825E7314: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825E7318: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E731C: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 825E7320: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E7324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E7328: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 825E732C: 419A0024  beq cr6, 0x825e7350
	if ctx.cr[6].eq {
	pc = 0x825E7350; continue 'dispatch;
	}
	// 825E7330: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825E7334: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E7338: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E733C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E7340: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E7344: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E7348: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E734C: 4082FFE8  bne 0x825e7334
	if !ctx.cr[0].eq {
	pc = 0x825E7334; continue 'dispatch;
	}
	// 825E7350: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 825E7354: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E7358: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E735C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7360: C00AD5B8  lfs f0, -0x2a48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E7364: C1ABDD6C  lfs f13, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E7368: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 825E736C: D1BF0108  stfs f13, 0x108(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 825E7370: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E7374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E7378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E737C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E7380: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E7384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E7388 size=8
    let mut pc: u32 = 0x825E7388;
    'dispatch: loop {
        match pc {
            0x825E7388 => {
    //   block [0x825E7388..0x825E7390)
	// 825E7388: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E738C: 48000104  b 0x825e7490
	sub_825E7490(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E7390 size=8
    let mut pc: u32 = 0x825E7390;
    'dispatch: loop {
        match pc {
            0x825E7390 => {
    //   block [0x825E7390..0x825E7398)
	// 825E7390: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825E7394: 480000FC  b 0x825e7490
	sub_825E7490(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E7398 size=248
    let mut pc: u32 = 0x825E7398;
    'dispatch: loop {
        match pc {
            0x825E7398 => {
    //   block [0x825E7398..0x825E7490)
	// 825E7398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E739C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E73A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E73A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E73A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E73AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E73B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E73B4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E73B8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E73BC: 396BFAD4  addi r11, r11, -0x52c
	ctx.r[11].s64 = ctx.r[11].s64 + -1324;
	// 825E73C0: 394AFAC0  addi r10, r10, -0x540
	ctx.r[10].s64 = ctx.r[10].s64 + -1344;
	// 825E73C4: 3929FA74  addi r9, r9, -0x58c
	ctx.r[9].s64 = ctx.r[9].s64 + -1420;
	// 825E73C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E73CC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E73D0: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825E73D4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825E73D8: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E73DC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E73E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E73E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E73E8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E73EC: 419A0024  beq cr6, 0x825e7410
	if ctx.cr[6].eq {
	pc = 0x825E7410; continue 'dispatch;
	}
	// 825E73F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E73F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E73F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E73FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E7400: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E7404: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E7408: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E740C: 4082FFE8  bne 0x825e73f4
	if !ctx.cr[0].eq {
	pc = 0x825E73F4; continue 'dispatch;
	}
	// 825E7410: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E7414: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E7418: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E741C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7420: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E7424: 4BF28C9D  bl 0x825100c0
	ctx.lr = 0x825E7428;
	sub_825100C0(ctx, base);
	// 825E7428: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E742C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7430: 419A0008  beq cr6, 0x825e7438
	if ctx.cr[6].eq {
	pc = 0x825E7438; continue 'dispatch;
	}
	// 825E7434: 4BCD945D  bl 0x822c0890
	ctx.lr = 0x825E7438;
	sub_822C0890(ctx, base);
	// 825E7438: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825E743C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7440: 419A0008  beq cr6, 0x825e7448
	if ctx.cr[6].eq {
	pc = 0x825E7448; continue 'dispatch;
	}
	// 825E7444: 4BCD944D  bl 0x822c0890
	ctx.lr = 0x825E7448;
	sub_822C0890(ctx, base);
	// 825E7448: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E744C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7450: 419A0008  beq cr6, 0x825e7458
	if ctx.cr[6].eq {
	pc = 0x825E7458; continue 'dispatch;
	}
	// 825E7454: 4BCD943D  bl 0x822c0890
	ctx.lr = 0x825E7458;
	sub_822C0890(ctx, base);
	// 825E7458: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E745C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7460: 419A0008  beq cr6, 0x825e7468
	if ctx.cr[6].eq {
	pc = 0x825E7468; continue 'dispatch;
	}
	// 825E7464: 4BCD942D  bl 0x822c0890
	ctx.lr = 0x825E7468;
	sub_822C0890(ctx, base);
	// 825E7468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E746C: 481C01ED  bl 0x827a7658
	ctx.lr = 0x825E7470;
	sub_827A7658(ctx, base);
	// 825E7470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7474: 4BD67EDD  bl 0x8234f350
	ctx.lr = 0x825E7478;
	sub_8234F350(ctx, base);
	// 825E7478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E747C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E7480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E7484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E7488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E748C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E7490 size=76
    let mut pc: u32 = 0x825E7490;
    'dispatch: loop {
        match pc {
            0x825E7490 => {
    //   block [0x825E7490..0x825E74DC)
	// 825E7490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E7494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E7498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E749C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E74A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E74A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E74A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E74AC: 4BFFFEED  bl 0x825e7398
	ctx.lr = 0x825E74B0;
	sub_825E7398(ctx, base);
	// 825E74B0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E74B4: 4182000C  beq 0x825e74c0
	if ctx.cr[0].eq {
	pc = 0x825E74C0; continue 'dispatch;
	}
	// 825E74B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E74BC: 4880AF1D  bl 0x82df23d8
	ctx.lr = 0x825E74C0;
	sub_82DF23D8(ctx, base);
	// 825E74C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E74C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E74C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E74CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E74D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E74D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E74D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E74E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E74E0 size=332
    let mut pc: u32 = 0x825E74E0;
    'dispatch: loop {
        match pc {
            0x825E74E0 => {
    //   block [0x825E74E0..0x825E762C)
	// 825E74E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E74E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E74E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E74EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E74F0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825E74F4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825E74F8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E74FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825E7500: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E7504: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E7508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E750C: 388BCACC  addi r4, r11, -0x3534
	ctx.r[4].s64 = ctx.r[11].s64 + -13620;
	// 825E7510: 4880C4F9  bl 0x82df3a08
	ctx.lr = 0x825E7514;
	sub_82DF3A08(ctx, base);
	// 825E7514: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E7518: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E751C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E7520: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825E7524: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E7528: C3EA9F64  lfs f31, -0x609c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E752C: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825E7530: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825E7534: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E7538: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825E753C: 4BFBBC75  bl 0x825a31b0
	ctx.lr = 0x825E7540;
	sub_825A31B0(ctx, base);
	// 825E7540: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E7544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7548: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E754C: 4BFBA225  bl 0x825a1770
	ctx.lr = 0x825E7550;
	sub_825A1770(ctx, base);
	// 825E7550: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825E7554: 4880BED5  bl 0x82df3428
	ctx.lr = 0x825E7558;
	sub_82DF3428(ctx, base);
	// 825E7558: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E755C: 4BCE175D  bl 0x822c8cb8
	ctx.lr = 0x825E7560;
	sub_822C8CB8(ctx, base);
	// 825E7560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7564: 4880BEC5  bl 0x82df3428
	ctx.lr = 0x825E7568;
	sub_82DF3428(ctx, base);
	// 825E7568: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825E756C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7570: 388B8FF4  addi r4, r11, -0x700c
	ctx.r[4].s64 = ctx.r[11].s64 + -28684;
	// 825E7574: 4880C495  bl 0x82df3a08
	ctx.lr = 0x825E7578;
	sub_82DF3A08(ctx, base);
	// 825E7578: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825E757C: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 825E7580: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825E7584: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E7588: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825E758C: C06B89AC  lfs f3, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E7590: 4BFBBC21  bl 0x825a31b0
	ctx.lr = 0x825E7594;
	sub_825A31B0(ctx, base);
	// 825E7594: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E7598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E759C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E75A0: 4BFBA1D1  bl 0x825a1770
	ctx.lr = 0x825E75A4;
	sub_825A1770(ctx, base);
	// 825E75A4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825E75A8: 4880BE81  bl 0x82df3428
	ctx.lr = 0x825E75AC;
	sub_82DF3428(ctx, base);
	// 825E75AC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825E75B0: 4BCE1709  bl 0x822c8cb8
	ctx.lr = 0x825E75B4;
	sub_822C8CB8(ctx, base);
	// 825E75B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E75B8: 4880BE71  bl 0x82df3428
	ctx.lr = 0x825E75BC;
	sub_82DF3428(ctx, base);
	// 825E75BC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825E75C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E75C4: 388B5EA0  addi r4, r11, 0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + 24224;
	// 825E75C8: 4880C441  bl 0x82df3a08
	ctx.lr = 0x825E75CC;
	sub_82DF3A08(ctx, base);
	// 825E75CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825E75D0: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 825E75D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825E75D8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825E75DC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825E75E0: 4BFBBDC9  bl 0x825a33a8
	ctx.lr = 0x825E75E4;
	sub_825A33A8(ctx, base);
	// 825E75E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E75E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E75EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E75F0: 4BFBA671  bl 0x825a1c60
	ctx.lr = 0x825E75F4;
	sub_825A1C60(ctx, base);
	// 825E75F4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825E75F8: 4880BE31  bl 0x82df3428
	ctx.lr = 0x825E75FC;
	sub_82DF3428(ctx, base);
	// 825E75FC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825E7600: 4BCE16B9  bl 0x822c8cb8
	ctx.lr = 0x825E7604;
	sub_822C8CB8(ctx, base);
	// 825E7604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7608: 4880BE21  bl 0x82df3428
	ctx.lr = 0x825E760C;
	sub_82DF3428(ctx, base);
	// 825E760C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825E7610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E7614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E7618: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825E761C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825E7620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E7624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E7628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E7630 size=120
    let mut pc: u32 = 0x825E7630;
    'dispatch: loop {
        match pc {
            0x825E7630 => {
    //   block [0x825E7630..0x825E76A8)
	// 825E7630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E7634: 48BC0B39  bl 0x831a816c
	ctx.lr = 0x825E7638;
	sub_831A8130(ctx, base);
	// 825E7638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E763C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E7640: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E7644: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E7648: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E764C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825E7650: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825E7654: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825E7658: 4880AD91  bl 0x82df23e8
	ctx.lr = 0x825E765C;
	sub_82DF23E8(ctx, base);
	// 825E765C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E7660: 41820014  beq 0x825e7674
	if ctx.cr[0].eq {
	pc = 0x825E7674; continue 'dispatch;
	}
	// 825E7664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7668: 4856ABF9  bl 0x82b52260
	ctx.lr = 0x825E766C;
	sub_82B52260(ctx, base);
	// 825E766C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E7670: 48000008  b 0x825e7678
	pc = 0x825E7678; continue 'dispatch;
	// 825E7674: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E7678: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E767C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825E7680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7688: 4BFFFB61  bl 0x825e71e8
	ctx.lr = 0x825E768C;
	sub_825E71E8(ctx, base);
	// 825E768C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E7690: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7698: 4BCD8969  bl 0x822c0000
	ctx.lr = 0x825E769C;
	sub_822C0000(ctx, base);
	// 825E769C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E76A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E76A4: 48BC0B18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E76A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E76A8 size=800
    let mut pc: u32 = 0x825E76A8;
    'dispatch: loop {
        match pc {
            0x825E76A8 => {
    //   block [0x825E76A8..0x825E79C8)
	// 825E76A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E76AC: 48BC0ABD  bl 0x831a8168
	ctx.lr = 0x825E76B0;
	sub_831A8130(ctx, base);
	// 825E76B0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825E76B4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825E76B8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E76BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E76C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E76C4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825E76C8: 4BF2A311  bl 0x825119d8
	ctx.lr = 0x825E76CC;
	sub_825119D8(ctx, base);
	// 825E76CC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E76D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E76D4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825E76D8: 4880C331  bl 0x82df3a08
	ctx.lr = 0x825E76DC;
	sub_82DF3A08(ctx, base);
	// 825E76DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E76E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E76E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E76E8: 4BF21099  bl 0x82508780
	ctx.lr = 0x825E76EC;
	sub_82508780(ctx, base);
	// 825E76EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E76F0: 4880BD39  bl 0x82df3428
	ctx.lr = 0x825E76F4;
	sub_82DF3428(ctx, base);
	// 825E76F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E76F8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825E76FC: 409A0008  bne cr6, 0x825e7704
	if !ctx.cr[6].eq {
	pc = 0x825E7704; continue 'dispatch;
	}
	// 825E7700: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E7704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7708: 4BF21099  bl 0x825087a0
	ctx.lr = 0x825E770C;
	sub_825087A0(ctx, base);
	// 825E770C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E7710: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7714: 488433D5  bl 0x82e2aae8
	ctx.lr = 0x825E7718;
	sub_82E2AAE8(ctx, base);
	// 825E7718: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E771C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7720: 388BFB68  addi r4, r11, -0x498
	ctx.r[4].s64 = ctx.r[11].s64 + -1176;
	// 825E7724: 4880C2E5  bl 0x82df3a08
	ctx.lr = 0x825E7728;
	sub_82DF3A08(ctx, base);
	// 825E7728: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E772C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E7730: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825E7734: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E7738: 48847739  bl 0x82e2ee70
	ctx.lr = 0x825E773C;
	sub_82E2EE70(ctx, base);
	// 825E773C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7740: 4880BCE9  bl 0x82df3428
	ctx.lr = 0x825E7744;
	sub_82DF3428(ctx, base);
	// 825E7744: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E7748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E774C: 388BFB20  addi r4, r11, -0x4e0
	ctx.r[4].s64 = ctx.r[11].s64 + -1248;
	// 825E7750: 38A0007B  li r5, 0x7b
	ctx.r[5].s64 = 123;
	// 825E7754: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825E7758: 4880AC91  bl 0x82df23e8
	ctx.lr = 0x825E775C;
	sub_82DF23E8(ctx, base);
	// 825E775C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E7760: 41820014  beq 0x825e7774
	if ctx.cr[0].eq {
	pc = 0x825E7774; continue 'dispatch;
	}
	// 825E7764: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825E7768: 4882F129  bl 0x82e16890
	ctx.lr = 0x825E776C;
	sub_82E16890(ctx, base);
	// 825E776C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7770: 48000008  b 0x825e7778
	pc = 0x825E7778; continue 'dispatch;
	// 825E7774: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E7778: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 825E777C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E7780: 4BD75BF1  bl 0x8235d370
	ctx.lr = 0x825E7784;
	sub_8235D370(ctx, base);
	// 825E7784: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E7788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E778C: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E7790: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825E7794: 4BF2A605  bl 0x82511d98
	ctx.lr = 0x825E7798;
	sub_82511D98(ctx, base);
	// 825E7798: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E779C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E77A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E77A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E77A8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E77AC: 4BF293AD  bl 0x82510b58
	ctx.lr = 0x825E77B0;
	sub_82510B58(ctx, base);
	// 825E77B0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E77B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E77B8: 419A0008  beq cr6, 0x825e77c0
	if ctx.cr[6].eq {
	pc = 0x825E77C0; continue 'dispatch;
	}
	// 825E77BC: 4BCD90D5  bl 0x822c0890
	ctx.lr = 0x825E77C0;
	sub_822C0890(ctx, base);
	// 825E77C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E77C4: 4884333D  bl 0x82e2ab00
	ctx.lr = 0x825E77C8;
	sub_82E2AB00(ctx, base);
	// 825E77C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E77CC: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E77D0: 4BCFFA39  bl 0x822e7208
	ctx.lr = 0x825E77D4;
	sub_822E7208(ctx, base);
	// 825E77D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E77D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E77DC: 3BCBFB10  addi r30, r11, -0x4f0
	ctx.r[30].s64 = ctx.r[11].s64 + -1264;
	// 825E77E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E77E4: 4880C225  bl 0x82df3a08
	ctx.lr = 0x825E77E8;
	sub_82DF3A08(ctx, base);
	// 825E77E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E77EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E77F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825E77F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E77F8: 4BCFFB99  bl 0x822e7390
	ctx.lr = 0x825E77FC;
	sub_822E7390(ctx, base);
	// 825E77FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7800: 4880BC29  bl 0x82df3428
	ctx.lr = 0x825E7804;
	sub_82DF3428(ctx, base);
	// 825E7804: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E7808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E780C: 4880C1FD  bl 0x82df3a08
	ctx.lr = 0x825E7810;
	sub_82DF3A08(ctx, base);
	// 825E7810: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 825E7814: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E7818: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E781C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E7820: 4BD06EB9  bl 0x822ee6d8
	ctx.lr = 0x825E7824;
	sub_822EE6D8(ctx, base);
	// 825E7824: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E7828: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 825E782C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825E7830: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825E7834: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7838: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825E783C: 4BCDCC25  bl 0x822c4460
	ctx.lr = 0x825E7840;
	sub_822C4460(ctx, base);
	// 825E7840: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825E7844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7848: 419A0008  beq cr6, 0x825e7850
	if ctx.cr[6].eq {
	pc = 0x825E7850; continue 'dispatch;
	}
	// 825E784C: 4BCD9045  bl 0x822c0890
	ctx.lr = 0x825E7850;
	sub_822C0890(ctx, base);
	// 825E7850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7854: 4880BBD5  bl 0x82df3428
	ctx.lr = 0x825E7858;
	sub_82DF3428(ctx, base);
	// 825E7858: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E785C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7860: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E7864: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825E7868: 4BD060B9  bl 0x822ed920
	ctx.lr = 0x825E786C;
	sub_822ED920(ctx, base);
	// 825E786C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E7870: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7874: 808B674C  lwz r4, 0x674c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 825E7878: 4BEA7B29  bl 0x8248f3a0
	ctx.lr = 0x825E787C;
	sub_8248F3A0(ctx, base);
	// 825E787C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 825E7880: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7884: 808B8610  lwz r4, -0x79f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31216 as u32) ) } as u64;
	// 825E7888: 4BD055B9  bl 0x822ece40
	ctx.lr = 0x825E788C;
	sub_822ECE40(ctx, base);
	// 825E788C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E7890: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7894: 4BD061A5  bl 0x822eda38
	ctx.lr = 0x825E7898;
	sub_822EDA38(ctx, base);
	// 825E7898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E789C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E78A0: 4BF294A1  bl 0x82510d40
	ctx.lr = 0x825E78A4;
	sub_82510D40(ctx, base);
	// 825E78A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E78A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E78AC: 419A0008  beq cr6, 0x825e78b4
	if ctx.cr[6].eq {
	pc = 0x825E78B4; continue 'dispatch;
	}
	// 825E78B0: 4BCD8FE1  bl 0x822c0890
	ctx.lr = 0x825E78B4;
	sub_822C0890(ctx, base);
	// 825E78B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E78B8: 4BCFF969  bl 0x822e7220
	ctx.lr = 0x825E78BC;
	sub_822E7220(ctx, base);
	// 825E78BC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825E78C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E78C4: 4BF2A4D5  bl 0x82511d98
	ctx.lr = 0x825E78C8;
	sub_82511D98(ctx, base);
	// 825E78C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E78CC: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 825E78D0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825E78D4: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E78D8: 409A0024  bne cr6, 0x825e78fc
	if !ctx.cr[6].eq {
	pc = 0x825E78FC; continue 'dispatch;
	}
	// 825E78DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E78E0: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825E78E4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825E78E8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E78EC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825E78F0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E78F4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825E78F8: 4800003C  b 0x825e7934
	pc = 0x825E7934; continue 'dispatch;
	// 825E78FC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825E7900: 409A0048  bne cr6, 0x825e7948
	if !ctx.cr[6].eq {
	pc = 0x825E7948; continue 'dispatch;
	}
	// 825E7904: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E7908: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825E790C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E7910: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E7914: C3CB08A8  lfs f30, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825E7918: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825E791C: 48894E65  bl 0x82e7c780
	ctx.lr = 0x825E7920;
	sub_82E7C780(ctx, base);
	// 825E7920: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825E7924: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825E7928: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825E792C: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825E7930: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825E7934: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E7938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E793C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825E7940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E7944: 4E800421  bctrl
	ctx.lr = 0x825E7948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E7948: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E794C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7950: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825E7954: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E7958: 4E800421  bctrl
	ctx.lr = 0x825E795C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E795C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E7960: 4182001C  beq 0x825e797c
	if ctx.cr[0].eq {
	pc = 0x825E797C; continue 'dispatch;
	}
	// 825E7964: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825E7968: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825E796C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825E7970: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E7974: C04B2514  lfs f2, 0x2514(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9492 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E7978: 48894E09  bl 0x82e7c780
	ctx.lr = 0x825E797C;
	sub_82E7C780(ctx, base);
	// 825E797C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825E7980: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E7984: 481B0D25  bl 0x827986a8
	ctx.lr = 0x825E7988;
	sub_827986A8(ctx, base);
	// 825E7988: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E798C: C03F0104  lfs f1, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E7990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7994: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E7998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E799C: 4E800421  bctrl
	ctx.lr = 0x825E79A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E79A0: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E79A4: C03F0108  lfs f1, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E79A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E79AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E79B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E79B4: 4E800421  bctrl
	ctx.lr = 0x825E79B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E79B8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825E79BC: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825E79C0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825E79C4: 48BC07F4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E79C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E79C8 size=568
    let mut pc: u32 = 0x825E79C8;
    'dispatch: loop {
        match pc {
            0x825E79C8 => {
    //   block [0x825E79C8..0x825E7C00)
	// 825E79C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E79CC: 48BC0799  bl 0x831a8164
	ctx.lr = 0x825E79D0;
	sub_831A8130(ctx, base);
	// 825E79D0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E79D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E79D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825E79DC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E79E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E79E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E79E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E79EC: 4E800421  bctrl
	ctx.lr = 0x825E79F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E79F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E79F4: 40820204  bne 0x825e7bf8
	if !ctx.cr[0].eq {
	pc = 0x825E7BF8; continue 'dispatch;
	}
	// 825E79F8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825E79FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E7A00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E7A04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E7A08: 4BD357C9  bl 0x8231d1d0
	ctx.lr = 0x825E7A0C;
	sub_8231D1D0(ctx, base);
	// 825E7A0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7A10: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E7A14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E7A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7A1C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825E7A20: 419A0024  beq cr6, 0x825e7a44
	if ctx.cr[6].eq {
	pc = 0x825E7A44; continue 'dispatch;
	}
	// 825E7A24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E7A28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E7A2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E7A30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E7A34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E7A38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E7A3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E7A40: 4082FFE8  bne 0x825e7a28
	if !ctx.cr[0].eq {
	pc = 0x825E7A28; continue 'dispatch;
	}
	// 825E7A44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7A48: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E7A4C: 4BF27A7D  bl 0x8250f4c8
	ctx.lr = 0x825E7A50;
	sub_8250F4C8(ctx, base);
	// 825E7A50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7A58: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E7A5C: 409A0008  bne cr6, 0x825e7a64
	if !ctx.cr[6].eq {
	pc = 0x825E7A64; continue 'dispatch;
	}
	// 825E7A60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E7A64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E7A68: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 825E7A6C: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825E7A70: 4BF20FA9  bl 0x82508a18
	ctx.lr = 0x825E7A74;
	sub_82508A18(ctx, base);
	// 825E7A74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E7A78: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E7A7C: 3BABFB20  addi r29, r11, -0x4e0
	ctx.r[29].s64 = ctx.r[11].s64 + -1248;
	// 825E7A80: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 825E7A84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E7A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7A8C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825E7A90: 4886F559  bl 0x82e56fe8
	ctx.lr = 0x825E7A94;
	sub_82E56FE8(ctx, base);
	// 825E7A94: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E7A98: 4880A1F9  bl 0x82df1c90
	ctx.lr = 0x825E7A9C;
	sub_82DF1C90(ctx, base);
	// 825E7A9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E7AA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7AA4: 419A0008  beq cr6, 0x825e7aac
	if ctx.cr[6].eq {
	pc = 0x825E7AAC; continue 'dispatch;
	}
	// 825E7AA8: 4BCD8DE9  bl 0x822c0890
	ctx.lr = 0x825E7AAC;
	sub_822C0890(ctx, base);
	// 825E7AAC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825E7AB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7AB4: 419A0008  beq cr6, 0x825e7abc
	if ctx.cr[6].eq {
	pc = 0x825E7ABC; continue 'dispatch;
	}
	// 825E7AB8: 4BCD8DD9  bl 0x822c0890
	ctx.lr = 0x825E7ABC;
	sub_822C0890(ctx, base);
	// 825E7ABC: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 825E7AC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E7AC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E7AC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E7ACC: 4BDB77BD  bl 0x8239f288
	ctx.lr = 0x825E7AD0;
	sub_8239F288(ctx, base);
	// 825E7AD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7AD4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E7AD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E7ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7AE0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825E7AE4: 419A0024  beq cr6, 0x825e7b08
	if ctx.cr[6].eq {
	pc = 0x825E7B08; continue 'dispatch;
	}
	// 825E7AE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E7AEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E7AF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E7AF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E7AF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E7AFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E7B00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E7B04: 4082FFE8  bne 0x825e7aec
	if !ctx.cr[0].eq {
	pc = 0x825E7AEC; continue 'dispatch;
	}
	// 825E7B08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7B0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E7B10: 4BF279B9  bl 0x8250f4c8
	ctx.lr = 0x825E7B14;
	sub_8250F4C8(ctx, base);
	// 825E7B14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7B1C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E7B20: 409A0008  bne cr6, 0x825e7b28
	if !ctx.cr[6].eq {
	pc = 0x825E7B28; continue 'dispatch;
	}
	// 825E7B24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E7B28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E7B2C: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 825E7B30: 4BF20EE9  bl 0x82508a18
	ctx.lr = 0x825E7B34;
	sub_82508A18(ctx, base);
	// 825E7B34: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E7B38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E7B3C: 38A000B7  li r5, 0xb7
	ctx.r[5].s64 = 183;
	// 825E7B40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7B44: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825E7B48: 4886F4A1  bl 0x82e56fe8
	ctx.lr = 0x825E7B4C;
	sub_82E56FE8(ctx, base);
	// 825E7B4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E7B50: 4880A141  bl 0x82df1c90
	ctx.lr = 0x825E7B54;
	sub_82DF1C90(ctx, base);
	// 825E7B54: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E7B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7B5C: 419A0008  beq cr6, 0x825e7b64
	if ctx.cr[6].eq {
	pc = 0x825E7B64; continue 'dispatch;
	}
	// 825E7B60: 4BCD8D31  bl 0x822c0890
	ctx.lr = 0x825E7B64;
	sub_822C0890(ctx, base);
	// 825E7B64: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E7B68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E7B6C: 419A0008  beq cr6, 0x825e7b74
	if ctx.cr[6].eq {
	pc = 0x825E7B74; continue 'dispatch;
	}
	// 825E7B70: 4BCD8D21  bl 0x822c0890
	ctx.lr = 0x825E7B74;
	sub_822C0890(ctx, base);
	// 825E7B74: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E7B78: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825E7B7C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825E7B80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E7B84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7B88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7B8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E7B90: 4E800421  bctrl
	ctx.lr = 0x825E7B94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E7B94: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825E7B98: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825E7B9C: 481B0B65  bl 0x82798700
	ctx.lr = 0x825E7BA0;
	sub_82798700(ctx, base);
	// 825E7BA0: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825E7BA4: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825E7BA8: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825E7BAC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825E7BB0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 825E7BB4: 80640084  lwz r3, 0x84(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E7BB8: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825E7BBC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825E7BC0: 13E85C07  vcmpneb. (lvlx128) v31, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E7BC4: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825E7BC8: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 825E7BCC: 13C93C07  vcmpneb. (lvlx128) v30, v9, v7
	tmp.u32 = ctx.r[9].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E7BD0: 13AA3407  vcmpneb. (lvlx128) v29, v10, v6
	tmp.u32 = ctx.r[10].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E7BD4: 13802C07  vcmpneb. (lvlx128) v28, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E7C00 size=660
    let mut pc: u32 = 0x825E7C00;
    'dispatch: loop {
        match pc {
            0x825E7C00 => {
    //   block [0x825E7C00..0x825E7E94)
	// 825E7C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E7C04: 48BC0565  bl 0x831a8168
	ctx.lr = 0x825E7C08;
	sub_831A8130(ctx, base);
	// 825E7C08: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E7C0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825E7C10: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 825E7C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E7C18: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 825E7C1C: 808B8610  lwz r4, -0x79f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31216 as u32) ) } as u64;
	// 825E7C20: 481D2319  bl 0x827b9f38
	ctx.lr = 0x825E7C24;
	sub_827B9F38(ctx, base);
	// 825E7C24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E7C28: 41820264  beq 0x825e7e8c
	if ctx.cr[0].eq {
	pc = 0x825E7E8C; continue 'dispatch;
	}
	// 825E7C2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7C30: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E7C34: 4BF27895  bl 0x8250f4c8
	ctx.lr = 0x825E7C38;
	sub_8250F4C8(ctx, base);
	// 825E7C38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7C40: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825E7C44: 409A0008  bne cr6, 0x825e7c4c
	if !ctx.cr[6].eq {
	pc = 0x825E7C4C; continue 'dispatch;
	}
	// 825E7C48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E7C4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825E7C50: 4BF229E9  bl 0x8250a638
	ctx.lr = 0x825E7C54;
	sub_8250A638(ctx, base);
	// 825E7C54: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E7C58: 4880A039  bl 0x82df1c90
	ctx.lr = 0x825E7C5C;
	sub_82DF1C90(ctx, base);
	// 825E7C5C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825E7C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7C64: 419A0144  beq cr6, 0x825e7da8
	if ctx.cr[6].eq {
	pc = 0x825E7DA8; continue 'dispatch;
	}
	// 825E7C68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E7C6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7C70: 388BFB94  addi r4, r11, -0x46c
	ctx.r[4].s64 = ctx.r[11].s64 + -1132;
	// 825E7C74: 4880BD95  bl 0x82df3a08
	ctx.lr = 0x825E7C78;
	sub_82DF3A08(ctx, base);
	// 825E7C78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E7C7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E7C80: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825E7C84: 481D9385  bl 0x827c1008
	ctx.lr = 0x825E7C88;
	sub_827C1008(ctx, base);
	// 825E7C88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E7C8C: 4880B79D  bl 0x82df3428
	ctx.lr = 0x825E7C90;
	sub_82DF3428(ctx, base);
	// 825E7C90: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E7C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7C98: 419A0100  beq cr6, 0x825e7d98
	if ctx.cr[6].eq {
	pc = 0x825E7D98; continue 'dispatch;
	}
	// 825E7C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7CA0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825E7CA4: 4BF29E45  bl 0x82511ae8
	ctx.lr = 0x825E7CA8;
	sub_82511AE8(ctx, base);
	// 825E7CA8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825E7CAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7CB0: 4BF29EA9  bl 0x82511b58
	ctx.lr = 0x825E7CB4;
	sub_82511B58(ctx, base);
	// 825E7CB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7CB8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825E7CBC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E7CC0: 4BD1FAB9  bl 0x82307778
	ctx.lr = 0x825E7CC4;
	sub_82307778(ctx, base);
	// 825E7CC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7CC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7CCC: 481D4005  bl 0x827bbcd0
	ctx.lr = 0x825E7CD0;
	sub_827BBCD0(ctx, base);
	// 825E7CD0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E7CD4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E7CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7CDC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E7CE0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E7CE4: 419A0024  beq cr6, 0x825e7d08
	if ctx.cr[6].eq {
	pc = 0x825E7D08; continue 'dispatch;
	}
	// 825E7CE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E7CEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E7CF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E7CF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E7CF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E7CFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E7D00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E7D04: 4082FFE8  bne 0x825e7cec
	if !ctx.cr[0].eq {
	pc = 0x825E7CEC; continue 'dispatch;
	}
	// 825E7D08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7D0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E7D10: 4BF277B9  bl 0x8250f4c8
	ctx.lr = 0x825E7D14;
	sub_8250F4C8(ctx, base);
	// 825E7D14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E7D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E7D1C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825E7D20: 409A0008  bne cr6, 0x825e7d28
	if !ctx.cr[6].eq {
	pc = 0x825E7D28; continue 'dispatch;
	}
	// 825E7D24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E7D28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7D2C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E7D30: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 825E7D34: 4BF277E5  bl 0x8250f518
	ctx.lr = 0x825E7D38;
	sub_8250F518(ctx, base);
	// 825E7D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7D40: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E7D44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E7D48: 4BF257C1  bl 0x8250d508
	ctx.lr = 0x825E7D4C;
	sub_8250D508(ctx, base);
	// 825E7D4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E7D50: 48809F41  bl 0x82df1c90
	ctx.lr = 0x825E7D54;
	sub_82DF1C90(ctx, base);
	// 825E7D54: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E7D58: 48809F39  bl 0x82df1c90
	ctx.lr = 0x825E7D5C;
	sub_82DF1C90(ctx, base);
	// 825E7D5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E7D60: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825E7D64: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E7D68: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 825E7D6C: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 825E7D70: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825E7D74: C00BD5B8  lfs f0, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E7D78: 389D0030  addi r4, r29, 0x30
	ctx.r[4].s64 = ctx.r[29].s64 + 48;
	// 825E7D7C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825E7D80: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E7E98 size=220
    let mut pc: u32 = 0x825E7E98;
    'dispatch: loop {
        match pc {
            0x825E7E98 => {
    //   block [0x825E7E98..0x825E7F74)
	// 825E7E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E7E9C: 48BC02CD  bl 0x831a8168
	ctx.lr = 0x825E7EA0;
	sub_831A8130(ctx, base);
	// 825E7EA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E7EA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825E7EA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E7EAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E7EB0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825E7EB4: 41820038  beq 0x825e7eec
	if ctx.cr[0].eq {
	pc = 0x825E7EEC; continue 'dispatch;
	}
	// 825E7EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7EBC: 48BC1ACD  bl 0x831a9988
	ctx.lr = 0x825E7EC0;
	sub_831A9988(ctx, base);
	// 825E7EC0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 825E7EC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7EC8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 825E7ECC: 48BC022D  bl 0x831a80f8
	ctx.lr = 0x825E7ED0;
	sub_831A80F8(ctx, base);
	// 825E7ED0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E7ED4: 41820018  beq 0x825e7eec
	if ctx.cr[0].eq {
	pc = 0x825E7EEC; continue 'dispatch;
	}
	// 825E7ED8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7EDC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E7EE0: 4BFFFD21  bl 0x825e7c00
	ctx.lr = 0x825E7EE4;
	sub_825E7C00(ctx, base);
	// 825E7EE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825E7EE8: 48000084  b 0x825e7f6c
	pc = 0x825E7F6C; continue 'dispatch;
	// 825E7EEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E7EF0: 419A006C  beq cr6, 0x825e7f5c
	if ctx.cr[6].eq {
	pc = 0x825E7F5C; continue 'dispatch;
	}
	// 825E7EF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7EF8: 48BC1A91  bl 0x831a9988
	ctx.lr = 0x825E7EFC;
	sub_831A9988(ctx, base);
	// 825E7EFC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E7F00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7F04: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 825E7F08: 48BC01F1  bl 0x831a80f8
	ctx.lr = 0x825E7F0C;
	sub_831A80F8(ctx, base);
	// 825E7F0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E7F10: 41820014  beq 0x825e7f24
	if ctx.cr[0].eq {
	pc = 0x825E7F24; continue 'dispatch;
	}
	// 825E7F14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7F18: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E7F1C: 480DA5CD  bl 0x826c24e8
	ctx.lr = 0x825E7F20;
	sub_826C24E8(ctx, base);
	// 825E7F20: 4BFFFFC4  b 0x825e7ee4
	pc = 0x825E7EE4; continue 'dispatch;
	// 825E7F24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E7F28: 419A0034  beq cr6, 0x825e7f5c
	if ctx.cr[6].eq {
	pc = 0x825E7F5C; continue 'dispatch;
	}
	// 825E7F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E7F30: 48BC1A59  bl 0x831a9988
	ctx.lr = 0x825E7F34;
	sub_831A9988(ctx, base);
	// 825E7F34: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E7F38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E7F3C: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 825E7F40: 48BC01B9  bl 0x831a80f8
	ctx.lr = 0x825E7F44;
	sub_831A80F8(ctx, base);
	// 825E7F44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E7F48: 41820014  beq 0x825e7f5c
	if ctx.cr[0].eq {
	pc = 0x825E7F5C; continue 'dispatch;
	}
	// 825E7F4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7F50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825E7F54: 4BFFEECD  bl 0x825e6e20
	ctx.lr = 0x825E7F58;
	sub_825E6E20(ctx, base);
	// 825E7F58: 4BFFFF8C  b 0x825e7ee4
	pc = 0x825E7EE4; continue 'dispatch;
	// 825E7F5C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825E7F60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E7F68: 4BF2A6B1  bl 0x82512618
	ctx.lr = 0x825E7F6C;
	sub_82512618(ctx, base);
	// 825E7F6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E7F70: 48BC0248  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E7F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E7F78 size=512
    let mut pc: u32 = 0x825E7F78;
    'dispatch: loop {
        match pc {
            0x825E7F78 => {
    //   block [0x825E7F78..0x825E8178)
	// 825E7F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E7F7C: 48BC01E9  bl 0x831a8164
	ctx.lr = 0x825E7F80;
	sub_831A8130(ctx, base);
	// 825E7F80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E7F84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E7F88: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E7F8C: 3B8BFB20  addi r28, r11, -0x4e0
	ctx.r[28].s64 = ctx.r[11].s64 + -1248;
	// 825E7F90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E7F94: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825E7F98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E7F9C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825E7FA0: 4880A449  bl 0x82df23e8
	ctx.lr = 0x825E7FA4;
	sub_82DF23E8(ctx, base);
	// 825E7FA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E7FA8: 41820010  beq 0x825e7fb8
	if ctx.cr[0].eq {
	pc = 0x825E7FB8; continue 'dispatch;
	}
	// 825E7FAC: 481B078D  bl 0x82798738
	ctx.lr = 0x825E7FB0;
	sub_82798738(ctx, base);
	// 825E7FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E7FB4: 48000008  b 0x825e7fbc
	pc = 0x825E7FBC; continue 'dispatch;
	// 825E7FB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E7FBC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E7FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7FC4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E7FC8: 4BFFEF49  bl 0x825e6f10
	ctx.lr = 0x825E7FCC;
	sub_825E6F10(ctx, base);
	// 825E7FCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E7FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E7FD4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E7FD8: 4BCD8029  bl 0x822c0000
	ctx.lr = 0x825E7FDC;
	sub_822C0000(ctx, base);
	// 825E7FDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E7FE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E7FE4: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 825E7FE8: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 825E7FEC: 4880A3FD  bl 0x82df23e8
	ctx.lr = 0x825E7FF0;
	sub_82DF23E8(ctx, base);
	// 825E7FF0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E7FF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E7FF8: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 825E7FFC: 41820020  beq 0x825e801c
	if ctx.cr[0].eq {
	pc = 0x825E801C; continue 'dispatch;
	}
	// 825E8000: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E8004: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E8008: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825E800C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825E8010: 4BFFF2A1  bl 0x825e72b0
	ctx.lr = 0x825E8014;
	sub_825E72B0(ctx, base);
	// 825E8014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8018: 48000008  b 0x825e8020
	pc = 0x825E8020; continue 'dispatch;
	// 825E801C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E8020: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E8024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8028: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E802C: 4BFFEF95  bl 0x825e6fc0
	ctx.lr = 0x825E8030;
	sub_825E6FC0(ctx, base);
	// 825E8030: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8034: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8038: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E803C: 4BCD7FC5  bl 0x822c0000
	ctx.lr = 0x825E8040;
	sub_822C0000(ctx, base);
	// 825E8040: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E8044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E8048: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E804C: 409A0008  bne cr6, 0x825e8054
	if !ctx.cr[6].eq {
	pc = 0x825E8054; continue 'dispatch;
	}
	// 825E8050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E8054: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E8058: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E805C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E8060: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825E8064: 419A0024  beq cr6, 0x825e8088
	if ctx.cr[6].eq {
	pc = 0x825E8088; continue 'dispatch;
	}
	// 825E8068: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E806C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E8070: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E8074: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E8078: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E807C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E8080: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E8084: 4082FFE8  bne 0x825e806c
	if !ctx.cr[0].eq {
	pc = 0x825E806C; continue 'dispatch;
	}
	// 825E8088: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E808C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E8090: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E8094: 419A0024  beq cr6, 0x825e80b8
	if ctx.cr[6].eq {
	pc = 0x825E80B8; continue 'dispatch;
	}
	// 825E8098: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E809C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E80A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E80A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E80A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E80AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E80B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E80B4: 4082FFE8  bne 0x825e809c
	if !ctx.cr[0].eq {
	pc = 0x825E809C; continue 'dispatch;
	}
	// 825E80B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E80BC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825E80C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825E80C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E80C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E80CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E80D0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E80D4: 481B0E5D  bl 0x82798f30
	ctx.lr = 0x825E80D8;
	sub_82798F30(ctx, base);
	// 825E80D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E80DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E80E0: 38A0002A  li r5, 0x2a
	ctx.r[5].s64 = 42;
	// 825E80E4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E80E8: 4BCD82F1  bl 0x822c03d8
	ctx.lr = 0x825E80EC;
	sub_822C03D8(ctx, base);
	// 825E80EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E80F0: 41820014  beq 0x825e8104
	if ctx.cr[0].eq {
	pc = 0x825E8104; continue 'dispatch;
	}
	// 825E80F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E80F8: 481B3571  bl 0x8279b668
	ctx.lr = 0x825E80FC;
	sub_8279B668(ctx, base);
	// 825E80FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8100: 48000008  b 0x825e8108
	pc = 0x825E8108; continue 'dispatch;
	// 825E8104: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E8108: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E810C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825E8110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8118: 4BFAFB39  bl 0x82597c50
	ctx.lr = 0x825E811C;
	sub_82597C50(ctx, base);
	// 825E811C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8120: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8128: 4BCD7ED9  bl 0x822c0000
	ctx.lr = 0x825E812C;
	sub_822C0000(ctx, base);
	// 825E812C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E8130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8134: 419A0008  beq cr6, 0x825e813c
	if ctx.cr[6].eq {
	pc = 0x825E813C; continue 'dispatch;
	}
	// 825E8138: 4BCD8759  bl 0x822c0890
	ctx.lr = 0x825E813C;
	sub_822C0890(ctx, base);
	// 825E813C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E8140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8144: 419A0008  beq cr6, 0x825e814c
	if ctx.cr[6].eq {
	pc = 0x825E814C; continue 'dispatch;
	}
	// 825E8148: 4BCD8749  bl 0x822c0890
	ctx.lr = 0x825E814C;
	sub_822C0890(ctx, base);
	// 825E814C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E8150: 419A000C  beq cr6, 0x825e815c
	if ctx.cr[6].eq {
	pc = 0x825E815C; continue 'dispatch;
	}
	// 825E8154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E8158: 4BCD8739  bl 0x822c0890
	ctx.lr = 0x825E815C;
	sub_822C0890(ctx, base);
	// 825E815C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E8160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8164: 419A0008  beq cr6, 0x825e816c
	if ctx.cr[6].eq {
	pc = 0x825E816C; continue 'dispatch;
	}
	// 825E8168: 4BCD8729  bl 0x822c0890
	ctx.lr = 0x825E816C;
	sub_822C0890(ctx, base);
	// 825E816C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E8170: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825E8174: 48BC0040  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E8178 size=552
    let mut pc: u32 = 0x825E8178;
    'dispatch: loop {
        match pc {
            0x825E8178 => {
    //   block [0x825E8178..0x825E83A0)
	// 825E8178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E817C: 48BBFFE9  bl 0x831a8164
	ctx.lr = 0x825E8180;
	sub_831A8130(ctx, base);
	// 825E8180: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825E8184: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8188: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E818C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E8190: 3B8BFB20  addi r28, r11, -0x4e0
	ctx.r[28].s64 = ctx.r[11].s64 + -1248;
	// 825E8194: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E8198: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825E819C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E81A0: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 825E81A4: 4880A245  bl 0x82df23e8
	ctx.lr = 0x825E81A8;
	sub_82DF23E8(ctx, base);
	// 825E81A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E81AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E81B0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E81B4: 4182002C  beq 0x825e81e0
	if ctx.cr[0].eq {
	pc = 0x825E81E0; continue 'dispatch;
	}
	// 825E81B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E81BC: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825E81C0: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825E81C4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E81C8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825E81CC: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E81D0: D0210070  stfs f1, 0x70(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825E81D4: 481B041D  bl 0x827985f0
	ctx.lr = 0x825E81D8;
	sub_827985F0(ctx, base);
	// 825E81D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E81DC: 48000008  b 0x825e81e4
	pc = 0x825E81E4; continue 'dispatch;
	// 825E81E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E81E4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E81E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E81EC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E81F0: 4BFFEE99  bl 0x825e7088
	ctx.lr = 0x825E81F4;
	sub_825E7088(ctx, base);
	// 825E81F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E81F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E81FC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E8200: 4BCD7E01  bl 0x822c0000
	ctx.lr = 0x825E8204;
	sub_822C0000(ctx, base);
	// 825E8204: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E8208: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E820C: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 825E8210: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 825E8214: 4880A1D5  bl 0x82df23e8
	ctx.lr = 0x825E8218;
	sub_82DF23E8(ctx, base);
	// 825E8218: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E821C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E8220: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 825E8224: 41820020  beq 0x825e8244
	if ctx.cr[0].eq {
	pc = 0x825E8244; continue 'dispatch;
	}
	// 825E8228: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E822C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E8230: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825E8234: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825E8238: 4BFFF079  bl 0x825e72b0
	ctx.lr = 0x825E823C;
	sub_825E72B0(ctx, base);
	// 825E823C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8240: 48000008  b 0x825e8248
	pc = 0x825E8248; continue 'dispatch;
	// 825E8244: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E8248: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E824C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8250: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E8254: 4BFFED6D  bl 0x825e6fc0
	ctx.lr = 0x825E8258;
	sub_825E6FC0(ctx, base);
	// 825E8258: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E825C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E8264: 4BCD7D9D  bl 0x822c0000
	ctx.lr = 0x825E8268;
	sub_822C0000(ctx, base);
	// 825E8268: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E826C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E8270: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E8274: 409A0008  bne cr6, 0x825e827c
	if !ctx.cr[6].eq {
	pc = 0x825E827C; continue 'dispatch;
	}
	// 825E8278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E827C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E8280: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E8284: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E8288: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825E828C: 419A0024  beq cr6, 0x825e82b0
	if ctx.cr[6].eq {
	pc = 0x825E82B0; continue 'dispatch;
	}
	// 825E8290: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E8294: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E8298: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E829C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E82A0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E82A4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E82A8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E82AC: 4082FFE8  bne 0x825e8294
	if !ctx.cr[0].eq {
	pc = 0x825E8294; continue 'dispatch;
	}
	// 825E82B0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E82B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E82B8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E82BC: 419A0024  beq cr6, 0x825e82e0
	if ctx.cr[6].eq {
	pc = 0x825E82E0; continue 'dispatch;
	}
	// 825E82C0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E82C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E82C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E82CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E82D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E82D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E82D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E82DC: 4082FFE8  bne 0x825e82c4
	if !ctx.cr[0].eq {
	pc = 0x825E82C4; continue 'dispatch;
	}
	// 825E82E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825E82E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E82E8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825E82EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E82F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E82F4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E82F8: 481B0C39  bl 0x82798f30
	ctx.lr = 0x825E82FC;
	sub_82798F30(ctx, base);
	// 825E82FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E8300: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E8304: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 825E8308: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E830C: 4BCD80CD  bl 0x822c03d8
	ctx.lr = 0x825E8310;
	sub_822C03D8(ctx, base);
	// 825E8310: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E8314: 41820014  beq 0x825e8328
	if ctx.cr[0].eq {
	pc = 0x825E8328; continue 'dispatch;
	}
	// 825E8318: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825E831C: 481B334D  bl 0x8279b668
	ctx.lr = 0x825E8320;
	sub_8279B668(ctx, base);
	// 825E8320: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8324: 48000008  b 0x825e832c
	pc = 0x825E832C; continue 'dispatch;
	// 825E8328: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E832C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E8330: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825E8334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E833C: 4BFAF915  bl 0x82597c50
	ctx.lr = 0x825E8340;
	sub_82597C50(ctx, base);
	// 825E8340: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8344: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E834C: 4BCD7CB5  bl 0x822c0000
	ctx.lr = 0x825E8350;
	sub_822C0000(ctx, base);
	// 825E8350: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825E8354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8358: 419A0008  beq cr6, 0x825e8360
	if ctx.cr[6].eq {
	pc = 0x825E8360; continue 'dispatch;
	}
	// 825E835C: 4BCD8535  bl 0x822c0890
	ctx.lr = 0x825E8360;
	sub_822C0890(ctx, base);
	// 825E8360: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E8364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8368: 419A0008  beq cr6, 0x825e8370
	if ctx.cr[6].eq {
	pc = 0x825E8370; continue 'dispatch;
	}
	// 825E836C: 4BCD8525  bl 0x822c0890
	ctx.lr = 0x825E8370;
	sub_822C0890(ctx, base);
	// 825E8370: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E8374: 419A000C  beq cr6, 0x825e8380
	if ctx.cr[6].eq {
	pc = 0x825E8380; continue 'dispatch;
	}
	// 825E8378: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E837C: 4BCD8515  bl 0x822c0890
	ctx.lr = 0x825E8380;
	sub_822C0890(ctx, base);
	// 825E8380: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E8384: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8388: 419A0008  beq cr6, 0x825e8390
	if ctx.cr[6].eq {
	pc = 0x825E8390; continue 'dispatch;
	}
	// 825E838C: 4BCD8505  bl 0x822c0890
	ctx.lr = 0x825E8390;
	sub_822C0890(ctx, base);
	// 825E8390: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E8394: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825E8398: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825E839C: 48BBFE18  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E83A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E83A0 size=536
    let mut pc: u32 = 0x825E83A0;
    'dispatch: loop {
        match pc {
            0x825E83A0 => {
    //   block [0x825E83A0..0x825E85B8)
	// 825E83A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E83A4: 48BBFDC1  bl 0x831a8164
	ctx.lr = 0x825E83A8;
	sub_831A8130(ctx, base);
	// 825E83A8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E83AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E83B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825E83B4: 3B8BFB20  addi r28, r11, -0x4e0
	ctx.r[28].s64 = ctx.r[11].s64 + -1248;
	// 825E83B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E83BC: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 825E83C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E83C4: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 825E83C8: 4880A021  bl 0x82df23e8
	ctx.lr = 0x825E83CC;
	sub_82DF23E8(ctx, base);
	// 825E83CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E83D0: 41820028  beq 0x825e83f8
	if ctx.cr[0].eq {
	pc = 0x825E83F8; continue 'dispatch;
	}
	// 825E83D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E83D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E83DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E83E0: C06BA1C4  lfs f3, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E83E4: C04A08AC  lfs f2, 0x8ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2220 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825E83E8: C02908A8  lfs f1, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E83EC: 481B0235  bl 0x82798620
	ctx.lr = 0x825E83F0;
	sub_82798620(ctx, base);
	// 825E83F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E83F4: 48000008  b 0x825e83fc
	pc = 0x825E83FC; continue 'dispatch;
	// 825E83F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E83FC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825E8400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8404: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E8408: 4BFFED31  bl 0x825e7138
	ctx.lr = 0x825E840C;
	sub_825E7138(ctx, base);
	// 825E840C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8414: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825E8418: 4BCD7BE9  bl 0x822c0000
	ctx.lr = 0x825E841C;
	sub_822C0000(ctx, base);
	// 825E841C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E8420: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E8424: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 825E8428: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 825E842C: 48809FBD  bl 0x82df23e8
	ctx.lr = 0x825E8430;
	sub_82DF23E8(ctx, base);
	// 825E8430: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E8434: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E8438: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 825E843C: 41820020  beq 0x825e845c
	if ctx.cr[0].eq {
	pc = 0x825E845C; continue 'dispatch;
	}
	// 825E8440: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E8444: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E8448: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825E844C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825E8450: 4BFFEE61  bl 0x825e72b0
	ctx.lr = 0x825E8454;
	sub_825E72B0(ctx, base);
	// 825E8454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8458: 48000008  b 0x825e8460
	pc = 0x825E8460; continue 'dispatch;
	// 825E845C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E8460: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E8464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8468: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E846C: 4BFFEB55  bl 0x825e6fc0
	ctx.lr = 0x825E8470;
	sub_825E6FC0(ctx, base);
	// 825E8470: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8478: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E847C: 4BCD7B85  bl 0x822c0000
	ctx.lr = 0x825E8480;
	sub_822C0000(ctx, base);
	// 825E8480: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E8484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E8488: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E848C: 409A0008  bne cr6, 0x825e8494
	if !ctx.cr[6].eq {
	pc = 0x825E8494; continue 'dispatch;
	}
	// 825E8490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E8494: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E8498: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E849C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E84A0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825E84A4: 419A0024  beq cr6, 0x825e84c8
	if ctx.cr[6].eq {
	pc = 0x825E84C8; continue 'dispatch;
	}
	// 825E84A8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E84AC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E84B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E84B4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E84B8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E84BC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E84C0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E84C4: 4082FFE8  bne 0x825e84ac
	if !ctx.cr[0].eq {
	pc = 0x825E84AC; continue 'dispatch;
	}
	// 825E84C8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E84CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E84D0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825E84D4: 419A0024  beq cr6, 0x825e84f8
	if ctx.cr[6].eq {
	pc = 0x825E84F8; continue 'dispatch;
	}
	// 825E84D8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825E84DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E84E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E84E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E84E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E84EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E84F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E84F4: 4082FFE8  bne 0x825e84dc
	if !ctx.cr[0].eq {
	pc = 0x825E84DC; continue 'dispatch;
	}
	// 825E84F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E84FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825E8500: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825E8504: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E8508: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E850C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E8510: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E8514: 481B0A1D  bl 0x82798f30
	ctx.lr = 0x825E8518;
	sub_82798F30(ctx, base);
	// 825E8518: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E851C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E8520: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 825E8524: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E8528: 4BCD7EB1  bl 0x822c03d8
	ctx.lr = 0x825E852C;
	sub_822C03D8(ctx, base);
	// 825E852C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E8530: 41820014  beq 0x825e8544
	if ctx.cr[0].eq {
	pc = 0x825E8544; continue 'dispatch;
	}
	// 825E8534: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E8538: 481B3131  bl 0x8279b668
	ctx.lr = 0x825E853C;
	sub_8279B668(ctx, base);
	// 825E853C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8540: 48000008  b 0x825e8548
	pc = 0x825E8548; continue 'dispatch;
	// 825E8544: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E8548: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E854C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825E8550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8558: 4BFAF6F9  bl 0x82597c50
	ctx.lr = 0x825E855C;
	sub_82597C50(ctx, base);
	// 825E855C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8568: 4BCD7A99  bl 0x822c0000
	ctx.lr = 0x825E856C;
	sub_822C0000(ctx, base);
	// 825E856C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E8570: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8574: 419A0008  beq cr6, 0x825e857c
	if ctx.cr[6].eq {
	pc = 0x825E857C; continue 'dispatch;
	}
	// 825E8578: 4BCD8319  bl 0x822c0890
	ctx.lr = 0x825E857C;
	sub_822C0890(ctx, base);
	// 825E857C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E8580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8584: 419A0008  beq cr6, 0x825e858c
	if ctx.cr[6].eq {
	pc = 0x825E858C; continue 'dispatch;
	}
	// 825E8588: 4BCD8309  bl 0x822c0890
	ctx.lr = 0x825E858C;
	sub_822C0890(ctx, base);
	// 825E858C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825E8590: 419A000C  beq cr6, 0x825e859c
	if ctx.cr[6].eq {
	pc = 0x825E859C; continue 'dispatch;
	}
	// 825E8594: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E8598: 4BCD82F9  bl 0x822c0890
	ctx.lr = 0x825E859C;
	sub_822C0890(ctx, base);
	// 825E859C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E85A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E85A4: 419A0008  beq cr6, 0x825e85ac
	if ctx.cr[6].eq {
	pc = 0x825E85AC; continue 'dispatch;
	}
	// 825E85A8: 4BCD82E9  bl 0x822c0890
	ctx.lr = 0x825E85AC;
	sub_822C0890(ctx, base);
	// 825E85AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E85B0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825E85B4: 48BBFC00  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E85B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E85B8 size=136
    let mut pc: u32 = 0x825E85B8;
    'dispatch: loop {
        match pc {
            0x825E85B8 => {
    //   block [0x825E85B8..0x825E8640)
	// 825E85B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E85BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E85C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E85C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E85C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E85CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E85D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E85D4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825E85D8: 409A0020  bne cr6, 0x825e85f8
	if !ctx.cr[6].eq {
	pc = 0x825E85F8; continue 'dispatch;
	}
	// 825E85DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E85E0: 419A0048  beq cr6, 0x825e8628
	if ctx.cr[6].eq {
	pc = 0x825E8628; continue 'dispatch;
	}
	// 825E85E4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825E85E8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825E85EC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825E85F0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825E85F4: 48000034  b 0x825e8628
	pc = 0x825E8628; continue 'dispatch;
	// 825E85F8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825E85FC: 419A002C  beq cr6, 0x825e8628
	if ctx.cr[6].eq {
	pc = 0x825E8628; continue 'dispatch;
	}
	// 825E8600: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E8604: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E8608: 388BDEC0  addi r4, r11, -0x2140
	ctx.r[4].s64 = ctx.r[11].s64 + -8512;
	// 825E860C: 48BBFAED  bl 0x831a80f8
	ctx.lr = 0x825E8610;
	sub_831A80F8(ctx, base);
	// 825E8610: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E8614: 4182000C  beq 0x825e8620
	if ctx.cr[0].eq {
	pc = 0x825E8620; continue 'dispatch;
	}
	// 825E8618: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825E861C: 4800000C  b 0x825e8628
	pc = 0x825E8628; continue 'dispatch;
	// 825E8620: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E8624: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E8628: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E862C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E8630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E8634: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E8638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E8640 size=136
    let mut pc: u32 = 0x825E8640;
    'dispatch: loop {
        match pc {
            0x825E8640 => {
    //   block [0x825E8640..0x825E86C8)
	// 825E8640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E864C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E8650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E8658: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E865C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825E8660: 409A0020  bne cr6, 0x825e8680
	if !ctx.cr[6].eq {
	pc = 0x825E8680; continue 'dispatch;
	}
	// 825E8664: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E8668: 419A0048  beq cr6, 0x825e86b0
	if ctx.cr[6].eq {
	pc = 0x825E86B0; continue 'dispatch;
	}
	// 825E866C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825E8670: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825E8674: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825E8678: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825E867C: 48000034  b 0x825e86b0
	pc = 0x825E86B0; continue 'dispatch;
	// 825E8680: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825E8684: 419A002C  beq cr6, 0x825e86b0
	if ctx.cr[6].eq {
	pc = 0x825E86B0; continue 'dispatch;
	}
	// 825E8688: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E868C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E8690: 388BDF58  addi r4, r11, -0x20a8
	ctx.r[4].s64 = ctx.r[11].s64 + -8360;
	// 825E8694: 48BBFA65  bl 0x831a80f8
	ctx.lr = 0x825E8698;
	sub_831A80F8(ctx, base);
	// 825E8698: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E869C: 4182000C  beq 0x825e86a8
	if ctx.cr[0].eq {
	pc = 0x825E86A8; continue 'dispatch;
	}
	// 825E86A0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825E86A4: 4800000C  b 0x825e86b0
	pc = 0x825E86B0; continue 'dispatch;
	// 825E86A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E86AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E86B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E86B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E86B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E86BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E86C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E86C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E86C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E86C8 size=16
    let mut pc: u32 = 0x825E86C8;
    'dispatch: loop {
        match pc {
            0x825E86C8 => {
    //   block [0x825E86C8..0x825E86D8)
	// 825E86C8: 81630140  lwz r11, 0x140(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 825E86CC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825E86D0: 41980014  blt cr6, 0x825e86e4
	if ctx.cr[6].lt {
		sub_825E86E4(ctx, base);
		return;
	}
	// 825E86D4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E86D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E86D8 size=12
    let mut pc: u32 = 0x825E86D8;
    'dispatch: loop {
        match pc {
            0x825E86D8 => {
    //   block [0x825E86D8..0x825E86E4)
	// 825E86D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E86DC: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 825E86E0: 4800000C  b 0x825e86ec
	sub_825E86E4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E86E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825E86E4 size=24
    let mut pc: u32 = 0x825E86E4;
    'dispatch: loop {
        match pc {
            0x825E86E4 => {
    //   block [0x825E86E4..0x825E86FC)
	// 825E86E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E86E8: 396BC4C0  addi r11, r11, -0x3b40
	ctx.r[11].s64 = ctx.r[11].s64 + -15168;
	// 825E86EC: 39400150  li r10, 0x150
	ctx.r[10].s64 = 336;
	// 825E86F0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E8700 size=340
    let mut pc: u32 = 0x825E8700;
    'dispatch: loop {
        match pc {
            0x825E8700 => {
    //   block [0x825E8700..0x825E8854)
	// 825E8700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E870C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825E8710: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825E8714: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E871C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E8720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E8724: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E8728: C1BF0134  lfs f13, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E872C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E8730: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825E8734: 4BF26D95  bl 0x8250f4c8
	ctx.lr = 0x825E8738;
	sub_8250F4C8(ctx, base);
	// 825E8738: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E873C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E8740: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E8744: 409A0008  bne cr6, 0x825e874c
	if !ctx.cr[6].eq {
	pc = 0x825E874C; continue 'dispatch;
	}
	// 825E8748: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E874C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825E8750: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E8754: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E8758: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E875C: EFC00372  fmuls f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E8760: 4BF1FDB9  bl 0x82508518
	ctx.lr = 0x825E8764;
	sub_82508518(ctx, base);
	// 825E8764: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 825E8768: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E876C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825E8770: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825E8774: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825E8778: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825E877C: C00ACEE4  lfs f0, -0x311c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E8780: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825E8784: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E8788: EC2107FA  fmadds f1, f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 825E878C: 48BC2085  bl 0x831aa810
	ctx.lr = 0x825E8790;
	sub_831AA810(ctx, base);
	// 825E8790: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E8794: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825E8798: 488094F9  bl 0x82df1c90
	ctx.lr = 0x825E879C;
	sub_82DF1C90(ctx, base);
	// 825E879C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825E87A0: 48BC0629  bl 0x831a8dc8
	ctx.lr = 0x825E87A4;
	sub_831A8DC8(ctx, base);
	// 825E87A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E87A8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825E87AC: 39400150  li r10, 0x150
	ctx.r[10].s64 = 336;
	// 825E87B0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825E87B4: 39200138  li r9, 0x138
	ctx.r[9].s64 = 312;
	// 825E87B8: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 825E87BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 825E87C0: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E8858 size=464
    let mut pc: u32 = 0x825E8858;
    'dispatch: loop {
        match pc {
            0x825E8858 => {
    //   block [0x825E8858..0x825E8A28)
	// 825E8858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E885C: 48BBF911  bl 0x831a816c
	ctx.lr = 0x825E8860;
	sub_831A8130(ctx, base);
	// 825E8860: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8868: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825E886C: 897F0164  lbz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 825E8870: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E8874: 408200A8  bne 0x825e891c
	if !ctx.cr[0].eq {
	pc = 0x825E891C; continue 'dispatch;
	}
	// 825E8878: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 825E887C: 13C030C7  vcmpequd (lvx128) v30, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E8880: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E8A28 size=196
    let mut pc: u32 = 0x825E8A28;
    'dispatch: loop {
        match pc {
            0x825E8A28 => {
    //   block [0x825E8A28..0x825E8AEC)
	// 825E8A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E8A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E8A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E8A40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E8A44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825E8A48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E8A4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E8A50: 4BCD7EE9  bl 0x822c0938
	ctx.lr = 0x825E8A54;
	sub_822C0938(ctx, base);
	// 825E8A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E8A58: 41820028  beq 0x825e8a80
	if ctx.cr[0].eq {
	pc = 0x825E8A80; continue 'dispatch;
	}
	// 825E8A5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E8A60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E8A64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825E8A68: 392BFBCC  addi r9, r11, -0x434
	ctx.r[9].s64 = ctx.r[11].s64 + -1076;
	// 825E8A6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825E8A70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E8A74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E8A78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825E8A7C: 48000008  b 0x825e8a84
	pc = 0x825E8A84; continue 'dispatch;
	// 825E8A80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E8A84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E8A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E8A8C: 409A0044  bne cr6, 0x825e8ad0
	if !ctx.cr[6].eq {
	pc = 0x825E8AD0; continue 'dispatch;
	}
	// 825E8A90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E8A94: 419A001C  beq cr6, 0x825e8ab0
	if ctx.cr[6].eq {
	pc = 0x825E8AB0; continue 'dispatch;
	}
	// 825E8A98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E8A9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825E8AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E8AA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E8AA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E8AAC: 4E800421  bctrl
	ctx.lr = 0x825E8AB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E8AB0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E8AB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E8AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8ABC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825E8AC0: 816BDEBC  lwz r11, -0x2144(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8516 as u32) ) } as u64;
	// 825E8AC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825E8AC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E8ACC: 4BCD7535  bl 0x822c0000
	ctx.lr = 0x825E8AD0;
	sub_822C0000(ctx, base);
	// 825E8AD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8AD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E8AD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E8ADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E8AE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E8AE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E8AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E8AF0 size=72
    let mut pc: u32 = 0x825E8AF0;
    'dispatch: loop {
        match pc {
            0x825E8AF0 => {
    //   block [0x825E8AF0..0x825E8B38)
	// 825E8AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8AF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8AFC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825E8B00: 419A001C  beq cr6, 0x825e8b1c
	if ctx.cr[6].eq {
	pc = 0x825E8B1C; continue 'dispatch;
	}
	// 825E8B04: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E8B08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E8B0C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825E8B10: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E8B14: 4BFFFAA5  bl 0x825e85b8
	ctx.lr = 0x825E8B18;
	sub_825E85B8(ctx, base);
	// 825E8B18: 48000010  b 0x825e8b28
	pc = 0x825E8B28; continue 'dispatch;
	// 825E8B1C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E8B20: 396BDEC0  addi r11, r11, -0x2140
	ctx.r[11].s64 = ctx.r[11].s64 + -8512;
	// 825E8B24: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E8B28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E8B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E8B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E8B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E8B38 size=72
    let mut pc: u32 = 0x825E8B38;
    'dispatch: loop {
        match pc {
            0x825E8B38 => {
    //   block [0x825E8B38..0x825E8B80)
	// 825E8B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8B40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8B44: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825E8B48: 419A001C  beq cr6, 0x825e8b64
	if ctx.cr[6].eq {
	pc = 0x825E8B64; continue 'dispatch;
	}
	// 825E8B4C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E8B50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E8B54: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825E8B58: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E8B5C: 4BFFFAE5  bl 0x825e8640
	ctx.lr = 0x825E8B60;
	sub_825E8640(ctx, base);
	// 825E8B60: 48000010  b 0x825e8b70
	pc = 0x825E8B70; continue 'dispatch;
	// 825E8B64: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825E8B68: 396BDF58  addi r11, r11, -0x20a8
	ctx.r[11].s64 = ctx.r[11].s64 + -8360;
	// 825E8B6C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E8B70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E8B74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E8B78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E8B7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E8B80 size=236
    let mut pc: u32 = 0x825E8B80;
    'dispatch: loop {
        match pc {
            0x825E8B80 => {
    //   block [0x825E8B80..0x825E8C6C)
	// 825E8B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8B84: 48BBF5E5  bl 0x831a8168
	ctx.lr = 0x825E8B88;
	sub_831A8130(ctx, base);
	// 825E8B88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8B8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8B90: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825E8B94: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825E8B98: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 825E8B9C: 4BF296C5  bl 0x82512260
	ctx.lr = 0x825E8BA0;
	sub_82512260(ctx, base);
	// 825E8BA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E8BA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E8BA8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E8BAC: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825E8BB0: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825E8BB4: 394AFC44  addi r10, r10, -0x3bc
	ctx.r[10].s64 = ctx.r[10].s64 + -956;
	// 825E8BB8: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825E8BBC: 3929FC30  addi r9, r9, -0x3d0
	ctx.r[9].s64 = ctx.r[9].s64 + -976;
	// 825E8BC0: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
	// 825E8BC4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E8BC8: 3908FBE4  addi r8, r8, -0x41c
	ctx.r[8].s64 = ctx.r[8].s64 + -1052;
	// 825E8BCC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E8BD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E8BD4: 39476910  addi r10, r7, 0x6910
	ctx.r[10].s64 = ctx.r[7].s64 + 26896;
	// 825E8BD8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825E8BDC: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 825E8BE0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825E8BE4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825E8BE8: 39000120  li r8, 0x120
	ctx.r[8].s64 = 288;
	// 825E8BEC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825E8BF0: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825E8BF4: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 825E8BF8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825E8BFC: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 825E8C00: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E8C70 size=8
    let mut pc: u32 = 0x825E8C70;
    'dispatch: loop {
        match pc {
            0x825E8C70 => {
    //   block [0x825E8C70..0x825E8C78)
	// 825E8C70: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825E8C74: 480000AC  b 0x825e8d20
	sub_825E8D20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E8C78 size=8
    let mut pc: u32 = 0x825E8C78;
    'dispatch: loop {
        match pc {
            0x825E8C78 => {
    //   block [0x825E8C78..0x825E8C80)
	// 825E8C78: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825E8C7C: 480000A4  b 0x825e8d20
	sub_825E8D20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E8C80 size=156
    let mut pc: u32 = 0x825E8C80;
    'dispatch: loop {
        match pc {
            0x825E8C80 => {
    //   block [0x825E8C80..0x825E8D1C)
	// 825E8C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8C88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E8C8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E8C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8C94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8C98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E8C9C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E8CA0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825E8CA4: 396BFC44  addi r11, r11, -0x3bc
	ctx.r[11].s64 = ctx.r[11].s64 + -956;
	// 825E8CA8: 394AFC30  addi r10, r10, -0x3d0
	ctx.r[10].s64 = ctx.r[10].s64 + -976;
	// 825E8CAC: 3929FBE4  addi r9, r9, -0x41c
	ctx.r[9].s64 = ctx.r[9].s64 + -1052;
	// 825E8CB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825E8CB4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825E8CB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E8CBC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825E8CC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E8CC4: 38BF00E8  addi r5, r31, 0xe8
	ctx.r[5].s64 = ctx.r[31].s64 + 232;
	// 825E8CC8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825E8CCC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825E8CD0: 4BF27521  bl 0x825101f0
	ctx.lr = 0x825E8CD4;
	sub_825101F0(ctx, base);
	// 825E8CD4: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825E8CD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8CDC: 419A0008  beq cr6, 0x825e8ce4
	if ctx.cr[6].eq {
	pc = 0x825E8CE4; continue 'dispatch;
	}
	// 825E8CE0: 4BCD7BB1  bl 0x822c0890
	ctx.lr = 0x825E8CE4;
	sub_822C0890(ctx, base);
	// 825E8CE4: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825E8CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E8CEC: 419A0008  beq cr6, 0x825e8cf4
	if ctx.cr[6].eq {
	pc = 0x825E8CF4; continue 'dispatch;
	}
	// 825E8CF0: 4BCD7BA1  bl 0x822c0890
	ctx.lr = 0x825E8CF4;
	sub_822C0890(ctx, base);
	// 825E8CF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8CF8: 481BE961  bl 0x827a7658
	ctx.lr = 0x825E8CFC;
	sub_827A7658(ctx, base);
	// 825E8CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E8D00: 4BD66651  bl 0x8234f350
	ctx.lr = 0x825E8D04;
	sub_8234F350(ctx, base);
	// 825E8D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E8D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E8D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E8D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E8D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E8D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E8D20 size=76
    let mut pc: u32 = 0x825E8D20;
    'dispatch: loop {
        match pc {
            0x825E8D20 => {
    //   block [0x825E8D20..0x825E8D6C)
	// 825E8D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E8D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E8D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E8D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8D38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E8D3C: 4BFFFF45  bl 0x825e8c80
	ctx.lr = 0x825E8D40;
	sub_825E8C80(ctx, base);
	// 825E8D40: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E8D44: 4182000C  beq 0x825e8d50
	if ctx.cr[0].eq {
	pc = 0x825E8D50; continue 'dispatch;
	}
	// 825E8D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E8D4C: 4880968D  bl 0x82df23d8
	ctx.lr = 0x825E8D50;
	sub_82DF23D8(ctx, base);
	// 825E8D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E8D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E8D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E8D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E8D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825E8D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E8D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E8D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E8D70 size=904
    let mut pc: u32 = 0x825E8D70;
    'dispatch: loop {
        match pc {
            0x825E8D70 => {
    //   block [0x825E8D70..0x825E90F8)
	// 825E8D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E8D74: 48BBF3ED  bl 0x831a8160
	ctx.lr = 0x825E8D78;
	sub_831A8130(ctx, base);
	// 825E8D78: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E8D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E8D80: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E8D84: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825E8D88: 4BF28C51  bl 0x825119d8
	ctx.lr = 0x825E8D8C;
	sub_825119D8(ctx, base);
	// 825E8D8C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E8D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8D94: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825E8D98: 4880AC71  bl 0x82df3a08
	ctx.lr = 0x825E8D9C;
	sub_82DF3A08(ctx, base);
	// 825E8D9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8DA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8DA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E8DA8: 4BF1F9D9  bl 0x82508780
	ctx.lr = 0x825E8DAC;
	sub_82508780(ctx, base);
	// 825E8DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8DB0: 4880A679  bl 0x82df3428
	ctx.lr = 0x825E8DB4;
	sub_82DF3428(ctx, base);
	// 825E8DB4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825E8DB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8DBC: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825E8DC0: 4880AC49  bl 0x82df3a08
	ctx.lr = 0x825E8DC4;
	sub_82DF3A08(ctx, base);
	// 825E8DC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E8DC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E8DCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8DD0: 4BF1F9B1  bl 0x82508780
	ctx.lr = 0x825E8DD4;
	sub_82508780(ctx, base);
	// 825E8DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8DD8: 4880A651  bl 0x82df3428
	ctx.lr = 0x825E8DDC;
	sub_82DF3428(ctx, base);
	// 825E8DDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825E8DE0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825E8DE4: 409A0008  bne cr6, 0x825e8dec
	if !ctx.cr[6].eq {
	pc = 0x825E8DEC; continue 'dispatch;
	}
	// 825E8DE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E8DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E8DF0: 4BF1F9B1  bl 0x825087a0
	ctx.lr = 0x825E8DF4;
	sub_825087A0(ctx, base);
	// 825E8DF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E8DF8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E8DFC: 48841CED  bl 0x82e2aae8
	ctx.lr = 0x825E8E00;
	sub_82E2AAE8(ctx, base);
	// 825E8E00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E8E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8E08: 388BFCEC  addi r4, r11, -0x314
	ctx.r[4].s64 = ctx.r[11].s64 + -788;
	// 825E8E0C: 4880ABFD  bl 0x82df3a08
	ctx.lr = 0x825E8E10;
	sub_82DF3A08(ctx, base);
	// 825E8E10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E8E14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E8E18: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825E8E1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825E8E20: 48846051  bl 0x82e2ee70
	ctx.lr = 0x825E8E24;
	sub_82E2EE70(ctx, base);
	// 825E8E24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825E8E28: 4880A601  bl 0x82df3428
	ctx.lr = 0x825E8E2C;
	sub_82DF3428(ctx, base);
	// 825E8E2C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825E8E30: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825E8E34: 394B6880  addi r10, r11, 0x6880
	ctx.r[10].s64 = ctx.r[11].s64 + 26752;
	// 825E8E38: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 825E8E3C: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 825E8E40: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 825E8E44: 3BC10090  addi r30, r1, 0x90
	ctx.r[30].s64 = ctx.r[1].s64 + 144;
	// 825E8E48: 3B6100A0  addi r27, r1, 0xa0
	ctx.r[27].s64 = ctx.r[1].s64 + 160;
	// 825E8E4C: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E8E50: 3B4100B0  addi r26, r1, 0xb0
	ctx.r[26].s64 = ctx.r[1].s64 + 176;
	// 825E8E54: 13C95407  vcmpneb. (lvlx128) v30, v9, v10
	tmp.u32 = ctx.r[9].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E8E58: 13BC5407  vcmpneb. (lvlx128) v29, v28, v10
	tmp.u32 = ctx.r[28].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E8E5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E8E60: 13885407  vcmpneb. (lvlx128) v28, v8, v10
	tmp.u32 = ctx.r[8].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E8E64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E90F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E90F8 size=612
    let mut pc: u32 = 0x825E90F8;
    'dispatch: loop {
        match pc {
            0x825E90F8 => {
    //   block [0x825E90F8..0x825E935C)
	// 825E90F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E90FC: 48BBF069  bl 0x831a8164
	ctx.lr = 0x825E9100;
	sub_831A8130(ctx, base);
	// 825E9100: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9108: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825E910C: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 825E9110: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825E9114: 419A01A0  beq cr6, 0x825e92b4
	if ctx.cr[6].eq {
	pc = 0x825E92B4; continue 'dispatch;
	}
	// 825E9118: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825E911C: 409A01A4  bne cr6, 0x825e92c0
	if !ctx.cr[6].eq {
	pc = 0x825E92C0; continue 'dispatch;
	}
	// 825E9120: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825E9124: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E9128: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E912C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E9130: 4BD340A1  bl 0x8231d1d0
	ctx.lr = 0x825E9134;
	sub_8231D1D0(ctx, base);
	// 825E9134: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E9138: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E913C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E9140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E9144: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825E9148: 419A0024  beq cr6, 0x825e916c
	if ctx.cr[6].eq {
	pc = 0x825E916C; continue 'dispatch;
	}
	// 825E914C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E9150: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E9154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9158: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E915C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E9160: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E9164: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9168: 4082FFE8  bne 0x825e9150
	if !ctx.cr[0].eq {
	pc = 0x825E9150; continue 'dispatch;
	}
	// 825E916C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9170: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E9174: 4BF26355  bl 0x8250f4c8
	ctx.lr = 0x825E9178;
	sub_8250F4C8(ctx, base);
	// 825E9178: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E917C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E9180: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E9184: 409A0008  bne cr6, 0x825e918c
	if !ctx.cr[6].eq {
	pc = 0x825E918C; continue 'dispatch;
	}
	// 825E9188: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E918C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E9190: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 825E9194: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825E9198: 4BF1F881  bl 0x82508a18
	ctx.lr = 0x825E919C;
	sub_82508A18(ctx, base);
	// 825E919C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E91A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E91A4: 3BABFCA0  addi r29, r11, -0x360
	ctx.r[29].s64 = ctx.r[11].s64 + -864;
	// 825E91A8: 38A000E3  li r5, 0xe3
	ctx.r[5].s64 = 227;
	// 825E91AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E91B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E91B4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825E91B8: 4886DE31  bl 0x82e56fe8
	ctx.lr = 0x825E91BC;
	sub_82E56FE8(ctx, base);
	// 825E91BC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825E91C0: 48808AD1  bl 0x82df1c90
	ctx.lr = 0x825E91C4;
	sub_82DF1C90(ctx, base);
	// 825E91C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E91C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E91CC: 419A0008  beq cr6, 0x825e91d4
	if ctx.cr[6].eq {
	pc = 0x825E91D4; continue 'dispatch;
	}
	// 825E91D0: 4BCD76C1  bl 0x822c0890
	ctx.lr = 0x825E91D4;
	sub_822C0890(ctx, base);
	// 825E91D4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825E91D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E91DC: 419A0008  beq cr6, 0x825e91e4
	if ctx.cr[6].eq {
	pc = 0x825E91E4; continue 'dispatch;
	}
	// 825E91E0: 4BCD76B1  bl 0x822c0890
	ctx.lr = 0x825E91E4;
	sub_822C0890(ctx, base);
	// 825E91E4: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825E91E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825E91EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E91F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E91F4: 4BDB6095  bl 0x8239f288
	ctx.lr = 0x825E91F8;
	sub_8239F288(ctx, base);
	// 825E91F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E91FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825E9200: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E9204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E9208: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825E920C: 419A0024  beq cr6, 0x825e9230
	if ctx.cr[6].eq {
	pc = 0x825E9230; continue 'dispatch;
	}
	// 825E9210: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E9214: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E9218: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E921C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E9220: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E9224: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E9228: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E922C: 4082FFE8  bne 0x825e9214
	if !ctx.cr[0].eq {
	pc = 0x825E9214; continue 'dispatch;
	}
	// 825E9230: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9234: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E9238: 4BF26291  bl 0x8250f4c8
	ctx.lr = 0x825E923C;
	sub_8250F4C8(ctx, base);
	// 825E923C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E9240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E9244: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825E9248: 409A0008  bne cr6, 0x825e9250
	if !ctx.cr[6].eq {
	pc = 0x825E9250; continue 'dispatch;
	}
	// 825E924C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E9250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825E9254: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 825E9258: 4BF1F7C1  bl 0x82508a18
	ctx.lr = 0x825E925C;
	sub_82508A18(ctx, base);
	// 825E925C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E9260: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825E9264: 38A000E4  li r5, 0xe4
	ctx.r[5].s64 = 228;
	// 825E9268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E926C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825E9270: 4886DD79  bl 0x82e56fe8
	ctx.lr = 0x825E9274;
	sub_82E56FE8(ctx, base);
	// 825E9274: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825E9278: 48808A19  bl 0x82df1c90
	ctx.lr = 0x825E927C;
	sub_82DF1C90(ctx, base);
	// 825E927C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825E9280: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9284: 419A0008  beq cr6, 0x825e928c
	if ctx.cr[6].eq {
	pc = 0x825E928C; continue 'dispatch;
	}
	// 825E9288: 4BCD7609  bl 0x822c0890
	ctx.lr = 0x825E928C;
	sub_822C0890(ctx, base);
	// 825E928C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E9290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9294: 419A0008  beq cr6, 0x825e929c
	if ctx.cr[6].eq {
	pc = 0x825E929C; continue 'dispatch;
	}
	// 825E9298: 4BCD75F9  bl 0x822c0890
	ctx.lr = 0x825E929C;
	sub_822C0890(ctx, base);
	// 825E929C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 825E92A0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825E92A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E92A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E92AC: 4BFFF5AD  bl 0x825e8858
	ctx.lr = 0x825E92B0;
	sub_825E8858(ctx, base);
	// 825E92B0: 48000010  b 0x825e92c0
	pc = 0x825E92C0; continue 'dispatch;
	// 825E92B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E92B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E92BC: 4BFFF445  bl 0x825e8700
	ctx.lr = 0x825E92C0;
	sub_825E8700(ctx, base);
	// 825E92C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825E92C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E92C8: 4BF27441  bl 0x82510708
	ctx.lr = 0x825E92CC;
	sub_82510708(ctx, base);
	// 825E92CC: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 825E92D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E92D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E92D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825E92DC: 4E800421  bctrl
	ctx.lr = 0x825E92E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825E92E0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 825E92E4: 392100F0  addi r9, r1, 0xf0
	ctx.r[9].s64 = ctx.r[1].s64 + 240;
	// 825E92E8: C1BC0000  lfs f13, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E92EC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825E92F0: 397F0110  addi r11, r31, 0x110
	ctx.r[11].s64 = ctx.r[31].s64 + 272;
	// 825E92F4: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 825E92F8: 13EA1C07  vcmpneb. (lvlx128) v31, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825E92FC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E9360 size=196
    let mut pc: u32 = 0x825E9360;
    'dispatch: loop {
        match pc {
            0x825E9360 => {
    //   block [0x825E9360..0x825E9424)
	// 825E9360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E9364: 48BBEE09  bl 0x831a816c
	ctx.lr = 0x825E9368;
	sub_831A8130(ctx, base);
	// 825E9368: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E936C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9370: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E9374: 3BBF0120  addi r29, r31, 0x120
	ctx.r[29].s64 = ctx.r[31].s64 + 288;
	// 825E9378: 4BF28771  bl 0x82511ae8
	ctx.lr = 0x825E937C;
	sub_82511AE8(ctx, base);
	// 825E937C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 825E9380: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E9384: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 825E9388: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E938C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E9390: 48222B01  bl 0x8280be90
	ctx.lr = 0x825E9394;
	sub_8280BE90(ctx, base);
	// 825E9394: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E9398: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E939C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E93A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E93A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825E93A8: 419A0024  beq cr6, 0x825e93cc
	if ctx.cr[6].eq {
	pc = 0x825E93CC; continue 'dispatch;
	}
	// 825E93AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E93B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E93B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E93B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E93BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E93C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E93C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E93C8: 4082FFE8  bne 0x825e93b0
	if !ctx.cr[0].eq {
	pc = 0x825E93B0; continue 'dispatch;
	}
	// 825E93CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E93D0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825E93D4: 48A1ED55  bl 0x83008128
	ctx.lr = 0x825E93D8;
	sub_83008128(ctx, base);
	// 825E93D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E93DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825E93E0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825E93E4: 388AFCA0  addi r4, r10, -0x360
	ctx.r[4].s64 = ctx.r[10].s64 + -864;
	// 825E93E8: 38A000F6  li r5, 0xf6
	ctx.r[5].s64 = 246;
	// 825E93EC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825E93F0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E93F4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825E93F8: 4886F649  bl 0x82e58a40
	ctx.lr = 0x825E93FC;
	sub_82E58A40(ctx, base);
	// 825E93FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E9400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9404: 419A0008  beq cr6, 0x825e940c
	if ctx.cr[6].eq {
	pc = 0x825E940C; continue 'dispatch;
	}
	// 825E9408: 4BCD7489  bl 0x822c0890
	ctx.lr = 0x825E940C;
	sub_822C0890(ctx, base);
	// 825E940C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E9410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9414: 419A0008  beq cr6, 0x825e941c
	if ctx.cr[6].eq {
	pc = 0x825E941C; continue 'dispatch;
	}
	// 825E9418: 4BCD7479  bl 0x822c0890
	ctx.lr = 0x825E941C;
	sub_822C0890(ctx, base);
	// 825E941C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E9420: 48BBED9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E9428 size=108
    let mut pc: u32 = 0x825E9428;
    'dispatch: loop {
        match pc {
            0x825E9428 => {
    //   block [0x825E9428..0x825E9494)
	// 825E9428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E942C: 48BBED41  bl 0x831a816c
	ctx.lr = 0x825E9430;
	sub_831A8130(ctx, base);
	// 825E9430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9434: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E9438: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825E943C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E9440: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9444: 41820038  beq 0x825e947c
	if ctx.cr[0].eq {
	pc = 0x825E947C; continue 'dispatch;
	}
	// 825E9448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E944C: 48BC053D  bl 0x831a9988
	ctx.lr = 0x825E9450;
	sub_831A9988(ctx, base);
	// 825E9450: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825E9454: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E9458: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825E945C: 48BBEC9D  bl 0x831a80f8
	ctx.lr = 0x825E9460;
	sub_831A80F8(ctx, base);
	// 825E9460: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9464: 41820018  beq 0x825e947c
	if ctx.cr[0].eq {
	pc = 0x825E947C; continue 'dispatch;
	}
	// 825E9468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E946C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 825E9470: 4BFFFEF1  bl 0x825e9360
	ctx.lr = 0x825E9474;
	sub_825E9360(ctx, base);
	// 825E9474: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825E9478: 48000014  b 0x825e948c
	pc = 0x825E948C; continue 'dispatch;
	// 825E947C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825E9480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9484: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825E9488: 4BF29191  bl 0x82512618
	ctx.lr = 0x825E948C;
	sub_82512618(ctx, base);
	// 825E948C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825E9490: 48BBED2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E9498 size=128
    let mut pc: u32 = 0x825E9498;
    'dispatch: loop {
        match pc {
            0x825E9498 => {
    //   block [0x825E9498..0x825E9518)
	// 825E9498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E949C: 48BBECD1  bl 0x831a816c
	ctx.lr = 0x825E94A0;
	sub_831A8130(ctx, base);
	// 825E94A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E94A4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825E94A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E94AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E94B0: 3BEB7EAC  addi r31, r11, 0x7eac
	ctx.r[31].s64 = ctx.r[11].s64 + 32428;
	// 825E94B4: 816A7EB4  lwz r11, 0x7eb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32436 as u32) ) } as u64;
	// 825E94B8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825E94BC: 40820024  bne 0x825e94e0
	if !ctx.cr[0].eq {
	pc = 0x825E94E0; continue 'dispatch;
	}
	// 825E94C0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 825E94C4: 3D00825F  lis r8, -0x7da1
	ctx.r[8].s64 = -2107703296;
	// 825E94C8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825E94CC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 825E94D0: 39088AF0  addi r8, r8, -0x7510
	ctx.r[8].s64 = ctx.r[8].s64 + -29968;
	// 825E94D4: 916A7EB4  stw r11, 0x7eb4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32436 as u32), ctx.r[11].u32 ) };
	// 825E94D8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825E94DC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825E94E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E94E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825E94E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E94EC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825E94F0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825E94F4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E94F8: 4806B0C9  bl 0x826545c0
	ctx.lr = 0x825E94FC;
	sub_826545C0(ctx, base);
	// 825E94FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9500: 4182000C  beq 0x825e950c
	if ctx.cr[0].eq {
	pc = 0x825E950C; continue 'dispatch;
	}
	// 825E9504: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9508: 48000008  b 0x825e9510
	pc = 0x825E9510; continue 'dispatch;
	// 825E950C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825E9510: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E9514: 48BBECA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E9518 size=460
    let mut pc: u32 = 0x825E9518;
    'dispatch: loop {
        match pc {
            0x825E9518 => {
    //   block [0x825E9518..0x825E96E4)
	// 825E9518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E951C: 48BBEC45  bl 0x831a8160
	ctx.lr = 0x825E9520;
	sub_831A8130(ctx, base);
	// 825E9520: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9524: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E9528: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E952C: 3BCBFCA0  addi r30, r11, -0x360
	ctx.r[30].s64 = ctx.r[11].s64 + -864;
	// 825E9530: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825E9534: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9538: 38A0004A  li r5, 0x4a
	ctx.r[5].s64 = 74;
	// 825E953C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E9540: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9544: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825E9548: 48808EA1  bl 0x82df23e8
	ctx.lr = 0x825E954C;
	sub_82DF23E8(ctx, base);
	// 825E954C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E9550: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E9554: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825E9558: 41820030  beq 0x825e9588
	if ctx.cr[0].eq {
	pc = 0x825E9588; continue 'dispatch;
	}
	// 825E955C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E9560: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825E9564: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E9568: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E956C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825E9570: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825E9574: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E9578: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E957C: 4BFFF605  bl 0x825e8b80
	ctx.lr = 0x825E9580;
	sub_825E8B80(ctx, base);
	// 825E9580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9584: 48000008  b 0x825e958c
	pc = 0x825E958C; continue 'dispatch;
	// 825E9588: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E958C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E9590: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9594: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9598: 4BFFF491  bl 0x825e8a28
	ctx.lr = 0x825E959C;
	sub_825E8A28(ctx, base);
	// 825E959C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E95A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E95A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E95A8: 4BCD6A59  bl 0x822c0000
	ctx.lr = 0x825E95AC;
	sub_822C0000(ctx, base);
	// 825E95AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E95B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E95B4: 38A0004B  li r5, 0x4b
	ctx.r[5].s64 = 75;
	// 825E95B8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E95BC: 4BCD6E1D  bl 0x822c03d8
	ctx.lr = 0x825E95C0;
	sub_822C03D8(ctx, base);
	// 825E95C0: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E95C4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E95C8: 418200B0  beq 0x825e9678
	if ctx.cr[0].eq {
	pc = 0x825E9678; continue 'dispatch;
	}
	// 825E95CC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E95D0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825E95D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E95D8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E95DC: 409A0008  bne cr6, 0x825e95e4
	if !ctx.cr[6].eq {
	pc = 0x825E95E4; continue 'dispatch;
	}
	// 825E95E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E95E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E95E8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E95EC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825E95F0: 419A0024  beq cr6, 0x825e9614
	if ctx.cr[6].eq {
	pc = 0x825E9614; continue 'dispatch;
	}
	// 825E95F4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E95F8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E95FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9600: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E9604: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E9608: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E960C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9610: 4082FFE8  bne 0x825e95f8
	if !ctx.cr[0].eq {
	pc = 0x825E95F8; continue 'dispatch;
	}
	// 825E9614: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E9618: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E961C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825E9620: 419A0024  beq cr6, 0x825e9644
	if ctx.cr[6].eq {
	pc = 0x825E9644; continue 'dispatch;
	}
	// 825E9624: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E9628: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E962C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9630: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E9634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E9638: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E963C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9640: 4082FFE8  bne 0x825e9628
	if !ctx.cr[0].eq {
	pc = 0x825E9628; continue 'dispatch;
	}
	// 825E9644: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E9648: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E964C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E9650: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E9654: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E9658: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E965C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E9660: 481AF8D1  bl 0x82798f30
	ctx.lr = 0x825E9664;
	sub_82798F30(ctx, base);
	// 825E9664: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E9668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E966C: 481B1FFD  bl 0x8279b668
	ctx.lr = 0x825E9670;
	sub_8279B668(ctx, base);
	// 825E9670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9674: 48000008  b 0x825e967c
	pc = 0x825E967C; continue 'dispatch;
	// 825E9678: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E967C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9680: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825E9684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E968C: 4BFAE5C5  bl 0x82597c50
	ctx.lr = 0x825E9690;
	sub_82597C50(ctx, base);
	// 825E9690: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9694: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E969C: 4BCD6965  bl 0x822c0000
	ctx.lr = 0x825E96A0;
	sub_822C0000(ctx, base);
	// 825E96A0: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E96A4: 41820024  beq 0x825e96c8
	if ctx.cr[0].eq {
	pc = 0x825E96C8; continue 'dispatch;
	}
	// 825E96A8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E96AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E96B0: 419A0008  beq cr6, 0x825e96b8
	if ctx.cr[6].eq {
	pc = 0x825E96B8; continue 'dispatch;
	}
	// 825E96B4: 4BCD71DD  bl 0x822c0890
	ctx.lr = 0x825E96B8;
	sub_822C0890(ctx, base);
	// 825E96B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E96BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E96C0: 419A0008  beq cr6, 0x825e96c8
	if ctx.cr[6].eq {
	pc = 0x825E96C8; continue 'dispatch;
	}
	// 825E96C4: 4BCD71CD  bl 0x822c0890
	ctx.lr = 0x825E96C8;
	sub_822C0890(ctx, base);
	// 825E96C8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E96CC: 419A000C  beq cr6, 0x825e96d8
	if ctx.cr[6].eq {
	pc = 0x825E96D8; continue 'dispatch;
	}
	// 825E96D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E96D4: 4BCD71BD  bl 0x822c0890
	ctx.lr = 0x825E96D8;
	sub_822C0890(ctx, base);
	// 825E96D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825E96DC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825E96E0: 48BBEAD0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E96E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E96E8 size=460
    let mut pc: u32 = 0x825E96E8;
    'dispatch: loop {
        match pc {
            0x825E96E8 => {
    //   block [0x825E96E8..0x825E98B4)
	// 825E96E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E96EC: 48BBEA75  bl 0x831a8160
	ctx.lr = 0x825E96F0;
	sub_831A8130(ctx, base);
	// 825E96F0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E96F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E96F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E96FC: 3BCBFCA0  addi r30, r11, -0x360
	ctx.r[30].s64 = ctx.r[11].s64 + -864;
	// 825E9700: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825E9704: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9708: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 825E970C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E9710: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9714: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825E9718: 48808CD1  bl 0x82df23e8
	ctx.lr = 0x825E971C;
	sub_82DF23E8(ctx, base);
	// 825E971C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E9720: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E9724: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825E9728: 41820030  beq 0x825e9758
	if ctx.cr[0].eq {
	pc = 0x825E9758; continue 'dispatch;
	}
	// 825E972C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825E9730: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825E9734: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E9738: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E973C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825E9740: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825E9744: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E9748: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E974C: 4BFFF435  bl 0x825e8b80
	ctx.lr = 0x825E9750;
	sub_825E8B80(ctx, base);
	// 825E9750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9754: 48000008  b 0x825e975c
	pc = 0x825E975C; continue 'dispatch;
	// 825E9758: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E975C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E9760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9764: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9768: 4BFFF2C1  bl 0x825e8a28
	ctx.lr = 0x825E976C;
	sub_825E8A28(ctx, base);
	// 825E976C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9770: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9774: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9778: 4BCD6889  bl 0x822c0000
	ctx.lr = 0x825E977C;
	sub_822C0000(ctx, base);
	// 825E977C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9780: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9784: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 825E9788: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E978C: 4BCD6C4D  bl 0x822c03d8
	ctx.lr = 0x825E9790;
	sub_822C03D8(ctx, base);
	// 825E9790: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E9794: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E9798: 418200B0  beq 0x825e9848
	if ctx.cr[0].eq {
	pc = 0x825E9848; continue 'dispatch;
	}
	// 825E979C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E97A0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825E97A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E97A8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E97AC: 409A0008  bne cr6, 0x825e97b4
	if !ctx.cr[6].eq {
	pc = 0x825E97B4; continue 'dispatch;
	}
	// 825E97B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E97B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E97B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E97BC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825E97C0: 419A0024  beq cr6, 0x825e97e4
	if ctx.cr[6].eq {
	pc = 0x825E97E4; continue 'dispatch;
	}
	// 825E97C4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E97C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E97CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E97D0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E97D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E97D8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E97DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E97E0: 4082FFE8  bne 0x825e97c8
	if !ctx.cr[0].eq {
	pc = 0x825E97C8; continue 'dispatch;
	}
	// 825E97E4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E97E8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E97EC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825E97F0: 419A0024  beq cr6, 0x825e9814
	if ctx.cr[6].eq {
	pc = 0x825E9814; continue 'dispatch;
	}
	// 825E97F4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E97F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E97FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9800: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E9804: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E9808: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E980C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9810: 4082FFE8  bne 0x825e97f8
	if !ctx.cr[0].eq {
	pc = 0x825E97F8; continue 'dispatch;
	}
	// 825E9814: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E9818: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E981C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E9820: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E9824: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E9828: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E982C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E9830: 481AF701  bl 0x82798f30
	ctx.lr = 0x825E9834;
	sub_82798F30(ctx, base);
	// 825E9834: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E9838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E983C: 481B1E2D  bl 0x8279b668
	ctx.lr = 0x825E9840;
	sub_8279B668(ctx, base);
	// 825E9840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9844: 48000008  b 0x825e984c
	pc = 0x825E984C; continue 'dispatch;
	// 825E9848: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E984C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9850: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825E9854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9858: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E985C: 4BFAE3F5  bl 0x82597c50
	ctx.lr = 0x825E9860;
	sub_82597C50(ctx, base);
	// 825E9860: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9864: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9868: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E986C: 4BCD6795  bl 0x822c0000
	ctx.lr = 0x825E9870;
	sub_822C0000(ctx, base);
	// 825E9870: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9874: 41820024  beq 0x825e9898
	if ctx.cr[0].eq {
	pc = 0x825E9898; continue 'dispatch;
	}
	// 825E9878: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E987C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9880: 419A0008  beq cr6, 0x825e9888
	if ctx.cr[6].eq {
	pc = 0x825E9888; continue 'dispatch;
	}
	// 825E9884: 4BCD700D  bl 0x822c0890
	ctx.lr = 0x825E9888;
	sub_822C0890(ctx, base);
	// 825E9888: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E988C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9890: 419A0008  beq cr6, 0x825e9898
	if ctx.cr[6].eq {
	pc = 0x825E9898; continue 'dispatch;
	}
	// 825E9894: 4BCD6FFD  bl 0x822c0890
	ctx.lr = 0x825E9898;
	sub_822C0890(ctx, base);
	// 825E9898: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E989C: 419A000C  beq cr6, 0x825e98a8
	if ctx.cr[6].eq {
	pc = 0x825E98A8; continue 'dispatch;
	}
	// 825E98A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E98A4: 4BCD6FED  bl 0x822c0890
	ctx.lr = 0x825E98A8;
	sub_822C0890(ctx, base);
	// 825E98A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825E98AC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825E98B0: 48BBE900  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E98B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E98B8 size=460
    let mut pc: u32 = 0x825E98B8;
    'dispatch: loop {
        match pc {
            0x825E98B8 => {
    //   block [0x825E98B8..0x825E9A84)
	// 825E98B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E98BC: 48BBE8A5  bl 0x831a8160
	ctx.lr = 0x825E98C0;
	sub_831A8130(ctx, base);
	// 825E98C0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E98C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E98C8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E98CC: 3BCBFCA0  addi r30, r11, -0x360
	ctx.r[30].s64 = ctx.r[11].s64 + -864;
	// 825E98D0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825E98D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E98D8: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 825E98DC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E98E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E98E4: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825E98E8: 48808B01  bl 0x82df23e8
	ctx.lr = 0x825E98EC;
	sub_82DF23E8(ctx, base);
	// 825E98EC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E98F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E98F4: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825E98F8: 41820030  beq 0x825e9928
	if ctx.cr[0].eq {
	pc = 0x825E9928; continue 'dispatch;
	}
	// 825E98FC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E9900: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825E9904: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E9908: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E990C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825E9910: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825E9914: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825E9918: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E991C: 4BFFF265  bl 0x825e8b80
	ctx.lr = 0x825E9920;
	sub_825E8B80(ctx, base);
	// 825E9920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9924: 48000008  b 0x825e992c
	pc = 0x825E992C; continue 'dispatch;
	// 825E9928: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E992C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E9930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9934: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9938: 4BFFF0F1  bl 0x825e8a28
	ctx.lr = 0x825E993C;
	sub_825E8A28(ctx, base);
	// 825E993C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9944: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9948: 4BCD66B9  bl 0x822c0000
	ctx.lr = 0x825E994C;
	sub_822C0000(ctx, base);
	// 825E994C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9950: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9954: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 825E9958: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E995C: 4BCD6A7D  bl 0x822c03d8
	ctx.lr = 0x825E9960;
	sub_822C03D8(ctx, base);
	// 825E9960: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E9964: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E9968: 418200B0  beq 0x825e9a18
	if ctx.cr[0].eq {
	pc = 0x825E9A18; continue 'dispatch;
	}
	// 825E996C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E9970: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825E9974: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E9978: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E997C: 409A0008  bne cr6, 0x825e9984
	if !ctx.cr[6].eq {
	pc = 0x825E9984; continue 'dispatch;
	}
	// 825E9980: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E9984: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E9988: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E998C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825E9990: 419A0024  beq cr6, 0x825e99b4
	if ctx.cr[6].eq {
	pc = 0x825E99B4; continue 'dispatch;
	}
	// 825E9994: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E9998: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E999C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E99A0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E99A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E99A8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E99AC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E99B0: 4082FFE8  bne 0x825e9998
	if !ctx.cr[0].eq {
	pc = 0x825E9998; continue 'dispatch;
	}
	// 825E99B4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E99B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E99BC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825E99C0: 419A0024  beq cr6, 0x825e99e4
	if ctx.cr[6].eq {
	pc = 0x825E99E4; continue 'dispatch;
	}
	// 825E99C4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E99C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E99CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E99D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E99D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E99D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E99DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E99E0: 4082FFE8  bne 0x825e99c8
	if !ctx.cr[0].eq {
	pc = 0x825E99C8; continue 'dispatch;
	}
	// 825E99E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E99E8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E99EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E99F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E99F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E99F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E99FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E9A00: 481AF531  bl 0x82798f30
	ctx.lr = 0x825E9A04;
	sub_82798F30(ctx, base);
	// 825E9A04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E9A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E9A0C: 481B1C5D  bl 0x8279b668
	ctx.lr = 0x825E9A10;
	sub_8279B668(ctx, base);
	// 825E9A10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9A14: 48000008  b 0x825e9a1c
	pc = 0x825E9A1C; continue 'dispatch;
	// 825E9A18: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E9A1C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9A20: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825E9A24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E9A2C: 4BFAE225  bl 0x82597c50
	ctx.lr = 0x825E9A30;
	sub_82597C50(ctx, base);
	// 825E9A30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9A34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E9A3C: 4BCD65C5  bl 0x822c0000
	ctx.lr = 0x825E9A40;
	sub_822C0000(ctx, base);
	// 825E9A40: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9A44: 41820024  beq 0x825e9a68
	if ctx.cr[0].eq {
	pc = 0x825E9A68; continue 'dispatch;
	}
	// 825E9A48: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E9A4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9A50: 419A0008  beq cr6, 0x825e9a58
	if ctx.cr[6].eq {
	pc = 0x825E9A58; continue 'dispatch;
	}
	// 825E9A54: 4BCD6E3D  bl 0x822c0890
	ctx.lr = 0x825E9A58;
	sub_822C0890(ctx, base);
	// 825E9A58: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E9A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9A60: 419A0008  beq cr6, 0x825e9a68
	if ctx.cr[6].eq {
	pc = 0x825E9A68; continue 'dispatch;
	}
	// 825E9A64: 4BCD6E2D  bl 0x822c0890
	ctx.lr = 0x825E9A68;
	sub_822C0890(ctx, base);
	// 825E9A68: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9A6C: 419A000C  beq cr6, 0x825e9a78
	if ctx.cr[6].eq {
	pc = 0x825E9A78; continue 'dispatch;
	}
	// 825E9A70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E9A74: 4BCD6E1D  bl 0x822c0890
	ctx.lr = 0x825E9A78;
	sub_822C0890(ctx, base);
	// 825E9A78: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825E9A7C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825E9A80: 48BBE730  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E9A88 size=460
    let mut pc: u32 = 0x825E9A88;
    'dispatch: loop {
        match pc {
            0x825E9A88 => {
    //   block [0x825E9A88..0x825E9C54)
	// 825E9A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E9A8C: 48BBE6D5  bl 0x831a8160
	ctx.lr = 0x825E9A90;
	sub_831A8130(ctx, base);
	// 825E9A90: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9A94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E9A98: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E9A9C: 3BCBFCA0  addi r30, r11, -0x360
	ctx.r[30].s64 = ctx.r[11].s64 + -864;
	// 825E9AA0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825E9AA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9AA8: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 825E9AAC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E9AB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9AB4: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825E9AB8: 48808931  bl 0x82df23e8
	ctx.lr = 0x825E9ABC;
	sub_82DF23E8(ctx, base);
	// 825E9ABC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E9AC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E9AC4: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825E9AC8: 41820030  beq 0x825e9af8
	if ctx.cr[0].eq {
	pc = 0x825E9AF8; continue 'dispatch;
	}
	// 825E9ACC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825E9AD0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825E9AD4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E9AD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E9ADC: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825E9AE0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825E9AE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825E9AE8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E9AEC: 4BFFF095  bl 0x825e8b80
	ctx.lr = 0x825E9AF0;
	sub_825E8B80(ctx, base);
	// 825E9AF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9AF4: 48000008  b 0x825e9afc
	pc = 0x825E9AFC; continue 'dispatch;
	// 825E9AF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E9AFC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E9B00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9B04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9B08: 4BFFEF21  bl 0x825e8a28
	ctx.lr = 0x825E9B0C;
	sub_825E8A28(ctx, base);
	// 825E9B0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9B10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9B14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9B18: 4BCD64E9  bl 0x822c0000
	ctx.lr = 0x825E9B1C;
	sub_822C0000(ctx, base);
	// 825E9B1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9B20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9B24: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 825E9B28: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E9B2C: 4BCD68AD  bl 0x822c03d8
	ctx.lr = 0x825E9B30;
	sub_822C03D8(ctx, base);
	// 825E9B30: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E9B34: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E9B38: 418200B0  beq 0x825e9be8
	if ctx.cr[0].eq {
	pc = 0x825E9BE8; continue 'dispatch;
	}
	// 825E9B3C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E9B40: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825E9B44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E9B48: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E9B4C: 409A0008  bne cr6, 0x825e9b54
	if !ctx.cr[6].eq {
	pc = 0x825E9B54; continue 'dispatch;
	}
	// 825E9B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E9B54: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E9B58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9B5C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825E9B60: 419A0024  beq cr6, 0x825e9b84
	if ctx.cr[6].eq {
	pc = 0x825E9B84; continue 'dispatch;
	}
	// 825E9B64: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E9B68: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E9B6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9B70: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E9B74: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E9B78: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E9B7C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9B80: 4082FFE8  bne 0x825e9b68
	if !ctx.cr[0].eq {
	pc = 0x825E9B68; continue 'dispatch;
	}
	// 825E9B84: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E9B88: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9B8C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825E9B90: 419A0024  beq cr6, 0x825e9bb4
	if ctx.cr[6].eq {
	pc = 0x825E9BB4; continue 'dispatch;
	}
	// 825E9B94: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E9B98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E9B9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9BA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E9BA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E9BA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E9BAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9BB0: 4082FFE8  bne 0x825e9b98
	if !ctx.cr[0].eq {
	pc = 0x825E9B98; continue 'dispatch;
	}
	// 825E9BB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E9BB8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E9BBC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E9BC0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E9BC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E9BC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E9BCC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E9BD0: 481AF361  bl 0x82798f30
	ctx.lr = 0x825E9BD4;
	sub_82798F30(ctx, base);
	// 825E9BD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E9BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E9BDC: 481B1A8D  bl 0x8279b668
	ctx.lr = 0x825E9BE0;
	sub_8279B668(ctx, base);
	// 825E9BE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9BE4: 48000008  b 0x825e9bec
	pc = 0x825E9BEC; continue 'dispatch;
	// 825E9BE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E9BEC: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9BF0: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825E9BF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9BF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E9BFC: 4BFAE055  bl 0x82597c50
	ctx.lr = 0x825E9C00;
	sub_82597C50(ctx, base);
	// 825E9C00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9C04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9C08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E9C0C: 4BCD63F5  bl 0x822c0000
	ctx.lr = 0x825E9C10;
	sub_822C0000(ctx, base);
	// 825E9C10: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9C14: 41820024  beq 0x825e9c38
	if ctx.cr[0].eq {
	pc = 0x825E9C38; continue 'dispatch;
	}
	// 825E9C18: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E9C1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9C20: 419A0008  beq cr6, 0x825e9c28
	if ctx.cr[6].eq {
	pc = 0x825E9C28; continue 'dispatch;
	}
	// 825E9C24: 4BCD6C6D  bl 0x822c0890
	ctx.lr = 0x825E9C28;
	sub_822C0890(ctx, base);
	// 825E9C28: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E9C2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9C30: 419A0008  beq cr6, 0x825e9c38
	if ctx.cr[6].eq {
	pc = 0x825E9C38; continue 'dispatch;
	}
	// 825E9C34: 4BCD6C5D  bl 0x822c0890
	ctx.lr = 0x825E9C38;
	sub_822C0890(ctx, base);
	// 825E9C38: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9C3C: 419A000C  beq cr6, 0x825e9c48
	if ctx.cr[6].eq {
	pc = 0x825E9C48; continue 'dispatch;
	}
	// 825E9C40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E9C44: 4BCD6C4D  bl 0x822c0890
	ctx.lr = 0x825E9C48;
	sub_822C0890(ctx, base);
	// 825E9C48: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825E9C4C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825E9C50: 48BBE560  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E9C58 size=460
    let mut pc: u32 = 0x825E9C58;
    'dispatch: loop {
        match pc {
            0x825E9C58 => {
    //   block [0x825E9C58..0x825E9E24)
	// 825E9C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E9C5C: 48BBE505  bl 0x831a8160
	ctx.lr = 0x825E9C60;
	sub_831A8130(ctx, base);
	// 825E9C60: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9C64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E9C68: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E9C6C: 3BCBFCA0  addi r30, r11, -0x360
	ctx.r[30].s64 = ctx.r[11].s64 + -864;
	// 825E9C70: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825E9C74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9C78: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 825E9C7C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825E9C80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9C84: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825E9C88: 48808761  bl 0x82df23e8
	ctx.lr = 0x825E9C8C;
	sub_82DF23E8(ctx, base);
	// 825E9C8C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825E9C90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825E9C94: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825E9C98: 41820030  beq 0x825e9cc8
	if ctx.cr[0].eq {
	pc = 0x825E9CC8; continue 'dispatch;
	}
	// 825E9C9C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825E9CA0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825E9CA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E9CA8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825E9CAC: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825E9CB0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825E9CB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825E9CB8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E9CBC: 4BFFEEC5  bl 0x825e8b80
	ctx.lr = 0x825E9CC0;
	sub_825E8B80(ctx, base);
	// 825E9CC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9CC4: 48000008  b 0x825e9ccc
	pc = 0x825E9CCC; continue 'dispatch;
	// 825E9CC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E9CCC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825E9CD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9CD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9CD8: 4BFFED51  bl 0x825e8a28
	ctx.lr = 0x825E9CDC;
	sub_825E8A28(ctx, base);
	// 825E9CDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9CE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9CE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825E9CE8: 4BCD6319  bl 0x822c0000
	ctx.lr = 0x825E9CEC;
	sub_822C0000(ctx, base);
	// 825E9CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825E9CF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E9CF4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825E9CF8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825E9CFC: 4BCD66DD  bl 0x822c03d8
	ctx.lr = 0x825E9D00;
	sub_822C03D8(ctx, base);
	// 825E9D00: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825E9D04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E9D08: 418200B0  beq 0x825e9db8
	if ctx.cr[0].eq {
	pc = 0x825E9DB8; continue 'dispatch;
	}
	// 825E9D0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E9D10: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825E9D14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E9D18: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825E9D1C: 409A0008  bne cr6, 0x825e9d24
	if !ctx.cr[6].eq {
	pc = 0x825E9D24; continue 'dispatch;
	}
	// 825E9D20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E9D24: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E9D28: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9D2C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825E9D30: 419A0024  beq cr6, 0x825e9d54
	if ctx.cr[6].eq {
	pc = 0x825E9D54; continue 'dispatch;
	}
	// 825E9D34: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E9D38: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825E9D3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9D40: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825E9D44: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825E9D48: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E9D4C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9D50: 4082FFE8  bne 0x825e9d38
	if !ctx.cr[0].eq {
	pc = 0x825E9D38; continue 'dispatch;
	}
	// 825E9D54: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E9D58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9D5C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825E9D60: 419A0024  beq cr6, 0x825e9d84
	if ctx.cr[6].eq {
	pc = 0x825E9D84; continue 'dispatch;
	}
	// 825E9D64: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825E9D68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825E9D6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9D70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825E9D74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E9D78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825E9D7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825E9D80: 4082FFE8  bne 0x825e9d68
	if !ctx.cr[0].eq {
	pc = 0x825E9D68; continue 'dispatch;
	}
	// 825E9D84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E9D88: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825E9D8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E9D90: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825E9D94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825E9D98: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825E9D9C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825E9DA0: 481AF191  bl 0x82798f30
	ctx.lr = 0x825E9DA4;
	sub_82798F30(ctx, base);
	// 825E9DA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825E9DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E9DAC: 481B18BD  bl 0x8279b668
	ctx.lr = 0x825E9DB0;
	sub_8279B668(ctx, base);
	// 825E9DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9DB4: 48000008  b 0x825e9dbc
	pc = 0x825E9DBC; continue 'dispatch;
	// 825E9DB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825E9DBC: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9DC0: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825E9DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9DC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E9DCC: 4BFADE85  bl 0x82597c50
	ctx.lr = 0x825E9DD0;
	sub_82597C50(ctx, base);
	// 825E9DD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825E9DD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825E9DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825E9DDC: 4BCD6225  bl 0x822c0000
	ctx.lr = 0x825E9DE0;
	sub_822C0000(ctx, base);
	// 825E9DE0: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9DE4: 41820024  beq 0x825e9e08
	if ctx.cr[0].eq {
	pc = 0x825E9E08; continue 'dispatch;
	}
	// 825E9DE8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825E9DEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9DF0: 419A0008  beq cr6, 0x825e9df8
	if ctx.cr[6].eq {
	pc = 0x825E9DF8; continue 'dispatch;
	}
	// 825E9DF4: 4BCD6A9D  bl 0x822c0890
	ctx.lr = 0x825E9DF8;
	sub_822C0890(ctx, base);
	// 825E9DF8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825E9DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E9E00: 419A0008  beq cr6, 0x825e9e08
	if ctx.cr[6].eq {
	pc = 0x825E9E08; continue 'dispatch;
	}
	// 825E9E04: 4BCD6A8D  bl 0x822c0890
	ctx.lr = 0x825E9E08;
	sub_822C0890(ctx, base);
	// 825E9E08: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825E9E0C: 419A000C  beq cr6, 0x825e9e18
	if ctx.cr[6].eq {
	pc = 0x825E9E18; continue 'dispatch;
	}
	// 825E9E10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825E9E14: 4BCD6A7D  bl 0x822c0890
	ctx.lr = 0x825E9E18;
	sub_822C0890(ctx, base);
	// 825E9E18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825E9E1C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825E9E20: 48BBE390  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E9E28 size=128
    let mut pc: u32 = 0x825E9E28;
    'dispatch: loop {
        match pc {
            0x825E9E28 => {
    //   block [0x825E9E28..0x825E9EA8)
	// 825E9E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E9E2C: 48BBE341  bl 0x831a816c
	ctx.lr = 0x825E9E30;
	sub_831A8130(ctx, base);
	// 825E9E30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9E34: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825E9E38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825E9E3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825E9E40: 3BEB7EB8  addi r31, r11, 0x7eb8
	ctx.r[31].s64 = ctx.r[11].s64 + 32440;
	// 825E9E44: 816A7EC0  lwz r11, 0x7ec0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32448 as u32) ) } as u64;
	// 825E9E48: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825E9E4C: 40820024  bne 0x825e9e70
	if !ctx.cr[0].eq {
	pc = 0x825E9E70; continue 'dispatch;
	}
	// 825E9E50: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 825E9E54: 3D00825F  lis r8, -0x7da1
	ctx.r[8].s64 = -2107703296;
	// 825E9E58: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825E9E5C: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 825E9E60: 39088B38  addi r8, r8, -0x74c8
	ctx.r[8].s64 = ctx.r[8].s64 + -29896;
	// 825E9E64: 916A7EC0  stw r11, 0x7ec0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32448 as u32), ctx.r[11].u32 ) };
	// 825E9E68: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825E9E6C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825E9E70: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825E9E74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825E9E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E9E7C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825E9E80: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825E9E84: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825E9E88: 4806A739  bl 0x826545c0
	ctx.lr = 0x825E9E8C;
	sub_826545C0(ctx, base);
	// 825E9E8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E9E90: 4182000C  beq 0x825e9e9c
	if ctx.cr[0].eq {
	pc = 0x825E9E9C; continue 'dispatch;
	}
	// 825E9E94: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825E9E98: 48000008  b 0x825e9ea0
	pc = 0x825E9EA0; continue 'dispatch;
	// 825E9E9C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825E9EA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825E9EA4: 48BBE318  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E9EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E9EA8 size=1124
    let mut pc: u32 = 0x825E9EA8;
    'dispatch: loop {
        match pc {
            0x825E9EA8 => {
    //   block [0x825E9EA8..0x825EA30C)
	// 825E9EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E9EAC: 48BBE2B5  bl 0x831a8160
	ctx.lr = 0x825E9EB0;
	sub_831A8130(ctx, base);
	// 825E9EB0: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 825E9EB4: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825E9EB8: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E9EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E9EC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825E9EC4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825E9EC8: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 825E9ECC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E9ED0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 825E9ED4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825E9ED8: 419A0100  beq cr6, 0x825e9fd8
	if ctx.cr[6].eq {
	pc = 0x825E9FD8; continue 'dispatch;
	}
	// 825E9EDC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825E9EE0: 409A041C  bne cr6, 0x825ea2fc
	if !ctx.cr[6].eq {
	pc = 0x825EA2FC; continue 'dispatch;
	}
	// 825E9EE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E9EE8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825E9EEC: 388BFD70  addi r4, r11, -0x290
	ctx.r[4].s64 = ctx.r[11].s64 + -656;
	// 825E9EF0: 48809B19  bl 0x82df3a08
	ctx.lr = 0x825E9EF4;
	sub_82DF3A08(ctx, base);
	// 825E9EF4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825E9EF8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E9EFC: 388BCACC  addi r4, r11, -0x3534
	ctx.r[4].s64 = ctx.r[11].s64 + -13620;
	// 825E9F00: 48809B09  bl 0x82df3a08
	ctx.lr = 0x825E9F04;
	sub_82DF3A08(ctx, base);
	// 825E9F04: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E9F08: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825E9F0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825E9F10: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 825E9F14: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825E9F18: C3EA9F64  lfs f31, -0x609c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E9F1C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825E9F20: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825E9F24: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825E9F28: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E9F2C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825E9F30: 4BFB9379  bl 0x825a32a8
	ctx.lr = 0x825E9F34;
	sub_825A32A8(ctx, base);
	// 825E9F34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E9F38: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825E9F3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E9F40: 4BFB7831  bl 0x825a1770
	ctx.lr = 0x825E9F44;
	sub_825A1770(ctx, base);
	// 825E9F44: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825E9F48: 488094E1  bl 0x82df3428
	ctx.lr = 0x825E9F4C;
	sub_82DF3428(ctx, base);
	// 825E9F4C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825E9F50: 4BCDED69  bl 0x822c8cb8
	ctx.lr = 0x825E9F54;
	sub_822C8CB8(ctx, base);
	// 825E9F54: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825E9F58: 488094D1  bl 0x82df3428
	ctx.lr = 0x825E9F5C;
	sub_82DF3428(ctx, base);
	// 825E9F5C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825E9F60: 488094C9  bl 0x82df3428
	ctx.lr = 0x825E9F64;
	sub_82DF3428(ctx, base);
	// 825E9F64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825E9F68: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E9F6C: 388BFD50  addi r4, r11, -0x2b0
	ctx.r[4].s64 = ctx.r[11].s64 + -688;
	// 825E9F70: 48809A99  bl 0x82df3a08
	ctx.lr = 0x825E9F74;
	sub_82DF3A08(ctx, base);
	// 825E9F74: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825E9F78: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825E9F7C: 388B8FF4  addi r4, r11, -0x700c
	ctx.r[4].s64 = ctx.r[11].s64 + -28684;
	// 825E9F80: 48809A89  bl 0x82df3a08
	ctx.lr = 0x825E9F84;
	sub_82DF3A08(ctx, base);
	// 825E9F84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825E9F88: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 825E9F8C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825E9F90: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825E9F94: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825E9F98: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 825E9F9C: C06B89AC  lfs f3, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E9FA0: 4BFB9309  bl 0x825a32a8
	ctx.lr = 0x825E9FA4;
	sub_825A32A8(ctx, base);
	// 825E9FA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825E9FA8: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 825E9FAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825E9FB0: 4BFB77C1  bl 0x825a1770
	ctx.lr = 0x825E9FB4;
	sub_825A1770(ctx, base);
	// 825E9FB4: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 825E9FB8: 48809471  bl 0x82df3428
	ctx.lr = 0x825E9FBC;
	sub_82DF3428(ctx, base);
	// 825E9FBC: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 825E9FC0: 4BCDECF9  bl 0x822c8cb8
	ctx.lr = 0x825E9FC4;
	sub_822C8CB8(ctx, base);
	// 825E9FC4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825E9FC8: 48809461  bl 0x82df3428
	ctx.lr = 0x825E9FCC;
	sub_82DF3428(ctx, base);
	// 825E9FCC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825E9FD0: 48809459  bl 0x82df3428
	ctx.lr = 0x825E9FD4;
	sub_82DF3428(ctx, base);
	// 825E9FD4: 48000328  b 0x825ea2fc
	pc = 0x825EA2FC; continue 'dispatch;
	// 825E9FD8: 3D60825F  lis r11, -0x7da1
	ctx.r[11].s64 = -2107703296;
	// 825E9FDC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825E9FE0: 3BBFFF1C  addi r29, r31, -0xe4
	ctx.r[29].s64 = ctx.r[31].s64 + -228;
	// 825E9FE4: 93C100D0  stw r30, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 825E9FE8: 396B86C8  addi r11, r11, -0x7938
	ctx.r[11].s64 = ctx.r[11].s64 + -31032;
	// 825E9FEC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825E9FF0: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 825E9FF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825E9FF8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825E9FFC: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 825EA000: 4BFFF499  bl 0x825e9498
	ctx.lr = 0x825EA004;
	sub_825E9498(ctx, base);
	// 825EA004: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA008: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825EA00C: 388BFD38  addi r4, r11, -0x2c8
	ctx.r[4].s64 = ctx.r[11].s64 + -712;
	// 825EA010: 488099F9  bl 0x82df3a08
	ctx.lr = 0x825EA014;
	sub_82DF3A08(ctx, base);
	// 825EA014: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825EA018: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EA01C: 388BCACC  addi r4, r11, -0x3534
	ctx.r[4].s64 = ctx.r[11].s64 + -13620;
	// 825EA020: 488099E9  bl 0x82df3a08
	ctx.lr = 0x825EA024;
	sub_82DF3A08(ctx, base);
	// 825EA024: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825EA028: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EA02C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EA030: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 825EA034: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 825EA038: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825EA03C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 825EA040: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825EA044: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825EA048: C04A9F64  lfs f2, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825EA04C: 4BFB925D  bl 0x825a32a8
	ctx.lr = 0x825EA050;
	sub_825A32A8(ctx, base);
	// 825EA050: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EA054: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EA058: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825EA05C: 4BFB7715  bl 0x825a1770
	ctx.lr = 0x825EA060;
	sub_825A1770(ctx, base);
	// 825EA060: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 825EA064: 488093C5  bl 0x82df3428
	ctx.lr = 0x825EA068;
	sub_82DF3428(ctx, base);
	// 825EA068: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825EA06C: 4BCDEC4D  bl 0x822c8cb8
	ctx.lr = 0x825EA070;
	sub_822C8CB8(ctx, base);
	// 825EA070: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EA074: 488093B5  bl 0x82df3428
	ctx.lr = 0x825EA078;
	sub_82DF3428(ctx, base);
	// 825EA078: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825EA07C: 488093AD  bl 0x82df3428
	ctx.lr = 0x825EA080;
	sub_82DF3428(ctx, base);
	// 825EA080: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA084: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825EA088: 388BFD24  addi r4, r11, -0x2dc
	ctx.r[4].s64 = ctx.r[11].s64 + -732;
	// 825EA08C: 4880997D  bl 0x82df3a08
	ctx.lr = 0x825EA090;
	sub_82DF3A08(ctx, base);
	// 825EA090: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825EA094: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EA098: 388B8FF4  addi r4, r11, -0x700c
	ctx.r[4].s64 = ctx.r[11].s64 + -28684;
	// 825EA09C: 4880996D  bl 0x82df3a08
	ctx.lr = 0x825EA0A0;
	sub_82DF3A08(ctx, base);
	// 825EA0A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EA0A4: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825EA0A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825EA0AC: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 825EA0B0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825EA0B4: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 825EA0B8: C06B964C  lfs f3, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825EA0BC: C04AC350  lfs f2, -0x3cb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825EA0C0: 4BFB91E9  bl 0x825a32a8
	ctx.lr = 0x825EA0C4;
	sub_825A32A8(ctx, base);
	// 825EA0C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EA0C8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825EA0CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825EA0D0: 4BFB76A1  bl 0x825a1770
	ctx.lr = 0x825EA0D4;
	sub_825A1770(ctx, base);
	// 825EA0D4: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 825EA0D8: 48809351  bl 0x82df3428
	ctx.lr = 0x825EA0DC;
	sub_82DF3428(ctx, base);
	// 825EA0DC: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 825EA0E0: 4BCDEBD9  bl 0x822c8cb8
	ctx.lr = 0x825EA0E4;
	sub_822C8CB8(ctx, base);
	// 825EA0E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EA0E8: 48809341  bl 0x82df3428
	ctx.lr = 0x825EA0EC;
	sub_82DF3428(ctx, base);
	// 825EA0EC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825EA0F0: 48809339  bl 0x82df3428
	ctx.lr = 0x825EA0F4;
	sub_82DF3428(ctx, base);
	// 825EA0F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA0F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EA0FC: 388BFCA0  addi r4, r11, -0x360
	ctx.r[4].s64 = ctx.r[11].s64 + -864;
	// 825EA100: 38A00109  li r5, 0x109
	ctx.r[5].s64 = 265;
	// 825EA104: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EA108: 4BCD62D1  bl 0x822c03d8
	ctx.lr = 0x825EA10C;
	sub_822C03D8(ctx, base);
	// 825EA10C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825EA110: 41820060  beq 0x825ea170
	if ctx.cr[0].eq {
	pc = 0x825EA170; continue 'dispatch;
	}
	// 825EA114: 3D60825F  lis r11, -0x7da1
	ctx.r[11].s64 = -2107703296;
	// 825EA118: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825EA11C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EA120: 396B86C8  addi r11, r11, -0x7938
	ctx.r[11].s64 = ctx.r[11].s64 + -31032;
	// 825EA124: 388AFD18  addi r4, r10, -0x2e8
	ctx.r[4].s64 = ctx.r[10].s64 + -744;
	// 825EA128: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825EA12C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825EA130: 488098D9  bl 0x82df3a08
	ctx.lr = 0x825EA134;
	sub_82DF3A08(ctx, base);
	// 825EA134: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825EA138: 93A10098  stw r29, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 825EA13C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 825EA140: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 825EA144: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825EA148: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 825EA14C: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 825EA150: 4BFFFCD9  bl 0x825e9e28
	ctx.lr = 0x825EA154;
	sub_825E9E28(ctx, base);
	// 825EA154: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825EA158: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825EA15C: 38BF005C  addi r5, r31, 0x5c
	ctx.r[5].s64 = ctx.r[31].s64 + 92;
	// 825EA160: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825EA164: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825EA168: 4BFC2029  bl 0x825ac190
	ctx.lr = 0x825EA16C;
	sub_825AC190(ctx, base);
	// 825EA16C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EA170: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825EA174: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EA178: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EA17C: 4BF0923D  bl 0x824f33b8
	ctx.lr = 0x825EA180;
	sub_824F33B8(ctx, base);
	// 825EA180: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825EA184: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EA188: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EA18C: 4BCD5E75  bl 0x822c0000
	ctx.lr = 0x825EA190;
	sub_822C0000(ctx, base);
	// 825EA190: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EA194: 4182000C  beq 0x825ea1a0
	if ctx.cr[0].eq {
	pc = 0x825EA1A0; continue 'dispatch;
	}
	// 825EA198: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825EA19C: 4880928D  bl 0x82df3428
	ctx.lr = 0x825EA1A0;
	sub_82DF3428(ctx, base);
	// 825EA1A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA1A4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825EA1A8: 388BFBBC  addi r4, r11, -0x444
	ctx.r[4].s64 = ctx.r[11].s64 + -1092;
	// 825EA1AC: 4880985D  bl 0x82df3a08
	ctx.lr = 0x825EA1B0;
	sub_82DF3A08(ctx, base);
	// 825EA1B0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EA1B4: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 825EA1B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EA1BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EA1C0: 4BFC1C01  bl 0x825abdc0
	ctx.lr = 0x825EA1C4;
	sub_825ABDC0(ctx, base);
	// 825EA1C4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825EA1C8: 48809261  bl 0x82df3428
	ctx.lr = 0x825EA1CC;
	sub_82DF3428(ctx, base);
	// 825EA1CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA1D0: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 825EA1D4: 388BFBB0  addi r4, r11, -0x450
	ctx.r[4].s64 = ctx.r[11].s64 + -1104;
	// 825EA1D8: 48809831  bl 0x82df3a08
	ctx.lr = 0x825EA1DC;
	sub_82DF3A08(ctx, base);
	// 825EA1DC: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 825EA1E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EA1E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EA1E8: 4BFC1BD9  bl 0x825abdc0
	ctx.lr = 0x825EA1EC;
	sub_825ABDC0(ctx, base);
	// 825EA1EC: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 825EA1F0: 48809239  bl 0x82df3428
	ctx.lr = 0x825EA1F4;
	sub_82DF3428(ctx, base);
	// 825EA1F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA1F8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825EA1FC: 388BFBA4  addi r4, r11, -0x45c
	ctx.r[4].s64 = ctx.r[11].s64 + -1116;
	// 825EA200: 48809809  bl 0x82df3a08
	ctx.lr = 0x825EA204;
	sub_82DF3A08(ctx, base);
	// 825EA204: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 825EA208: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825EA20C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EA210: 4BFC1BB1  bl 0x825abdc0
	ctx.lr = 0x825EA214;
	sub_825ABDC0(ctx, base);
	// 825EA214: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825EA218: 48809211  bl 0x82df3428
	ctx.lr = 0x825EA21C;
	sub_82DF3428(ctx, base);
	// 825EA21C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825EA220: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EA224: 388B5EA0  addi r4, r11, 0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + 24224;
	// 825EA228: 488097E1  bl 0x82df3a08
	ctx.lr = 0x825EA22C;
	sub_82DF3A08(ctx, base);
	// 825EA22C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EA230: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 825EA234: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825EA238: 93C100A4  stw r30, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 825EA23C: 419A0024  beq cr6, 0x825ea260
	if ctx.cr[6].eq {
	pc = 0x825EA260; continue 'dispatch;
	}
	// 825EA240: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825EA244: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EA248: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EA24C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EA250: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EA254: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EA258: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EA25C: 4082FFE8  bne 0x825ea244
	if !ctx.cr[0].eq {
	pc = 0x825EA244; continue 'dispatch;
	}
	// 825EA260: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825EA264: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825EA268: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825EA26C: 4BFB7EA5  bl 0x825a2110
	ctx.lr = 0x825EA270;
	sub_825A2110(ctx, base);
	// 825EA270: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EA274: 488091B5  bl 0x82df3428
	ctx.lr = 0x825EA278;
	sub_82DF3428(ctx, base);
	// 825EA278: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA27C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EA280: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 825EA284: 48809785  bl 0x82df3a08
	ctx.lr = 0x825EA288;
	sub_82DF3A08(ctx, base);
	// 825EA288: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA28C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA290: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 825EA294: 48809775  bl 0x82df3a08
	ctx.lr = 0x825EA298;
	sub_82DF3A08(ctx, base);
	// 825EA298: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EA29C: 38E02710  li r7, 0x2710
	ctx.r[7].s64 = 10000;
	// 825EA2A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EA2A4: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 825EA2A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825EA2AC: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 825EA2B0: 4BFB9169  bl 0x825a3418
	ctx.lr = 0x825EA2B4;
	sub_825A3418(ctx, base);
	// 825EA2B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EA2B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EA2BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825EA2C0: 4BFB7C19  bl 0x825a1ed8
	ctx.lr = 0x825EA2C4;
	sub_825A1ED8(ctx, base);
	// 825EA2C4: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 825EA2C8: 48809161  bl 0x82df3428
	ctx.lr = 0x825EA2CC;
	sub_82DF3428(ctx, base);
	// 825EA2CC: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 825EA2D0: 4BCDE9E9  bl 0x822c8cb8
	ctx.lr = 0x825EA2D4;
	sub_822C8CB8(ctx, base);
	// 825EA2D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA2D8: 48809151  bl 0x82df3428
	ctx.lr = 0x825EA2DC;
	sub_82DF3428(ctx, base);
	// 825EA2DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EA2E0: 48809149  bl 0x82df3428
	ctx.lr = 0x825EA2E4;
	sub_82DF3428(ctx, base);
	// 825EA2E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825EA2E8: 419A000C  beq cr6, 0x825ea2f4
	if ctx.cr[6].eq {
	pc = 0x825EA2F4; continue 'dispatch;
	}
	// 825EA2EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA2F0: 4BCD65A1  bl 0x822c0890
	ctx.lr = 0x825EA2F4;
	sub_822C0890(ctx, base);
	// 825EA2F4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825EA2F8: 4BCDE9C1  bl 0x822c8cb8
	ctx.lr = 0x825EA2FC;
	sub_822C8CB8(ctx, base);
	// 825EA2FC: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 825EA300: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 825EA304: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825EA308: 48BBDEA8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EA310 size=196
    let mut pc: u32 = 0x825EA310;
    'dispatch: loop {
        match pc {
            0x825EA310 => {
    //   block [0x825EA310..0x825EA3D4)
	// 825EA310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EA318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EA31C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EA320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EA328: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EA32C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EA330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EA334: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EA338: 4BCD6601  bl 0x822c0938
	ctx.lr = 0x825EA33C;
	sub_822C0938(ctx, base);
	// 825EA33C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EA340: 41820028  beq 0x825ea368
	if ctx.cr[0].eq {
	pc = 0x825EA368; continue 'dispatch;
	}
	// 825EA344: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA348: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EA34C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EA350: 392BFDB4  addi r9, r11, -0x24c
	ctx.r[9].s64 = ctx.r[11].s64 + -588;
	// 825EA354: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EA358: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EA35C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EA360: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EA364: 48000008  b 0x825ea36c
	pc = 0x825EA36C; continue 'dispatch;
	// 825EA368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EA36C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EA370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EA374: 409A0044  bne cr6, 0x825ea3b8
	if !ctx.cr[6].eq {
	pc = 0x825EA3B8; continue 'dispatch;
	}
	// 825EA378: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EA37C: 419A001C  beq cr6, 0x825ea398
	if ctx.cr[6].eq {
	pc = 0x825EA398; continue 'dispatch;
	}
	// 825EA380: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA384: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EA388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA38C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EA394: 4E800421  bctrl
	ctx.lr = 0x825EA398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EA398: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EA39C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EA3A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA3A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EA3A8: 816BE07C  lwz r11, -0x1f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8068 as u32) ) } as u64;
	// 825EA3AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EA3B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EA3B4: 4BCD5C4D  bl 0x822c0000
	ctx.lr = 0x825EA3B8;
	sub_822C0000(ctx, base);
	// 825EA3B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA3BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EA3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EA3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EA3C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EA3CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EA3D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EA3D8 size=172
    let mut pc: u32 = 0x825EA3D8;
    'dispatch: loop {
        match pc {
            0x825EA3D8 => {
    //   block [0x825EA3D8..0x825EA484)
	// 825EA3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EA3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EA3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EA3E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA3EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EA3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EA3F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EA3F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EA3FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EA400: 4BCD6539  bl 0x822c0938
	ctx.lr = 0x825EA404;
	sub_822C0938(ctx, base);
	// 825EA404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EA408: 41820028  beq 0x825ea430
	if ctx.cr[0].eq {
	pc = 0x825EA430; continue 'dispatch;
	}
	// 825EA40C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA410: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EA414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EA418: 392BFDC8  addi r9, r11, -0x238
	ctx.r[9].s64 = ctx.r[11].s64 + -568;
	// 825EA41C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EA420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EA424: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EA428: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EA42C: 48000008  b 0x825ea434
	pc = 0x825EA434; continue 'dispatch;
	// 825EA430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EA434: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EA438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EA43C: 409A002C  bne cr6, 0x825ea468
	if !ctx.cr[6].eq {
	pc = 0x825EA468; continue 'dispatch;
	}
	// 825EA440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA444: 48807F95  bl 0x82df23d8
	ctx.lr = 0x825EA448;
	sub_82DF23D8(ctx, base);
	// 825EA448: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EA44C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EA450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA454: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EA458: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EA45C: 816BE07C  lwz r11, -0x1f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8068 as u32) ) } as u64;
	// 825EA460: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EA464: 4BCD5B9D  bl 0x822c0000
	ctx.lr = 0x825EA468;
	sub_822C0000(ctx, base);
	// 825EA468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA46C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EA470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EA474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EA478: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EA47C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EA480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EA488 size=208
    let mut pc: u32 = 0x825EA488;
    'dispatch: loop {
        match pc {
            0x825EA488 => {
    //   block [0x825EA488..0x825EA558)
	// 825EA488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA48C: 48BBDCDD  bl 0x831a8168
	ctx.lr = 0x825EA490;
	sub_831A8130(ctx, base);
	// 825EA490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EA498: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825EA49C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825EA4A0: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 825EA4A4: 4BF27DBD  bl 0x82512260
	ctx.lr = 0x825EA4A8;
	sub_82512260(ctx, base);
	// 825EA4A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA4AC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EA4B0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825EA4B4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825EA4B8: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825EA4BC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825EA4C0: 394AFE3C  addi r10, r10, -0x1c4
	ctx.r[10].s64 = ctx.r[10].s64 + -452;
	// 825EA4C4: 3929FE28  addi r9, r9, -0x1d8
	ctx.r[9].s64 = ctx.r[9].s64 + -472;
	// 825EA4C8: 3908FDDC  addi r8, r8, -0x224
	ctx.r[8].s64 = ctx.r[8].s64 + -548;
	// 825EA4CC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825EA4D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EA4D4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825EA4D8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825EA4DC: 395F00F8  addi r10, r31, 0xf8
	ctx.r[10].s64 = ctx.r[31].s64 + 248;
	// 825EA4E0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825EA4E4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825EA4E8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825EA4EC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825EA4F0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA4F4: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 825EA4F8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EA4FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EA500: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 825EA504: 419A0024  beq cr6, 0x825ea528
	if ctx.cr[6].eq {
	pc = 0x825EA528; continue 'dispatch;
	}
	// 825EA508: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825EA50C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EA510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EA514: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EA518: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EA51C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EA520: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EA524: 4082FFE8  bne 0x825ea50c
	if !ctx.cr[0].eq {
	pc = 0x825EA50C; continue 'dispatch;
	}
	// 825EA528: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EA52C: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 825EA530: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825EA534: 93BF0104  stw r29, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[29].u32 ) };
	// 825EA538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA53C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825EA540: C00AD5B8  lfs f0, -0x2a48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EA544: C1A9DD6C  lfs f13, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EA548: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 825EA54C: D1BF010C  stfs f13, 0x10c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 825EA550: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825EA554: 48BBDC64  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EA558 size=8
    let mut pc: u32 = 0x825EA558;
    'dispatch: loop {
        match pc {
            0x825EA558 => {
    //   block [0x825EA558..0x825EA560)
	// 825EA558: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825EA55C: 48000104  b 0x825ea660
	sub_825EA660(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EA560 size=8
    let mut pc: u32 = 0x825EA560;
    'dispatch: loop {
        match pc {
            0x825EA560 => {
    //   block [0x825EA560..0x825EA568)
	// 825EA560: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825EA564: 480000FC  b 0x825ea660
	sub_825EA660(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EA568 size=248
    let mut pc: u32 = 0x825EA568;
    'dispatch: loop {
        match pc {
            0x825EA568 => {
    //   block [0x825EA568..0x825EA660)
	// 825EA568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EA570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EA574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EA578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EA580: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA584: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EA588: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825EA58C: 396BFE3C  addi r11, r11, -0x1c4
	ctx.r[11].s64 = ctx.r[11].s64 + -452;
	// 825EA590: 394AFE28  addi r10, r10, -0x1d8
	ctx.r[10].s64 = ctx.r[10].s64 + -472;
	// 825EA594: 3929FDDC  addi r9, r9, -0x224
	ctx.r[9].s64 = ctx.r[9].s64 + -548;
	// 825EA598: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EA59C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825EA5A0: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825EA5A4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825EA5A8: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825EA5AC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825EA5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EA5B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EA5B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EA5BC: 419A0024  beq cr6, 0x825ea5e0
	if ctx.cr[6].eq {
	pc = 0x825EA5E0; continue 'dispatch;
	}
	// 825EA5C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825EA5C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EA5C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EA5CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EA5D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EA5D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EA5D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EA5DC: 4082FFE8  bne 0x825ea5c4
	if !ctx.cr[0].eq {
	pc = 0x825EA5C4; continue 'dispatch;
	}
	// 825EA5E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EA5E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825EA5E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825EA5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA5F0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825EA5F4: 4BF25ACD  bl 0x825100c0
	ctx.lr = 0x825EA5F8;
	sub_825100C0(ctx, base);
	// 825EA5F8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EA5FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA600: 419A0008  beq cr6, 0x825ea608
	if ctx.cr[6].eq {
	pc = 0x825EA608; continue 'dispatch;
	}
	// 825EA604: 4BCD628D  bl 0x822c0890
	ctx.lr = 0x825EA608;
	sub_822C0890(ctx, base);
	// 825EA608: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825EA60C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA610: 419A0008  beq cr6, 0x825ea618
	if ctx.cr[6].eq {
	pc = 0x825EA618; continue 'dispatch;
	}
	// 825EA614: 4BCD627D  bl 0x822c0890
	ctx.lr = 0x825EA618;
	sub_822C0890(ctx, base);
	// 825EA618: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825EA61C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA620: 419A0008  beq cr6, 0x825ea628
	if ctx.cr[6].eq {
	pc = 0x825EA628; continue 'dispatch;
	}
	// 825EA624: 4BCD626D  bl 0x822c0890
	ctx.lr = 0x825EA628;
	sub_822C0890(ctx, base);
	// 825EA628: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825EA62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA630: 419A0008  beq cr6, 0x825ea638
	if ctx.cr[6].eq {
	pc = 0x825EA638; continue 'dispatch;
	}
	// 825EA634: 4BCD625D  bl 0x822c0890
	ctx.lr = 0x825EA638;
	sub_822C0890(ctx, base);
	// 825EA638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA63C: 481BD01D  bl 0x827a7658
	ctx.lr = 0x825EA640;
	sub_827A7658(ctx, base);
	// 825EA640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA644: 4BD64D0D  bl 0x8234f350
	ctx.lr = 0x825EA648;
	sub_8234F350(ctx, base);
	// 825EA648: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EA64C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EA650: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EA654: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EA658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EA65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EA660 size=76
    let mut pc: u32 = 0x825EA660;
    'dispatch: loop {
        match pc {
            0x825EA660 => {
    //   block [0x825EA660..0x825EA6AC)
	// 825EA660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EA668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EA66C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EA670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EA678: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EA67C: 4BFFFEED  bl 0x825ea568
	ctx.lr = 0x825EA680;
	sub_825EA568(ctx, base);
	// 825EA680: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EA684: 4182000C  beq 0x825ea690
	if ctx.cr[0].eq {
	pc = 0x825EA690; continue 'dispatch;
	}
	// 825EA688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA68C: 48807D4D  bl 0x82df23d8
	ctx.lr = 0x825EA690;
	sub_82DF23D8(ctx, base);
	// 825EA690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EA698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EA69C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EA6A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EA6A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EA6A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EA6B0 size=332
    let mut pc: u32 = 0x825EA6B0;
    'dispatch: loop {
        match pc {
            0x825EA6B0 => {
    //   block [0x825EA6B0..0x825EA7FC)
	// 825EA6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EA6B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EA6BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EA6C0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825EA6C4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825EA6C8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA6CC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825EA6D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EA6D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EA6D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA6DC: 388BCACC  addi r4, r11, -0x3534
	ctx.r[4].s64 = ctx.r[11].s64 + -13620;
	// 825EA6E0: 48809329  bl 0x82df3a08
	ctx.lr = 0x825EA6E4;
	sub_82DF3A08(ctx, base);
	// 825EA6E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EA6E8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825EA6EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EA6F0: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 825EA6F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA6F8: C3EA9F64  lfs f31, -0x609c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825EA6FC: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825EA700: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825EA704: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825EA708: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825EA70C: 4BFB8AA5  bl 0x825a31b0
	ctx.lr = 0x825EA710;
	sub_825A31B0(ctx, base);
	// 825EA710: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EA714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EA71C: 4BFB7055  bl 0x825a1770
	ctx.lr = 0x825EA720;
	sub_825A1770(ctx, base);
	// 825EA720: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825EA724: 48808D05  bl 0x82df3428
	ctx.lr = 0x825EA728;
	sub_82DF3428(ctx, base);
	// 825EA728: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825EA72C: 4BCDE58D  bl 0x822c8cb8
	ctx.lr = 0x825EA730;
	sub_822C8CB8(ctx, base);
	// 825EA730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA734: 48808CF5  bl 0x82df3428
	ctx.lr = 0x825EA738;
	sub_82DF3428(ctx, base);
	// 825EA738: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825EA73C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA740: 388B8FF4  addi r4, r11, -0x700c
	ctx.r[4].s64 = ctx.r[11].s64 + -28684;
	// 825EA744: 488092C5  bl 0x82df3a08
	ctx.lr = 0x825EA748;
	sub_82DF3A08(ctx, base);
	// 825EA748: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825EA74C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825EA750: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825EA754: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825EA758: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825EA75C: C06B89AC  lfs f3, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825EA760: 4BFB8A51  bl 0x825a31b0
	ctx.lr = 0x825EA764;
	sub_825A31B0(ctx, base);
	// 825EA764: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EA768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA76C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EA770: 4BFB7001  bl 0x825a1770
	ctx.lr = 0x825EA774;
	sub_825A1770(ctx, base);
	// 825EA774: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825EA778: 48808CB1  bl 0x82df3428
	ctx.lr = 0x825EA77C;
	sub_82DF3428(ctx, base);
	// 825EA77C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825EA780: 4BCDE539  bl 0x822c8cb8
	ctx.lr = 0x825EA784;
	sub_822C8CB8(ctx, base);
	// 825EA784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA788: 48808CA1  bl 0x82df3428
	ctx.lr = 0x825EA78C;
	sub_82DF3428(ctx, base);
	// 825EA78C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825EA790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA794: 388B5EA0  addi r4, r11, 0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + 24224;
	// 825EA798: 48809271  bl 0x82df3a08
	ctx.lr = 0x825EA79C;
	sub_82DF3A08(ctx, base);
	// 825EA79C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825EA7A0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825EA7A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825EA7A8: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 825EA7AC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825EA7B0: 4BFB8BF9  bl 0x825a33a8
	ctx.lr = 0x825EA7B4;
	sub_825A33A8(ctx, base);
	// 825EA7B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EA7B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EA7BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA7C0: 4BFB74A1  bl 0x825a1c60
	ctx.lr = 0x825EA7C4;
	sub_825A1C60(ctx, base);
	// 825EA7C4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825EA7C8: 48808C61  bl 0x82df3428
	ctx.lr = 0x825EA7CC;
	sub_82DF3428(ctx, base);
	// 825EA7CC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825EA7D0: 4BCDE4E9  bl 0x822c8cb8
	ctx.lr = 0x825EA7D4;
	sub_822C8CB8(ctx, base);
	// 825EA7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA7D8: 48808C51  bl 0x82df3428
	ctx.lr = 0x825EA7DC;
	sub_82DF3428(ctx, base);
	// 825EA7DC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825EA7E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EA7E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EA7E8: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825EA7EC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825EA7F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EA7F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EA7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EA800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EA800 size=620
    let mut pc: u32 = 0x825EA800;
    'dispatch: loop {
        match pc {
            0x825EA800 => {
    //   block [0x825EA800..0x825EAA6C)
	// 825EA800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EA804: 48BBD965  bl 0x831a8168
	ctx.lr = 0x825EA808;
	sub_831A8130(ctx, base);
	// 825EA808: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EA80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EA810: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825EA814: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825EA818: 4BF271C1  bl 0x825119d8
	ctx.lr = 0x825EA81C;
	sub_825119D8(ctx, base);
	// 825EA81C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825EA820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA824: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825EA828: 488091E1  bl 0x82df3a08
	ctx.lr = 0x825EA82C;
	sub_82DF3A08(ctx, base);
	// 825EA82C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EA830: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EA834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA838: 4BF1DF49  bl 0x82508780
	ctx.lr = 0x825EA83C;
	sub_82508780(ctx, base);
	// 825EA83C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA840: 48808BE9  bl 0x82df3428
	ctx.lr = 0x825EA844;
	sub_82DF3428(ctx, base);
	// 825EA844: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EA848: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825EA84C: 409A0008  bne cr6, 0x825ea854
	if !ctx.cr[6].eq {
	pc = 0x825EA854; continue 'dispatch;
	}
	// 825EA850: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EA854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EA858: 4BF1DF49  bl 0x825087a0
	ctx.lr = 0x825EA85C;
	sub_825087A0(ctx, base);
	// 825EA85C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA860: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA864: 48840285  bl 0x82e2aae8
	ctx.lr = 0x825EA868;
	sub_82E2AAE8(ctx, base);
	// 825EA868: 3FC08329  lis r30, -0x7cd7
	ctx.r[30].s64 = -2094465024;
	// 825EA86C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA870: 809EE058  lwz r4, -0x1fa8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 825EA874: 48809195  bl 0x82df3a08
	ctx.lr = 0x825EA878;
	sub_82DF3A08(ctx, base);
	// 825EA878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EA87C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825EA880: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EA884: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EA888: 488445E9  bl 0x82e2ee70
	ctx.lr = 0x825EA88C;
	sub_82E2EE70(ctx, base);
	// 825EA88C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA890: 48808B99  bl 0x82df3428
	ctx.lr = 0x825EA894;
	sub_82DF3428(ctx, base);
	// 825EA894: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EA898: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EA89C: 388BFE78  addi r4, r11, -0x188
	ctx.r[4].s64 = ctx.r[11].s64 + -392;
	// 825EA8A0: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825EA8A4: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825EA8A8: 48807B41  bl 0x82df23e8
	ctx.lr = 0x825EA8AC;
	sub_82DF23E8(ctx, base);
	// 825EA8AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EA8B0: 41820014  beq 0x825ea8c4
	if ctx.cr[0].eq {
	pc = 0x825EA8C4; continue 'dispatch;
	}
	// 825EA8B4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825EA8B8: 4882BFD9  bl 0x82e16890
	ctx.lr = 0x825EA8BC;
	sub_82E16890(ctx, base);
	// 825EA8BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EA8C0: 48000008  b 0x825ea8c8
	pc = 0x825EA8C8; continue 'dispatch;
	// 825EA8C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EA8C8: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 825EA8CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EA8D0: 4BD72AA1  bl 0x8235d370
	ctx.lr = 0x825EA8D4;
	sub_8235D370(ctx, base);
	// 825EA8D4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825EA8D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA8DC: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 825EA8E0: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825EA8E4: 4BF274B5  bl 0x82511d98
	ctx.lr = 0x825EA8E8;
	sub_82511D98(ctx, base);
	// 825EA8E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EA8EC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825EA8F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EA8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA8F8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825EA8FC: 4BF2625D  bl 0x82510b58
	ctx.lr = 0x825EA900;
	sub_82510B58(ctx, base);
	// 825EA900: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EA904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA908: 419A0008  beq cr6, 0x825ea910
	if ctx.cr[6].eq {
	pc = 0x825EA910; continue 'dispatch;
	}
	// 825EA90C: 4BCD5F85  bl 0x822c0890
	ctx.lr = 0x825EA910;
	sub_822C0890(ctx, base);
	// 825EA910: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA914: 488401ED  bl 0x82e2ab00
	ctx.lr = 0x825EA918;
	sub_82E2AB00(ctx, base);
	// 825EA918: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA91C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA920: 4BCFC8E9  bl 0x822e7208
	ctx.lr = 0x825EA924;
	sub_822E7208(ctx, base);
	// 825EA924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA928: 809EE058  lwz r4, -0x1fa8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 825EA92C: 488090DD  bl 0x82df3a08
	ctx.lr = 0x825EA930;
	sub_82DF3A08(ctx, base);
	// 825EA930: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EA934: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825EA938: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EA93C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EA940: 4BCFCA51  bl 0x822e7390
	ctx.lr = 0x825EA944;
	sub_822E7390(ctx, base);
	// 825EA944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA948: 48808AE1  bl 0x82df3428
	ctx.lr = 0x825EA94C;
	sub_82DF3428(ctx, base);
	// 825EA94C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA950: 809EE058  lwz r4, -0x1fa8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 825EA954: 488090B5  bl 0x82df3a08
	ctx.lr = 0x825EA958;
	sub_82DF3A08(ctx, base);
	// 825EA958: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 825EA95C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825EA960: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EA964: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EA968: 4BD03D71  bl 0x822ee6d8
	ctx.lr = 0x825EA96C;
	sub_822EE6D8(ctx, base);
	// 825EA96C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EA970: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 825EA974: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825EA978: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825EA97C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA980: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825EA984: 4BCD9ADD  bl 0x822c4460
	ctx.lr = 0x825EA988;
	sub_822C4460(ctx, base);
	// 825EA988: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EA98C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA990: 419A0008  beq cr6, 0x825ea998
	if ctx.cr[6].eq {
	pc = 0x825EA998; continue 'dispatch;
	}
	// 825EA994: 4BCD5EFD  bl 0x822c0890
	ctx.lr = 0x825EA998;
	sub_822C0890(ctx, base);
	// 825EA998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EA99C: 48808A8D  bl 0x82df3428
	ctx.lr = 0x825EA9A0;
	sub_82DF3428(ctx, base);
	// 825EA9A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA9A4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EA9A8: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 825EA9AC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825EA9B0: 4BD02F71  bl 0x822ed920
	ctx.lr = 0x825EA9B4;
	sub_822ED920(ctx, base);
	// 825EA9B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EA9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA9BC: 4BF26385  bl 0x82510d40
	ctx.lr = 0x825EA9C0;
	sub_82510D40(ctx, base);
	// 825EA9C0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825EA9C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EA9C8: 419A0008  beq cr6, 0x825ea9d0
	if ctx.cr[6].eq {
	pc = 0x825EA9D0; continue 'dispatch;
	}
	// 825EA9CC: 4BCD5EC5  bl 0x822c0890
	ctx.lr = 0x825EA9D0;
	sub_822C0890(ctx, base);
	// 825EA9D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EA9D4: 4BCFC84D  bl 0x822e7220
	ctx.lr = 0x825EA9D8;
	sub_822E7220(ctx, base);
	// 825EA9D8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825EA9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EA9E0: 4BF273B9  bl 0x82511d98
	ctx.lr = 0x825EA9E4;
	sub_82511D98(ctx, base);
	// 825EA9E4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825EA9E8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EA9EC: 481ADCBD  bl 0x827986a8
	ctx.lr = 0x825EA9F0;
	sub_827986A8(ctx, base);
	// 825EA9F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EA9F4: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EA9F8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825EA9FC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EAA00: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825EAA04: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825EAA08: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825EAA0C: E97F0112  lwa r11, 0x110(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as i32) as i64;
	// 825EAA10: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825EAA14: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825EAA18: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825EAA1C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825EAA20: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825EAA24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAA28: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825EAA2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EAA30: 4E800421  bctrl
	ctx.lr = 0x825EAA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EAA34: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EAA38: C03F010C  lfs f1, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EAA3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAA40: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825EAA44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EAA48: 4E800421  bctrl
	ctx.lr = 0x825EAA4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EAA4C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EAA50: C03F0108  lfs f1, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EAA54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAA58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EAA5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EAA60: 4E800421  bctrl
	ctx.lr = 0x825EAA64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EAA64: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825EAA68: 48BBD750  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EAA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EAA70 size=568
    let mut pc: u32 = 0x825EAA70;
    'dispatch: loop {
        match pc {
            0x825EAA70 => {
    //   block [0x825EAA70..0x825EACA8)
	// 825EAA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EAA74: 48BBD6F1  bl 0x831a8164
	ctx.lr = 0x825EAA78;
	sub_831A8130(ctx, base);
	// 825EAA78: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EAA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EAA80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825EAA84: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EAA88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAA8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EAA90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EAA94: 4E800421  bctrl
	ctx.lr = 0x825EAA98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EAA98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EAA9C: 40820204  bne 0x825eaca0
	if !ctx.cr[0].eq {
	pc = 0x825EACA0; continue 'dispatch;
	}
	// 825EAAA0: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825EAAA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EAAA8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825EAAAC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EAAB0: 4BD32721  bl 0x8231d1d0
	ctx.lr = 0x825EAAB4;
	sub_8231D1D0(ctx, base);
	// 825EAAB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAAB8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825EAABC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EAAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EAAC4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825EAAC8: 419A0024  beq cr6, 0x825eaaec
	if ctx.cr[6].eq {
	pc = 0x825EAAEC; continue 'dispatch;
	}
	// 825EAACC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825EAAD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EAAD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EAAD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EAADC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EAAE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EAAE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EAAE8: 4082FFE8  bne 0x825eaad0
	if !ctx.cr[0].eq {
	pc = 0x825EAAD0; continue 'dispatch;
	}
	// 825EAAEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAAF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825EAAF4: 4BF249D5  bl 0x8250f4c8
	ctx.lr = 0x825EAAF8;
	sub_8250F4C8(ctx, base);
	// 825EAAF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAAFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EAB00: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825EAB04: 409A0008  bne cr6, 0x825eab0c
	if !ctx.cr[6].eq {
	pc = 0x825EAB0C; continue 'dispatch;
	}
	// 825EAB08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825EAB0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EAB10: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 825EAB14: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825EAB18: 4BF1DF01  bl 0x82508a18
	ctx.lr = 0x825EAB1C;
	sub_82508A18(ctx, base);
	// 825EAB1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EAB20: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825EAB24: 3BABFE78  addi r29, r11, -0x188
	ctx.r[29].s64 = ctx.r[11].s64 + -392;
	// 825EAB28: 38A00092  li r5, 0x92
	ctx.r[5].s64 = 146;
	// 825EAB2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EAB30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EAB34: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825EAB38: 4886C4B1  bl 0x82e56fe8
	ctx.lr = 0x825EAB3C;
	sub_82E56FE8(ctx, base);
	// 825EAB3C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825EAB40: 48807151  bl 0x82df1c90
	ctx.lr = 0x825EAB44;
	sub_82DF1C90(ctx, base);
	// 825EAB44: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EAB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAB4C: 419A0008  beq cr6, 0x825eab54
	if ctx.cr[6].eq {
	pc = 0x825EAB54; continue 'dispatch;
	}
	// 825EAB50: 4BCD5D41  bl 0x822c0890
	ctx.lr = 0x825EAB54;
	sub_822C0890(ctx, base);
	// 825EAB54: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825EAB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAB5C: 419A0008  beq cr6, 0x825eab64
	if ctx.cr[6].eq {
	pc = 0x825EAB64; continue 'dispatch;
	}
	// 825EAB60: 4BCD5D31  bl 0x822c0890
	ctx.lr = 0x825EAB64;
	sub_822C0890(ctx, base);
	// 825EAB64: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 825EAB68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EAB6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825EAB70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EAB74: 4BDB4715  bl 0x8239f288
	ctx.lr = 0x825EAB78;
	sub_8239F288(ctx, base);
	// 825EAB78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAB7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EAB80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EAB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EAB88: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825EAB8C: 419A0024  beq cr6, 0x825eabb0
	if ctx.cr[6].eq {
	pc = 0x825EABB0; continue 'dispatch;
	}
	// 825EAB90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825EAB94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EAB98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EAB9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EABA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EABA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EABA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EABAC: 4082FFE8  bne 0x825eab94
	if !ctx.cr[0].eq {
	pc = 0x825EAB94; continue 'dispatch;
	}
	// 825EABB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EABB4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825EABB8: 4BF24911  bl 0x8250f4c8
	ctx.lr = 0x825EABBC;
	sub_8250F4C8(ctx, base);
	// 825EABBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EABC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EABC4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825EABC8: 409A0008  bne cr6, 0x825eabd0
	if !ctx.cr[6].eq {
	pc = 0x825EABD0; continue 'dispatch;
	}
	// 825EABCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825EABD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EABD4: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 825EABD8: 4BF1DE41  bl 0x82508a18
	ctx.lr = 0x825EABDC;
	sub_82508A18(ctx, base);
	// 825EABDC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825EABE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EABE4: 38A00093  li r5, 0x93
	ctx.r[5].s64 = 147;
	// 825EABE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EABEC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825EABF0: 4886C3F9  bl 0x82e56fe8
	ctx.lr = 0x825EABF4;
	sub_82E56FE8(ctx, base);
	// 825EABF4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825EABF8: 48807099  bl 0x82df1c90
	ctx.lr = 0x825EABFC;
	sub_82DF1C90(ctx, base);
	// 825EABFC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EAC00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAC04: 419A0008  beq cr6, 0x825eac0c
	if ctx.cr[6].eq {
	pc = 0x825EAC0C; continue 'dispatch;
	}
	// 825EAC08: 4BCD5C89  bl 0x822c0890
	ctx.lr = 0x825EAC0C;
	sub_822C0890(ctx, base);
	// 825EAC0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EAC10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAC14: 419A0008  beq cr6, 0x825eac1c
	if ctx.cr[6].eq {
	pc = 0x825EAC1C; continue 'dispatch;
	}
	// 825EAC18: 4BCD5C79  bl 0x822c0890
	ctx.lr = 0x825EAC1C;
	sub_822C0890(ctx, base);
	// 825EAC1C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EAC20: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825EAC24: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825EAC28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EAC2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAC30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EAC34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EAC38: 4E800421  bctrl
	ctx.lr = 0x825EAC3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EAC3C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825EAC40: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825EAC44: 481ADABD  bl 0x82798700
	ctx.lr = 0x825EAC48;
	sub_82798700(ctx, base);
	// 825EAC48: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825EAC4C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825EAC50: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825EAC54: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825EAC58: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 825EAC5C: 80640084  lwz r3, 0x84(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 825EAC60: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825EAC64: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825EAC68: 13E85C07  vcmpneb. (lvlx128) v31, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EAC6C: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825EAC70: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 825EAC74: 13C93C07  vcmpneb. (lvlx128) v30, v9, v7
	tmp.u32 = ctx.r[9].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EAC78: 13AA3407  vcmpneb. (lvlx128) v29, v10, v6
	tmp.u32 = ctx.r[10].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EAC7C: 13802C07  vcmpneb. (lvlx128) v28, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EACA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EACA8 size=520
    let mut pc: u32 = 0x825EACA8;
    'dispatch: loop {
        match pc {
            0x825EACA8 => {
    //   block [0x825EACA8..0x825EAEB0)
	// 825EACA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EACAC: 48BBD4B9  bl 0x831a8164
	ctx.lr = 0x825EACB0;
	sub_831A8130(ctx, base);
	// 825EACB0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EACB4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EACB8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825EACBC: 3B8BFE78  addi r28, r11, -0x188
	ctx.r[28].s64 = ctx.r[11].s64 + -392;
	// 825EACC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EACC4: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 825EACC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EACCC: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EACD0: 48807719  bl 0x82df23e8
	ctx.lr = 0x825EACD4;
	sub_82DF23E8(ctx, base);
	// 825EACD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EACD8: 41820010  beq 0x825eace8
	if ctx.cr[0].eq {
	pc = 0x825EACE8; continue 'dispatch;
	}
	// 825EACDC: 481ADA5D  bl 0x82798738
	ctx.lr = 0x825EACE0;
	sub_82798738(ctx, base);
	// 825EACE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EACE4: 48000008  b 0x825eacec
	pc = 0x825EACEC; continue 'dispatch;
	// 825EACE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EACEC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EACF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EACF4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EACF8: 4BFFC219  bl 0x825e6f10
	ctx.lr = 0x825EACFC;
	sub_825E6F10(ctx, base);
	// 825EACFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EAD00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAD04: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EAD08: 4BCD52F9  bl 0x822c0000
	ctx.lr = 0x825EAD0C;
	sub_822C0000(ctx, base);
	// 825EAD0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EAD10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EAD14: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 825EAD18: 38600114  li r3, 0x114
	ctx.r[3].s64 = 276;
	// 825EAD1C: 488076CD  bl 0x82df23e8
	ctx.lr = 0x825EAD20;
	sub_82DF23E8(ctx, base);
	// 825EAD20: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EAD24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EAD28: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 825EAD2C: 41820028  beq 0x825ead54
	if ctx.cr[0].eq {
	pc = 0x825EAD54; continue 'dispatch;
	}
	// 825EAD30: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EAD34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825EAD38: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825EAD3C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EAD40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825EAD44: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825EAD48: 4BFFF741  bl 0x825ea488
	ctx.lr = 0x825EAD4C;
	sub_825EA488(ctx, base);
	// 825EAD4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EAD50: 48000008  b 0x825ead58
	pc = 0x825EAD58; continue 'dispatch;
	// 825EAD54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EAD58: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EAD5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAD60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EAD64: 4BFFF5AD  bl 0x825ea310
	ctx.lr = 0x825EAD68;
	sub_825EA310(ctx, base);
	// 825EAD68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EAD6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAD70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EAD74: 4BCD528D  bl 0x822c0000
	ctx.lr = 0x825EAD78;
	sub_822C0000(ctx, base);
	// 825EAD78: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EAD7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EAD80: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825EAD84: 409A0008  bne cr6, 0x825ead8c
	if !ctx.cr[6].eq {
	pc = 0x825EAD8C; continue 'dispatch;
	}
	// 825EAD88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EAD8C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EAD90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825EAD94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EAD98: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825EAD9C: 419A0024  beq cr6, 0x825eadc0
	if ctx.cr[6].eq {
	pc = 0x825EADC0; continue 'dispatch;
	}
	// 825EADA0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EADA4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EADA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EADAC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EADB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EADB4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EADB8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EADBC: 4082FFE8  bne 0x825eada4
	if !ctx.cr[0].eq {
	pc = 0x825EADA4; continue 'dispatch;
	}
	// 825EADC0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825EADC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EADC8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EADCC: 419A0024  beq cr6, 0x825eadf0
	if ctx.cr[6].eq {
	pc = 0x825EADF0; continue 'dispatch;
	}
	// 825EADD0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EADD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EADD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EADDC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EADE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EADE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EADE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EADEC: 4082FFE8  bne 0x825eadd4
	if !ctx.cr[0].eq {
	pc = 0x825EADD4; continue 'dispatch;
	}
	// 825EADF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EADF4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825EADF8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EADFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825EAE00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EAE04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EAE08: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EAE0C: 481AE125  bl 0x82798f30
	ctx.lr = 0x825EAE10;
	sub_82798F30(ctx, base);
	// 825EAE10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EAE14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EAE18: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 825EAE1C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EAE20: 4BCD55B9  bl 0x822c03d8
	ctx.lr = 0x825EAE24;
	sub_822C03D8(ctx, base);
	// 825EAE24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EAE28: 41820014  beq 0x825eae3c
	if ctx.cr[0].eq {
	pc = 0x825EAE3C; continue 'dispatch;
	}
	// 825EAE2C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825EAE30: 481B0839  bl 0x8279b668
	ctx.lr = 0x825EAE34;
	sub_8279B668(ctx, base);
	// 825EAE34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EAE38: 48000008  b 0x825eae40
	pc = 0x825EAE40; continue 'dispatch;
	// 825EAE3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EAE40: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EAE44: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825EAE48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAE4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EAE50: 4BFACE01  bl 0x82597c50
	ctx.lr = 0x825EAE54;
	sub_82597C50(ctx, base);
	// 825EAE54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EAE58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EAE60: 4BCD51A1  bl 0x822c0000
	ctx.lr = 0x825EAE64;
	sub_822C0000(ctx, base);
	// 825EAE64: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EAE68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAE6C: 419A0008  beq cr6, 0x825eae74
	if ctx.cr[6].eq {
	pc = 0x825EAE74; continue 'dispatch;
	}
	// 825EAE70: 4BCD5A21  bl 0x822c0890
	ctx.lr = 0x825EAE74;
	sub_822C0890(ctx, base);
	// 825EAE74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EAE78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAE7C: 419A0008  beq cr6, 0x825eae84
	if ctx.cr[6].eq {
	pc = 0x825EAE84; continue 'dispatch;
	}
	// 825EAE80: 4BCD5A11  bl 0x822c0890
	ctx.lr = 0x825EAE84;
	sub_822C0890(ctx, base);
	// 825EAE84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EAE88: 419A000C  beq cr6, 0x825eae94
	if ctx.cr[6].eq {
	pc = 0x825EAE94; continue 'dispatch;
	}
	// 825EAE8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EAE90: 4BCD5A01  bl 0x822c0890
	ctx.lr = 0x825EAE94;
	sub_822C0890(ctx, base);
	// 825EAE94: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EAE98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EAE9C: 419A0008  beq cr6, 0x825eaea4
	if ctx.cr[6].eq {
	pc = 0x825EAEA4; continue 'dispatch;
	}
	// 825EAEA0: 4BCD59F1  bl 0x822c0890
	ctx.lr = 0x825EAEA4;
	sub_822C0890(ctx, base);
	// 825EAEA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825EAEA8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825EAEAC: 48BBD308  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EAEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EAEB0 size=568
    let mut pc: u32 = 0x825EAEB0;
    'dispatch: loop {
        match pc {
            0x825EAEB0 => {
    //   block [0x825EAEB0..0x825EB0E8)
	// 825EAEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EAEB4: 48BBD2B1  bl 0x831a8164
	ctx.lr = 0x825EAEB8;
	sub_831A8130(ctx, base);
	// 825EAEB8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825EAEBC: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EAEC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EAEC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825EAEC8: 3B8BFE78  addi r28, r11, -0x188
	ctx.r[28].s64 = ctx.r[11].s64 + -392;
	// 825EAECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EAED0: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 825EAED4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EAED8: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825EAEDC: 4880750D  bl 0x82df23e8
	ctx.lr = 0x825EAEE0;
	sub_82DF23E8(ctx, base);
	// 825EAEE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EAEE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EAEE8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825EAEEC: 41820034  beq 0x825eaf20
	if ctx.cr[0].eq {
	pc = 0x825EAF20; continue 'dispatch;
	}
	// 825EAEF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EAEF4: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825EAEF8: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825EAEFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EAF00: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825EAF04: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825EAF08: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EAF0C: D0210078  stfs f1, 0x78(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825EAF10: C04A959C  lfs f2, -0x6a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825EAF14: 481AD745  bl 0x82798658
	ctx.lr = 0x825EAF18;
	sub_82798658(ctx, base);
	// 825EAF18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EAF1C: 48000008  b 0x825eaf24
	pc = 0x825EAF24; continue 'dispatch;
	// 825EAF20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EAF24: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EAF28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAF2C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EAF30: 4BFFF4A9  bl 0x825ea3d8
	ctx.lr = 0x825EAF34;
	sub_825EA3D8(ctx, base);
	// 825EAF34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EAF38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAF3C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EAF40: 4BCD50C1  bl 0x822c0000
	ctx.lr = 0x825EAF44;
	sub_822C0000(ctx, base);
	// 825EAF44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EAF48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EAF4C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 825EAF50: 38600114  li r3, 0x114
	ctx.r[3].s64 = 276;
	// 825EAF54: 48807495  bl 0x82df23e8
	ctx.lr = 0x825EAF58;
	sub_82DF23E8(ctx, base);
	// 825EAF58: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EAF5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EAF60: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 825EAF64: 41820028  beq 0x825eaf8c
	if ctx.cr[0].eq {
	pc = 0x825EAF8C; continue 'dispatch;
	}
	// 825EAF68: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EAF6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825EAF70: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825EAF74: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EAF78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825EAF7C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825EAF80: 4BFFF509  bl 0x825ea488
	ctx.lr = 0x825EAF84;
	sub_825EA488(ctx, base);
	// 825EAF84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EAF88: 48000008  b 0x825eaf90
	pc = 0x825EAF90; continue 'dispatch;
	// 825EAF8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EAF90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EAF94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAF98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EAF9C: 4BFFF375  bl 0x825ea310
	ctx.lr = 0x825EAFA0;
	sub_825EA310(ctx, base);
	// 825EAFA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EAFA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EAFA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EAFAC: 4BCD5055  bl 0x822c0000
	ctx.lr = 0x825EAFB0;
	sub_822C0000(ctx, base);
	// 825EAFB0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EAFB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EAFB8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825EAFBC: 409A0008  bne cr6, 0x825eafc4
	if !ctx.cr[6].eq {
	pc = 0x825EAFC4; continue 'dispatch;
	}
	// 825EAFC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EAFC4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EAFC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825EAFCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EAFD0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825EAFD4: 419A0024  beq cr6, 0x825eaff8
	if ctx.cr[6].eq {
	pc = 0x825EAFF8; continue 'dispatch;
	}
	// 825EAFD8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EAFDC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EAFE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EAFE4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EAFE8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EAFEC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EAFF0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EAFF4: 4082FFE8  bne 0x825eafdc
	if !ctx.cr[0].eq {
	pc = 0x825EAFDC; continue 'dispatch;
	}
	// 825EAFF8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825EAFFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EB000: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EB004: 419A0024  beq cr6, 0x825eb028
	if ctx.cr[6].eq {
	pc = 0x825EB028; continue 'dispatch;
	}
	// 825EB008: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EB00C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EB010: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EB014: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EB018: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EB01C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EB020: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EB024: 4082FFE8  bne 0x825eb00c
	if !ctx.cr[0].eq {
	pc = 0x825EB00C; continue 'dispatch;
	}
	// 825EB028: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825EB02C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825EB030: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EB034: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825EB038: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EB03C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825EB040: 481ADEF1  bl 0x82798f30
	ctx.lr = 0x825EB044;
	sub_82798F30(ctx, base);
	// 825EB044: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EB048: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EB04C: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 825EB050: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EB054: 4BCD5385  bl 0x822c03d8
	ctx.lr = 0x825EB058;
	sub_822C03D8(ctx, base);
	// 825EB058: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB05C: 41820014  beq 0x825eb070
	if ctx.cr[0].eq {
	pc = 0x825EB070; continue 'dispatch;
	}
	// 825EB060: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825EB064: 481B0605  bl 0x8279b668
	ctx.lr = 0x825EB068;
	sub_8279B668(ctx, base);
	// 825EB068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EB06C: 48000008  b 0x825eb074
	pc = 0x825EB074; continue 'dispatch;
	// 825EB070: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EB074: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EB078: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825EB07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EB080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB084: 4BFACBCD  bl 0x82597c50
	ctx.lr = 0x825EB088;
	sub_82597C50(ctx, base);
	// 825EB088: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EB08C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EB090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB094: 4BCD4F6D  bl 0x822c0000
	ctx.lr = 0x825EB098;
	sub_822C0000(ctx, base);
	// 825EB098: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825EB09C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EB0A0: 419A0008  beq cr6, 0x825eb0a8
	if ctx.cr[6].eq {
	pc = 0x825EB0A8; continue 'dispatch;
	}
	// 825EB0A4: 4BCD57ED  bl 0x822c0890
	ctx.lr = 0x825EB0A8;
	sub_822C0890(ctx, base);
	// 825EB0A8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825EB0AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EB0B0: 419A0008  beq cr6, 0x825eb0b8
	if ctx.cr[6].eq {
	pc = 0x825EB0B8; continue 'dispatch;
	}
	// 825EB0B4: 4BCD57DD  bl 0x822c0890
	ctx.lr = 0x825EB0B8;
	sub_822C0890(ctx, base);
	// 825EB0B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EB0BC: 419A000C  beq cr6, 0x825eb0c8
	if ctx.cr[6].eq {
	pc = 0x825EB0C8; continue 'dispatch;
	}
	// 825EB0C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EB0C4: 4BCD57CD  bl 0x822c0890
	ctx.lr = 0x825EB0C8;
	sub_822C0890(ctx, base);
	// 825EB0C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EB0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EB0D0: 419A0008  beq cr6, 0x825eb0d8
	if ctx.cr[6].eq {
	pc = 0x825EB0D8; continue 'dispatch;
	}
	// 825EB0D4: 4BCD57BD  bl 0x822c0890
	ctx.lr = 0x825EB0D8;
	sub_822C0890(ctx, base);
	// 825EB0D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825EB0DC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825EB0E0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825EB0E4: 48BBD0D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EB0E8 size=72
    let mut pc: u32 = 0x825EB0E8;
    'dispatch: loop {
        match pc {
            0x825EB0E8 => {
    //   block [0x825EB0E8..0x825EB130)
	// 825EB0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB0F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB0F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB0F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB0FC: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825EB100: 4BF28479  bl 0x82513578
	ctx.lr = 0x825EB104;
	sub_82513578(ctx, base);
	// 825EB104: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825EB108: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EB10C: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EB110: C00A0110  lfs f0, 0x110(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EB114: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825EB118: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825EB11C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825EB120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB12C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EB130 size=8
    let mut pc: u32 = 0x825EB130;
    'dispatch: loop {
        match pc {
            0x825EB130 => {
    //   block [0x825EB130..0x825EB138)
	// 825EB130: 38840020  addi r4, r4, 0x20
	ctx.r[4].s64 = ctx.r[4].s64 + 32;
	// 825EB134: 4BF28444  b 0x82513578
	sub_82513578(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB138 size=80
    let mut pc: u32 = 0x825EB138;
    'dispatch: loop {
        match pc {
            0x825EB138 => {
    //   block [0x825EB138..0x825EB188)
	// 825EB138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB148: 48B694B9  bl 0x83154600
	ctx.lr = 0x825EB14C;
	sub_83154600(ctx, base);
	// 825EB14C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EB150: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB154: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 825EB158: 4BFCAE59  bl 0x825b5fb0
	ctx.lr = 0x825EB15C;
	sub_825B5FB0(ctx, base);
	// 825EB15C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EB160: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 825EB164: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825EB168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB16C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825EB170: 4BF259E9  bl 0x82510b58
	ctx.lr = 0x825EB174;
	sub_82510B58(ctx, base);
	// 825EB174: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825EB178: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB17C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB180: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB188 size=196
    let mut pc: u32 = 0x825EB188;
    'dispatch: loop {
        match pc {
            0x825EB188 => {
    //   block [0x825EB188..0x825EB24C)
	// 825EB188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB18C: 48BBCFE1  bl 0x831a816c
	ctx.lr = 0x825EB190;
	sub_831A8130(ctx, base);
	// 825EB190: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB194: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB198: 39600246  li r11, 0x246
	ctx.r[11].s64 = 582;
	// 825EB19C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB1A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825EB1A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EB1A8: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 825EB1AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB1B0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 825EB1B4: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 825EB1B8: 4BF284B1  bl 0x82513668
	ctx.lr = 0x825EB1BC;
	sub_82513668(ctx, base);
	// 825EB1BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB250 size=52
    let mut pc: u32 = 0x825EB250;
    'dispatch: loop {
        match pc {
            0x825EB250 => {
    //   block [0x825EB250..0x825EB284)
	// 825EB250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB25C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB260: 8063026C  lwz r3, 0x26c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(620 as u32) ) } as u64;
	// 825EB264: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB268: 485D63B1  bl 0x82bc1618
	ctx.lr = 0x825EB26C;
	sub_82BC1618(ctx, base);
	// 825EB26C: 987F0018  stb r3, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u8 ) };
	// 825EB270: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825EB274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB27C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB288 size=240
    let mut pc: u32 = 0x825EB288;
    'dispatch: loop {
        match pc {
            0x825EB288 => {
    //   block [0x825EB288..0x825EB378)
	// 825EB288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB298: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB29C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB2A0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 825EB2A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB2A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EB2AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB2B0: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825EB2B4: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825EB2B8: 4BF283B1  bl 0x82513668
	ctx.lr = 0x825EB2BC;
	sub_82513668(ctx, base);
	// 825EB2BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB378 size=172
    let mut pc: u32 = 0x825EB378;
    'dispatch: loop {
        match pc {
            0x825EB378 => {
    //   block [0x825EB378..0x825EB424)
	// 825EB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB38C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB394: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB398: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB39C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB3A0: 4BCD5599  bl 0x822c0938
	ctx.lr = 0x825EB3A4;
	sub_822C0938(ctx, base);
	// 825EB3A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB3A8: 41820028  beq 0x825eb3d0
	if ctx.cr[0].eq {
	pc = 0x825EB3D0; continue 'dispatch;
	}
	// 825EB3AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB3B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB3B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB3B8: 392B0128  addi r9, r11, 0x128
	ctx.r[9].s64 = ctx.r[11].s64 + 296;
	// 825EB3BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB3C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB3C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB3C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB3CC: 48000008  b 0x825eb3d4
	pc = 0x825EB3D4; continue 'dispatch;
	// 825EB3D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB3D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB3DC: 409A002C  bne cr6, 0x825eb408
	if !ctx.cr[6].eq {
	pc = 0x825EB408; continue 'dispatch;
	}
	// 825EB3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB3E4: 48806FF5  bl 0x82df23d8
	ctx.lr = 0x825EB3E8;
	sub_82DF23D8(ctx, base);
	// 825EB3E8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB3EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB3F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB3F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB3FC: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB400: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB404: 4BCD4BFD  bl 0x822c0000
	ctx.lr = 0x825EB408;
	sub_822C0000(ctx, base);
	// 825EB408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB40C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB418: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB41C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB428 size=196
    let mut pc: u32 = 0x825EB428;
    'dispatch: loop {
        match pc {
            0x825EB428 => {
    //   block [0x825EB428..0x825EB4EC)
	// 825EB428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB43C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB444: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB448: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB44C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB450: 4BCD54E9  bl 0x822c0938
	ctx.lr = 0x825EB454;
	sub_822C0938(ctx, base);
	// 825EB454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB458: 41820028  beq 0x825eb480
	if ctx.cr[0].eq {
	pc = 0x825EB480; continue 'dispatch;
	}
	// 825EB45C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB460: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB464: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB468: 392B013C  addi r9, r11, 0x13c
	ctx.r[9].s64 = ctx.r[11].s64 + 316;
	// 825EB46C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB470: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB474: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB478: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB47C: 48000008  b 0x825eb484
	pc = 0x825EB484; continue 'dispatch;
	// 825EB480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB484: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB48C: 409A0044  bne cr6, 0x825eb4d0
	if !ctx.cr[6].eq {
	pc = 0x825EB4D0; continue 'dispatch;
	}
	// 825EB490: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB494: 419A001C  beq cr6, 0x825eb4b0
	if ctx.cr[6].eq {
	pc = 0x825EB4B0; continue 'dispatch;
	}
	// 825EB498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB49C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB4A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB4A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB4AC: 4E800421  bctrl
	ctx.lr = 0x825EB4B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB4B0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB4B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB4B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB4BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB4C0: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB4C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB4C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB4CC: 4BCD4B35  bl 0x822c0000
	ctx.lr = 0x825EB4D0;
	sub_822C0000(ctx, base);
	// 825EB4D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB4D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB4D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB4DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB4E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB4E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB4E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB4F0 size=196
    let mut pc: u32 = 0x825EB4F0;
    'dispatch: loop {
        match pc {
            0x825EB4F0 => {
    //   block [0x825EB4F0..0x825EB5B4)
	// 825EB4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB4F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB4F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB4FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB504: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB50C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB510: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB514: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB518: 4BCD5421  bl 0x822c0938
	ctx.lr = 0x825EB51C;
	sub_822C0938(ctx, base);
	// 825EB51C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB520: 41820028  beq 0x825eb548
	if ctx.cr[0].eq {
	pc = 0x825EB548; continue 'dispatch;
	}
	// 825EB524: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB528: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB52C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB530: 392B0150  addi r9, r11, 0x150
	ctx.r[9].s64 = ctx.r[11].s64 + 336;
	// 825EB534: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB538: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB53C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB540: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB544: 48000008  b 0x825eb54c
	pc = 0x825EB54C; continue 'dispatch;
	// 825EB548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB54C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB554: 409A0044  bne cr6, 0x825eb598
	if !ctx.cr[6].eq {
	pc = 0x825EB598; continue 'dispatch;
	}
	// 825EB558: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB55C: 419A001C  beq cr6, 0x825eb578
	if ctx.cr[6].eq {
	pc = 0x825EB578; continue 'dispatch;
	}
	// 825EB560: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB564: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB56C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB570: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB574: 4E800421  bctrl
	ctx.lr = 0x825EB578;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB578: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB57C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB584: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB588: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB58C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB590: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB594: 4BCD4A6D  bl 0x822c0000
	ctx.lr = 0x825EB598;
	sub_822C0000(ctx, base);
	// 825EB598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB59C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB5A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB5A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB5A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB5AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB5B8 size=196
    let mut pc: u32 = 0x825EB5B8;
    'dispatch: loop {
        match pc {
            0x825EB5B8 => {
    //   block [0x825EB5B8..0x825EB67C)
	// 825EB5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB5C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB5C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB5C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB5CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB5D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB5D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB5D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB5DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB5E0: 4BCD5359  bl 0x822c0938
	ctx.lr = 0x825EB5E4;
	sub_822C0938(ctx, base);
	// 825EB5E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB5E8: 41820028  beq 0x825eb610
	if ctx.cr[0].eq {
	pc = 0x825EB610; continue 'dispatch;
	}
	// 825EB5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB5F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB5F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB5F8: 392B0164  addi r9, r11, 0x164
	ctx.r[9].s64 = ctx.r[11].s64 + 356;
	// 825EB5FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB600: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB604: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB608: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB60C: 48000008  b 0x825eb614
	pc = 0x825EB614; continue 'dispatch;
	// 825EB610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB614: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB61C: 409A0044  bne cr6, 0x825eb660
	if !ctx.cr[6].eq {
	pc = 0x825EB660; continue 'dispatch;
	}
	// 825EB620: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB624: 419A001C  beq cr6, 0x825eb640
	if ctx.cr[6].eq {
	pc = 0x825EB640; continue 'dispatch;
	}
	// 825EB628: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB62C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB634: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB63C: 4E800421  bctrl
	ctx.lr = 0x825EB640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB640: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB644: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB64C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB650: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB654: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB658: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB65C: 4BCD49A5  bl 0x822c0000
	ctx.lr = 0x825EB660;
	sub_822C0000(ctx, base);
	// 825EB660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB66C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB670: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB674: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


