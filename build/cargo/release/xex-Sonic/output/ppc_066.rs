pub fn sub_826A8174(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826A8174 size=24
    let mut pc: u32 = 0x826A8174;
    'dispatch: loop {
        match pc {
            0x826A8174 => {
    //   block [0x826A8174..0x826A818C)
	// 826A8174: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A8178: C1AB08A4  lfs f13, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A817C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826A8180: 4098FFD8  bge cr6, 0x826a8158
	if !ctx.cr[6].lt {
		sub_826A811C(ctx, base);
		return;
	}
	// 826A8184: D1A1FFE0  stfs f13, -0x20(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 826A8188: 4BFFFFD4  b 0x826a815c
	sub_826A811C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A8190 size=552
    let mut pc: u32 = 0x826A8190;
    'dispatch: loop {
        match pc {
            0x826A8190 => {
    //   block [0x826A8190..0x826A83B8)
	// 826A8190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8194: 48AFFFC5  bl 0x831a8158
	ctx.lr = 0x826A8198;
	sub_831A8130(ctx, base);
	// 826A8198: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 826A819C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 826A81A0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A81A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A81A8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826A81AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A81B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826A81B4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826A81B8: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826A81BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A81C0: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826A81C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A81C8: 83DB01A4  lwz r30, 0x1a4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A81CC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A81D0: C3CA9450  lfs f30, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A81D4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A81D8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A81DC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A81E0: 487D3E39  bl 0x82e7c018
	ctx.lr = 0x826A81E4;
	sub_82E7C018(ctx, base);
	// 826A81E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A81E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A81EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A81F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A81F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A81F8: 4E800421  bctrl
	ctx.lr = 0x826A81FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A81FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A8200: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826A8204: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A8208: 4BC1C6F9  bl 0x822c4900
	ctx.lr = 0x826A820C;
	sub_822C4900(ctx, base);
	// 826A820C: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 826A8210: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 826A8214: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A8218: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 826A821C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 826A8220: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826A8224: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 826A8228: 13DC1C07  vcmpneb. (lvlx128) v30, v28, v3
	tmp.u32 = ctx.r[28].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A822C: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 826A8230: 13BD1C07  vcmpneb. (lvlx128) v29, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A8234: 139E1C07  vcmpneb. (lvlx128) v28, v30, v3
	tmp.u32 = ctx.r[30].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A8238: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A83B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A83B8 size=72
    let mut pc: u32 = 0x826A83B8;
    'dispatch: loop {
        match pc {
            0x826A83B8 => {
    //   block [0x826A83B8..0x826A8400)
	// 826A83B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A83BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A83C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A83C4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 826A83C8: 419A001C  beq cr6, 0x826a83e4
	if ctx.cr[6].eq {
	pc = 0x826A83E4; continue 'dispatch;
	}
	// 826A83CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826A83D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826A83D4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 826A83D8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A83DC: 4BFFF9D5  bl 0x826a7db0
	ctx.lr = 0x826A83E0;
	sub_826A7DB0(ctx, base);
	// 826A83E0: 48000010  b 0x826a83f0
	pc = 0x826A83F0; continue 'dispatch;
	// 826A83E4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A83E8: 396B9FE8  addi r11, r11, -0x6018
	ctx.r[11].s64 = ctx.r[11].s64 + -24600;
	// 826A83EC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A83F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A83F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A83F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A83FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8400 size=100
    let mut pc: u32 = 0x826A8400;
    'dispatch: loop {
        match pc {
            0x826A8400 => {
    //   block [0x826A8400..0x826A8464)
	// 826A8400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A840C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8414: 4BFFF20D  bl 0x826a7620
	ctx.lr = 0x826A8418;
	sub_826A7620(ctx, base);
	// 826A8418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A841C: 4BFFD45D  bl 0x826a5878
	ctx.lr = 0x826A8420;
	sub_826A5878(ctx, base);
	// 826A8420: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8424: 4182001C  beq 0x826a8440
	if ctx.cr[0].eq {
	pc = 0x826A8440; continue 'dispatch;
	}
	// 826A8428: 897F01C4  lbz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 826A842C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A8430: 41820010  beq 0x826a8440
	if ctx.cr[0].eq {
	pc = 0x826A8440; continue 'dispatch;
	}
	// 826A8434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8438: 4BFFFB39  bl 0x826a7f70
	ctx.lr = 0x826A843C;
	sub_826A7F70(ctx, base);
	// 826A843C: 48000014  b 0x826a8450
	pc = 0x826A8450; continue 'dispatch;
	// 826A8440: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A8444: 807F01A4  lwz r3, 0x1a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A8448: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A844C: 4876AE15  bl 0x82e13260
	ctx.lr = 0x826A8450;
	sub_82E13260(ctx, base);
	// 826A8450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A845C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A8468 size=32
    let mut pc: u32 = 0x826A8468;
    'dispatch: loop {
        match pc {
            0x826A8468 => {
    //   block [0x826A8468..0x826A8488)
	// 826A8468: 810301A4  lwz r8, 0x1a4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A846C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826A8470: 394301A4  addi r10, r3, 0x1a4
	ctx.r[10].s64 = ctx.r[3].s64 + 420;
	// 826A8474: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826A8478: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826A847C: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826A8480: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826A8484: 4BC1BFDC  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8488 size=388
    let mut pc: u32 = 0x826A8488;
    'dispatch: loop {
        match pc {
            0x826A8488 => {
    //   block [0x826A8488..0x826A860C)
	// 826A8488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A848C: 48AFFCDD  bl 0x831a8168
	ctx.lr = 0x826A8490;
	sub_831A8130(ctx, base);
	// 826A8490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8494: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826A8498: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A849C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A84A0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A84A4: 41820038  beq 0x826a84dc
	if ctx.cr[0].eq {
	pc = 0x826A84DC; continue 'dispatch;
	}
	// 826A84A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A84AC: 48B014DD  bl 0x831a9988
	ctx.lr = 0x826A84B0;
	sub_831A9988(ctx, base);
	// 826A84B0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A84B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A84B8: 386B6B84  addi r3, r11, 0x6b84
	ctx.r[3].s64 = ctx.r[11].s64 + 27524;
	// 826A84BC: 48AFFC3D  bl 0x831a80f8
	ctx.lr = 0x826A84C0;
	sub_831A80F8(ctx, base);
	// 826A84C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A84C4: 41820018  beq 0x826a84dc
	if ctx.cr[0].eq {
	pc = 0x826A84DC; continue 'dispatch;
	}
	// 826A84C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A84CC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A84D0: 4BFFFF99  bl 0x826a8468
	ctx.lr = 0x826A84D4;
	sub_826A8468(ctx, base);
	// 826A84D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826A84D8: 4800012C  b 0x826a8604
	pc = 0x826A8604; continue 'dispatch;
	// 826A84DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A84E0: 419A0114  beq cr6, 0x826a85f4
	if ctx.cr[6].eq {
	pc = 0x826A85F4; continue 'dispatch;
	}
	// 826A84E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A84E8: 48B014A1  bl 0x831a9988
	ctx.lr = 0x826A84EC;
	sub_831A9988(ctx, base);
	// 826A84EC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A84F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A84F4: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826A84F8: 48AFFC01  bl 0x831a80f8
	ctx.lr = 0x826A84FC;
	sub_831A80F8(ctx, base);
	// 826A84FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8500: 41820014  beq 0x826a8514
	if ctx.cr[0].eq {
	pc = 0x826A8514; continue 'dispatch;
	}
	// 826A8504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8508: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A850C: 4BFFFF5D  bl 0x826a8468
	ctx.lr = 0x826A8510;
	sub_826A8468(ctx, base);
	// 826A8510: 4BFFFFC4  b 0x826a84d4
	pc = 0x826A84D4; continue 'dispatch;
	// 826A8514: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A8518: 419A00DC  beq cr6, 0x826a85f4
	if ctx.cr[6].eq {
	pc = 0x826A85F4; continue 'dispatch;
	}
	// 826A851C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8520: 48B01469  bl 0x831a9988
	ctx.lr = 0x826A8524;
	sub_831A9988(ctx, base);
	// 826A8524: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A8528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A852C: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 826A8530: 48AFFBC9  bl 0x831a80f8
	ctx.lr = 0x826A8534;
	sub_831A80F8(ctx, base);
	// 826A8534: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8538: 41820014  beq 0x826a854c
	if ctx.cr[0].eq {
	pc = 0x826A854C; continue 'dispatch;
	}
	// 826A853C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8540: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A8544: 4BFFF84D  bl 0x826a7d90
	ctx.lr = 0x826A8548;
	sub_826A7D90(ctx, base);
	// 826A8548: 4BFFFF8C  b 0x826a84d4
	pc = 0x826A84D4; continue 'dispatch;
	// 826A854C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A8550: 419A00A4  beq cr6, 0x826a85f4
	if ctx.cr[6].eq {
	pc = 0x826A85F4; continue 'dispatch;
	}
	// 826A8554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8558: 48B01431  bl 0x831a9988
	ctx.lr = 0x826A855C;
	sub_831A9988(ctx, base);
	// 826A855C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A8560: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A8564: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 826A8568: 48AFFB91  bl 0x831a80f8
	ctx.lr = 0x826A856C;
	sub_831A80F8(ctx, base);
	// 826A856C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8570: 41820014  beq 0x826a8584
	if ctx.cr[0].eq {
	pc = 0x826A8584; continue 'dispatch;
	}
	// 826A8574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8578: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A857C: 4BFFF825  bl 0x826a7da0
	ctx.lr = 0x826A8580;
	sub_826A7DA0(ctx, base);
	// 826A8580: 4BFFFF54  b 0x826a84d4
	pc = 0x826A84D4; continue 'dispatch;
	// 826A8584: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A8588: 419A006C  beq cr6, 0x826a85f4
	if ctx.cr[6].eq {
	pc = 0x826A85F4; continue 'dispatch;
	}
	// 826A858C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8590: 48B013F9  bl 0x831a9988
	ctx.lr = 0x826A8594;
	sub_831A9988(ctx, base);
	// 826A8594: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A8598: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A859C: 386B9470  addi r3, r11, -0x6b90
	ctx.r[3].s64 = ctx.r[11].s64 + -27536;
	// 826A85A0: 48AFFB59  bl 0x831a80f8
	ctx.lr = 0x826A85A4;
	sub_831A80F8(ctx, base);
	// 826A85A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A85A8: 41820014  beq 0x826a85bc
	if ctx.cr[0].eq {
	pc = 0x826A85BC; continue 'dispatch;
	}
	// 826A85AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A85B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A85B4: 4BFFF885  bl 0x826a7e38
	ctx.lr = 0x826A85B8;
	sub_826A7E38(ctx, base);
	// 826A85B8: 4BFFFF1C  b 0x826a84d4
	pc = 0x826A84D4; continue 'dispatch;
	// 826A85BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A85C0: 419A0034  beq cr6, 0x826a85f4
	if ctx.cr[6].eq {
	pc = 0x826A85F4; continue 'dispatch;
	}
	// 826A85C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A85C8: 48B013C1  bl 0x831a9988
	ctx.lr = 0x826A85CC;
	sub_831A9988(ctx, base);
	// 826A85CC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A85D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A85D4: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826A85D8: 48AFFB21  bl 0x831a80f8
	ctx.lr = 0x826A85DC;
	sub_831A80F8(ctx, base);
	// 826A85DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A85E0: 41820014  beq 0x826a85f4
	if ctx.cr[0].eq {
	pc = 0x826A85F4; continue 'dispatch;
	}
	// 826A85E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A85E8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A85EC: 4BFFFBA5  bl 0x826a8190
	ctx.lr = 0x826A85F0;
	sub_826A8190(ctx, base);
	// 826A85F0: 4BFFFEE4  b 0x826a84d4
	pc = 0x826A84D4; continue 'dispatch;
	// 826A85F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826A85F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A85FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A8600: 4BFFF2C9  bl 0x826a78c8
	ctx.lr = 0x826A8604;
	sub_826A78C8(ctx, base);
	// 826A8604: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A8608: 48AFFBB0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A8610 size=244
    let mut pc: u32 = 0x826A8610;
    'dispatch: loop {
        match pc {
            0x826A8610 => {
    //   block [0x826A8610..0x826A8704)
	// 826A8610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A861C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8628: 897F01BC  lbz r11, 0x1bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A862C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A8630: 418200BC  beq 0x826a86ec
	if ctx.cr[0].eq {
	pc = 0x826A86EC; continue 'dispatch;
	}
	// 826A8634: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A8638: 4BD169F1  bl 0x823bf028
	ctx.lr = 0x826A863C;
	sub_823BF028(ctx, base);
	// 826A863C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A8640: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826A8644: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A8648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A864C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A8650: 419A0024  beq cr6, 0x826a8674
	if ctx.cr[6].eq {
	pc = 0x826A8674; continue 'dispatch;
	}
	// 826A8654: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A8658: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A865C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A8660: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A8664: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A8668: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A866C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A8670: 4082FFE8  bne 0x826a8658
	if !ctx.cr[0].eq {
	pc = 0x826A8658; continue 'dispatch;
	}
	// 826A8674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A867C: 4BE66E4D  bl 0x8250f4c8
	ctx.lr = 0x826A8680;
	sub_8250F4C8(ctx, base);
	// 826A8680: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A8684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8688: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A868C: 409A0008  bne cr6, 0x826a8694
	if !ctx.cr[6].eq {
	pc = 0x826A8694; continue 'dispatch;
	}
	// 826A8690: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A8694: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A8698: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826A869C: 4BE6037D  bl 0x82508a18
	ctx.lr = 0x826A86A0;
	sub_82508A18(ctx, base);
	// 826A86A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A86A4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A86A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826A86AC: 388A18D8  addi r4, r10, 0x18d8
	ctx.r[4].s64 = ctx.r[10].s64 + 6360;
	// 826A86B0: 38A0011F  li r5, 0x11f
	ctx.r[5].s64 = 287;
	// 826A86B4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826A86B8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A86BC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826A86C0: 487B0381  bl 0x82e58a40
	ctx.lr = 0x826A86C4;
	sub_82E58A40(ctx, base);
	// 826A86C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A86C8: 487495C9  bl 0x82df1c90
	ctx.lr = 0x826A86CC;
	sub_82DF1C90(ctx, base);
	// 826A86CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A86D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A86D4: 419A0008  beq cr6, 0x826a86dc
	if ctx.cr[6].eq {
	pc = 0x826A86DC; continue 'dispatch;
	}
	// 826A86D8: 4BC181B9  bl 0x822c0890
	ctx.lr = 0x826A86DC;
	sub_822C0890(ctx, base);
	// 826A86DC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A86E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A86E4: 419A0008  beq cr6, 0x826a86ec
	if ctx.cr[6].eq {
	pc = 0x826A86EC; continue 'dispatch;
	}
	// 826A86E8: 4BC181A9  bl 0x822c0890
	ctx.lr = 0x826A86EC;
	sub_822C0890(ctx, base);
	// 826A86EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A86F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A86F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A86F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A86FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8708 size=128
    let mut pc: u32 = 0x826A8708;
    'dispatch: loop {
        match pc {
            0x826A8708 => {
    //   block [0x826A8708..0x826A8788)
	// 826A8708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A870C: 48AFFA61  bl 0x831a816c
	ctx.lr = 0x826A8710;
	sub_831A8130(ctx, base);
	// 826A8710: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8714: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826A8718: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826A871C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A8720: 3BEB8150  addi r31, r11, -0x7eb0
	ctx.r[31].s64 = ctx.r[11].s64 + -32432;
	// 826A8724: 816A8158  lwz r11, -0x7ea8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32424 as u32) ) } as u64;
	// 826A8728: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826A872C: 40820024  bne 0x826a8750
	if !ctx.cr[0].eq {
	pc = 0x826A8750; continue 'dispatch;
	}
	// 826A8730: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 826A8734: 3D00826B  lis r8, -0x7d95
	ctx.r[8].s64 = -2106916864;
	// 826A8738: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826A873C: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 826A8740: 390883B8  addi r8, r8, -0x7c48
	ctx.r[8].s64 = ctx.r[8].s64 + -31816;
	// 826A8744: 916A8158  stw r11, -0x7ea8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32424 as u32), ctx.r[11].u32 ) };
	// 826A8748: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826A874C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826A8750: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826A8754: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826A8758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A875C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 826A8760: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 826A8764: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A8768: 4BFABE59  bl 0x826545c0
	ctx.lr = 0x826A876C;
	sub_826545C0(ctx, base);
	// 826A876C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8770: 4182000C  beq 0x826a877c
	if ctx.cr[0].eq {
	pc = 0x826A877C; continue 'dispatch;
	}
	// 826A8774: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826A8778: 48000008  b 0x826a8780
	pc = 0x826A8780; continue 'dispatch;
	// 826A877C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826A8780: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A8784: 48AFFA38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8788 size=172
    let mut pc: u32 = 0x826A8788;
    'dispatch: loop {
        match pc {
            0x826A8788 => {
    //   block [0x826A8788..0x826A8834)
	// 826A8788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A878C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8794: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A879C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A87A0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A87A4: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A87A8: 396B198C  addi r11, r11, 0x198c
	ctx.r[11].s64 = ctx.r[11].s64 + 6540;
	// 826A87AC: 394A1978  addi r10, r10, 0x1978
	ctx.r[10].s64 = ctx.r[10].s64 + 6520;
	// 826A87B0: 3929192C  addi r9, r9, 0x192c
	ctx.r[9].s64 = ctx.r[9].s64 + 6444;
	// 826A87B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A87B8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A87BC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A87C0: 807F01B8  lwz r3, 0x1b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 826A87C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A87C8: 419A0008  beq cr6, 0x826a87d0
	if ctx.cr[6].eq {
	pc = 0x826A87D0; continue 'dispatch;
	}
	// 826A87CC: 4BC180C5  bl 0x822c0890
	ctx.lr = 0x826A87D0;
	sub_822C0890(ctx, base);
	// 826A87D0: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 826A87D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A87D8: 419A0008  beq cr6, 0x826a87e0
	if ctx.cr[6].eq {
	pc = 0x826A87E0; continue 'dispatch;
	}
	// 826A87DC: 4BC180B5  bl 0x822c0890
	ctx.lr = 0x826A87E0;
	sub_822C0890(ctx, base);
	// 826A87E0: 807F01A8  lwz r3, 0x1a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 826A87E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A87E8: 419A0008  beq cr6, 0x826a87f0
	if ctx.cr[6].eq {
	pc = 0x826A87F0; continue 'dispatch;
	}
	// 826A87EC: 4BC180A5  bl 0x822c0890
	ctx.lr = 0x826A87F0;
	sub_822C0890(ctx, base);
	// 826A87F0: 387F0194  addi r3, r31, 0x194
	ctx.r[3].s64 = ctx.r[31].s64 + 404;
	// 826A87F4: 4BE08AAD  bl 0x824b12a0
	ctx.lr = 0x826A87F8;
	sub_824B12A0(ctx, base);
	// 826A87F8: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826A87FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A8800: 419A0008  beq cr6, 0x826a8808
	if ctx.cr[6].eq {
	pc = 0x826A8808; continue 'dispatch;
	}
	// 826A8804: 4BC1808D  bl 0x822c0890
	ctx.lr = 0x826A8808;
	sub_822C0890(ctx, base);
	// 826A8808: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826A880C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A8810: 419A0008  beq cr6, 0x826a8818
	if ctx.cr[6].eq {
	pc = 0x826A8818; continue 'dispatch;
	}
	// 826A8814: 4BC1807D  bl 0x822c0890
	ctx.lr = 0x826A8818;
	sub_822C0890(ctx, base);
	// 826A8818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A881C: 4BFFDFED  bl 0x826a6808
	ctx.lr = 0x826A8820;
	sub_826A6808(ctx, base);
	// 826A8820: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A882C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A8838 size=8
    let mut pc: u32 = 0x826A8838;
    'dispatch: loop {
        match pc {
            0x826A8838 => {
    //   block [0x826A8838..0x826A8840)
	// 826A8838: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826A883C: 4800000C  b 0x826a8848
	sub_826A8848(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A8840 size=8
    let mut pc: u32 = 0x826A8840;
    'dispatch: loop {
        match pc {
            0x826A8840 => {
    //   block [0x826A8840..0x826A8848)
	// 826A8840: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826A8844: 48000004  b 0x826a8848
	sub_826A8848(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8848 size=76
    let mut pc: u32 = 0x826A8848;
    'dispatch: loop {
        match pc {
            0x826A8848 => {
    //   block [0x826A8848..0x826A8894)
	// 826A8848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A884C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A8854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A885C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8860: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A8864: 4BFFFF25  bl 0x826a8788
	ctx.lr = 0x826A8868;
	sub_826A8788(ctx, base);
	// 826A8868: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A886C: 4182000C  beq 0x826a8878
	if ctx.cr[0].eq {
	pc = 0x826A8878; continue 'dispatch;
	}
	// 826A8870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8874: 48749B65  bl 0x82df23d8
	ctx.lr = 0x826A8878;
	sub_82DF23D8(ctx, base);
	// 826A8878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A887C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A8880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8888: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A888C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A8898 size=184
    let mut pc: u32 = 0x826A8898;
    'dispatch: loop {
        match pc {
            0x826A8898 => {
    //   block [0x826A8898..0x826A8950)
	// 826A8898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A889C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A88A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A88A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A88A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A88AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A88B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A88B4: 4BFFE26D  bl 0x826a6b20
	ctx.lr = 0x826A88B8;
	sub_826A6B20(ctx, base);
	// 826A88B8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A88BC: 93DF0180  stw r30, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 826A88C0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A88C4: 396B198C  addi r11, r11, 0x198c
	ctx.r[11].s64 = ctx.r[11].s64 + 6540;
	// 826A88C8: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A88CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A88D0: 394A1978  addi r10, r10, 0x1978
	ctx.r[10].s64 = ctx.r[10].s64 + 6520;
	// 826A88D4: 3929192C  addi r9, r9, 0x192c
	ctx.r[9].s64 = ctx.r[9].s64 + 6444;
	// 826A88D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A88DC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A88E0: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A88E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A88E8: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 826A88EC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826A88F0: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 826A88F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A88F8: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826A88FC: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 826A8900: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 826A8904: C00AA1C4  lfs f0, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A8908: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 826A890C: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 826A8910: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 826A8914: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 826A8918: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 826A891C: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 826A8920: 917F01B4  stw r11, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 826A8924: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 826A8928: D01F01C0  stfs f0, 0x1c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 826A892C: 997F01BC  stb r11, 0x1bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u8 ) };
	// 826A8930: 993F01C4  stb r9, 0x1c4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[9].u8 ) };
	// 826A8934: 917F01C8  stw r11, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 826A8938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A893C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A8948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A894C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A8950 size=432
    let mut pc: u32 = 0x826A8950;
    'dispatch: loop {
        match pc {
            0x826A8950 => {
    //   block [0x826A8950..0x826A8B00)
	// 826A8950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8954: 48AFF811  bl 0x831a8164
	ctx.lr = 0x826A8958;
	sub_831A8130(ctx, base);
	// 826A8958: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A895C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A8960: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826A8964: 3BCB18D8  addi r30, r11, 0x18d8
	ctx.r[30].s64 = ctx.r[11].s64 + 6360;
	// 826A8968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A896C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826A8970: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A8974: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 826A8978: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826A897C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A8980: 386001D0  li r3, 0x1d0
	ctx.r[3].s64 = 464;
	// 826A8984: 48749A65  bl 0x82df23e8
	ctx.lr = 0x826A8988;
	sub_82DF23E8(ctx, base);
	// 826A8988: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A898C: 41820014  beq 0x826a89a0
	if ctx.cr[0].eq {
	pc = 0x826A89A0; continue 'dispatch;
	}
	// 826A8990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8994: 4BFFFF05  bl 0x826a8898
	ctx.lr = 0x826A8998;
	sub_826A8898(ctx, base);
	// 826A8998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A899C: 48000008  b 0x826a89a4
	pc = 0x826A89A4; continue 'dispatch;
	// 826A89A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A89A4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A89A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A89AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A89B0: 4BFFF4F9  bl 0x826a7ea8
	ctx.lr = 0x826A89B4;
	sub_826A7EA8(ctx, base);
	// 826A89B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A89B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A89BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A89C0: 4BC17641  bl 0x822c0000
	ctx.lr = 0x826A89C4;
	sub_822C0000(ctx, base);
	// 826A89C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A89C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A89CC: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 826A89D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826A89D4: 4BC17A05  bl 0x822c03d8
	ctx.lr = 0x826A89D8;
	sub_822C03D8(ctx, base);
	// 826A89D8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A89DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A89E0: 418200B4  beq 0x826a8a94
	if ctx.cr[0].eq {
	pc = 0x826A8A94; continue 'dispatch;
	}
	// 826A89E4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A89E8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826A89EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826A89F0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826A89F4: 409A0008  bne cr6, 0x826a89fc
	if !ctx.cr[6].eq {
	pc = 0x826A89FC; continue 'dispatch;
	}
	// 826A89F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A89FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A8A00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A8A04: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826A8A08: 419A0024  beq cr6, 0x826a8a2c
	if ctx.cr[6].eq {
	pc = 0x826A8A2C; continue 'dispatch;
	}
	// 826A8A0C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A8A10: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826A8A14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A8A18: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826A8A1C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826A8A20: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A8A24: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A8A28: 4082FFE8  bne 0x826a8a10
	if !ctx.cr[0].eq {
	pc = 0x826A8A10; continue 'dispatch;
	}
	// 826A8A2C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826A8A30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A8A34: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826A8A38: 419A0024  beq cr6, 0x826a8a5c
	if ctx.cr[6].eq {
	pc = 0x826A8A5C; continue 'dispatch;
	}
	// 826A8A3C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A8A40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A8A44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A8A48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A8A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A8A50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A8A54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A8A58: 4082FFE8  bne 0x826a8a40
	if !ctx.cr[0].eq {
	pc = 0x826A8A40; continue 'dispatch;
	}
	// 826A8A5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A8A60: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826A8A64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A8A68: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826A8A6C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A8A70: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A8A74: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A8A78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A8A7C: 480F04B5  bl 0x82798f30
	ctx.lr = 0x826A8A80;
	sub_82798F30(ctx, base);
	// 826A8A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A8A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8A88: 480F2BE1  bl 0x8279b668
	ctx.lr = 0x826A8A8C;
	sub_8279B668(ctx, base);
	// 826A8A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8A90: 48000008  b 0x826a8a98
	pc = 0x826A8A98; continue 'dispatch;
	// 826A8A94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A8A98: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826A8A9C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826A8AA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A8AA8: 4BEEF1A9  bl 0x82597c50
	ctx.lr = 0x826A8AAC;
	sub_82597C50(ctx, base);
	// 826A8AAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A8AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A8AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A8AB8: 4BC17549  bl 0x822c0000
	ctx.lr = 0x826A8ABC;
	sub_822C0000(ctx, base);
	// 826A8ABC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8AC0: 41820024  beq 0x826a8ae4
	if ctx.cr[0].eq {
	pc = 0x826A8AE4; continue 'dispatch;
	}
	// 826A8AC4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826A8AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A8ACC: 419A0008  beq cr6, 0x826a8ad4
	if ctx.cr[6].eq {
	pc = 0x826A8AD4; continue 'dispatch;
	}
	// 826A8AD0: 4BC17DC1  bl 0x822c0890
	ctx.lr = 0x826A8AD4;
	sub_822C0890(ctx, base);
	// 826A8AD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A8AD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A8ADC: 419A0008  beq cr6, 0x826a8ae4
	if ctx.cr[6].eq {
	pc = 0x826A8AE4; continue 'dispatch;
	}
	// 826A8AE0: 4BC17DB1  bl 0x822c0890
	ctx.lr = 0x826A8AE4;
	sub_822C0890(ctx, base);
	// 826A8AE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A8AE8: 419A000C  beq cr6, 0x826a8af4
	if ctx.cr[6].eq {
	pc = 0x826A8AF4; continue 'dispatch;
	}
	// 826A8AEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A8AF0: 4BC17DA1  bl 0x822c0890
	ctx.lr = 0x826A8AF4;
	sub_822C0890(ctx, base);
	// 826A8AF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826A8AF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826A8AFC: 48AFF6B8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8B00 size=52
    let mut pc: u32 = 0x826A8B00;
    'dispatch: loop {
        match pc {
            0x826A8B00 => {
    //   block [0x826A8B00..0x826A8B34)
	// 826A8B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8B08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8B0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8B10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A8B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8B18: 4BFFFE39  bl 0x826a8950
	ctx.lr = 0x826A8B1C;
	sub_826A8950(ctx, base);
	// 826A8B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8B38 size=52
    let mut pc: u32 = 0x826A8B38;
    'dispatch: loop {
        match pc {
            0x826A8B38 => {
    //   block [0x826A8B38..0x826A8B6C)
	// 826A8B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8B44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8B48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A8B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8B50: 4BFFFE01  bl 0x826a8950
	ctx.lr = 0x826A8B54;
	sub_826A8950(ctx, base);
	// 826A8B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8B58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8B5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8B60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8B64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8B68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8B70 size=52
    let mut pc: u32 = 0x826A8B70;
    'dispatch: loop {
        match pc {
            0x826A8B70 => {
    //   block [0x826A8B70..0x826A8BA4)
	// 826A8B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8B78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8B7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8B80: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826A8B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8B88: 4BFFFDC9  bl 0x826a8950
	ctx.lr = 0x826A8B8C;
	sub_826A8950(ctx, base);
	// 826A8B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8BA8 size=52
    let mut pc: u32 = 0x826A8BA8;
    'dispatch: loop {
        match pc {
            0x826A8BA8 => {
    //   block [0x826A8BA8..0x826A8BDC)
	// 826A8BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8BB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8BB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8BB8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826A8BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8BC0: 4BFFFD91  bl 0x826a8950
	ctx.lr = 0x826A8BC4;
	sub_826A8950(ctx, base);
	// 826A8BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8BC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8BE0 size=52
    let mut pc: u32 = 0x826A8BE0;
    'dispatch: loop {
        match pc {
            0x826A8BE0 => {
    //   block [0x826A8BE0..0x826A8C14)
	// 826A8BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8BE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8BEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8BF0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826A8BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8BF8: 4BFFFD59  bl 0x826a8950
	ctx.lr = 0x826A8BFC;
	sub_826A8950(ctx, base);
	// 826A8BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8C00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8C18 size=52
    let mut pc: u32 = 0x826A8C18;
    'dispatch: loop {
        match pc {
            0x826A8C18 => {
    //   block [0x826A8C18..0x826A8C4C)
	// 826A8C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8C28: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826A8C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8C30: 4BFFFD21  bl 0x826a8950
	ctx.lr = 0x826A8C34;
	sub_826A8950(ctx, base);
	// 826A8C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8C38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8C44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8C50 size=52
    let mut pc: u32 = 0x826A8C50;
    'dispatch: loop {
        match pc {
            0x826A8C50 => {
    //   block [0x826A8C50..0x826A8C84)
	// 826A8C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8C5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8C60: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826A8C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8C68: 4BFFFCE9  bl 0x826a8950
	ctx.lr = 0x826A8C6C;
	sub_826A8950(ctx, base);
	// 826A8C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8C70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8C88 size=52
    let mut pc: u32 = 0x826A8C88;
    'dispatch: loop {
        match pc {
            0x826A8C88 => {
    //   block [0x826A8C88..0x826A8CBC)
	// 826A8C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8C90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8C94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8C98: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826A8C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8CA0: 4BFFFCB1  bl 0x826a8950
	ctx.lr = 0x826A8CA4;
	sub_826A8950(ctx, base);
	// 826A8CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8CA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8CAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8CB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8CB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8CC0 size=52
    let mut pc: u32 = 0x826A8CC0;
    'dispatch: loop {
        match pc {
            0x826A8CC0 => {
    //   block [0x826A8CC0..0x826A8CF4)
	// 826A8CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8CD0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826A8CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8CD8: 4BFFFC79  bl 0x826a8950
	ctx.lr = 0x826A8CDC;
	sub_826A8950(ctx, base);
	// 826A8CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8CE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8CE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8CE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A8CF8 size=52
    let mut pc: u32 = 0x826A8CF8;
    'dispatch: loop {
        match pc {
            0x826A8CF8 => {
    //   block [0x826A8CF8..0x826A8D2C)
	// 826A8CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A8D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A8D04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8D08: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 826A8D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A8D10: 4BFFFC41  bl 0x826a8950
	ctx.lr = 0x826A8D14;
	sub_826A8950(ctx, base);
	// 826A8D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A8D18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A8D1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A8D20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A8D24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A8D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A8D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A8D30 size=1964
    let mut pc: u32 = 0x826A8D30;
    'dispatch: loop {
        match pc {
            0x826A8D30 => {
    //   block [0x826A8D30..0x826A94DC)
	// 826A8D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A8D34: 48AFF415  bl 0x831a8148
	ctx.lr = 0x826A8D38;
	sub_831A8130(ctx, base);
	// 826A8D38: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 826A8D3C: 48AFFD3D  bl 0x831a8a78
	ctx.lr = 0x826A8D40;
	sub_831A8A40(ctx, base);
	// 826A8D40: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A8D44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A8D48: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A8D4C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A8D50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A8D54: 4BE66775  bl 0x8250f4c8
	ctx.lr = 0x826A8D58;
	sub_8250F4C8(ctx, base);
	// 826A8D58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A8D5C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 826A8D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8D64: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 826A8D68: 409A0008  bne cr6, 0x826a8d70
	if !ctx.cr[6].eq {
	pc = 0x826A8D70; continue 'dispatch;
	}
	// 826A8D6C: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 826A8D70: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A8D74: 48748F1D  bl 0x82df1c90
	ctx.lr = 0x826A8D78;
	sub_82DF1C90(ctx, base);
	// 826A8D78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A8D7C: 419A0750  beq cr6, 0x826a94cc
	if ctx.cr[6].eq {
	pc = 0x826A94CC; continue 'dispatch;
	}
	// 826A8D80: 817D0184  lwz r11, 0x184(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) } as u64;
	// 826A8D84: 3A9D0184  addi r20, r29, 0x184
	ctx.r[20].s64 = ctx.r[29].s64 + 388;
	// 826A8D88: 3EC08335  lis r22, -0x7ccb
	ctx.r[22].s64 = -2093678592;
	// 826A8D8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8D90: 419A0018  beq cr6, 0x826a8da8
	if ctx.cr[6].eq {
	pc = 0x826A8DA8; continue 'dispatch;
	}
	// 826A8D94: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A8D98: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A8D9C: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 826A8DA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A8DA4: 4BE6744D  bl 0x825101f0
	ctx.lr = 0x826A8DA8;
	sub_825101F0(ctx, base);
	// 826A8DA8: 817D018C  lwz r11, 0x18c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(396 as u32) ) } as u64;
	// 826A8DAC: 3ABD018C  addi r21, r29, 0x18c
	ctx.r[21].s64 = ctx.r[29].s64 + 396;
	// 826A8DB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A8DB4: 419A0018  beq cr6, 0x826a8dcc
	if ctx.cr[6].eq {
	pc = 0x826A8DCC; continue 'dispatch;
	}
	// 826A8DB8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A8DBC: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A8DC0: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 826A8DC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A8DC8: 4BE67429  bl 0x825101f0
	ctx.lr = 0x826A8DCC;
	sub_825101F0(ctx, base);
	// 826A8DCC: 83DD0198  lwz r30, 0x198(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A8DD0: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A8DD4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A8DD8: 419A0058  beq cr6, 0x826a8e30
	if ctx.cr[6].eq {
	pc = 0x826A8E30; continue 'dispatch;
	}
	// 826A8DDC: 3BFD0194  addi r31, r29, 0x194
	ctx.r[31].s64 = ctx.r[29].s64 + 404;
	// 826A8DE0: 3B9E0008  addi r28, r30, 8
	ctx.r[28].s64 = ctx.r[30].s64 + 8;
	// 826A8DE4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A8DE8: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A8DEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A8DF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A8DF4: 4BE673FD  bl 0x825101f0
	ctx.lr = 0x826A8DF8;
	sub_825101F0(ctx, base);
	// 826A8DF8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A8DFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A8E00: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A8E04: 4BC1C54D  bl 0x822c5350
	ctx.lr = 0x826A8E08;
	sub_822C5350(ctx, base);
	// 826A8E08: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A8E0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A8E10: 3864FFF8  addi r3, r4, -8
	ctx.r[3].s64 = ctx.r[4].s64 + -8;
	// 826A8E14: 48129535  bl 0x827d2348
	ctx.lr = 0x826A8E18;
	sub_827D2348(ctx, base);
	// 826A8E18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A8E1C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 826A8E20: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826A8E24: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A8E28: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A8E2C: 409AFFB8  bne cr6, 0x826a8de4
	if !ctx.cr[6].eq {
	pc = 0x826A8DE4; continue 'dispatch;
	}
	// 826A8E30: 809D01B4  lwz r4, 0x1b4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(436 as u32) ) } as u64;
	// 826A8E34: 3B7D01B4  addi r27, r29, 0x1b4
	ctx.r[27].s64 = ctx.r[29].s64 + 436;
	// 826A8E38: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 826A8E3C: 419A0024  beq cr6, 0x826a8e60
	if ctx.cr[6].eq {
	pc = 0x826A8E60; continue 'dispatch;
	}
	// 826A8E40: 807D01A4  lwz r3, 0x1a4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A8E44: 48769BB5  bl 0x82e129f8
	ctx.lr = 0x826A8E48;
	sub_82E129F8(ctx, base);
	// 826A8E48: 92FB0000  stw r23, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 826A8E4C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A8E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A8E54: 92FB0004  stw r23, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 826A8E58: 419A0008  beq cr6, 0x826a8e60
	if ctx.cr[6].eq {
	pc = 0x826A8E60; continue 'dispatch;
	}
	// 826A8E5C: 4BC17A35  bl 0x822c0890
	ctx.lr = 0x826A8E60;
	sub_822C0890(ctx, base);
	// 826A8E60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A8E64: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A8E68: 4BE66661  bl 0x8250f4c8
	ctx.lr = 0x826A8E6C;
	sub_8250F4C8(ctx, base);
	// 826A8E6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A8E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8E74: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A8E78: 409A0008  bne cr6, 0x826a8e80
	if !ctx.cr[6].eq {
	pc = 0x826A8E80; continue 'dispatch;
	}
	// 826A8E7C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826A8E80: 4BE5F6A9  bl 0x82508528
	ctx.lr = 0x826A8E84;
	sub_82508528(ctx, base);
	// 826A8E84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A8E88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A8E8C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A8E90: 48781C59  bl 0x82e2aae8
	ctx.lr = 0x826A8E94;
	sub_82E2AAE8(ctx, base);
	// 826A8E94: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A8E98: 48748DF9  bl 0x82df1c90
	ctx.lr = 0x826A8E9C;
	sub_82DF1C90(ctx, base);
	// 826A8E9C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A8EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8EA4: 3BEB9EF8  addi r31, r11, -0x6108
	ctx.r[31].s64 = ctx.r[11].s64 + -24840;
	// 826A8EA8: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A8EAC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A8EB0: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 826A8EB4: 4874AB55  bl 0x82df3a08
	ctx.lr = 0x826A8EB8;
	sub_82DF3A08(ctx, base);
	// 826A8EB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A8EBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A8EC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A8EC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A8EC8: 48785FA9  bl 0x82e2ee70
	ctx.lr = 0x826A8ECC;
	sub_82E2EE70(ctx, base);
	// 826A8ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8ED0: 4874A559  bl 0x82df3428
	ctx.lr = 0x826A8ED4;
	sub_82DF3428(ctx, base);
	// 826A8ED4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826A8ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8EDC: 419A05D8  beq cr6, 0x826a94b4
	if ctx.cr[6].eq {
	pc = 0x826A94B4; continue 'dispatch;
	}
	// 826A8EE0: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A8EE4: 395F0028  addi r10, r31, 0x28
	ctx.r[10].s64 = ctx.r[31].s64 + 40;
	// 826A8EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8EEC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A8EF0: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826A8EF4: 4874AB15  bl 0x82df3a08
	ctx.lr = 0x826A8EF8;
	sub_82DF3A08(ctx, base);
	// 826A8EF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A8EFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A8F00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A8F04: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A8F08: 48785F69  bl 0x82e2ee70
	ctx.lr = 0x826A8F0C;
	sub_82E2EE70(ctx, base);
	// 826A8F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8F10: 4874A519  bl 0x82df3428
	ctx.lr = 0x826A8F14;
	sub_82DF3428(ctx, base);
	// 826A8F14: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826A8F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8F1C: 419A0588  beq cr6, 0x826a94a4
	if ctx.cr[6].eq {
	pc = 0x826A94A4; continue 'dispatch;
	}
	// 826A8F20: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A8F24: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 826A8F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8F2C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A8F30: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826A8F34: 4874AAD5  bl 0x82df3a08
	ctx.lr = 0x826A8F38;
	sub_82DF3A08(ctx, base);
	// 826A8F38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A8F3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A8F40: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A8F44: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826A8F48: 48785F29  bl 0x82e2ee70
	ctx.lr = 0x826A8F4C;
	sub_82E2EE70(ctx, base);
	// 826A8F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8F50: 4874A4D9  bl 0x82df3428
	ctx.lr = 0x826A8F54;
	sub_82DF3428(ctx, base);
	// 826A8F54: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 826A8F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8F5C: 419A0538  beq cr6, 0x826a9494
	if ctx.cr[6].eq {
	pc = 0x826A9494; continue 'dispatch;
	}
	// 826A8F60: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A8F64: 395F0078  addi r10, r31, 0x78
	ctx.r[10].s64 = ctx.r[31].s64 + 120;
	// 826A8F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8F6C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A8F70: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826A8F74: 4874AA95  bl 0x82df3a08
	ctx.lr = 0x826A8F78;
	sub_82DF3A08(ctx, base);
	// 826A8F78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A8F7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A8F80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A8F84: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A8F88: 48785EE9  bl 0x82e2ee70
	ctx.lr = 0x826A8F8C;
	sub_82E2EE70(ctx, base);
	// 826A8F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A8F90: 4874A499  bl 0x82df3428
	ctx.lr = 0x826A8F94;
	sub_82DF3428(ctx, base);
	// 826A8F94: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 826A8F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A8F9C: 419A04E8  beq cr6, 0x826a9484
	if ctx.cr[6].eq {
	pc = 0x826A9484; continue 'dispatch;
	}
	// 826A8FA0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 826A8FA4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A8FA8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826A8FAC: 3B2B18D8  addi r25, r11, 0x18d8
	ctx.r[25].s64 = ctx.r[11].s64 + 6360;
	// 826A8FB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A8FB4: C00A6150  lfs f0, 0x6150(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A8FB8: 38A00161  li r5, 0x161
	ctx.r[5].s64 = 353;
	// 826A8FBC: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 826A8FC0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A8FC4: C389D7BC  lfs f28, -0x2844(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826A8FC8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A8FCC: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 826A8FD0: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 826A8FD4: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A8FD8: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 826A8FDC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 826A8FE0: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826A8FE4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826A8FE8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826A8FEC: EC00FF3C  fnmsubs f0, f0, f28, f31
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[28].f64 - ctx.f[31].f64) as f32) as f64);
	// 826A8FF0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 826A8FF4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 826A8FF8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A8FFC: 487493ED  bl 0x82df23e8
	ctx.lr = 0x826A9000;
	sub_82DF23E8(ctx, base);
	// 826A9000: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A9004: 41820014  beq 0x826a9018
	if ctx.cr[0].eq {
	pc = 0x826A9018; continue 'dispatch;
	}
	// 826A9008: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826A900C: 4876D885  bl 0x82e16890
	ctx.lr = 0x826A9010;
	sub_82E16890(ctx, base);
	// 826A9010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A9014: 48000008  b 0x826a901c
	pc = 0x826A901C; continue 'dispatch;
	// 826A9018: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A901C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826A9020: 4BCB4351  bl 0x8235d370
	ctx.lr = 0x826A9024;
	sub_8235D370(ctx, base);
	// 826A9024: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A9028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A902C: 38A00162  li r5, 0x162
	ctx.r[5].s64 = 354;
	// 826A9030: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A9034: 487493B5  bl 0x82df23e8
	ctx.lr = 0x826A9038;
	sub_82DF23E8(ctx, base);
	// 826A9038: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A903C: 41820014  beq 0x826a9050
	if ctx.cr[0].eq {
	pc = 0x826A9050; continue 'dispatch;
	}
	// 826A9040: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A9044: 4876D84D  bl 0x82e16890
	ctx.lr = 0x826A9048;
	sub_82E16890(ctx, base);
	// 826A9048: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A904C: 48000008  b 0x826a9054
	pc = 0x826A9054; continue 'dispatch;
	// 826A9050: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A9054: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 826A9058: 4BCB4319  bl 0x8235d370
	ctx.lr = 0x826A905C;
	sub_8235D370(ctx, base);
	// 826A905C: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	// 826A9060: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 826A9064: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 826A9068: 419A0058  beq cr6, 0x826a90c0
	if ctx.cr[6].eq {
	pc = 0x826A90C0; continue 'dispatch;
	}
	// 826A906C: 3B9D0194  addi r28, r29, 0x194
	ctx.r[28].s64 = ctx.r[29].s64 + 404;
	// 826A9070: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 826A9074: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A9078: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A907C: 38A00166  li r5, 0x166
	ctx.r[5].s64 = 358;
	// 826A9080: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A9084: 48749365  bl 0x82df23e8
	ctx.lr = 0x826A9088;
	sub_82DF23E8(ctx, base);
	// 826A9088: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A908C: 41820014  beq 0x826a90a0
	if ctx.cr[0].eq {
	pc = 0x826A90A0; continue 'dispatch;
	}
	// 826A9090: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A9094: 4876D7FD  bl 0x82e16890
	ctx.lr = 0x826A9098;
	sub_82E16890(ctx, base);
	// 826A9098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A909C: 48000008  b 0x826a90a4
	pc = 0x826A90A4; continue 'dispatch;
	// 826A90A0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A90A4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A90A8: 4BCB42C9  bl 0x8235d370
	ctx.lr = 0x826A90AC;
	sub_8235D370(ctx, base);
	// 826A90AC: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826A90B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A90B4: 4850A055  bl 0x82bb3108
	ctx.lr = 0x826A90B8;
	sub_82BB3108(ctx, base);
	// 826A90B8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826A90BC: 4082FFB8  bne 0x826a9074
	if !ctx.cr[0].eq {
	pc = 0x826A9074; continue 'dispatch;
	}
	// 826A90C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A90C4: 419A0054  beq cr6, 0x826a9118
	if ctx.cr[6].eq {
	pc = 0x826A9118; continue 'dispatch;
	}
	// 826A90C8: 3BDD0194  addi r30, r29, 0x194
	ctx.r[30].s64 = ctx.r[29].s64 + 404;
	// 826A90CC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A90D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A90D4: 38A0016B  li r5, 0x16b
	ctx.r[5].s64 = 363;
	// 826A90D8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A90DC: 4874930D  bl 0x82df23e8
	ctx.lr = 0x826A90E0;
	sub_82DF23E8(ctx, base);
	// 826A90E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A90E4: 41820014  beq 0x826a90f8
	if ctx.cr[0].eq {
	pc = 0x826A90F8; continue 'dispatch;
	}
	// 826A90E8: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826A90EC: 4876D7A5  bl 0x82e16890
	ctx.lr = 0x826A90F0;
	sub_82E16890(ctx, base);
	// 826A90F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A90F4: 48000008  b 0x826a90fc
	pc = 0x826A90FC; continue 'dispatch;
	// 826A90F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A90FC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A9100: 4BCB4271  bl 0x8235d370
	ctx.lr = 0x826A9104;
	sub_8235D370(ctx, base);
	// 826A9104: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826A9108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A910C: 48509FFD  bl 0x82bb3108
	ctx.lr = 0x826A9110;
	sub_82BB3108(ctx, base);
	// 826A9110: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A9114: 4082FFB8  bne 0x826a90cc
	if !ctx.cr[0].eq {
	pc = 0x826A90CC; continue 'dispatch;
	}
	// 826A9118: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A911C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A9120: 38A00170  li r5, 0x170
	ctx.r[5].s64 = 368;
	// 826A9124: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A9128: 487492C1  bl 0x82df23e8
	ctx.lr = 0x826A912C;
	sub_82DF23E8(ctx, base);
	// 826A912C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A9130: 41820034  beq 0x826a9164
	if ctx.cr[0].eq {
	pc = 0x826A9164; continue 'dispatch;
	}
	// 826A9134: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826A9138: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A913C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A9140: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A9144: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A9148: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826A914C: 487D389D  bl 0x82e7c9e8
	ctx.lr = 0x826A9150;
	sub_82E7C9E8(ctx, base);
	// 826A9150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A9154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9158: 48769F99  bl 0x82e130f0
	ctx.lr = 0x826A915C;
	sub_82E130F0(ctx, base);
	// 826A915C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A9160: 48000008  b 0x826a9168
	pc = 0x826A9168; continue 'dispatch;
	// 826A9164: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A9168: 3BFD01AC  addi r31, r29, 0x1ac
	ctx.r[31].s64 = ctx.r[29].s64 + 428;
	// 826A916C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9170: 4BC38BE1  bl 0x822e1d50
	ctx.lr = 0x826A9174;
	sub_822E1D50(ctx, base);
	// 826A9174: 809D01AC  lwz r4, 0x1ac(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(428 as u32) ) } as u64;
	// 826A9178: 807D01A4  lwz r3, 0x1a4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A917C: 48769CB5  bl 0x82e12e30
	ctx.lr = 0x826A9180;
	sub_82E12E30(ctx, base);
	// 826A9180: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A9184: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A9188: 38A00172  li r5, 0x172
	ctx.r[5].s64 = 370;
	// 826A918C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A9190: 48749259  bl 0x82df23e8
	ctx.lr = 0x826A9194;
	sub_82DF23E8(ctx, base);
	// 826A9194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A9198: 41820018  beq 0x826a91b0
	if ctx.cr[0].eq {
	pc = 0x826A91B0; continue 'dispatch;
	}
	// 826A919C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A91A0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A91A4: 48769F4D  bl 0x82e130f0
	ctx.lr = 0x826A91A8;
	sub_82E130F0(ctx, base);
	// 826A91A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A91AC: 48000008  b 0x826a91b4
	pc = 0x826A91B4; continue 'dispatch;
	// 826A91B0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A91B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826A91B8: 4BC38B99  bl 0x822e1d50
	ctx.lr = 0x826A91BC;
	sub_822E1D50(ctx, base);
	// 826A91BC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A91C0: 807D01A4  lwz r3, 0x1a4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A91C4: 48769C6D  bl 0x82e12e30
	ctx.lr = 0x826A91C8;
	sub_82E12E30(ctx, base);
	// 826A91C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A91CC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A91D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A91D4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826A91D8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826A91DC: 419A0024  beq cr6, 0x826a9200
	if ctx.cr[6].eq {
	pc = 0x826A9200; continue 'dispatch;
	}
	// 826A91E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A91E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A91E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A91EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A91F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A91F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A91F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A91FC: 4082FFE8  bne 0x826a91e4
	if !ctx.cr[0].eq {
	pc = 0x826A91E4; continue 'dispatch;
	}
	// 826A9200: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826A9204: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A9208: 4876BEA9  bl 0x82e150b0
	ctx.lr = 0x826A920C;
	sub_82E150B0(ctx, base);
	// 826A920C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A9210: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A9214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A9218: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A921C: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 826A9220: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826A9224: 835B0000  lwz r26, 0(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A9228: 419A0024  beq cr6, 0x826a924c
	if ctx.cr[6].eq {
	pc = 0x826A924C; continue 'dispatch;
	}
	// 826A922C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A9230: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A9234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A9238: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A923C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A9240: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A9244: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A9248: 4082FFE8  bne 0x826a9230
	if !ctx.cr[0].eq {
	pc = 0x826A9230; continue 'dispatch;
	}
	// 826A924C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A9250: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 826A9254: 3B7D0194  addi r27, r29, 0x194
	ctx.r[27].s64 = ctx.r[29].s64 + 404;
	// 826A9258: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 826A925C: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 826A9260: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 826A9264: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A9268: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A926C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A9270: 419A00F0  beq cr6, 0x826a9360
	if ctx.cr[6].eq {
	pc = 0x826A9360; continue 'dispatch;
	}
	// 826A9274: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A9278: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826A927C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 826A9280: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A9284: 409800DC  bge cr6, 0x826a9360
	if !ctx.cr[6].lt {
	pc = 0x826A9360; continue 'dispatch;
	}
	// 826A9288: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A928C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A9290: 38A0017A  li r5, 0x17a
	ctx.r[5].s64 = 378;
	// 826A9294: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A9298: 48749151  bl 0x82df23e8
	ctx.lr = 0x826A929C;
	sub_82DF23E8(ctx, base);
	// 826A929C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A92A0: 4182002C  beq 0x826a92cc
	if ctx.cr[0].eq {
	pc = 0x826A92CC; continue 'dispatch;
	}
	// 826A92A4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A92A8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A92AC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A92B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A92B4: 487D2D65  bl 0x82e7c018
	ctx.lr = 0x826A92B8;
	sub_82E7C018(ctx, base);
	// 826A92B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A92BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A92C0: 48769E31  bl 0x82e130f0
	ctx.lr = 0x826A92C4;
	sub_82E130F0(ctx, base);
	// 826A92C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A92C8: 48000008  b 0x826a92d0
	pc = 0x826A92D0; continue 'dispatch;
	// 826A92CC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A92D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A92D4: 4BC38A7D  bl 0x822e1d50
	ctx.lr = 0x826A92D8;
	sub_822E1D50(ctx, base);
	// 826A92D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826A92DC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A92E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A92E4: 48769B4D  bl 0x82e12e30
	ctx.lr = 0x826A92E8;
	sub_82E12E30(ctx, base);
	// 826A92E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A92EC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826A92F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A92F4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826A92F8: 419A0024  beq cr6, 0x826a931c
	if ctx.cr[6].eq {
	pc = 0x826A931C; continue 'dispatch;
	}
	// 826A92FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A9300: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A9304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A9308: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A930C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A9310: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A9314: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A9318: 4082FFE8  bne 0x826a9300
	if !ctx.cr[0].eq {
	pc = 0x826A9300; continue 'dispatch;
	}
	// 826A931C: 817D0198  lwz r11, 0x198(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A9320: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A9324: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826A9328: 4876BD89  bl 0x82e150b0
	ctx.lr = 0x826A932C;
	sub_82E150B0(ctx, base);
	// 826A932C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 826A9330: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A9334: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 826A9338: 4BC1B129  bl 0x822c4460
	ctx.lr = 0x826A933C;
	sub_822C4460(ctx, base);
	// 826A933C: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 826A9340: 4098000C  bge cr6, 0x826a934c
	if !ctx.cr[6].lt {
	pc = 0x826A934C; continue 'dispatch;
	}
	// 826A9344: FFE0E090  fmr f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[28].f64;
	// 826A9348: 48000008  b 0x826a9350
	pc = 0x826A9350; continue 'dispatch;
	// 826A934C: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 826A9350: 83410070  lwz r26, 0x70(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826A9354: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826A9358: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 826A935C: 4BFFFF0C  b 0x826a9268
	pc = 0x826A9268; continue 'dispatch;
	// 826A9360: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A9364: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A9368: 38A00187  li r5, 0x187
	ctx.r[5].s64 = 391;
	// 826A936C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A9370: 48749079  bl 0x82df23e8
	ctx.lr = 0x826A9374;
	sub_82DF23E8(ctx, base);
	// 826A9374: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A9378: 4182002C  beq 0x826a93a4
	if ctx.cr[0].eq {
	pc = 0x826A93A4; continue 'dispatch;
	}
	// 826A937C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A9380: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A9384: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A9388: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A938C: 487D2C8D  bl 0x82e7c018
	ctx.lr = 0x826A9390;
	sub_82E7C018(ctx, base);
	// 826A9390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A9394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9398: 48769D59  bl 0x82e130f0
	ctx.lr = 0x826A939C;
	sub_82E130F0(ctx, base);
	// 826A939C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A93A0: 48000008  b 0x826a93a8
	pc = 0x826A93A8; continue 'dispatch;
	// 826A93A4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A93A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A93AC: 4BC389A5  bl 0x822e1d50
	ctx.lr = 0x826A93B0;
	sub_822E1D50(ctx, base);
	// 826A93B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826A93B4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A93B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A93BC: 48769A75  bl 0x82e12e30
	ctx.lr = 0x826A93C0;
	sub_82E12E30(ctx, base);
	// 826A93C0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A93C4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826A93C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826A93CC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826A93D0: 419A0024  beq cr6, 0x826a93f4
	if ctx.cr[6].eq {
	pc = 0x826A93F4; continue 'dispatch;
	}
	// 826A93D4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826A93D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A93DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A93E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A93E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A93E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A93EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A93F0: 4082FFE8  bne 0x826a93d8
	if !ctx.cr[0].eq {
	pc = 0x826A93D8; continue 'dispatch;
	}
	// 826A93F4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A93F8: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A93FC: 4876BCB5  bl 0x82e150b0
	ctx.lr = 0x826A9400;
	sub_82E150B0(ctx, base);
	// 826A9400: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A9404: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 826A9408: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A940C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A9410: 4BE67749  bl 0x82510b58
	ctx.lr = 0x826A9414;
	sub_82510B58(ctx, base);
	// 826A9414: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A9418: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 826A941C: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A9420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A9424: 4BE67735  bl 0x82510b58
	ctx.lr = 0x826A9428;
	sub_82510B58(ctx, base);
	// 826A9428: 83FD0198  lwz r31, 0x198(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A942C: 4800001C  b 0x826a9448
	pc = 0x826A9448; continue 'dispatch;
	// 826A9430: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A9434: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A9438: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A943C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A9440: 4BE67719  bl 0x82510b58
	ctx.lr = 0x826A9444;
	sub_82510B58(ctx, base);
	// 826A9444: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826A9448: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A944C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A9450: 409AFFE0  bne cr6, 0x826a9430
	if !ctx.cr[6].eq {
	pc = 0x826A9430; continue 'dispatch;
	}
	// 826A9454: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826A9458: 419A000C  beq cr6, 0x826a9464
	if ctx.cr[6].eq {
	pc = 0x826A9464; continue 'dispatch;
	}
	// 826A945C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A9460: 4BC17431  bl 0x822c0890
	ctx.lr = 0x826A9464;
	sub_822C0890(ctx, base);
	// 826A9464: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A9468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A946C: 419A0008  beq cr6, 0x826a9474
	if ctx.cr[6].eq {
	pc = 0x826A9474; continue 'dispatch;
	}
	// 826A9470: 4BC17421  bl 0x822c0890
	ctx.lr = 0x826A9474;
	sub_822C0890(ctx, base);
	// 826A9474: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826A9478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A947C: 419A0008  beq cr6, 0x826a9484
	if ctx.cr[6].eq {
	pc = 0x826A9484; continue 'dispatch;
	}
	// 826A9480: 4BC17411  bl 0x822c0890
	ctx.lr = 0x826A9484;
	sub_822C0890(ctx, base);
	// 826A9484: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826A9488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A948C: 419A0008  beq cr6, 0x826a9494
	if ctx.cr[6].eq {
	pc = 0x826A9494; continue 'dispatch;
	}
	// 826A9490: 4BC17401  bl 0x822c0890
	ctx.lr = 0x826A9494;
	sub_822C0890(ctx, base);
	// 826A9494: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826A9498: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A949C: 419A0008  beq cr6, 0x826a94a4
	if ctx.cr[6].eq {
	pc = 0x826A94A4; continue 'dispatch;
	}
	// 826A94A0: 4BC173F1  bl 0x822c0890
	ctx.lr = 0x826A94A4;
	sub_822C0890(ctx, base);
	// 826A94A4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826A94A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A94AC: 419A0008  beq cr6, 0x826a94b4
	if ctx.cr[6].eq {
	pc = 0x826A94B4; continue 'dispatch;
	}
	// 826A94B0: 4BC173E1  bl 0x822c0890
	ctx.lr = 0x826A94B4;
	sub_822C0890(ctx, base);
	// 826A94B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826A94B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A94BC: 419A0008  beq cr6, 0x826a94c4
	if ctx.cr[6].eq {
	pc = 0x826A94C4; continue 'dispatch;
	}
	// 826A94C0: 4BC173D1  bl 0x822c0890
	ctx.lr = 0x826A94C4;
	sub_822C0890(ctx, base);
	// 826A94C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A94C8: 48781639  bl 0x82e2ab00
	ctx.lr = 0x826A94CC;
	sub_82E2AB00(ctx, base);
	// 826A94CC: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 826A94D0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 826A94D4: 48AFF5F1  bl 0x831a8ac4
	ctx.lr = 0x826A94D8;
	sub_831A8A8C(ctx, base);
	// 826A94D8: 48AFECC0  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A94E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826A94E0 size=8
    let mut pc: u32 = 0x826A94E0;
    'dispatch: loop {
        match pc {
            0x826A94E0 => {
    //   block [0x826A94E0..0x826A94E8)
	// 826A94E0: C02301C0  lfs f1, 0x1c0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(448 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A94E4: 4BFFF84C  b 0x826a8d30
	sub_826A8D30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A94E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A94E8 size=448
    let mut pc: u32 = 0x826A94E8;
    'dispatch: loop {
        match pc {
            0x826A94E8 => {
    //   block [0x826A94E8..0x826A96A8)
	// 826A94E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A94EC: 48AFEC81  bl 0x831a816c
	ctx.lr = 0x826A94F0;
	sub_831A8130(ctx, base);
	// 826A94F0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A94F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A94F8: 4BFFE4E9  bl 0x826a79e0
	ctx.lr = 0x826A94FC;
	sub_826A79E0(ctx, base);
	// 826A94FC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9500: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A9504: 388B18D8  addi r4, r11, 0x18d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6360;
	// 826A9508: 38A000C3  li r5, 0xc3
	ctx.r[5].s64 = 195;
	// 826A950C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A9510: 48748ED9  bl 0x82df23e8
	ctx.lr = 0x826A9514;
	sub_82DF23E8(ctx, base);
	// 826A9514: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A9518: 41820018  beq 0x826a9530
	if ctx.cr[0].eq {
	pc = 0x826A9530; continue 'dispatch;
	}
	// 826A951C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A9520: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A9524: 48769BCD  bl 0x82e130f0
	ctx.lr = 0x826A9528;
	sub_82E130F0(ctx, base);
	// 826A9528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A952C: 48000008  b 0x826a9534
	pc = 0x826A9534; continue 'dispatch;
	// 826A9530: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A9534: 3BDF01A4  addi r30, r31, 0x1a4
	ctx.r[30].s64 = ctx.r[31].s64 + 420;
	// 826A9538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A953C: 4BC38815  bl 0x822e1d50
	ctx.lr = 0x826A9540;
	sub_822E1D50(ctx, base);
	// 826A9540: 809F01A4  lwz r4, 0x1a4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A9544: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A9548: 487698E9  bl 0x82e12e30
	ctx.lr = 0x826A954C;
	sub_82E12E30(ctx, base);
	// 826A954C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9550: C03F01C0  lfs f1, 0x1c0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A9554: 4BFFF7DD  bl 0x826a8d30
	ctx.lr = 0x826A9558;
	sub_826A8D30(ctx, base);
	// 826A9558: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A955C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826A9560: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826A9564: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826A9568: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826A956C: 487F71C5  bl 0x82ea0730
	ctx.lr = 0x826A9570;
	sub_82EA0730(ctx, base);
	// 826A9570: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826A9574: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 826A9578: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826A957C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 826A9580: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 826A9584: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A9588: C01F01C0  lfs f0, 0x1c0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A958C: C04BF614  lfs f2, -0x9ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A9590: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A9594: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 826A9598: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826A959C: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 826A95A0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A95A4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826A95A8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A95AC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826A95B0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 826A95B4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826A95B8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A95BC: 13C038C7  vcmpequd (lvx128) v30, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A95C0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A96A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A96A8 size=412
    let mut pc: u32 = 0x826A96A8;
    'dispatch: loop {
        match pc {
            0x826A96A8 => {
    //   block [0x826A96A8..0x826A9844)
	// 826A96A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A96AC: 48AFEAC1  bl 0x831a816c
	ctx.lr = 0x826A96B0;
	sub_831A8130(ctx, base);
	// 826A96B0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A96B4: 3D60826B  lis r11, -0x7d95
	ctx.r[11].s64 = -2106916864;
	// 826A96B8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A96BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A96C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826A96C4: 396B94E0  addi r11, r11, -0x6b20
	ctx.r[11].s64 = ctx.r[11].s64 + -27424;
	// 826A96C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826A96CC: 388AD3FC  addi r4, r10, -0x2c04
	ctx.r[4].s64 = ctx.r[10].s64 + -11268;
	// 826A96D0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826A96D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A96D8: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 826A96DC: 4874A32D  bl 0x82df3a08
	ctx.lr = 0x826A96E0;
	sub_82DF3A08(ctx, base);
	// 826A96E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A96E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A96E8: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 826A96EC: 4874A31D  bl 0x82df3a08
	ctx.lr = 0x826A96F0;
	sub_82DF3A08(ctx, base);
	// 826A96F0: 397FFF1C  addi r11, r31, -0xe4
	ctx.r[11].s64 = ctx.r[31].s64 + -228;
	// 826A96F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A96F8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 826A96FC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826A9700: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 826A9704: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 826A9708: 4BFFF001  bl 0x826a8708
	ctx.lr = 0x826A970C;
	sub_826A8708(ctx, base);
	// 826A970C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A9710: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 826A9714: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826A9718: 38BF00DC  addi r5, r31, 0xdc
	ctx.r[5].s64 = ctx.r[31].s64 + 220;
	// 826A971C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A9720: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826A9724: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826A9728: C04A9A8C  lfs f2, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A972C: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 826A9730: 4BEF9AF9  bl 0x825a3228
	ctx.lr = 0x826A9734;
	sub_825A3228(ctx, base);
	// 826A9734: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A9738: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A973C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A9740: 4BEF8031  bl 0x825a1770
	ctx.lr = 0x826A9744;
	sub_825A1770(ctx, base);
	// 826A9744: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826A9748: 48749CE1  bl 0x82df3428
	ctx.lr = 0x826A974C;
	sub_82DF3428(ctx, base);
	// 826A974C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826A9750: 4BC1F569  bl 0x822c8cb8
	ctx.lr = 0x826A9754;
	sub_822C8CB8(ctx, base);
	// 826A9754: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9758: 48749CD1  bl 0x82df3428
	ctx.lr = 0x826A975C;
	sub_82DF3428(ctx, base);
	// 826A975C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9760: 48749CC9  bl 0x82df3428
	ctx.lr = 0x826A9764;
	sub_82DF3428(ctx, base);
	// 826A9764: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A9768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A976C: 4BFFD54D  bl 0x826a6cb8
	ctx.lr = 0x826A9770;
	sub_826A6CB8(ctx, base);
	// 826A9770: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9774: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9778: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 826A977C: 4874A28D  bl 0x82df3a08
	ctx.lr = 0x826A9780;
	sub_82DF3A08(ctx, base);
	// 826A9780: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9788: 388B18B4  addi r4, r11, 0x18b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6324;
	// 826A978C: 4874A27D  bl 0x82df3a08
	ctx.lr = 0x826A9790;
	sub_82DF3A08(ctx, base);
	// 826A9790: 38BF00E0  addi r5, r31, 0xe0
	ctx.r[5].s64 = ctx.r[31].s64 + 224;
	// 826A9794: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A9798: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A979C: 4BEF98B5  bl 0x825a3050
	ctx.lr = 0x826A97A0;
	sub_825A3050(ctx, base);
	// 826A97A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A97A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A97A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A97AC: 4BEF89DD  bl 0x825a2188
	ctx.lr = 0x826A97B0;
	sub_825A2188(ctx, base);
	// 826A97B0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826A97B4: 48749C75  bl 0x82df3428
	ctx.lr = 0x826A97B8;
	sub_82DF3428(ctx, base);
	// 826A97B8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A97BC: 4BC1F4FD  bl 0x822c8cb8
	ctx.lr = 0x826A97C0;
	sub_822C8CB8(ctx, base);
	// 826A97C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A97C4: 48749C65  bl 0x82df3428
	ctx.lr = 0x826A97C8;
	sub_82DF3428(ctx, base);
	// 826A97C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A97CC: 48749C5D  bl 0x82df3428
	ctx.lr = 0x826A97D0;
	sub_82DF3428(ctx, base);
	// 826A97D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A97D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A97D8: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826A97DC: 4874A22D  bl 0x82df3a08
	ctx.lr = 0x826A97E0;
	sub_82DF3A08(ctx, base);
	// 826A97E0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A97E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A97E8: 388B18A4  addi r4, r11, 0x18a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6308;
	// 826A97EC: 4874A21D  bl 0x82df3a08
	ctx.lr = 0x826A97F0;
	sub_82DF3A08(ctx, base);
	// 826A97F0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826A97F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A97F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A97FC: 38BF00E4  addi r5, r31, 0xe4
	ctx.r[5].s64 = ctx.r[31].s64 + 228;
	// 826A9800: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A9804: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826A9808: 4BEF9C11  bl 0x825a3418
	ctx.lr = 0x826A980C;
	sub_825A3418(ctx, base);
	// 826A980C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A9810: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A9814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A9818: 4BEF86C1  bl 0x825a1ed8
	ctx.lr = 0x826A981C;
	sub_825A1ED8(ctx, base);
	// 826A981C: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 826A9820: 48749C09  bl 0x82df3428
	ctx.lr = 0x826A9824;
	sub_82DF3428(ctx, base);
	// 826A9824: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826A9828: 4BC1F491  bl 0x822c8cb8
	ctx.lr = 0x826A982C;
	sub_822C8CB8(ctx, base);
	// 826A982C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9830: 48749BF9  bl 0x82df3428
	ctx.lr = 0x826A9834;
	sub_82DF3428(ctx, base);
	// 826A9834: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9838: 48749BF1  bl 0x82df3428
	ctx.lr = 0x826A983C;
	sub_82DF3428(ctx, base);
	// 826A983C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 826A9840: 48AFE97C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9848 size=220
    let mut pc: u32 = 0x826A9848;
    'dispatch: loop {
        match pc {
            0x826A9848 => {
    //   block [0x826A9848..0x826A9924)
	// 826A9848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A984C: 48AFE91D  bl 0x831a8168
	ctx.lr = 0x826A9850;
	sub_831A8130(ctx, base);
	// 826A9850: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A9858: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A985C: 4BFFB63D  bl 0x826a4e98
	ctx.lr = 0x826A9860;
	sub_826A4E98(ctx, base);
	// 826A9860: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9868: 3BAB18B4  addi r29, r11, 0x18b4
	ctx.r[29].s64 = ctx.r[11].s64 + 6324;
	// 826A986C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A9870: 4874A199  bl 0x82df3a08
	ctx.lr = 0x826A9874;
	sub_82DF3A08(ctx, base);
	// 826A9874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9878: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A987C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A9880: 4BEF7D09  bl 0x825a1588
	ctx.lr = 0x826A9884;
	sub_825A1588(ctx, base);
	// 826A9884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9888: 48749BA1  bl 0x82df3428
	ctx.lr = 0x826A988C;
	sub_82DF3428(ctx, base);
	// 826A988C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9894: 3B8B18A4  addi r28, r11, 0x18a4
	ctx.r[28].s64 = ctx.r[11].s64 + 6308;
	// 826A9898: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A989C: 4874A16D  bl 0x82df3a08
	ctx.lr = 0x826A98A0;
	sub_82DF3A08(ctx, base);
	// 826A98A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A98A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A98A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A98AC: 4BEF7CDD  bl 0x825a1588
	ctx.lr = 0x826A98B0;
	sub_825A1588(ctx, base);
	// 826A98B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A98B4: 48749B75  bl 0x82df3428
	ctx.lr = 0x826A98B8;
	sub_82DF3428(ctx, base);
	// 826A98B8: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 826A98BC: 4BFFBFBD  bl 0x826a5878
	ctx.lr = 0x826A98C0;
	sub_826A5878(ctx, base);
	// 826A98C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A98C4: 41820058  beq 0x826a991c
	if ctx.cr[0].eq {
	pc = 0x826A991C; continue 'dispatch;
	}
	// 826A98C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A98CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A98D0: 4874A139  bl 0x82df3a08
	ctx.lr = 0x826A98D4;
	sub_82DF3A08(ctx, base);
	// 826A98D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A98D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A98DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A98E0: 4BEF7CA9  bl 0x825a1588
	ctx.lr = 0x826A98E4;
	sub_825A1588(ctx, base);
	// 826A98E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A98E8: 48749B41  bl 0x82df3428
	ctx.lr = 0x826A98EC;
	sub_82DF3428(ctx, base);
	// 826A98EC: 897E00C0  lbz r11, 0xc0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 826A98F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A98F4: 41820028  beq 0x826a991c
	if ctx.cr[0].eq {
	pc = 0x826A991C; continue 'dispatch;
	}
	// 826A98F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A98FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9900: 4874A109  bl 0x82df3a08
	ctx.lr = 0x826A9904;
	sub_82DF3A08(ctx, base);
	// 826A9904: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A9908: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A990C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9910: 4BEF7C79  bl 0x825a1588
	ctx.lr = 0x826A9914;
	sub_825A1588(ctx, base);
	// 826A9914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9918: 48749B11  bl 0x82df3428
	ctx.lr = 0x826A991C;
	sub_82DF3428(ctx, base);
	// 826A991C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A9920: 48AFE898  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9928 size=148
    let mut pc: u32 = 0x826A9928;
    'dispatch: loop {
        match pc {
            0x826A9928 => {
    //   block [0x826A9928..0x826A99BC)
	// 826A9928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A992C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A993C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9940: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A9944: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A9948: 396B1D8C  addi r11, r11, 0x1d8c
	ctx.r[11].s64 = ctx.r[11].s64 + 7564;
	// 826A994C: 394A1D78  addi r10, r10, 0x1d78
	ctx.r[10].s64 = ctx.r[10].s64 + 7544;
	// 826A9950: 39291D2C  addi r9, r9, 0x1d2c
	ctx.r[9].s64 = ctx.r[9].s64 + 7468;
	// 826A9954: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A9958: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A995C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A9960: 807F01A0  lwz r3, 0x1a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 826A9964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A9968: 419A0008  beq cr6, 0x826a9970
	if ctx.cr[6].eq {
	pc = 0x826A9970; continue 'dispatch;
	}
	// 826A996C: 4BC16F25  bl 0x822c0890
	ctx.lr = 0x826A9970;
	sub_822C0890(ctx, base);
	// 826A9970: 807F0198  lwz r3, 0x198(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A9974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A9978: 419A0008  beq cr6, 0x826a9980
	if ctx.cr[6].eq {
	pc = 0x826A9980; continue 'dispatch;
	}
	// 826A997C: 4BC16F15  bl 0x822c0890
	ctx.lr = 0x826A9980;
	sub_822C0890(ctx, base);
	// 826A9980: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826A9984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A9988: 419A0008  beq cr6, 0x826a9990
	if ctx.cr[6].eq {
	pc = 0x826A9990; continue 'dispatch;
	}
	// 826A998C: 4BC16F05  bl 0x822c0890
	ctx.lr = 0x826A9990;
	sub_822C0890(ctx, base);
	// 826A9990: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826A9994: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A9998: 419A0008  beq cr6, 0x826a99a0
	if ctx.cr[6].eq {
	pc = 0x826A99A0; continue 'dispatch;
	}
	// 826A999C: 4BC16EF5  bl 0x822c0890
	ctx.lr = 0x826A99A0;
	sub_822C0890(ctx, base);
	// 826A99A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A99A4: 4BFFCE65  bl 0x826a6808
	ctx.lr = 0x826A99A8;
	sub_826A6808(ctx, base);
	// 826A99A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A99AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A99B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A99B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A99B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A99C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A99C0 size=8
    let mut pc: u32 = 0x826A99C0;
    'dispatch: loop {
        match pc {
            0x826A99C0 => {
    //   block [0x826A99C0..0x826A99C8)
	// 826A99C0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826A99C4: 480003D4  b 0x826a9d98
	sub_826A9D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A99C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A99C8 size=8
    let mut pc: u32 = 0x826A99C8;
    'dispatch: loop {
        match pc {
            0x826A99C8 => {
    //   block [0x826A99C8..0x826A99D0)
	// 826A99C8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826A99CC: 480003CC  b 0x826a9d98
	sub_826A9D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A99D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A99D0 size=328
    let mut pc: u32 = 0x826A99D0;
    'dispatch: loop {
        match pc {
            0x826A99D0 => {
    //   block [0x826A99D0..0x826A9B18)
	// 826A99D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A99D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A99D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A99DC: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 826A99E0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A99E4: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A99E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A99EC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A99F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A99F4: 419A0108  beq cr6, 0x826a9afc
	if ctx.cr[6].eq {
	pc = 0x826A9AFC; continue 'dispatch;
	}
	// 826A99F8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826A99FC: 4BC266B5  bl 0x822d00b0
	ctx.lr = 0x826A9A00;
	sub_822D00B0(ctx, base);
	// 826A9A00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A9A04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A9A08: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826A9A0C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A9A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9A14: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A9A18: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A9A1C: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826A9A20: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826A9A24: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826A9A28: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826A9A2C: 487D38F5  bl 0x82e7d320
	ctx.lr = 0x826A9A30;
	sub_82E7D320(ctx, base);
	// 826A9A30: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 826A9A34: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A9A38: 409A0044  bne cr6, 0x826a9a7c
	if !ctx.cr[6].eq {
	pc = 0x826A9A7C; continue 'dispatch;
	}
	// 826A9A3C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826A9A40: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A9A44: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 826A9A48: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A9A4C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A9A50: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A9A54: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A9A58: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A9A5C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826A9A60: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A9A64: FC005850  fneg f0, f11
	ctx.f[0].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A9A68: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826A9A6C: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826A9A70: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826A9A74: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A9B18 size=288
    let mut pc: u32 = 0x826A9B18;
    'dispatch: loop {
        match pc {
            0x826A9B18 => {
    //   block [0x826A9B18..0x826A9C38)
	// 826A9B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9B24: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9B28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A9B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A9B30: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826A9B34: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826A9B38: 80630194  lwz r3, 0x194(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 826A9B3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A9B40: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A9B44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A9B48: 4E800421  bctrl
	ctx.lr = 0x826A9B4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A9B4C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826A9B50: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826A9B54: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A9B58: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826A9B5C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 826A9B60: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 826A9B64: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A9B68: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 826A9B6C: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 826A9B70: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A9B74: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A9B78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9C38 size=196
    let mut pc: u32 = 0x826A9C38;
    'dispatch: loop {
        match pc {
            0x826A9C38 => {
    //   block [0x826A9C38..0x826A9CFC)
	// 826A9C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9C40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A9C44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9C4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A9C50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A9C54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A9C58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A9C5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A9C60: 4BC16CD9  bl 0x822c0938
	ctx.lr = 0x826A9C64;
	sub_822C0938(ctx, base);
	// 826A9C64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A9C68: 41820028  beq 0x826a9c90
	if ctx.cr[0].eq {
	pc = 0x826A9C90; continue 'dispatch;
	}
	// 826A9C6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9C70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A9C74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A9C78: 392B1D14  addi r9, r11, 0x1d14
	ctx.r[9].s64 = ctx.r[11].s64 + 7444;
	// 826A9C7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A9C80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A9C84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A9C88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A9C8C: 48000008  b 0x826a9c94
	pc = 0x826A9C94; continue 'dispatch;
	// 826A9C90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A9C94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A9C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A9C9C: 409A0044  bne cr6, 0x826a9ce0
	if !ctx.cr[6].eq {
	pc = 0x826A9CE0; continue 'dispatch;
	}
	// 826A9CA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A9CA4: 419A001C  beq cr6, 0x826a9cc0
	if ctx.cr[6].eq {
	pc = 0x826A9CC0; continue 'dispatch;
	}
	// 826A9CA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A9CAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A9CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9CB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A9CB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A9CBC: 4E800421  bctrl
	ctx.lr = 0x826A9CC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A9CC0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A9CC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A9CC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9CCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A9CD0: 816BA14C  lwz r11, -0x5eb4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24244 as u32) ) } as u64;
	// 826A9CD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A9CD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A9CDC: 4BC16325  bl 0x822c0000
	ctx.lr = 0x826A9CE0;
	sub_822C0000(ctx, base);
	// 826A9CE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A9CE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A9CE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A9CEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A9CF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A9CF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A9CF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9D00 size=148
    let mut pc: u32 = 0x826A9D00;
    'dispatch: loop {
        match pc {
            0x826A9D00 => {
    //   block [0x826A9D00..0x826A9D94)
	// 826A9D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9D08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A9D0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9D10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9D14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A9D18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A9D1C: 4BFFCE05  bl 0x826a6b20
	ctx.lr = 0x826A9D20;
	sub_826A6B20(ctx, base);
	// 826A9D20: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9D24: 93DF0180  stw r30, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 826A9D28: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A9D2C: 396B1D8C  addi r11, r11, 0x1d8c
	ctx.r[11].s64 = ctx.r[11].s64 + 7564;
	// 826A9D30: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A9D34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A9D38: 394A1D78  addi r10, r10, 0x1d78
	ctx.r[10].s64 = ctx.r[10].s64 + 7544;
	// 826A9D3C: 39291D2C  addi r9, r9, 0x1d2c
	ctx.r[9].s64 = ctx.r[9].s64 + 7468;
	// 826A9D40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A9D44: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A9D48: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A9D4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A9D50: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 826A9D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9D58: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 826A9D5C: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826A9D60: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 826A9D64: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 826A9D68: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 826A9D6C: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 826A9D70: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 826A9D74: 995F01A4  stb r10, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[10].u8 ) };
	// 826A9D78: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 826A9D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A9D80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A9D84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A9D88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A9D8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A9D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9D98 size=76
    let mut pc: u32 = 0x826A9D98;
    'dispatch: loop {
        match pc {
            0x826A9D98 => {
    //   block [0x826A9D98..0x826A9DE4)
	// 826A9D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A9DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9DA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9DAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A9DB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A9DB4: 4BFFFB75  bl 0x826a9928
	ctx.lr = 0x826A9DB8;
	sub_826A9928(ctx, base);
	// 826A9DB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A9DBC: 4182000C  beq 0x826a9dc8
	if ctx.cr[0].eq {
	pc = 0x826A9DC8; continue 'dispatch;
	}
	// 826A9DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9DC4: 48748615  bl 0x82df23d8
	ctx.lr = 0x826A9DC8;
	sub_82DF23D8(ctx, base);
	// 826A9DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9DCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A9DD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A9DD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A9DD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A9DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A9DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9DE8 size=100
    let mut pc: u32 = 0x826A9DE8;
    'dispatch: loop {
        match pc {
            0x826A9DE8 => {
    //   block [0x826A9DE8..0x826A9E4C)
	// 826A9DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9DF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9DF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A9DFC: 4BFFD825  bl 0x826a7620
	ctx.lr = 0x826A9E00;
	sub_826A7620(ctx, base);
	// 826A9E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9E04: 4BFFBA75  bl 0x826a5878
	ctx.lr = 0x826A9E08;
	sub_826A5878(ctx, base);
	// 826A9E08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A9E0C: 4182001C  beq 0x826a9e28
	if ctx.cr[0].eq {
	pc = 0x826A9E28; continue 'dispatch;
	}
	// 826A9E10: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A9E14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A9E18: 41820010  beq 0x826a9e28
	if ctx.cr[0].eq {
	pc = 0x826A9E28; continue 'dispatch;
	}
	// 826A9E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9E20: 4BFFFBB1  bl 0x826a99d0
	ctx.lr = 0x826A9E24;
	sub_826A99D0(ctx, base);
	// 826A9E24: 48000014  b 0x826a9e38
	pc = 0x826A9E38; continue 'dispatch;
	// 826A9E28: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A9E2C: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 826A9E30: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A9E34: 4876942D  bl 0x82e13260
	ctx.lr = 0x826A9E38;
	sub_82E13260(ctx, base);
	// 826A9E38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A9E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A9E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A9E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A9E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A9E50 size=32
    let mut pc: u32 = 0x826A9E50;
    'dispatch: loop {
        match pc {
            0x826A9E50 => {
    //   block [0x826A9E50..0x826A9E70)
	// 826A9E50: 8103019C  lwz r8, 0x19c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A9E54: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826A9E58: 3943019C  addi r10, r3, 0x19c
	ctx.r[10].s64 = ctx.r[3].s64 + 412;
	// 826A9E5C: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826A9E60: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826A9E64: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826A9E68: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826A9E6C: 4BC1A5F4  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9E70 size=164
    let mut pc: u32 = 0x826A9E70;
    'dispatch: loop {
        match pc {
            0x826A9E70 => {
    //   block [0x826A9E70..0x826A9F14)
	// 826A9E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9E74: 48AFE2F5  bl 0x831a8168
	ctx.lr = 0x826A9E78;
	sub_831A8130(ctx, base);
	// 826A9E78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9E7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826A9E80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A9E84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A9E88: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826A9E8C: 41820038  beq 0x826a9ec4
	if ctx.cr[0].eq {
	pc = 0x826A9EC4; continue 'dispatch;
	}
	// 826A9E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9E94: 48AFFAF5  bl 0x831a9988
	ctx.lr = 0x826A9E98;
	sub_831A9988(ctx, base);
	// 826A9E98: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A9E9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A9EA0: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826A9EA4: 48AFE255  bl 0x831a80f8
	ctx.lr = 0x826A9EA8;
	sub_831A80F8(ctx, base);
	// 826A9EA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A9EAC: 41820018  beq 0x826a9ec4
	if ctx.cr[0].eq {
	pc = 0x826A9EC4; continue 'dispatch;
	}
	// 826A9EB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A9EB4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A9EB8: 4BFFFF99  bl 0x826a9e50
	ctx.lr = 0x826A9EBC;
	sub_826A9E50(ctx, base);
	// 826A9EBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826A9EC0: 4800004C  b 0x826a9f0c
	pc = 0x826A9F0C; continue 'dispatch;
	// 826A9EC4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826A9EC8: 419A0034  beq cr6, 0x826a9efc
	if ctx.cr[6].eq {
	pc = 0x826A9EFC; continue 'dispatch;
	}
	// 826A9ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A9ED0: 48AFFAB9  bl 0x831a9988
	ctx.lr = 0x826A9ED4;
	sub_831A9988(ctx, base);
	// 826A9ED4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A9ED8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A9EDC: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826A9EE0: 48AFE219  bl 0x831a80f8
	ctx.lr = 0x826A9EE4;
	sub_831A80F8(ctx, base);
	// 826A9EE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A9EE8: 41820014  beq 0x826a9efc
	if ctx.cr[0].eq {
	pc = 0x826A9EFC; continue 'dispatch;
	}
	// 826A9EEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A9EF0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A9EF4: 4BFFFC25  bl 0x826a9b18
	ctx.lr = 0x826A9EF8;
	sub_826A9B18(ctx, base);
	// 826A9EF8: 4BFFFFC4  b 0x826a9ebc
	pc = 0x826A9EBC; continue 'dispatch;
	// 826A9EFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A9F00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A9F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A9F08: 4BFFD9C1  bl 0x826a78c8
	ctx.lr = 0x826A9F0C;
	sub_826A78C8(ctx, base);
	// 826A9F0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A9F10: 48AFE2A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A9F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A9F18 size=260
    let mut pc: u32 = 0x826A9F18;
    'dispatch: loop {
        match pc {
            0x826A9F18 => {
    //   block [0x826A9F18..0x826AA01C)
	// 826A9F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A9F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A9F20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A9F24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A9F28: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A9F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A9F30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A9F34: 4BFFCD85  bl 0x826a6cb8
	ctx.lr = 0x826A9F38;
	sub_826A6CB8(ctx, base);
	// 826A9F38: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9F3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9F40: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 826A9F44: 48749AC5  bl 0x82df3a08
	ctx.lr = 0x826A9F48;
	sub_82DF3A08(ctx, base);
	// 826A9F48: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9F50: 388B18B4  addi r4, r11, 0x18b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6324;
	// 826A9F54: 48749AB5  bl 0x82df3a08
	ctx.lr = 0x826A9F58;
	sub_82DF3A08(ctx, base);
	// 826A9F58: 38BF00C0  addi r5, r31, 0xc0
	ctx.r[5].s64 = ctx.r[31].s64 + 192;
	// 826A9F5C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A9F60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A9F64: 4BEF90ED  bl 0x825a3050
	ctx.lr = 0x826A9F68;
	sub_825A3050(ctx, base);
	// 826A9F68: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A9F6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A9F70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A9F74: 4BEF8215  bl 0x825a2188
	ctx.lr = 0x826A9F78;
	sub_825A2188(ctx, base);
	// 826A9F78: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826A9F7C: 487494AD  bl 0x82df3428
	ctx.lr = 0x826A9F80;
	sub_82DF3428(ctx, base);
	// 826A9F80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A9F84: 4BC1ED35  bl 0x822c8cb8
	ctx.lr = 0x826A9F88;
	sub_822C8CB8(ctx, base);
	// 826A9F88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9F8C: 4874949D  bl 0x82df3428
	ctx.lr = 0x826A9F90;
	sub_82DF3428(ctx, base);
	// 826A9F90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9F94: 48749495  bl 0x82df3428
	ctx.lr = 0x826A9F98;
	sub_82DF3428(ctx, base);
	// 826A9F98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A9F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A9FA0: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826A9FA4: 48749A65  bl 0x82df3a08
	ctx.lr = 0x826A9FA8;
	sub_82DF3A08(ctx, base);
	// 826A9FA8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A9FAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9FB0: 388B18A4  addi r4, r11, 0x18a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6308;
	// 826A9FB4: 48749A55  bl 0x82df3a08
	ctx.lr = 0x826A9FB8;
	sub_82DF3A08(ctx, base);
	// 826A9FB8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826A9FBC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A9FC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A9FC4: 38BF00C4  addi r5, r31, 0xc4
	ctx.r[5].s64 = ctx.r[31].s64 + 196;
	// 826A9FC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A9FCC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A9FD0: 4BEF9449  bl 0x825a3418
	ctx.lr = 0x826A9FD4;
	sub_825A3418(ctx, base);
	// 826A9FD4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A9FD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A9FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A9FE0: 4BEF7EF9  bl 0x825a1ed8
	ctx.lr = 0x826A9FE4;
	sub_825A1ED8(ctx, base);
	// 826A9FE4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826A9FE8: 48749441  bl 0x82df3428
	ctx.lr = 0x826A9FEC;
	sub_82DF3428(ctx, base);
	// 826A9FEC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826A9FF0: 4BC1ECC9  bl 0x822c8cb8
	ctx.lr = 0x826A9FF4;
	sub_822C8CB8(ctx, base);
	// 826A9FF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A9FF8: 48749431  bl 0x82df3428
	ctx.lr = 0x826A9FFC;
	sub_82DF3428(ctx, base);
	// 826A9FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AA000: 48749429  bl 0x82df3428
	ctx.lr = 0x826AA004;
	sub_82DF3428(ctx, base);
	// 826AA004: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 826AA008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA010: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AA014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AA020 size=432
    let mut pc: u32 = 0x826AA020;
    'dispatch: loop {
        match pc {
            0x826AA020 => {
    //   block [0x826AA020..0x826AA1D0)
	// 826AA020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA024: 48AFE141  bl 0x831a8164
	ctx.lr = 0x826AA028;
	sub_831A8130(ctx, base);
	// 826AA028: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA02C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AA030: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826AA034: 3BCB1DD0  addi r30, r11, 0x1dd0
	ctx.r[30].s64 = ctx.r[11].s64 + 7632;
	// 826AA038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AA03C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826AA040: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AA044: 38A0007E  li r5, 0x7e
	ctx.r[5].s64 = 126;
	// 826AA048: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826AA04C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AA050: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 826AA054: 48748395  bl 0x82df23e8
	ctx.lr = 0x826AA058;
	sub_82DF23E8(ctx, base);
	// 826AA058: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AA05C: 41820014  beq 0x826aa070
	if ctx.cr[0].eq {
	pc = 0x826AA070; continue 'dispatch;
	}
	// 826AA060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AA064: 4BFFFC9D  bl 0x826a9d00
	ctx.lr = 0x826AA068;
	sub_826A9D00(ctx, base);
	// 826AA068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA06C: 48000008  b 0x826aa074
	pc = 0x826AA074; continue 'dispatch;
	// 826AA070: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AA074: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826AA078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AA07C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826AA080: 4BFFFBB9  bl 0x826a9c38
	ctx.lr = 0x826AA084;
	sub_826A9C38(ctx, base);
	// 826AA084: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AA088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AA08C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826AA090: 4BC15F71  bl 0x822c0000
	ctx.lr = 0x826AA094;
	sub_822C0000(ctx, base);
	// 826AA094: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AA098: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AA09C: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 826AA0A0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826AA0A4: 4BC16335  bl 0x822c03d8
	ctx.lr = 0x826AA0A8;
	sub_822C03D8(ctx, base);
	// 826AA0A8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826AA0AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826AA0B0: 418200B4  beq 0x826aa164
	if ctx.cr[0].eq {
	pc = 0x826AA164; continue 'dispatch;
	}
	// 826AA0B4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826AA0B8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826AA0BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826AA0C0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826AA0C4: 409A0008  bne cr6, 0x826aa0cc
	if !ctx.cr[6].eq {
	pc = 0x826AA0CC; continue 'dispatch;
	}
	// 826AA0C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AA0CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826AA0D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AA0D4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826AA0D8: 419A0024  beq cr6, 0x826aa0fc
	if ctx.cr[6].eq {
	pc = 0x826AA0FC; continue 'dispatch;
	}
	// 826AA0DC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AA0E0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826AA0E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AA0E8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826AA0EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826AA0F0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AA0F4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AA0F8: 4082FFE8  bne 0x826aa0e0
	if !ctx.cr[0].eq {
	pc = 0x826AA0E0; continue 'dispatch;
	}
	// 826AA0FC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826AA100: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AA104: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826AA108: 419A0024  beq cr6, 0x826aa12c
	if ctx.cr[6].eq {
	pc = 0x826AA12C; continue 'dispatch;
	}
	// 826AA10C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AA110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AA114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AA118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AA11C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AA120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AA124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AA128: 4082FFE8  bne 0x826aa110
	if !ctx.cr[0].eq {
	pc = 0x826AA110; continue 'dispatch;
	}
	// 826AA12C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AA130: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826AA134: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826AA138: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826AA13C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826AA140: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826AA144: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AA148: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AA14C: 480EEDE5  bl 0x82798f30
	ctx.lr = 0x826AA150;
	sub_82798F30(ctx, base);
	// 826AA150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AA154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA158: 480F1511  bl 0x8279b668
	ctx.lr = 0x826AA15C;
	sub_8279B668(ctx, base);
	// 826AA15C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA160: 48000008  b 0x826aa168
	pc = 0x826AA168; continue 'dispatch;
	// 826AA164: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AA168: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826AA16C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826AA170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AA174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AA178: 4BEEDAD9  bl 0x82597c50
	ctx.lr = 0x826AA17C;
	sub_82597C50(ctx, base);
	// 826AA17C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AA180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AA184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AA188: 4BC15E79  bl 0x822c0000
	ctx.lr = 0x826AA18C;
	sub_822C0000(ctx, base);
	// 826AA18C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AA190: 41820024  beq 0x826aa1b4
	if ctx.cr[0].eq {
	pc = 0x826AA1B4; continue 'dispatch;
	}
	// 826AA194: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826AA198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AA19C: 419A0008  beq cr6, 0x826aa1a4
	if ctx.cr[6].eq {
	pc = 0x826AA1A4; continue 'dispatch;
	}
	// 826AA1A0: 4BC166F1  bl 0x822c0890
	ctx.lr = 0x826AA1A4;
	sub_822C0890(ctx, base);
	// 826AA1A4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826AA1A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AA1AC: 419A0008  beq cr6, 0x826aa1b4
	if ctx.cr[6].eq {
	pc = 0x826AA1B4; continue 'dispatch;
	}
	// 826AA1B0: 4BC166E1  bl 0x822c0890
	ctx.lr = 0x826AA1B4;
	sub_822C0890(ctx, base);
	// 826AA1B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AA1B8: 419A000C  beq cr6, 0x826aa1c4
	if ctx.cr[6].eq {
	pc = 0x826AA1C4; continue 'dispatch;
	}
	// 826AA1BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AA1C0: 4BC166D1  bl 0x822c0890
	ctx.lr = 0x826AA1C4;
	sub_822C0890(ctx, base);
	// 826AA1C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826AA1C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826AA1CC: 48AFDFE8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA1D0 size=52
    let mut pc: u32 = 0x826AA1D0;
    'dispatch: loop {
        match pc {
            0x826AA1D0 => {
    //   block [0x826AA1D0..0x826AA204)
	// 826AA1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA1D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA1DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA1E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826AA1E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA1E8: 4BFFFE39  bl 0x826aa020
	ctx.lr = 0x826AA1EC;
	sub_826AA020(ctx, base);
	// 826AA1EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA1F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA1F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA1F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA1FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA208 size=52
    let mut pc: u32 = 0x826AA208;
    'dispatch: loop {
        match pc {
            0x826AA208 => {
    //   block [0x826AA208..0x826AA23C)
	// 826AA208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA218: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AA21C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA220: 4BFFFE01  bl 0x826aa020
	ctx.lr = 0x826AA224;
	sub_826AA020(ctx, base);
	// 826AA224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA228: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA22C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA240 size=52
    let mut pc: u32 = 0x826AA240;
    'dispatch: loop {
        match pc {
            0x826AA240 => {
    //   block [0x826AA240..0x826AA274)
	// 826AA240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA248: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA24C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA250: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826AA254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA258: 4BFFFDC9  bl 0x826aa020
	ctx.lr = 0x826AA25C;
	sub_826AA020(ctx, base);
	// 826AA25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA260: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA26C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA278 size=52
    let mut pc: u32 = 0x826AA278;
    'dispatch: loop {
        match pc {
            0x826AA278 => {
    //   block [0x826AA278..0x826AA2AC)
	// 826AA278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA284: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA288: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826AA28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA290: 4BFFFD91  bl 0x826aa020
	ctx.lr = 0x826AA294;
	sub_826AA020(ctx, base);
	// 826AA294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA298: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA29C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA2A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA2A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA2B0 size=52
    let mut pc: u32 = 0x826AA2B0;
    'dispatch: loop {
        match pc {
            0x826AA2B0 => {
    //   block [0x826AA2B0..0x826AA2E4)
	// 826AA2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA2BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA2C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826AA2C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA2C8: 4BFFFD59  bl 0x826aa020
	ctx.lr = 0x826AA2CC;
	sub_826AA020(ctx, base);
	// 826AA2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA2D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA2D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA2D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA2DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA2E8 size=52
    let mut pc: u32 = 0x826AA2E8;
    'dispatch: loop {
        match pc {
            0x826AA2E8 => {
    //   block [0x826AA2E8..0x826AA31C)
	// 826AA2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA2F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA2F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA2F8: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826AA2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA300: 4BFFFD21  bl 0x826aa020
	ctx.lr = 0x826AA304;
	sub_826AA020(ctx, base);
	// 826AA304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA308: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA30C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA320 size=52
    let mut pc: u32 = 0x826AA320;
    'dispatch: loop {
        match pc {
            0x826AA320 => {
    //   block [0x826AA320..0x826AA354)
	// 826AA320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA328: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA32C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA330: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826AA334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA338: 4BFFFCE9  bl 0x826aa020
	ctx.lr = 0x826AA33C;
	sub_826AA020(ctx, base);
	// 826AA33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA340: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA34C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA358 size=52
    let mut pc: u32 = 0x826AA358;
    'dispatch: loop {
        match pc {
            0x826AA358 => {
    //   block [0x826AA358..0x826AA38C)
	// 826AA358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA35C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA360: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA364: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA368: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826AA36C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA370: 4BFFFCB1  bl 0x826aa020
	ctx.lr = 0x826AA374;
	sub_826AA020(ctx, base);
	// 826AA374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA378: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA37C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA390 size=52
    let mut pc: u32 = 0x826AA390;
    'dispatch: loop {
        match pc {
            0x826AA390 => {
    //   block [0x826AA390..0x826AA3C4)
	// 826AA390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA398: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA39C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA3A0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826AA3A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA3A8: 4BFFFC79  bl 0x826aa020
	ctx.lr = 0x826AA3AC;
	sub_826AA020(ctx, base);
	// 826AA3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA3B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA3BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA3C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA3C8 size=52
    let mut pc: u32 = 0x826AA3C8;
    'dispatch: loop {
        match pc {
            0x826AA3C8 => {
    //   block [0x826AA3C8..0x826AA3FC)
	// 826AA3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA3D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA3D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA3D8: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 826AA3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA3E0: 4BFFFC41  bl 0x826aa020
	ctx.lr = 0x826AA3E4;
	sub_826AA020(ctx, base);
	// 826AA3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA3E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA3F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA400 size=52
    let mut pc: u32 = 0x826AA400;
    'dispatch: loop {
        match pc {
            0x826AA400 => {
    //   block [0x826AA400..0x826AA434)
	// 826AA400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA40C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA410: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 826AA414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA418: 4BFFFC09  bl 0x826aa020
	ctx.lr = 0x826AA41C;
	sub_826AA020(ctx, base);
	// 826AA41C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA420: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AA438 size=52
    let mut pc: u32 = 0x826AA438;
    'dispatch: loop {
        match pc {
            0x826AA438 => {
    //   block [0x826AA438..0x826AA46C)
	// 826AA438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AA440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AA444: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA448: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 826AA44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA450: 4BFFFBD1  bl 0x826aa020
	ctx.lr = 0x826AA454;
	sub_826AA020(ctx, base);
	// 826AA454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA458: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AA45C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AA460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AA464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AA468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AA470 size=1312
    let mut pc: u32 = 0x826AA470;
    'dispatch: loop {
        match pc {
            0x826AA470 => {
    //   block [0x826AA470..0x826AA990)
	// 826AA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA474: 48AFDCE9  bl 0x831a815c
	ctx.lr = 0x826AA478;
	sub_831A8130(ctx, base);
	// 826AA478: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA47C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AA480: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826AA484: 4BFFD55D  bl 0x826a79e0
	ctx.lr = 0x826AA488;
	sub_826A79E0(ctx, base);
	// 826AA488: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AA48C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AA490: 3B4B1DD0  addi r26, r11, 0x1dd0
	ctx.r[26].s64 = ctx.r[11].s64 + 7632;
	// 826AA494: 38A000D1  li r5, 0xd1
	ctx.r[5].s64 = 209;
	// 826AA498: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826AA49C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AA4A0: 48747F49  bl 0x82df23e8
	ctx.lr = 0x826AA4A4;
	sub_82DF23E8(ctx, base);
	// 826AA4A4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 826AA4A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AA4AC: 41820018  beq 0x826aa4c4
	if ctx.cr[0].eq {
	pc = 0x826AA4C4; continue 'dispatch;
	}
	// 826AA4B0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826AA4B4: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826AA4B8: 48768C39  bl 0x82e130f0
	ctx.lr = 0x826AA4BC;
	sub_82E130F0(ctx, base);
	// 826AA4BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AA4C0: 48000008  b 0x826aa4c8
	pc = 0x826AA4C8; continue 'dispatch;
	// 826AA4C4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826AA4C8: 3BDF0194  addi r30, r31, 0x194
	ctx.r[30].s64 = ctx.r[31].s64 + 404;
	// 826AA4CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AA4D0: 4BC37881  bl 0x822e1d50
	ctx.lr = 0x826AA4D4;
	sub_822E1D50(ctx, base);
	// 826AA4D4: 809F0194  lwz r4, 0x194(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 826AA4D8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826AA4DC: 48768955  bl 0x82e12e30
	ctx.lr = 0x826AA4E0;
	sub_82E12E30(ctx, base);
	// 826AA4E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826AA4E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AA4E8: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 826AA4EC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AA4F0: 48747EF9  bl 0x82df23e8
	ctx.lr = 0x826AA4F4;
	sub_82DF23E8(ctx, base);
	// 826AA4F4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AA4F8: 4182002C  beq 0x826aa524
	if ctx.cr[0].eq {
	pc = 0x826AA524; continue 'dispatch;
	}
	// 826AA4FC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826AA500: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826AA504: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AA508: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AA50C: 487D24DD  bl 0x82e7c9e8
	ctx.lr = 0x826AA510;
	sub_82E7C9E8(ctx, base);
	// 826AA510: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AA514: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AA518: 48768BD9  bl 0x82e130f0
	ctx.lr = 0x826AA51C;
	sub_82E130F0(ctx, base);
	// 826AA51C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AA520: 48000008  b 0x826aa528
	pc = 0x826AA528; continue 'dispatch;
	// 826AA524: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826AA528: 387F019C  addi r3, r31, 0x19c
	ctx.r[3].s64 = ctx.r[31].s64 + 412;
	// 826AA52C: 4BC37825  bl 0x822e1d50
	ctx.lr = 0x826AA530;
	sub_822E1D50(ctx, base);
	// 826AA530: 807F019C  lwz r3, 0x19c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 826AA534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AA538: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826AA53C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AA540: 4E800421  bctrl
	ctx.lr = 0x826AA544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AA544: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826AA548: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826AA54C: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AA550: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826AA554: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 826AA558: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 826AA55C: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AA560: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 826AA564: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 826AA568: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AA56C: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AA570: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AA990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AA990 size=764
    let mut pc: u32 = 0x826AA990;
    'dispatch: loop {
        match pc {
            0x826AA990 => {
    //   block [0x826AA990..0x826AAC8C)
	// 826AA990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AA994: 48AFD7BD  bl 0x831a8150
	ctx.lr = 0x826AA998;
	sub_831A8130(ctx, base);
	// 826AA998: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AA99C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AA9A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AA9A4: 4BFFA4F5  bl 0x826a4e98
	ctx.lr = 0x826AA9A8;
	sub_826A4E98(ctx, base);
	// 826AA9A8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AA9AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AA9B0: 3B4B18B4  addi r26, r11, 0x18b4
	ctx.r[26].s64 = ctx.r[11].s64 + 6324;
	// 826AA9B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826AA9B8: 48749051  bl 0x82df3a08
	ctx.lr = 0x826AA9BC;
	sub_82DF3A08(ctx, base);
	// 826AA9BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA9C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AA9C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AA9C8: 4BEF6BC1  bl 0x825a1588
	ctx.lr = 0x826AA9CC;
	sub_825A1588(ctx, base);
	// 826AA9CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AA9D0: 48748A59  bl 0x82df3428
	ctx.lr = 0x826AA9D4;
	sub_82DF3428(ctx, base);
	// 826AA9D4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AA9D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AA9DC: 3B2B18A4  addi r25, r11, 0x18a4
	ctx.r[25].s64 = ctx.r[11].s64 + 6308;
	// 826AA9E0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826AA9E4: 48749025  bl 0x82df3a08
	ctx.lr = 0x826AA9E8;
	sub_82DF3A08(ctx, base);
	// 826AA9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AA9EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AA9F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AA9F4: 4BEF6B95  bl 0x825a1588
	ctx.lr = 0x826AA9F8;
	sub_825A1588(ctx, base);
	// 826AA9F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AA9FC: 48748A2D  bl 0x82df3428
	ctx.lr = 0x826AAA00;
	sub_82DF3428(ctx, base);
	// 826AAA00: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAA04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA08: 3B0BD2C0  addi r24, r11, -0x2d40
	ctx.r[24].s64 = ctx.r[11].s64 + -11584;
	// 826AAA0C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826AAA10: 48748FF9  bl 0x82df3a08
	ctx.lr = 0x826AAA14;
	sub_82DF3A08(ctx, base);
	// 826AAA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAA18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AAA1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAA20: 4BEF6B69  bl 0x825a1588
	ctx.lr = 0x826AAA24;
	sub_825A1588(ctx, base);
	// 826AAA24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA28: 48748A01  bl 0x82df3428
	ctx.lr = 0x826AAA2C;
	sub_82DF3428(ctx, base);
	// 826AAA2C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAA30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA34: 3AEBA13C  addi r23, r11, -0x5ec4
	ctx.r[23].s64 = ctx.r[11].s64 + -24260;
	// 826AAA38: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826AAA3C: 48748FCD  bl 0x82df3a08
	ctx.lr = 0x826AAA40;
	sub_82DF3A08(ctx, base);
	// 826AAA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAA44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AAA48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAA4C: 4BEF6B3D  bl 0x825a1588
	ctx.lr = 0x826AAA50;
	sub_825A1588(ctx, base);
	// 826AAA50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA54: 487489D5  bl 0x82df3428
	ctx.lr = 0x826AAA58;
	sub_82DF3428(ctx, base);
	// 826AAA58: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAA5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA60: 3BABC3A4  addi r29, r11, -0x3c5c
	ctx.r[29].s64 = ctx.r[11].s64 + -15452;
	// 826AAA64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AAA68: 48748FA1  bl 0x82df3a08
	ctx.lr = 0x826AAA6C;
	sub_82DF3A08(ctx, base);
	// 826AAA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAA70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AAA74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAA78: 4BEF6B11  bl 0x825a1588
	ctx.lr = 0x826AAA7C;
	sub_825A1588(ctx, base);
	// 826AAA7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA80: 487489A9  bl 0x82df3428
	ctx.lr = 0x826AAA84;
	sub_82DF3428(ctx, base);
	// 826AAA84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AAA88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAA8C: 3B8BF800  addi r28, r11, -0x800
	ctx.r[28].s64 = ctx.r[11].s64 + -2048;
	// 826AAA90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826AAA94: 48748F75  bl 0x82df3a08
	ctx.lr = 0x826AAA98;
	sub_82DF3A08(ctx, base);
	// 826AAA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAA9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AAAA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAAA4: 4BEF6AE5  bl 0x825a1588
	ctx.lr = 0x826AAAA8;
	sub_825A1588(ctx, base);
	// 826AAAA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAAAC: 4874897D  bl 0x82df3428
	ctx.lr = 0x826AAAB0;
	sub_82DF3428(ctx, base);
	// 826AAAB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AAAB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAAB8: 3B6BE0B8  addi r27, r11, -0x1f48
	ctx.r[27].s64 = ctx.r[11].s64 + -8008;
	// 826AAABC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AAAC0: 48748F49  bl 0x82df3a08
	ctx.lr = 0x826AAAC4;
	sub_82DF3A08(ctx, base);
	// 826AAAC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AAAC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAAD0: 4BEF6AB9  bl 0x825a1588
	ctx.lr = 0x826AAAD4;
	sub_825A1588(ctx, base);
	// 826AAAD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAAD8: 48748951  bl 0x82df3428
	ctx.lr = 0x826AAADC;
	sub_82DF3428(ctx, base);
	// 826AAADC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAAE0: 815E0064  lwz r10, 0x64(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 826AAAE4: 3ACBD2E8  addi r22, r11, -0x2d18
	ctx.r[22].s64 = ctx.r[11].s64 + -11544;
	// 826AAAE8: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 826AAAEC: 409A0094  bne cr6, 0x826aab80
	if !ctx.cr[6].eq {
	pc = 0x826AAB80; continue 'dispatch;
	}
	// 826AAAF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AAAF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAAF8: 48748F11  bl 0x82df3a08
	ctx.lr = 0x826AAAFC;
	sub_82DF3A08(ctx, base);
	// 826AAAFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAB00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAB08: 4BEF6A81  bl 0x825a1588
	ctx.lr = 0x826AAB0C;
	sub_825A1588(ctx, base);
	// 826AAB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB10: 48748919  bl 0x82df3428
	ctx.lr = 0x826AAB14;
	sub_82DF3428(ctx, base);
	// 826AAB14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826AAB18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB1C: 48748EED  bl 0x82df3a08
	ctx.lr = 0x826AAB20;
	sub_82DF3A08(ctx, base);
	// 826AAB20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAB24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAB2C: 4BEF6A5D  bl 0x825a1588
	ctx.lr = 0x826AAB30;
	sub_825A1588(ctx, base);
	// 826AAB30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB34: 487488F5  bl 0x82df3428
	ctx.lr = 0x826AAB38;
	sub_82DF3428(ctx, base);
	// 826AAB38: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AAB3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB40: 48748EC9  bl 0x82df3a08
	ctx.lr = 0x826AAB44;
	sub_82DF3A08(ctx, base);
	// 826AAB44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAB48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAB50: 4BEF6A39  bl 0x825a1588
	ctx.lr = 0x826AAB54;
	sub_825A1588(ctx, base);
	// 826AAB54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB58: 487488D1  bl 0x82df3428
	ctx.lr = 0x826AAB5C;
	sub_82DF3428(ctx, base);
	// 826AAB5C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826AAB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB64: 48748EA5  bl 0x82df3a08
	ctx.lr = 0x826AAB68;
	sub_82DF3A08(ctx, base);
	// 826AAB68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAB6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAB74: 4BEF6A15  bl 0x825a1588
	ctx.lr = 0x826AAB78;
	sub_825A1588(ctx, base);
	// 826AAB78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB7C: 487488AD  bl 0x82df3428
	ctx.lr = 0x826AAB80;
	sub_82DF3428(ctx, base);
	// 826AAB80: 3BBEFF1C  addi r29, r30, -0xe4
	ctx.r[29].s64 = ctx.r[30].s64 + -228;
	// 826AAB84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AAB88: 4BFFACF1  bl 0x826a5878
	ctx.lr = 0x826AAB8C;
	sub_826A5878(ctx, base);
	// 826AAB8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AAB90: 41820058  beq 0x826aabe8
	if ctx.cr[0].eq {
	pc = 0x826AABE8; continue 'dispatch;
	}
	// 826AAB94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826AAB98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAB9C: 48748E6D  bl 0x82df3a08
	ctx.lr = 0x826AABA0;
	sub_82DF3A08(ctx, base);
	// 826AABA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AABA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AABA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AABAC: 4BEF69DD  bl 0x825a1588
	ctx.lr = 0x826AABB0;
	sub_825A1588(ctx, base);
	// 826AABB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AABB4: 48748875  bl 0x82df3428
	ctx.lr = 0x826AABB8;
	sub_82DF3428(ctx, base);
	// 826AABB8: 897E00C8  lbz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 826AABBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AABC0: 41820028  beq 0x826aabe8
	if ctx.cr[0].eq {
	pc = 0x826AABE8; continue 'dispatch;
	}
	// 826AABC4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826AABC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AABCC: 48748E3D  bl 0x82df3a08
	ctx.lr = 0x826AABD0;
	sub_82DF3A08(ctx, base);
	// 826AABD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AABD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AABD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AABDC: 4BEF69AD  bl 0x825a1588
	ctx.lr = 0x826AABE0;
	sub_825A1588(ctx, base);
	// 826AABE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AABE4: 48748845  bl 0x82df3428
	ctx.lr = 0x826AABE8;
	sub_82DF3428(ctx, base);
	// 826AABE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AABEC: 4BFFAC8D  bl 0x826a5878
	ctx.lr = 0x826AABF0;
	sub_826A5878(ctx, base);
	// 826AABF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AABF4: 41820010  beq 0x826aac04
	if ctx.cr[0].eq {
	pc = 0x826AAC04; continue 'dispatch;
	}
	// 826AABF8: 897E00C8  lbz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 826AABFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AAC00: 4082004C  bne 0x826aac4c
	if !ctx.cr[0].eq {
	pc = 0x826AAC4C; continue 'dispatch;
	}
	// 826AAC04: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826AAC08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAC0C: 48748DFD  bl 0x82df3a08
	ctx.lr = 0x826AAC10;
	sub_82DF3A08(ctx, base);
	// 826AAC10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAC14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAC1C: 4BEF696D  bl 0x825a1588
	ctx.lr = 0x826AAC20;
	sub_825A1588(ctx, base);
	// 826AAC20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAC24: 48748805  bl 0x82df3428
	ctx.lr = 0x826AAC28;
	sub_82DF3428(ctx, base);
	// 826AAC28: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826AAC2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAC30: 48748DD9  bl 0x82df3a08
	ctx.lr = 0x826AAC34;
	sub_82DF3A08(ctx, base);
	// 826AAC34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAC38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAC3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAC40: 4BEF6949  bl 0x825a1588
	ctx.lr = 0x826AAC44;
	sub_825A1588(ctx, base);
	// 826AAC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAC48: 487487E1  bl 0x82df3428
	ctx.lr = 0x826AAC4C;
	sub_82DF3428(ctx, base);
	// 826AAC4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AAC50: C1BE00D0  lfs f13, 0xd0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AAC54: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AAC58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826AAC5C: 419A0028  beq cr6, 0x826aac84
	if ctx.cr[6].eq {
	pc = 0x826AAC84; continue 'dispatch;
	}
	// 826AAC60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826AAC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAC68: 48748DA1  bl 0x82df3a08
	ctx.lr = 0x826AAC6C;
	sub_82DF3A08(ctx, base);
	// 826AAC6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AAC70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AAC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAC78: 4BEF6911  bl 0x825a1588
	ctx.lr = 0x826AAC7C;
	sub_825A1588(ctx, base);
	// 826AAC7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAC80: 487487A9  bl 0x82df3428
	ctx.lr = 0x826AAC84;
	sub_82DF3428(ctx, base);
	// 826AAC84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826AAC88: 48AFD518  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AAC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AAC90 size=96
    let mut pc: u32 = 0x826AAC90;
    'dispatch: loop {
        match pc {
            0x826AAC90 => {
    //   block [0x826AAC90..0x826AACF0)
	// 826AAC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AAC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AAC98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AAC9C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AACA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AACA4: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826AACA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AACAC: 41820030  beq 0x826aacdc
	if ctx.cr[0].eq {
	pc = 0x826AACDC; continue 'dispatch;
	}
	// 826AACB0: C03F01B8  lfs f1, 0x1b8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AACB4: 4BFFAD25  bl 0x826a59d8
	ctx.lr = 0x826AACB8;
	sub_826A59D8(ctx, base);
	// 826AACB8: C01F01B4  lfs f0, 0x1b4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AACBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AACC0: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826AACC4: 83FF0194  lwz r31, 0x194(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 826AACC8: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AACCC: 487D1D1D  bl 0x82e7c9e8
	ctx.lr = 0x826AACD0;
	sub_82E7C9E8(ctx, base);
	// 826AACD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AACD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AACD8: 48768589  bl 0x82e13260
	ctx.lr = 0x826AACDC;
	sub_82E13260(ctx, base);
	// 826AACDC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826AACE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AACE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AACE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AACEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AACF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AACF0 size=144
    let mut pc: u32 = 0x826AACF0;
    'dispatch: loop {
        match pc {
            0x826AACF0 => {
    //   block [0x826AACF0..0x826AAD80)
	// 826AACF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AACF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AACF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AACFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AAD00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AAD04: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826AAD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AAD0C: 409A0060  bne cr6, 0x826aad6c
	if !ctx.cr[6].eq {
	pc = 0x826AAD6C; continue 'dispatch;
	}
	// 826AAD10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826AAD14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AAD18: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 826AAD1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAD20: 4BE647A9  bl 0x8250f4c8
	ctx.lr = 0x826AAD24;
	sub_8250F4C8(ctx, base);
	// 826AAD24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AAD28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AAD2C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826AAD30: 409A0008  bne cr6, 0x826aad38
	if !ctx.cr[6].eq {
	pc = 0x826AAD38; continue 'dispatch;
	}
	// 826AAD34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826AAD38: 4BE5D7E1  bl 0x82508518
	ctx.lr = 0x826AAD3C;
	sub_82508518(ctx, base);
	// 826AAD3C: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AAD40: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 826AAD44: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AAD48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAD4C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826AAD50: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 826AAD54: 48746F3D  bl 0x82df1c90
	ctx.lr = 0x826AAD58;
	sub_82DF1C90(ctx, base);
	// 826AAD58: C01F01C0  lfs f0, 0x1c0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AAD5C: C1BF01BC  lfs f13, 0x1bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AAD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAD64: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826AAD68: 4BE66F01  bl 0x82511c68
	ctx.lr = 0x826AAD6C;
	sub_82511C68(ctx, base);
	// 826AAD6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AAD70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AAD74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AAD78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AAD7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AAD80 size=160
    let mut pc: u32 = 0x826AAD80;
    'dispatch: loop {
        match pc {
            0x826AAD80 => {
    //   block [0x826AAD80..0x826AAE20)
	// 826AAD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AAD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AAD88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AAD8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AAD90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AAD94: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 826AAD98: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 826AAD9C: 409A0068  bne cr6, 0x826aae04
	if !ctx.cr[6].eq {
	pc = 0x826AAE04; continue 'dispatch;
	}
	// 826AADA0: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826AADA4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826AADA8: 409A0064  bne cr6, 0x826aae0c
	if !ctx.cr[6].eq {
	pc = 0x826AAE0C; continue 'dispatch;
	}
	// 826AADAC: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826AADB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AADB4: 409A0058  bne cr6, 0x826aae0c
	if !ctx.cr[6].eq {
	pc = 0x826AAE0C; continue 'dispatch;
	}
	// 826AADB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826AADBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AADC0: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 826AADC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AADC8: 4BE64701  bl 0x8250f4c8
	ctx.lr = 0x826AADCC;
	sub_8250F4C8(ctx, base);
	// 826AADCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AADD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AADD4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826AADD8: 409A0008  bne cr6, 0x826aade0
	if !ctx.cr[6].eq {
	pc = 0x826AADE0; continue 'dispatch;
	}
	// 826AADDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826AADE0: 4BE5D739  bl 0x82508518
	ctx.lr = 0x826AADE4;
	sub_82508518(ctx, base);
	// 826AADE4: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AADE8: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 826AADEC: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AADF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AADF4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826AADF8: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 826AADFC: 48746E95  bl 0x82df1c90
	ctx.lr = 0x826AAE00;
	sub_82DF1C90(ctx, base);
	// 826AAE00: 4800000C  b 0x826aae0c
	pc = 0x826AAE0C; continue 'dispatch;
	// 826AAE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAE08: 4BFFAFD1  bl 0x826a5dd8
	ctx.lr = 0x826AAE0C;
	sub_826A5DD8(ctx, base);
	// 826AAE0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AAE10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AAE14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AAE18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AAE1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AAE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AAE20 size=196
    let mut pc: u32 = 0x826AAE20;
    'dispatch: loop {
        match pc {
            0x826AAE20 => {
    //   block [0x826AAE20..0x826AAEE4)
	// 826AAE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AAE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AAE28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AAE2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AAE30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AAE34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AAE38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AAE3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826AAE40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AAE44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AAE48: 4BC15AF1  bl 0x822c0938
	ctx.lr = 0x826AAE4C;
	sub_822C0938(ctx, base);
	// 826AAE4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AAE50: 41820028  beq 0x826aae78
	if ctx.cr[0].eq {
	pc = 0x826AAE78; continue 'dispatch;
	}
	// 826AAE54: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAE58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826AAE5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826AAE60: 392B20CC  addi r9, r11, 0x20cc
	ctx.r[9].s64 = ctx.r[11].s64 + 8396;
	// 826AAE64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826AAE68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826AAE6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826AAE70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826AAE74: 48000008  b 0x826aae7c
	pc = 0x826AAE7C; continue 'dispatch;
	// 826AAE78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AAE7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AAE80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AAE84: 409A0044  bne cr6, 0x826aaec8
	if !ctx.cr[6].eq {
	pc = 0x826AAEC8; continue 'dispatch;
	}
	// 826AAE88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826AAE8C: 419A001C  beq cr6, 0x826aaea8
	if ctx.cr[6].eq {
	pc = 0x826AAEA8; continue 'dispatch;
	}
	// 826AAE90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AAE94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AAE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAE9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AAEA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AAEA4: 4E800421  bctrl
	ctx.lr = 0x826AAEA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AAEA8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AAEAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AAEB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAEB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826AAEB8: 816BA214  lwz r11, -0x5dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24044 as u32) ) } as u64;
	// 826AAEBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AAEC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AAEC4: 4BC1513D  bl 0x822c0000
	ctx.lr = 0x826AAEC8;
	sub_822C0000(ctx, base);
	// 826AAEC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AAECC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AAED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AAED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AAED8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AAEDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AAEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AAEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AAEE8 size=196
    let mut pc: u32 = 0x826AAEE8;
    'dispatch: loop {
        match pc {
            0x826AAEE8 => {
    //   block [0x826AAEE8..0x826AAFAC)
	// 826AAEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AAEEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AAEF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AAEF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AAEF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AAEFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AAF00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AAF04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826AAF08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AAF0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AAF10: 4BC15A29  bl 0x822c0938
	ctx.lr = 0x826AAF14;
	sub_822C0938(ctx, base);
	// 826AAF14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AAF18: 41820028  beq 0x826aaf40
	if ctx.cr[0].eq {
	pc = 0x826AAF40; continue 'dispatch;
	}
	// 826AAF1C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAF20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826AAF24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826AAF28: 392B20E0  addi r9, r11, 0x20e0
	ctx.r[9].s64 = ctx.r[11].s64 + 8416;
	// 826AAF2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826AAF30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826AAF34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826AAF38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826AAF3C: 48000008  b 0x826aaf44
	pc = 0x826AAF44; continue 'dispatch;
	// 826AAF40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AAF44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AAF48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AAF4C: 409A0044  bne cr6, 0x826aaf90
	if !ctx.cr[6].eq {
	pc = 0x826AAF90; continue 'dispatch;
	}
	// 826AAF50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826AAF54: 419A001C  beq cr6, 0x826aaf70
	if ctx.cr[6].eq {
	pc = 0x826AAF70; continue 'dispatch;
	}
	// 826AAF58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AAF5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AAF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AAF64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AAF68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AAF6C: 4E800421  bctrl
	ctx.lr = 0x826AAF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AAF70: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AAF74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AAF78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AAF7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826AAF80: 816BA214  lwz r11, -0x5dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24044 as u32) ) } as u64;
	// 826AAF84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AAF88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AAF8C: 4BC15075  bl 0x822c0000
	ctx.lr = 0x826AAF90;
	sub_822C0000(ctx, base);
	// 826AAF90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AAF94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AAF98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AAF9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AAFA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AAFA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AAFA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AAFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AAFB0 size=148
    let mut pc: u32 = 0x826AAFB0;
    'dispatch: loop {
        match pc {
            0x826AAFB0 => {
    //   block [0x826AAFB0..0x826AB044)
	// 826AAFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AAFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AAFB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AAFBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AAFC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AAFC4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AAFC8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AAFCC: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AAFD0: 396B2154  addi r11, r11, 0x2154
	ctx.r[11].s64 = ctx.r[11].s64 + 8532;
	// 826AAFD4: 394A2140  addi r10, r10, 0x2140
	ctx.r[10].s64 = ctx.r[10].s64 + 8512;
	// 826AAFD8: 392920F4  addi r9, r9, 0x20f4
	ctx.r[9].s64 = ctx.r[9].s64 + 8436;
	// 826AAFDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AAFE0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826AAFE4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826AAFE8: 807F01A0  lwz r3, 0x1a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 826AAFEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AAFF0: 419A0008  beq cr6, 0x826aaff8
	if ctx.cr[6].eq {
	pc = 0x826AAFF8; continue 'dispatch;
	}
	// 826AAFF4: 4BC1589D  bl 0x822c0890
	ctx.lr = 0x826AAFF8;
	sub_822C0890(ctx, base);
	// 826AAFF8: 807F0198  lwz r3, 0x198(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 826AAFFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB000: 419A0008  beq cr6, 0x826ab008
	if ctx.cr[6].eq {
	pc = 0x826AB008; continue 'dispatch;
	}
	// 826AB004: 4BC1588D  bl 0x822c0890
	ctx.lr = 0x826AB008;
	sub_822C0890(ctx, base);
	// 826AB008: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826AB00C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB010: 419A0008  beq cr6, 0x826ab018
	if ctx.cr[6].eq {
	pc = 0x826AB018; continue 'dispatch;
	}
	// 826AB014: 4BC1587D  bl 0x822c0890
	ctx.lr = 0x826AB018;
	sub_822C0890(ctx, base);
	// 826AB018: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826AB01C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB020: 419A0008  beq cr6, 0x826ab028
	if ctx.cr[6].eq {
	pc = 0x826AB028; continue 'dispatch;
	}
	// 826AB024: 4BC1586D  bl 0x822c0890
	ctx.lr = 0x826AB028;
	sub_822C0890(ctx, base);
	// 826AB028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB02C: 4BFFB7DD  bl 0x826a6808
	ctx.lr = 0x826AB030;
	sub_826A6808(ctx, base);
	// 826AB030: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AB034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AB038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AB03C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AB040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AB048 size=8
    let mut pc: u32 = 0x826AB048;
    'dispatch: loop {
        match pc {
            0x826AB048 => {
    //   block [0x826AB048..0x826AB050)
	// 826AB048: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826AB04C: 48000214  b 0x826ab260
	sub_826AB260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AB050 size=8
    let mut pc: u32 = 0x826AB050;
    'dispatch: loop {
        match pc {
            0x826AB050 => {
    //   block [0x826AB050..0x826AB058)
	// 826AB050: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826AB054: 4800020C  b 0x826ab260
	sub_826AB260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AB058 size=308
    let mut pc: u32 = 0x826AB058;
    'dispatch: loop {
        match pc {
            0x826AB058 => {
    //   block [0x826AB058..0x826AB18C)
	// 826AB058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AB05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AB060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AB064: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AB068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AB06C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826AB070: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826AB074: 419A0104  beq cr6, 0x826ab178
	if ctx.cr[6].eq {
	pc = 0x826AB178; continue 'dispatch;
	}
	// 826AB078: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826AB07C: 4BC25035  bl 0x822d00b0
	ctx.lr = 0x826AB080;
	sub_822D00B0(ctx, base);
	// 826AB080: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826AB084: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826AB088: 4BC24F61  bl 0x822cffe8
	ctx.lr = 0x826AB08C;
	sub_822CFFE8(ctx, base);
	// 826AB08C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 826AB090: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826AB094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB098: 487D2289  bl 0x82e7d320
	ctx.lr = 0x826AB09C;
	sub_82E7D320(ctx, base);
	// 826AB09C: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 826AB0A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826AB0A4: 409A0044  bne cr6, 0x826ab0e8
	if !ctx.cr[6].eq {
	pc = 0x826AB0E8; continue 'dispatch;
	}
	// 826AB0A8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826AB0AC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AB0B0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 826AB0B4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AB0B8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826AB0BC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AB0C0: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826AB0C4: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AB0C8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826AB0CC: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AB0D0: FC005850  fneg f0, f11
	ctx.f[0].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AB0D4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826AB0D8: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826AB0DC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826AB0E0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AB190 size=208
    let mut pc: u32 = 0x826AB190;
    'dispatch: loop {
        match pc {
            0x826AB190 => {
    //   block [0x826AB190..0x826AB260)
	// 826AB190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AB194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AB198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AB19C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AB1A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AB1A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AB1A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AB1AC: 4BFFB975  bl 0x826a6b20
	ctx.lr = 0x826AB1B0;
	sub_826A6B20(ctx, base);
	// 826AB1B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AB1B4: 93DF0180  stw r30, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 826AB1B8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AB1BC: 396B2154  addi r11, r11, 0x2154
	ctx.r[11].s64 = ctx.r[11].s64 + 8532;
	// 826AB1C0: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AB1C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AB1C8: 394A2140  addi r10, r10, 0x2140
	ctx.r[10].s64 = ctx.r[10].s64 + 8512;
	// 826AB1CC: 392920F4  addi r9, r9, 0x20f4
	ctx.r[9].s64 = ctx.r[9].s64 + 8436;
	// 826AB1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AB1D4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826AB1D8: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826AB1DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AB1E0: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 826AB1E4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826AB1E8: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 826AB1EC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 826AB1F0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 826AB1F4: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826AB1F8: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 826AB1FC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826AB200: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 826AB204: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AB208: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 826AB20C: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AB210: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 826AB214: C188D7BC  lfs f12, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826AB218: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 826AB21C: C1670A9C  lfs f11, 0xa9c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2716 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826AB220: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 826AB224: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 826AB228: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 826AB22C: 98DF01AC  stb r6, 0x1ac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[6].u8 ) };
	// 826AB230: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 826AB234: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 826AB238: D1BF01BC  stfs f13, 0x1bc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 826AB23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB240: D19F01C0  stfs f12, 0x1c0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 826AB244: D17F01C4  stfs f11, 0x1c4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 826AB248: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AB24C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AB250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AB254: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AB258: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AB25C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AB260 size=76
    let mut pc: u32 = 0x826AB260;
    'dispatch: loop {
        match pc {
            0x826AB260 => {
    //   block [0x826AB260..0x826AB2AC)
	// 826AB260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AB264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AB268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AB26C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AB270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AB274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AB278: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AB27C: 4BFFFD35  bl 0x826aafb0
	ctx.lr = 0x826AB280;
	sub_826AAFB0(ctx, base);
	// 826AB280: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AB284: 4182000C  beq 0x826ab290
	if ctx.cr[0].eq {
	pc = 0x826AB290; continue 'dispatch;
	}
	// 826AB288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB28C: 4874714D  bl 0x82df23d8
	ctx.lr = 0x826AB290;
	sub_82DF23D8(ctx, base);
	// 826AB290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AB298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AB29C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AB2A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AB2A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AB2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AB2B0 size=32
    let mut pc: u32 = 0x826AB2B0;
    'dispatch: loop {
        match pc {
            0x826AB2B0 => {
    //   block [0x826AB2B0..0x826AB2D0)
	// 826AB2B0: 81030194  lwz r8, 0x194(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 826AB2B4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826AB2B8: 39430194  addi r10, r3, 0x194
	ctx.r[10].s64 = ctx.r[3].s64 + 404;
	// 826AB2BC: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826AB2C0: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826AB2C4: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826AB2C8: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826AB2CC: 4BC19194  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AB2D0 size=124
    let mut pc: u32 = 0x826AB2D0;
    'dispatch: loop {
        match pc {
            0x826AB2D0 => {
    //   block [0x826AB2D0..0x826AB34C)
	// 826AB2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AB2D4: 48AFCE99  bl 0x831a816c
	ctx.lr = 0x826AB2D8;
	sub_831A8130(ctx, base);
	// 826AB2D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AB2DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AB2E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826AB2E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB2E8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826AB2EC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826AB2F0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 826AB2F4: 487470F5  bl 0x82df23e8
	ctx.lr = 0x826AB2F8;
	sub_82DF23E8(ctx, base);
	// 826AB2F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826AB2FC: 4182001C  beq 0x826ab318
	if ctx.cr[0].eq {
	pc = 0x826AB318; continue 'dispatch;
	}
	// 826AB300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB304: 487AE37D  bl 0x82e59680
	ctx.lr = 0x826AB308;
	sub_82E59680(ctx, base);
	// 826AB308: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AB30C: 396B20C4  addi r11, r11, 0x20c4
	ctx.r[11].s64 = ctx.r[11].s64 + 8388;
	// 826AB310: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AB314: 48000008  b 0x826ab31c
	pc = 0x826AB31C; continue 'dispatch;
	// 826AB318: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AB31C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826AB320: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826AB324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AB32C: 4BFFFBBD  bl 0x826aaee8
	ctx.lr = 0x826AB330;
	sub_826AAEE8(ctx, base);
	// 826AB330: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AB334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AB33C: 4BC14CC5  bl 0x822c0000
	ctx.lr = 0x826AB340;
	sub_822C0000(ctx, base);
	// 826AB340: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AB344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AB348: 48AFCE74  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AB350 size=220
    let mut pc: u32 = 0x826AB350;
    'dispatch: loop {
        match pc {
            0x826AB350 => {
    //   block [0x826AB350..0x826AB42C)
	// 826AB350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AB354: 48AFCE15  bl 0x831a8168
	ctx.lr = 0x826AB358;
	sub_831A8130(ctx, base);
	// 826AB358: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AB35C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826AB360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AB364: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AB368: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AB36C: 41820038  beq 0x826ab3a4
	if ctx.cr[0].eq {
	pc = 0x826AB3A4; continue 'dispatch;
	}
	// 826AB370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB374: 48AFE615  bl 0x831a9988
	ctx.lr = 0x826AB378;
	sub_831A9988(ctx, base);
	// 826AB378: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826AB37C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB380: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826AB384: 48AFCD75  bl 0x831a80f8
	ctx.lr = 0x826AB388;
	sub_831A80F8(ctx, base);
	// 826AB388: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AB38C: 41820018  beq 0x826ab3a4
	if ctx.cr[0].eq {
	pc = 0x826AB3A4; continue 'dispatch;
	}
	// 826AB390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB394: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AB398: 4BFFF959  bl 0x826aacf0
	ctx.lr = 0x826AB39C;
	sub_826AACF0(ctx, base);
	// 826AB39C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826AB3A0: 48000084  b 0x826ab424
	pc = 0x826AB424; continue 'dispatch;
	// 826AB3A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AB3A8: 419A006C  beq cr6, 0x826ab414
	if ctx.cr[6].eq {
	pc = 0x826AB414; continue 'dispatch;
	}
	// 826AB3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB3B0: 48AFE5D9  bl 0x831a9988
	ctx.lr = 0x826AB3B4;
	sub_831A9988(ctx, base);
	// 826AB3B4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826AB3B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB3BC: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826AB3C0: 48AFCD39  bl 0x831a80f8
	ctx.lr = 0x826AB3C4;
	sub_831A80F8(ctx, base);
	// 826AB3C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AB3C8: 41820014  beq 0x826ab3dc
	if ctx.cr[0].eq {
	pc = 0x826AB3DC; continue 'dispatch;
	}
	// 826AB3CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB3D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AB3D4: 4BFFF9AD  bl 0x826aad80
	ctx.lr = 0x826AB3D8;
	sub_826AAD80(ctx, base);
	// 826AB3D8: 4BFFFFC4  b 0x826ab39c
	pc = 0x826AB39C; continue 'dispatch;
	// 826AB3DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AB3E0: 419A0034  beq cr6, 0x826ab414
	if ctx.cr[6].eq {
	pc = 0x826AB414; continue 'dispatch;
	}
	// 826AB3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB3E8: 48AFE5A1  bl 0x831a9988
	ctx.lr = 0x826AB3EC;
	sub_831A9988(ctx, base);
	// 826AB3EC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826AB3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB3F4: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826AB3F8: 48AFCD01  bl 0x831a80f8
	ctx.lr = 0x826AB3FC;
	sub_831A80F8(ctx, base);
	// 826AB3FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AB400: 41820014  beq 0x826ab414
	if ctx.cr[0].eq {
	pc = 0x826AB414; continue 'dispatch;
	}
	// 826AB404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB408: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AB40C: 4BFFFEA5  bl 0x826ab2b0
	ctx.lr = 0x826AB410;
	sub_826AB2B0(ctx, base);
	// 826AB410: 4BFFFF8C  b 0x826ab39c
	pc = 0x826AB39C; continue 'dispatch;
	// 826AB414: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826AB418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AB420: 4BFFC4A9  bl 0x826a78c8
	ctx.lr = 0x826AB424;
	sub_826A78C8(ctx, base);
	// 826AB424: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826AB428: 48AFCD90  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AB430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AB430 size=1648
    let mut pc: u32 = 0x826AB430;
    'dispatch: loop {
        match pc {
            0x826AB430 => {
    //   block [0x826AB430..0x826ABAA0)
	// 826AB430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AB434: 48AFCD11  bl 0x831a8144
	ctx.lr = 0x826AB438;
	sub_831A8130(ctx, base);
	// 826AB438: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 826AB43C: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AB440: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 826AB444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AB448: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 826AB44C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 826AB450: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 826AB454: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826AB458: 4BFFC589  bl 0x826a79e0
	ctx.lr = 0x826AB45C;
	sub_826A79E0(ctx, base);
	// 826AB45C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AB460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB464: 3ACB2198  addi r22, r11, 0x2198
	ctx.r[22].s64 = ctx.r[11].s64 + 8600;
	// 826AB468: 38A0012F  li r5, 0x12f
	ctx.r[5].s64 = 303;
	// 826AB46C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826AB470: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AB474: 48746F75  bl 0x82df23e8
	ctx.lr = 0x826AB478;
	sub_82DF23E8(ctx, base);
	// 826AB478: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AB47C: 41820018  beq 0x826ab494
	if ctx.cr[0].eq {
	pc = 0x826AB494; continue 'dispatch;
	}
	// 826AB480: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826AB484: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826AB488: 48767C69  bl 0x82e130f0
	ctx.lr = 0x826AB48C;
	sub_82E130F0(ctx, base);
	// 826AB48C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB490: 48000008  b 0x826ab498
	pc = 0x826AB498; continue 'dispatch;
	// 826AB494: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826AB498: 3B1F0194  addi r24, r31, 0x194
	ctx.r[24].s64 = ctx.r[31].s64 + 404;
	// 826AB49C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826AB4A0: 4BC368B1  bl 0x822e1d50
	ctx.lr = 0x826AB4A4;
	sub_822E1D50(ctx, base);
	// 826AB4A4: 809F0194  lwz r4, 0x194(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 826AB4A8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826AB4AC: 48767985  bl 0x82e12e30
	ctx.lr = 0x826AB4B0;
	sub_82E12E30(ctx, base);
	// 826AB4B0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826AB4B4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB4B8: 4877F631  bl 0x82e2aae8
	ctx.lr = 0x826AB4BC;
	sub_82E2AAE8(ctx, base);
	// 826AB4BC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AB4C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB4C4: 3BABA1B8  addi r29, r11, -0x5e48
	ctx.r[29].s64 = ctx.r[11].s64 + -24136;
	// 826AB4C8: 817F0180  lwz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826AB4CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826AB4D0: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826AB4D4: 48748535  bl 0x82df3a08
	ctx.lr = 0x826AB4D8;
	sub_82DF3A08(ctx, base);
	// 826AB4D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB4DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AB4E0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826AB4E4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826AB4E8: 48783989  bl 0x82e2ee70
	ctx.lr = 0x826AB4EC;
	sub_82E2EE70(ctx, base);
	// 826AB4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB4F0: 48747F39  bl 0x82df3428
	ctx.lr = 0x826AB4F4;
	sub_82DF3428(ctx, base);
	// 826AB4F4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 826AB4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB4FC: 419A009C  beq cr6, 0x826ab598
	if ctx.cr[6].eq {
	pc = 0x826AB598; continue 'dispatch;
	}
	// 826AB500: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826AB504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB508: 38A00137  li r5, 0x137
	ctx.r[5].s64 = 311;
	// 826AB50C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826AB510: 48746ED9  bl 0x82df23e8
	ctx.lr = 0x826AB514;
	sub_82DF23E8(ctx, base);
	// 826AB514: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AB518: 41820014  beq 0x826ab52c
	if ctx.cr[0].eq {
	pc = 0x826AB52C; continue 'dispatch;
	}
	// 826AB51C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826AB520: 4876B371  bl 0x82e16890
	ctx.lr = 0x826AB524;
	sub_82E16890(ctx, base);
	// 826AB524: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB528: 48000008  b 0x826ab530
	pc = 0x826AB530; continue 'dispatch;
	// 826AB52C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826AB530: 3BDF0184  addi r30, r31, 0x184
	ctx.r[30].s64 = ctx.r[31].s64 + 388;
	// 826AB534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AB538: 4BCB1E39  bl 0x8235d370
	ctx.lr = 0x826AB53C;
	sub_8235D370(ctx, base);
	// 826AB53C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AB540: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB548: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AB54C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AB550: 419A0024  beq cr6, 0x826ab574
	if ctx.cr[6].eq {
	pc = 0x826AB574; continue 'dispatch;
	}
	// 826AB554: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AB558: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AB55C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB560: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AB564: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AB568: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AB56C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB570: 4082FFE8  bne 0x826ab558
	if !ctx.cr[0].eq {
	pc = 0x826AB558; continue 'dispatch;
	}
	// 826AB574: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AB578: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB57C: 48769B35  bl 0x82e150b0
	ctx.lr = 0x826AB580;
	sub_82E150B0(ctx, base);
	// 826AB580: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826AB584: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826AB588: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826AB58C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB590: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826AB594: 4BE655C5  bl 0x82510b58
	ctx.lr = 0x826AB598;
	sub_82510B58(ctx, base);
	// 826AB598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB59C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826AB5A0: 4BE63F29  bl 0x8250f4c8
	ctx.lr = 0x826AB5A4;
	sub_8250F4C8(ctx, base);
	// 826AB5A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB5AC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826AB5B0: 409A0008  bne cr6, 0x826ab5b8
	if !ctx.cr[6].eq {
	pc = 0x826AB5B8; continue 'dispatch;
	}
	// 826AB5B4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826AB5B8: 4BE5CF71  bl 0x82508528
	ctx.lr = 0x826AB5BC;
	sub_82508528(ctx, base);
	// 826AB5BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826AB5C0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826AB5C4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB5C8: 4BC3BC41  bl 0x822e7208
	ctx.lr = 0x826AB5CC;
	sub_822E7208(ctx, base);
	// 826AB5CC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826AB5D0: 487466C1  bl 0x82df1c90
	ctx.lr = 0x826AB5D4;
	sub_82DF1C90(ctx, base);
	// 826AB5D4: 815F0180  lwz r10, 0x180(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826AB5D8: 397D0060  addi r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 + 96;
	// 826AB5DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826AB5E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB5E4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826AB5E8: 48748421  bl 0x82df3a08
	ctx.lr = 0x826AB5EC;
	sub_82DF3A08(ctx, base);
	// 826AB5EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB5F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AB5F4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826AB5F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826AB5FC: 4BC3BD95  bl 0x822e7390
	ctx.lr = 0x826AB600;
	sub_822E7390(ctx, base);
	// 826AB600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB604: 48747E25  bl 0x82df3428
	ctx.lr = 0x826AB608;
	sub_82DF3428(ctx, base);
	// 826AB608: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826AB60C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB610: 419A0454  beq cr6, 0x826aba64
	if ctx.cr[6].eq {
	pc = 0x826ABA64; continue 'dispatch;
	}
	// 826AB614: 817F0180  lwz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826AB618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB61C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826AB620: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826AB624: 487483E5  bl 0x82df3a08
	ctx.lr = 0x826AB628;
	sub_82DF3A08(ctx, base);
	// 826AB628: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 826AB62C: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826AB630: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AB634: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826AB638: 4BC430A1  bl 0x822ee6d8
	ctx.lr = 0x826AB63C;
	sub_822EE6D8(ctx, base);
	// 826AB63C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826AB640: 3B3F018C  addi r25, r31, 0x18c
	ctx.r[25].s64 = ctx.r[31].s64 + 396;
	// 826AB644: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826AB648: 38790004  addi r3, r25, 4
	ctx.r[3].s64 = ctx.r[25].s64 + 4;
	// 826AB64C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB650: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826AB654: 4BC18E0D  bl 0x822c4460
	ctx.lr = 0x826AB658;
	sub_822C4460(ctx, base);
	// 826AB658: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 826AB65C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB660: 419A0008  beq cr6, 0x826ab668
	if ctx.cr[6].eq {
	pc = 0x826AB668; continue 'dispatch;
	}
	// 826AB664: 4BC1522D  bl 0x822c0890
	ctx.lr = 0x826AB668;
	sub_822C0890(ctx, base);
	// 826AB668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB66C: 48747DBD  bl 0x82df3428
	ctx.lr = 0x826AB670;
	sub_82DF3428(ctx, base);
	// 826AB670: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB678: 419A03EC  beq cr6, 0x826aba64
	if ctx.cr[6].eq {
	pc = 0x826ABA64; continue 'dispatch;
	}
	// 826AB67C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AB680: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AB68C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AB690: 419A0024  beq cr6, 0x826ab6b4
	if ctx.cr[6].eq {
	pc = 0x826AB6B4; continue 'dispatch;
	}
	// 826AB694: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AB698: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AB69C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB6A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AB6A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AB6A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AB6AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB6B0: 4082FFE8  bne 0x826ab698
	if !ctx.cr[0].eq {
	pc = 0x826AB698; continue 'dispatch;
	}
	// 826AB6B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AB6B8: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB6BC: 4BC428A5  bl 0x822edf60
	ctx.lr = 0x826AB6C0;
	sub_822EDF60(ctx, base);
	// 826AB6C0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826AB6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB6C8: 4BE65679  bl 0x82510d40
	ctx.lr = 0x826AB6CC;
	sub_82510D40(ctx, base);
	// 826AB6CC: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 826AB6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB6D4: 419A0014  beq cr6, 0x826ab6e8
	if ctx.cr[6].eq {
	pc = 0x826AB6E8; continue 'dispatch;
	}
	// 826AB6D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826AB6DC: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB6E0: 3880200E  li r4, 0x200e
	ctx.r[4].s64 = 8206;
	// 826AB6E4: 4BDE3ACD  bl 0x8248f1b0
	ctx.lr = 0x826AB6E8;
	sub_8248F1B0(ctx, base);
	// 826AB6E8: 815F0180  lwz r10, 0x180(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826AB6EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AB6F0: 393D00C0  addi r9, r29, 0xc0
	ctx.r[9].s64 = ctx.r[29].s64 + 192;
	// 826AB6F4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 826AB6F8: 3B4B9BC9  addi r26, r11, -0x6437
	ctx.r[26].s64 = ctx.r[11].s64 + -25655;
	// 826AB6FC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 826AB700: 7D68482E  lwzx r11, r8, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 826AB704: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB708: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB70C: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 826AB710: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 826AB714: 41820014  beq 0x826ab728
	if ctx.cr[0].eq {
	pc = 0x826AB728; continue 'dispatch;
	}
	// 826AB718: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 826AB71C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AB720: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826AB724: 419AFFE0  beq cr6, 0x826ab704
	if ctx.cr[6].eq {
	pc = 0x826AB704; continue 'dispatch;
	}
	// 826AB728: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 826AB72C: 4182021C  beq 0x826ab948
	if ctx.cr[0].eq {
	pc = 0x826AB948; continue 'dispatch;
	}
	// 826AB730: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AB734: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB738: 4BC26649  bl 0x822d1d80
	ctx.lr = 0x826AB73C;
	sub_822D1D80(ctx, base);
	// 826AB73C: 815F0180  lwz r10, 0x180(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826AB740: 397D00C0  addi r11, r29, 0xc0
	ctx.r[11].s64 = ctx.r[29].s64 + 192;
	// 826AB744: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826AB748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB74C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826AB750: 487482B9  bl 0x82df3a08
	ctx.lr = 0x826AB754;
	sub_82DF3A08(ctx, base);
	// 826AB754: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB758: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AB75C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826AB760: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826AB764: 4BC267A5  bl 0x822d1f08
	ctx.lr = 0x826AB768;
	sub_822D1F08(ctx, base);
	// 826AB768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB76C: 48747CBD  bl 0x82df3428
	ctx.lr = 0x826AB770;
	sub_82DF3428(ctx, base);
	// 826AB770: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826AB774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB778: 419A006C  beq cr6, 0x826ab7e4
	if ctx.cr[6].eq {
	pc = 0x826AB7E4; continue 'dispatch;
	}
	// 826AB77C: 48753065  bl 0x82dfe7e0
	ctx.lr = 0x826AB780;
	sub_82DFE7E0(ctx, base);
	// 826AB780: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AB784: 40820060  bne 0x826ab7e4
	if !ctx.cr[0].eq {
	pc = 0x826AB7E4; continue 'dispatch;
	}
	// 826AB788: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826AB78C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826AB790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB794: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AB798: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AB79C: 419A0024  beq cr6, 0x826ab7c0
	if ctx.cr[6].eq {
	pc = 0x826AB7C0; continue 'dispatch;
	}
	// 826AB7A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AB7A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AB7A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB7AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AB7B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AB7B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AB7B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB7BC: 4082FFE8  bne 0x826ab7a4
	if !ctx.cr[0].eq {
	pc = 0x826AB7A4; continue 'dispatch;
	}
	// 826AB7C0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826AB7C4: 4BE3F2C5  bl 0x824eaa88
	ctx.lr = 0x826AB7C8;
	sub_824EAA88(ctx, base);
	// 826AB7C8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 826AB7CC: 38C0015D  li r6, 0x15d
	ctx.r[6].s64 = 349;
	// 826AB7D0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB7D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AB7D8: 4850E9A9  bl 0x82bba180
	ctx.lr = 0x826AB7DC;
	sub_82BBA180(ctx, base);
	// 826AB7DC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826AB7E0: 487464B1  bl 0x82df1c90
	ctx.lr = 0x826AB7E4;
	sub_82DF1C90(ctx, base);
	// 826AB7E4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826AB7E8: 4BC23C01  bl 0x822cf3e8
	ctx.lr = 0x826AB7EC;
	sub_822CF3E8(ctx, base);
	// 826AB7EC: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826AB7F0: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 826AB7F4: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 826AB7F8: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 826AB7FC: 41820134  beq 0x826ab930
	if ctx.cr[0].eq {
	pc = 0x826AB930; continue 'dispatch;
	}
	// 826AB800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AB804: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 826AB808: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826AB80C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826AB810: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB814: 38A00162  li r5, 0x162
	ctx.r[5].s64 = 354;
	// 826AB818: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826AB81C: 48746BCD  bl 0x82df23e8
	ctx.lr = 0x826AB820;
	sub_82DF23E8(ctx, base);
	// 826AB820: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AB824: 41820064  beq 0x826ab888
	if ctx.cr[0].eq {
	pc = 0x826AB888; continue 'dispatch;
	}
	// 826AB828: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AB82C: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AB834: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 826AB838: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 826AB83C: 419A0024  beq cr6, 0x826ab860
	if ctx.cr[6].eq {
	pc = 0x826AB860; continue 'dispatch;
	}
	// 826AB840: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AB844: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AB848: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB84C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AB850: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AB854: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AB858: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB85C: 4082FFE8  bne 0x826ab844
	if !ctx.cr[0].eq {
	pc = 0x826AB844; continue 'dispatch;
	}
	// 826AB860: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826AB864: 80DB6824  lwz r6, 0x6824(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826AB868: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 826AB86C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AB870: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826AB874: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826AB878: 62F70001  ori r23, r23, 1
	ctx.r[23].u64 = ctx.r[23].u64 | 1;
	// 826AB87C: 4BC362E5  bl 0x822e1b60
	ctx.lr = 0x826AB880;
	sub_822E1B60(ctx, base);
	// 826AB880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB884: 48000008  b 0x826ab88c
	pc = 0x826AB88C; continue 'dispatch;
	// 826AB888: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826AB88C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB890: 48026BD1  bl 0x826d2460
	ctx.lr = 0x826AB894;
	sub_826D2460(ctx, base);
	// 826AB894: 56EB07FF  clrlwi. r11, r23, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AB898: 41820018  beq 0x826ab8b0
	if ctx.cr[0].eq {
	pc = 0x826AB8B0; continue 'dispatch;
	}
	// 826AB89C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826AB8A0: 56F7003C  rlwinm r23, r23, 0, 0, 0x1e
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 826AB8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB8A8: 419A0008  beq cr6, 0x826ab8b0
	if ctx.cr[6].eq {
	pc = 0x826AB8B0; continue 'dispatch;
	}
	// 826AB8AC: 4BC14FE5  bl 0x822c0890
	ctx.lr = 0x826AB8B0;
	sub_822C0890(ctx, base);
	// 826AB8B0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826AB8B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826AB8B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AB8BC: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 826AB8C0: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 826AB8C4: 419A0024  beq cr6, 0x826ab8e8
	if ctx.cr[6].eq {
	pc = 0x826AB8E8; continue 'dispatch;
	}
	// 826AB8C8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AB8CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AB8D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB8D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AB8D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AB8DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AB8E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AB8E4: 4082FFE8  bne 0x826ab8cc
	if !ctx.cr[0].eq {
	pc = 0x826AB8CC; continue 'dispatch;
	}
	// 826AB8E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AB8EC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826AB8F0: 3A610098  addi r19, r1, 0x98
	ctx.r[19].s64 = ctx.r[1].s64 + 152;
	// 826AB8F4: 4BE63C25  bl 0x8250f518
	ctx.lr = 0x826AB8F8;
	sub_8250F518(ctx, base);
	// 826AB8F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB8FC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 826AB900: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 826AB904: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826AB908: 4BE61C01  bl 0x8250d508
	ctx.lr = 0x826AB90C;
	sub_8250D508(ctx, base);
	// 826AB90C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826AB910: 48746381  bl 0x82df1c90
	ctx.lr = 0x826AB914;
	sub_82DF1C90(ctx, base);
	// 826AB914: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826AB918: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 826AB91C: 4198FEF0  blt cr6, 0x826ab80c
	if ctx.cr[6].lt {
	pc = 0x826AB80C; continue 'dispatch;
	}
	// 826AB920: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AB924: 419A000C  beq cr6, 0x826ab930
	if ctx.cr[6].eq {
	pc = 0x826AB930; continue 'dispatch;
	}
	// 826AB928: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AB92C: 4BC14F65  bl 0x822c0890
	ctx.lr = 0x826AB930;
	sub_822C0890(ctx, base);
	// 826AB930: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826AB934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AB938: 419A0008  beq cr6, 0x826ab940
	if ctx.cr[6].eq {
	pc = 0x826AB940; continue 'dispatch;
	}
	// 826AB93C: 4BC14F55  bl 0x822c0890
	ctx.lr = 0x826AB940;
	sub_822C0890(ctx, base);
	// 826AB940: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AB944: 4BC26455  bl 0x822d1d98
	ctx.lr = 0x826AB948;
	sub_822D1D98(ctx, base);
	// 826AB948: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 826AB94C: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 826AB950: 409A0114  bne cr6, 0x826aba64
	if !ctx.cr[6].eq {
	pc = 0x826ABA64; continue 'dispatch;
	}
	// 826AB954: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 826AB958: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AB95C: 40820108  bne 0x826aba64
	if !ctx.cr[0].eq {
	pc = 0x826ABA64; continue 'dispatch;
	}
	// 826AB960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AB964: 4BE67135  bl 0x82512a98
	ctx.lr = 0x826AB968;
	sub_82512A98(ctx, base);
	// 826AB968: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826AB96C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AB970: 38A0016B  li r5, 0x16b
	ctx.r[5].s64 = 363;
	// 826AB974: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AB978: 48746A71  bl 0x82df23e8
	ctx.lr = 0x826AB97C;
	sub_82DF23E8(ctx, base);
	// 826AB97C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826AB980: 41820044  beq 0x826ab9c4
	if ctx.cr[0].eq {
	pc = 0x826AB9C4; continue 'dispatch;
	}
	// 826AB984: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AB988: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 826AB98C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826AB990: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826AB994: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AB998: C1AA7BC8  lfs f13, 0x7bc8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AB99C: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 826AB9A0: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 826AB9A4: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 826AB9A8: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 826AB9AC: 487D062D  bl 0x82e7bfd8
	ctx.lr = 0x826AB9B0;
	sub_82E7BFD8(ctx, base);
	// 826AB9B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB9B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AB9B8: 48767739  bl 0x82e130f0
	ctx.lr = 0x826AB9BC;
	sub_82E130F0(ctx, base);
	// 826AB9BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AB9C0: 48000008  b 0x826ab9c8
	pc = 0x826AB9C8; continue 'dispatch;
	// 826AB9C4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826AB9C8: 387F019C  addi r3, r31, 0x19c
	ctx.r[3].s64 = ctx.r[31].s64 + 412;
	// 826AB9CC: 4BC36385  bl 0x822e1d50
	ctx.lr = 0x826AB9D0;
	sub_822E1D50(ctx, base);
	// 826AB9D0: 809F019C  lwz r4, 0x19c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 826AB9D4: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB9D8: 48767459  bl 0x82e12e30
	ctx.lr = 0x826AB9DC;
	sub_82E12E30(ctx, base);
	// 826AB9DC: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB9E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AB9E4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AB9E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AB9EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AB9F0: 4E800421  bctrl
	ctx.lr = 0x826AB9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AB9F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826AB9F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AB9FC: 4874DB35  bl 0x82df9530
	ctx.lr = 0x826ABA00;
	sub_82DF9530(ctx, base);
	// 826ABA00: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 826ABA04: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 826ABA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ABA0C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826ABA10: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826ABA14: 419A0024  beq cr6, 0x826aba38
	if ctx.cr[6].eq {
	pc = 0x826ABA38; continue 'dispatch;
	}
	// 826ABA18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826ABA1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826ABA20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ABA24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826ABA28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826ABA2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826ABA30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ABA34: 4082FFE8  bne 0x826aba1c
	if !ctx.cr[0].eq {
	pc = 0x826ABA1C; continue 'dispatch;
	}
	// 826ABA38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ABA3C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 826ABA40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826ABA44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABA48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ABA4C: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 826ABA50: 4BE676A9  bl 0x825130f8
	ctx.lr = 0x826ABA54;
	sub_825130F8(ctx, base);
	// 826ABA54: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826ABA58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ABA5C: 419A0008  beq cr6, 0x826aba64
	if ctx.cr[6].eq {
	pc = 0x826ABA64; continue 'dispatch;
	}
	// 826ABA60: 4BC3C809  bl 0x822e8268
	ctx.lr = 0x826ABA64;
	sub_822E8268(ctx, base);
	// 826ABA64: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826ABA68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ABA6C: 419A0008  beq cr6, 0x826aba74
	if ctx.cr[6].eq {
	pc = 0x826ABA74; continue 'dispatch;
	}
	// 826ABA70: 4BC14E21  bl 0x822c0890
	ctx.lr = 0x826ABA74;
	sub_822C0890(ctx, base);
	// 826ABA74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ABA78: 4BC3B7A9  bl 0x822e7220
	ctx.lr = 0x826ABA7C;
	sub_822E7220(ctx, base);
	// 826ABA7C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826ABA80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ABA84: 419A0008  beq cr6, 0x826aba8c
	if ctx.cr[6].eq {
	pc = 0x826ABA8C; continue 'dispatch;
	}
	// 826ABA88: 4BC14E09  bl 0x822c0890
	ctx.lr = 0x826ABA8C;
	sub_822C0890(ctx, base);
	// 826ABA8C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826ABA90: 4877F071  bl 0x82e2ab00
	ctx.lr = 0x826ABA94;
	sub_82E2AB00(ctx, base);
	// 826ABA94: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 826ABA98: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 826ABA9C: 48AFC6F8  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ABAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ABAA0 size=2704
    let mut pc: u32 = 0x826ABAA0;
    'dispatch: loop {
        match pc {
            0x826ABAA0 => {
    //   block [0x826ABAA0..0x826AC530)
	// 826ABAA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ABAA4: 48AFC6B9  bl 0x831a815c
	ctx.lr = 0x826ABAA8;
	sub_831A8130(ctx, base);
	// 826ABAA8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 826ABAAC: 48AFCFCD  bl 0x831a8a78
	ctx.lr = 0x826ABAB0;
	sub_831A8A40(ctx, base);
	// 826ABAB0: 9421FB50  stwu r1, -0x4b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1200 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ABAB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABAB8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 826ABABC: 3B6B2198  addi r27, r11, 0x2198
	ctx.r[27].s64 = ctx.r[11].s64 + 8600;
	// 826ABAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ABAC4: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 826ABAC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826ABACC: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 826ABAD0: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 826ABAD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ABAD8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826ABADC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 826ABAE0: 38A00177  li r5, 0x177
	ctx.r[5].s64 = 375;
	// 826ABAE4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826ABAE8: 4BC148F1  bl 0x822c03d8
	ctx.lr = 0x826ABAEC;
	sub_822C03D8(ctx, base);
	// 826ABAEC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826ABAF0: 41820034  beq 0x826abb24
	if ctx.cr[0].eq {
	pc = 0x826ABB24; continue 'dispatch;
	}
	// 826ABAF4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABAFC: 388BC580  addi r4, r11, -0x3a80
	ctx.r[4].s64 = ctx.r[11].s64 + -14976;
	// 826ABB00: 48747F09  bl 0x82df3a08
	ctx.lr = 0x826ABB04;
	sub_82DF3A08(ctx, base);
	// 826ABB04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ABB08: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 826ABB0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABB10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABB14: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826ABB18: 4BF008F9  bl 0x825ac410
	ctx.lr = 0x826ABB1C;
	sub_825AC410(ctx, base);
	// 826ABB1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ABB20: 48000008  b 0x826abb28
	pc = 0x826ABB28; continue 'dispatch;
	// 826ABB24: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826ABB28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826ABB2C: 4BF068CD  bl 0x825b23f8
	ctx.lr = 0x826ABB30;
	sub_825B23F8(ctx, base);
	// 826ABB30: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826ABB34: 41820010  beq 0x826abb44
	if ctx.cr[0].eq {
	pc = 0x826ABB44; continue 'dispatch;
	}
	// 826ABB38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABB3C: 579C003C  rlwinm r28, r28, 0, 0, 0x1e
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 826ABB40: 487478E9  bl 0x82df3428
	ctx.lr = 0x826ABB44;
	sub_82DF3428(ctx, base);
	// 826ABB44: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABB4C: 388BC578  addi r4, r11, -0x3a88
	ctx.r[4].s64 = ctx.r[11].s64 + -14984;
	// 826ABB50: 48747EB9  bl 0x82df3a08
	ctx.lr = 0x826ABB54;
	sub_82DF3A08(ctx, base);
	// 826ABB54: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826ABB58: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABB5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826ABB60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABB64: 4BF0025D  bl 0x825abdc0
	ctx.lr = 0x826ABB68;
	sub_825ABDC0(ctx, base);
	// 826ABB68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABB6C: 487478BD  bl 0x82df3428
	ctx.lr = 0x826ABB70;
	sub_82DF3428(ctx, base);
	// 826ABB70: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABB74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABB78: 388B1344  addi r4, r11, 0x1344
	ctx.r[4].s64 = ctx.r[11].s64 + 4932;
	// 826ABB7C: 48747E8D  bl 0x82df3a08
	ctx.lr = 0x826ABB80;
	sub_82DF3A08(ctx, base);
	// 826ABB80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABB84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ABB88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABB8C: 4BF00235  bl 0x825abdc0
	ctx.lr = 0x826ABB90;
	sub_825ABDC0(ctx, base);
	// 826ABB90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABB94: 48747895  bl 0x82df3428
	ctx.lr = 0x826ABB98;
	sub_82DF3428(ctx, base);
	// 826ABB98: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABB9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABBA0: 388B1334  addi r4, r11, 0x1334
	ctx.r[4].s64 = ctx.r[11].s64 + 4916;
	// 826ABBA4: 48747E65  bl 0x82df3a08
	ctx.lr = 0x826ABBA8;
	sub_82DF3A08(ctx, base);
	// 826ABBA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABBAC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826ABBB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABBB4: 4BF0020D  bl 0x825abdc0
	ctx.lr = 0x826ABBB8;
	sub_825ABDC0(ctx, base);
	// 826ABBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABBBC: 4874786D  bl 0x82df3428
	ctx.lr = 0x826ABBC0;
	sub_82DF3428(ctx, base);
	// 826ABBC0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826ABBC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABBC8: 388B997C  addi r4, r11, -0x6684
	ctx.r[4].s64 = ctx.r[11].s64 + -26244;
	// 826ABBCC: 48747E3D  bl 0x82df3a08
	ctx.lr = 0x826ABBD0;
	sub_82DF3A08(ctx, base);
	// 826ABBD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABBD4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826ABBD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABBDC: 4BF001E5  bl 0x825abdc0
	ctx.lr = 0x826ABBE0;
	sub_825ABDC0(ctx, base);
	// 826ABBE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABBE4: 48747845  bl 0x82df3428
	ctx.lr = 0x826ABBE8;
	sub_82DF3428(ctx, base);
	// 826ABBE8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABBF0: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826ABBF4: 48747E15  bl 0x82df3a08
	ctx.lr = 0x826ABBF8;
	sub_82DF3A08(ctx, base);
	// 826ABBF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABBFC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826ABC00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABC04: 4BF001BD  bl 0x825abdc0
	ctx.lr = 0x826ABC08;
	sub_825ABDC0(ctx, base);
	// 826ABC08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC0C: 4874781D  bl 0x82df3428
	ctx.lr = 0x826ABC10;
	sub_82DF3428(ctx, base);
	// 826ABC10: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC18: 388B131C  addi r4, r11, 0x131c
	ctx.r[4].s64 = ctx.r[11].s64 + 4892;
	// 826ABC1C: 48747DED  bl 0x82df3a08
	ctx.lr = 0x826ABC20;
	sub_82DF3A08(ctx, base);
	// 826ABC20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABC24: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826ABC28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABC2C: 4BF00195  bl 0x825abdc0
	ctx.lr = 0x826ABC30;
	sub_825ABDC0(ctx, base);
	// 826ABC30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC34: 487477F5  bl 0x82df3428
	ctx.lr = 0x826ABC38;
	sub_82DF3428(ctx, base);
	// 826ABC38: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC40: 388B1314  addi r4, r11, 0x1314
	ctx.r[4].s64 = ctx.r[11].s64 + 4884;
	// 826ABC44: 48747DC5  bl 0x82df3a08
	ctx.lr = 0x826ABC48;
	sub_82DF3A08(ctx, base);
	// 826ABC48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABC4C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826ABC50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABC54: 4BF0016D  bl 0x825abdc0
	ctx.lr = 0x826ABC58;
	sub_825ABDC0(ctx, base);
	// 826ABC58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC5C: 487477CD  bl 0x82df3428
	ctx.lr = 0x826ABC60;
	sub_82DF3428(ctx, base);
	// 826ABC60: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC68: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826ABC6C: 48747D9D  bl 0x82df3a08
	ctx.lr = 0x826ABC70;
	sub_82DF3A08(ctx, base);
	// 826ABC70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABC74: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826ABC78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABC7C: 4BF00145  bl 0x825abdc0
	ctx.lr = 0x826ABC80;
	sub_825ABDC0(ctx, base);
	// 826ABC80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC84: 487477A5  bl 0x82df3428
	ctx.lr = 0x826ABC88;
	sub_82DF3428(ctx, base);
	// 826ABC88: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABC8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABC90: 388B12F8  addi r4, r11, 0x12f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4856;
	// 826ABC94: 48747D75  bl 0x82df3a08
	ctx.lr = 0x826ABC98;
	sub_82DF3A08(ctx, base);
	// 826ABC98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABC9C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826ABCA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABCA4: 4BF0011D  bl 0x825abdc0
	ctx.lr = 0x826ABCA8;
	sub_825ABDC0(ctx, base);
	// 826ABCA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABCAC: 4874777D  bl 0x82df3428
	ctx.lr = 0x826ABCB0;
	sub_82DF3428(ctx, base);
	// 826ABCB0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABCB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABCB8: 388B12EC  addi r4, r11, 0x12ec
	ctx.r[4].s64 = ctx.r[11].s64 + 4844;
	// 826ABCBC: 48747D4D  bl 0x82df3a08
	ctx.lr = 0x826ABCC0;
	sub_82DF3A08(ctx, base);
	// 826ABCC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABCC4: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 826ABCC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABCCC: 4BF000F5  bl 0x825abdc0
	ctx.lr = 0x826ABCD0;
	sub_825ABDC0(ctx, base);
	// 826ABCD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABCD4: 48747755  bl 0x82df3428
	ctx.lr = 0x826ABCD8;
	sub_82DF3428(ctx, base);
	// 826ABCD8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABCDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABCE0: 388B12D4  addi r4, r11, 0x12d4
	ctx.r[4].s64 = ctx.r[11].s64 + 4820;
	// 826ABCE4: 48747D25  bl 0x82df3a08
	ctx.lr = 0x826ABCE8;
	sub_82DF3A08(ctx, base);
	// 826ABCE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABCEC: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 826ABCF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABCF4: 4BF000CD  bl 0x825abdc0
	ctx.lr = 0x826ABCF8;
	sub_825ABDC0(ctx, base);
	// 826ABCF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABCFC: 4874772D  bl 0x82df3428
	ctx.lr = 0x826ABD00;
	sub_82DF3428(ctx, base);
	// 826ABD00: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABD04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABD08: 388BC55C  addi r4, r11, -0x3aa4
	ctx.r[4].s64 = ctx.r[11].s64 + -15012;
	// 826ABD0C: 48747CFD  bl 0x82df3a08
	ctx.lr = 0x826ABD10;
	sub_82DF3A08(ctx, base);
	// 826ABD10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ABD14: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 826ABD18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ABD1C: 4BF000A5  bl 0x825abdc0
	ctx.lr = 0x826ABD20;
	sub_825ABDC0(ctx, base);
	// 826ABD20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABD24: 48747705  bl 0x82df3428
	ctx.lr = 0x826ABD28;
	sub_82DF3428(ctx, base);
	// 826ABD28: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826ABD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABD30: 388B4A98  addi r4, r11, 0x4a98
	ctx.r[4].s64 = ctx.r[11].s64 + 19096;
	// 826ABD34: 48747CD5  bl 0x82df3a08
	ctx.lr = 0x826ABD38;
	sub_82DF3A08(ctx, base);
	// 826ABD38: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826ABD3C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 826ABD40: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826ABD44: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 826ABD48: 419A0024  beq cr6, 0x826abd6c
	if ctx.cr[6].eq {
	pc = 0x826ABD6C; continue 'dispatch;
	}
	// 826ABD4C: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 826ABD50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826ABD54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ABD58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826ABD5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826ABD60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826ABD64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ABD68: 4082FFE8  bne 0x826abd50
	if !ctx.cr[0].eq {
	pc = 0x826ABD50; continue 'dispatch;
	}
	// 826ABD6C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826ABD70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABD74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ABD78: 4BEF6399  bl 0x825a2110
	ctx.lr = 0x826ABD7C;
	sub_825A2110(ctx, base);
	// 826ABD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABD80: 487476A9  bl 0x82df3428
	ctx.lr = 0x826ABD84;
	sub_82DF3428(ctx, base);
	// 826ABD84: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABD88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABD8C: 388BD2E0  addi r4, r11, -0x2d20
	ctx.r[4].s64 = ctx.r[11].s64 + -11552;
	// 826ABD90: 48747C79  bl 0x82df3a08
	ctx.lr = 0x826ABD94;
	sub_82DF3A08(ctx, base);
	// 826ABD94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ABD98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABD9C: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826ABDA0: 48747C69  bl 0x82df3a08
	ctx.lr = 0x826ABDA4;
	sub_82DF3A08(ctx, base);
	// 826ABDA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826ABDA8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826ABDAC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826ABDB0: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 826ABDB4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ABDB8: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826ABDBC: 386103D0  addi r3, r1, 0x3d0
	ctx.r[3].s64 = ctx.r[1].s64 + 976;
	// 826ABDC0: C38A6218  lfs f28, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826ABDC4: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826ABDC8: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826ABDCC: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 826ABDD0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ABDD4: 4BEF74D5  bl 0x825a32a8
	ctx.lr = 0x826ABDD8;
	sub_825A32A8(ctx, base);
	// 826ABDD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ABDDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABDE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ABDE4: 4BEF598D  bl 0x825a1770
	ctx.lr = 0x826ABDE8;
	sub_825A1770(ctx, base);
	// 826ABDE8: 38610408  addi r3, r1, 0x408
	ctx.r[3].s64 = ctx.r[1].s64 + 1032;
	// 826ABDEC: 4874763D  bl 0x82df3428
	ctx.lr = 0x826ABDF0;
	sub_82DF3428(ctx, base);
	// 826ABDF0: 386103E8  addi r3, r1, 0x3e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1000;
	// 826ABDF4: 4BC1CEC5  bl 0x822c8cb8
	ctx.lr = 0x826ABDF8;
	sub_822C8CB8(ctx, base);
	// 826ABDF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABDFC: 4874762D  bl 0x82df3428
	ctx.lr = 0x826ABE00;
	sub_82DF3428(ctx, base);
	// 826ABE00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABE04: 48747625  bl 0x82df3428
	ctx.lr = 0x826ABE08;
	sub_82DF3428(ctx, base);
	// 826ABE08: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABE0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABE10: 388BC4D4  addi r4, r11, -0x3b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -15148;
	// 826ABE14: 48747BF5  bl 0x82df3a08
	ctx.lr = 0x826ABE18;
	sub_82DF3A08(ctx, base);
	// 826ABE18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ABE1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABE20: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 826ABE24: 48747BE5  bl 0x82df3a08
	ctx.lr = 0x826ABE28;
	sub_82DF3A08(ctx, base);
	// 826ABE28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ABE2C: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 826ABE30: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826ABE34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABE38: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ABE3C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 826ABE40: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826ABE44: 4BEF7465  bl 0x825a32a8
	ctx.lr = 0x826ABE48;
	sub_825A32A8(ctx, base);
	// 826ABE48: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ABE4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ABE50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ABE54: 4BEF591D  bl 0x825a1770
	ctx.lr = 0x826ABE58;
	sub_825A1770(ctx, base);
	// 826ABE58: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 826ABE5C: 487475CD  bl 0x82df3428
	ctx.lr = 0x826ABE60;
	sub_82DF3428(ctx, base);
	// 826ABE60: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826ABE64: 4BC1CE55  bl 0x822c8cb8
	ctx.lr = 0x826ABE68;
	sub_822C8CB8(ctx, base);
	// 826ABE68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABE6C: 487475BD  bl 0x82df3428
	ctx.lr = 0x826ABE70;
	sub_82DF3428(ctx, base);
	// 826ABE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABE74: 487475B5  bl 0x82df3428
	ctx.lr = 0x826ABE78;
	sub_82DF3428(ctx, base);
	// 826ABE78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ABE7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABE80: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826ABE84: 48747B85  bl 0x82df3a08
	ctx.lr = 0x826ABE88;
	sub_82DF3A08(ctx, base);
	// 826ABE88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ABE8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABE90: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826ABE94: 48747B75  bl 0x82df3a08
	ctx.lr = 0x826ABE98;
	sub_82DF3A08(ctx, base);
	// 826ABE98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 826ABE9C: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 826ABEA0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826ABEA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABEA8: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 826ABEAC: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826ABEB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ABEB4: 4BEF73F5  bl 0x825a32a8
	ctx.lr = 0x826ABEB8;
	sub_825A32A8(ctx, base);
	// 826ABEB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ABEBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ABEC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ABEC4: 4BEF58AD  bl 0x825a1770
	ctx.lr = 0x826ABEC8;
	sub_825A1770(ctx, base);
	// 826ABEC8: 38610308  addi r3, r1, 0x308
	ctx.r[3].s64 = ctx.r[1].s64 + 776;
	// 826ABECC: 4874755D  bl 0x82df3428
	ctx.lr = 0x826ABED0;
	sub_82DF3428(ctx, base);
	// 826ABED0: 386102E8  addi r3, r1, 0x2e8
	ctx.r[3].s64 = ctx.r[1].s64 + 744;
	// 826ABED4: 4BC1CDE5  bl 0x822c8cb8
	ctx.lr = 0x826ABED8;
	sub_822C8CB8(ctx, base);
	// 826ABED8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABEDC: 4874754D  bl 0x82df3428
	ctx.lr = 0x826ABEE0;
	sub_82DF3428(ctx, base);
	// 826ABEE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABEE4: 48747545  bl 0x82df3428
	ctx.lr = 0x826ABEE8;
	sub_82DF3428(ctx, base);
	// 826ABEE8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABEEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABEF0: 388BF3F8  addi r4, r11, -0xc08
	ctx.r[4].s64 = ctx.r[11].s64 + -3080;
	// 826ABEF4: 48747B15  bl 0x82df3a08
	ctx.lr = 0x826ABEF8;
	sub_82DF3A08(ctx, base);
	// 826ABEF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ABEFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABF00: 388B4370  addi r4, r11, 0x4370
	ctx.r[4].s64 = ctx.r[11].s64 + 17264;
	// 826ABF04: 48747B05  bl 0x82df3a08
	ctx.lr = 0x826ABF08;
	sub_82DF3A08(ctx, base);
	// 826ABF08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826ABF0C: 38BF0074  addi r5, r31, 0x74
	ctx.r[5].s64 = ctx.r[31].s64 + 116;
	// 826ABF10: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ABF14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABF18: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826ABF1C: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 826ABF20: C3AB9A8C  lfs f29, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826ABF24: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826ABF28: 4BEF7381  bl 0x825a32a8
	ctx.lr = 0x826ABF2C;
	sub_825A32A8(ctx, base);
	// 826ABF2C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ABF30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ABF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ABF38: 4BEF5839  bl 0x825a1770
	ctx.lr = 0x826ABF3C;
	sub_825A1770(ctx, base);
	// 826ABF3C: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 826ABF40: 487474E9  bl 0x82df3428
	ctx.lr = 0x826ABF44;
	sub_82DF3428(ctx, base);
	// 826ABF44: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 826ABF48: 4BC1CD71  bl 0x822c8cb8
	ctx.lr = 0x826ABF4C;
	sub_822C8CB8(ctx, base);
	// 826ABF4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABF50: 487474D9  bl 0x82df3428
	ctx.lr = 0x826ABF54;
	sub_82DF3428(ctx, base);
	// 826ABF54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABF58: 487474D1  bl 0x82df3428
	ctx.lr = 0x826ABF5C;
	sub_82DF3428(ctx, base);
	// 826ABF5C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABF60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABF64: 388B12C8  addi r4, r11, 0x12c8
	ctx.r[4].s64 = ctx.r[11].s64 + 4808;
	// 826ABF68: 48747AA1  bl 0x82df3a08
	ctx.lr = 0x826ABF6C;
	sub_82DF3A08(ctx, base);
	// 826ABF6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABF70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABF74: 388BD2D0  addi r4, r11, -0x2d30
	ctx.r[4].s64 = ctx.r[11].s64 + -11568;
	// 826ABF78: 48747A91  bl 0x82df3a08
	ctx.lr = 0x826ABF7C;
	sub_82DF3A08(ctx, base);
	// 826ABF7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826ABF80: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826ABF84: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ABF88: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 826ABF8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABF90: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826ABF94: C06B08A8  lfs f3, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826ABF98: C04AD200  lfs f2, -0x2e00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826ABF9C: 4BEF730D  bl 0x825a32a8
	ctx.lr = 0x826ABFA0;
	sub_825A32A8(ctx, base);
	// 826ABFA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ABFA4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ABFA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ABFAC: 4BEF57C5  bl 0x825a1770
	ctx.lr = 0x826ABFB0;
	sub_825A1770(ctx, base);
	// 826ABFB0: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826ABFB4: 48747475  bl 0x82df3428
	ctx.lr = 0x826ABFB8;
	sub_82DF3428(ctx, base);
	// 826ABFB8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826ABFBC: 4BC1CCFD  bl 0x822c8cb8
	ctx.lr = 0x826ABFC0;
	sub_822C8CB8(ctx, base);
	// 826ABFC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABFC4: 48747465  bl 0x82df3428
	ctx.lr = 0x826ABFC8;
	sub_82DF3428(ctx, base);
	// 826ABFC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABFCC: 4874745D  bl 0x82df3428
	ctx.lr = 0x826ABFD0;
	sub_82DF3428(ctx, base);
	// 826ABFD0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABFD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ABFD8: 388BC50C  addi r4, r11, -0x3af4
	ctx.r[4].s64 = ctx.r[11].s64 + -15092;
	// 826ABFDC: 48747A2D  bl 0x82df3a08
	ctx.lr = 0x826ABFE0;
	sub_82DF3A08(ctx, base);
	// 826ABFE0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ABFE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ABFE8: 388B1160  addi r4, r11, 0x1160
	ctx.r[4].s64 = ctx.r[11].s64 + 4448;
	// 826ABFEC: 48747A1D  bl 0x82df3a08
	ctx.lr = 0x826ABFF0;
	sub_82DF3A08(ctx, base);
	// 826ABFF0: 38BF007C  addi r5, r31, 0x7c
	ctx.r[5].s64 = ctx.r[31].s64 + 124;
	// 826ABFF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ABFF8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826ABFFC: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 826AC000: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826AC004: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AC008: 4BEF72A1  bl 0x825a32a8
	ctx.lr = 0x826AC00C;
	sub_825A32A8(ctx, base);
	// 826AC00C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC010: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC018: 4BEF5759  bl 0x825a1770
	ctx.lr = 0x826AC01C;
	sub_825A1770(ctx, base);
	// 826AC01C: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 826AC020: 48747409  bl 0x82df3428
	ctx.lr = 0x826AC024;
	sub_82DF3428(ctx, base);
	// 826AC024: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 826AC028: 4BC1CC91  bl 0x822c8cb8
	ctx.lr = 0x826AC02C;
	sub_822C8CB8(ctx, base);
	// 826AC02C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC030: 487473F9  bl 0x82df3428
	ctx.lr = 0x826AC034;
	sub_82DF3428(ctx, base);
	// 826AC034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC038: 487473F1  bl 0x82df3428
	ctx.lr = 0x826AC03C;
	sub_82DF3428(ctx, base);
	// 826AC03C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC044: 388B12BC  addi r4, r11, 0x12bc
	ctx.r[4].s64 = ctx.r[11].s64 + 4796;
	// 826AC048: 487479C1  bl 0x82df3a08
	ctx.lr = 0x826AC04C;
	sub_82DF3A08(ctx, base);
	// 826AC04C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC054: 388B1154  addi r4, r11, 0x1154
	ctx.r[4].s64 = ctx.r[11].s64 + 4436;
	// 826AC058: 487479B1  bl 0x82df3a08
	ctx.lr = 0x826AC05C;
	sub_82DF3A08(ctx, base);
	// 826AC05C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826AC060: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826AC064: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AC068: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 826AC06C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC070: 38610350  addi r3, r1, 0x350
	ctx.r[3].s64 = ctx.r[1].s64 + 848;
	// 826AC074: 4BEF73A5  bl 0x825a3418
	ctx.lr = 0x826AC078;
	sub_825A3418(ctx, base);
	// 826AC078: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC07C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC084: 4BEF5E55  bl 0x825a1ed8
	ctx.lr = 0x826AC088;
	sub_825A1ED8(ctx, base);
	// 826AC088: 38610388  addi r3, r1, 0x388
	ctx.r[3].s64 = ctx.r[1].s64 + 904;
	// 826AC08C: 4874739D  bl 0x82df3428
	ctx.lr = 0x826AC090;
	sub_82DF3428(ctx, base);
	// 826AC090: 38610368  addi r3, r1, 0x368
	ctx.r[3].s64 = ctx.r[1].s64 + 872;
	// 826AC094: 4BC1CC25  bl 0x822c8cb8
	ctx.lr = 0x826AC098;
	sub_822C8CB8(ctx, base);
	// 826AC098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC09C: 4874738D  bl 0x82df3428
	ctx.lr = 0x826AC0A0;
	sub_82DF3428(ctx, base);
	// 826AC0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC0A4: 48747385  bl 0x82df3428
	ctx.lr = 0x826AC0A8;
	sub_82DF3428(ctx, base);
	// 826AC0A8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC0AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC0B0: 388B21F0  addi r4, r11, 0x21f0
	ctx.r[4].s64 = ctx.r[11].s64 + 8688;
	// 826AC0B4: 48747955  bl 0x82df3a08
	ctx.lr = 0x826AC0B8;
	sub_82DF3A08(ctx, base);
	// 826AC0B8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC0BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC0C0: 388BC3A4  addi r4, r11, -0x3c5c
	ctx.r[4].s64 = ctx.r[11].s64 + -15452;
	// 826AC0C4: 48747945  bl 0x82df3a08
	ctx.lr = 0x826AC0C8;
	sub_82DF3A08(ctx, base);
	// 826AC0C8: 38BF00D8  addi r5, r31, 0xd8
	ctx.r[5].s64 = ctx.r[31].s64 + 216;
	// 826AC0CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC0D0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826AC0D4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826AC0D8: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826AC0DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AC0E0: 4BEF71C9  bl 0x825a32a8
	ctx.lr = 0x826AC0E4;
	sub_825A32A8(ctx, base);
	// 826AC0E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC0E8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC0EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC0F0: 4BEF5681  bl 0x825a1770
	ctx.lr = 0x826AC0F4;
	sub_825A1770(ctx, base);
	// 826AC0F4: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826AC0F8: 48747331  bl 0x82df3428
	ctx.lr = 0x826AC0FC;
	sub_82DF3428(ctx, base);
	// 826AC0FC: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826AC100: 4BC1CBB9  bl 0x822c8cb8
	ctx.lr = 0x826AC104;
	sub_822C8CB8(ctx, base);
	// 826AC104: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC108: 48747321  bl 0x82df3428
	ctx.lr = 0x826AC10C;
	sub_82DF3428(ctx, base);
	// 826AC10C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC110: 48747319  bl 0x82df3428
	ctx.lr = 0x826AC114;
	sub_82DF3428(ctx, base);
	// 826AC114: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC11C: 388BC51C  addi r4, r11, -0x3ae4
	ctx.r[4].s64 = ctx.r[11].s64 + -15076;
	// 826AC120: 487478E9  bl 0x82df3a08
	ctx.lr = 0x826AC124;
	sub_82DF3A08(ctx, base);
	// 826AC124: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AC128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC12C: 388BF800  addi r4, r11, -0x800
	ctx.r[4].s64 = ctx.r[11].s64 + -2048;
	// 826AC130: 487478D9  bl 0x82df3a08
	ctx.lr = 0x826AC134;
	sub_82DF3A08(ctx, base);
	// 826AC134: 38BF00DC  addi r5, r31, 0xdc
	ctx.r[5].s64 = ctx.r[31].s64 + 220;
	// 826AC138: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC13C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826AC140: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 826AC144: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826AC148: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AC14C: 4BEF715D  bl 0x825a32a8
	ctx.lr = 0x826AC150;
	sub_825A32A8(ctx, base);
	// 826AC150: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC154: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC15C: 4BEF5615  bl 0x825a1770
	ctx.lr = 0x826AC160;
	sub_825A1770(ctx, base);
	// 826AC160: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 826AC164: 487472C5  bl 0x82df3428
	ctx.lr = 0x826AC168;
	sub_82DF3428(ctx, base);
	// 826AC168: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 826AC16C: 4BC1CB4D  bl 0x822c8cb8
	ctx.lr = 0x826AC170;
	sub_822C8CB8(ctx, base);
	// 826AC170: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC174: 487472B5  bl 0x82df3428
	ctx.lr = 0x826AC178;
	sub_82DF3428(ctx, base);
	// 826AC178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC17C: 487472AD  bl 0x82df3428
	ctx.lr = 0x826AC180;
	sub_82DF3428(ctx, base);
	// 826AC180: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AC184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC188: 388BE0C0  addi r4, r11, -0x1f40
	ctx.r[4].s64 = ctx.r[11].s64 + -8000;
	// 826AC18C: 4874787D  bl 0x82df3a08
	ctx.lr = 0x826AC190;
	sub_82DF3A08(ctx, base);
	// 826AC190: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AC194: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC198: 388BE0B8  addi r4, r11, -0x1f48
	ctx.r[4].s64 = ctx.r[11].s64 + -8008;
	// 826AC19C: 4874786D  bl 0x82df3a08
	ctx.lr = 0x826AC1A0;
	sub_82DF3A08(ctx, base);
	// 826AC1A0: 38BF00E0  addi r5, r31, 0xe0
	ctx.r[5].s64 = ctx.r[31].s64 + 224;
	// 826AC1A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC1A8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826AC1AC: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 826AC1B0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826AC1B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AC1B8: 4BEF70F1  bl 0x825a32a8
	ctx.lr = 0x826AC1BC;
	sub_825A32A8(ctx, base);
	// 826AC1BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC1C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC1C8: 4BEF55A9  bl 0x825a1770
	ctx.lr = 0x826AC1CC;
	sub_825A1770(ctx, base);
	// 826AC1CC: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 826AC1D0: 48747259  bl 0x82df3428
	ctx.lr = 0x826AC1D4;
	sub_82DF3428(ctx, base);
	// 826AC1D4: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 826AC1D8: 4BC1CAE1  bl 0x822c8cb8
	ctx.lr = 0x826AC1DC;
	sub_822C8CB8(ctx, base);
	// 826AC1DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC1E0: 48747249  bl 0x82df3428
	ctx.lr = 0x826AC1E4;
	sub_82DF3428(ctx, base);
	// 826AC1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC1E8: 48747241  bl 0x82df3428
	ctx.lr = 0x826AC1EC;
	sub_82DF3428(ctx, base);
	// 826AC1EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AC1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC1F4: 388B4164  addi r4, r11, 0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + 16740;
	// 826AC1F8: 48747811  bl 0x82df3a08
	ctx.lr = 0x826AC1FC;
	sub_82DF3A08(ctx, base);
	// 826AC1FC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC200: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC204: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 826AC208: 48747801  bl 0x82df3a08
	ctx.lr = 0x826AC20C;
	sub_82DF3A08(ctx, base);
	// 826AC20C: 38BF0084  addi r5, r31, 0x84
	ctx.r[5].s64 = ctx.r[31].s64 + 132;
	// 826AC210: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC214: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AC218: 4BEF6E39  bl 0x825a3050
	ctx.lr = 0x826AC21C;
	sub_825A3050(ctx, base);
	// 826AC21C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC220: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC228: 4BEF5F61  bl 0x825a2188
	ctx.lr = 0x826AC22C;
	sub_825A2188(ctx, base);
	// 826AC22C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826AC230: 487471F9  bl 0x82df3428
	ctx.lr = 0x826AC234;
	sub_82DF3428(ctx, base);
	// 826AC234: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826AC238: 4BC1CA81  bl 0x822c8cb8
	ctx.lr = 0x826AC23C;
	sub_822C8CB8(ctx, base);
	// 826AC23C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC240: 487471E9  bl 0x82df3428
	ctx.lr = 0x826AC244;
	sub_82DF3428(ctx, base);
	// 826AC244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC248: 487471E1  bl 0x82df3428
	ctx.lr = 0x826AC24C;
	sub_82DF3428(ctx, base);
	// 826AC24C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AC250: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AC254: 38A00194  li r5, 0x194
	ctx.r[5].s64 = 404;
	// 826AC258: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826AC25C: 4BC1417D  bl 0x822c03d8
	ctx.lr = 0x826AC260;
	sub_822C03D8(ctx, base);
	// 826AC260: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AC264: 41820034  beq 0x826ac298
	if ctx.cr[0].eq {
	pc = 0x826AC298; continue 'dispatch;
	}
	// 826AC268: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC270: 388B12AC  addi r4, r11, 0x12ac
	ctx.r[4].s64 = ctx.r[11].s64 + 4780;
	// 826AC274: 48747795  bl 0x82df3a08
	ctx.lr = 0x826AC278;
	sub_82DF3A08(ctx, base);
	// 826AC278: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 826AC27C: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 826AC280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC284: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AC288: 639C0002  ori r28, r28, 2
	ctx.r[28].u64 = ctx.r[28].u64 | 2;
	// 826AC28C: 4BEFDD9D  bl 0x825aa028
	ctx.lr = 0x826AC290;
	sub_825AA028(ctx, base);
	// 826AC290: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826AC294: 48000008  b 0x826ac29c
	pc = 0x826AC29C; continue 'dispatch;
	// 826AC298: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 826AC29C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC2A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC2A4: 388B114C  addi r4, r11, 0x114c
	ctx.r[4].s64 = ctx.r[11].s64 + 4428;
	// 826AC2A8: 48747761  bl 0x82df3a08
	ctx.lr = 0x826AC2AC;
	sub_82DF3A08(ctx, base);
	// 826AC2AC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826AC2B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AC2B4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826AC2B8: 4BEFB469  bl 0x825a7720
	ctx.lr = 0x826AC2BC;
	sub_825A7720(ctx, base);
	// 826AC2BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826AC2C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AC2C4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826AC2C8: 4BC13D39  bl 0x822c0000
	ctx.lr = 0x826AC2CC;
	sub_822C0000(ctx, base);
	// 826AC2CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826AC2D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC2D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC2D8: 4BEF5E39  bl 0x825a2110
	ctx.lr = 0x826AC2DC;
	sub_825A2110(ctx, base);
	// 826AC2DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC2E0: 48747149  bl 0x82df3428
	ctx.lr = 0x826AC2E4;
	sub_82DF3428(ctx, base);
	// 826AC2E4: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AC2E8: 4182000C  beq 0x826ac2f4
	if ctx.cr[0].eq {
	pc = 0x826AC2F4; continue 'dispatch;
	}
	// 826AC2EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC2F0: 48747139  bl 0x82df3428
	ctx.lr = 0x826AC2F4;
	sub_82DF3428(ctx, base);
	// 826AC2F4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC2F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC2FC: 388B1298  addi r4, r11, 0x1298
	ctx.r[4].s64 = ctx.r[11].s64 + 4760;
	// 826AC300: 48747709  bl 0x82df3a08
	ctx.lr = 0x826AC304;
	sub_82DF3A08(ctx, base);
	// 826AC304: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC308: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC30C: 388B113C  addi r4, r11, 0x113c
	ctx.r[4].s64 = ctx.r[11].s64 + 4412;
	// 826AC310: 487476F9  bl 0x82df3a08
	ctx.lr = 0x826AC314;
	sub_82DF3A08(ctx, base);
	// 826AC314: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826AC318: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826AC31C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AC320: 38BF008C  addi r5, r31, 0x8c
	ctx.r[5].s64 = ctx.r[31].s64 + 140;
	// 826AC324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC328: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 826AC32C: 4BF01865  bl 0x825adb90
	ctx.lr = 0x826AC330;
	sub_825ADB90(ctx, base);
	// 826AC330: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC334: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC33C: 4BEF5A7D  bl 0x825a1db8
	ctx.lr = 0x826AC340;
	sub_825A1DB8(ctx, base);
	// 826AC340: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 826AC344: 487470E5  bl 0x82df3428
	ctx.lr = 0x826AC348;
	sub_82DF3428(ctx, base);
	// 826AC348: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 826AC34C: 4BC1C96D  bl 0x822c8cb8
	ctx.lr = 0x826AC350;
	sub_822C8CB8(ctx, base);
	// 826AC350: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC354: 487470D5  bl 0x82df3428
	ctx.lr = 0x826AC358;
	sub_82DF3428(ctx, base);
	// 826AC358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC35C: 487470CD  bl 0x82df3428
	ctx.lr = 0x826AC360;
	sub_82DF3428(ctx, base);
	// 826AC360: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC364: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC368: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 826AC36C: 4874769D  bl 0x82df3a08
	ctx.lr = 0x826AC370;
	sub_82DF3A08(ctx, base);
	// 826AC370: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC374: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC378: 388B18B4  addi r4, r11, 0x18b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6324;
	// 826AC37C: 4874768D  bl 0x82df3a08
	ctx.lr = 0x826AC380;
	sub_82DF3A08(ctx, base);
	// 826AC380: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 826AC384: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC388: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826AC38C: 4BEF6CC5  bl 0x825a3050
	ctx.lr = 0x826AC390;
	sub_825A3050(ctx, base);
	// 826AC390: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC394: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC39C: 4BEF5DED  bl 0x825a2188
	ctx.lr = 0x826AC3A0;
	sub_825A2188(ctx, base);
	// 826AC3A0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826AC3A4: 48747085  bl 0x82df3428
	ctx.lr = 0x826AC3A8;
	sub_82DF3428(ctx, base);
	// 826AC3A8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826AC3AC: 4BC1C90D  bl 0x822c8cb8
	ctx.lr = 0x826AC3B0;
	sub_822C8CB8(ctx, base);
	// 826AC3B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC3B4: 48747075  bl 0x82df3428
	ctx.lr = 0x826AC3B8;
	sub_82DF3428(ctx, base);
	// 826AC3B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC3BC: 4874706D  bl 0x82df3428
	ctx.lr = 0x826AC3C0;
	sub_82DF3428(ctx, base);
	// 826AC3C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AC3C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC3C8: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826AC3CC: 4874763D  bl 0x82df3a08
	ctx.lr = 0x826AC3D0;
	sub_82DF3A08(ctx, base);
	// 826AC3D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC3D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC3D8: 388B18A4  addi r4, r11, 0x18a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6308;
	// 826AC3DC: 4874762D  bl 0x82df3a08
	ctx.lr = 0x826AC3E0;
	sub_82DF3A08(ctx, base);
	// 826AC3E0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826AC3E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826AC3E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AC3EC: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 826AC3F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC3F4: 38610310  addi r3, r1, 0x310
	ctx.r[3].s64 = ctx.r[1].s64 + 784;
	// 826AC3F8: 4BEF7021  bl 0x825a3418
	ctx.lr = 0x826AC3FC;
	sub_825A3418(ctx, base);
	// 826AC3FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC400: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC408: 4BEF5AD1  bl 0x825a1ed8
	ctx.lr = 0x826AC40C;
	sub_825A1ED8(ctx, base);
	// 826AC40C: 38610348  addi r3, r1, 0x348
	ctx.r[3].s64 = ctx.r[1].s64 + 840;
	// 826AC410: 48747019  bl 0x82df3428
	ctx.lr = 0x826AC414;
	sub_82DF3428(ctx, base);
	// 826AC414: 38610328  addi r3, r1, 0x328
	ctx.r[3].s64 = ctx.r[1].s64 + 808;
	// 826AC418: 4BC1C8A1  bl 0x822c8cb8
	ctx.lr = 0x826AC41C;
	sub_822C8CB8(ctx, base);
	// 826AC41C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC420: 48747009  bl 0x82df3428
	ctx.lr = 0x826AC424;
	sub_82DF3428(ctx, base);
	// 826AC424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC428: 48747001  bl 0x82df3428
	ctx.lr = 0x826AC42C;
	sub_82DF3428(ctx, base);
	// 826AC42C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AC430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC434: 388B2BF0  addi r4, r11, 0x2bf0
	ctx.r[4].s64 = ctx.r[11].s64 + 11248;
	// 826AC438: 487475D1  bl 0x82df3a08
	ctx.lr = 0x826AC43C;
	sub_82DF3A08(ctx, base);
	// 826AC43C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC440: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC444: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 826AC448: 487475C1  bl 0x82df3a08
	ctx.lr = 0x826AC44C;
	sub_82DF3A08(ctx, base);
	// 826AC44C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AC450: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826AC454: FC40E090  fmr f2, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[28].f64;
	// 826AC458: 38BF00D0  addi r5, r31, 0xd0
	ctx.r[5].s64 = ctx.r[31].s64 + 208;
	// 826AC45C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC460: 38610390  addi r3, r1, 0x390
	ctx.r[3].s64 = ctx.r[1].s64 + 912;
	// 826AC464: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826AC468: C02A0790  lfs f1, 0x790(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AC46C: 4BF0164D  bl 0x825adab8
	ctx.lr = 0x826AC470;
	sub_825ADAB8(ctx, base);
	// 826AC470: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC474: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC47C: 4BEF51D5  bl 0x825a1650
	ctx.lr = 0x826AC480;
	sub_825A1650(ctx, base);
	// 826AC480: 386103C8  addi r3, r1, 0x3c8
	ctx.r[3].s64 = ctx.r[1].s64 + 968;
	// 826AC484: 48746FA5  bl 0x82df3428
	ctx.lr = 0x826AC488;
	sub_82DF3428(ctx, base);
	// 826AC488: 386103A8  addi r3, r1, 0x3a8
	ctx.r[3].s64 = ctx.r[1].s64 + 936;
	// 826AC48C: 4BC1C82D  bl 0x822c8cb8
	ctx.lr = 0x826AC490;
	sub_822C8CB8(ctx, base);
	// 826AC490: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC494: 48746F95  bl 0x82df3428
	ctx.lr = 0x826AC498;
	sub_82DF3428(ctx, base);
	// 826AC498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC49C: 48746F8D  bl 0x82df3428
	ctx.lr = 0x826AC4A0;
	sub_82DF3428(ctx, base);
	// 826AC4A0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC4A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC4A8: 388BD2B4  addi r4, r11, -0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11596;
	// 826AC4AC: 4874755D  bl 0x82df3a08
	ctx.lr = 0x826AC4B0;
	sub_82DF3A08(ctx, base);
	// 826AC4B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC4B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC4B8: 388BA13C  addi r4, r11, -0x5ec4
	ctx.r[4].s64 = ctx.r[11].s64 + -24260;
	// 826AC4BC: 4874754D  bl 0x82df3a08
	ctx.lr = 0x826AC4C0;
	sub_82DF3A08(ctx, base);
	// 826AC4C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AC4C4: 38BF00D4  addi r5, r31, 0xd4
	ctx.r[5].s64 = ctx.r[31].s64 + 212;
	// 826AC4C8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826AC4CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AC4D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AC4D4: 38610410  addi r3, r1, 0x410
	ctx.r[3].s64 = ctx.r[1].s64 + 1040;
	// 826AC4D8: C04B9584  lfs f2, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826AC4DC: 4BF015DD  bl 0x825adab8
	ctx.lr = 0x826AC4E0;
	sub_825ADAB8(ctx, base);
	// 826AC4E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AC4E4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AC4E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC4EC: 4BEF5165  bl 0x825a1650
	ctx.lr = 0x826AC4F0;
	sub_825A1650(ctx, base);
	// 826AC4F0: 38610448  addi r3, r1, 0x448
	ctx.r[3].s64 = ctx.r[1].s64 + 1096;
	// 826AC4F4: 48746F35  bl 0x82df3428
	ctx.lr = 0x826AC4F8;
	sub_82DF3428(ctx, base);
	// 826AC4F8: 38610428  addi r3, r1, 0x428
	ctx.r[3].s64 = ctx.r[1].s64 + 1064;
	// 826AC4FC: 4BC1C7BD  bl 0x822c8cb8
	ctx.lr = 0x826AC500;
	sub_822C8CB8(ctx, base);
	// 826AC500: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC504: 48746F25  bl 0x82df3428
	ctx.lr = 0x826AC508;
	sub_82DF3428(ctx, base);
	// 826AC508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AC50C: 48746F1D  bl 0x82df3428
	ctx.lr = 0x826AC510;
	sub_82DF3428(ctx, base);
	// 826AC510: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826AC514: 419A000C  beq cr6, 0x826ac520
	if ctx.cr[6].eq {
	pc = 0x826AC520; continue 'dispatch;
	}
	// 826AC518: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826AC51C: 4BC14375  bl 0x822c0890
	ctx.lr = 0x826AC520;
	sub_822C0890(ctx, base);
	// 826AC520: 382104B0  addi r1, r1, 0x4b0
	ctx.r[1].s64 = ctx.r[1].s64 + 1200;
	// 826AC524: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 826AC528: 48AFC59D  bl 0x831a8ac4
	ctx.lr = 0x826AC52C;
	sub_831A8A8C(ctx, base);
	// 826AC52C: 48AFBC80  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AC530 size=472
    let mut pc: u32 = 0x826AC530;
    'dispatch: loop {
        match pc {
            0x826AC530 => {
    //   block [0x826AC530..0x826AC708)
	// 826AC530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AC538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AC53C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AC540: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826AC544: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC54C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AC554: 4BE62F75  bl 0x8250f4c8
	ctx.lr = 0x826AC558;
	sub_8250F4C8(ctx, base);
	// 826AC558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AC55C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AC560: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826AC564: 409A0008  bne cr6, 0x826ac56c
	if !ctx.cr[6].eq {
	pc = 0x826AC56C; continue 'dispatch;
	}
	// 826AC568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826AC56C: 4BE5BFAD  bl 0x82508518
	ctx.lr = 0x826AC570;
	sub_82508518(ctx, base);
	// 826AC570: C01F010C  lfs f0, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AC574: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AC578: EFE10028  fsubs f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 826AC57C: 48745715  bl 0x82df1c90
	ctx.lr = 0x826AC580;
	sub_82DF1C90(ctx, base);
	// 826AC580: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826AC584: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826AC588: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826AC58C: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 826AC590: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826AC594: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AC708 size=124
    let mut pc: u32 = 0x826AC708;
    'dispatch: loop {
        match pc {
            0x826AC708 => {
    //   block [0x826AC708..0x826AC784)
	// 826AC708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AC710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AC714: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC71C: 4BFFAF05  bl 0x826a7620
	ctx.lr = 0x826AC720;
	sub_826A7620(ctx, base);
	// 826AC720: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 826AC724: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 826AC728: 409A000C  bne cr6, 0x826ac734
	if !ctx.cr[6].eq {
	pc = 0x826AC734; continue 'dispatch;
	}
	// 826AC72C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC730: 4BFFFE01  bl 0x826ac530
	ctx.lr = 0x826AC734;
	sub_826AC530(ctx, base);
	// 826AC734: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826AC738: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826AC73C: 419A0034  beq cr6, 0x826ac770
	if ctx.cr[6].eq {
	pc = 0x826AC770; continue 'dispatch;
	}
	// 826AC740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC744: 4BFF9135  bl 0x826a5878
	ctx.lr = 0x826AC748;
	sub_826A5878(ctx, base);
	// 826AC748: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AC74C: 4182001C  beq 0x826ac768
	if ctx.cr[0].eq {
	pc = 0x826AC768; continue 'dispatch;
	}
	// 826AC750: 897F01AC  lbz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 826AC754: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AC758: 41820010  beq 0x826ac768
	if ctx.cr[0].eq {
	pc = 0x826AC768; continue 'dispatch;
	}
	// 826AC75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC760: 4BFFE8F9  bl 0x826ab058
	ctx.lr = 0x826AC764;
	sub_826AB058(ctx, base);
	// 826AC764: 4800000C  b 0x826ac770
	pc = 0x826AC770; continue 'dispatch;
	// 826AC768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC76C: 4BFFE525  bl 0x826aac90
	ctx.lr = 0x826AC770;
	sub_826AAC90(ctx, base);
	// 826AC770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AC774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AC778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AC77C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AC780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AC788 size=432
    let mut pc: u32 = 0x826AC788;
    'dispatch: loop {
        match pc {
            0x826AC788 => {
    //   block [0x826AC788..0x826AC938)
	// 826AC788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC78C: 48AFB9D9  bl 0x831a8164
	ctx.lr = 0x826AC790;
	sub_831A8130(ctx, base);
	// 826AC790: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC794: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AC798: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826AC79C: 3BCB2198  addi r30, r11, 0x2198
	ctx.r[30].s64 = ctx.r[11].s64 + 8600;
	// 826AC7A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AC7A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826AC7A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AC7AC: 38A0009D  li r5, 0x9d
	ctx.r[5].s64 = 157;
	// 826AC7B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826AC7B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AC7B8: 386001D0  li r3, 0x1d0
	ctx.r[3].s64 = 464;
	// 826AC7BC: 48745C2D  bl 0x82df23e8
	ctx.lr = 0x826AC7C0;
	sub_82DF23E8(ctx, base);
	// 826AC7C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AC7C4: 41820014  beq 0x826ac7d8
	if ctx.cr[0].eq {
	pc = 0x826AC7D8; continue 'dispatch;
	}
	// 826AC7C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AC7CC: 4BFFE9C5  bl 0x826ab190
	ctx.lr = 0x826AC7D0;
	sub_826AB190(ctx, base);
	// 826AC7D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC7D4: 48000008  b 0x826ac7dc
	pc = 0x826AC7DC; continue 'dispatch;
	// 826AC7D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AC7DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826AC7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AC7E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826AC7E8: 4BFFE639  bl 0x826aae20
	ctx.lr = 0x826AC7EC;
	sub_826AAE20(ctx, base);
	// 826AC7EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AC7F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AC7F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826AC7F8: 4BC13809  bl 0x822c0000
	ctx.lr = 0x826AC7FC;
	sub_822C0000(ctx, base);
	// 826AC7FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AC800: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AC804: 38A0009E  li r5, 0x9e
	ctx.r[5].s64 = 158;
	// 826AC808: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826AC80C: 4BC13BCD  bl 0x822c03d8
	ctx.lr = 0x826AC810;
	sub_822C03D8(ctx, base);
	// 826AC810: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826AC814: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826AC818: 418200B4  beq 0x826ac8cc
	if ctx.cr[0].eq {
	pc = 0x826AC8CC; continue 'dispatch;
	}
	// 826AC81C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826AC820: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826AC824: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826AC828: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826AC82C: 409A0008  bne cr6, 0x826ac834
	if !ctx.cr[6].eq {
	pc = 0x826AC834; continue 'dispatch;
	}
	// 826AC830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AC834: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826AC838: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AC83C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826AC840: 419A0024  beq cr6, 0x826ac864
	if ctx.cr[6].eq {
	pc = 0x826AC864; continue 'dispatch;
	}
	// 826AC844: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AC848: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826AC84C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AC850: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826AC854: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826AC858: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AC85C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AC860: 4082FFE8  bne 0x826ac848
	if !ctx.cr[0].eq {
	pc = 0x826AC848; continue 'dispatch;
	}
	// 826AC864: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826AC868: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AC86C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826AC870: 419A0024  beq cr6, 0x826ac894
	if ctx.cr[6].eq {
	pc = 0x826AC894; continue 'dispatch;
	}
	// 826AC874: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AC878: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AC87C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AC880: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AC884: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AC888: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AC88C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AC890: 4082FFE8  bne 0x826ac878
	if !ctx.cr[0].eq {
	pc = 0x826AC878; continue 'dispatch;
	}
	// 826AC894: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AC898: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826AC89C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826AC8A0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826AC8A4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826AC8A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826AC8AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AC8B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AC8B4: 480EC67D  bl 0x82798f30
	ctx.lr = 0x826AC8B8;
	sub_82798F30(ctx, base);
	// 826AC8B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AC8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC8C0: 480EEDA9  bl 0x8279b668
	ctx.lr = 0x826AC8C4;
	sub_8279B668(ctx, base);
	// 826AC8C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC8C8: 48000008  b 0x826ac8d0
	pc = 0x826AC8D0; continue 'dispatch;
	// 826AC8CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AC8D0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826AC8D4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826AC8D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AC8DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC8E0: 4BEEB371  bl 0x82597c50
	ctx.lr = 0x826AC8E4;
	sub_82597C50(ctx, base);
	// 826AC8E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AC8E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AC8EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AC8F0: 4BC13711  bl 0x822c0000
	ctx.lr = 0x826AC8F4;
	sub_822C0000(ctx, base);
	// 826AC8F4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AC8F8: 41820024  beq 0x826ac91c
	if ctx.cr[0].eq {
	pc = 0x826AC91C; continue 'dispatch;
	}
	// 826AC8FC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826AC900: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AC904: 419A0008  beq cr6, 0x826ac90c
	if ctx.cr[6].eq {
	pc = 0x826AC90C; continue 'dispatch;
	}
	// 826AC908: 4BC13F89  bl 0x822c0890
	ctx.lr = 0x826AC90C;
	sub_822C0890(ctx, base);
	// 826AC90C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826AC910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AC914: 419A0008  beq cr6, 0x826ac91c
	if ctx.cr[6].eq {
	pc = 0x826AC91C; continue 'dispatch;
	}
	// 826AC918: 4BC13F79  bl 0x822c0890
	ctx.lr = 0x826AC91C;
	sub_822C0890(ctx, base);
	// 826AC91C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AC920: 419A000C  beq cr6, 0x826ac92c
	if ctx.cr[6].eq {
	pc = 0x826AC92C; continue 'dispatch;
	}
	// 826AC924: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AC928: 4BC13F69  bl 0x822c0890
	ctx.lr = 0x826AC92C;
	sub_822C0890(ctx, base);
	// 826AC92C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826AC930: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826AC934: 48AFB880  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AC938 size=52
    let mut pc: u32 = 0x826AC938;
    'dispatch: loop {
        match pc {
            0x826AC938 => {
    //   block [0x826AC938..0x826AC96C)
	// 826AC938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AC940: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AC944: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC948: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826AC94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC950: 4BFFFE39  bl 0x826ac788
	ctx.lr = 0x826AC954;
	sub_826AC788(ctx, base);
	// 826AC954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC958: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AC95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AC960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AC964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AC968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AC970 size=52
    let mut pc: u32 = 0x826AC970;
    'dispatch: loop {
        match pc {
            0x826AC970 => {
    //   block [0x826AC970..0x826AC9A4)
	// 826AC970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AC978: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AC97C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC980: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AC984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC988: 4BFFFE01  bl 0x826ac788
	ctx.lr = 0x826AC98C;
	sub_826AC788(ctx, base);
	// 826AC98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC990: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AC994: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AC998: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AC99C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AC9A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AC9A8 size=52
    let mut pc: u32 = 0x826AC9A8;
    'dispatch: loop {
        match pc {
            0x826AC9A8 => {
    //   block [0x826AC9A8..0x826AC9DC)
	// 826AC9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AC9B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AC9B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC9B8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826AC9BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC9C0: 4BFFFDC9  bl 0x826ac788
	ctx.lr = 0x826AC9C4;
	sub_826AC788(ctx, base);
	// 826AC9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AC9C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AC9CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AC9D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AC9D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AC9D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AC9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AC9E0 size=52
    let mut pc: u32 = 0x826AC9E0;
    'dispatch: loop {
        match pc {
            0x826AC9E0 => {
    //   block [0x826AC9E0..0x826ACA14)
	// 826AC9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AC9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AC9E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AC9EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AC9F0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826AC9F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AC9F8: 4BFFFD91  bl 0x826ac788
	ctx.lr = 0x826AC9FC;
	sub_826AC788(ctx, base);
	// 826AC9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACA00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACA04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACA08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACA18 size=52
    let mut pc: u32 = 0x826ACA18;
    'dispatch: loop {
        match pc {
            0x826ACA18 => {
    //   block [0x826ACA18..0x826ACA4C)
	// 826ACA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACA20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACA24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACA28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826ACA2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACA30: 4BFFFD59  bl 0x826ac788
	ctx.lr = 0x826ACA34;
	sub_826AC788(ctx, base);
	// 826ACA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACA38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACA3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACA40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACA50 size=52
    let mut pc: u32 = 0x826ACA50;
    'dispatch: loop {
        match pc {
            0x826ACA50 => {
    //   block [0x826ACA50..0x826ACA84)
	// 826ACA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACA58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACA5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACA60: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826ACA64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACA68: 4BFFFD21  bl 0x826ac788
	ctx.lr = 0x826ACA6C;
	sub_826AC788(ctx, base);
	// 826ACA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACA70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACA7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACA88 size=52
    let mut pc: u32 = 0x826ACA88;
    'dispatch: loop {
        match pc {
            0x826ACA88 => {
    //   block [0x826ACA88..0x826ACABC)
	// 826ACA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACA90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACA94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACA98: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826ACA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACAA0: 4BFFFCE9  bl 0x826ac788
	ctx.lr = 0x826ACAA4;
	sub_826AC788(ctx, base);
	// 826ACAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACAA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACAB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACAB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACAC0 size=52
    let mut pc: u32 = 0x826ACAC0;
    'dispatch: loop {
        match pc {
            0x826ACAC0 => {
    //   block [0x826ACAC0..0x826ACAF4)
	// 826ACAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACAC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACACC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACAD0: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826ACAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACAD8: 4BFFFCB1  bl 0x826ac788
	ctx.lr = 0x826ACADC;
	sub_826AC788(ctx, base);
	// 826ACADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACAE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACAE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACAE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACAF8 size=52
    let mut pc: u32 = 0x826ACAF8;
    'dispatch: loop {
        match pc {
            0x826ACAF8 => {
    //   block [0x826ACAF8..0x826ACB2C)
	// 826ACAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACB00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACB04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACB08: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826ACB0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACB10: 4BFFFC79  bl 0x826ac788
	ctx.lr = 0x826ACB14;
	sub_826AC788(ctx, base);
	// 826ACB14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACB18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACB24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACB30 size=52
    let mut pc: u32 = 0x826ACB30;
    'dispatch: loop {
        match pc {
            0x826ACB30 => {
    //   block [0x826ACB30..0x826ACB64)
	// 826ACB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACB38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACB3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACB40: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 826ACB44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACB48: 4BFFFC41  bl 0x826ac788
	ctx.lr = 0x826ACB4C;
	sub_826AC788(ctx, base);
	// 826ACB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACB50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACB54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACB58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACB5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACB60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACB68 size=52
    let mut pc: u32 = 0x826ACB68;
    'dispatch: loop {
        match pc {
            0x826ACB68 => {
    //   block [0x826ACB68..0x826ACB9C)
	// 826ACB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACB70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACB74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACB78: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 826ACB7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACB80: 4BFFFC09  bl 0x826ac788
	ctx.lr = 0x826ACB84;
	sub_826AC788(ctx, base);
	// 826ACB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACB88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACB8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACB90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACB94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACB98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACBA0 size=52
    let mut pc: u32 = 0x826ACBA0;
    'dispatch: loop {
        match pc {
            0x826ACBA0 => {
    //   block [0x826ACBA0..0x826ACBD4)
	// 826ACBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACBA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACBAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACBB0: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 826ACBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACBB8: 4BFFFBD1  bl 0x826ac788
	ctx.lr = 0x826ACBBC;
	sub_826AC788(ctx, base);
	// 826ACBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACBC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACBC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACBC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACBCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACBD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACBD8 size=52
    let mut pc: u32 = 0x826ACBD8;
    'dispatch: loop {
        match pc {
            0x826ACBD8 => {
    //   block [0x826ACBD8..0x826ACC0C)
	// 826ACBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACBDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACBE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACBE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACBE8: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 826ACBEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACBF0: 4BFFFB99  bl 0x826ac788
	ctx.lr = 0x826ACBF4;
	sub_826AC788(ctx, base);
	// 826ACBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACBF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACBFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACC00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACC04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACC08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACC10 size=52
    let mut pc: u32 = 0x826ACC10;
    'dispatch: loop {
        match pc {
            0x826ACC10 => {
    //   block [0x826ACC10..0x826ACC44)
	// 826ACC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACC14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACC18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACC1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACC20: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 826ACC24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACC28: 4BFFFB61  bl 0x826ac788
	ctx.lr = 0x826ACC2C;
	sub_826AC788(ctx, base);
	// 826ACC2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACC30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACC3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACC48 size=52
    let mut pc: u32 = 0x826ACC48;
    'dispatch: loop {
        match pc {
            0x826ACC48 => {
    //   block [0x826ACC48..0x826ACC7C)
	// 826ACC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACC50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACC54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACC58: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 826ACC5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACC60: 4BFFFB29  bl 0x826ac788
	ctx.lr = 0x826ACC64;
	sub_826AC788(ctx, base);
	// 826ACC64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACC68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACC6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACC70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACC74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACC80 size=52
    let mut pc: u32 = 0x826ACC80;
    'dispatch: loop {
        match pc {
            0x826ACC80 => {
    //   block [0x826ACC80..0x826ACCB4)
	// 826ACC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACC84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACC88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACC8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACC90: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 826ACC94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACC98: 4BFFFAF1  bl 0x826ac788
	ctx.lr = 0x826ACC9C;
	sub_826AC788(ctx, base);
	// 826ACC9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACCA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACCA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACCA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACCAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACCB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACCB8 size=52
    let mut pc: u32 = 0x826ACCB8;
    'dispatch: loop {
        match pc {
            0x826ACCB8 => {
    //   block [0x826ACCB8..0x826ACCEC)
	// 826ACCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACCBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACCC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACCC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACCC8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 826ACCCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACCD0: 4BFFFAB9  bl 0x826ac788
	ctx.lr = 0x826ACCD4;
	sub_826AC788(ctx, base);
	// 826ACCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACCD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACCDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACCE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACCE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACCE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACCF0 size=52
    let mut pc: u32 = 0x826ACCF0;
    'dispatch: loop {
        match pc {
            0x826ACCF0 => {
    //   block [0x826ACCF0..0x826ACD24)
	// 826ACCF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACCF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACCF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACCFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACD00: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 826ACD04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACD08: 4BFFFA81  bl 0x826ac788
	ctx.lr = 0x826ACD0C;
	sub_826AC788(ctx, base);
	// 826ACD0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACD10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACD14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACD18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACD28 size=52
    let mut pc: u32 = 0x826ACD28;
    'dispatch: loop {
        match pc {
            0x826ACD28 => {
    //   block [0x826ACD28..0x826ACD5C)
	// 826ACD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACD30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACD34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACD38: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 826ACD3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACD40: 4BFFFA49  bl 0x826ac788
	ctx.lr = 0x826ACD44;
	sub_826AC788(ctx, base);
	// 826ACD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACD48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACD4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACD50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACD54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACD58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACD60 size=52
    let mut pc: u32 = 0x826ACD60;
    'dispatch: loop {
        match pc {
            0x826ACD60 => {
    //   block [0x826ACD60..0x826ACD94)
	// 826ACD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACD64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACD68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACD6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACD70: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 826ACD74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACD78: 4BFFFA11  bl 0x826ac788
	ctx.lr = 0x826ACD7C;
	sub_826AC788(ctx, base);
	// 826ACD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACD80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACD84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACD88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACD8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACD90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACD98 size=52
    let mut pc: u32 = 0x826ACD98;
    'dispatch: loop {
        match pc {
            0x826ACD98 => {
    //   block [0x826ACD98..0x826ACDCC)
	// 826ACD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACD9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACDA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACDA8: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 826ACDAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACDB0: 4BFFF9D9  bl 0x826ac788
	ctx.lr = 0x826ACDB4;
	sub_826AC788(ctx, base);
	// 826ACDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACDB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACDBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACDC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACDC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACDC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACDD0 size=52
    let mut pc: u32 = 0x826ACDD0;
    'dispatch: loop {
        match pc {
            0x826ACDD0 => {
    //   block [0x826ACDD0..0x826ACE04)
	// 826ACDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACDDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACDE0: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 826ACDE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACDE8: 4BFFF9A1  bl 0x826ac788
	ctx.lr = 0x826ACDEC;
	sub_826AC788(ctx, base);
	// 826ACDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACDF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACE08 size=52
    let mut pc: u32 = 0x826ACE08;
    'dispatch: loop {
        match pc {
            0x826ACE08 => {
    //   block [0x826ACE08..0x826ACE3C)
	// 826ACE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACE10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACE14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACE18: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 826ACE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACE20: 4BFFF969  bl 0x826ac788
	ctx.lr = 0x826ACE24;
	sub_826AC788(ctx, base);
	// 826ACE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACE28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACE2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACE30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACE34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ACE40 size=60
    let mut pc: u32 = 0x826ACE40;
    'dispatch: loop {
        match pc {
            0x826ACE40 => {
    //   block [0x826ACE40..0x826ACE7C)
	// 826ACE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACE48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACE4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACE50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ACE54: 387FFF18  addi r3, r31, -0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + -232;
	// 826ACE58: C03F0044  lfs f1, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826ACE5C: 4BFE701D  bl 0x82693e78
	ctx.lr = 0x826ACE60;
	sub_82693E78(ctx, base);
	// 826ACE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACE64: 4BC1319D  bl 0x822c0000
	ctx.lr = 0x826ACE68;
	sub_822C0000(ctx, base);
	// 826ACE68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ACE6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACE70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACE74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACE78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACE80 size=196
    let mut pc: u32 = 0x826ACE80;
    'dispatch: loop {
        match pc {
            0x826ACE80 => {
    //   block [0x826ACE80..0x826ACF44)
	// 826ACE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACE88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ACE8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACE90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACE94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ACE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ACE9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826ACEA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826ACEA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ACEA8: 4BC13A91  bl 0x822c0938
	ctx.lr = 0x826ACEAC;
	sub_822C0938(ctx, base);
	// 826ACEAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ACEB0: 41820028  beq 0x826aced8
	if ctx.cr[0].eq {
	pc = 0x826ACED8; continue 'dispatch;
	}
	// 826ACEB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ACEB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826ACEBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826ACEC0: 392B2208  addi r9, r11, 0x2208
	ctx.r[9].s64 = ctx.r[11].s64 + 8712;
	// 826ACEC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826ACEC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ACECC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826ACED0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826ACED4: 48000008  b 0x826acedc
	pc = 0x826ACEDC; continue 'dispatch;
	// 826ACED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ACEDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ACEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ACEE4: 409A0044  bne cr6, 0x826acf28
	if !ctx.cr[6].eq {
	pc = 0x826ACF28; continue 'dispatch;
	}
	// 826ACEE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826ACEEC: 419A001C  beq cr6, 0x826acf08
	if ctx.cr[6].eq {
	pc = 0x826ACF08; continue 'dispatch;
	}
	// 826ACEF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ACEF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ACEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACEFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ACF00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ACF04: 4E800421  bctrl
	ctx.lr = 0x826ACF08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ACF08: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826ACF0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826ACF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ACF14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826ACF18: 816BA39C  lwz r11, -0x5c64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23652 as u32) ) } as u64;
	// 826ACF1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826ACF20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826ACF24: 4BC130DD  bl 0x822c0000
	ctx.lr = 0x826ACF28;
	sub_822C0000(ctx, base);
	// 826ACF28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ACF2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ACF30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACF34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ACF38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826ACF3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ACF40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ACF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ACF48 size=196
    let mut pc: u32 = 0x826ACF48;
    'dispatch: loop {
        match pc {
            0x826ACF48 => {
    //   block [0x826ACF48..0x826AD00C)
	// 826ACF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ACF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ACF50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ACF54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ACF58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ACF5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ACF60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ACF64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826ACF68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826ACF6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ACF70: 4BC139C9  bl 0x822c0938
	ctx.lr = 0x826ACF74;
	sub_822C0938(ctx, base);
	// 826ACF74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ACF78: 41820028  beq 0x826acfa0
	if ctx.cr[0].eq {
	pc = 0x826ACFA0; continue 'dispatch;
	}
	// 826ACF7C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ACF80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826ACF84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826ACF88: 392B221C  addi r9, r11, 0x221c
	ctx.r[9].s64 = ctx.r[11].s64 + 8732;
	// 826ACF8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826ACF90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ACF94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826ACF98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826ACF9C: 48000008  b 0x826acfa4
	pc = 0x826ACFA4; continue 'dispatch;
	// 826ACFA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ACFA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ACFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ACFAC: 409A0044  bne cr6, 0x826acff0
	if !ctx.cr[6].eq {
	pc = 0x826ACFF0; continue 'dispatch;
	}
	// 826ACFB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826ACFB4: 419A001C  beq cr6, 0x826acfd0
	if ctx.cr[6].eq {
	pc = 0x826ACFD0; continue 'dispatch;
	}
	// 826ACFB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ACFBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ACFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ACFC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ACFC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ACFCC: 4E800421  bctrl
	ctx.lr = 0x826ACFD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ACFD0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826ACFD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826ACFD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ACFDC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826ACFE0: 816BA39C  lwz r11, -0x5c64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23652 as u32) ) } as u64;
	// 826ACFE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826ACFE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826ACFEC: 4BC13015  bl 0x822c0000
	ctx.lr = 0x826ACFF0;
	sub_822C0000(ctx, base);
	// 826ACFF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ACFF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ACFF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ACFFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AD000: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AD004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AD008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AD010 size=196
    let mut pc: u32 = 0x826AD010;
    'dispatch: loop {
        match pc {
            0x826AD010 => {
    //   block [0x826AD010..0x826AD0D4)
	// 826AD010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AD018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AD01C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AD020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AD028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AD02C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826AD030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AD034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AD038: 4BC13901  bl 0x822c0938
	ctx.lr = 0x826AD03C;
	sub_822C0938(ctx, base);
	// 826AD03C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AD040: 41820028  beq 0x826ad068
	if ctx.cr[0].eq {
	pc = 0x826AD068; continue 'dispatch;
	}
	// 826AD044: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AD048: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826AD04C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826AD050: 392B2230  addi r9, r11, 0x2230
	ctx.r[9].s64 = ctx.r[11].s64 + 8752;
	// 826AD054: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826AD058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826AD05C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826AD060: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826AD064: 48000008  b 0x826ad06c
	pc = 0x826AD06C; continue 'dispatch;
	// 826AD068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AD06C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AD070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AD074: 409A0044  bne cr6, 0x826ad0b8
	if !ctx.cr[6].eq {
	pc = 0x826AD0B8; continue 'dispatch;
	}
	// 826AD078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826AD07C: 419A001C  beq cr6, 0x826ad098
	if ctx.cr[6].eq {
	pc = 0x826AD098; continue 'dispatch;
	}
	// 826AD080: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD084: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AD088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD08C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AD094: 4E800421  bctrl
	ctx.lr = 0x826AD098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AD098: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AD09C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AD0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AD0A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826AD0A8: 816BA39C  lwz r11, -0x5c64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23652 as u32) ) } as u64;
	// 826AD0AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AD0B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AD0B4: 4BC12F4D  bl 0x822c0000
	ctx.lr = 0x826AD0B8;
	sub_822C0000(ctx, base);
	// 826AD0B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD0BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AD0C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AD0C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AD0C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AD0CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AD0D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AD0D8 size=112
    let mut pc: u32 = 0x826AD0D8;
    'dispatch: loop {
        match pc {
            0x826AD0D8 => {
    //   block [0x826AD0D8..0x826AD148)
	// 826AD0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD0DC: 48AFB091  bl 0x831a816c
	ctx.lr = 0x826AD0E0;
	sub_831A8130(ctx, base);
	// 826AD0E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD0E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AD0E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826AD0EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AD0F0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826AD0F4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826AD0F8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 826AD0FC: 487452ED  bl 0x82df23e8
	ctx.lr = 0x826AD100;
	sub_82DF23E8(ctx, base);
	// 826AD100: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AD104: 41820010  beq 0x826ad114
	if ctx.cr[0].eq {
	pc = 0x826AD114; continue 'dispatch;
	}
	// 826AD108: 48268C89  bl 0x82915d90
	ctx.lr = 0x826AD10C;
	sub_82915D90(ctx, base);
	// 826AD10C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD110: 48000008  b 0x826ad118
	pc = 0x826AD118; continue 'dispatch;
	// 826AD114: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AD118: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826AD11C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826AD120: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD128: 4BFFFD59  bl 0x826ace80
	ctx.lr = 0x826AD12C;
	sub_826ACE80(ctx, base);
	// 826AD12C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AD130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD138: 4BC12EC9  bl 0x822c0000
	ctx.lr = 0x826AD13C;
	sub_822C0000(ctx, base);
	// 826AD13C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AD140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AD144: 48AFB078  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AD148 size=8
    let mut pc: u32 = 0x826AD148;
    'dispatch: loop {
        match pc {
            0x826AD148 => {
    //   block [0x826AD148..0x826AD150)
	// 826AD148: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 826AD14C: 480001DC  b 0x826ad328
	sub_826AD328(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AD150 size=8
    let mut pc: u32 = 0x826AD150;
    'dispatch: loop {
        match pc {
            0x826AD150 => {
    //   block [0x826AD150..0x826AD158)
	// 826AD150: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826AD154: 480001D4  b 0x826ad328
	sub_826AD328(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AD158 size=152
    let mut pc: u32 = 0x826AD158;
    'dispatch: loop {
        match pc {
            0x826AD158 => {
    //   block [0x826AD158..0x826AD1F0)
	// 826AD158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AD160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AD164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AD168: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD16C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AD170: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AD174: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826AD178: 419A0060  beq cr6, 0x826ad1d8
	if ctx.cr[6].eq {
	pc = 0x826AD1D8; continue 'dispatch;
	}
	// 826AD17C: 4BFE720D  bl 0x82694388
	ctx.lr = 0x826AD180;
	sub_82694388(ctx, base);
	// 826AD180: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AD184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AD188: 388B22E8  addi r4, r11, 0x22e8
	ctx.r[4].s64 = ctx.r[11].s64 + 8936;
	// 826AD18C: 4874687D  bl 0x82df3a08
	ctx.lr = 0x826AD190;
	sub_82DF3A08(ctx, base);
	// 826AD190: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AD194: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826AD198: 389E0044  addi r4, r30, 0x44
	ctx.r[4].s64 = ctx.r[30].s64 + 68;
	// 826AD19C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826AD1A0: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826AD1A4: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826AD1A8: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 826AD1AC: 4BEF6005  bl 0x825a31b0
	ctx.lr = 0x826AD1B0;
	sub_825A31B0(ctx, base);
	// 826AD1B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AD1B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AD1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD1BC: 4BEF45B5  bl 0x825a1770
	ctx.lr = 0x826AD1C0;
	sub_825A1770(ctx, base);
	// 826AD1C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826AD1C4: 48746265  bl 0x82df3428
	ctx.lr = 0x826AD1C8;
	sub_82DF3428(ctx, base);
	// 826AD1C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826AD1CC: 4BC1BAED  bl 0x822c8cb8
	ctx.lr = 0x826AD1D0;
	sub_822C8CB8(ctx, base);
	// 826AD1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AD1D4: 48746255  bl 0x82df3428
	ctx.lr = 0x826AD1D8;
	sub_82DF3428(ctx, base);
	// 826AD1D8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826AD1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AD1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AD1E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AD1E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AD1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AD1F0 size=196
    let mut pc: u32 = 0x826AD1F0;
    'dispatch: loop {
        match pc {
            0x826AD1F0 => {
    //   block [0x826AD1F0..0x826AD2B4)
	// 826AD1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AD1F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AD1FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AD200: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AD20C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AD210: 4BFFFEC9  bl 0x826ad0d8
	ctx.lr = 0x826AD214;
	sub_826AD0D8(ctx, base);
	// 826AD214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD218: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826AD21C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AD220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AD224: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AD228: 419A0024  beq cr6, 0x826ad24c
	if ctx.cr[6].eq {
	pc = 0x826AD24C; continue 'dispatch;
	}
	// 826AD22C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AD230: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AD234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD238: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AD23C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AD240: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AD244: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD248: 4082FFE8  bne 0x826ad230
	if !ctx.cr[0].eq {
	pc = 0x826AD230; continue 'dispatch;
	}
	// 826AD24C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD250: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826AD254: 4895AED5  bl 0x83008128
	ctx.lr = 0x826AD258;
	sub_83008128(ctx, base);
	// 826AD258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AD25C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AD260: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826AD264: 388A2300  addi r4, r10, 0x2300
	ctx.r[4].s64 = ctx.r[10].s64 + 8960;
	// 826AD268: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 826AD26C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826AD270: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AD274: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826AD278: 487AB7C9  bl 0x82e58a40
	ctx.lr = 0x826AD27C;
	sub_82E58A40(ctx, base);
	// 826AD27C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826AD280: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD284: 419A0008  beq cr6, 0x826ad28c
	if ctx.cr[6].eq {
	pc = 0x826AD28C; continue 'dispatch;
	}
	// 826AD288: 4BC13609  bl 0x822c0890
	ctx.lr = 0x826AD28C;
	sub_822C0890(ctx, base);
	// 826AD28C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826AD290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD294: 419A0008  beq cr6, 0x826ad29c
	if ctx.cr[6].eq {
	pc = 0x826AD29C; continue 'dispatch;
	}
	// 826AD298: 4BC135F9  bl 0x822c0890
	ctx.lr = 0x826AD29C;
	sub_822C0890(ctx, base);
	// 826AD29C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826AD2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AD2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AD2A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AD2AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AD2B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AD2B8 size=112
    let mut pc: u32 = 0x826AD2B8;
    'dispatch: loop {
        match pc {
            0x826AD2B8 => {
    //   block [0x826AD2B8..0x826AD328)
	// 826AD2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD2BC: 48AFAEB1  bl 0x831a816c
	ctx.lr = 0x826AD2C0;
	sub_831A8130(ctx, base);
	// 826AD2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD2C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AD2C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826AD2CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AD2D0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826AD2D4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826AD2D8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 826AD2DC: 4874510D  bl 0x82df23e8
	ctx.lr = 0x826AD2E0;
	sub_82DF23E8(ctx, base);
	// 826AD2E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AD2E4: 41820010  beq 0x826ad2f4
	if ctx.cr[0].eq {
	pc = 0x826AD2F4; continue 'dispatch;
	}
	// 826AD2E8: 48268A69  bl 0x82915d50
	ctx.lr = 0x826AD2EC;
	sub_82915D50(ctx, base);
	// 826AD2EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD2F0: 48000008  b 0x826ad2f8
	pc = 0x826AD2F8; continue 'dispatch;
	// 826AD2F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AD2F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826AD2FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826AD300: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD308: 4BFFFD09  bl 0x826ad010
	ctx.lr = 0x826AD30C;
	sub_826AD010(ctx, base);
	// 826AD30C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AD310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD318: 4BC12CE9  bl 0x822c0000
	ctx.lr = 0x826AD31C;
	sub_822C0000(ctx, base);
	// 826AD31C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AD320: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AD324: 48AFAE98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AD328 size=112
    let mut pc: u32 = 0x826AD328;
    'dispatch: loop {
        match pc {
            0x826AD328 => {
    //   block [0x826AD328..0x826AD398)
	// 826AD328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AD330: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AD334: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AD338: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD33C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD340: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AD344: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AD348: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AD34C: 396B22A4  addi r11, r11, 0x22a4
	ctx.r[11].s64 = ctx.r[11].s64 + 8868;
	// 826AD350: 394A2290  addi r10, r10, 0x2290
	ctx.r[10].s64 = ctx.r[10].s64 + 8848;
	// 826AD354: 39292244  addi r9, r9, 0x2244
	ctx.r[9].s64 = ctx.r[9].s64 + 8772;
	// 826AD358: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AD35C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826AD360: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AD364: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 826AD368: 4BF43049  bl 0x825f03b0
	ctx.lr = 0x826AD36C;
	sub_825F03B0(ctx, base);
	// 826AD36C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AD370: 4182000C  beq 0x826ad37c
	if ctx.cr[0].eq {
	pc = 0x826AD37C; continue 'dispatch;
	}
	// 826AD374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD378: 48745061  bl 0x82df23d8
	ctx.lr = 0x826AD37C;
	sub_82DF23D8(ctx, base);
	// 826AD37C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AD384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AD388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AD38C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AD390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AD394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AD398 size=560
    let mut pc: u32 = 0x826AD398;
    'dispatch: loop {
        match pc {
            0x826AD398 => {
    //   block [0x826AD398..0x826AD5C8)
	// 826AD398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD39C: 48AFADC9  bl 0x831a8164
	ctx.lr = 0x826AD3A0;
	sub_831A8130(ctx, base);
	// 826AD3A0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826AD3A4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD3A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD3AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AD3B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826AD3B4: 4BFFFF05  bl 0x826ad2b8
	ctx.lr = 0x826AD3B8;
	sub_826AD2B8(ctx, base);
	// 826AD3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD3BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826AD3C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AD3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AD3C8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826AD3CC: 419A0024  beq cr6, 0x826ad3f0
	if ctx.cr[6].eq {
	pc = 0x826AD3F0; continue 'dispatch;
	}
	// 826AD3D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AD3D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AD3D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD3DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AD3E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AD3E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AD3E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD3EC: 4082FFE8  bne 0x826ad3d4
	if !ctx.cr[0].eq {
	pc = 0x826AD3D4; continue 'dispatch;
	}
	// 826AD3F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826AD3F4: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 826AD3F8: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 826AD3FC: 4895AD2D  bl 0x83008128
	ctx.lr = 0x826AD400;
	sub_83008128(ctx, base);
	// 826AD400: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AD404: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AD408: 3BAB2300  addi r29, r11, 0x2300
	ctx.r[29].s64 = ctx.r[11].s64 + 8960;
	// 826AD40C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826AD410: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AD414: 38A00096  li r5, 0x96
	ctx.r[5].s64 = 150;
	// 826AD418: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826AD41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD420: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 826AD424: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AD428: 487AB619  bl 0x82e58a40
	ctx.lr = 0x826AD42C;
	sub_82E58A40(ctx, base);
	// 826AD42C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826AD430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD434: 419A0008  beq cr6, 0x826ad43c
	if ctx.cr[6].eq {
	pc = 0x826AD43C; continue 'dispatch;
	}
	// 826AD438: 4BC13459  bl 0x822c0890
	ctx.lr = 0x826AD43C;
	sub_822C0890(ctx, base);
	// 826AD43C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826AD440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD444: 419A0008  beq cr6, 0x826ad44c
	if ctx.cr[6].eq {
	pc = 0x826AD44C; continue 'dispatch;
	}
	// 826AD448: 4BC13449  bl 0x822c0890
	ctx.lr = 0x826AD44C;
	sub_822C0890(ctx, base);
	// 826AD44C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD450: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826AD454: 4BE62075  bl 0x8250f4c8
	ctx.lr = 0x826AD458;
	sub_8250F4C8(ctx, base);
	// 826AD458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AD460: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826AD464: 409A0008  bne cr6, 0x826ad46c
	if !ctx.cr[6].eq {
	pc = 0x826AD46C; continue 'dispatch;
	}
	// 826AD468: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826AD46C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826AD470: 4BE5B5A9  bl 0x82508a18
	ctx.lr = 0x826AD474;
	sub_82508A18(ctx, base);
	// 826AD474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD478: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826AD47C: 4895ACAD  bl 0x83008128
	ctx.lr = 0x826AD480;
	sub_83008128(ctx, base);
	// 826AD480: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 826AD484: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826AD488: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 826AD48C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 826AD490: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 826AD494: 487447FD  bl 0x82df1c90
	ctx.lr = 0x826AD498;
	sub_82DF1C90(ctx, base);
	// 826AD498: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AD49C: 41820120  beq 0x826ad5bc
	if ctx.cr[0].eq {
	pc = 0x826AD5BC; continue 'dispatch;
	}
	// 826AD4A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826AD4A4: 4BD11B85  bl 0x823bf028
	ctx.lr = 0x826AD4A8;
	sub_823BF028(ctx, base);
	// 826AD4A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD4AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826AD4B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AD4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AD4B8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826AD4BC: 419A0024  beq cr6, 0x826ad4e0
	if ctx.cr[6].eq {
	pc = 0x826AD4E0; continue 'dispatch;
	}
	// 826AD4C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AD4C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AD4C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD4CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AD4D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AD4D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AD4D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD4DC: 4082FFE8  bne 0x826ad4c4
	if !ctx.cr[0].eq {
	pc = 0x826AD4C4; continue 'dispatch;
	}
	// 826AD4E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826AD4E4: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 826AD4E8: 4895AC41  bl 0x83008128
	ctx.lr = 0x826AD4EC;
	sub_83008128(ctx, base);
	// 826AD4EC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826AD4F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AD4F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AD4F8: 38A0009B  li r5, 0x9b
	ctx.r[5].s64 = 155;
	// 826AD4FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD500: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 826AD504: 487AB53D  bl 0x82e58a40
	ctx.lr = 0x826AD508;
	sub_82E58A40(ctx, base);
	// 826AD508: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826AD50C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD510: 419A0008  beq cr6, 0x826ad518
	if ctx.cr[6].eq {
	pc = 0x826AD518; continue 'dispatch;
	}
	// 826AD514: 4BC1337D  bl 0x822c0890
	ctx.lr = 0x826AD518;
	sub_822C0890(ctx, base);
	// 826AD518: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826AD51C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD520: 419A0008  beq cr6, 0x826ad528
	if ctx.cr[6].eq {
	pc = 0x826AD528; continue 'dispatch;
	}
	// 826AD524: 4BC1336D  bl 0x822c0890
	ctx.lr = 0x826AD528;
	sub_822C0890(ctx, base);
	// 826AD528: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 826AD52C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AD530: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826AD534: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826AD538: 4BCECFC1  bl 0x8239a4f8
	ctx.lr = 0x826AD53C;
	sub_8239A4F8(ctx, base);
	// 826AD53C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD540: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826AD544: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AD548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AD54C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 826AD550: 419A0024  beq cr6, 0x826ad574
	if ctx.cr[6].eq {
	pc = 0x826AD574; continue 'dispatch;
	}
	// 826AD554: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AD558: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AD55C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD560: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AD564: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AD568: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AD56C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AD570: 4082FFE8  bne 0x826ad558
	if !ctx.cr[0].eq {
	pc = 0x826AD558; continue 'dispatch;
	}
	// 826AD574: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826AD578: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 826AD57C: 4895ABAD  bl 0x83008128
	ctx.lr = 0x826AD580;
	sub_83008128(ctx, base);
	// 826AD580: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826AD584: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AD588: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AD58C: 38A0009E  li r5, 0x9e
	ctx.r[5].s64 = 158;
	// 826AD590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD594: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 826AD598: 487AB4A9  bl 0x82e58a40
	ctx.lr = 0x826AD59C;
	sub_82E58A40(ctx, base);
	// 826AD59C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826AD5A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD5A4: 419A0008  beq cr6, 0x826ad5ac
	if ctx.cr[6].eq {
	pc = 0x826AD5AC; continue 'dispatch;
	}
	// 826AD5A8: 4BC132E9  bl 0x822c0890
	ctx.lr = 0x826AD5AC;
	sub_822C0890(ctx, base);
	// 826AD5AC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826AD5B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AD5B4: 419A0008  beq cr6, 0x826ad5bc
	if ctx.cr[6].eq {
	pc = 0x826AD5BC; continue 'dispatch;
	}
	// 826AD5B8: 4BC132D9  bl 0x822c0890
	ctx.lr = 0x826AD5BC;
	sub_822C0890(ctx, base);
	// 826AD5BC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826AD5C0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826AD5C4: 48AFABF0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AD5C8 size=164
    let mut pc: u32 = 0x826AD5C8;
    'dispatch: loop {
        match pc {
            0x826AD5C8 => {
    //   block [0x826AD5C8..0x826AD66C)
	// 826AD5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD5CC: 48AFAB9D  bl 0x831a8168
	ctx.lr = 0x826AD5D0;
	sub_831A8130(ctx, base);
	// 826AD5D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD5D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826AD5D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AD5DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AD5E0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826AD5E4: 41820038  beq 0x826ad61c
	if ctx.cr[0].eq {
	pc = 0x826AD61C; continue 'dispatch;
	}
	// 826AD5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD5EC: 48AFC39D  bl 0x831a9988
	ctx.lr = 0x826AD5F0;
	sub_831A9988(ctx, base);
	// 826AD5F0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826AD5F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AD5F8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826AD5FC: 48AFAAFD  bl 0x831a80f8
	ctx.lr = 0x826AD600;
	sub_831A80F8(ctx, base);
	// 826AD600: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AD604: 41820018  beq 0x826ad61c
	if ctx.cr[0].eq {
	pc = 0x826AD61C; continue 'dispatch;
	}
	// 826AD608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD60C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AD610: 4BFFFD89  bl 0x826ad398
	ctx.lr = 0x826AD614;
	sub_826AD398(ctx, base);
	// 826AD614: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826AD618: 4800004C  b 0x826ad664
	pc = 0x826AD664; continue 'dispatch;
	// 826AD61C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826AD620: 419A0034  beq cr6, 0x826ad654
	if ctx.cr[6].eq {
	pc = 0x826AD654; continue 'dispatch;
	}
	// 826AD624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD628: 48AFC361  bl 0x831a9988
	ctx.lr = 0x826AD62C;
	sub_831A9988(ctx, base);
	// 826AD62C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826AD630: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AD634: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 826AD638: 48AFAAC1  bl 0x831a80f8
	ctx.lr = 0x826AD63C;
	sub_831A80F8(ctx, base);
	// 826AD63C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AD640: 41820014  beq 0x826ad654
	if ctx.cr[0].eq {
	pc = 0x826AD654; continue 'dispatch;
	}
	// 826AD644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD648: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AD64C: 4BFFFBA5  bl 0x826ad1f0
	ctx.lr = 0x826AD650;
	sub_826AD1F0(ctx, base);
	// 826AD650: 4BFFFFC4  b 0x826ad614
	pc = 0x826AD614; continue 'dispatch;
	// 826AD654: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826AD658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AD65C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD660: 4BFE7501  bl 0x82694b60
	ctx.lr = 0x826AD664;
	sub_82694B60(ctx, base);
	// 826AD664: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826AD668: 48AFAB50  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AD670 size=304
    let mut pc: u32 = 0x826AD670;
    'dispatch: loop {
        match pc {
            0x826AD670 => {
    //   block [0x826AD670..0x826AD7A0)
	// 826AD670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD674: 48AFAAF9  bl 0x831a816c
	ctx.lr = 0x826AD678;
	sub_831A8130(ctx, base);
	// 826AD678: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD67C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD680: 4BFE6C41  bl 0x826942c0
	ctx.lr = 0x826AD684;
	sub_826942C0(ctx, base);
	// 826AD684: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AD688: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AD68C: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 826AD690: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AD694: 3CE08335  lis r7, -0x7ccb
	ctx.r[7].s64 = -2093678592;
	// 826AD698: C00B21FC  lfs f0, 0x21fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AD69C: 39692290  addi r11, r9, 0x2290
	ctx.r[11].s64 = ctx.r[9].s64 + 8848;
	// 826AD6A0: 394A22A4  addi r10, r10, 0x22a4
	ctx.r[10].s64 = ctx.r[10].s64 + 8868;
	// 826AD6A4: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 826AD6A8: 39282244  addi r9, r8, 0x2244
	ctx.r[9].s64 = ctx.r[8].s64 + 8772;
	// 826AD6AC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 826AD6B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826AD6B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826AD6B8: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 826AD6BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AD6C0: 80876784  lwz r4, 0x6784(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26500 as u32) ) } as u64;
	// 826AD6C4: 80AB67D4  lwz r5, 0x67d4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 826AD6C8: 4BC4A0D9  bl 0x822f77a0
	ctx.lr = 0x826AD6CC;
	sub_822F77A0(ctx, base);
	// 826AD6CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826AD6D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AD6D4: 808B6870  lwz r4, 0x6870(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26736 as u32) ) } as u64;
	// 826AD6D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826AD6DC: 4BC37855  bl 0x822e4f30
	ctx.lr = 0x826AD6E0;
	sub_822E4F30(ctx, base);
	// 826AD6E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826AD6E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AD6E8: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826AD6EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AD6F0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826AD6F4: 4BDDEB95  bl 0x8248c288
	ctx.lr = 0x826AD6F8;
	sub_8248C288(ctx, base);
	// 826AD6F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AD6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD700: 4BFE6661  bl 0x82693d60
	ctx.lr = 0x826AD704;
	sub_82693D60(ctx, base);
	// 826AD704: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826AD708: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 826AD70C: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 826AD710: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 826AD714: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 826AD718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD71C: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 826AD720: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AD724: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 826AD728: 4BFE66E1  bl 0x82693e08
	ctx.lr = 0x826AD72C;
	sub_82693E08(ctx, base);
	// 826AD72C: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 826AD730: 9BC10055  stb r30, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[30].u8 ) };
	// 826AD734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD738: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 826AD73C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826AD740: 9BA10056  stb r29, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[29].u8 ) };
	// 826AD744: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 826AD748: 4BFE66E9  bl 0x82693e30
	ctx.lr = 0x826AD74C;
	sub_82693E30(ctx, base);
	// 826AD74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD750: C03F012C  lfs f1, 0x12c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AD754: 4BFE6725  bl 0x82693e78
	ctx.lr = 0x826AD758;
	sub_82693E78(ctx, base);
	// 826AD758: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AD75C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AD760: 388B2364  addi r4, r11, 0x2364
	ctx.r[4].s64 = ctx.r[11].s64 + 9060;
	// 826AD764: 4BC1BB8D  bl 0x822c92f0
	ctx.lr = 0x826AD768;
	sub_822C92F0(ctx, base);
	// 826AD768: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 826AD76C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 826AD770: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AD774: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826AD778: 4BC1B9B9  bl 0x822c9130
	ctx.lr = 0x826AD77C;
	sub_822C9130(ctx, base);
	// 826AD77C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826AD780: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AD784: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AD788: 4BC1B6A9  bl 0x822c8e30
	ctx.lr = 0x826AD78C;
	sub_822C8E30(ctx, base);
	// 826AD78C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826AD790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD794: 997F0100  stb r11, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 826AD798: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826AD79C: 48AFAA20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AD7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AD7A0 size=704
    let mut pc: u32 = 0x826AD7A0;
    'dispatch: loop {
        match pc {
            0x826AD7A0 => {
    //   block [0x826AD7A0..0x826ADA60)
	// 826AD7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AD7A4: 48AFA9C1  bl 0x831a8164
	ctx.lr = 0x826AD7A8;
	sub_831A8130(ctx, base);
	// 826AD7A8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 826AD7AC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826AD7B0: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AD7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AD7B8: 3F608201  lis r27, -0x7dff
	ctx.r[27].s64 = -2113863680;
	// 826AD7BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826AD7C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826AD7C4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826AD7C8: C01F012C  lfs f0, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AD7CC: C03B964C  lfs f1, -0x69b4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AD7D0: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 826AD7D4: 41980008  blt cr6, 0x826ad7dc
	if ctx.cr[6].lt {
	pc = 0x826AD7DC; continue 'dispatch;
	}
	// 826AD7D8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 826AD7DC: D03F012C  stfs f1, 0x12c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 826AD7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD7E4: 4BFE6695  bl 0x82693e78
	ctx.lr = 0x826AD7E8;
	sub_82693E78(ctx, base);
	// 826AD7E8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 826AD7EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826AD7F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AD7F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AD7F8: 4BFE7541  bl 0x82694d38
	ctx.lr = 0x826AD7FC;
	sub_82694D38(ctx, base);
	// 826AD7FC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826AD800: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AD804: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826AD808: 48746201  bl 0x82df3a08
	ctx.lr = 0x826AD80C;
	sub_82DF3A08(ctx, base);
	// 826AD80C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AD810: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AD814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD818: 4BE5AF69  bl 0x82508780
	ctx.lr = 0x826AD81C;
	sub_82508780(ctx, base);
	// 826AD81C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AD820: 48745C09  bl 0x82df3428
	ctx.lr = 0x826AD824;
	sub_82DF3428(ctx, base);
	// 826AD824: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826AD828: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AD82C: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 826AD830: 487461D9  bl 0x82df3a08
	ctx.lr = 0x826AD834;
	sub_82DF3A08(ctx, base);
	// 826AD834: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AD838: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826AD83C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD840: 4BE5AF41  bl 0x82508780
	ctx.lr = 0x826AD844;
	sub_82508780(ctx, base);
	// 826AD844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826AD848: 48745BE1  bl 0x82df3428
	ctx.lr = 0x826AD84C;
	sub_82DF3428(ctx, base);
	// 826AD84C: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 826AD850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AD854: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826AD858: 4BE5AF49  bl 0x825087a0
	ctx.lr = 0x826AD85C;
	sub_825087A0(ctx, base);
	// 826AD85C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826AD860: 4881F189  bl 0x82ecc9e8
	ctx.lr = 0x826AD864;
	sub_82ECC9E8(ctx, base);
	// 826AD864: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 826AD868: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AD86C: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 826AD870: 99610190  stb r11, 0x190(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 826AD874: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826AD878: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826AD87C: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826AD880: 487F2EB1  bl 0x82ea0730
	ctx.lr = 0x826AD884;
	sub_82EA0730(ctx, base);
	// 826AD884: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 826AD888: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826AD88C: C01B964C  lfs f0, -0x69b4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AD890: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 826AD894: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AD898: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826AD89C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826AD8A0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826AD8A4: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AD8A8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 826AD8AC: C02AF614  lfs f1, -0x9ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AD8B0: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 826AD8B4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826AD8B8: C3C99450  lfs f30, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826AD8BC: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826AD8C0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 826AD8C4: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 826AD8C8: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826AD8CC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826AD8D0: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826AD8D4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ADA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ADA60 size=400
    let mut pc: u32 = 0x826ADA60;
    'dispatch: loop {
        match pc {
            0x826ADA60 => {
    //   block [0x826ADA60..0x826ADBF0)
	// 826ADA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ADA64: 48AFA705  bl 0x831a8168
	ctx.lr = 0x826ADA68;
	sub_831A8130(ctx, base);
	// 826ADA68: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ADA6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ADA70: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826ADA74: 3BCB2300  addi r30, r11, 0x2300
	ctx.r[30].s64 = ctx.r[11].s64 + 8960;
	// 826ADA78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ADA7C: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 826ADA80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826ADA84: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 826ADA88: 48744961  bl 0x82df23e8
	ctx.lr = 0x826ADA8C;
	sub_82DF23E8(ctx, base);
	// 826ADA8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ADA90: 41820010  beq 0x826adaa0
	if ctx.cr[0].eq {
	pc = 0x826ADAA0; continue 'dispatch;
	}
	// 826ADA94: 4BFFFBDD  bl 0x826ad670
	ctx.lr = 0x826ADA98;
	sub_826AD670(ctx, base);
	// 826ADA98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ADA9C: 48000008  b 0x826adaa4
	pc = 0x826ADAA4; continue 'dispatch;
	// 826ADAA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826ADAA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826ADAA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ADAAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ADAB0: 4BFFF499  bl 0x826acf48
	ctx.lr = 0x826ADAB4;
	sub_826ACF48(ctx, base);
	// 826ADAB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826ADAB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ADABC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ADAC0: 4BC12541  bl 0x822c0000
	ctx.lr = 0x826ADAC4;
	sub_822C0000(ctx, base);
	// 826ADAC4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826ADAC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826ADACC: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 826ADAD0: 409A0008  bne cr6, 0x826adad8
	if !ctx.cr[6].eq {
	pc = 0x826ADAD8; continue 'dispatch;
	}
	// 826ADAD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ADAD8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826ADADC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826ADAE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826ADAE4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 826ADAE8: 419A0024  beq cr6, 0x826adb0c
	if ctx.cr[6].eq {
	pc = 0x826ADB0C; continue 'dispatch;
	}
	// 826ADAEC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826ADAF0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826ADAF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ADAF8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826ADAFC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826ADB00: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826ADB04: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ADB08: 4082FFE8  bne 0x826adaf0
	if !ctx.cr[0].eq {
	pc = 0x826ADAF0; continue 'dispatch;
	}
	// 826ADB0C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826ADB10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826ADB14: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826ADB18: 419A0024  beq cr6, 0x826adb3c
	if ctx.cr[6].eq {
	pc = 0x826ADB3C; continue 'dispatch;
	}
	// 826ADB1C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826ADB20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826ADB24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ADB28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826ADB2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826ADB30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826ADB34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ADB38: 4082FFE8  bne 0x826adb20
	if !ctx.cr[0].eq {
	pc = 0x826ADB20; continue 'dispatch;
	}
	// 826ADB3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826ADB40: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826ADB44: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826ADB48: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826ADB4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ADB50: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ADB54: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826ADB58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826ADB5C: 480EB3D5  bl 0x82798f30
	ctx.lr = 0x826ADB60;
	sub_82798F30(ctx, base);
	// 826ADB60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826ADB64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ADB68: 38A0002A  li r5, 0x2a
	ctx.r[5].s64 = 42;
	// 826ADB6C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826ADB70: 4BC12869  bl 0x822c03d8
	ctx.lr = 0x826ADB74;
	sub_822C03D8(ctx, base);
	// 826ADB74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ADB78: 41820014  beq 0x826adb8c
	if ctx.cr[0].eq {
	pc = 0x826ADB8C; continue 'dispatch;
	}
	// 826ADB7C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826ADB80: 480EDAE9  bl 0x8279b668
	ctx.lr = 0x826ADB84;
	sub_8279B668(ctx, base);
	// 826ADB84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ADB88: 48000008  b 0x826adb90
	pc = 0x826ADB90; continue 'dispatch;
	// 826ADB8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826ADB90: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826ADB94: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 826ADB98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ADB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ADBA0: 4BEEA0B1  bl 0x82597c50
	ctx.lr = 0x826ADBA4;
	sub_82597C50(ctx, base);
	// 826ADBA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826ADBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ADBAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ADBB0: 4BC12451  bl 0x822c0000
	ctx.lr = 0x826ADBB4;
	sub_822C0000(ctx, base);
	// 826ADBB4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826ADBB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ADBBC: 419A0008  beq cr6, 0x826adbc4
	if ctx.cr[6].eq {
	pc = 0x826ADBC4; continue 'dispatch;
	}
	// 826ADBC0: 4BC12CD1  bl 0x822c0890
	ctx.lr = 0x826ADBC4;
	sub_822C0890(ctx, base);
	// 826ADBC4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826ADBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ADBCC: 419A0008  beq cr6, 0x826adbd4
	if ctx.cr[6].eq {
	pc = 0x826ADBD4; continue 'dispatch;
	}
	// 826ADBD0: 4BC12CC1  bl 0x822c0890
	ctx.lr = 0x826ADBD4;
	sub_822C0890(ctx, base);
	// 826ADBD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826ADBD8: 419A000C  beq cr6, 0x826adbe4
	if ctx.cr[6].eq {
	pc = 0x826ADBE4; continue 'dispatch;
	}
	// 826ADBDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ADBE0: 4BC12CB1  bl 0x822c0890
	ctx.lr = 0x826ADBE4;
	sub_822C0890(ctx, base);
	// 826ADBE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826ADBE8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826ADBEC: 48AFA5CC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ADBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826ADBF0 size=12
    let mut pc: u32 = 0x826ADBF0;
    'dispatch: loop {
        match pc {
            0x826ADBF0 => {
    //   block [0x826ADBF0..0x826ADBFC)
	// 826ADBF0: C00301C8  lfs f0, 0x1c8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADBF4: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826ADBF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ADC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826ADC00 size=12
    let mut pc: u32 = 0x826ADC00;
    'dispatch: loop {
        match pc {
            0x826ADC00 => {
    //   block [0x826ADC00..0x826ADC0C)
	// 826ADC00: C00301A0  lfs f0, 0x1a0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADC04: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826ADC08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ADC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ADC10 size=532
    let mut pc: u32 = 0x826ADC10;
    'dispatch: loop {
        match pc {
            0x826ADC10 => {
    //   block [0x826ADC10..0x826ADE24)
	// 826ADC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ADC14: 48AFA54D  bl 0x831a8160
	ctx.lr = 0x826ADC18;
	sub_831A8130(ctx, base);
	// 826ADC18: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 826ADC1C: 48AFAE59  bl 0x831a8a74
	ctx.lr = 0x826ADC20;
	sub_831A8A40(ctx, base);
	// 826ADC20: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ADC24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ADC28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826ADC2C: C19E00C0  lfs f12, 0xc0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826ADC30: C1AB0A90  lfs f13, 0xa90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ADC34: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 826ADC38: C01E00BC  lfs f0, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADC3C: D01E00C4  stfs f0, 0xc4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 826ADC40: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 826ADC44: 4099000C  ble cr6, 0x826adc50
	if !ctx.cr[6].gt {
	pc = 0x826ADC50; continue 'dispatch;
	}
	// 826ADC48: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826ADC4C: D1BE00C0  stfs f13, 0xc0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 826ADC50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826ADC54: 815E00F8  lwz r10, 0xf8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 826ADC58: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826ADC5C: C38B08A8  lfs f28, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826ADC60: 409A0048  bne cr6, 0x826adca8
	if !ctx.cr[6].eq {
	pc = 0x826ADCA8; continue 'dispatch;
	}
	// 826ADC64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826ADC68: C19E00C0  lfs f12, 0xc0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826ADC6C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826ADC70: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826ADC74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ADC78: C1AB7DF0  lfs f13, 0x7df0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ADC7C: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826ADC80: C00A2984  lfs f0, 0x2984(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADC84: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 826ADC88: C1A92530  lfs f13, 0x2530(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ADC8C: EC6BE03A  fmadds f3, f11, f0, f28
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 826ADC90: EC4C683A  fmadds f2, f12, f0, f13
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 826ADC94: EC2BE03A  fmadds f1, f11, f0, f28
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 826ADC98: 487CE2D9  bl 0x82e7bf70
	ctx.lr = 0x826ADC9C;
	sub_82E7BF70(ctx, base);
	// 826ADC9C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826ADCA0: 807E005C  lwz r3, 0x5c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 826ADCA4: 487655BD  bl 0x82e13260
	ctx.lr = 0x826ADCA8;
	sub_82E13260(ctx, base);
	// 826ADCA8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826ADCAC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826ADCB0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826ADCB4: 3CE08205  lis r7, -0x7dfb
	ctx.r[7].s64 = -2113601536;
	// 826ADCB8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826ADCBC: C36A9528  lfs f27, -0x6ad8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 826ADCC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826ADCC4: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826ADCC8: 3BBE0084  addi r29, r30, 0x84
	ctx.r[29].s64 = ctx.r[30].s64 + 132;
	// 826ADCCC: C3A89530  lfs f29, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826ADCD0: 3B7E00E0  addi r27, r30, 0xe0
	ctx.r[27].s64 = ctx.r[30].s64 + 224;
	// 826ADCD4: C3C7252C  lfs f30, 0x252c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826ADCD8: 3B8B6880  addi r28, r11, 0x6880
	ctx.r[28].s64 = ctx.r[11].s64 + 26752;
	// 826ADCDC: 7D7BF8AE  lbzx r11, r27, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 826ADCE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ADCE4: 41820080  beq 0x826add64
	if ctx.cr[0].eq {
	pc = 0x826ADD64; continue 'dispatch;
	}
	// 826ADCE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826ADCEC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADCF0: 48765571  bl 0x82e13260
	ctx.lr = 0x826ADCF4;
	sub_82E13260(ctx, base);
	// 826ADCF4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826ADCF8: 419A000C  beq cr6, 0x826add04
	if ctx.cr[6].eq {
	pc = 0x826ADD04; continue 'dispatch;
	}
	// 826ADCFC: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 826ADD00: 409A0030  bne cr6, 0x826add30
	if !ctx.cr[6].eq {
	pc = 0x826ADD30; continue 'dispatch;
	}
	// 826ADD04: C01E00C4  lfs f0, 0xc4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADD08: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ADD0C: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 826ADD10: 835D0000  lwz r26, 0(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADD14: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826ADD18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ADD1C: EC600772  fmuls f3, f0, f29
	ctx.f[3].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 826ADD20: 487CE2F9  bl 0x82e7c018
	ctx.lr = 0x826ADD24;
	sub_82E7C018(ctx, base);
	// 826ADD24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADD28: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826ADD2C: 48765535  bl 0x82e13260
	ctx.lr = 0x826ADD30;
	sub_82E13260(ctx, base);
	// 826ADD30: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 826ADD34: 419A000C  beq cr6, 0x826add40
	if ctx.cr[6].eq {
	pc = 0x826ADD40; continue 'dispatch;
	}
	// 826ADD38: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 826ADD3C: 409A004C  bne cr6, 0x826add88
	if !ctx.cr[6].eq {
	pc = 0x826ADD88; continue 'dispatch;
	}
	// 826ADD40: C01E00BC  lfs f0, 0xbc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADD44: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ADD48: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 826ADD4C: 835D0000  lwz r26, 0(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADD50: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826ADD54: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ADD58: EC600772  fmuls f3, f0, f29
	ctx.f[3].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 826ADD5C: 487CE2BD  bl 0x82e7c018
	ctx.lr = 0x826ADD60;
	sub_82E7C018(ctx, base);
	// 826ADD60: 4800001C  b 0x826add7c
	pc = 0x826ADD7C; continue 'dispatch;
	// 826ADD64: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ADD68: 835D0000  lwz r26, 0(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADD6C: FC60D890  fmr f3, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[27].f64;
	// 826ADD70: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 826ADD74: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 826ADD78: 487CE1F9  bl 0x82e7bf70
	ctx.lr = 0x826ADD7C;
	sub_82E7BF70(ctx, base);
	// 826ADD7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADD80: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826ADD84: 487654DD  bl 0x82e13260
	ctx.lr = 0x826ADD88;
	sub_82E13260(ctx, base);
	// 826ADD88: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826ADD8C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 826ADD90: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 826ADD94: 4198FF48  blt cr6, 0x826adcdc
	if ctx.cr[6].lt {
	pc = 0x826ADCDC; continue 'dispatch;
	}
	// 826ADD98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826ADD9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826ADDA0: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 826ADDA4: 3FA08212  lis r29, -0x7dee
	ctx.r[29].s64 = -2112749568;
	// 826ADDA8: C3CB9450  lfs f30, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826ADDAC: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 826ADDB0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826ADDB4: D3810064  stfs f28, 0x64(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826ADDB8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826ADDBC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 826ADDC0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826ADDC4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826ADDC8: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826ADDCC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826ADDD0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826ADDD4: C01DDFAC  lfs f0, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADDD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826ADDDC: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 826ADDE0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826ADDE4: EC2067B8  fmsubs f1, f0, f30, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 826ADDE8: 487CEE59  bl 0x82e7cc40
	ctx.lr = 0x826ADDEC;
	sub_82E7CC40(ctx, base);
	// 826ADDEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADDF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ADDF4: 487CE0A5  bl 0x82e7be98
	ctx.lr = 0x826ADDF8;
	sub_82E7BE98(ctx, base);
	// 826ADDF8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826ADDFC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADE00: 48765461  bl 0x82e13260
	ctx.lr = 0x826ADE04;
	sub_82E13260(ctx, base);
	// 826ADE04: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826ADE08: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826ADE0C: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 826ADE10: 4198FF9C  blt cr6, 0x826addac
	if ctx.cr[6].lt {
	pc = 0x826ADDAC; continue 'dispatch;
	}
	// 826ADE14: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 826ADE18: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 826ADE1C: 48AFACA5  bl 0x831a8ac0
	ctx.lr = 0x826ADE20;
	sub_831A8A8C(ctx, base);
	// 826ADE20: 48AFA390  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ADE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ADE28 size=196
    let mut pc: u32 = 0x826ADE28;
    'dispatch: loop {
        match pc {
            0x826ADE28 => {
    //   block [0x826ADE28..0x826ADEEC)
	// 826ADE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ADE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ADE30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ADE34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ADE38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ADE3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ADE40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ADE44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826ADE48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826ADE4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ADE50: 4BC12AE9  bl 0x822c0938
	ctx.lr = 0x826ADE54;
	sub_822C0938(ctx, base);
	// 826ADE54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ADE58: 41820028  beq 0x826ade80
	if ctx.cr[0].eq {
	pc = 0x826ADE80; continue 'dispatch;
	}
	// 826ADE5C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ADE60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826ADE64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826ADE68: 392B251C  addi r9, r11, 0x251c
	ctx.r[9].s64 = ctx.r[11].s64 + 9500;
	// 826ADE6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826ADE70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ADE74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826ADE78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826ADE7C: 48000008  b 0x826ade84
	pc = 0x826ADE84; continue 'dispatch;
	// 826ADE80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ADE84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ADE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ADE8C: 409A0044  bne cr6, 0x826aded0
	if !ctx.cr[6].eq {
	pc = 0x826ADED0; continue 'dispatch;
	}
	// 826ADE90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826ADE94: 419A001C  beq cr6, 0x826adeb0
	if ctx.cr[6].eq {
	pc = 0x826ADEB0; continue 'dispatch;
	}
	// 826ADE98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADE9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ADEA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ADEA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ADEAC: 4E800421  bctrl
	ctx.lr = 0x826ADEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ADEB0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826ADEB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826ADEB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ADEBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826ADEC0: 816BA518  lwz r11, -0x5ae8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23272 as u32) ) } as u64;
	// 826ADEC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826ADEC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826ADECC: 4BC12135  bl 0x822c0000
	ctx.lr = 0x826ADED0;
	sub_822C0000(ctx, base);
	// 826ADED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ADED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ADED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ADEDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ADEE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826ADEE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ADEE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ADEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ADEF0 size=676
    let mut pc: u32 = 0x826ADEF0;
    'dispatch: loop {
        match pc {
            0x826ADEF0 => {
    //   block [0x826ADEF0..0x826AE194)
	// 826ADEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ADEF4: 48AFA269  bl 0x831a815c
	ctx.lr = 0x826ADEF8;
	sub_831A8130(ctx, base);
	// 826ADEF8: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 826ADEFC: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 826ADF00: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 826ADF04: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ADF08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ADF0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826ADF10: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826ADF14: 3F808205  lis r28, -0x7dfb
	ctx.r[28].s64 = -2113601536;
	// 826ADF18: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 826ADF1C: C1BF01A4  lfs f13, 0x1a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ADF20: 83DF0138  lwz r30, 0x138(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826ADF24: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826ADF28: C3CA9450  lfs f30, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826ADF2C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826ADF30: C01C2514  lfs f0, 0x2514(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADF34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ADF38: EC4D07BC  fnmsubs f2, f13, f30, f0
	ctx.f[2].f64 = -(((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826ADF3C: 487CE0DD  bl 0x82e7c018
	ctx.lr = 0x826ADF40;
	sub_82E7C018(ctx, base);
	// 826ADF40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADF44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ADF48: 48765319  bl 0x82e13260
	ctx.lr = 0x826ADF4C;
	sub_82E13260(ctx, base);
	// 826ADF4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826ADF50: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826ADF54: 3BBF0148  addi r29, r31, 0x148
	ctx.r[29].s64 = ctx.r[31].s64 + 328;
	// 826ADF58: 3F608212  lis r27, -0x7dee
	ctx.r[27].s64 = -2112749568;
	// 826ADF5C: C3AB08A8  lfs f29, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826ADF60: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 826ADF64: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826ADF68: D3A10064  stfs f29, 0x64(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826ADF6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826ADF70: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 826ADF74: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 826ADF78: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826ADF7C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826ADF80: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826ADF84: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826ADF88: C01BDFAC  lfs f0, -0x2054(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADF8C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 826ADF90: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 826ADF94: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826ADF98: EC2067B8  fmsubs f1, f0, f30, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 826ADF9C: 487CECA5  bl 0x82e7cc40
	ctx.lr = 0x826ADFA0;
	sub_82E7CC40(ctx, base);
	// 826ADFA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADFA4: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 826ADFA8: 487CDEF1  bl 0x82e7be98
	ctx.lr = 0x826ADFAC;
	sub_82E7BE98(ctx, base);
	// 826ADFAC: C01C2514  lfs f0, 0x2514(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ADFB0: C1BF01A4  lfs f13, 0x1a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ADFB4: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 826ADFB8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826ADFBC: 3B410140  addi r26, r1, 0x140
	ctx.r[26].s64 = ctx.r[1].s64 + 320;
	// 826ADFC0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826ADFC4: EC4D07BC  fnmsubs f2, f13, f30, f0
	ctx.f[2].f64 = -(((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826ADFC8: 833D0000  lwz r25, 0(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ADFCC: 487CE04D  bl 0x82e7c018
	ctx.lr = 0x826ADFD0;
	sub_82E7C018(ctx, base);
	// 826ADFD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADFD4: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 826ADFD8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 826ADFDC: 4BC16925  bl 0x822c4900
	ctx.lr = 0x826ADFE0;
	sub_822C4900(ctx, base);
	// 826ADFE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ADFE4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826ADFE8: 48765279  bl 0x82e13260
	ctx.lr = 0x826ADFEC;
	sub_82E13260(ctx, base);
	// 826ADFEC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826ADFF0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 826ADFF4: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 826ADFF8: 4198FF68  blt cr6, 0x826adf60
	if ctx.cr[6].lt {
	pc = 0x826ADF60; continue 'dispatch;
	}
	// 826ADFFC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826AE000: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826AE004: 4BC3EF45  bl 0x822ecf48
	ctx.lr = 0x826AE008;
	sub_822ECF48(ctx, base);
	// 826AE008: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826AE00C: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826AE010: 4BC3F911  bl 0x822ed920
	ctx.lr = 0x826AE014;
	sub_822ED920(ctx, base);
	// 826AE014: 809F01D8  lwz r4, 0x1d8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 826AE018: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 826AE01C: 41980018  blt cr6, 0x826ae034
	if ctx.cr[6].lt {
	pc = 0x826AE034; continue 'dispatch;
	}
	// 826AE020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE024: 3BC10090  addi r30, r1, 0x90
	ctx.r[30].s64 = ctx.r[1].s64 + 144;
	// 826AE028: 4BE64099  bl 0x825120c0
	ctx.lr = 0x826AE02C;
	sub_825120C0(ctx, base);
	// 826AE02C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AE030: 4BDDE871  bl 0x8248c8a0
	ctx.lr = 0x826AE034;
	sub_8248C8A0(ctx, base);
	// 826AE034: 809F0100  lwz r4, 0x100(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826AE038: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826AE03C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AE040: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826AE044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AE048: 4E800421  bctrl
	ctx.lr = 0x826AE04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AE04C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826AE050: 809F0100  lwz r4, 0x100(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826AE054: 4BC3EF1D  bl 0x822ecf70
	ctx.lr = 0x826AE058;
	sub_822ECF70(ctx, base);
	// 826AE058: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826AE05C: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 826AE060: C1BF01A4  lfs f13, 0x1a4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826AE064: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 826AE068: C01C2514  lfs f0, 0x2514(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AE06C: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 826AE070: EC0D07BC  fnmsubs f0, f13, f30, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826AE074: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 826AE078: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826AE07C: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 826AE080: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826AE084: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 826AE088: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826AE08C: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 826AE090: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AE094: 38E10120  addi r7, r1, 0x120
	ctx.r[7].s64 = ctx.r[1].s64 + 288;
	// 826AE098: 13DB5C07  vcmpneb. (lvlx128) v30, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AE09C: 13BD5C07  vcmpneb. (lvlx128) v29, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AE0A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AE0A4: 139E5C07  vcmpneb. (lvlx128) v28, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AE0A8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826AE0AC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826AE0B0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AE198 size=136
    let mut pc: u32 = 0x826AE198;
    'dispatch: loop {
        match pc {
            0x826AE198 => {
    //   block [0x826AE198..0x826AE220)
	// 826AE198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AE1A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AE1A4: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826AE220 size=28
    let mut pc: u32 = 0x826AE220;
    'dispatch: loop {
        match pc {
            0x826AE220 => {
    //   block [0x826AE220..0x826AE23C)
	// 826AE220: 396301B0  addi r11, r3, 0x1b0
	ctx.r[11].s64 = ctx.r[3].s64 + 432;
	// 826AE224: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826AE228: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AE22C: 13C450C7  vcmpequd (lvx128) v30, v4, v10
	tmp.u32 = ctx.r[4].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AE240 size=444
    let mut pc: u32 = 0x826AE240;
    'dispatch: loop {
        match pc {
            0x826AE240 => {
    //   block [0x826AE240..0x826AE3FC)
	// 826AE240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE244: 48AF9F29  bl 0x831a816c
	ctx.lr = 0x826AE248;
	sub_831A8130(ctx, base);
	// 826AE248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AE24C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AE250: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 826AE254: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 826AE258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AE25C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 826AE260: 4BE64001  bl 0x82512260
	ctx.lr = 0x826AE264;
	sub_82512260(ctx, base);
	// 826AE264: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AE268: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AE26C: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826AE270: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AE274: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 826AE278: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826AE27C: 394A259C  addi r10, r10, 0x259c
	ctx.r[10].s64 = ctx.r[10].s64 + 9628;
	// 826AE280: 39292588  addi r9, r9, 0x2588
	ctx.r[9].s64 = ctx.r[9].s64 + 9608;
	// 826AE284: 3908253C  addi r8, r8, 0x253c
	ctx.r[8].s64 = ctx.r[8].s64 + 9532;
	// 826AE288: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826AE28C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AE290: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826AE294: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826AE298: 395F0108  addi r10, r31, 0x108
	ctx.r[10].s64 = ctx.r[31].s64 + 264;
	// 826AE29C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826AE2A0: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826AE2A4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826AE2A8: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826AE2AC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AE2B0: 915F0108  stw r10, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[10].u32 ) };
	// 826AE2B4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826AE2B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826AE2BC: 915F010C  stw r10, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[10].u32 ) };
	// 826AE2C0: 419A0024  beq cr6, 0x826ae2e4
	if ctx.cr[6].eq {
	pc = 0x826AE2E4; continue 'dispatch;
	}
	// 826AE2C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 826AE2C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826AE2CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AE2D0: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826AE2D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826AE2D8: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AE2DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AE2E0: 4082FFE8  bne 0x826ae2c8
	if !ctx.cr[0].eq {
	pc = 0x826AE2C8; continue 'dispatch;
	}
	// 826AE2E4: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826AE2E8: 395F0118  addi r10, r31, 0x118
	ctx.r[10].s64 = ctx.r[31].s64 + 280;
	// 826AE2EC: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826AE2F0: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 826AE2F4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AE2F8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826AE2FC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826AE300: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826AE304: 4080FFF0  bge 0x826ae2f4
	if !ctx.cr[0].lt {
	pc = 0x826AE2F4; continue 'dispatch;
	}
	// 826AE308: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 826AE30C: 395F0148  addi r10, r31, 0x148
	ctx.r[10].s64 = ctx.r[31].s64 + 328;
	// 826AE310: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 826AE314: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 826AE318: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 826AE31C: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 826AE320: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AE324: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826AE328: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826AE32C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826AE330: 4080FFF0  bge 0x826ae320
	if !ctx.cr[0].lt {
	pc = 0x826AE320; continue 'dispatch;
	}
	// 826AE334: 395F0168  addi r10, r31, 0x168
	ctx.r[10].s64 = ctx.r[31].s64 + 360;
	// 826AE338: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 826AE33C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AE340: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826AE344: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826AE348: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826AE34C: 4080FFF0  bge 0x826ae33c
	if !ctx.cr[0].lt {
	pc = 0x826AE33C; continue 'dispatch;
	}
	// 826AE350: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826AE354: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 826AE358: 57C92036  slwi r9, r30, 4
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 826AE35C: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826AE360: 394AA520  addi r10, r10, -0x5ae0
	ctx.r[10].s64 = ctx.r[10].s64 + -23264;
	// 826AE364: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 826AE368: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 826AE36C: 390001A0  li r8, 0x1a0
	ctx.r[8].s64 = 416;
	// 826AE370: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
	// 826AE374: 38C001B0  li r6, 0x1b0
	ctx.r[6].s64 = 432;
	// 826AE378: 38E76910  addi r7, r7, 0x6910
	ctx.r[7].s64 = ctx.r[7].s64 + 26896;
	// 826AE37C: 13E950C7  vcmpequd (lvx128) v31, v9, v10
	tmp.u32 = ctx.r[9].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AE380: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AE400 size=8
    let mut pc: u32 = 0x826AE400;
    'dispatch: loop {
        match pc {
            0x826AE400 => {
    //   block [0x826AE400..0x826AE408)
	// 826AE400: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826AE404: 480004F4  b 0x826ae8f8
	sub_826AE8F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AE408 size=8
    let mut pc: u32 = 0x826AE408;
    'dispatch: loop {
        match pc {
            0x826AE408 => {
    //   block [0x826AE408..0x826AE410)
	// 826AE408: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826AE40C: 480004EC  b 0x826ae8f8
	sub_826AE8F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AE410 size=360
    let mut pc: u32 = 0x826AE410;
    'dispatch: loop {
        match pc {
            0x826AE410 => {
    //   block [0x826AE410..0x826AE578)
	// 826AE410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE414: 48AF9D55  bl 0x831a8168
	ctx.lr = 0x826AE418;
	sub_831A8130(ctx, base);
	// 826AE418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AE41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AE420: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AE424: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AE428: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AE42C: 396B259C  addi r11, r11, 0x259c
	ctx.r[11].s64 = ctx.r[11].s64 + 9628;
	// 826AE430: 394A2588  addi r10, r10, 0x2588
	ctx.r[10].s64 = ctx.r[10].s64 + 9608;
	// 826AE434: 3929253C  addi r9, r9, 0x253c
	ctx.r[9].s64 = ctx.r[9].s64 + 9532;
	// 826AE438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AE43C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826AE440: 3B9F00E4  addi r28, r31, 0xe4
	ctx.r[28].s64 = ctx.r[31].s64 + 228;
	// 826AE444: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826AE448: 807F01E4  lwz r3, 0x1e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 826AE44C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE450: 419A0008  beq cr6, 0x826ae458
	if ctx.cr[6].eq {
	pc = 0x826AE458; continue 'dispatch;
	}
	// 826AE454: 4BC1243D  bl 0x822c0890
	ctx.lr = 0x826AE458;
	sub_822C0890(ctx, base);
	// 826AE458: 807F01D4  lwz r3, 0x1d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 826AE45C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE460: 419A0008  beq cr6, 0x826ae468
	if ctx.cr[6].eq {
	pc = 0x826AE468; continue 'dispatch;
	}
	// 826AE464: 4BC1242D  bl 0x822c0890
	ctx.lr = 0x826AE468;
	sub_822C0890(ctx, base);
	// 826AE468: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 826AE46C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE470: 419A0008  beq cr6, 0x826ae478
	if ctx.cr[6].eq {
	pc = 0x826AE478; continue 'dispatch;
	}
	// 826AE474: 4BC1241D  bl 0x822c0890
	ctx.lr = 0x826AE478;
	sub_822C0890(ctx, base);
	// 826AE478: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826AE47C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE480: 419A0008  beq cr6, 0x826ae488
	if ctx.cr[6].eq {
	pc = 0x826AE488; continue 'dispatch;
	}
	// 826AE484: 4BC1240D  bl 0x822c0890
	ctx.lr = 0x826AE488;
	sub_822C0890(ctx, base);
	// 826AE488: 397F0188  addi r11, r31, 0x188
	ctx.r[11].s64 = ctx.r[31].s64 + 392;
	// 826AE48C: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 826AE490: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826AE494: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826AE498: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AE49C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE4A0: 419A0008  beq cr6, 0x826ae4a8
	if ctx.cr[6].eq {
	pc = 0x826AE4A8; continue 'dispatch;
	}
	// 826AE4A4: 4BC123ED  bl 0x822c0890
	ctx.lr = 0x826AE4A8;
	sub_822C0890(ctx, base);
	// 826AE4A8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AE4AC: 4080FFE8  bge 0x826ae494
	if !ctx.cr[0].lt {
	pc = 0x826AE494; continue 'dispatch;
	}
	// 826AE4B0: 397F0168  addi r11, r31, 0x168
	ctx.r[11].s64 = ctx.r[31].s64 + 360;
	// 826AE4B4: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 826AE4B8: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826AE4BC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826AE4C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AE4C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE4C8: 419A0008  beq cr6, 0x826ae4d0
	if ctx.cr[6].eq {
	pc = 0x826AE4D0; continue 'dispatch;
	}
	// 826AE4CC: 4BC123C5  bl 0x822c0890
	ctx.lr = 0x826AE4D0;
	sub_822C0890(ctx, base);
	// 826AE4D0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AE4D4: 4080FFE8  bge 0x826ae4bc
	if !ctx.cr[0].lt {
	pc = 0x826AE4BC; continue 'dispatch;
	}
	// 826AE4D8: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826AE4DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE4E0: 419A0008  beq cr6, 0x826ae4e8
	if ctx.cr[6].eq {
	pc = 0x826AE4E8; continue 'dispatch;
	}
	// 826AE4E4: 4BC123AD  bl 0x822c0890
	ctx.lr = 0x826AE4E8;
	sub_822C0890(ctx, base);
	// 826AE4E8: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 826AE4EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE4F0: 419A0008  beq cr6, 0x826ae4f8
	if ctx.cr[6].eq {
	pc = 0x826AE4F8; continue 'dispatch;
	}
	// 826AE4F4: 4BC1239D  bl 0x822c0890
	ctx.lr = 0x826AE4F8;
	sub_822C0890(ctx, base);
	// 826AE4F8: 397F0138  addi r11, r31, 0x138
	ctx.r[11].s64 = ctx.r[31].s64 + 312;
	// 826AE4FC: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 826AE500: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826AE504: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826AE508: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AE50C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE510: 419A0008  beq cr6, 0x826ae518
	if ctx.cr[6].eq {
	pc = 0x826AE518; continue 'dispatch;
	}
	// 826AE514: 4BC1237D  bl 0x822c0890
	ctx.lr = 0x826AE518;
	sub_822C0890(ctx, base);
	// 826AE518: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AE51C: 4080FFE8  bge 0x826ae504
	if !ctx.cr[0].lt {
	pc = 0x826AE504; continue 'dispatch;
	}
	// 826AE520: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826AE524: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE528: 419A0008  beq cr6, 0x826ae530
	if ctx.cr[6].eq {
	pc = 0x826AE530; continue 'dispatch;
	}
	// 826AE52C: 4BC12365  bl 0x822c0890
	ctx.lr = 0x826AE530;
	sub_822C0890(ctx, base);
	// 826AE530: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 826AE534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE538: 419A0008  beq cr6, 0x826ae540
	if ctx.cr[6].eq {
	pc = 0x826AE540; continue 'dispatch;
	}
	// 826AE53C: 4BC12355  bl 0x822c0890
	ctx.lr = 0x826AE540;
	sub_822C0890(ctx, base);
	// 826AE540: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826AE544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE548: 419A0008  beq cr6, 0x826ae550
	if ctx.cr[6].eq {
	pc = 0x826AE550; continue 'dispatch;
	}
	// 826AE54C: 4BC12345  bl 0x822c0890
	ctx.lr = 0x826AE550;
	sub_822C0890(ctx, base);
	// 826AE550: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826AE554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AE558: 419A0008  beq cr6, 0x826ae560
	if ctx.cr[6].eq {
	pc = 0x826AE560; continue 'dispatch;
	}
	// 826AE55C: 4BC12335  bl 0x822c0890
	ctx.lr = 0x826AE560;
	sub_822C0890(ctx, base);
	// 826AE560: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826AE564: 480F90F5  bl 0x827a7658
	ctx.lr = 0x826AE568;
	sub_827A7658(ctx, base);
	// 826AE568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE56C: 4BCA0DE5  bl 0x8234f350
	ctx.lr = 0x826AE570;
	sub_8234F350(ctx, base);
	// 826AE570: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826AE574: 48AF9C44  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826AE578 size=616
    let mut pc: u32 = 0x826AE578;
    'dispatch: loop {
        match pc {
            0x826AE578 => {
    //   block [0x826AE578..0x826AE7E0)
	// 826AE578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE57C: 48AF9BF1  bl 0x831a816c
	ctx.lr = 0x826AE580;
	sub_831A8130(ctx, base);
	// 826AE580: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826AE584: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826AE588: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AE7E0 size=276
    let mut pc: u32 = 0x826AE7E0;
    'dispatch: loop {
        match pc {
            0x826AE7E0 => {
    //   block [0x826AE7E0..0x826AE8F4)
	// 826AE7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE7E4: 48AF9985  bl 0x831a8168
	ctx.lr = 0x826AE7E8;
	sub_831A8130(ctx, base);
	// 826AE7E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AE7EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826AE7F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AE7F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AE7F8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826AE7FC: 41820038  beq 0x826ae834
	if ctx.cr[0].eq {
	pc = 0x826AE834; continue 'dispatch;
	}
	// 826AE800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE804: 48AFB185  bl 0x831a9988
	ctx.lr = 0x826AE808;
	sub_831A9988(ctx, base);
	// 826AE808: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AE80C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AE810: 386BA664  addi r3, r11, -0x599c
	ctx.r[3].s64 = ctx.r[11].s64 + -22940;
	// 826AE814: 48AF98E5  bl 0x831a80f8
	ctx.lr = 0x826AE818;
	sub_831A80F8(ctx, base);
	// 826AE818: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AE81C: 41820018  beq 0x826ae834
	if ctx.cr[0].eq {
	pc = 0x826AE834; continue 'dispatch;
	}
	// 826AE820: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AE824: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AE828: 4BFFF9F9  bl 0x826ae220
	ctx.lr = 0x826AE82C;
	sub_826AE220(ctx, base);
	// 826AE82C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826AE830: 480000BC  b 0x826ae8ec
	pc = 0x826AE8EC; continue 'dispatch;
	// 826AE834: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AE838: 419A00A4  beq cr6, 0x826ae8dc
	if ctx.cr[6].eq {
	pc = 0x826AE8DC; continue 'dispatch;
	}
	// 826AE83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE840: 48AFB149  bl 0x831a9988
	ctx.lr = 0x826AE844;
	sub_831A9988(ctx, base);
	// 826AE844: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826AE848: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AE84C: 386BFAF0  addi r3, r11, -0x510
	ctx.r[3].s64 = ctx.r[11].s64 + -1296;
	// 826AE850: 48AF98A9  bl 0x831a80f8
	ctx.lr = 0x826AE854;
	sub_831A80F8(ctx, base);
	// 826AE854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AE858: 41820014  beq 0x826ae86c
	if ctx.cr[0].eq {
	pc = 0x826AE86C; continue 'dispatch;
	}
	// 826AE85C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AE860: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AE864: 4BFFF935  bl 0x826ae198
	ctx.lr = 0x826AE868;
	sub_826AE198(ctx, base);
	// 826AE868: 4BFFFFC4  b 0x826ae82c
	pc = 0x826AE82C; continue 'dispatch;
	// 826AE86C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AE870: 419A006C  beq cr6, 0x826ae8dc
	if ctx.cr[6].eq {
	pc = 0x826AE8DC; continue 'dispatch;
	}
	// 826AE874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE878: 48AFB111  bl 0x831a9988
	ctx.lr = 0x826AE87C;
	sub_831A9988(ctx, base);
	// 826AE87C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826AE880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AE884: 386B21D0  addi r3, r11, 0x21d0
	ctx.r[3].s64 = ctx.r[11].s64 + 8656;
	// 826AE888: 48AF9871  bl 0x831a80f8
	ctx.lr = 0x826AE88C;
	sub_831A80F8(ctx, base);
	// 826AE88C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AE890: 41820014  beq 0x826ae8a4
	if ctx.cr[0].eq {
	pc = 0x826AE8A4; continue 'dispatch;
	}
	// 826AE894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AE898: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AE89C: 4BFFF355  bl 0x826adbf0
	ctx.lr = 0x826AE8A0;
	sub_826ADBF0(ctx, base);
	// 826AE8A0: 4BFFFF8C  b 0x826ae82c
	pc = 0x826AE82C; continue 'dispatch;
	// 826AE8A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AE8A8: 419A0034  beq cr6, 0x826ae8dc
	if ctx.cr[6].eq {
	pc = 0x826AE8DC; continue 'dispatch;
	}
	// 826AE8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE8B0: 48AFB0D9  bl 0x831a9988
	ctx.lr = 0x826AE8B4;
	sub_831A9988(ctx, base);
	// 826AE8B4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826AE8B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AE8BC: 386BFA18  addi r3, r11, -0x5e8
	ctx.r[3].s64 = ctx.r[11].s64 + -1512;
	// 826AE8C0: 48AF9839  bl 0x831a80f8
	ctx.lr = 0x826AE8C4;
	sub_831A80F8(ctx, base);
	// 826AE8C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AE8C8: 41820014  beq 0x826ae8dc
	if ctx.cr[0].eq {
	pc = 0x826AE8DC; continue 'dispatch;
	}
	// 826AE8CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AE8D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826AE8D4: 4BFFF32D  bl 0x826adc00
	ctx.lr = 0x826AE8D8;
	sub_826ADC00(ctx, base);
	// 826AE8D8: 4BFFFF54  b 0x826ae82c
	pc = 0x826AE82C; continue 'dispatch;
	// 826AE8DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826AE8E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AE8E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AE8E8: 4BE63D31  bl 0x82512618
	ctx.lr = 0x826AE8EC;
	sub_82512618(ctx, base);
	// 826AE8EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826AE8F0: 48AF98C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AE8F8 size=76
    let mut pc: u32 = 0x826AE8F8;
    'dispatch: loop {
        match pc {
            0x826AE8F8 => {
    //   block [0x826AE8F8..0x826AE944)
	// 826AE8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AE900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AE904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AE908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AE90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AE910: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AE914: 4BFFFAFD  bl 0x826ae410
	ctx.lr = 0x826AE918;
	sub_826AE410(ctx, base);
	// 826AE918: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AE91C: 4182000C  beq 0x826ae928
	if ctx.cr[0].eq {
	pc = 0x826AE928; continue 'dispatch;
	}
	// 826AE920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE924: 48743AB5  bl 0x82df23d8
	ctx.lr = 0x826AE928;
	sub_82DF23D8(ctx, base);
	// 826AE928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AE92C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AE930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AE934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AE938: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AE93C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AE940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AE948 size=524
    let mut pc: u32 = 0x826AE948;
    'dispatch: loop {
        match pc {
            0x826AE948 => {
    //   block [0x826AE948..0x826AEB54)
	// 826AE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AE94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AE950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AE954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AE958: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826AE95C: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AE960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AE964: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AE968: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826AE96C: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826AE970: C3EB964C  lfs f31, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826AE974: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826AE978: 409A005C  bne cr6, 0x826ae9d4
	if !ctx.cr[6].eq {
	pc = 0x826AE9D4; continue 'dispatch;
	}
	// 826AE97C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826AE980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AE984: 388B4170  addi r4, r11, 0x4170
	ctx.r[4].s64 = ctx.r[11].s64 + 16752;
	// 826AE988: 48745081  bl 0x82df3a08
	ctx.lr = 0x826AE98C;
	sub_82DF3A08(ctx, base);
	// 826AE98C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AE990: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826AE994: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826AE998: 389F00C0  addi r4, r31, 0xc0
	ctx.r[4].s64 = ctx.r[31].s64 + 192;
	// 826AE99C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826AE9A0: C04B9F64  lfs f2, -0x609c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826AE9A4: C02A7DF0  lfs f1, 0x7df0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32240 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AE9A8: 4BEF4809  bl 0x825a31b0
	ctx.lr = 0x826AE9AC;
	sub_825A31B0(ctx, base);
	// 826AE9AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AE9B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AE9B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AE9B8: 4BEF2DB9  bl 0x825a1770
	ctx.lr = 0x826AE9BC;
	sub_825A1770(ctx, base);
	// 826AE9BC: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 826AE9C0: 48744A69  bl 0x82df3428
	ctx.lr = 0x826AE9C4;
	sub_82DF3428(ctx, base);
	// 826AE9C4: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 826AE9C8: 4BC1A2F1  bl 0x822c8cb8
	ctx.lr = 0x826AE9CC;
	sub_822C8CB8(ctx, base);
	// 826AE9CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AE9D0: 48744A59  bl 0x82df3428
	ctx.lr = 0x826AE9D4;
	sub_82DF3428(ctx, base);
	// 826AE9D4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AE9D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AE9DC: 388B261C  addi r4, r11, 0x261c
	ctx.r[4].s64 = ctx.r[11].s64 + 9756;
	// 826AE9E0: 48745029  bl 0x82df3a08
	ctx.lr = 0x826AE9E4;
	sub_82DF3A08(ctx, base);
	// 826AE9E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AE9E8: 389F00E4  addi r4, r31, 0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + 228;
	// 826AE9EC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826AE9F0: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 826AE9F4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826AE9F8: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826AE9FC: 4BEF47B5  bl 0x825a31b0
	ctx.lr = 0x826AEA00;
	sub_825A31B0(ctx, base);
	// 826AEA00: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AEA04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AEA08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEA0C: 4BEF2D65  bl 0x825a1770
	ctx.lr = 0x826AEA10;
	sub_825A1770(ctx, base);
	// 826AEA10: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 826AEA14: 48744A15  bl 0x82df3428
	ctx.lr = 0x826AEA18;
	sub_82DF3428(ctx, base);
	// 826AEA18: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 826AEA1C: 4BC1A29D  bl 0x822c8cb8
	ctx.lr = 0x826AEA20;
	sub_822C8CB8(ctx, base);
	// 826AEA20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEA24: 48744A05  bl 0x82df3428
	ctx.lr = 0x826AEA28;
	sub_82DF3428(ctx, base);
	// 826AEA28: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AEA2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEA30: 388B2610  addi r4, r11, 0x2610
	ctx.r[4].s64 = ctx.r[11].s64 + 9744;
	// 826AEA34: 48744FD5  bl 0x82df3a08
	ctx.lr = 0x826AEA38;
	sub_82DF3A08(ctx, base);
	// 826AEA38: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 826AEA3C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826AEA40: 4BEF4531  bl 0x825a2f70
	ctx.lr = 0x826AEA44;
	sub_825A2F70(ctx, base);
	// 826AEA44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AEA48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AEA4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEA50: 4BEF3739  bl 0x825a2188
	ctx.lr = 0x826AEA54;
	sub_825A2188(ctx, base);
	// 826AEA54: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826AEA58: 487449D1  bl 0x82df3428
	ctx.lr = 0x826AEA5C;
	sub_82DF3428(ctx, base);
	// 826AEA5C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826AEA60: 4BC1A259  bl 0x822c8cb8
	ctx.lr = 0x826AEA64;
	sub_822C8CB8(ctx, base);
	// 826AEA64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEA68: 487449C1  bl 0x82df3428
	ctx.lr = 0x826AEA6C;
	sub_82DF3428(ctx, base);
	// 826AEA6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AEA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEA74: 388B2604  addi r4, r11, 0x2604
	ctx.r[4].s64 = ctx.r[11].s64 + 9732;
	// 826AEA78: 48744F91  bl 0x82df3a08
	ctx.lr = 0x826AEA7C;
	sub_82DF3A08(ctx, base);
	// 826AEA7C: 389F00E1  addi r4, r31, 0xe1
	ctx.r[4].s64 = ctx.r[31].s64 + 225;
	// 826AEA80: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826AEA84: 4BEF44ED  bl 0x825a2f70
	ctx.lr = 0x826AEA88;
	sub_825A2F70(ctx, base);
	// 826AEA88: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AEA8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AEA90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEA94: 4BEF36F5  bl 0x825a2188
	ctx.lr = 0x826AEA98;
	sub_825A2188(ctx, base);
	// 826AEA98: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826AEA9C: 4874498D  bl 0x82df3428
	ctx.lr = 0x826AEAA0;
	sub_82DF3428(ctx, base);
	// 826AEAA0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826AEAA4: 4BC1A215  bl 0x822c8cb8
	ctx.lr = 0x826AEAA8;
	sub_822C8CB8(ctx, base);
	// 826AEAA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEAAC: 4874497D  bl 0x82df3428
	ctx.lr = 0x826AEAB0;
	sub_82DF3428(ctx, base);
	// 826AEAB0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AEAB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEAB8: 388B25F8  addi r4, r11, 0x25f8
	ctx.r[4].s64 = ctx.r[11].s64 + 9720;
	// 826AEABC: 48744F4D  bl 0x82df3a08
	ctx.lr = 0x826AEAC0;
	sub_82DF3A08(ctx, base);
	// 826AEAC0: 389F00E2  addi r4, r31, 0xe2
	ctx.r[4].s64 = ctx.r[31].s64 + 226;
	// 826AEAC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826AEAC8: 4BEF44A9  bl 0x825a2f70
	ctx.lr = 0x826AEACC;
	sub_825A2F70(ctx, base);
	// 826AEACC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AEAD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AEAD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEAD8: 4BEF36B1  bl 0x825a2188
	ctx.lr = 0x826AEADC;
	sub_825A2188(ctx, base);
	// 826AEADC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826AEAE0: 48744949  bl 0x82df3428
	ctx.lr = 0x826AEAE4;
	sub_82DF3428(ctx, base);
	// 826AEAE4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826AEAE8: 4BC1A1D1  bl 0x822c8cb8
	ctx.lr = 0x826AEAEC;
	sub_822C8CB8(ctx, base);
	// 826AEAEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEAF0: 48744939  bl 0x82df3428
	ctx.lr = 0x826AEAF4;
	sub_82DF3428(ctx, base);
	// 826AEAF4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AEAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEAFC: 388B25EC  addi r4, r11, 0x25ec
	ctx.r[4].s64 = ctx.r[11].s64 + 9708;
	// 826AEB00: 48744F09  bl 0x82df3a08
	ctx.lr = 0x826AEB04;
	sub_82DF3A08(ctx, base);
	// 826AEB04: 389F00E3  addi r4, r31, 0xe3
	ctx.r[4].s64 = ctx.r[31].s64 + 227;
	// 826AEB08: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826AEB0C: 4BEF4465  bl 0x825a2f70
	ctx.lr = 0x826AEB10;
	sub_825A2F70(ctx, base);
	// 826AEB10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826AEB14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AEB18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEB1C: 4BEF366D  bl 0x825a2188
	ctx.lr = 0x826AEB20;
	sub_825A2188(ctx, base);
	// 826AEB20: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826AEB24: 48744905  bl 0x82df3428
	ctx.lr = 0x826AEB28;
	sub_82DF3428(ctx, base);
	// 826AEB28: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826AEB2C: 4BC1A18D  bl 0x822c8cb8
	ctx.lr = 0x826AEB30;
	sub_822C8CB8(ctx, base);
	// 826AEB30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEB34: 487448F5  bl 0x82df3428
	ctx.lr = 0x826AEB38;
	sub_82DF3428(ctx, base);
	// 826AEB38: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 826AEB3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEB40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEB44: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826AEB48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AEB4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEB50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AEB58 size=552
    let mut pc: u32 = 0x826AEB58;
    'dispatch: loop {
        match pc {
            0x826AEB58 => {
    //   block [0x826AEB58..0x826AED80)
	// 826AEB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEB5C: 48AF9605  bl 0x831a8160
	ctx.lr = 0x826AEB60;
	sub_831A8130(ctx, base);
	// 826AEB60: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEB64: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AEB68: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826AEB6C: 3BCB2628  addi r30, r11, 0x2628
	ctx.r[30].s64 = ctx.r[11].s64 + 9768;
	// 826AEB70: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826AEB74: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 826AEB78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AEB7C: 38A000AD  li r5, 0xad
	ctx.r[5].s64 = 173;
	// 826AEB80: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 826AEB84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AEB88: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 826AEB8C: 4874385D  bl 0x82df23e8
	ctx.lr = 0x826AEB90;
	sub_82DF23E8(ctx, base);
	// 826AEB90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AEB94: 41820018  beq 0x826aebac
	if ctx.cr[0].eq {
	pc = 0x826AEBAC; continue 'dispatch;
	}
	// 826AEB98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826AEB9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEBA0: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 826AEBA4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AEBA8: 48000008  b 0x826aebb0
	pc = 0x826AEBB0; continue 'dispatch;
	// 826AEBAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AEBB0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826AEBB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AEBB8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826AEBBC: 4BF3C7BD  bl 0x825eb378
	ctx.lr = 0x826AEBC0;
	sub_825EB378(ctx, base);
	// 826AEBC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AEBC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AEBC8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826AEBCC: 4BC11435  bl 0x822c0000
	ctx.lr = 0x826AEBD0;
	sub_822C0000(ctx, base);
	// 826AEBD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AEBD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AEBD8: 38A000AE  li r5, 0xae
	ctx.r[5].s64 = 174;
	// 826AEBDC: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 826AEBE0: 48743809  bl 0x82df23e8
	ctx.lr = 0x826AEBE4;
	sub_82DF23E8(ctx, base);
	// 826AEBE4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826AEBE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AEBEC: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 826AEBF0: 41820024  beq 0x826aec14
	if ctx.cr[0].eq {
	pc = 0x826AEC14; continue 'dispatch;
	}
	// 826AEBF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826AEBF8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 826AEBFC: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 826AEC00: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826AEC04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AEC08: 4BFFF639  bl 0x826ae240
	ctx.lr = 0x826AEC0C;
	sub_826AE240(ctx, base);
	// 826AEC0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEC10: 48000008  b 0x826aec18
	pc = 0x826AEC18; continue 'dispatch;
	// 826AEC14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AEC18: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826AEC1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AEC20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826AEC24: 4BFFF205  bl 0x826ade28
	ctx.lr = 0x826AEC28;
	sub_826ADE28(ctx, base);
	// 826AEC28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AEC2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AEC30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826AEC34: 4BC113CD  bl 0x822c0000
	ctx.lr = 0x826AEC38;
	sub_822C0000(ctx, base);
	// 826AEC38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826AEC3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AEC40: 38A000AF  li r5, 0xaf
	ctx.r[5].s64 = 175;
	// 826AEC44: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826AEC48: 4BC11791  bl 0x822c03d8
	ctx.lr = 0x826AEC4C;
	sub_822C03D8(ctx, base);
	// 826AEC4C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826AEC50: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826AEC54: 418200B0  beq 0x826aed04
	if ctx.cr[0].eq {
	pc = 0x826AED04; continue 'dispatch;
	}
	// 826AEC58: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826AEC5C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 826AEC60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826AEC64: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826AEC68: 409A0008  bne cr6, 0x826aec70
	if !ctx.cr[6].eq {
	pc = 0x826AEC70; continue 'dispatch;
	}
	// 826AEC6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AEC70: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826AEC74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AEC78: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826AEC7C: 419A0024  beq cr6, 0x826aeca0
	if ctx.cr[6].eq {
	pc = 0x826AECA0; continue 'dispatch;
	}
	// 826AEC80: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AEC84: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826AEC88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AEC8C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826AEC90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826AEC94: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AEC98: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AEC9C: 4082FFE8  bne 0x826aec84
	if !ctx.cr[0].eq {
	pc = 0x826AEC84; continue 'dispatch;
	}
	// 826AECA0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 826AECA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AECA8: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 826AECAC: 419A0024  beq cr6, 0x826aecd0
	if ctx.cr[6].eq {
	pc = 0x826AECD0; continue 'dispatch;
	}
	// 826AECB0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826AECB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AECB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AECBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AECC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AECC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AECC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AECCC: 4082FFE8  bne 0x826aecb4
	if !ctx.cr[0].eq {
	pc = 0x826AECB4; continue 'dispatch;
	}
	// 826AECD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826AECD4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 826AECD8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826AECDC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826AECE0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826AECE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AECE8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AECEC: 480EA245  bl 0x82798f30
	ctx.lr = 0x826AECF0;
	sub_82798F30(ctx, base);
	// 826AECF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AECF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AECF8: 480EC971  bl 0x8279b668
	ctx.lr = 0x826AECFC;
	sub_8279B668(ctx, base);
	// 826AECFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AED00: 48000008  b 0x826aed08
	pc = 0x826AED08; continue 'dispatch;
	// 826AED04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826AED08: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826AED0C: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826AED10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AED14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AED18: 4BEE8F39  bl 0x82597c50
	ctx.lr = 0x826AED1C;
	sub_82597C50(ctx, base);
	// 826AED1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AED20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AED24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AED28: 4BC112D9  bl 0x822c0000
	ctx.lr = 0x826AED2C;
	sub_822C0000(ctx, base);
	// 826AED2C: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826AED30: 41820024  beq 0x826aed54
	if ctx.cr[0].eq {
	pc = 0x826AED54; continue 'dispatch;
	}
	// 826AED34: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826AED38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AED3C: 419A0008  beq cr6, 0x826aed44
	if ctx.cr[6].eq {
	pc = 0x826AED44; continue 'dispatch;
	}
	// 826AED40: 4BC11B51  bl 0x822c0890
	ctx.lr = 0x826AED44;
	sub_822C0890(ctx, base);
	// 826AED44: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826AED48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AED4C: 419A0008  beq cr6, 0x826aed54
	if ctx.cr[6].eq {
	pc = 0x826AED54; continue 'dispatch;
	}
	// 826AED50: 4BC11B41  bl 0x822c0890
	ctx.lr = 0x826AED54;
	sub_822C0890(ctx, base);
	// 826AED54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826AED58: 419A000C  beq cr6, 0x826aed64
	if ctx.cr[6].eq {
	pc = 0x826AED64; continue 'dispatch;
	}
	// 826AED5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826AED60: 4BC11B31  bl 0x822c0890
	ctx.lr = 0x826AED64;
	sub_822C0890(ctx, base);
	// 826AED64: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826AED68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AED6C: 419A0008  beq cr6, 0x826aed74
	if ctx.cr[6].eq {
	pc = 0x826AED74; continue 'dispatch;
	}
	// 826AED70: 4BC11B21  bl 0x822c0890
	ctx.lr = 0x826AED74;
	sub_822C0890(ctx, base);
	// 826AED74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826AED78: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 826AED7C: 48AF9434  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AED80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AED80 size=52
    let mut pc: u32 = 0x826AED80;
    'dispatch: loop {
        match pc {
            0x826AED80 => {
    //   block [0x826AED80..0x826AEDB4)
	// 826AED80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AED84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AED88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AED8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AED90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826AED94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AED98: 4BFFFDC1  bl 0x826aeb58
	ctx.lr = 0x826AED9C;
	sub_826AEB58(ctx, base);
	// 826AED9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEDA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEDA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEDA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEDAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEDB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AEDB8 size=52
    let mut pc: u32 = 0x826AEDB8;
    'dispatch: loop {
        match pc {
            0x826AEDB8 => {
    //   block [0x826AEDB8..0x826AEDEC)
	// 826AEDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AEDC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AEDC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEDC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AEDCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEDD0: 4BFFFD89  bl 0x826aeb58
	ctx.lr = 0x826AEDD4;
	sub_826AEB58(ctx, base);
	// 826AEDD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEDD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEDDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEDE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEDE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEDE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AEDF0 size=52
    let mut pc: u32 = 0x826AEDF0;
    'dispatch: loop {
        match pc {
            0x826AEDF0 => {
    //   block [0x826AEDF0..0x826AEE24)
	// 826AEDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AEDF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AEDFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEE00: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826AEE04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEE08: 4BFFFD51  bl 0x826aeb58
	ctx.lr = 0x826AEE0C;
	sub_826AEB58(ctx, base);
	// 826AEE0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEE10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEE14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEE18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEE1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AEE28 size=52
    let mut pc: u32 = 0x826AEE28;
    'dispatch: loop {
        match pc {
            0x826AEE28 => {
    //   block [0x826AEE28..0x826AEE5C)
	// 826AEE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AEE30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AEE34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEE38: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826AEE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEE40: 4BFFFD19  bl 0x826aeb58
	ctx.lr = 0x826AEE44;
	sub_826AEB58(ctx, base);
	// 826AEE44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEE48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEE4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEE50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEE54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEE58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AEE60 size=52
    let mut pc: u32 = 0x826AEE60;
    'dispatch: loop {
        match pc {
            0x826AEE60 => {
    //   block [0x826AEE60..0x826AEE94)
	// 826AEE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEE64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AEE68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AEE6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEE70: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826AEE74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEE78: 4BFFFCE1  bl 0x826aeb58
	ctx.lr = 0x826AEE7C;
	sub_826AEB58(ctx, base);
	// 826AEE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEE80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEE84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEE88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AEE98 size=52
    let mut pc: u32 = 0x826AEE98;
    'dispatch: loop {
        match pc {
            0x826AEE98 => {
    //   block [0x826AEE98..0x826AEECC)
	// 826AEE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AEEA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AEEA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEEA8: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826AEEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEEB0: 4BFFFCA9  bl 0x826aeb58
	ctx.lr = 0x826AEEB4;
	sub_826AEB58(ctx, base);
	// 826AEEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEEB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEEBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEEC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEEC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AEED0 size=52
    let mut pc: u32 = 0x826AEED0;
    'dispatch: loop {
        match pc {
            0x826AEED0 => {
    //   block [0x826AEED0..0x826AEF04)
	// 826AEED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AEED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AEEDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEEE0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826AEEE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEEE8: 4BFFFC71  bl 0x826aeb58
	ctx.lr = 0x826AEEEC;
	sub_826AEB58(ctx, base);
	// 826AEEEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AEEF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826AEEF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AEEF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AEEFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AEF00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AEF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AEF08 size=3996
    let mut pc: u32 = 0x826AEF08;
    'dispatch: loop {
        match pc {
            0x826AEF08 => {
    //   block [0x826AEF08..0x826AFEA4)
	// 826AEF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AEF0C: 48AF9225  bl 0x831a8130
	ctx.lr = 0x826AEF10;
	sub_831A8130(ctx, base);
	// 826AEF10: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 826AEF14: 48AF9B5D  bl 0x831a8a70
	ctx.lr = 0x826AEF18;
	sub_831A8A40(ctx, base);
	// 826AEF18: 9421FAB0  stwu r1, -0x550(r1)
	ea = ctx.r[1].u32.wrapping_add(-1360 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AEF1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AEF20: 9081056C  stw r4, 0x56c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1388 as u32), ctx.r[4].u32 ) };
	// 826AEF24: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826AEF28: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 826AEF2C: 4BE62AAD  bl 0x825119d8
	ctx.lr = 0x826AEF30;
	sub_825119D8(ctx, base);
	// 826AEF30: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826AEF34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEF38: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826AEF3C: 48744ACD  bl 0x82df3a08
	ctx.lr = 0x826AEF40;
	sub_82DF3A08(ctx, base);
	// 826AEF40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826AEF44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826AEF48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEF4C: 4BE59835  bl 0x82508780
	ctx.lr = 0x826AEF50;
	sub_82508780(ctx, base);
	// 826AEF50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEF54: 487444D5  bl 0x82df3428
	ctx.lr = 0x826AEF58;
	sub_82DF3428(ctx, base);
	// 826AEF58: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 826AEF5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826AEF60: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826AEF64: 409A0008  bne cr6, 0x826aef6c
	if !ctx.cr[6].eq {
	pc = 0x826AEF6C; continue 'dispatch;
	}
	// 826AEF68: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AEF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AEF70: 4BE59831  bl 0x825087a0
	ctx.lr = 0x826AEF74;
	sub_825087A0(ctx, base);
	// 826AEF74: 92410098  stw r18, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[18].u32 ) };
	// 826AEF78: 9241009C  stw r18, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[18].u32 ) };
	// 826AEF7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AEF80: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AEF84: 4877BB65  bl 0x82e2aae8
	ctx.lr = 0x826AEF88;
	sub_82E2AAE8(ctx, base);
	// 826AEF88: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AEF8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEF90: 3B4BA4E0  addi r26, r11, -0x5b20
	ctx.r[26].s64 = ctx.r[11].s64 + -23328;
	// 826AEF94: 817F01DC  lwz r11, 0x1dc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 826AEF98: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826AEF9C: 7C8BD02E  lwzx r4, r11, r26
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 826AEFA0: 48744A69  bl 0x82df3a08
	ctx.lr = 0x826AEFA4;
	sub_82DF3A08(ctx, base);
	// 826AEFA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AEFA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AEFAC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826AEFB0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826AEFB4: 4877FEBD  bl 0x82e2ee70
	ctx.lr = 0x826AEFB8;
	sub_82E2EE70(ctx, base);
	// 826AEFB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AEFBC: 4874446D  bl 0x82df3428
	ctx.lr = 0x826AEFC0;
	sub_82DF3428(ctx, base);
	// 826AEFC0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AEFC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AEFC8: 3AAB2628  addi r21, r11, 0x2628
	ctx.r[21].s64 = ctx.r[11].s64 + 9768;
	// 826AEFCC: 38A000E6  li r5, 0xe6
	ctx.r[5].s64 = 230;
	// 826AEFD0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826AEFD4: 92A10090  stw r21, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[21].u32 ) };
	// 826AEFD8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826AEFDC: 4874340D  bl 0x82df23e8
	ctx.lr = 0x826AEFE0;
	sub_82DF23E8(ctx, base);
	// 826AEFE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AEFE4: 41820014  beq 0x826aeff8
	if ctx.cr[0].eq {
	pc = 0x826AEFF8; continue 'dispatch;
	}
	// 826AEFE8: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 826AEFEC: 487678A5  bl 0x82e16890
	ctx.lr = 0x826AEFF0;
	sub_82E16890(ctx, base);
	// 826AEFF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AEFF4: 48000008  b 0x826aeffc
	pc = 0x826AEFFC; continue 'dispatch;
	// 826AEFF8: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AEFFC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826AF000: 4BCAE371  bl 0x8235d370
	ctx.lr = 0x826AF004;
	sub_8235D370(ctx, base);
	// 826AF004: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826AF008: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AF00C: 38A000E7  li r5, 0xe7
	ctx.r[5].s64 = 231;
	// 826AF010: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AF014: 487433D5  bl 0x82df23e8
	ctx.lr = 0x826AF018;
	sub_82DF23E8(ctx, base);
	// 826AF018: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826AF01C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AF020: 3B6B6880  addi r27, r11, 0x6880
	ctx.r[27].s64 = ctx.r[11].s64 + 26752;
	// 826AF024: 41820014  beq 0x826af038
	if ctx.cr[0].eq {
	pc = 0x826AF038; continue 'dispatch;
	}
	// 826AF028: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AF02C: 487640C5  bl 0x82e130f0
	ctx.lr = 0x826AF030;
	sub_82E130F0(ctx, base);
	// 826AF030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AF034: 48000008  b 0x826af03c
	pc = 0x826AF03C; continue 'dispatch;
	// 826AF038: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AF03C: 3BDF0138  addi r30, r31, 0x138
	ctx.r[30].s64 = ctx.r[31].s64 + 312;
	// 826AF040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AF044: 4BC32D0D  bl 0x822e1d50
	ctx.lr = 0x826AF048;
	sub_822E1D50(ctx, base);
	// 826AF048: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AF04C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826AF050: 83BF0138  lwz r29, 0x138(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826AF054: 4BE630C5  bl 0x82512118
	ctx.lr = 0x826AF058;
	sub_82512118(ctx, base);
	// 826AF058: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826AF05C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF060: 48763DD1  bl 0x82e12e30
	ctx.lr = 0x826AF064;
	sub_82E12E30(ctx, base);
	// 826AF064: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 826AF068: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AF06C: 419A0008  beq cr6, 0x826af074
	if ctx.cr[6].eq {
	pc = 0x826AF074; continue 'dispatch;
	}
	// 826AF070: 4BC11821  bl 0x822c0890
	ctx.lr = 0x826AF074;
	sub_822C0890(ctx, base);
	// 826AF074: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826AF078: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AF07C: 38A000E9  li r5, 0xe9
	ctx.r[5].s64 = 233;
	// 826AF080: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AF084: 48743365  bl 0x82df23e8
	ctx.lr = 0x826AF088;
	sub_82DF23E8(ctx, base);
	// 826AF088: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AF08C: 41820014  beq 0x826af0a0
	if ctx.cr[0].eq {
	pc = 0x826AF0A0; continue 'dispatch;
	}
	// 826AF090: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AF094: 4876405D  bl 0x82e130f0
	ctx.lr = 0x826AF098;
	sub_82E130F0(ctx, base);
	// 826AF098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AF09C: 48000008  b 0x826af0a4
	pc = 0x826AF0A4; continue 'dispatch;
	// 826AF0A0: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AF0A4: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 826AF0A8: 4BC32CA9  bl 0x822e1d50
	ctx.lr = 0x826AF0AC;
	sub_822E1D50(ctx, base);
	// 826AF0AC: 809F0140  lwz r4, 0x140(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826AF0B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF0B4: 48763D7D  bl 0x82e12e30
	ctx.lr = 0x826AF0B8;
	sub_82E12E30(ctx, base);
	// 826AF0B8: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826AF0BC: 815F0140  lwz r10, 0x140(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826AF0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AF0C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826AF0C8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826AF0CC: 419A0024  beq cr6, 0x826af0f0
	if ctx.cr[6].eq {
	pc = 0x826AF0F0; continue 'dispatch;
	}
	// 826AF0D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AF0D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AF0D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AF0DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AF0E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AF0E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AF0E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AF0EC: 4082FFE8  bne 0x826af0d4
	if !ctx.cr[0].eq {
	pc = 0x826AF0D4; continue 'dispatch;
	}
	// 826AF0F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826AF0F4: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 826AF0F8: 48765FB9  bl 0x82e150b0
	ctx.lr = 0x826AF0FC;
	sub_82E150B0(ctx, base);
	// 826AF0FC: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826AF100: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826AF104: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 826AF108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AF10C: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826AF110: 4BE61A49  bl 0x82510b58
	ctx.lr = 0x826AF114;
	sub_82510B58(ctx, base);
	// 826AF114: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 826AF118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AF11C: 419A0008  beq cr6, 0x826af124
	if ctx.cr[6].eq {
	pc = 0x826AF124; continue 'dispatch;
	}
	// 826AF120: 4BC11771  bl 0x822c0890
	ctx.lr = 0x826AF124;
	sub_822C0890(ctx, base);
	// 826AF124: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AF128: 4877B9D9  bl 0x82e2ab00
	ctx.lr = 0x826AF12C;
	sub_82E2AB00(ctx, base);
	// 826AF12C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AF130: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AF134: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826AF138: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 826AF13C: 3BDF0148  addi r30, r31, 0x148
	ctx.r[30].s64 = ctx.r[31].s64 + 328;
	// 826AF140: C34B9450  lfs f26, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 826AF144: 3F008212  lis r24, -0x7dee
	ctx.r[24].s64 = -2112749568;
	// 826AF148: C36A08A8  lfs f27, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 826AF14C: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826AF150: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AF154: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF158: 4877B991  bl 0x82e2aae8
	ctx.lr = 0x826AF15C;
	sub_82E2AAE8(ctx, base);
	// 826AF15C: 815F01DC  lwz r10, 0x1dc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 826AF160: 397A001C  addi r11, r26, 0x1c
	ctx.r[11].s64 = ctx.r[26].s64 + 28;
	// 826AF164: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826AF168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AF16C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826AF170: 48744899  bl 0x82df3a08
	ctx.lr = 0x826AF174;
	sub_82DF3A08(ctx, base);
	// 826AF174: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AF178: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826AF17C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826AF180: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826AF184: 4877FCED  bl 0x82e2ee70
	ctx.lr = 0x826AF188;
	sub_82E2EE70(ctx, base);
	// 826AF188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AF18C: 4874429D  bl 0x82df3428
	ctx.lr = 0x826AF190;
	sub_82DF3428(ctx, base);
	// 826AF190: 924100B0  stw r18, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[18].u32 ) };
	// 826AF194: 924100B4  stw r18, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[18].u32 ) };
	// 826AF198: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826AF19C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AF1A0: 38A000F7  li r5, 0xf7
	ctx.r[5].s64 = 247;
	// 826AF1A4: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826AF1A8: 48743241  bl 0x82df23e8
	ctx.lr = 0x826AF1AC;
	sub_82DF23E8(ctx, base);
	// 826AF1AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AF1B0: 41820014  beq 0x826af1c4
	if ctx.cr[0].eq {
	pc = 0x826AF1C4; continue 'dispatch;
	}
	// 826AF1B4: 388100D8  addi r4, r1, 0xd8
	ctx.r[4].s64 = ctx.r[1].s64 + 216;
	// 826AF1B8: 487676D9  bl 0x82e16890
	ctx.lr = 0x826AF1BC;
	sub_82E16890(ctx, base);
	// 826AF1BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AF1C0: 48000008  b 0x826af1c8
	pc = 0x826AF1C8; continue 'dispatch;
	// 826AF1C4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AF1C8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826AF1CC: 4BCAE1A5  bl 0x8235d370
	ctx.lr = 0x826AF1D0;
	sub_8235D370(ctx, base);
	// 826AF1D0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826AF1D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AF1D8: 38A000F9  li r5, 0xf9
	ctx.r[5].s64 = 249;
	// 826AF1DC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AF1E0: 48743209  bl 0x82df23e8
	ctx.lr = 0x826AF1E4;
	sub_82DF23E8(ctx, base);
	// 826AF1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AF1E8: 41820014  beq 0x826af1fc
	if ctx.cr[0].eq {
	pc = 0x826AF1FC; continue 'dispatch;
	}
	// 826AF1EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AF1F0: 48763F01  bl 0x82e130f0
	ctx.lr = 0x826AF1F4;
	sub_82E130F0(ctx, base);
	// 826AF1F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AF1F8: 48000008  b 0x826af200
	pc = 0x826AF200; continue 'dispatch;
	// 826AF1FC: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AF200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AF204: 4BC32B4D  bl 0x822e1d50
	ctx.lr = 0x826AF208;
	sub_822E1D50(ctx, base);
	// 826AF208: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 826AF20C: D3E100E0  stfs f31, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 826AF210: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 826AF214: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 826AF218: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 826AF21C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826AF220: D36100E4  stfs f27, 0xe4(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 826AF224: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826AF228: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 826AF22C: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 826AF230: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826AF234: C018DFAC  lfs f0, -0x2054(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AF238: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826AF23C: EC2006B2  fmuls f1, f0, f26
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 826AF240: 487CDA01  bl 0x82e7cc40
	ctx.lr = 0x826AF244;
	sub_82E7CC40(ctx, base);
	// 826AF244: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AF248: 38610380  addi r3, r1, 0x380
	ctx.r[3].s64 = ctx.r[1].s64 + 896;
	// 826AF24C: 487CCC4D  bl 0x82e7be98
	ctx.lr = 0x826AF250;
	sub_82E7BE98(ctx, base);
	// 826AF250: 38810380  addi r4, r1, 0x380
	ctx.r[4].s64 = ctx.r[1].s64 + 896;
	// 826AF254: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF258: 48764009  bl 0x82e13260
	ctx.lr = 0x826AF25C;
	sub_82E13260(ctx, base);
	// 826AF25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826AF260: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826AF264: 82FE0000  lwz r23, 0(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF268: 4BE62EB1  bl 0x82512118
	ctx.lr = 0x826AF26C;
	sub_82512118(ctx, base);
	// 826AF26C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826AF270: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF274: 48763BBD  bl 0x82e12e30
	ctx.lr = 0x826AF278;
	sub_82E12E30(ctx, base);
	// 826AF278: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 826AF27C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AF280: 419A0008  beq cr6, 0x826af288
	if ctx.cr[6].eq {
	pc = 0x826AF288; continue 'dispatch;
	}
	// 826AF284: 4BC1160D  bl 0x822c0890
	ctx.lr = 0x826AF288;
	sub_822C0890(ctx, base);
	// 826AF288: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826AF28C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826AF290: 38A000FE  li r5, 0xfe
	ctx.r[5].s64 = 254;
	// 826AF294: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826AF298: 48743151  bl 0x82df23e8
	ctx.lr = 0x826AF29C;
	sub_82DF23E8(ctx, base);
	// 826AF29C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AF2A0: 41820014  beq 0x826af2b4
	if ctx.cr[0].eq {
	pc = 0x826AF2B4; continue 'dispatch;
	}
	// 826AF2A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826AF2A8: 48763E49  bl 0x82e130f0
	ctx.lr = 0x826AF2AC;
	sub_82E130F0(ctx, base);
	// 826AF2AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AF2B0: 48000008  b 0x826af2b8
	pc = 0x826AF2B8; continue 'dispatch;
	// 826AF2B4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 826AF2B8: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 826AF2BC: 4BC32A95  bl 0x822e1d50
	ctx.lr = 0x826AF2C0;
	sub_822E1D50(ctx, base);
	// 826AF2C0: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 826AF2C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF2C8: 48763B69  bl 0x82e12e30
	ctx.lr = 0x826AF2CC;
	sub_82E12E30(ctx, base);
	// 826AF2CC: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 826AF2D0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 826AF2D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AF2D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826AF2DC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826AF2E0: 419A0024  beq cr6, 0x826af304
	if ctx.cr[6].eq {
	pc = 0x826AF304; continue 'dispatch;
	}
	// 826AF2E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826AF2E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826AF2EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AF2F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826AF2F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826AF2F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826AF2FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826AF300: 4082FFE8  bne 0x826af2e8
	if !ctx.cr[0].eq {
	pc = 0x826AF2E8; continue 'dispatch;
	}
	// 826AF304: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826AF308: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 826AF30C: 48765DA5  bl 0x82e150b0
	ctx.lr = 0x826AF310;
	sub_82E150B0(ctx, base);
	// 826AF310: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826AF314: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 826AF318: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826AF31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AF320: 4BE61839  bl 0x82510b58
	ctx.lr = 0x826AF324;
	sub_82510B58(ctx, base);
	// 826AF324: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 826AF328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AF32C: 419A0008  beq cr6, 0x826af334
	if ctx.cr[6].eq {
	pc = 0x826AF334; continue 'dispatch;
	}
	// 826AF330: 4BC11561  bl 0x822c0890
	ctx.lr = 0x826AF334;
	sub_822C0890(ctx, base);
	// 826AF334: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 826AF338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826AF33C: 419A0008  beq cr6, 0x826af344
	if ctx.cr[6].eq {
	pc = 0x826AF344; continue 'dispatch;
	}
	// 826AF340: 4BC11551  bl 0x822c0890
	ctx.lr = 0x826AF344;
	sub_822C0890(ctx, base);
	// 826AF344: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826AF348: 4877B7B9  bl 0x82e2ab00
	ctx.lr = 0x826AF34C;
	sub_82E2AB00(ctx, base);
	// 826AF34C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 826AF350: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826AF354: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 826AF358: 4198FDF8  blt cr6, 0x826af150
	if ctx.cr[6].lt {
	pc = 0x826AF150; continue 'dispatch;
	}
	// 826AF35C: C01F01A0  lfs f0, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AF360: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 826AF364: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 826AF368: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826AF36C: 809A6868  lwz r4, 0x6868(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26728 as u32) ) } as u64;
	// 826AF370: 4BC35BC1  bl 0x822e4f30
	ctx.lr = 0x826AF374;
	sub_822E4F30(ctx, base);
	// 826AF374: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 826AF378: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 826AF37C: 80B96750  lwz r5, 0x6750(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26448 as u32) ) } as u64;
	// 826AF380: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AF384: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826AF388: 809D685C  lwz r4, 0x685c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26716 as u32) ) } as u64;
	// 826AF38C: 4BC48415  bl 0x822f77a0
	ctx.lr = 0x826AF390;
	sub_822F77A0(ctx, base);
	// 826AF390: 3E608336  lis r19, -0x7cca
	ctx.r[19].s64 = -2093613056;
	// 826AF394: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826AF398: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 826AF39C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826AF3A0: 88D38160  lbz r6, -0x7ea0(r19)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[19].u32.wrapping_add(-32416 as u32) ) } as u64;
	// 826AF3A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 826AF3A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 826AF3AC: 5567063E  clrlwi r7, r11, 0x18
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826AF3B0: 4BDDCED9  bl 0x8248c288
	ctx.lr = 0x826AF3B4;
	sub_8248C288(ctx, base);
	// 826AF3B4: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AF3B8: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 826AF3BC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826AF3C0: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826AF3C4: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 826AF3C8: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826AF3CC: 487F1365  bl 0x82ea0730
	ctx.lr = 0x826AF3D0;
	sub_82EA0730(ctx, base);
	// 826AF3D0: 3AC00030  li r22, 0x30
	ctx.r[22].s64 = 48;
	// 826AF3D4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AF3D8: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 826AF3DC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826AF3E0: 39CB24F8  addi r14, r11, 0x24f8
	ctx.r[14].s64 = ctx.r[11].s64 + 9464;
	// 826AF3E4: 396A8170  addi r11, r10, -0x7e90
	ctx.r[11].s64 = ctx.r[10].s64 + -32400;
	// 826AF3E8: 815F01DC  lwz r10, 0x1dc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 826AF3EC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 826AF3F0: 91C10070  stw r14, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[14].u32 ) };
	// 826AF3F4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826AF3F8: 7C29742E  lfsx f1, r9, r14
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[14].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AF3FC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 826AF400: 48870CD9  bl 0x82f200d8
	ctx.lr = 0x826AF404;
	sub_82F200D8(ctx, base);
	// 826AF404: 39610220  addi r11, r1, 0x220
	ctx.r[11].s64 = ctx.r[1].s64 + 544;
	// 826AF408: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 826AF40C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826AF410: 39610220  addi r11, r1, 0x220
	ctx.r[11].s64 = ctx.r[1].s64 + 544;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AFEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826AFEA8 size=100
    let mut pc: u32 = 0x826AFEA8;
    'dispatch: loop {
        match pc {
            0x826AFEA8 => {
    //   block [0x826AFEA8..0x826AFF0C)
	// 826AFEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AFEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AFEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AFEB4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AFEB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AFEBC: C03F0240  lfs f1, 0x240(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826AFEC0: 4BFF5B19  bl 0x826a59d8
	ctx.lr = 0x826AFEC4;
	sub_826A59D8(ctx, base);
	// 826AFEC4: C01F023C  lfs f0, 0x23c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AFEC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826AFECC: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826AFED0: C19F0244  lfs f12, 0x244(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826AFED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AFED8: 83FF0224  lwz r31, 0x224(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826AFEDC: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826AFEE0: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826AFEE4: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 826AFEE8: 487CCB01  bl 0x82e7c9e8
	ctx.lr = 0x826AFEEC;
	sub_82E7C9E8(ctx, base);
	// 826AFEEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826AFEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AFEF4: 4876336D  bl 0x82e13260
	ctx.lr = 0x826AFEF8;
	sub_82E13260(ctx, base);
	// 826AFEF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826AFEFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AFF00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AFF04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AFF08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AFF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AFF10 size=196
    let mut pc: u32 = 0x826AFF10;
    'dispatch: loop {
        match pc {
            0x826AFF10 => {
    //   block [0x826AFF10..0x826AFFD4)
	// 826AFF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AFF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AFF18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826AFF1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AFF20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AFF24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826AFF28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AFF2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826AFF30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826AFF34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AFF38: 4BC10A01  bl 0x822c0938
	ctx.lr = 0x826AFF3C;
	sub_822C0938(ctx, base);
	// 826AFF3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826AFF40: 41820028  beq 0x826aff68
	if ctx.cr[0].eq {
	pc = 0x826AFF68; continue 'dispatch;
	}
	// 826AFF44: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AFF48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826AFF4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826AFF50: 392B2918  addi r9, r11, 0x2918
	ctx.r[9].s64 = ctx.r[11].s64 + 10520;
	// 826AFF54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826AFF58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826AFF5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826AFF60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826AFF64: 48000008  b 0x826aff6c
	pc = 0x826AFF6C; continue 'dispatch;
	// 826AFF68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826AFF6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826AFF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826AFF74: 409A0044  bne cr6, 0x826affb8
	if !ctx.cr[6].eq {
	pc = 0x826AFFB8; continue 'dispatch;
	}
	// 826AFF78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826AFF7C: 419A001C  beq cr6, 0x826aff98
	if ctx.cr[6].eq {
	pc = 0x826AFF98; continue 'dispatch;
	}
	// 826AFF80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AFF84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826AFF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826AFF8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826AFF90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826AFF94: 4E800421  bctrl
	ctx.lr = 0x826AFF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826AFF98: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826AFF9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826AFFA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826AFFA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826AFFA8: 816BA70C  lwz r11, -0x58f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22772 as u32) ) } as u64;
	// 826AFFAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826AFFB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826AFFB4: 4BC1004D  bl 0x822c0000
	ctx.lr = 0x826AFFB8;
	sub_822C0000(ctx, base);
	// 826AFFB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826AFFBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826AFFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826AFFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826AFFC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826AFFCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826AFFD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826AFFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826AFFD8 size=148
    let mut pc: u32 = 0x826AFFD8;
    'dispatch: loop {
        match pc {
            0x826AFFD8 => {
    //   block [0x826AFFD8..0x826B006C)
	// 826AFFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826AFFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826AFFE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826AFFE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826AFFE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826AFFEC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826AFFF0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826AFFF4: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826AFFF8: 396B298C  addi r11, r11, 0x298c
	ctx.r[11].s64 = ctx.r[11].s64 + 10636;
	// 826AFFFC: 394A2978  addi r10, r10, 0x2978
	ctx.r[10].s64 = ctx.r[10].s64 + 10616;
	// 826B0000: 3929292C  addi r9, r9, 0x292c
	ctx.r[9].s64 = ctx.r[9].s64 + 10540;
	// 826B0004: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B0008: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B000C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B0010: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B0014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0018: 419A0008  beq cr6, 0x826b0020
	if ctx.cr[6].eq {
	pc = 0x826B0020; continue 'dispatch;
	}
	// 826B001C: 4BC10875  bl 0x822c0890
	ctx.lr = 0x826B0020;
	sub_822C0890(ctx, base);
	// 826B0020: 807F0228  lwz r3, 0x228(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 826B0024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0028: 419A0008  beq cr6, 0x826b0030
	if ctx.cr[6].eq {
	pc = 0x826B0030; continue 'dispatch;
	}
	// 826B002C: 4BC10865  bl 0x822c0890
	ctx.lr = 0x826B0030;
	sub_822C0890(ctx, base);
	// 826B0030: 807F0220  lwz r3, 0x220(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 826B0034: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0038: 419A0008  beq cr6, 0x826b0040
	if ctx.cr[6].eq {
	pc = 0x826B0040; continue 'dispatch;
	}
	// 826B003C: 4BC10855  bl 0x822c0890
	ctx.lr = 0x826B0040;
	sub_822C0890(ctx, base);
	// 826B0040: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 826B0044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0048: 419A0008  beq cr6, 0x826b0050
	if ctx.cr[6].eq {
	pc = 0x826B0050; continue 'dispatch;
	}
	// 826B004C: 4BC10845  bl 0x822c0890
	ctx.lr = 0x826B0050;
	sub_822C0890(ctx, base);
	// 826B0050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0054: 4BFF364D  bl 0x826a36a0
	ctx.lr = 0x826B0058;
	sub_826A36A0(ctx, base);
	// 826B0058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B005C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B0070 size=8
    let mut pc: u32 = 0x826B0070;
    'dispatch: loop {
        match pc {
            0x826B0070 => {
    //   block [0x826B0070..0x826B0078)
	// 826B0070: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826B0074: 4800039C  b 0x826b0410
	sub_826B0410(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B0078 size=8
    let mut pc: u32 = 0x826B0078;
    'dispatch: loop {
        match pc {
            0x826B0078 => {
    //   block [0x826B0078..0x826B0080)
	// 826B0078: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826B007C: 48000394  b 0x826b0410
	sub_826B0410(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0080 size=52
    let mut pc: u32 = 0x826B0080;
    'dispatch: loop {
        match pc {
            0x826B0080 => {
    //   block [0x826B0080..0x826B00B4)
	// 826B0080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B008C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0094: 4BFF366D  bl 0x826a3700
	ctx.lr = 0x826B0098;
	sub_826A3700(ctx, base);
	// 826B0098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B009C: 4BFFFE0D  bl 0x826afea8
	ctx.lr = 0x826B00A0;
	sub_826AFEA8(ctx, base);
	// 826B00A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B00A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B00A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B00AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B00B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B00B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B00B8 size=320
    let mut pc: u32 = 0x826B00B8;
    'dispatch: loop {
        match pc {
            0x826B00B8 => {
    //   block [0x826B00B8..0x826B01F8)
	// 826B00B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B00BC: 48AF80B1  bl 0x831a816c
	ctx.lr = 0x826B00C0;
	sub_831A8130(ctx, base);
	// 826B00C0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 826B00C4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826B00C8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826B00CC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B00D0: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 826B00D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B00D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B00DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B00E0: C00B967C  lfs f0, -0x6984(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B00E4: EC3D0032  fmuls f1, f29, f0
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B00E8: 48AF8CE1  bl 0x831a8dc8
	ctx.lr = 0x826B00EC;
	sub_831A8DC8(ctx, base);
	// 826B00EC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B00F0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826B00F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B00F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B00FC: C0099670  lfs f0, -0x6990(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27024 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B0100: C3CBCFC8  lfs f30, -0x3038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12344 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826B0104: EC3D0032  fmuls f1, f29, f0
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B0108: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B010C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826B0110: EC0D07B2  fmuls f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 826B0114: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826B0118: 48AF8CB1  bl 0x831a8dc8
	ctx.lr = 0x826B011C;
	sub_831A8DC8(ctx, base);
	// 826B011C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B0120: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826B0124: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B0128: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826B012C: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B0130: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 826B0134: EC0D07B2  fmuls f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 826B0138: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826B013C: 40980098  bge cr6, 0x826b01d4
	if !ctx.cr[6].lt {
	pc = 0x826B01D4; continue 'dispatch;
	}
	// 826B0140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0144: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B0148: 4BE5F381  bl 0x8250f4c8
	ctx.lr = 0x826B014C;
	sub_8250F4C8(ctx, base);
	// 826B014C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B0154: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B0158: 409A0008  bne cr6, 0x826b0160
	if !ctx.cr[6].eq {
	pc = 0x826B0160; continue 'dispatch;
	}
	// 826B015C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B0160: 4BE583B9  bl 0x82508518
	ctx.lr = 0x826B0164;
	sub_82508518(ctx, base);
	// 826B0164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B0168: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826B016C: 48741B25  bl 0x82df1c90
	ctx.lr = 0x826B0170;
	sub_82DF1C90(ctx, base);
	// 826B0170: C1BF0234  lfs f13, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B0174: EDBF6828  fsubs f13, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B0178: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B017C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B0180: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B0184: 40990050  ble cr6, 0x826b01d4
	if !ctx.cr[6].gt {
	pc = 0x826B01D4; continue 'dispatch;
	}
	// 826B0188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B018C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0190: 4BE61959  bl 0x82511ae8
	ctx.lr = 0x826B0194;
	sub_82511AE8(ctx, base);
	// 826B0194: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B0198: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826B019C: 813E002C  lwz r9, 0x2c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826B01A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B01A4: 394AA6CC  addi r10, r10, -0x5934
	ctx.r[10].s64 = ctx.r[10].s64 + -22836;
	// 826B01A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B01AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B01B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B01B4: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B01B8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 826B01BC: 4E800421  bctrl
	ctx.lr = 0x826B01C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B01C0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B01C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B01C8: 419A0008  beq cr6, 0x826b01d0
	if ctx.cr[6].eq {
	pc = 0x826B01D0; continue 'dispatch;
	}
	// 826B01CC: 4BC106C5  bl 0x822c0890
	ctx.lr = 0x826B01D0;
	sub_822C0890(ctx, base);
	// 826B01D0: D3FF0234  stfs f31, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 826B01D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B01D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B01DC: 487CBDFD  bl 0x82e7bfd8
	ctx.lr = 0x826B01E0;
	sub_82E7BFD8(ctx, base);
	// 826B01E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B01E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826B01E8: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826B01EC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826B01F0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826B01F4: 48AF7FC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B01F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B01F8 size=368
    let mut pc: u32 = 0x826B01F8;
    'dispatch: loop {
        match pc {
            0x826B01F8 => {
    //   block [0x826B01F8..0x826B0368)
	// 826B01F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B01FC: 48AF7F69  bl 0x831a8164
	ctx.lr = 0x826B0200;
	sub_831A8130(ctx, base);
	// 826B0200: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0204: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B0208: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 826B020C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B0210: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826B0214: 4BFF36F5  bl 0x826a3908
	ctx.lr = 0x826B0218;
	sub_826A3908(ctx, base);
	// 826B0218: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 826B021C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826B0220: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 826B0224: 3BAA6910  addi r29, r10, 0x6910
	ctx.r[29].s64 = ctx.r[10].s64 + 26896;
	// 826B0228: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 826B022C: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826B0230: 807E0224  lwz r3, 0x224(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(548 as u32) ) } as u64;
	// 826B0234: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0238: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B023C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B0240: 4E800421  bctrl
	ctx.lr = 0x826B0244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B0244: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0248: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826B024C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B0250: 487CBA79  bl 0x82e7bcc8
	ctx.lr = 0x826B0254;
	sub_82E7BCC8(ctx, base);
	// 826B0254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B0258: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B025C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826B0260: C06B08A4  lfs f3, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826B0264: C04A0944  lfs f2, 0x944(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2372 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826B0268: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 826B026C: 839E0224  lwz r28, 0x224(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(548 as u32) ) } as u64;
	// 826B0270: 487CBDA9  bl 0x82e7c018
	ctx.lr = 0x826B0274;
	sub_82E7C018(ctx, base);
	// 826B0274: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0278: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B027C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B0280: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B0284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B0288: 4E800421  bctrl
	ctx.lr = 0x826B028C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B028C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0290: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826B0294: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826B0298: 4BC14669  bl 0x822c4900
	ctx.lr = 0x826B029C;
	sub_822C4900(ctx, base);
	// 826B029C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826B02A0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826B02A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B02A8: 487CBA21  bl 0x82e7bcc8
	ctx.lr = 0x826B02AC;
	sub_82E7BCC8(ctx, base);
	// 826B02AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B02B0: 38FF0020  addi r7, r31, 0x20
	ctx.r[7].s64 = ctx.r[31].s64 + 32;
	// 826B02B4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826B02B8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826B02BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B02C0: 4BFF7DF9  bl 0x826a80b8
	ctx.lr = 0x826B02C4;
	sub_826A80B8(ctx, base);
	// 826B02C4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826B02C8: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 826B02CC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B0368 size=164
    let mut pc: u32 = 0x826B0368;
    'dispatch: loop {
        match pc {
            0x826B0368 => {
    //   block [0x826B0368..0x826B040C)
	// 826B0368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B036C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B0374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B037C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0380: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B0384: 4BFF35ED  bl 0x826a3970
	ctx.lr = 0x826B0388;
	sub_826A3970(ctx, base);
	// 826B0388: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B038C: 93DF0210  stw r30, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[30].u32 ) };
	// 826B0390: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B0394: 396B298C  addi r11, r11, 0x298c
	ctx.r[11].s64 = ctx.r[11].s64 + 10636;
	// 826B0398: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B039C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B03A0: 394A2978  addi r10, r10, 0x2978
	ctx.r[10].s64 = ctx.r[10].s64 + 10616;
	// 826B03A4: 3929292C  addi r9, r9, 0x292c
	ctx.r[9].s64 = ctx.r[9].s64 + 10540;
	// 826B03A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B03AC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B03B0: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B03B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B03B8: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 826B03BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B03C0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 826B03C4: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 826B03C8: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 826B03CC: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 826B03D0: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B03D4: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 826B03D8: 917F022C  stw r11, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[11].u32 ) };
	// 826B03DC: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 826B03E0: D01F0234  stfs f0, 0x234(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 826B03E4: D01F023C  stfs f0, 0x23c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 826B03E8: 997F0238  stb r11, 0x238(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u8 ) };
	// 826B03EC: D01F0240  stfs f0, 0x240(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 826B03F0: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 826B03F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B03F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B03FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0400: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B0404: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0410 size=76
    let mut pc: u32 = 0x826B0410;
    'dispatch: loop {
        match pc {
            0x826B0410 => {
    //   block [0x826B0410..0x826B045C)
	// 826B0410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0418: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B041C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0428: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B042C: 4BFFFBAD  bl 0x826affd8
	ctx.lr = 0x826B0430;
	sub_826AFFD8(ctx, base);
	// 826B0430: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B0434: 4182000C  beq 0x826b0440
	if ctx.cr[0].eq {
	pc = 0x826B0440; continue 'dispatch;
	}
	// 826B0438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B043C: 48741F9D  bl 0x82df23d8
	ctx.lr = 0x826B0440;
	sub_82DF23D8(ctx, base);
	// 826B0440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B0448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B044C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B0454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B0460 size=212
    let mut pc: u32 = 0x826B0460;
    'dispatch: loop {
        match pc {
            0x826B0460 => {
    //   block [0x826B0460..0x826B0534)
	// 826B0460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B046C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B0474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0478: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B047C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 826B0480: 4199000C  bgt cr6, 0x826b048c
	if ctx.cr[6].gt {
	pc = 0x826B048C; continue 'dispatch;
	}
	// 826B0484: EC200828  fsubs f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 826B0488: 48000044  b 0x826b04cc
	pc = 0x826B04CC; continue 'dispatch;
	// 826B048C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B0490: C84BE3A0  lfd f2, -0x1c60(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) };
	// 826B0494: 48AFA37D  bl 0x831aa810
	ctx.lr = 0x826B0498;
	sub_831AA810(ctx, base);
	// 826B0498: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B049C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B04A0: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B04A4: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B04A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B04AC: 4199001C  bgt cr6, 0x826b04c8
	if ctx.cr[6].gt {
	pc = 0x826B04C8; continue 'dispatch;
	}
	// 826B04B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B04B4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 826B04B8: C18B08A4  lfs f12, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B04BC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 826B04C0: 40980008  bge cr6, 0x826b04c8
	if !ctx.cr[6].lt {
	pc = 0x826B04C8; continue 'dispatch;
	}
	// 826B04C4: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 826B04C8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 826B04CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B04D0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B04D4: 4BFFFBE5  bl 0x826b00b8
	ctx.lr = 0x826B04D8;
	sub_826B00B8(ctx, base);
	// 826B04D8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826B04DC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826B04E0: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B04E4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826B04E8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826B04EC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826B04F0: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B04F4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826B04F8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 826B04FC: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B0500: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B0504: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B0538 size=32
    let mut pc: u32 = 0x826B0538;
    'dispatch: loop {
        match pc {
            0x826B0538 => {
    //   block [0x826B0538..0x826B0558)
	// 826B0538: 81030224  lwz r8, 0x224(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(548 as u32) ) } as u64;
	// 826B053C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826B0540: 39430224  addi r10, r3, 0x224
	ctx.r[10].s64 = ctx.r[3].s64 + 548;
	// 826B0544: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826B0548: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826B054C: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826B0550: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826B0554: 4BC13F0C  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0558 size=220
    let mut pc: u32 = 0x826B0558;
    'dispatch: loop {
        match pc {
            0x826B0558 => {
    //   block [0x826B0558..0x826B0634)
	// 826B0558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B055C: 48AF7C0D  bl 0x831a8168
	ctx.lr = 0x826B0560;
	sub_831A8130(ctx, base);
	// 826B0560: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0564: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826B0568: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B056C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B0570: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826B0574: 41820038  beq 0x826b05ac
	if ctx.cr[0].eq {
	pc = 0x826B05AC; continue 'dispatch;
	}
	// 826B0578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B057C: 48AF940D  bl 0x831a9988
	ctx.lr = 0x826B0580;
	sub_831A9988(ctx, base);
	// 826B0580: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826B0584: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0588: 386BCB78  addi r3, r11, -0x3488
	ctx.r[3].s64 = ctx.r[11].s64 + -13448;
	// 826B058C: 48AF7B6D  bl 0x831a80f8
	ctx.lr = 0x826B0590;
	sub_831A80F8(ctx, base);
	// 826B0590: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B0594: 41820018  beq 0x826b05ac
	if ctx.cr[0].eq {
	pc = 0x826B05AC; continue 'dispatch;
	}
	// 826B0598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B059C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B05A0: 4BFF10C1  bl 0x826a1660
	ctx.lr = 0x826B05A4;
	sub_826A1660(ctx, base);
	// 826B05A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826B05A8: 48000084  b 0x826b062c
	pc = 0x826B062C; continue 'dispatch;
	// 826B05AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B05B0: 419A006C  beq cr6, 0x826b061c
	if ctx.cr[6].eq {
	pc = 0x826B061C; continue 'dispatch;
	}
	// 826B05B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B05B8: 48AF93D1  bl 0x831a9988
	ctx.lr = 0x826B05BC;
	sub_831A9988(ctx, base);
	// 826B05BC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B05C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B05C4: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826B05C8: 48AF7B31  bl 0x831a80f8
	ctx.lr = 0x826B05CC;
	sub_831A80F8(ctx, base);
	// 826B05CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B05D0: 41820014  beq 0x826b05e4
	if ctx.cr[0].eq {
	pc = 0x826B05E4; continue 'dispatch;
	}
	// 826B05D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B05D8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B05DC: 4BFFFF5D  bl 0x826b0538
	ctx.lr = 0x826B05E0;
	sub_826B0538(ctx, base);
	// 826B05E0: 4BFFFFC4  b 0x826b05a4
	pc = 0x826B05A4; continue 'dispatch;
	// 826B05E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B05E8: 419A0034  beq cr6, 0x826b061c
	if ctx.cr[6].eq {
	pc = 0x826B061C; continue 'dispatch;
	}
	// 826B05EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B05F0: 48AF9399  bl 0x831a9988
	ctx.lr = 0x826B05F4;
	sub_831A9988(ctx, base);
	// 826B05F4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B05F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B05FC: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826B0600: 48AF7AF9  bl 0x831a80f8
	ctx.lr = 0x826B0604;
	sub_831A80F8(ctx, base);
	// 826B0604: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B0608: 41820014  beq 0x826b061c
	if ctx.cr[0].eq {
	pc = 0x826B061C; continue 'dispatch;
	}
	// 826B060C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0610: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B0614: 4BFFFBE5  bl 0x826b01f8
	ctx.lr = 0x826B0618;
	sub_826B01F8(ctx, base);
	// 826B0618: 4BFFFF8C  b 0x826b05a4
	pc = 0x826B05A4; continue 'dispatch;
	// 826B061C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826B0620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0628: 4BFF4721  bl 0x826a4d48
	ctx.lr = 0x826B062C;
	sub_826A4D48(ctx, base);
	// 826B062C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B0630: 48AF7B88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B0638 size=480
    let mut pc: u32 = 0x826B0638;
    'dispatch: loop {
        match pc {
            0x826B0638 => {
    //   block [0x826B0638..0x826B0818)
	// 826B0638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B063C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B0644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0648: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826B064C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0654: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B0658: 4BFF4269  bl 0x826a48c0
	ctx.lr = 0x826B065C;
	sub_826A48C0(ctx, base);
	// 826B065C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B0660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B0664: 388B2BF0  addi r4, r11, 0x2bf0
	ctx.r[4].s64 = ctx.r[11].s64 + 11248;
	// 826B0668: 487433A1  bl 0x82df3a08
	ctx.lr = 0x826B066C;
	sub_82DF3A08(ctx, base);
	// 826B066C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B0670: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B0674: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 826B0678: 48743391  bl 0x82df3a08
	ctx.lr = 0x826B067C;
	sub_82DF3A08(ctx, base);
	// 826B067C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B0680: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826B0684: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826B0688: 38BF0158  addi r5, r31, 0x158
	ctx.r[5].s64 = ctx.r[31].s64 + 344;
	// 826B068C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B0690: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B0694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B0698: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826B069C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826B06A0: C0290790  lfs f1, 0x790(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B06A4: 4BEFD415  bl 0x825adab8
	ctx.lr = 0x826B06A8;
	sub_825ADAB8(ctx, base);
	// 826B06A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B06AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B06B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B06B4: 4BEF0F9D  bl 0x825a1650
	ctx.lr = 0x826B06B8;
	sub_825A1650(ctx, base);
	// 826B06B8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826B06BC: 48742D6D  bl 0x82df3428
	ctx.lr = 0x826B06C0;
	sub_82DF3428(ctx, base);
	// 826B06C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B06C4: 4BC185F5  bl 0x822c8cb8
	ctx.lr = 0x826B06C8;
	sub_822C8CB8(ctx, base);
	// 826B06C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B06CC: 48742D5D  bl 0x82df3428
	ctx.lr = 0x826B06D0;
	sub_82DF3428(ctx, base);
	// 826B06D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B06D4: 48742D55  bl 0x82df3428
	ctx.lr = 0x826B06D8;
	sub_82DF3428(ctx, base);
	// 826B06D8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B06DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B06E0: 388BD2B4  addi r4, r11, -0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11596;
	// 826B06E4: 48743325  bl 0x82df3a08
	ctx.lr = 0x826B06E8;
	sub_82DF3A08(ctx, base);
	// 826B06E8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B06EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B06F0: 388BA13C  addi r4, r11, -0x5ec4
	ctx.r[4].s64 = ctx.r[11].s64 + -24260;
	// 826B06F4: 48743315  bl 0x82df3a08
	ctx.lr = 0x826B06F8;
	sub_82DF3A08(ctx, base);
	// 826B06F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B06FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B0700: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826B0704: 38BF015C  addi r5, r31, 0x15c
	ctx.r[5].s64 = ctx.r[31].s64 + 348;
	// 826B0708: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B070C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B0710: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B0714: C04B9584  lfs f2, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826B0718: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B071C: 4BEFD39D  bl 0x825adab8
	ctx.lr = 0x826B0720;
	sub_825ADAB8(ctx, base);
	// 826B0720: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B0724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0728: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B072C: 4BEF0F25  bl 0x825a1650
	ctx.lr = 0x826B0730;
	sub_825A1650(ctx, base);
	// 826B0730: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826B0734: 48742CF5  bl 0x82df3428
	ctx.lr = 0x826B0738;
	sub_82DF3428(ctx, base);
	// 826B0738: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826B073C: 4BC1857D  bl 0x822c8cb8
	ctx.lr = 0x826B0740;
	sub_822C8CB8(ctx, base);
	// 826B0740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B0744: 48742CE5  bl 0x82df3428
	ctx.lr = 0x826B0748;
	sub_82DF3428(ctx, base);
	// 826B0748: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B074C: 48742CDD  bl 0x82df3428
	ctx.lr = 0x826B0750;
	sub_82DF3428(ctx, base);
	// 826B0750: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B0754: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B0758: 388B0E74  addi r4, r11, 0xe74
	ctx.r[4].s64 = ctx.r[11].s64 + 3700;
	// 826B075C: 487432AD  bl 0x82df3a08
	ctx.lr = 0x826B0760;
	sub_82DF3A08(ctx, base);
	// 826B0760: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B0764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B0768: 388B0E68  addi r4, r11, 0xe68
	ctx.r[4].s64 = ctx.r[11].s64 + 3688;
	// 826B076C: 4874329D  bl 0x82df3a08
	ctx.lr = 0x826B0770;
	sub_82DF3A08(ctx, base);
	// 826B0770: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B0774: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826B0778: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 826B077C: 38BF0160  addi r5, r31, 0x160
	ctx.r[5].s64 = ctx.r[31].s64 + 352;
	// 826B0780: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B0784: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826B0788: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826B078C: C04AD200  lfs f2, -0x2e00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826B0790: C0298E4C  lfs f1, -0x71b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B0794: 4BEFD325  bl 0x825adab8
	ctx.lr = 0x826B0798;
	sub_825ADAB8(ctx, base);
	// 826B0798: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B079C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B07A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B07A4: 4BEF0EAD  bl 0x825a1650
	ctx.lr = 0x826B07A8;
	sub_825A1650(ctx, base);
	// 826B07A8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826B07AC: 48742C7D  bl 0x82df3428
	ctx.lr = 0x826B07B0;
	sub_82DF3428(ctx, base);
	// 826B07B0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826B07B4: 4BC18505  bl 0x822c8cb8
	ctx.lr = 0x826B07B8;
	sub_822C8CB8(ctx, base);
	// 826B07B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B07BC: 48742C6D  bl 0x82df3428
	ctx.lr = 0x826B07C0;
	sub_82DF3428(ctx, base);
	// 826B07C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B07C4: 48742C65  bl 0x82df3428
	ctx.lr = 0x826B07C8;
	sub_82DF3428(ctx, base);
	// 826B07C8: C01F0158  lfs f0, 0x158(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B07CC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 826B07D0: 419A002C  beq cr6, 0x826b07fc
	if ctx.cr[6].eq {
	pc = 0x826B07FC; continue 'dispatch;
	}
	// 826B07D4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B07D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B07DC: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 826B07E0: 48743229  bl 0x82df3a08
	ctx.lr = 0x826B07E4;
	sub_82DF3A08(ctx, base);
	// 826B07E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826B07E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B07EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B07F0: 4BEF0D99  bl 0x825a1588
	ctx.lr = 0x826B07F4;
	sub_825A1588(ctx, base);
	// 826B07F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B07F8: 48742C31  bl 0x82df3428
	ctx.lr = 0x826B07FC;
	sub_82DF3428(ctx, base);
	// 826B07FC: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826B0800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0808: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826B080C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B0810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B0818 size=260
    let mut pc: u32 = 0x826B0818;
    'dispatch: loop {
        match pc {
            0x826B0818 => {
    //   block [0x826B0818..0x826B091C)
	// 826B0818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B081C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B0824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B082C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0830: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B0834: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 826B0838: 807F021C  lwz r3, 0x21c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 826B083C: 4BC3C915  bl 0x822ed150
	ctx.lr = 0x826B0840;
	sub_822ED150(ctx, base);
	// 826B0840: 897F01E4  lbz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 826B0844: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B0848: 418200BC  beq 0x826b0904
	if ctx.cr[0].eq {
	pc = 0x826B0904; continue 'dispatch;
	}
	// 826B084C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B0850: 4BD0E7D9  bl 0x823bf028
	ctx.lr = 0x826B0854;
	sub_823BF028(ctx, base);
	// 826B0854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0858: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826B085C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B0860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B0864: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B0868: 419A0024  beq cr6, 0x826b088c
	if ctx.cr[6].eq {
	pc = 0x826B088C; continue 'dispatch;
	}
	// 826B086C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B0870: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B0874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0878: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B087C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B0880: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0884: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0888: 4082FFE8  bne 0x826b0870
	if !ctx.cr[0].eq {
	pc = 0x826B0870; continue 'dispatch;
	}
	// 826B088C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B0894: 4BE5EC35  bl 0x8250f4c8
	ctx.lr = 0x826B0898;
	sub_8250F4C8(ctx, base);
	// 826B0898: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B089C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B08A0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B08A4: 409A0008  bne cr6, 0x826b08ac
	if !ctx.cr[6].eq {
	pc = 0x826B08AC; continue 'dispatch;
	}
	// 826B08A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B08AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B08B0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826B08B4: 4BE58165  bl 0x82508a18
	ctx.lr = 0x826B08B8;
	sub_82508A18(ctx, base);
	// 826B08B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B08BC: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B08C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B08C4: 388A29D8  addi r4, r10, 0x29d8
	ctx.r[4].s64 = ctx.r[10].s64 + 10712;
	// 826B08C8: 38A00110  li r5, 0x110
	ctx.r[5].s64 = 272;
	// 826B08CC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826B08D0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B08D4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B08D8: 487A8169  bl 0x82e58a40
	ctx.lr = 0x826B08DC;
	sub_82E58A40(ctx, base);
	// 826B08DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B08E0: 487413B1  bl 0x82df1c90
	ctx.lr = 0x826B08E4;
	sub_82DF1C90(ctx, base);
	// 826B08E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B08E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B08EC: 419A0008  beq cr6, 0x826b08f4
	if ctx.cr[6].eq {
	pc = 0x826B08F4; continue 'dispatch;
	}
	// 826B08F0: 4BC0FFA1  bl 0x822c0890
	ctx.lr = 0x826B08F4;
	sub_822C0890(ctx, base);
	// 826B08F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B08F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B08FC: 419A0008  beq cr6, 0x826b0904
	if ctx.cr[6].eq {
	pc = 0x826B0904; continue 'dispatch;
	}
	// 826B0900: 4BC0FF91  bl 0x822c0890
	ctx.lr = 0x826B0904;
	sub_822C0890(ctx, base);
	// 826B0904: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B0908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B090C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0910: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B0914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B0920 size=900
    let mut pc: u32 = 0x826B0920;
    'dispatch: loop {
        match pc {
            0x826B0920 => {
    //   block [0x826B0920..0x826B0CA4)
	// 826B0920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0924: 48AF7835  bl 0x831a8158
	ctx.lr = 0x826B0928;
	sub_831A8130(ctx, base);
	// 826B0928: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 826B092C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0934: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 826B0938: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B093C: 4BE611AD  bl 0x82511ae8
	ctx.lr = 0x826B0940;
	sub_82511AE8(ctx, base);
	// 826B0940: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B0944: 813F0210  lwz r9, 0x210(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B0948: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826B094C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B0950: 3BCBA6AC  addi r30, r11, -0x5954
	ctx.r[30].s64 = ctx.r[11].s64 + -22868;
	// 826B0954: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B0958: 393E0040  addi r9, r30, 0x40
	ctx.r[9].s64 = ctx.r[30].s64 + 64;
	// 826B095C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0960: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B0964: 7CAB482E  lwzx r5, r11, r9
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 826B0968: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826B096C: 4E800421  bctrl
	ctx.lr = 0x826B0970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B0970: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B0974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0978: 419A0008  beq cr6, 0x826b0980
	if ctx.cr[6].eq {
	pc = 0x826B0980; continue 'dispatch;
	}
	// 826B097C: 4BC0FF15  bl 0x822c0890
	ctx.lr = 0x826B0980;
	sub_822C0890(ctx, base);
	// 826B0980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0984: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B0988: 4BE5EB41  bl 0x8250f4c8
	ctx.lr = 0x826B098C;
	sub_8250F4C8(ctx, base);
	// 826B098C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B0994: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 826B0998: 409A0008  bne cr6, 0x826b09a0
	if !ctx.cr[6].eq {
	pc = 0x826B09A0; continue 'dispatch;
	}
	// 826B099C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B09A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826B09A4: 4BE59C95  bl 0x8250a638
	ctx.lr = 0x826B09A8;
	sub_8250A638(ctx, base);
	// 826B09A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B09AC: 487412E5  bl 0x82df1c90
	ctx.lr = 0x826B09B0;
	sub_82DF1C90(ctx, base);
	// 826B09B0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826B09B4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 826B09B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B09BC: 419A0290  beq cr6, 0x826b0c4c
	if ctx.cr[6].eq {
	pc = 0x826B0C4C; continue 'dispatch;
	}
	// 826B09C0: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B09C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B09C8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B09CC: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826B09D0: 48743039  bl 0x82df3a08
	ctx.lr = 0x826B09D4;
	sub_82DF3A08(ctx, base);
	// 826B09D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B09D8: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826B09DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826B09E0: 48110629  bl 0x827c1008
	ctx.lr = 0x826B09E4;
	sub_827C1008(ctx, base);
	// 826B09E4: 83630004  lwz r27, 4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B09E8: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B09EC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826B09F0: 419A0024  beq cr6, 0x826b0a14
	if ctx.cr[6].eq {
	pc = 0x826B0A14; continue 'dispatch;
	}
	// 826B09F4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826B09F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B09FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0A00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B0A04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B0A08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0A0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0A10: 4082FFE8  bne 0x826b09f8
	if !ctx.cr[0].eq {
	pc = 0x826B09F8; continue 'dispatch;
	}
	// 826B0A14: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826B0A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0A1C: 419A0008  beq cr6, 0x826b0a24
	if ctx.cr[6].eq {
	pc = 0x826B0A24; continue 'dispatch;
	}
	// 826B0A20: 4BC0FE71  bl 0x822c0890
	ctx.lr = 0x826B0A24;
	sub_822C0890(ctx, base);
	// 826B0A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B0A28: 48742A01  bl 0x82df3428
	ctx.lr = 0x826B0A2C;
	sub_82DF3428(ctx, base);
	// 826B0A2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B0A30: 419A020C  beq cr6, 0x826b0c3c
	if ctx.cr[6].eq {
	pc = 0x826B0C3C; continue 'dispatch;
	}
	// 826B0A34: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 826B0A38: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826B0A3C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 826B0A40: 419A0024  beq cr6, 0x826b0a64
	if ctx.cr[6].eq {
	pc = 0x826B0A64; continue 'dispatch;
	}
	// 826B0A44: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826B0A48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B0A4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0A50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B0A54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B0A58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0A5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0A60: 4082FFE8  bne 0x826b0a48
	if !ctx.cr[0].eq {
	pc = 0x826B0A48; continue 'dispatch;
	}
	// 826B0A64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0A68: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B0A6C: 4BE5EA5D  bl 0x8250f4c8
	ctx.lr = 0x826B0A70;
	sub_8250F4C8(ctx, base);
	// 826B0A70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0A74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B0A78: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826B0A7C: 409A0008  bne cr6, 0x826b0a84
	if !ctx.cr[6].eq {
	pc = 0x826B0A84; continue 'dispatch;
	}
	// 826B0A80: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826B0A84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0A88: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B0A8C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 826B0A90: 4BE5EA89  bl 0x8250f518
	ctx.lr = 0x826B0A94;
	sub_8250F518(ctx, base);
	// 826B0A94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0A9C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826B0AA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B0AA4: 4BE5CA65  bl 0x8250d508
	ctx.lr = 0x826B0AA8;
	sub_8250D508(ctx, base);
	// 826B0AA8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B0AAC: 487411E5  bl 0x82df1c90
	ctx.lr = 0x826B0AB0;
	sub_82DF1C90(ctx, base);
	// 826B0AB0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B0AB4: 487411DD  bl 0x82df1c90
	ctx.lr = 0x826B0AB8;
	sub_82DF1C90(ctx, base);
	// 826B0AB8: 807F022C  lwz r3, 0x22c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B0ABC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B0AC0: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826B0AC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0AC8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B0ACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B0AD0: 4E800421  bctrl
	ctx.lr = 0x826B0AD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B0AD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0AD8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826B0ADC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826B0AE0: 487CB1E9  bl 0x82e7bcc8
	ctx.lr = 0x826B0AE4;
	sub_82E7BCC8(ctx, base);
	// 826B0AE4: 807F022C  lwz r3, 0x22c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B0AE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0AEC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B0AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B0AF4: 4E800421  bctrl
	ctx.lr = 0x826B0AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B0AF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0AFC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826B0B00: 487CC309  bl 0x82e7ce08
	ctx.lr = 0x826B0B04;
	sub_82E7CE08(ctx, base);
	// 826B0B04: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826B0B08: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826B0B0C: 4BCC3FCD  bl 0x82374ad8
	ctx.lr = 0x826B0B10;
	sub_82374AD8(ctx, base);
	// 826B0B10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0B14: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B0B18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B0B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B0B20: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826B0B24: 419A0024  beq cr6, 0x826b0b48
	if ctx.cr[6].eq {
	pc = 0x826B0B48; continue 'dispatch;
	}
	// 826B0B28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B0B2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B0B30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0B34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B0B38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B0B3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0B40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0B44: 4082FFE8  bne 0x826b0b2c
	if !ctx.cr[0].eq {
	pc = 0x826B0B2C; continue 'dispatch;
	}
	// 826B0B48: 3BDD0028  addi r30, r29, 0x28
	ctx.r[30].s64 = ctx.r[29].s64 + 40;
	// 826B0B4C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 826B0B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0B54: 3B010058  addi r24, r1, 0x58
	ctx.r[24].s64 = ctx.r[1].s64 + 88;
	// 826B0B58: 48958461  bl 0x83008fb8
	ctx.lr = 0x826B0B5C;
	sub_83008FB8(ctx, base);
	// 826B0B5C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B0B60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B0B64: 3B8B29D8  addi r28, r11, 0x29d8
	ctx.r[28].s64 = ctx.r[11].s64 + 10712;
	// 826B0B68: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B0B6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B0B70: 38A00155  li r5, 0x155
	ctx.r[5].s64 = 341;
	// 826B0B74: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B0B78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B0B7C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 826B0B80: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B0B84: 487A7EBD  bl 0x82e58a40
	ctx.lr = 0x826B0B88;
	sub_82E58A40(ctx, base);
	// 826B0B88: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B0B8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0B90: 419A0008  beq cr6, 0x826b0b98
	if ctx.cr[6].eq {
	pc = 0x826B0B98; continue 'dispatch;
	}
	// 826B0B94: 4BC0FCFD  bl 0x822c0890
	ctx.lr = 0x826B0B98;
	sub_822C0890(ctx, base);
	// 826B0B98: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826B0B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0BA0: 419A0008  beq cr6, 0x826b0ba8
	if ctx.cr[6].eq {
	pc = 0x826B0BA8; continue 'dispatch;
	}
	// 826B0BA4: 4BC0FCED  bl 0x822c0890
	ctx.lr = 0x826B0BA8;
	sub_822C0890(ctx, base);
	// 826B0BA8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 826B0BAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B0BB0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826B0BB4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B0BB8: 4BEEB3D9  bl 0x8259bf90
	ctx.lr = 0x826B0BBC;
	sub_8259BF90(ctx, base);
	// 826B0BBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B0BC0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826B0BC4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B0BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B0BCC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826B0BD0: 419A0024  beq cr6, 0x826b0bf4
	if ctx.cr[6].eq {
	pc = 0x826B0BF4; continue 'dispatch;
	}
	// 826B0BD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B0BD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B0BDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0BE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B0BE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B0BE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0BEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0BF0: 4082FFE8  bne 0x826b0bd8
	if !ctx.cr[0].eq {
	pc = 0x826B0BD8; continue 'dispatch;
	}
	// 826B0BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0BF8: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 826B0BFC: 489583BD  bl 0x83008fb8
	ctx.lr = 0x826B0C00;
	sub_83008FB8(ctx, base);
	// 826B0C00: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B0C04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B0C08: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B0C0C: 38A00156  li r5, 0x156
	ctx.r[5].s64 = 342;
	// 826B0C10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B0C14: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B0C18: 487A7E29  bl 0x82e58a40
	ctx.lr = 0x826B0C1C;
	sub_82E58A40(ctx, base);
	// 826B0C1C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B0C20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0C24: 419A0008  beq cr6, 0x826b0c2c
	if ctx.cr[6].eq {
	pc = 0x826B0C2C; continue 'dispatch;
	}
	// 826B0C28: 4BC0FC69  bl 0x822c0890
	ctx.lr = 0x826B0C2C;
	sub_822C0890(ctx, base);
	// 826B0C2C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826B0C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0C34: 419A0008  beq cr6, 0x826b0c3c
	if ctx.cr[6].eq {
	pc = 0x826B0C3C; continue 'dispatch;
	}
	// 826B0C38: 4BC0FC59  bl 0x822c0890
	ctx.lr = 0x826B0C3C;
	sub_822C0890(ctx, base);
	// 826B0C3C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826B0C40: 419A000C  beq cr6, 0x826b0c4c
	if ctx.cr[6].eq {
	pc = 0x826B0C4C; continue 'dispatch;
	}
	// 826B0C44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B0C48: 4BC0FC49  bl 0x822c0890
	ctx.lr = 0x826B0C4C;
	sub_822C0890(ctx, base);
	// 826B0C4C: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B0C50: 9B5F0238  stb r26, 0x238(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[26].u8 ) };
	// 826B0C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0C58: 4182002C  beq 0x826b0c84
	if ctx.cr[0].eq {
	pc = 0x826B0C84; continue 'dispatch;
	}
	// 826B0C5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B0C60: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B0C64: 38BF0214  addi r5, r31, 0x214
	ctx.r[5].s64 = ctx.r[31].s64 + 532;
	// 826B0C68: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B0C6C: 4BE5F585  bl 0x825101f0
	ctx.lr = 0x826B0C70;
	sub_825101F0(ctx, base);
	// 826B0C70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B0C74: 807F021C  lwz r3, 0x21c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 826B0C78: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 826B0C7C: 4BDDE725  bl 0x8248f3a0
	ctx.lr = 0x826B0C80;
	sub_8248F3A0(ctx, base);
	// 826B0C80: 48000008  b 0x826b0c88
	pc = 0x826B0C88; continue 'dispatch;
	// 826B0C84: 4BE5F94D  bl 0x825105d0
	ctx.lr = 0x826B0C88;
	sub_825105D0(ctx, base);
	// 826B0C88: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826B0C8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0C90: 419A0008  beq cr6, 0x826b0c98
	if ctx.cr[6].eq {
	pc = 0x826B0C98; continue 'dispatch;
	}
	// 826B0C94: 4BC0FBFD  bl 0x822c0890
	ctx.lr = 0x826B0C98;
	sub_822C0890(ctx, base);
	// 826B0C98: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 826B0C9C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 826B0CA0: 48AF7508  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B0CA8 size=432
    let mut pc: u32 = 0x826B0CA8;
    'dispatch: loop {
        match pc {
            0x826B0CA8 => {
    //   block [0x826B0CA8..0x826B0E58)
	// 826B0CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0CAC: 48AF74B9  bl 0x831a8164
	ctx.lr = 0x826B0CB0;
	sub_831A8130(ctx, base);
	// 826B0CB0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0CB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B0CB8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B0CBC: 3BCB29D8  addi r30, r11, 0x29d8
	ctx.r[30].s64 = ctx.r[11].s64 + 10712;
	// 826B0CC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B0CC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826B0CC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B0CCC: 38A00075  li r5, 0x75
	ctx.r[5].s64 = 117;
	// 826B0CD0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826B0CD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B0CD8: 38600250  li r3, 0x250
	ctx.r[3].s64 = 592;
	// 826B0CDC: 4874170D  bl 0x82df23e8
	ctx.lr = 0x826B0CE0;
	sub_82DF23E8(ctx, base);
	// 826B0CE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B0CE4: 41820014  beq 0x826b0cf8
	if ctx.cr[0].eq {
	pc = 0x826B0CF8; continue 'dispatch;
	}
	// 826B0CE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0CEC: 4BFFF67D  bl 0x826b0368
	ctx.lr = 0x826B0CF0;
	sub_826B0368(ctx, base);
	// 826B0CF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0CF4: 48000008  b 0x826b0cfc
	pc = 0x826B0CFC; continue 'dispatch;
	// 826B0CF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B0CFC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826B0D00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0D04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B0D08: 4BFFF209  bl 0x826aff10
	ctx.lr = 0x826B0D0C;
	sub_826AFF10(ctx, base);
	// 826B0D0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B0D10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0D14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B0D18: 4BC0F2E9  bl 0x822c0000
	ctx.lr = 0x826B0D1C;
	sub_822C0000(ctx, base);
	// 826B0D1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B0D20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B0D24: 38A00076  li r5, 0x76
	ctx.r[5].s64 = 118;
	// 826B0D28: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826B0D2C: 4BC0F6AD  bl 0x822c03d8
	ctx.lr = 0x826B0D30;
	sub_822C03D8(ctx, base);
	// 826B0D30: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B0D34: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826B0D38: 418200B4  beq 0x826b0dec
	if ctx.cr[0].eq {
	pc = 0x826B0DEC; continue 'dispatch;
	}
	// 826B0D3C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826B0D40: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826B0D44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826B0D48: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826B0D4C: 409A0008  bne cr6, 0x826b0d54
	if !ctx.cr[6].eq {
	pc = 0x826B0D54; continue 'dispatch;
	}
	// 826B0D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B0D54: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B0D58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B0D5C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826B0D60: 419A0024  beq cr6, 0x826b0d84
	if ctx.cr[6].eq {
	pc = 0x826B0D84; continue 'dispatch;
	}
	// 826B0D64: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826B0D68: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826B0D6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0D70: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826B0D74: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826B0D78: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0D7C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0D80: 4082FFE8  bne 0x826b0d68
	if !ctx.cr[0].eq {
	pc = 0x826B0D68; continue 'dispatch;
	}
	// 826B0D84: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826B0D88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B0D8C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826B0D90: 419A0024  beq cr6, 0x826b0db4
	if ctx.cr[6].eq {
	pc = 0x826B0DB4; continue 'dispatch;
	}
	// 826B0D94: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826B0D98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B0D9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0DA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B0DA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B0DA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B0DAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B0DB0: 4082FFE8  bne 0x826b0d98
	if !ctx.cr[0].eq {
	pc = 0x826B0D98; continue 'dispatch;
	}
	// 826B0DB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B0DB8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826B0DBC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826B0DC0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826B0DC4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826B0DC8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B0DCC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B0DD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B0DD4: 480E815D  bl 0x82798f30
	ctx.lr = 0x826B0DD8;
	sub_82798F30(ctx, base);
	// 826B0DD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B0DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0DE0: 480EA889  bl 0x8279b668
	ctx.lr = 0x826B0DE4;
	sub_8279B668(ctx, base);
	// 826B0DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0DE8: 48000008  b 0x826b0df0
	pc = 0x826B0DF0; continue 'dispatch;
	// 826B0DEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B0DF0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826B0DF4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826B0DF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0DFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0E00: 4BEE6E51  bl 0x82597c50
	ctx.lr = 0x826B0E04;
	sub_82597C50(ctx, base);
	// 826B0E04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B0E08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B0E0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B0E10: 4BC0F1F1  bl 0x822c0000
	ctx.lr = 0x826B0E14;
	sub_822C0000(ctx, base);
	// 826B0E14: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B0E18: 41820024  beq 0x826b0e3c
	if ctx.cr[0].eq {
	pc = 0x826B0E3C; continue 'dispatch;
	}
	// 826B0E1C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826B0E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0E24: 419A0008  beq cr6, 0x826b0e2c
	if ctx.cr[6].eq {
	pc = 0x826B0E2C; continue 'dispatch;
	}
	// 826B0E28: 4BC0FA69  bl 0x822c0890
	ctx.lr = 0x826B0E2C;
	sub_822C0890(ctx, base);
	// 826B0E2C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B0E30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B0E34: 419A0008  beq cr6, 0x826b0e3c
	if ctx.cr[6].eq {
	pc = 0x826B0E3C; continue 'dispatch;
	}
	// 826B0E38: 4BC0FA59  bl 0x822c0890
	ctx.lr = 0x826B0E3C;
	sub_822C0890(ctx, base);
	// 826B0E3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B0E40: 419A000C  beq cr6, 0x826b0e4c
	if ctx.cr[6].eq {
	pc = 0x826B0E4C; continue 'dispatch;
	}
	// 826B0E44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B0E48: 4BC0FA49  bl 0x822c0890
	ctx.lr = 0x826B0E4C;
	sub_822C0890(ctx, base);
	// 826B0E4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B0E50: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826B0E54: 48AF7360  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0E58 size=52
    let mut pc: u32 = 0x826B0E58;
    'dispatch: loop {
        match pc {
            0x826B0E58 => {
    //   block [0x826B0E58..0x826B0E8C)
	// 826B0E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0E64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0E68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B0E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0E70: 4BFFFE39  bl 0x826b0ca8
	ctx.lr = 0x826B0E74;
	sub_826B0CA8(ctx, base);
	// 826B0E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0E78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0E84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0E88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0E90 size=52
    let mut pc: u32 = 0x826B0E90;
    'dispatch: loop {
        match pc {
            0x826B0E90 => {
    //   block [0x826B0E90..0x826B0EC4)
	// 826B0E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0E98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0E9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0EA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B0EA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0EA8: 4BFFFE01  bl 0x826b0ca8
	ctx.lr = 0x826B0EAC;
	sub_826B0CA8(ctx, base);
	// 826B0EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0EB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0EB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0EB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0EC8 size=52
    let mut pc: u32 = 0x826B0EC8;
    'dispatch: loop {
        match pc {
            0x826B0EC8 => {
    //   block [0x826B0EC8..0x826B0EFC)
	// 826B0EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0ED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0ED4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0ED8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826B0EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0EE0: 4BFFFDC9  bl 0x826b0ca8
	ctx.lr = 0x826B0EE4;
	sub_826B0CA8(ctx, base);
	// 826B0EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0EE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0F00 size=52
    let mut pc: u32 = 0x826B0F00;
    'dispatch: loop {
        match pc {
            0x826B0F00 => {
    //   block [0x826B0F00..0x826B0F34)
	// 826B0F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0F08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0F0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0F10: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826B0F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0F18: 4BFFFD91  bl 0x826b0ca8
	ctx.lr = 0x826B0F1C;
	sub_826B0CA8(ctx, base);
	// 826B0F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0F20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0F24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0F28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0F38 size=52
    let mut pc: u32 = 0x826B0F38;
    'dispatch: loop {
        match pc {
            0x826B0F38 => {
    //   block [0x826B0F38..0x826B0F6C)
	// 826B0F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0F44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0F48: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826B0F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0F50: 4BFFFD59  bl 0x826b0ca8
	ctx.lr = 0x826B0F54;
	sub_826B0CA8(ctx, base);
	// 826B0F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0F64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0F70 size=52
    let mut pc: u32 = 0x826B0F70;
    'dispatch: loop {
        match pc {
            0x826B0F70 => {
    //   block [0x826B0F70..0x826B0FA4)
	// 826B0F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0F78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0F7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0F80: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826B0F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0F88: 4BFFFD21  bl 0x826b0ca8
	ctx.lr = 0x826B0F8C;
	sub_826B0CA8(ctx, base);
	// 826B0F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0F90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0F94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0F98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0FA8 size=52
    let mut pc: u32 = 0x826B0FA8;
    'dispatch: loop {
        match pc {
            0x826B0FA8 => {
    //   block [0x826B0FA8..0x826B0FDC)
	// 826B0FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0FB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0FB8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826B0FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0FC0: 4BFFFCE9  bl 0x826b0ca8
	ctx.lr = 0x826B0FC4;
	sub_826B0CA8(ctx, base);
	// 826B0FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B0FC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B0FCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B0FD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B0FD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B0FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B0FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B0FE0 size=52
    let mut pc: u32 = 0x826B0FE0;
    'dispatch: loop {
        match pc {
            0x826B0FE0 => {
    //   block [0x826B0FE0..0x826B1014)
	// 826B0FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B0FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B0FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B0FEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B0FF0: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826B0FF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B0FF8: 4BFFFCB1  bl 0x826b0ca8
	ctx.lr = 0x826B0FFC;
	sub_826B0CA8(ctx, base);
	// 826B0FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1000: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B1004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B1008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B100C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B1010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B1018 size=948
    let mut pc: u32 = 0x826B1018;
    'dispatch: loop {
        match pc {
            0x826B1018 => {
    //   block [0x826B1018..0x826B13CC)
	// 826B1018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B101C: 48AF7145  bl 0x831a8160
	ctx.lr = 0x826B1020;
	sub_831A8130(ctx, base);
	// 826B1020: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B1028: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 826B102C: 4BFF36FD  bl 0x826a4728
	ctx.lr = 0x826B1030;
	sub_826A4728(ctx, base);
	// 826B1030: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1034: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B1038: 3B4B29D8  addi r26, r11, 0x29d8
	ctx.r[26].s64 = ctx.r[11].s64 + 10712;
	// 826B103C: 38A000B8  li r5, 0xb8
	ctx.r[5].s64 = 184;
	// 826B1040: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826B1044: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826B1048: 487413A1  bl 0x82df23e8
	ctx.lr = 0x826B104C;
	sub_82DF23E8(ctx, base);
	// 826B104C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B1050: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B1054: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 826B1058: 41820014  beq 0x826b106c
	if ctx.cr[0].eq {
	pc = 0x826B106C; continue 'dispatch;
	}
	// 826B105C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B1060: 48762091  bl 0x82e130f0
	ctx.lr = 0x826B1064;
	sub_82E130F0(ctx, base);
	// 826B1064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1068: 48000008  b 0x826b1070
	pc = 0x826B1070; continue 'dispatch;
	// 826B106C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B1070: 3BDF022C  addi r30, r31, 0x22c
	ctx.r[30].s64 = ctx.r[31].s64 + 556;
	// 826B1074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B1078: 4BC30CD9  bl 0x822e1d50
	ctx.lr = 0x826B107C;
	sub_822E1D50(ctx, base);
	// 826B107C: 809F022C  lwz r4, 0x22c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B1080: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826B1084: 48761DAD  bl 0x82e12e30
	ctx.lr = 0x826B1088;
	sub_82E12E30(ctx, base);
	// 826B1088: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826B108C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B1090: 38A000BC  li r5, 0xbc
	ctx.r[5].s64 = 188;
	// 826B1094: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826B1098: 48741351  bl 0x82df23e8
	ctx.lr = 0x826B109C;
	sub_82DF23E8(ctx, base);
	// 826B109C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B10A0: 41820014  beq 0x826b10b4
	if ctx.cr[0].eq {
	pc = 0x826B10B4; continue 'dispatch;
	}
	// 826B10A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B10A8: 48762049  bl 0x82e130f0
	ctx.lr = 0x826B10AC;
	sub_82E130F0(ctx, base);
	// 826B10AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B10B0: 48000008  b 0x826b10b8
	pc = 0x826B10B8; continue 'dispatch;
	// 826B10B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B10B8: 3B9F0224  addi r28, r31, 0x224
	ctx.r[28].s64 = ctx.r[31].s64 + 548;
	// 826B10BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B10C0: 4BC30C91  bl 0x822e1d50
	ctx.lr = 0x826B10C4;
	sub_822E1D50(ctx, base);
	// 826B10C4: 809F0224  lwz r4, 0x224(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826B10C8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B10CC: 48761D65  bl 0x82e12e30
	ctx.lr = 0x826B10D0;
	sub_82E12E30(ctx, base);
	// 826B10D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826B10D4: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B10D8: 48779A11  bl 0x82e2aae8
	ctx.lr = 0x826B10DC;
	sub_82E2AAE8(ctx, base);
	// 826B10DC: 815F0210  lwz r10, 0x210(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B10E0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B10E4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826B10E8: 396BA68C  addi r11, r11, -0x5974
	ctx.r[11].s64 = ctx.r[11].s64 + -22900;
	// 826B10EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B10F0: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826B10F4: 48742915  bl 0x82df3a08
	ctx.lr = 0x826B10F8;
	sub_82DF3A08(ctx, base);
	// 826B10F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B10FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B1100: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826B1104: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B1108: 4877DD69  bl 0x82e2ee70
	ctx.lr = 0x826B110C;
	sub_82E2EE70(ctx, base);
	// 826B110C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1110: 48742319  bl 0x82df3428
	ctx.lr = 0x826B1114;
	sub_82DF3428(ctx, base);
	// 826B1114: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826B1118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B111C: 419A0084  beq cr6, 0x826b11a0
	if ctx.cr[6].eq {
	pc = 0x826B11A0; continue 'dispatch;
	}
	// 826B1120: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826B1124: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B1128: 38A000C4  li r5, 0xc4
	ctx.r[5].s64 = 196;
	// 826B112C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826B1130: 487412B9  bl 0x82df23e8
	ctx.lr = 0x826B1134;
	sub_82DF23E8(ctx, base);
	// 826B1134: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B1138: 41820014  beq 0x826b114c
	if ctx.cr[0].eq {
	pc = 0x826B114C; continue 'dispatch;
	}
	// 826B113C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B1140: 48765751  bl 0x82e16890
	ctx.lr = 0x826B1144;
	sub_82E16890(ctx, base);
	// 826B1144: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1148: 48000008  b 0x826b1150
	pc = 0x826B1150; continue 'dispatch;
	// 826B114C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B1150: 3BDF0214  addi r30, r31, 0x214
	ctx.r[30].s64 = ctx.r[31].s64 + 532;
	// 826B1154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B1158: 4BCAC219  bl 0x8235d370
	ctx.lr = 0x826B115C;
	sub_8235D370(ctx, base);
	// 826B115C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B1160: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B1164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B1168: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B116C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B1170: 419A0024  beq cr6, 0x826b1194
	if ctx.cr[6].eq {
	pc = 0x826B1194; continue 'dispatch;
	}
	// 826B1174: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B1178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B117C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B1180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B1184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B1188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B118C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B1190: 4082FFE8  bne 0x826b1178
	if !ctx.cr[0].eq {
	pc = 0x826B1178; continue 'dispatch;
	}
	// 826B1194: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B1198: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B119C: 48763F15  bl 0x82e150b0
	ctx.lr = 0x826B11A0;
	sub_82E150B0(ctx, base);
	// 826B11A0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B11A4: 4881B845  bl 0x82ecc9e8
	ctx.lr = 0x826B11A8;
	sub_82ECC9E8(ctx, base);
	// 826B11A8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 826B11AC: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B11B0: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 826B11B4: 99610150  stb r11, 0x150(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u8 ) };
	// 826B11B8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826B11BC: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826B11C0: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826B11C4: 487EF56D  bl 0x82ea0730
	ctx.lr = 0x826B11C8;
	sub_82EA0730(ctx, base);
	// 826B11C8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826B11CC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826B11D0: 396BAA50  addi r11, r11, -0x55b0
	ctx.r[11].s64 = ctx.r[11].s64 + -21936;
	// 826B11D4: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 826B11D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826B11DC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 826B11E0: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 826B11E4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B11E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B11EC: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B11F0: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B13D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B13D0 size=128
    let mut pc: u32 = 0x826B13D0;
    'dispatch: loop {
        match pc {
            0x826B13D0 => {
    //   block [0x826B13D0..0x826B1450)
	// 826B13D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B13D4: 48AF6D99  bl 0x831a816c
	ctx.lr = 0x826B13D8;
	sub_831A8130(ctx, base);
	// 826B13D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B13DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B13E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B13E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B13E8: 38BF0214  addi r5, r31, 0x214
	ctx.r[5].s64 = ctx.r[31].s64 + 532;
	// 826B13EC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B13F0: 4BE5F769  bl 0x82510b58
	ctx.lr = 0x826B13F4;
	sub_82510B58(ctx, base);
	// 826B13F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B13F8: 83DF021C  lwz r30, 0x21c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 826B13FC: 4BC33AC5  bl 0x822e4ec0
	ctx.lr = 0x826B1400;
	sub_822E4EC0(ctx, base);
	// 826B1400: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B1404: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826B1408: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B140C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B1410: 80AB6750  lwz r5, 0x6750(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 826B1414: 808A6848  lwz r4, 0x6848(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26696 as u32) ) } as u64;
	// 826B1418: 4BC46389  bl 0x822f77a0
	ctx.lr = 0x826B141C;
	sub_822F77A0(ctx, base);
	// 826B141C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826B1420: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 826B1424: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B1428: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826B142C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B1430: 4BDDAE59  bl 0x8248c288
	ctx.lr = 0x826B1434;
	sub_8248C288(ctx, base);
	// 826B1434: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B143C: 4BDDDF65  bl 0x8248f3a0
	ctx.lr = 0x826B1440;
	sub_8248F3A0(ctx, base);
	// 826B1440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B1444: 997F0238  stb r11, 0x238(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u8 ) };
	// 826B1448: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B144C: 48AF6D70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1450 size=220
    let mut pc: u32 = 0x826B1450;
    'dispatch: loop {
        match pc {
            0x826B1450 => {
    //   block [0x826B1450..0x826B152C)
	// 826B1450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1454: 48AF6D15  bl 0x831a8168
	ctx.lr = 0x826B1458;
	sub_831A8130(ctx, base);
	// 826B1458: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B145C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B1460: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B1464: 4BFF22E5  bl 0x826a3748
	ctx.lr = 0x826B1468;
	sub_826A3748(ctx, base);
	// 826B1468: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B146C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1470: 3BAB18B4  addi r29, r11, 0x18b4
	ctx.r[29].s64 = ctx.r[11].s64 + 6324;
	// 826B1474: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B1478: 48742591  bl 0x82df3a08
	ctx.lr = 0x826B147C;
	sub_82DF3A08(ctx, base);
	// 826B147C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1480: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B1484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B1488: 4BEF0101  bl 0x825a1588
	ctx.lr = 0x826B148C;
	sub_825A1588(ctx, base);
	// 826B148C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1490: 48741F99  bl 0x82df3428
	ctx.lr = 0x826B1494;
	sub_82DF3428(ctx, base);
	// 826B1494: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B149C: 3B8B18A4  addi r28, r11, 0x18a4
	ctx.r[28].s64 = ctx.r[11].s64 + 6308;
	// 826B14A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B14A4: 48742565  bl 0x82df3a08
	ctx.lr = 0x826B14A8;
	sub_82DF3A08(ctx, base);
	// 826B14A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B14AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B14B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B14B4: 4BEF00D5  bl 0x825a1588
	ctx.lr = 0x826B14B8;
	sub_825A1588(ctx, base);
	// 826B14B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B14BC: 48741F6D  bl 0x82df3428
	ctx.lr = 0x826B14C0;
	sub_82DF3428(ctx, base);
	// 826B14C0: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 826B14C4: 4BFF43B5  bl 0x826a5878
	ctx.lr = 0x826B14C8;
	sub_826A5878(ctx, base);
	// 826B14C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B14CC: 41820058  beq 0x826b1524
	if ctx.cr[0].eq {
	pc = 0x826B1524; continue 'dispatch;
	}
	// 826B14D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B14D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B14D8: 48742531  bl 0x82df3a08
	ctx.lr = 0x826B14DC;
	sub_82DF3A08(ctx, base);
	// 826B14DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826B14E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B14E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B14E8: 4BEF00A1  bl 0x825a1588
	ctx.lr = 0x826B14EC;
	sub_825A1588(ctx, base);
	// 826B14EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B14F0: 48741F39  bl 0x82df3428
	ctx.lr = 0x826B14F4;
	sub_82DF3428(ctx, base);
	// 826B14F4: 897E0169  lbz r11, 0x169(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(361 as u32) ) } as u64;
	// 826B14F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B14FC: 41820028  beq 0x826b1524
	if ctx.cr[0].eq {
	pc = 0x826B1524; continue 'dispatch;
	}
	// 826B1500: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B1504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1508: 48742501  bl 0x82df3a08
	ctx.lr = 0x826B150C;
	sub_82DF3A08(ctx, base);
	// 826B150C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826B1510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B1514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1518: 4BEF0071  bl 0x825a1588
	ctx.lr = 0x826B151C;
	sub_825A1588(ctx, base);
	// 826B151C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1520: 48741F09  bl 0x82df3428
	ctx.lr = 0x826B1524;
	sub_82DF3428(ctx, base);
	// 826B1524: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B1528: 48AF6C90  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826B1530 size=44
    let mut pc: u32 = 0x826B1530;
    'dispatch: loop {
        match pc {
            0x826B1530 => {
    //   block [0x826B1530..0x826B155C)
	// 826B1530: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1534: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B1538: 396B2F40  addi r11, r11, 0x2f40
	ctx.r[11].s64 = ctx.r[11].s64 + 12096;
	// 826B153C: 394A2F30  addi r10, r10, 0x2f30
	ctx.r[10].s64 = ctx.r[10].s64 + 12080;
	// 826B1540: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826B1544: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 826B1548: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B154C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1560 size=196
    let mut pc: u32 = 0x826B1560;
    'dispatch: loop {
        match pc {
            0x826B1560 => {
    //   block [0x826B1560..0x826B1624)
	// 826B1560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B156C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1574: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B1578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B157C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826B1580: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B1584: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B1588: 4BC0F3B1  bl 0x822c0938
	ctx.lr = 0x826B158C;
	sub_822C0938(ctx, base);
	// 826B158C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B1590: 41820028  beq 0x826b15b8
	if ctx.cr[0].eq {
	pc = 0x826B15B8; continue 'dispatch;
	}
	// 826B1594: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1598: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826B159C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826B15A0: 392B2F18  addi r9, r11, 0x2f18
	ctx.r[9].s64 = ctx.r[11].s64 + 12056;
	// 826B15A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826B15A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826B15AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826B15B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826B15B4: 48000008  b 0x826b15bc
	pc = 0x826B15BC; continue 'dispatch;
	// 826B15B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B15BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B15C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B15C4: 409A0044  bne cr6, 0x826b1608
	if !ctx.cr[6].eq {
	pc = 0x826B1608; continue 'dispatch;
	}
	// 826B15C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826B15CC: 419A001C  beq cr6, 0x826b15e8
	if ctx.cr[6].eq {
	pc = 0x826B15E8; continue 'dispatch;
	}
	// 826B15D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B15D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B15D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B15DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B15E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B15E4: 4E800421  bctrl
	ctx.lr = 0x826B15E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B15E8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B15EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B15F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B15F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826B15F8: 816BA880  lwz r11, -0x5780(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22400 as u32) ) } as u64;
	// 826B15FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B1600: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B1604: 4BC0E9FD  bl 0x822c0000
	ctx.lr = 0x826B1608;
	sub_822C0000(ctx, base);
	// 826B1608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B160C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B1610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B1614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B1618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B161C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B1620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1628 size=212
    let mut pc: u32 = 0x826B1628;
    'dispatch: loop {
        match pc {
            0x826B1628 => {
    //   block [0x826B1628..0x826B16FC)
	// 826B1628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B162C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1630: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1634: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B163C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1640: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B1644: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B1648: 396B2FB4  addi r11, r11, 0x2fb4
	ctx.r[11].s64 = ctx.r[11].s64 + 12212;
	// 826B164C: 394A2FA0  addi r10, r10, 0x2fa0
	ctx.r[10].s64 = ctx.r[10].s64 + 12192;
	// 826B1650: 39292F54  addi r9, r9, 0x2f54
	ctx.r[9].s64 = ctx.r[9].s64 + 12116;
	// 826B1654: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B1658: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B165C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B1660: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 826B1664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B1668: 419A0008  beq cr6, 0x826b1670
	if ctx.cr[6].eq {
	pc = 0x826B1670; continue 'dispatch;
	}
	// 826B166C: 4BC0F225  bl 0x822c0890
	ctx.lr = 0x826B1670;
	sub_822C0890(ctx, base);
	// 826B1670: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 826B1674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B1678: 419A0008  beq cr6, 0x826b1680
	if ctx.cr[6].eq {
	pc = 0x826B1680; continue 'dispatch;
	}
	// 826B167C: 4BC0F215  bl 0x822c0890
	ctx.lr = 0x826B1680;
	sub_822C0890(ctx, base);
	// 826B1680: 807F0234  lwz r3, 0x234(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 826B1684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B1688: 419A0008  beq cr6, 0x826b1690
	if ctx.cr[6].eq {
	pc = 0x826B1690; continue 'dispatch;
	}
	// 826B168C: 4BC0F205  bl 0x822c0890
	ctx.lr = 0x826B1690;
	sub_822C0890(ctx, base);
	// 826B1690: 807F022C  lwz r3, 0x22c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B1694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B1698: 419A0018  beq cr6, 0x826b16b0
	if ctx.cr[6].eq {
	pc = 0x826B16B0; continue 'dispatch;
	}
	// 826B169C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B16A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B16A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B16A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B16AC: 4E800421  bctrl
	ctx.lr = 0x826B16B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B16B0: 807F0228  lwz r3, 0x228(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 826B16B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B16B8: 419A0008  beq cr6, 0x826b16c0
	if ctx.cr[6].eq {
	pc = 0x826B16C0; continue 'dispatch;
	}
	// 826B16BC: 4BC0F1D5  bl 0x822c0890
	ctx.lr = 0x826B16C0;
	sub_822C0890(ctx, base);
	// 826B16C0: 807F0220  lwz r3, 0x220(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 826B16C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B16C8: 419A0008  beq cr6, 0x826b16d0
	if ctx.cr[6].eq {
	pc = 0x826B16D0; continue 'dispatch;
	}
	// 826B16CC: 4BC0F1C5  bl 0x822c0890
	ctx.lr = 0x826B16D0;
	sub_822C0890(ctx, base);
	// 826B16D0: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 826B16D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B16D8: 419A0008  beq cr6, 0x826b16e0
	if ctx.cr[6].eq {
	pc = 0x826B16E0; continue 'dispatch;
	}
	// 826B16DC: 4BC0F1B5  bl 0x822c0890
	ctx.lr = 0x826B16E0;
	sub_822C0890(ctx, base);
	// 826B16E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B16E4: 4BFF1FBD  bl 0x826a36a0
	ctx.lr = 0x826B16E8;
	sub_826A36A0(ctx, base);
	// 826B16E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B16EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B16F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B16F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B16F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B1700 size=8
    let mut pc: u32 = 0x826B1700;
    'dispatch: loop {
        match pc {
            0x826B1700 => {
    //   block [0x826B1700..0x826B1708)
	// 826B1700: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826B1704: 4800059C  b 0x826b1ca0
	sub_826B1CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B1708 size=8
    let mut pc: u32 = 0x826B1708;
    'dispatch: loop {
        match pc {
            0x826B1708 => {
    //   block [0x826B1708..0x826B1710)
	// 826B1708: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826B170C: 48000594  b 0x826b1ca0
	sub_826B1CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B1710 size=328
    let mut pc: u32 = 0x826B1710;
    'dispatch: loop {
        match pc {
            0x826B1710 => {
    //   block [0x826B1710..0x826B1858)
	// 826B1710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B171C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 826B1720: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826B1724: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B172C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826B1730: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826B1734: 419A0108  beq cr6, 0x826b183c
	if ctx.cr[6].eq {
	pc = 0x826B183C; continue 'dispatch;
	}
	// 826B1738: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826B173C: 4BC1E975  bl 0x822d00b0
	ctx.lr = 0x826B1740;
	sub_822D00B0(ctx, base);
	// 826B1740: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B1744: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B1748: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826B174C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826B1750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1754: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B1758: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826B175C: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826B1760: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826B1764: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826B1768: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826B176C: 487CBBB5  bl 0x82e7d320
	ctx.lr = 0x826B1770;
	sub_82E7D320(ctx, base);
	// 826B1770: 817F0250  lwz r11, 0x250(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 826B1774: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826B1778: 409A0044  bne cr6, 0x826b17bc
	if !ctx.cr[6].eq {
	pc = 0x826B17BC; continue 'dispatch;
	}
	// 826B177C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826B1780: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B1784: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 826B1788: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B178C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B1790: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B1794: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826B1798: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B179C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826B17A0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B17A4: FC005850  fneg f0, f11
	ctx.f[0].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B17A8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826B17AC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826B17B0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826B17B4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B1858 size=320
    let mut pc: u32 = 0x826B1858;
    'dispatch: loop {
        match pc {
            0x826B1858 => {
    //   block [0x826B1858..0x826B1998)
	// 826B1858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B185C: 48AF6911  bl 0x831a816c
	ctx.lr = 0x826B1860;
	sub_831A8130(ctx, base);
	// 826B1860: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 826B1864: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826B1868: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826B186C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1870: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B1874: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 826B1878: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826B187C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B1880: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B1884: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B1888: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826B188C: C00A967C  lfs f0, -0x6984(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B1890: EC3D0032  fmuls f1, f29, f0
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B1894: 48AF7535  bl 0x831a8dc8
	ctx.lr = 0x826B1898;
	sub_831A8DC8(ctx, base);
	// 826B1898: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B189C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826B18A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B18A4: C00A9670  lfs f0, -0x6990(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27024 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B18A8: C3CBCFC8  lfs f30, -0x3038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12344 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826B18AC: EC3D0032  fmuls f1, f29, f0
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B18B0: EC0D07B2  fmuls f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 826B18B4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826B18B8: 48AF7511  bl 0x831a8dc8
	ctx.lr = 0x826B18BC;
	sub_831A8DC8(ctx, base);
	// 826B18BC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B18C0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826B18C4: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B18C8: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826B18CC: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B18D0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 826B18D4: EC0D07B2  fmuls f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 826B18D8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826B18DC: 40980098  bge cr6, 0x826b1974
	if !ctx.cr[6].lt {
	pc = 0x826B1974; continue 'dispatch;
	}
	// 826B18E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B18E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B18E8: 4BE5DBE1  bl 0x8250f4c8
	ctx.lr = 0x826B18EC;
	sub_8250F4C8(ctx, base);
	// 826B18EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B18F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B18F4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B18F8: 409A0008  bne cr6, 0x826b1900
	if !ctx.cr[6].eq {
	pc = 0x826B1900; continue 'dispatch;
	}
	// 826B18FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B1900: 4BE56C19  bl 0x82508518
	ctx.lr = 0x826B1904;
	sub_82508518(ctx, base);
	// 826B1904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1908: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826B190C: 48740385  bl 0x82df1c90
	ctx.lr = 0x826B1910;
	sub_82DF1C90(ctx, base);
	// 826B1910: C1BF0248  lfs f13, 0x248(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B1914: EDBF6828  fsubs f13, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B1918: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B191C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B1920: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B1924: 40990050  ble cr6, 0x826b1974
	if !ctx.cr[6].gt {
	pc = 0x826B1974; continue 'dispatch;
	}
	// 826B1928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B192C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B1930: 4BE601B9  bl 0x82511ae8
	ctx.lr = 0x826B1934;
	sub_82511AE8(ctx, base);
	// 826B1934: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B1938: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826B193C: 813E002C  lwz r9, 0x2c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826B1940: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B1944: 394AA814  addi r10, r10, -0x57ec
	ctx.r[10].s64 = ctx.r[10].s64 + -22508;
	// 826B1948: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B194C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1950: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B1954: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B1958: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 826B195C: 4E800421  bctrl
	ctx.lr = 0x826B1960;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B1960: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B1964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B1968: 419A0008  beq cr6, 0x826b1970
	if ctx.cr[6].eq {
	pc = 0x826B1970; continue 'dispatch;
	}
	// 826B196C: 4BC0EF25  bl 0x822c0890
	ctx.lr = 0x826B1970;
	sub_822C0890(ctx, base);
	// 826B1970: D3FF0248  stfs f31, 0x248(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), tmp.u32 ) };
	// 826B1974: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B1978: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B197C: 487CA65D  bl 0x82e7bfd8
	ctx.lr = 0x826B1980;
	sub_82E7BFD8(ctx, base);
	// 826B1980: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B1984: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826B1988: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826B198C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826B1990: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826B1994: 48AF6828  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B1998 size=32
    let mut pc: u32 = 0x826B1998;
    'dispatch: loop {
        match pc {
            0x826B1998 => {
    //   block [0x826B1998..0x826B19B8)
	// 826B1998: 81030230  lwz r8, 0x230(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B199C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826B19A0: 39430230  addi r10, r3, 0x230
	ctx.r[10].s64 = ctx.r[3].s64 + 560;
	// 826B19A4: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826B19A8: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826B19AC: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826B19B0: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826B19B4: 4BC12AAC  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B19B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B19B8 size=556
    let mut pc: u32 = 0x826B19B8;
    'dispatch: loop {
        match pc {
            0x826B19B8 => {
    //   block [0x826B19B8..0x826B1BE4)
	// 826B19B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B19BC: 48AF679D  bl 0x831a8158
	ctx.lr = 0x826B19C0;
	sub_831A8130(ctx, base);
	// 826B19C0: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 826B19C4: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 826B19C8: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B19CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B19D0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826B19D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B19D8: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826B19DC: 4BFF1F2D  bl 0x826a3908
	ctx.lr = 0x826B19E0;
	sub_826A3908(ctx, base);
	// 826B19E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 826B19E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B19E8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 826B19EC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826B19F0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 826B19F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826B19F8: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826B19FC: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B1A00: 83DB0238  lwz r30, 0x238(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(568 as u32) ) } as u64;
	// 826B1A04: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826B1A08: C3C99450  lfs f30, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826B1A0C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826B1A10: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826B1A14: 487CA605  bl 0x82e7c018
	ctx.lr = 0x826B1A18;
	sub_82E7C018(ctx, base);
	// 826B1A18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B1A1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B1A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B1A24: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B1A28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B1A2C: 4E800421  bctrl
	ctx.lr = 0x826B1A30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B1A30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1A34: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826B1A38: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826B1A3C: 4BC12EC5  bl 0x822c4900
	ctx.lr = 0x826B1A40;
	sub_822C4900(ctx, base);
	// 826B1A40: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 826B1A44: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 826B1A48: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1A4C: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 826B1A50: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 826B1A54: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826B1A58: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 826B1A5C: 13DC1C07  vcmpneb. (lvlx128) v30, v28, v3
	tmp.u32 = ctx.r[28].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1A60: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 826B1A64: 13BD1C07  vcmpneb. (lvlx128) v29, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1A68: 139E1C07  vcmpneb. (lvlx128) v28, v30, v3
	tmp.u32 = ctx.r[30].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1A6C: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B1BE8 size=184
    let mut pc: u32 = 0x826B1BE8;
    'dispatch: loop {
        match pc {
            0x826B1BE8 => {
    //   block [0x826B1BE8..0x826B1CA0)
	// 826B1BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B1BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1BF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B1C00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B1C04: 4BFF1D6D  bl 0x826a3970
	ctx.lr = 0x826B1C08;
	sub_826A3970(ctx, base);
	// 826B1C08: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1C0C: 93DF0210  stw r30, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[30].u32 ) };
	// 826B1C10: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B1C14: 396B2FB4  addi r11, r11, 0x2fb4
	ctx.r[11].s64 = ctx.r[11].s64 + 12212;
	// 826B1C18: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B1C1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B1C20: 394A2FA0  addi r10, r10, 0x2fa0
	ctx.r[10].s64 = ctx.r[10].s64 + 12192;
	// 826B1C24: 39292F54  addi r9, r9, 0x2f54
	ctx.r[9].s64 = ctx.r[9].s64 + 12116;
	// 826B1C28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B1C2C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B1C30: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B1C34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B1C38: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 826B1C3C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826B1C40: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 826B1C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1C48: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 826B1C4C: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 826B1C50: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 826B1C54: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B1C58: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 826B1C5C: 917F022C  stw r11, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[11].u32 ) };
	// 826B1C60: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 826B1C64: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 826B1C68: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 826B1C6C: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 826B1C70: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 826B1C74: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 826B1C78: D01F0248  stfs f0, 0x248(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), tmp.u32 ) };
	// 826B1C7C: 997F024C  stb r11, 0x24c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u8 ) };
	// 826B1C80: 993F024D  stb r9, 0x24d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(589 as u32), ctx.r[9].u8 ) };
	// 826B1C84: 917F0250  stw r11, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 826B1C88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B1C8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B1C90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B1C94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B1C98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B1C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1CA0 size=76
    let mut pc: u32 = 0x826B1CA0;
    'dispatch: loop {
        match pc {
            0x826B1CA0 => {
    //   block [0x826B1CA0..0x826B1CEC)
	// 826B1CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1CA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B1CAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1CB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1CB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B1CB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B1CBC: 4BFFF96D  bl 0x826b1628
	ctx.lr = 0x826B1CC0;
	sub_826B1628(ctx, base);
	// 826B1CC0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1CC4: 4182000C  beq 0x826b1cd0
	if ctx.cr[0].eq {
	pc = 0x826B1CD0; continue 'dispatch;
	}
	// 826B1CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1CCC: 4874070D  bl 0x82df23d8
	ctx.lr = 0x826B1CD0;
	sub_82DF23D8(ctx, base);
	// 826B1CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1CD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B1CD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B1CDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B1CE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B1CE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B1CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1CF0 size=100
    let mut pc: u32 = 0x826B1CF0;
    'dispatch: loop {
        match pc {
            0x826B1CF0 => {
    //   block [0x826B1CF0..0x826B1D54)
	// 826B1CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1CF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1CFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1D00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B1D04: 4BFF19FD  bl 0x826a3700
	ctx.lr = 0x826B1D08;
	sub_826A3700(ctx, base);
	// 826B1D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1D0C: 4BFF3B6D  bl 0x826a5878
	ctx.lr = 0x826B1D10;
	sub_826A5878(ctx, base);
	// 826B1D10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1D14: 4182001C  beq 0x826b1d30
	if ctx.cr[0].eq {
	pc = 0x826B1D30; continue 'dispatch;
	}
	// 826B1D18: 897F024D  lbz r11, 0x24d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(589 as u32) ) } as u64;
	// 826B1D1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B1D20: 41820010  beq 0x826b1d30
	if ctx.cr[0].eq {
	pc = 0x826B1D30; continue 'dispatch;
	}
	// 826B1D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1D28: 4BFFF9E9  bl 0x826b1710
	ctx.lr = 0x826B1D2C;
	sub_826B1710(ctx, base);
	// 826B1D2C: 48000014  b 0x826b1d40
	pc = 0x826B1D40; continue 'dispatch;
	// 826B1D30: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B1D34: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 826B1D38: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826B1D3C: 48761525  bl 0x82e13260
	ctx.lr = 0x826B1D40;
	sub_82E13260(ctx, base);
	// 826B1D40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B1D44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B1D48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B1D4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B1D50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B1D58 size=212
    let mut pc: u32 = 0x826B1D58;
    'dispatch: loop {
        match pc {
            0x826B1D58 => {
    //   block [0x826B1D58..0x826B1E2C)
	// 826B1D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1D64: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1D68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B1D6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B1D70: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B1D74: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 826B1D78: 4199000C  bgt cr6, 0x826b1d84
	if ctx.cr[6].gt {
	pc = 0x826B1D84; continue 'dispatch;
	}
	// 826B1D7C: EC200828  fsubs f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 826B1D80: 48000044  b 0x826b1dc4
	pc = 0x826B1DC4; continue 'dispatch;
	// 826B1D84: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1D88: C84BE3A0  lfd f2, -0x1c60(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) };
	// 826B1D8C: 48AF8A85  bl 0x831aa810
	ctx.lr = 0x826B1D90;
	sub_831AA810(ctx, base);
	// 826B1D90: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B1D94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B1D98: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B1D9C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B1DA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B1DA4: 4199001C  bgt cr6, 0x826b1dc0
	if ctx.cr[6].gt {
	pc = 0x826B1DC0; continue 'dispatch;
	}
	// 826B1DA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B1DAC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 826B1DB0: C18B08A4  lfs f12, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B1DB4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 826B1DB8: 40980008  bge cr6, 0x826b1dc0
	if !ctx.cr[6].lt {
	pc = 0x826B1DC0; continue 'dispatch;
	}
	// 826B1DBC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 826B1DC0: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 826B1DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1DC8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B1DCC: 4BFFFA8D  bl 0x826b1858
	ctx.lr = 0x826B1DD0;
	sub_826B1858(ctx, base);
	// 826B1DD0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826B1DD4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826B1DD8: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1DDC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826B1DE0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826B1DE4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826B1DE8: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1DEC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826B1DF0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 826B1DF4: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1DF8: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B1DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B1E30 size=32
    let mut pc: u32 = 0x826B1E30;
    'dispatch: loop {
        match pc {
            0x826B1E30 => {
    //   block [0x826B1E30..0x826B1E50)
	// 826B1E30: 81030238  lwz r8, 0x238(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(568 as u32) ) } as u64;
	// 826B1E34: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826B1E38: 39430238  addi r10, r3, 0x238
	ctx.r[10].s64 = ctx.r[3].s64 + 568;
	// 826B1E3C: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826B1E40: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826B1E44: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826B1E48: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826B1E4C: 4BC12614  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1E50 size=332
    let mut pc: u32 = 0x826B1E50;
    'dispatch: loop {
        match pc {
            0x826B1E50 => {
    //   block [0x826B1E50..0x826B1F9C)
	// 826B1E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1E54: 48AF6315  bl 0x831a8168
	ctx.lr = 0x826B1E58;
	sub_831A8130(ctx, base);
	// 826B1E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1E5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826B1E60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B1E64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B1E68: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826B1E6C: 41820038  beq 0x826b1ea4
	if ctx.cr[0].eq {
	pc = 0x826B1EA4; continue 'dispatch;
	}
	// 826B1E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1E74: 48AF7B15  bl 0x831a9988
	ctx.lr = 0x826B1E78;
	sub_831A9988(ctx, base);
	// 826B1E78: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B1E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1E80: 386B6B84  addi r3, r11, 0x6b84
	ctx.r[3].s64 = ctx.r[11].s64 + 27524;
	// 826B1E84: 48AF6275  bl 0x831a80f8
	ctx.lr = 0x826B1E88;
	sub_831A80F8(ctx, base);
	// 826B1E88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1E8C: 41820018  beq 0x826b1ea4
	if ctx.cr[0].eq {
	pc = 0x826B1EA4; continue 'dispatch;
	}
	// 826B1E90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1E94: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B1E98: 4BFFFF99  bl 0x826b1e30
	ctx.lr = 0x826B1E9C;
	sub_826B1E30(ctx, base);
	// 826B1E9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826B1EA0: 480000F4  b 0x826b1f94
	pc = 0x826B1F94; continue 'dispatch;
	// 826B1EA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B1EA8: 419A00DC  beq cr6, 0x826b1f84
	if ctx.cr[6].eq {
	pc = 0x826B1F84; continue 'dispatch;
	}
	// 826B1EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1EB0: 48AF7AD9  bl 0x831a9988
	ctx.lr = 0x826B1EB4;
	sub_831A9988(ctx, base);
	// 826B1EB4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B1EB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1EBC: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826B1EC0: 48AF6239  bl 0x831a80f8
	ctx.lr = 0x826B1EC4;
	sub_831A80F8(ctx, base);
	// 826B1EC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1EC8: 41820014  beq 0x826b1edc
	if ctx.cr[0].eq {
	pc = 0x826B1EDC; continue 'dispatch;
	}
	// 826B1ECC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1ED0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B1ED4: 4BFFFF5D  bl 0x826b1e30
	ctx.lr = 0x826B1ED8;
	sub_826B1E30(ctx, base);
	// 826B1ED8: 4BFFFFC4  b 0x826b1e9c
	pc = 0x826B1E9C; continue 'dispatch;
	// 826B1EDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B1EE0: 419A00A4  beq cr6, 0x826b1f84
	if ctx.cr[6].eq {
	pc = 0x826B1F84; continue 'dispatch;
	}
	// 826B1EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1EE8: 48AF7AA1  bl 0x831a9988
	ctx.lr = 0x826B1EEC;
	sub_831A9988(ctx, base);
	// 826B1EEC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B1EF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1EF4: 386B9470  addi r3, r11, -0x6b90
	ctx.r[3].s64 = ctx.r[11].s64 + -27536;
	// 826B1EF8: 48AF6201  bl 0x831a80f8
	ctx.lr = 0x826B1EFC;
	sub_831A80F8(ctx, base);
	// 826B1EFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1F00: 41820014  beq 0x826b1f14
	if ctx.cr[0].eq {
	pc = 0x826B1F14; continue 'dispatch;
	}
	// 826B1F04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1F08: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B1F0C: 4BFFF625  bl 0x826b1530
	ctx.lr = 0x826B1F10;
	sub_826B1530(ctx, base);
	// 826B1F10: 4BFFFF8C  b 0x826b1e9c
	pc = 0x826B1E9C; continue 'dispatch;
	// 826B1F14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B1F18: 419A006C  beq cr6, 0x826b1f84
	if ctx.cr[6].eq {
	pc = 0x826B1F84; continue 'dispatch;
	}
	// 826B1F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1F20: 48AF7A69  bl 0x831a9988
	ctx.lr = 0x826B1F24;
	sub_831A9988(ctx, base);
	// 826B1F24: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826B1F28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1F2C: 386B193C  addi r3, r11, 0x193c
	ctx.r[3].s64 = ctx.r[11].s64 + 6460;
	// 826B1F30: 48AF61C9  bl 0x831a80f8
	ctx.lr = 0x826B1F34;
	sub_831A80F8(ctx, base);
	// 826B1F34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1F38: 41820014  beq 0x826b1f4c
	if ctx.cr[0].eq {
	pc = 0x826B1F4C; continue 'dispatch;
	}
	// 826B1F3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1F40: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B1F44: 4BFFFA55  bl 0x826b1998
	ctx.lr = 0x826B1F48;
	sub_826B1998(ctx, base);
	// 826B1F48: 4BFFFF54  b 0x826b1e9c
	pc = 0x826B1E9C; continue 'dispatch;
	// 826B1F4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B1F50: 419A0034  beq cr6, 0x826b1f84
	if ctx.cr[6].eq {
	pc = 0x826B1F84; continue 'dispatch;
	}
	// 826B1F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B1F58: 48AF7A31  bl 0x831a9988
	ctx.lr = 0x826B1F5C;
	sub_831A9988(ctx, base);
	// 826B1F5C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B1F60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B1F64: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826B1F68: 48AF6191  bl 0x831a80f8
	ctx.lr = 0x826B1F6C;
	sub_831A80F8(ctx, base);
	// 826B1F6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B1F70: 41820014  beq 0x826b1f84
	if ctx.cr[0].eq {
	pc = 0x826B1F84; continue 'dispatch;
	}
	// 826B1F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1F78: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B1F7C: 4BFFFA3D  bl 0x826b19b8
	ctx.lr = 0x826B1F80;
	sub_826B19B8(ctx, base);
	// 826B1F80: 4BFFFF1C  b 0x826b1e9c
	pc = 0x826B1E9C; continue 'dispatch;
	// 826B1F84: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826B1F88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B1F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B1F90: 4BFF2DB9  bl 0x826a4d48
	ctx.lr = 0x826B1F94;
	sub_826A4D48(ctx, base);
	// 826B1F94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B1F98: 48AF6220  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B1FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B1FA0 size=260
    let mut pc: u32 = 0x826B1FA0;
    'dispatch: loop {
        match pc {
            0x826B1FA0 => {
    //   block [0x826B1FA0..0x826B20A4)
	// 826B1FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B1FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B1FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B1FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B1FB0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B1FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B1FB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B1FBC: 4BFF2905  bl 0x826a48c0
	ctx.lr = 0x826B1FC0;
	sub_826A48C0(ctx, base);
	// 826B1FC0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1FC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B1FC8: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 826B1FCC: 48741A3D  bl 0x82df3a08
	ctx.lr = 0x826B1FD0;
	sub_82DF3A08(ctx, base);
	// 826B1FD0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B1FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B1FD8: 388B18B4  addi r4, r11, 0x18b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6324;
	// 826B1FDC: 48741A2D  bl 0x82df3a08
	ctx.lr = 0x826B1FE0;
	sub_82DF3A08(ctx, base);
	// 826B1FE0: 38BF0169  addi r5, r31, 0x169
	ctx.r[5].s64 = ctx.r[31].s64 + 361;
	// 826B1FE4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B1FE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B1FEC: 4BEF1065  bl 0x825a3050
	ctx.lr = 0x826B1FF0;
	sub_825A3050(ctx, base);
	// 826B1FF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B1FF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B1FF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B1FFC: 4BEF018D  bl 0x825a2188
	ctx.lr = 0x826B2000;
	sub_825A2188(ctx, base);
	// 826B2000: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B2004: 48741425  bl 0x82df3428
	ctx.lr = 0x826B2008;
	sub_82DF3428(ctx, base);
	// 826B2008: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826B200C: 4BC16CAD  bl 0x822c8cb8
	ctx.lr = 0x826B2010;
	sub_822C8CB8(ctx, base);
	// 826B2010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2014: 48741415  bl 0x82df3428
	ctx.lr = 0x826B2018;
	sub_82DF3428(ctx, base);
	// 826B2018: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B201C: 4874140D  bl 0x82df3428
	ctx.lr = 0x826B2020;
	sub_82DF3428(ctx, base);
	// 826B2020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826B2024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2028: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826B202C: 487419DD  bl 0x82df3a08
	ctx.lr = 0x826B2030;
	sub_82DF3A08(ctx, base);
	// 826B2030: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B2034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B2038: 388B18A4  addi r4, r11, 0x18a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6308;
	// 826B203C: 487419CD  bl 0x82df3a08
	ctx.lr = 0x826B2040;
	sub_82DF3A08(ctx, base);
	// 826B2040: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826B2044: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826B2048: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B204C: 38BF016C  addi r5, r31, 0x16c
	ctx.r[5].s64 = ctx.r[31].s64 + 364;
	// 826B2050: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B2054: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B2058: 4BEF13C1  bl 0x825a3418
	ctx.lr = 0x826B205C;
	sub_825A3418(ctx, base);
	// 826B205C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B2060: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B2064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B2068: 4BEEFE71  bl 0x825a1ed8
	ctx.lr = 0x826B206C;
	sub_825A1ED8(ctx, base);
	// 826B206C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826B2070: 487413B9  bl 0x82df3428
	ctx.lr = 0x826B2074;
	sub_82DF3428(ctx, base);
	// 826B2074: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826B2078: 4BC16C41  bl 0x822c8cb8
	ctx.lr = 0x826B207C;
	sub_822C8CB8(ctx, base);
	// 826B207C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B2080: 487413A9  bl 0x82df3428
	ctx.lr = 0x826B2084;
	sub_82DF3428(ctx, base);
	// 826B2084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2088: 487413A1  bl 0x82df3428
	ctx.lr = 0x826B208C;
	sub_82DF3428(ctx, base);
	// 826B208C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 826B2090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B2094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B2098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B209C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B20A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B20A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B20A8 size=260
    let mut pc: u32 = 0x826B20A8;
    'dispatch: loop {
        match pc {
            0x826B20A8 => {
    //   block [0x826B20A8..0x826B21AC)
	// 826B20A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B20AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B20B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B20B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B20B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B20BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B20C0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B20C4: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 826B20C8: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B20CC: 4BC3B085  bl 0x822ed150
	ctx.lr = 0x826B20D0;
	sub_822ED150(ctx, base);
	// 826B20D0: 897F01E4  lbz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 826B20D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B20D8: 418200BC  beq 0x826b2194
	if ctx.cr[0].eq {
	pc = 0x826B2194; continue 'dispatch;
	}
	// 826B20DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B20E0: 4BD0CF49  bl 0x823bf028
	ctx.lr = 0x826B20E4;
	sub_823BF028(ctx, base);
	// 826B20E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B20E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826B20EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B20F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B20F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B20F8: 419A0024  beq cr6, 0x826b211c
	if ctx.cr[6].eq {
	pc = 0x826B211C; continue 'dispatch;
	}
	// 826B20FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B2100: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B2104: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2108: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B210C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2110: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2114: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2118: 4082FFE8  bne 0x826b2100
	if !ctx.cr[0].eq {
	pc = 0x826B2100; continue 'dispatch;
	}
	// 826B211C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B2120: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B2124: 4BE5D3A5  bl 0x8250f4c8
	ctx.lr = 0x826B2128;
	sub_8250F4C8(ctx, base);
	// 826B2128: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B212C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2130: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B2134: 409A0008  bne cr6, 0x826b213c
	if !ctx.cr[6].eq {
	pc = 0x826B213C; continue 'dispatch;
	}
	// 826B2138: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B213C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B2140: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826B2144: 4BE568D5  bl 0x82508a18
	ctx.lr = 0x826B2148;
	sub_82508A18(ctx, base);
	// 826B2148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B214C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B2150: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B2154: 388A3000  addi r4, r10, 0x3000
	ctx.r[4].s64 = ctx.r[10].s64 + 12288;
	// 826B2158: 38A0015D  li r5, 0x15d
	ctx.r[5].s64 = 349;
	// 826B215C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826B2160: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B2164: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B2168: 487A68D9  bl 0x82e58a40
	ctx.lr = 0x826B216C;
	sub_82E58A40(ctx, base);
	// 826B216C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B2170: 4873FB21  bl 0x82df1c90
	ctx.lr = 0x826B2174;
	sub_82DF1C90(ctx, base);
	// 826B2174: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B2178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B217C: 419A0008  beq cr6, 0x826b2184
	if ctx.cr[6].eq {
	pc = 0x826B2184; continue 'dispatch;
	}
	// 826B2180: 4BC0E711  bl 0x822c0890
	ctx.lr = 0x826B2184;
	sub_822C0890(ctx, base);
	// 826B2184: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B2188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B218C: 419A0008  beq cr6, 0x826b2194
	if ctx.cr[6].eq {
	pc = 0x826B2194; continue 'dispatch;
	}
	// 826B2190: 4BC0E701  bl 0x822c0890
	ctx.lr = 0x826B2194;
	sub_822C0890(ctx, base);
	// 826B2194: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B2198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B219C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B21A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B21A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B21A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B21B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B21B0 size=968
    let mut pc: u32 = 0x826B21B0;
    'dispatch: loop {
        match pc {
            0x826B21B0 => {
    //   block [0x826B21B0..0x826B2578)
	// 826B21B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B21B4: 48AF5FA9  bl 0x831a815c
	ctx.lr = 0x826B21B8;
	sub_831A8130(ctx, base);
	// 826B21B8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 826B21BC: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B21C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B21C4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B21C8: 3BABA7F0  addi r29, r11, -0x5810
	ctx.r[29].s64 = ctx.r[11].s64 + -22544;
	// 826B21CC: 815F022C  lwz r10, 0x22c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B21D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826B21D4: 419A0070  beq cr6, 0x826b2244
	if ctx.cr[6].eq {
	pc = 0x826B2244; continue 'dispatch;
	}
	// 826B21D8: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B21DC: 395D006C  addi r10, r29, 0x6c
	ctx.r[10].s64 = ctx.r[29].s64 + 108;
	// 826B21E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B21E4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B21E8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B21EC: 4874181D  bl 0x82df3a08
	ctx.lr = 0x826B21F0;
	sub_82DF3A08(ctx, base);
	// 826B21F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B21F4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826B21F8: 839F022C  lwz r28, 0x22c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B21FC: 4BE5F8ED  bl 0x82511ae8
	ctx.lr = 0x826B2200;
	sub_82511AE8(ctx, base);
	// 826B2200: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2204: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826B2208: 487C9DD1  bl 0x82e7bfd8
	ctx.lr = 0x826B220C;
	sub_82E7BFD8(ctx, base);
	// 826B220C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B2210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B2214: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826B2218: 4BE5D2B1  bl 0x8250f4c8
	ctx.lr = 0x826B221C;
	sub_8250F4C8(ctx, base);
	// 826B221C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B2220: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2224: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B2228: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826B222C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826B2230: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826B2234: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B2238: 4811CF19  bl 0x827cf150
	ctx.lr = 0x826B223C;
	sub_827CF150(ctx, base);
	// 826B223C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2240: 487411E9  bl 0x82df3428
	ctx.lr = 0x826B2244;
	sub_82DF3428(ctx, base);
	// 826B2244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2248: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B224C: 4BE5F89D  bl 0x82511ae8
	ctx.lr = 0x826B2250;
	sub_82511AE8(ctx, base);
	// 826B2250: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B2254: 395D0048  addi r10, r29, 0x48
	ctx.r[10].s64 = ctx.r[29].s64 + 72;
	// 826B2258: 813E002C  lwz r9, 0x2c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826B225C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B2260: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B2264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B2268: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B226C: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B2270: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 826B2274: 4E800421  bctrl
	ctx.lr = 0x826B2278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B2278: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826B227C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2280: 419A0008  beq cr6, 0x826b2288
	if ctx.cr[6].eq {
	pc = 0x826B2288; continue 'dispatch;
	}
	// 826B2284: 4BC0E60D  bl 0x822c0890
	ctx.lr = 0x826B2288;
	sub_822C0890(ctx, base);
	// 826B2288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B228C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826B2290: 4BE5D239  bl 0x8250f4c8
	ctx.lr = 0x826B2294;
	sub_8250F4C8(ctx, base);
	// 826B2294: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B229C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 826B22A0: 409A0008  bne cr6, 0x826b22a8
	if !ctx.cr[6].eq {
	pc = 0x826B22A8; continue 'dispatch;
	}
	// 826B22A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B22A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826B22AC: 4BE5838D  bl 0x8250a638
	ctx.lr = 0x826B22B0;
	sub_8250A638(ctx, base);
	// 826B22B0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826B22B4: 4873F9DD  bl 0x82df1c90
	ctx.lr = 0x826B22B8;
	sub_82DF1C90(ctx, base);
	// 826B22B8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826B22BC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 826B22C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B22C4: 419A0258  beq cr6, 0x826b251c
	if ctx.cr[6].eq {
	pc = 0x826B251C; continue 'dispatch;
	}
	// 826B22C8: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B22CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B22D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B22D4: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826B22D8: 48741731  bl 0x82df3a08
	ctx.lr = 0x826B22DC;
	sub_82DF3A08(ctx, base);
	// 826B22DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B22E0: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826B22E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B22E8: 4810ED21  bl 0x827c1008
	ctx.lr = 0x826B22EC;
	sub_827C1008(ctx, base);
	// 826B22EC: 83630004  lwz r27, 4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B22F0: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B22F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826B22F8: 419A0024  beq cr6, 0x826b231c
	if ctx.cr[6].eq {
	pc = 0x826B231C; continue 'dispatch;
	}
	// 826B22FC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826B2300: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B2304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2308: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B230C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2310: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2314: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2318: 4082FFE8  bne 0x826b2300
	if !ctx.cr[0].eq {
	pc = 0x826B2300; continue 'dispatch;
	}
	// 826B231C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B2320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2324: 419A0008  beq cr6, 0x826b232c
	if ctx.cr[6].eq {
	pc = 0x826B232C; continue 'dispatch;
	}
	// 826B2328: 4BC0E569  bl 0x822c0890
	ctx.lr = 0x826B232C;
	sub_822C0890(ctx, base);
	// 826B232C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2330: 487410F9  bl 0x82df3428
	ctx.lr = 0x826B2334;
	sub_82DF3428(ctx, base);
	// 826B2334: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B2338: 419A01D4  beq cr6, 0x826b250c
	if ctx.cr[6].eq {
	pc = 0x826B250C; continue 'dispatch;
	}
	// 826B233C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 826B2340: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826B2344: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 826B2348: 419A0024  beq cr6, 0x826b236c
	if ctx.cr[6].eq {
	pc = 0x826B236C; continue 'dispatch;
	}
	// 826B234C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826B2350: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B2354: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2358: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B235C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2360: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2364: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2368: 4082FFE8  bne 0x826b2350
	if !ctx.cr[0].eq {
	pc = 0x826B2350; continue 'dispatch;
	}
	// 826B236C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B2370: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B2374: 4BE5D155  bl 0x8250f4c8
	ctx.lr = 0x826B2378;
	sub_8250F4C8(ctx, base);
	// 826B2378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B237C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2380: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826B2384: 409A0008  bne cr6, 0x826b238c
	if !ctx.cr[6].eq {
	pc = 0x826B238C; continue 'dispatch;
	}
	// 826B2388: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826B238C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B2390: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B2394: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 826B2398: 4BE5D181  bl 0x8250f518
	ctx.lr = 0x826B239C;
	sub_8250F518(ctx, base);
	// 826B239C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B23A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B23A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826B23A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B23AC: 4BE5B15D  bl 0x8250d508
	ctx.lr = 0x826B23B0;
	sub_8250D508(ctx, base);
	// 826B23B0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B23B4: 4873F8DD  bl 0x82df1c90
	ctx.lr = 0x826B23B8;
	sub_82DF1C90(ctx, base);
	// 826B23B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B23BC: 4873F8D5  bl 0x82df1c90
	ctx.lr = 0x826B23C0;
	sub_82DF1C90(ctx, base);
	// 826B23C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B23C4: 4BE5F725  bl 0x82511ae8
	ctx.lr = 0x826B23C8;
	sub_82511AE8(ctx, base);
	// 826B23C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B23CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826B23D0: 4BCC2709  bl 0x82374ad8
	ctx.lr = 0x826B23D4;
	sub_82374AD8(ctx, base);
	// 826B23D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B23D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B23DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B23E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B23E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826B23E8: 419A0024  beq cr6, 0x826b240c
	if ctx.cr[6].eq {
	pc = 0x826B240C; continue 'dispatch;
	}
	// 826B23EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B23F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B23F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B23F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B23FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2400: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2404: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2408: 4082FFE8  bne 0x826b23f0
	if !ctx.cr[0].eq {
	pc = 0x826B23F0; continue 'dispatch;
	}
	// 826B240C: 3BDD0028  addi r30, r29, 0x28
	ctx.r[30].s64 = ctx.r[29].s64 + 40;
	// 826B2410: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 826B2414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B2418: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 826B241C: 48956B9D  bl 0x83008fb8
	ctx.lr = 0x826B2420;
	sub_83008FB8(ctx, base);
	// 826B2420: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B2424: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B2428: 3B8B3000  addi r28, r11, 0x3000
	ctx.r[28].s64 = ctx.r[11].s64 + 12288;
	// 826B242C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B2430: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B2434: 38A00186  li r5, 0x186
	ctx.r[5].s64 = 390;
	// 826B2438: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B243C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B2440: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 826B2444: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B2448: 487A65F9  bl 0x82e58a40
	ctx.lr = 0x826B244C;
	sub_82E58A40(ctx, base);
	// 826B244C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B2450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2454: 419A0008  beq cr6, 0x826b245c
	if ctx.cr[6].eq {
	pc = 0x826B245C; continue 'dispatch;
	}
	// 826B2458: 4BC0E439  bl 0x822c0890
	ctx.lr = 0x826B245C;
	sub_822C0890(ctx, base);
	// 826B245C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826B2460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2464: 419A0008  beq cr6, 0x826b246c
	if ctx.cr[6].eq {
	pc = 0x826B246C; continue 'dispatch;
	}
	// 826B2468: 4BC0E429  bl 0x822c0890
	ctx.lr = 0x826B246C;
	sub_822C0890(ctx, base);
	// 826B246C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2470: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 826B2474: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 826B2478: 4BE5F6E1  bl 0x82511b58
	ctx.lr = 0x826B247C;
	sub_82511B58(ctx, base);
	// 826B247C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2480: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B2484: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 826B2488: 4BEE9B09  bl 0x8259bf90
	ctx.lr = 0x826B248C;
	sub_8259BF90(ctx, base);
	// 826B248C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2490: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826B2494: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B2498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B249C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826B24A0: 419A0024  beq cr6, 0x826b24c4
	if ctx.cr[6].eq {
	pc = 0x826B24C4; continue 'dispatch;
	}
	// 826B24A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B24A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B24AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B24B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B24B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B24B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B24BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B24C0: 4082FFE8  bne 0x826b24a8
	if !ctx.cr[0].eq {
	pc = 0x826B24A8; continue 'dispatch;
	}
	// 826B24C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B24C8: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 826B24CC: 48956AED  bl 0x83008fb8
	ctx.lr = 0x826B24D0;
	sub_83008FB8(ctx, base);
	// 826B24D0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B24D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B24D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B24DC: 38A00187  li r5, 0x187
	ctx.r[5].s64 = 391;
	// 826B24E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B24E4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B24E8: 487A6559  bl 0x82e58a40
	ctx.lr = 0x826B24EC;
	sub_82E58A40(ctx, base);
	// 826B24EC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B24F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B24F4: 419A0008  beq cr6, 0x826b24fc
	if ctx.cr[6].eq {
	pc = 0x826B24FC; continue 'dispatch;
	}
	// 826B24F8: 4BC0E399  bl 0x822c0890
	ctx.lr = 0x826B24FC;
	sub_822C0890(ctx, base);
	// 826B24FC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826B2500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2504: 419A0008  beq cr6, 0x826b250c
	if ctx.cr[6].eq {
	pc = 0x826B250C; continue 'dispatch;
	}
	// 826B2508: 4BC0E389  bl 0x822c0890
	ctx.lr = 0x826B250C;
	sub_822C0890(ctx, base);
	// 826B250C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826B2510: 419A000C  beq cr6, 0x826b251c
	if ctx.cr[6].eq {
	pc = 0x826B251C; continue 'dispatch;
	}
	// 826B2514: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B2518: 4BC0E379  bl 0x822c0890
	ctx.lr = 0x826B251C;
	sub_822C0890(ctx, base);
	// 826B251C: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 826B2520: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B2524: 38BF021C  addi r5, r31, 0x21c
	ctx.r[5].s64 = ctx.r[31].s64 + 540;
	// 826B2528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B252C: 809E7058  lwz r4, 0x7058(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B2530: 4BE5DCC1  bl 0x825101f0
	ctx.lr = 0x826B2534;
	sub_825101F0(ctx, base);
	// 826B2534: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B2538: 809E7058  lwz r4, 0x7058(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B253C: 38BF0224  addi r5, r31, 0x224
	ctx.r[5].s64 = ctx.r[31].s64 + 548;
	// 826B2540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2544: 4BE5DCAD  bl 0x825101f0
	ctx.lr = 0x826B2548;
	sub_825101F0(ctx, base);
	// 826B2548: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B254C: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B2550: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 826B2554: 4BDDCE4D  bl 0x8248f3a0
	ctx.lr = 0x826B2558;
	sub_8248F3A0(ctx, base);
	// 826B2558: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826B255C: 9B5F024C  stb r26, 0x24c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[26].u8 ) };
	// 826B2560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2564: 419A0008  beq cr6, 0x826b256c
	if ctx.cr[6].eq {
	pc = 0x826B256C; continue 'dispatch;
	}
	// 826B2568: 4BC0E329  bl 0x822c0890
	ctx.lr = 0x826B256C;
	sub_822C0890(ctx, base);
	// 826B256C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826B2570: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 826B2574: 48AF5C38  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B2578 size=432
    let mut pc: u32 = 0x826B2578;
    'dispatch: loop {
        match pc {
            0x826B2578 => {
    //   block [0x826B2578..0x826B2728)
	// 826B2578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B257C: 48AF5BE9  bl 0x831a8164
	ctx.lr = 0x826B2580;
	sub_831A8130(ctx, base);
	// 826B2580: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2584: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B2588: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B258C: 3BCB3000  addi r30, r11, 0x3000
	ctx.r[30].s64 = ctx.r[11].s64 + 12288;
	// 826B2590: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B2594: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826B2598: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B259C: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 826B25A0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826B25A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B25A8: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 826B25AC: 4873FE3D  bl 0x82df23e8
	ctx.lr = 0x826B25B0;
	sub_82DF23E8(ctx, base);
	// 826B25B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B25B4: 41820014  beq 0x826b25c8
	if ctx.cr[0].eq {
	pc = 0x826B25C8; continue 'dispatch;
	}
	// 826B25B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B25BC: 4BFFF62D  bl 0x826b1be8
	ctx.lr = 0x826B25C0;
	sub_826B1BE8(ctx, base);
	// 826B25C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B25C4: 48000008  b 0x826b25cc
	pc = 0x826B25CC; continue 'dispatch;
	// 826B25C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B25CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826B25D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B25D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B25D8: 4BFFEF89  bl 0x826b1560
	ctx.lr = 0x826B25DC;
	sub_826B1560(ctx, base);
	// 826B25DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B25E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B25E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B25E8: 4BC0DA19  bl 0x822c0000
	ctx.lr = 0x826B25EC;
	sub_822C0000(ctx, base);
	// 826B25EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B25F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B25F4: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 826B25F8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826B25FC: 4BC0DDDD  bl 0x822c03d8
	ctx.lr = 0x826B2600;
	sub_822C03D8(ctx, base);
	// 826B2600: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B2604: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826B2608: 418200B4  beq 0x826b26bc
	if ctx.cr[0].eq {
	pc = 0x826B26BC; continue 'dispatch;
	}
	// 826B260C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826B2610: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826B2614: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826B2618: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826B261C: 409A0008  bne cr6, 0x826b2624
	if !ctx.cr[6].eq {
	pc = 0x826B2624; continue 'dispatch;
	}
	// 826B2620: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B2624: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B2628: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B262C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826B2630: 419A0024  beq cr6, 0x826b2654
	if ctx.cr[6].eq {
	pc = 0x826B2654; continue 'dispatch;
	}
	// 826B2634: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826B2638: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826B263C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2640: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826B2644: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826B2648: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B264C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2650: 4082FFE8  bne 0x826b2638
	if !ctx.cr[0].eq {
	pc = 0x826B2638; continue 'dispatch;
	}
	// 826B2654: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826B2658: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B265C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826B2660: 419A0024  beq cr6, 0x826b2684
	if ctx.cr[6].eq {
	pc = 0x826B2684; continue 'dispatch;
	}
	// 826B2664: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826B2668: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B266C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2670: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B2674: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2678: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B267C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2680: 4082FFE8  bne 0x826b2668
	if !ctx.cr[0].eq {
	pc = 0x826B2668; continue 'dispatch;
	}
	// 826B2684: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B2688: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826B268C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826B2690: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826B2694: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826B2698: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B269C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B26A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B26A4: 480E688D  bl 0x82798f30
	ctx.lr = 0x826B26A8;
	sub_82798F30(ctx, base);
	// 826B26A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B26AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B26B0: 480E8FB9  bl 0x8279b668
	ctx.lr = 0x826B26B4;
	sub_8279B668(ctx, base);
	// 826B26B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B26B8: 48000008  b 0x826b26c0
	pc = 0x826B26C0; continue 'dispatch;
	// 826B26BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B26C0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826B26C4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826B26C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B26CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B26D0: 4BEE5581  bl 0x82597c50
	ctx.lr = 0x826B26D4;
	sub_82597C50(ctx, base);
	// 826B26D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B26D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B26DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B26E0: 4BC0D921  bl 0x822c0000
	ctx.lr = 0x826B26E4;
	sub_822C0000(ctx, base);
	// 826B26E4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B26E8: 41820024  beq 0x826b270c
	if ctx.cr[0].eq {
	pc = 0x826B270C; continue 'dispatch;
	}
	// 826B26EC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826B26F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B26F4: 419A0008  beq cr6, 0x826b26fc
	if ctx.cr[6].eq {
	pc = 0x826B26FC; continue 'dispatch;
	}
	// 826B26F8: 4BC0E199  bl 0x822c0890
	ctx.lr = 0x826B26FC;
	sub_822C0890(ctx, base);
	// 826B26FC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B2700: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2704: 419A0008  beq cr6, 0x826b270c
	if ctx.cr[6].eq {
	pc = 0x826B270C; continue 'dispatch;
	}
	// 826B2708: 4BC0E189  bl 0x822c0890
	ctx.lr = 0x826B270C;
	sub_822C0890(ctx, base);
	// 826B270C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B2710: 419A000C  beq cr6, 0x826b271c
	if ctx.cr[6].eq {
	pc = 0x826B271C; continue 'dispatch;
	}
	// 826B2714: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B2718: 4BC0E179  bl 0x822c0890
	ctx.lr = 0x826B271C;
	sub_822C0890(ctx, base);
	// 826B271C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B2720: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826B2724: 48AF5A90  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2728 size=52
    let mut pc: u32 = 0x826B2728;
    'dispatch: loop {
        match pc {
            0x826B2728 => {
    //   block [0x826B2728..0x826B275C)
	// 826B2728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B272C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B2730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B2734: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2738: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B273C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2740: 4BFFFE39  bl 0x826b2578
	ctx.lr = 0x826B2744;
	sub_826B2578(ctx, base);
	// 826B2744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B274C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B2750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B2754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B2758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2760 size=52
    let mut pc: u32 = 0x826B2760;
    'dispatch: loop {
        match pc {
            0x826B2760 => {
    //   block [0x826B2760..0x826B2794)
	// 826B2760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B2764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B2768: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B276C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2770: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B2774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2778: 4BFFFE01  bl 0x826b2578
	ctx.lr = 0x826B277C;
	sub_826B2578(ctx, base);
	// 826B277C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2780: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B2784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B2788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B278C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B2790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2798 size=52
    let mut pc: u32 = 0x826B2798;
    'dispatch: loop {
        match pc {
            0x826B2798 => {
    //   block [0x826B2798..0x826B27CC)
	// 826B2798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B279C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B27A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B27A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B27A8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826B27AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B27B0: 4BFFFDC9  bl 0x826b2578
	ctx.lr = 0x826B27B4;
	sub_826B2578(ctx, base);
	// 826B27B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B27B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B27BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B27C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B27C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B27C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B27D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B27D0 size=52
    let mut pc: u32 = 0x826B27D0;
    'dispatch: loop {
        match pc {
            0x826B27D0 => {
    //   block [0x826B27D0..0x826B2804)
	// 826B27D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B27D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B27D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B27DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B27E0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826B27E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B27E8: 4BFFFD91  bl 0x826b2578
	ctx.lr = 0x826B27EC;
	sub_826B2578(ctx, base);
	// 826B27EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B27F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B27F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B27F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B27FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B2800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2808 size=52
    let mut pc: u32 = 0x826B2808;
    'dispatch: loop {
        match pc {
            0x826B2808 => {
    //   block [0x826B2808..0x826B283C)
	// 826B2808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B280C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B2810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B2814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2818: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826B281C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2820: 4BFFFD59  bl 0x826b2578
	ctx.lr = 0x826B2824;
	sub_826B2578(ctx, base);
	// 826B2824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2828: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B282C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B2830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B2834: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B2838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2840 size=52
    let mut pc: u32 = 0x826B2840;
    'dispatch: loop {
        match pc {
            0x826B2840 => {
    //   block [0x826B2840..0x826B2874)
	// 826B2840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B2844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B2848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B284C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2850: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826B2854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2858: 4BFFFD21  bl 0x826b2578
	ctx.lr = 0x826B285C;
	sub_826B2578(ctx, base);
	// 826B285C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2860: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B2864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B2868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B286C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B2870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2878 size=52
    let mut pc: u32 = 0x826B2878;
    'dispatch: loop {
        match pc {
            0x826B2878 => {
    //   block [0x826B2878..0x826B28AC)
	// 826B2878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B287C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B2880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B2884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2888: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826B288C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2890: 4BFFFCE9  bl 0x826b2578
	ctx.lr = 0x826B2894;
	sub_826B2578(ctx, base);
	// 826B2894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2898: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B289C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B28A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B28A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B28A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B28B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B28B0 size=52
    let mut pc: u32 = 0x826B28B0;
    'dispatch: loop {
        match pc {
            0x826B28B0 => {
    //   block [0x826B28B0..0x826B28E4)
	// 826B28B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B28B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B28B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B28BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B28C0: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826B28C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B28C8: 4BFFFCB1  bl 0x826b2578
	ctx.lr = 0x826B28CC;
	sub_826B2578(ctx, base);
	// 826B28CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B28D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B28D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B28D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B28DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B28E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B28E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B28E8 size=52
    let mut pc: u32 = 0x826B28E8;
    'dispatch: loop {
        match pc {
            0x826B28E8 => {
    //   block [0x826B28E8..0x826B291C)
	// 826B28E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B28EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B28F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B28F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B28F8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826B28FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2900: 4BFFFC79  bl 0x826b2578
	ctx.lr = 0x826B2904;
	sub_826B2578(ctx, base);
	// 826B2904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2908: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B290C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B2910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B2914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B2918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B2920 size=1592
    let mut pc: u32 = 0x826B2920;
    'dispatch: loop {
        match pc {
            0x826B2920 => {
    //   block [0x826B2920..0x826B2F58)
	// 826B2920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B2924: 48AF5831  bl 0x831a8154
	ctx.lr = 0x826B2928;
	sub_831A8130(ctx, base);
	// 826B2928: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B292C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2930: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 826B2934: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826B2938: 4BFF1DF1  bl 0x826a4728
	ctx.lr = 0x826B293C;
	sub_826A4728(ctx, base);
	// 826B293C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B2940: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2944: 3B2B3000  addi r25, r11, 0x3000
	ctx.r[25].s64 = ctx.r[11].s64 + 12288;
	// 826B2948: 38A000E4  li r5, 0xe4
	ctx.r[5].s64 = 228;
	// 826B294C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B2950: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826B2954: 4873FA95  bl 0x82df23e8
	ctx.lr = 0x826B2958;
	sub_82DF23E8(ctx, base);
	// 826B2958: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B295C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 826B2960: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B2964: 3BCB6880  addi r30, r11, 0x6880
	ctx.r[30].s64 = ctx.r[11].s64 + 26752;
	// 826B2968: 41820014  beq 0x826b297c
	if ctx.cr[0].eq {
	pc = 0x826B297C; continue 'dispatch;
	}
	// 826B296C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B2970: 48760781  bl 0x82e130f0
	ctx.lr = 0x826B2974;
	sub_82E130F0(ctx, base);
	// 826B2974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2978: 48000008  b 0x826b2980
	pc = 0x826B2980; continue 'dispatch;
	// 826B297C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B2980: 3B7F0238  addi r27, r31, 0x238
	ctx.r[27].s64 = ctx.r[31].s64 + 568;
	// 826B2984: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B2988: 4BC2F3C9  bl 0x822e1d50
	ctx.lr = 0x826B298C;
	sub_822E1D50(ctx, base);
	// 826B298C: 809F0238  lwz r4, 0x238(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 826B2990: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826B2994: 4876049D  bl 0x82e12e30
	ctx.lr = 0x826B2998;
	sub_82E12E30(ctx, base);
	// 826B2998: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B299C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B29A0: 38A000E8  li r5, 0xe8
	ctx.r[5].s64 = 232;
	// 826B29A4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826B29A8: 4873FA41  bl 0x82df23e8
	ctx.lr = 0x826B29AC;
	sub_82DF23E8(ctx, base);
	// 826B29AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B29B0: 41820014  beq 0x826b29c4
	if ctx.cr[0].eq {
	pc = 0x826B29C4; continue 'dispatch;
	}
	// 826B29B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B29B8: 48760739  bl 0x82e130f0
	ctx.lr = 0x826B29BC;
	sub_82E130F0(ctx, base);
	// 826B29BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B29C0: 48000008  b 0x826b29c8
	pc = 0x826B29C8; continue 'dispatch;
	// 826B29C4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B29C8: 3BDF0240  addi r30, r31, 0x240
	ctx.r[30].s64 = ctx.r[31].s64 + 576;
	// 826B29CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B29D0: 4BC2F381  bl 0x822e1d50
	ctx.lr = 0x826B29D4;
	sub_822E1D50(ctx, base);
	// 826B29D4: 809F0240  lwz r4, 0x240(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 826B29D8: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B29DC: 48760455  bl 0x82e12e30
	ctx.lr = 0x826B29E0;
	sub_82E12E30(ctx, base);
	// 826B29E0: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 826B29E4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826B29E8: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 826B29EC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B29F0: 487780F9  bl 0x82e2aae8
	ctx.lr = 0x826B29F4;
	sub_82E2AAE8(ctx, base);
	// 826B29F4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B29F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B29FC: 3B8BA784  addi r28, r11, -0x587c
	ctx.r[28].s64 = ctx.r[11].s64 + -22652;
	// 826B2A00: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B2A04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B2A08: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826B2A0C: 48740FFD  bl 0x82df3a08
	ctx.lr = 0x826B2A10;
	sub_82DF3A08(ctx, base);
	// 826B2A10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2A14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B2A18: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826B2A1C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B2A20: 4877C451  bl 0x82e2ee70
	ctx.lr = 0x826B2A24;
	sub_82E2EE70(ctx, base);
	// 826B2A24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826B2A28: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826B2A2C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826B2A30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2A34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B2A38: 4BC11A29  bl 0x822c4460
	ctx.lr = 0x826B2A3C;
	sub_822C4460(ctx, base);
	// 826B2A3C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826B2A40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2A44: 419A0008  beq cr6, 0x826b2a4c
	if ctx.cr[6].eq {
	pc = 0x826B2A4C; continue 'dispatch;
	}
	// 826B2A48: 4BC0DE49  bl 0x822c0890
	ctx.lr = 0x826B2A4C;
	sub_822C0890(ctx, base);
	// 826B2A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2A50: 487409D9  bl 0x82df3428
	ctx.lr = 0x826B2A54;
	sub_82DF3428(ctx, base);
	// 826B2A54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826B2A58: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 826B2A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2A60: 419A0098  beq cr6, 0x826b2af8
	if ctx.cr[6].eq {
	pc = 0x826B2AF8; continue 'dispatch;
	}
	// 826B2A64: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B2A68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2A6C: 38A000F1  li r5, 0xf1
	ctx.r[5].s64 = 241;
	// 826B2A70: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826B2A74: 4873F975  bl 0x82df23e8
	ctx.lr = 0x826B2A78;
	sub_82DF23E8(ctx, base);
	// 826B2A78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B2A7C: 41820014  beq 0x826b2a90
	if ctx.cr[0].eq {
	pc = 0x826B2A90; continue 'dispatch;
	}
	// 826B2A80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B2A84: 48763E0D  bl 0x82e16890
	ctx.lr = 0x826B2A88;
	sub_82E16890(ctx, base);
	// 826B2A88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2A8C: 48000008  b 0x826b2a94
	pc = 0x826B2A94; continue 'dispatch;
	// 826B2A90: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B2A94: 3BBF0214  addi r29, r31, 0x214
	ctx.r[29].s64 = ctx.r[31].s64 + 532;
	// 826B2A98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B2A9C: 4BCAA8D5  bl 0x8235d370
	ctx.lr = 0x826B2AA0;
	sub_8235D370(ctx, base);
	// 826B2AA0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B2AA4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2AAC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B2AB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B2AB4: 419A0024  beq cr6, 0x826b2ad8
	if ctx.cr[6].eq {
	pc = 0x826B2AD8; continue 'dispatch;
	}
	// 826B2AB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B2ABC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B2AC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2AC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B2AC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2ACC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2AD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2AD4: 4082FFE8  bne 0x826b2abc
	if !ctx.cr[0].eq {
	pc = 0x826B2ABC; continue 'dispatch;
	}
	// 826B2AD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B2ADC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2AE0: 487625D1  bl 0x82e150b0
	ctx.lr = 0x826B2AE4;
	sub_82E150B0(ctx, base);
	// 826B2AE4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B2AE8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826B2AEC: 809A7058  lwz r4, 0x7058(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B2AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2AF4: 4BE5E065  bl 0x82510b58
	ctx.lr = 0x826B2AF8;
	sub_82510B58(ctx, base);
	// 826B2AF8: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B2AFC: 395C0024  addi r10, r28, 0x24
	ctx.r[10].s64 = ctx.r[28].s64 + 36;
	// 826B2B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2B04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B2B08: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B2B0C: 48740EFD  bl 0x82df3a08
	ctx.lr = 0x826B2B10;
	sub_82DF3A08(ctx, base);
	// 826B2B10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2B14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B2B18: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826B2B1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B2B20: 4877C351  bl 0x82e2ee70
	ctx.lr = 0x826B2B24;
	sub_82E2EE70(ctx, base);
	// 826B2B24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826B2B28: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826B2B2C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826B2B30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2B34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B2B38: 4BC11929  bl 0x822c4460
	ctx.lr = 0x826B2B3C;
	sub_822C4460(ctx, base);
	// 826B2B3C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B2B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2B44: 419A0008  beq cr6, 0x826b2b4c
	if ctx.cr[6].eq {
	pc = 0x826B2B4C; continue 'dispatch;
	}
	// 826B2B48: 4BC0DD49  bl 0x822c0890
	ctx.lr = 0x826B2B4C;
	sub_822C0890(ctx, base);
	// 826B2B4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2B50: 487408D9  bl 0x82df3428
	ctx.lr = 0x826B2B54;
	sub_82DF3428(ctx, base);
	// 826B2B54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826B2B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2B5C: 419A0084  beq cr6, 0x826b2be0
	if ctx.cr[6].eq {
	pc = 0x826B2BE0; continue 'dispatch;
	}
	// 826B2B60: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B2B64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2B68: 38A000F8  li r5, 0xf8
	ctx.r[5].s64 = 248;
	// 826B2B6C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826B2B70: 4873F879  bl 0x82df23e8
	ctx.lr = 0x826B2B74;
	sub_82DF23E8(ctx, base);
	// 826B2B74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B2B78: 41820014  beq 0x826b2b8c
	if ctx.cr[0].eq {
	pc = 0x826B2B8C; continue 'dispatch;
	}
	// 826B2B7C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B2B80: 48763D11  bl 0x82e16890
	ctx.lr = 0x826B2B84;
	sub_82E16890(ctx, base);
	// 826B2B84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2B88: 48000008  b 0x826b2b90
	pc = 0x826B2B90; continue 'dispatch;
	// 826B2B8C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B2B90: 3BBF021C  addi r29, r31, 0x21c
	ctx.r[29].s64 = ctx.r[31].s64 + 540;
	// 826B2B94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B2B98: 4BCAA7D9  bl 0x8235d370
	ctx.lr = 0x826B2B9C;
	sub_8235D370(ctx, base);
	// 826B2B9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B2BA0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2BA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B2BAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B2BB0: 419A0024  beq cr6, 0x826b2bd4
	if ctx.cr[6].eq {
	pc = 0x826B2BD4; continue 'dispatch;
	}
	// 826B2BB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B2BB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B2BBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2BC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B2BC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2BC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2BCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2BD0: 4082FFE8  bne 0x826b2bb8
	if !ctx.cr[0].eq {
	pc = 0x826B2BB8; continue 'dispatch;
	}
	// 826B2BD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B2BD8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2BDC: 487624D5  bl 0x82e150b0
	ctx.lr = 0x826B2BE0;
	sub_82E150B0(ctx, base);
	// 826B2BE0: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B2BE4: 395C0048  addi r10, r28, 0x48
	ctx.r[10].s64 = ctx.r[28].s64 + 72;
	// 826B2BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2BEC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B2BF0: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B2BF4: 48740E15  bl 0x82df3a08
	ctx.lr = 0x826B2BF8;
	sub_82DF3A08(ctx, base);
	// 826B2BF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2BFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B2C00: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826B2C04: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826B2C08: 4877C269  bl 0x82e2ee70
	ctx.lr = 0x826B2C0C;
	sub_82E2EE70(ctx, base);
	// 826B2C0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826B2C10: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826B2C14: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826B2C18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2C1C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B2C20: 4BC11841  bl 0x822c4460
	ctx.lr = 0x826B2C24;
	sub_822C4460(ctx, base);
	// 826B2C24: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826B2C28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B2C2C: 419A0008  beq cr6, 0x826b2c34
	if ctx.cr[6].eq {
	pc = 0x826B2C34; continue 'dispatch;
	}
	// 826B2C30: 4BC0DC61  bl 0x822c0890
	ctx.lr = 0x826B2C34;
	sub_822C0890(ctx, base);
	// 826B2C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2C38: 487407F1  bl 0x82df3428
	ctx.lr = 0x826B2C3C;
	sub_82DF3428(ctx, base);
	// 826B2C3C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826B2C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2C44: 419A0084  beq cr6, 0x826b2cc8
	if ctx.cr[6].eq {
	pc = 0x826B2CC8; continue 'dispatch;
	}
	// 826B2C48: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B2C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2C50: 38A000FE  li r5, 0xfe
	ctx.r[5].s64 = 254;
	// 826B2C54: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826B2C58: 4873F791  bl 0x82df23e8
	ctx.lr = 0x826B2C5C;
	sub_82DF23E8(ctx, base);
	// 826B2C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B2C60: 41820014  beq 0x826b2c74
	if ctx.cr[0].eq {
	pc = 0x826B2C74; continue 'dispatch;
	}
	// 826B2C64: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B2C68: 48763C29  bl 0x82e16890
	ctx.lr = 0x826B2C6C;
	sub_82E16890(ctx, base);
	// 826B2C6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2C70: 48000008  b 0x826b2c78
	pc = 0x826B2C78; continue 'dispatch;
	// 826B2C74: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B2C78: 3BBF0224  addi r29, r31, 0x224
	ctx.r[29].s64 = ctx.r[31].s64 + 548;
	// 826B2C7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B2C80: 4BCAA6F1  bl 0x8235d370
	ctx.lr = 0x826B2C84;
	sub_8235D370(ctx, base);
	// 826B2C84: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B2C88: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B2C90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B2C94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B2C98: 419A0024  beq cr6, 0x826b2cbc
	if ctx.cr[6].eq {
	pc = 0x826B2CBC; continue 'dispatch;
	}
	// 826B2C9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B2CA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B2CA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2CA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B2CAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B2CB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B2CB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B2CB8: 4082FFE8  bne 0x826b2ca0
	if !ctx.cr[0].eq {
	pc = 0x826B2CA0; continue 'dispatch;
	}
	// 826B2CBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B2CC0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2CC4: 487623ED  bl 0x82e150b0
	ctx.lr = 0x826B2CC8;
	sub_82E150B0(ctx, base);
	// 826B2CC8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826B2CCC: 48819D1D  bl 0x82ecc9e8
	ctx.lr = 0x826B2CD0;
	sub_82ECC9E8(ctx, base);
	// 826B2CD0: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 826B2CD4: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B2CD8: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 826B2CDC: 99610160  stb r11, 0x160(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u8 ) };
	// 826B2CE0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826B2CE4: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826B2CE8: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826B2CEC: 487EDA45  bl 0x82ea0730
	ctx.lr = 0x826B2CF0;
	sub_82EA0730(ctx, base);
	// 826B2CF0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B2CF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826B2CF8: 396B3060  addi r11, r11, 0x3060
	ctx.r[11].s64 = ctx.r[11].s64 + 12384;
	// 826B2CFC: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 826B2D00: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 826B2D04: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 826B2D08: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 826B2D0C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B2D10: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B2D14: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B2D18: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2F58 size=148
    let mut pc: u32 = 0x826B2F58;
    'dispatch: loop {
        match pc {
            0x826B2F58 => {
    //   block [0x826B2F58..0x826B2FEC)
	// 826B2F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B2F5C: 48AF5211  bl 0x831a816c
	ctx.lr = 0x826B2F60;
	sub_831A8130(ctx, base);
	// 826B2F60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B2F64: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 826B2F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B2F6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B2F70: 38BF021C  addi r5, r31, 0x21c
	ctx.r[5].s64 = ctx.r[31].s64 + 540;
	// 826B2F74: 809E7058  lwz r4, 0x7058(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B2F78: 4BE5DBE1  bl 0x82510b58
	ctx.lr = 0x826B2F7C;
	sub_82510B58(ctx, base);
	// 826B2F7C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B2F80: 809E7058  lwz r4, 0x7058(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B2F84: 38BF0224  addi r5, r31, 0x224
	ctx.r[5].s64 = ctx.r[31].s64 + 548;
	// 826B2F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B2F8C: 4BE5DBCD  bl 0x82510b58
	ctx.lr = 0x826B2F90;
	sub_82510B58(ctx, base);
	// 826B2F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B2F94: 83DF0230  lwz r30, 0x230(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B2F98: 4BC31F29  bl 0x822e4ec0
	ctx.lr = 0x826B2F9C;
	sub_822E4EC0(ctx, base);
	// 826B2F9C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B2FA0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826B2FA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B2FA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B2FAC: 80AB6750  lwz r5, 0x6750(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 826B2FB0: 808A6850  lwz r4, 0x6850(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26704 as u32) ) } as u64;
	// 826B2FB4: 4BC447ED  bl 0x822f77a0
	ctx.lr = 0x826B2FB8;
	sub_822F77A0(ctx, base);
	// 826B2FB8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826B2FBC: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 826B2FC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B2FC4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826B2FC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B2FCC: 4BDD92BD  bl 0x8248c288
	ctx.lr = 0x826B2FD0;
	sub_8248C288(ctx, base);
	// 826B2FD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B2FD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B2FD8: 4BDDC3C9  bl 0x8248f3a0
	ctx.lr = 0x826B2FDC;
	sub_8248F3A0(ctx, base);
	// 826B2FDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B2FE0: 997F024C  stb r11, 0x24c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u8 ) };
	// 826B2FE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B2FE8: 48AF51D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B2FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B2FF0 size=196
    let mut pc: u32 = 0x826B2FF0;
    'dispatch: loop {
        match pc {
            0x826B2FF0 => {
    //   block [0x826B2FF0..0x826B30B4)
	// 826B2FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B2FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B2FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B2FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B3008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B300C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826B3010: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B3014: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B3018: 4BC0D921  bl 0x822c0938
	ctx.lr = 0x826B301C;
	sub_822C0938(ctx, base);
	// 826B301C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B3020: 41820028  beq 0x826b3048
	if ctx.cr[0].eq {
	pc = 0x826B3048; continue 'dispatch;
	}
	// 826B3024: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3028: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826B302C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826B3030: 392B3074  addi r9, r11, 0x3074
	ctx.r[9].s64 = ctx.r[11].s64 + 12404;
	// 826B3034: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826B3038: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826B303C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826B3040: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826B3044: 48000008  b 0x826b304c
	pc = 0x826B304C; continue 'dispatch;
	// 826B3048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B304C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B3050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B3054: 409A0044  bne cr6, 0x826b3098
	if !ctx.cr[6].eq {
	pc = 0x826B3098; continue 'dispatch;
	}
	// 826B3058: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826B305C: 419A001C  beq cr6, 0x826b3078
	if ctx.cr[6].eq {
	pc = 0x826B3078; continue 'dispatch;
	}
	// 826B3060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3064: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B3068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B306C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B3074: 4E800421  bctrl
	ctx.lr = 0x826B3078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B3078: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B307C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B3080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3084: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826B3088: 816BA8F4  lwz r11, -0x570c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22284 as u32) ) } as u64;
	// 826B308C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B3090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B3094: 4BC0CF6D  bl 0x822c0000
	ctx.lr = 0x826B3098;
	sub_822C0000(ctx, base);
	// 826B3098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B309C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B30A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B30A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B30A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B30AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B30B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B30B8 size=128
    let mut pc: u32 = 0x826B30B8;
    'dispatch: loop {
        match pc {
            0x826B30B8 => {
    //   block [0x826B30B8..0x826B3138)
	// 826B30B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B30BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B30C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B30C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B30C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B30CC: 4BE5F195  bl 0x82512260
	ctx.lr = 0x826B30D0;
	sub_82512260(ctx, base);
	// 826B30D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826B30D4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B30D8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826B30DC: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B30E0: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 826B30E4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826B30E8: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 826B30EC: 394A30EC  addi r10, r10, 0x30ec
	ctx.r[10].s64 = ctx.r[10].s64 + 12524;
	// 826B30F0: 392930D8  addi r9, r9, 0x30d8
	ctx.r[9].s64 = ctx.r[9].s64 + 12504;
	// 826B30F4: 3908308C  addi r8, r8, 0x308c
	ctx.r[8].s64 = ctx.r[8].s64 + 12428;
	// 826B30F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826B30FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B3100: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826B3104: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826B3108: C00708A4  lfs f0, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B310C: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 826B3110: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826B3114: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826B3118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B311C: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826B3120: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826B3124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B3128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B312C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B3130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B3134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B3138 size=8
    let mut pc: u32 = 0x826B3138;
    'dispatch: loop {
        match pc {
            0x826B3138 => {
    //   block [0x826B3138..0x826B3140)
	// 826B3138: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826B313C: 480003C4  b 0x826b3500
	sub_826B3500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B3140 size=8
    let mut pc: u32 = 0x826B3140;
    'dispatch: loop {
        match pc {
            0x826B3140 => {
    //   block [0x826B3140..0x826B3148)
	// 826B3140: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826B3144: 480003BC  b 0x826b3500
	sub_826B3500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B3148 size=92
    let mut pc: u32 = 0x826B3148;
    'dispatch: loop {
        match pc {
            0x826B3148 => {
    //   block [0x826B3148..0x826B31A4)
	// 826B3148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B314C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3154: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B315C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3160: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B3164: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B3168: 396B30EC  addi r11, r11, 0x30ec
	ctx.r[11].s64 = ctx.r[11].s64 + 12524;
	// 826B316C: 394A30D8  addi r10, r10, 0x30d8
	ctx.r[10].s64 = ctx.r[10].s64 + 12504;
	// 826B3170: 3929308C  addi r9, r9, 0x308c
	ctx.r[9].s64 = ctx.r[9].s64 + 12428;
	// 826B3174: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B3178: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B317C: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826B3180: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B3184: 480F44D5  bl 0x827a7658
	ctx.lr = 0x826B3188;
	sub_827A7658(ctx, base);
	// 826B3188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B318C: 4BC9C1C5  bl 0x8234f350
	ctx.lr = 0x826B3190;
	sub_8234F350(ctx, base);
	// 826B3190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B3194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B3198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B319C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B31A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B31A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B31A8 size=852
    let mut pc: u32 = 0x826B31A8;
    'dispatch: loop {
        match pc {
            0x826B31A8 => {
    //   block [0x826B31A8..0x826B34FC)
	// 826B31A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B31AC: 48AF4FBD  bl 0x831a8168
	ctx.lr = 0x826B31B0;
	sub_831A8130(ctx, base);
	// 826B31B0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B31B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826B31B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826B31BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B31C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B31C4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 826B31C8: 419A032C  beq cr6, 0x826b34f4
	if ctx.cr[6].eq {
	pc = 0x826B34F4; continue 'dispatch;
	}
	// 826B31CC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B31D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B31D4: 388B3130  addi r4, r11, 0x3130
	ctx.r[4].s64 = ctx.r[11].s64 + 12592;
	// 826B31D8: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 826B31DC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826B31E0: 4BC0D1F9  bl 0x822c03d8
	ctx.lr = 0x826B31E4;
	sub_822C03D8(ctx, base);
	// 826B31E4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826B31E8: 41820034  beq 0x826b321c
	if ctx.cr[0].eq {
	pc = 0x826B321C; continue 'dispatch;
	}
	// 826B31EC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B31F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B31F4: 388BEE4C  addi r4, r11, -0x11b4
	ctx.r[4].s64 = ctx.r[11].s64 + -4532;
	// 826B31F8: 48740811  bl 0x82df3a08
	ctx.lr = 0x826B31FC;
	sub_82DF3A08(ctx, base);
	// 826B31FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B3200: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826B3204: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B3208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B320C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826B3210: 4BEF9201  bl 0x825ac410
	ctx.lr = 0x826B3214;
	sub_825AC410(ctx, base);
	// 826B3214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3218: 48000008  b 0x826b3220
	pc = 0x826B3220; continue 'dispatch;
	// 826B321C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B3220: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826B3224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B3228: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826B322C: 4BE4018D  bl 0x824f33b8
	ctx.lr = 0x826B3230;
	sub_824F33B8(ctx, base);
	// 826B3230: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B3234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B3238: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826B323C: 4BC0CDC5  bl 0x822c0000
	ctx.lr = 0x826B3240;
	sub_822C0000(ctx, base);
	// 826B3240: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B3244: 4182000C  beq 0x826b3250
	if ctx.cr[0].eq {
	pc = 0x826B3250; continue 'dispatch;
	}
	// 826B3248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B324C: 487401DD  bl 0x82df3428
	ctx.lr = 0x826B3250;
	sub_82DF3428(ctx, base);
	// 826B3250: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3258: 388BEE30  addi r4, r11, -0x11d0
	ctx.r[4].s64 = ctx.r[11].s64 + -4560;
	// 826B325C: 487407AD  bl 0x82df3a08
	ctx.lr = 0x826B3260;
	sub_82DF3A08(ctx, base);
	// 826B3260: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826B3264: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B3268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B326C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B3270: 4BEF8B51  bl 0x825abdc0
	ctx.lr = 0x826B3274;
	sub_825ABDC0(ctx, base);
	// 826B3274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3278: 487401B1  bl 0x82df3428
	ctx.lr = 0x826B327C;
	sub_82DF3428(ctx, base);
	// 826B327C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3284: 388BEE38  addi r4, r11, -0x11c8
	ctx.r[4].s64 = ctx.r[11].s64 + -4552;
	// 826B3288: 48740781  bl 0x82df3a08
	ctx.lr = 0x826B328C;
	sub_82DF3A08(ctx, base);
	// 826B328C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B3290: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B3294: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B3298: 4BEF8B29  bl 0x825abdc0
	ctx.lr = 0x826B329C;
	sub_825ABDC0(ctx, base);
	// 826B329C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B32A0: 48740189  bl 0x82df3428
	ctx.lr = 0x826B32A4;
	sub_82DF3428(ctx, base);
	// 826B32A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B32A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B32AC: 388B3128  addi r4, r11, 0x3128
	ctx.r[4].s64 = ctx.r[11].s64 + 12584;
	// 826B32B0: 48740759  bl 0x82df3a08
	ctx.lr = 0x826B32B4;
	sub_82DF3A08(ctx, base);
	// 826B32B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B32B8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826B32BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B32C0: 4BEF8B01  bl 0x825abdc0
	ctx.lr = 0x826B32C4;
	sub_825ABDC0(ctx, base);
	// 826B32C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B32C8: 48740161  bl 0x82df3428
	ctx.lr = 0x826B32CC;
	sub_82DF3428(ctx, base);
	// 826B32CC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B32D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B32D4: 388BEE20  addi r4, r11, -0x11e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4576;
	// 826B32D8: 48740731  bl 0x82df3a08
	ctx.lr = 0x826B32DC;
	sub_82DF3A08(ctx, base);
	// 826B32DC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B32E0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 826B32E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826B32E8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826B32EC: 419A0024  beq cr6, 0x826b3310
	if ctx.cr[6].eq {
	pc = 0x826B3310; continue 'dispatch;
	}
	// 826B32F0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826B32F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B32F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B32FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B3300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B3304: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B3308: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B330C: 4082FFE8  bne 0x826b32f4
	if !ctx.cr[0].eq {
	pc = 0x826B32F4; continue 'dispatch;
	}
	// 826B3310: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826B3314: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B3318: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B331C: 4BEEEDF5  bl 0x825a2110
	ctx.lr = 0x826B3320;
	sub_825A2110(ctx, base);
	// 826B3320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3324: 48740105  bl 0x82df3428
	ctx.lr = 0x826B3328;
	sub_82DF3428(ctx, base);
	// 826B3328: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B332C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B3330: 388BEE0C  addi r4, r11, -0x11f4
	ctx.r[4].s64 = ctx.r[11].s64 + -4596;
	// 826B3334: 487406D5  bl 0x82df3a08
	ctx.lr = 0x826B3338;
	sub_82DF3A08(ctx, base);
	// 826B3338: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826B333C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3340: 388B6058  addi r4, r11, 0x6058
	ctx.r[4].s64 = ctx.r[11].s64 + 24664;
	// 826B3344: 487406C5  bl 0x82df3a08
	ctx.lr = 0x826B3348;
	sub_82DF3A08(ctx, base);
	// 826B3348: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826B334C: 38E0270F  li r7, 0x270f
	ctx.r[7].s64 = 9999;
	// 826B3350: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B3354: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 826B3358: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B335C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B3360: 4BEF00B9  bl 0x825a3418
	ctx.lr = 0x826B3364;
	sub_825A3418(ctx, base);
	// 826B3364: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B3368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B336C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B3370: 4BEEEB69  bl 0x825a1ed8
	ctx.lr = 0x826B3374;
	sub_825A1ED8(ctx, base);
	// 826B3374: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826B3378: 487400B1  bl 0x82df3428
	ctx.lr = 0x826B337C;
	sub_82DF3428(ctx, base);
	// 826B337C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B3380: 4BC15939  bl 0x822c8cb8
	ctx.lr = 0x826B3384;
	sub_822C8CB8(ctx, base);
	// 826B3384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3388: 487400A1  bl 0x82df3428
	ctx.lr = 0x826B338C;
	sub_82DF3428(ctx, base);
	// 826B338C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B3390: 48740099  bl 0x82df3428
	ctx.lr = 0x826B3394;
	sub_82DF3428(ctx, base);
	// 826B3394: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B339C: 388BEDF4  addi r4, r11, -0x120c
	ctx.r[4].s64 = ctx.r[11].s64 + -4620;
	// 826B33A0: 48740669  bl 0x82df3a08
	ctx.lr = 0x826B33A4;
	sub_82DF3A08(ctx, base);
	// 826B33A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B33A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B33AC: 388BEDEC  addi r4, r11, -0x1214
	ctx.r[4].s64 = ctx.r[11].s64 + -4628;
	// 826B33B0: 48740659  bl 0x82df3a08
	ctx.lr = 0x826B33B4;
	sub_82DF3A08(ctx, base);
	// 826B33B4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826B33B8: 38E0270F  li r7, 0x270f
	ctx.r[7].s64 = 9999;
	// 826B33BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B33C0: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 826B33C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B33C8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826B33CC: 4BEF004D  bl 0x825a3418
	ctx.lr = 0x826B33D0;
	sub_825A3418(ctx, base);
	// 826B33D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B33D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B33D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B33DC: 4BEEEAFD  bl 0x825a1ed8
	ctx.lr = 0x826B33E0;
	sub_825A1ED8(ctx, base);
	// 826B33E0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826B33E4: 48740045  bl 0x82df3428
	ctx.lr = 0x826B33E8;
	sub_82DF3428(ctx, base);
	// 826B33E8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826B33EC: 4BC158CD  bl 0x822c8cb8
	ctx.lr = 0x826B33F0;
	sub_822C8CB8(ctx, base);
	// 826B33F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B33F4: 48740035  bl 0x82df3428
	ctx.lr = 0x826B33F8;
	sub_82DF3428(ctx, base);
	// 826B33F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B33FC: 4874002D  bl 0x82df3428
	ctx.lr = 0x826B3400;
	sub_82DF3428(ctx, base);
	// 826B3400: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3404: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3408: 388BEDE0  addi r4, r11, -0x1220
	ctx.r[4].s64 = ctx.r[11].s64 + -4640;
	// 826B340C: 487405FD  bl 0x82df3a08
	ctx.lr = 0x826B3410;
	sub_82DF3A08(ctx, base);
	// 826B3410: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3414: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B3418: 388BEDD8  addi r4, r11, -0x1228
	ctx.r[4].s64 = ctx.r[11].s64 + -4648;
	// 826B341C: 487405ED  bl 0x82df3a08
	ctx.lr = 0x826B3420;
	sub_82DF3A08(ctx, base);
	// 826B3420: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826B3424: 38E0270F  li r7, 0x270f
	ctx.r[7].s64 = 9999;
	// 826B3428: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B342C: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 826B3430: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B3434: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826B3438: 4BEEFFE1  bl 0x825a3418
	ctx.lr = 0x826B343C;
	sub_825A3418(ctx, base);
	// 826B343C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B3440: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B3444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B3448: 4BEEEA91  bl 0x825a1ed8
	ctx.lr = 0x826B344C;
	sub_825A1ED8(ctx, base);
	// 826B344C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826B3450: 4873FFD9  bl 0x82df3428
	ctx.lr = 0x826B3454;
	sub_82DF3428(ctx, base);
	// 826B3454: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826B3458: 4BC15861  bl 0x822c8cb8
	ctx.lr = 0x826B345C;
	sub_822C8CB8(ctx, base);
	// 826B345C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B3460: 4873FFC9  bl 0x82df3428
	ctx.lr = 0x826B3464;
	sub_82DF3428(ctx, base);
	// 826B3464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3468: 4873FFC1  bl 0x82df3428
	ctx.lr = 0x826B346C;
	sub_82DF3428(ctx, base);
	// 826B346C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3474: 388BEDC8  addi r4, r11, -0x1238
	ctx.r[4].s64 = ctx.r[11].s64 + -4664;
	// 826B3478: 48740591  bl 0x82df3a08
	ctx.lr = 0x826B347C;
	sub_82DF3A08(ctx, base);
	// 826B347C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3480: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B3484: 388BEDBC  addi r4, r11, -0x1244
	ctx.r[4].s64 = ctx.r[11].s64 + -4676;
	// 826B3488: 48740581  bl 0x82df3a08
	ctx.lr = 0x826B348C;
	sub_82DF3A08(ctx, base);
	// 826B348C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B3490: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826B3494: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826B3498: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 826B349C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B34A0: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 826B34A4: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826B34A8: C04A4C5C  lfs f2, 0x4c5c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(19548 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826B34AC: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B34B0: 4BEEFDF9  bl 0x825a32a8
	ctx.lr = 0x826B34B4;
	sub_825A32A8(ctx, base);
	// 826B34B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B34B8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B34BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B34C0: 4BEEE2B1  bl 0x825a1770
	ctx.lr = 0x826B34C4;
	sub_825A1770(ctx, base);
	// 826B34C4: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826B34C8: 4873FF61  bl 0x82df3428
	ctx.lr = 0x826B34CC;
	sub_82DF3428(ctx, base);
	// 826B34CC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826B34D0: 4BC157E9  bl 0x822c8cb8
	ctx.lr = 0x826B34D4;
	sub_822C8CB8(ctx, base);
	// 826B34D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B34D8: 4873FF51  bl 0x82df3428
	ctx.lr = 0x826B34DC;
	sub_82DF3428(ctx, base);
	// 826B34DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B34E0: 4873FF49  bl 0x82df3428
	ctx.lr = 0x826B34E4;
	sub_82DF3428(ctx, base);
	// 826B34E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826B34E8: 419A000C  beq cr6, 0x826b34f4
	if ctx.cr[6].eq {
	pc = 0x826B34F4; continue 'dispatch;
	}
	// 826B34EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B34F0: 4BC0D3A1  bl 0x822c0890
	ctx.lr = 0x826B34F4;
	sub_822C0890(ctx, base);
	// 826B34F4: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 826B34F8: 48AF4CC0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B3500 size=76
    let mut pc: u32 = 0x826B3500;
    'dispatch: loop {
        match pc {
            0x826B3500 => {
    //   block [0x826B3500..0x826B354C)
	// 826B3500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B350C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B351C: 4BFFFC2D  bl 0x826b3148
	ctx.lr = 0x826B3520;
	sub_826B3148(ctx, base);
	// 826B3520: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B3524: 4182000C  beq 0x826b3530
	if ctx.cr[0].eq {
	pc = 0x826B3530; continue 'dispatch;
	}
	// 826B3528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B352C: 4873EEAD  bl 0x82df23d8
	ctx.lr = 0x826B3530;
	sub_82DF23D8(ctx, base);
	// 826B3530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B3534: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B3538: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B353C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B3540: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B3544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B3548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B3550 size=8
    let mut pc: u32 = 0x826B3550;
    'dispatch: loop {
        match pc {
            0x826B3550 => {
    //   block [0x826B3550..0x826B3558)
	// 826B3550: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 826B3554: 4BFFFC54  b 0x826b31a8
	sub_826B31A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B3558 size=344
    let mut pc: u32 = 0x826B3558;
    'dispatch: loop {
        match pc {
            0x826B3558 => {
    //   block [0x826B3558..0x826B36B0)
	// 826B3558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B355C: 48AF4C01  bl 0x831a815c
	ctx.lr = 0x826B3560;
	sub_831A8130(ctx, base);
	// 826B3560: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3568: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826B356C: 4BE5E46D  bl 0x825119d8
	ctx.lr = 0x826B3570;
	sub_825119D8(ctx, base);
	// 826B3570: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826B3574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3578: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826B357C: 4874048D  bl 0x82df3a08
	ctx.lr = 0x826B3580;
	sub_82DF3A08(ctx, base);
	// 826B3580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B3584: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B3588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B358C: 4BE551F5  bl 0x82508780
	ctx.lr = 0x826B3590;
	sub_82508780(ctx, base);
	// 826B3590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3594: 4873FE95  bl 0x82df3428
	ctx.lr = 0x826B3598;
	sub_82DF3428(ctx, base);
	// 826B3598: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826B359C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B35A0: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 826B35A4: 48740465  bl 0x82df3a08
	ctx.lr = 0x826B35A8;
	sub_82DF3A08(ctx, base);
	// 826B35A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B35AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B35B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B35B4: 4BE551CD  bl 0x82508780
	ctx.lr = 0x826B35B8;
	sub_82508780(ctx, base);
	// 826B35B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B35BC: 4873FE6D  bl 0x82df3428
	ctx.lr = 0x826B35C0;
	sub_82DF3428(ctx, base);
	// 826B35C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826B35C4: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826B35C8: 409A0008  bne cr6, 0x826b35d0
	if !ctx.cr[6].eq {
	pc = 0x826B35D0; continue 'dispatch;
	}
	// 826B35CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B35D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B35D4: 4BE551CD  bl 0x825087a0
	ctx.lr = 0x826B35D8;
	sub_825087A0(ctx, base);
	// 826B35D8: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826B35DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B35E0: 4BE550A1  bl 0x82508680
	ctx.lr = 0x826B35E4;
	sub_82508680(ctx, base);
	// 826B35E4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826B35E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B35EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B35F0: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 826B35F4: 3B9F00F4  addi r28, r31, 0xf4
	ctx.r[28].s64 = ctx.r[31].s64 + 244;
	// 826B35F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826B35FC: 3B7F00F0  addi r27, r31, 0xf0
	ctx.r[27].s64 = ctx.r[31].s64 + 240;
	// 826B3600: 3B5F00EC  addi r26, r31, 0xec
	ctx.r[26].s64 = ctx.r[31].s64 + 236;
	// 826B3604: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 826B3608: 4BE5E4E1  bl 0x82511ae8
	ctx.lr = 0x826B360C;
	sub_82511AE8(ctx, base);
	// 826B360C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B3610: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B3614: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 826B3618: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 826B361C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 826B3620: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 826B3624: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 826B3628: 4BFDC171  bl 0x8268f798
	ctx.lr = 0x826B362C;
	sub_8268F798(ctx, base);
	// 826B362C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3630: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B3634: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B3638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B363C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826B3640: 419A0024  beq cr6, 0x826b3664
	if ctx.cr[6].eq {
	pc = 0x826B3664; continue 'dispatch;
	}
	// 826B3644: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B3648: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B364C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3650: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B3654: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B3658: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B365C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3660: 4082FFE8  bne 0x826b3648
	if !ctx.cr[0].eq {
	pc = 0x826B3648; continue 'dispatch;
	}
	// 826B3664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B3668: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B366C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826B3670: 388A3130  addi r4, r10, 0x3130
	ctx.r[4].s64 = ctx.r[10].s64 + 12592;
	// 826B3674: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826B3678: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 826B367C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B3680: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826B3684: 487A53BD  bl 0x82e58a40
	ctx.lr = 0x826B3688;
	sub_82E58A40(ctx, base);
	// 826B3688: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B368C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B3690: 419A0008  beq cr6, 0x826b3698
	if ctx.cr[6].eq {
	pc = 0x826B3698; continue 'dispatch;
	}
	// 826B3694: 4BC0D1FD  bl 0x822c0890
	ctx.lr = 0x826B3698;
	sub_822C0890(ctx, base);
	// 826B3698: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B369C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B36A0: 419A0008  beq cr6, 0x826b36a8
	if ctx.cr[6].eq {
	pc = 0x826B36A8; continue 'dispatch;
	}
	// 826B36A4: 4BC0D1ED  bl 0x822c0890
	ctx.lr = 0x826B36A8;
	sub_822C0890(ctx, base);
	// 826B36A8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826B36AC: 48AF4B00  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B36B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B36B0 size=200
    let mut pc: u32 = 0x826B36B0;
    'dispatch: loop {
        match pc {
            0x826B36B0 => {
    //   block [0x826B36B0..0x826B3778)
	// 826B36B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B36B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B36B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B36BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B36C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B36C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B36C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 826B36CC: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826B36D0: 4BE54FB1  bl 0x82508680
	ctx.lr = 0x826B36D4;
	sub_82508680(ctx, base);
	// 826B36D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B36D8: 389F00EC  addi r4, r31, 0xec
	ctx.r[4].s64 = ctx.r[31].s64 + 236;
	// 826B36DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B36E0: 4BFDC159  bl 0x8268f838
	ctx.lr = 0x826B36E4;
	sub_8268F838(ctx, base);
	// 826B36E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B36E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826B36EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B36F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B36F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B36F8: 419A0024  beq cr6, 0x826b371c
	if ctx.cr[6].eq {
	pc = 0x826B371C; continue 'dispatch;
	}
	// 826B36FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B3700: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B3704: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3708: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B370C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B3710: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B3714: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3718: 4082FFE8  bne 0x826b3700
	if !ctx.cr[0].eq {
	pc = 0x826B3700; continue 'dispatch;
	}
	// 826B371C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B3720: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B3724: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826B3728: 388A3130  addi r4, r10, 0x3130
	ctx.r[4].s64 = ctx.r[10].s64 + 12592;
	// 826B372C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826B3730: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 826B3734: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B3738: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826B373C: 487A5305  bl 0x82e58a40
	ctx.lr = 0x826B3740;
	sub_82E58A40(ctx, base);
	// 826B3740: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B3744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B3748: 419A0008  beq cr6, 0x826b3750
	if ctx.cr[6].eq {
	pc = 0x826B3750; continue 'dispatch;
	}
	// 826B374C: 4BC0D145  bl 0x822c0890
	ctx.lr = 0x826B3750;
	sub_822C0890(ctx, base);
	// 826B3750: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B3754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B3758: 419A0008  beq cr6, 0x826b3760
	if ctx.cr[6].eq {
	pc = 0x826B3760; continue 'dispatch;
	}
	// 826B375C: 4BC0D135  bl 0x822c0890
	ctx.lr = 0x826B3760;
	sub_822C0890(ctx, base);
	// 826B3760: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B3764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B3768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B376C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B3770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B3774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B3778 size=416
    let mut pc: u32 = 0x826B3778;
    'dispatch: loop {
        match pc {
            0x826B3778 => {
    //   block [0x826B3778..0x826B3918)
	// 826B3778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B377C: 48AF49E9  bl 0x831a8164
	ctx.lr = 0x826B3780;
	sub_831A8130(ctx, base);
	// 826B3780: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3784: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3788: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B378C: 3BCB3130  addi r30, r11, 0x3130
	ctx.r[30].s64 = ctx.r[11].s64 + 12592;
	// 826B3790: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B3794: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 826B3798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B379C: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 826B37A0: 4873EC49  bl 0x82df23e8
	ctx.lr = 0x826B37A4;
	sub_82DF23E8(ctx, base);
	// 826B37A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826B37A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B37AC: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 826B37B0: 4182001C  beq 0x826b37cc
	if ctx.cr[0].eq {
	pc = 0x826B37CC; continue 'dispatch;
	}
	// 826B37B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B37B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826B37BC: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 826B37C0: 4BFFF8F9  bl 0x826b30b8
	ctx.lr = 0x826B37C4;
	sub_826B30B8(ctx, base);
	// 826B37C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B37C8: 48000008  b 0x826b37d0
	pc = 0x826B37D0; continue 'dispatch;
	// 826B37CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B37D0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826B37D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B37D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B37DC: 4BFFF815  bl 0x826b2ff0
	ctx.lr = 0x826B37E0;
	sub_826B2FF0(ctx, base);
	// 826B37E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B37E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B37E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B37EC: 4BC0C815  bl 0x822c0000
	ctx.lr = 0x826B37F0;
	sub_822C0000(ctx, base);
	// 826B37F0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826B37F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826B37F8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826B37FC: 409A0008  bne cr6, 0x826b3804
	if !ctx.cr[6].eq {
	pc = 0x826B3804; continue 'dispatch;
	}
	// 826B3800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B3804: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B3808: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826B380C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B3810: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 826B3814: 419A0024  beq cr6, 0x826b3838
	if ctx.cr[6].eq {
	pc = 0x826B3838; continue 'dispatch;
	}
	// 826B3818: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826B381C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826B3820: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3824: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826B3828: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826B382C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B3830: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3834: 4082FFE8  bne 0x826b381c
	if !ctx.cr[0].eq {
	pc = 0x826B381C; continue 'dispatch;
	}
	// 826B3838: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826B383C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B3840: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 826B3844: 419A0024  beq cr6, 0x826b3868
	if ctx.cr[6].eq {
	pc = 0x826B3868; continue 'dispatch;
	}
	// 826B3848: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826B384C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B3850: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3854: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B3858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B385C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B3860: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B3864: 4082FFE8  bne 0x826b384c
	if !ctx.cr[0].eq {
	pc = 0x826B384C; continue 'dispatch;
	}
	// 826B3868: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B386C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 826B3870: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826B3874: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B3878: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826B387C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B3880: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B3884: 480E56AD  bl 0x82798f30
	ctx.lr = 0x826B3888;
	sub_82798F30(ctx, base);
	// 826B3888: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B388C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B3890: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 826B3894: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826B3898: 4BC0CB41  bl 0x822c03d8
	ctx.lr = 0x826B389C;
	sub_822C03D8(ctx, base);
	// 826B389C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B38A0: 41820014  beq 0x826b38b4
	if ctx.cr[0].eq {
	pc = 0x826B38B4; continue 'dispatch;
	}
	// 826B38A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B38A8: 480E7DC1  bl 0x8279b668
	ctx.lr = 0x826B38AC;
	sub_8279B668(ctx, base);
	// 826B38AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B38B0: 48000008  b 0x826b38b8
	pc = 0x826B38B8; continue 'dispatch;
	// 826B38B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B38B8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826B38BC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826B38C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B38C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B38C8: 4BEE4389  bl 0x82597c50
	ctx.lr = 0x826B38CC;
	sub_82597C50(ctx, base);
	// 826B38CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B38D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B38D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B38D8: 4BC0C729  bl 0x822c0000
	ctx.lr = 0x826B38DC;
	sub_822C0000(ctx, base);
	// 826B38DC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826B38E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B38E4: 419A0008  beq cr6, 0x826b38ec
	if ctx.cr[6].eq {
	pc = 0x826B38EC; continue 'dispatch;
	}
	// 826B38E8: 4BC0CFA9  bl 0x822c0890
	ctx.lr = 0x826B38EC;
	sub_822C0890(ctx, base);
	// 826B38EC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B38F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B38F4: 419A0008  beq cr6, 0x826b38fc
	if ctx.cr[6].eq {
	pc = 0x826B38FC; continue 'dispatch;
	}
	// 826B38F8: 4BC0CF99  bl 0x822c0890
	ctx.lr = 0x826B38FC;
	sub_822C0890(ctx, base);
	// 826B38FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B3900: 419A000C  beq cr6, 0x826b390c
	if ctx.cr[6].eq {
	pc = 0x826B390C; continue 'dispatch;
	}
	// 826B3904: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B3908: 4BC0CF89  bl 0x822c0890
	ctx.lr = 0x826B390C;
	sub_822C0890(ctx, base);
	// 826B390C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B3910: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826B3914: 48AF48A0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B3918 size=220
    let mut pc: u32 = 0x826B3918;
    'dispatch: loop {
        match pc {
            0x826B3918 => {
    //   block [0x826B3918..0x826B39F4)
	// 826B3918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B391C: 48AF484D  bl 0x831a8168
	ctx.lr = 0x826B3920;
	sub_831A8130(ctx, base);
	// 826B3920: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B3928: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B392C: 4BFEFE1D  bl 0x826a3748
	ctx.lr = 0x826B3930;
	sub_826A3748(ctx, base);
	// 826B3930: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3938: 3BAB18B4  addi r29, r11, 0x18b4
	ctx.r[29].s64 = ctx.r[11].s64 + 6324;
	// 826B393C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B3940: 487400C9  bl 0x82df3a08
	ctx.lr = 0x826B3944;
	sub_82DF3A08(ctx, base);
	// 826B3944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B3948: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B394C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B3950: 4BEEDC39  bl 0x825a1588
	ctx.lr = 0x826B3954;
	sub_825A1588(ctx, base);
	// 826B3954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3958: 4873FAD1  bl 0x82df3428
	ctx.lr = 0x826B395C;
	sub_82DF3428(ctx, base);
	// 826B395C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3964: 3B8B18A4  addi r28, r11, 0x18a4
	ctx.r[28].s64 = ctx.r[11].s64 + 6308;
	// 826B3968: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B396C: 4874009D  bl 0x82df3a08
	ctx.lr = 0x826B3970;
	sub_82DF3A08(ctx, base);
	// 826B3970: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B3974: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B3978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B397C: 4BEEDC0D  bl 0x825a1588
	ctx.lr = 0x826B3980;
	sub_825A1588(ctx, base);
	// 826B3980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3984: 4873FAA5  bl 0x82df3428
	ctx.lr = 0x826B3988;
	sub_82DF3428(ctx, base);
	// 826B3988: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 826B398C: 4BFF1EED  bl 0x826a5878
	ctx.lr = 0x826B3990;
	sub_826A5878(ctx, base);
	// 826B3990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B3994: 41820058  beq 0x826b39ec
	if ctx.cr[0].eq {
	pc = 0x826B39EC; continue 'dispatch;
	}
	// 826B3998: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B399C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B39A0: 48740069  bl 0x82df3a08
	ctx.lr = 0x826B39A4;
	sub_82DF3A08(ctx, base);
	// 826B39A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826B39A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B39AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B39B0: 4BEEDBD9  bl 0x825a1588
	ctx.lr = 0x826B39B4;
	sub_825A1588(ctx, base);
	// 826B39B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B39B8: 4873FA71  bl 0x82df3428
	ctx.lr = 0x826B39BC;
	sub_82DF3428(ctx, base);
	// 826B39BC: 897E016D  lbz r11, 0x16d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(365 as u32) ) } as u64;
	// 826B39C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B39C4: 41820028  beq 0x826b39ec
	if ctx.cr[0].eq {
	pc = 0x826B39EC; continue 'dispatch;
	}
	// 826B39C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826B39CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B39D0: 48740039  bl 0x82df3a08
	ctx.lr = 0x826B39D4;
	sub_82DF3A08(ctx, base);
	// 826B39D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826B39D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B39DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B39E0: 4BEEDBA9  bl 0x825a1588
	ctx.lr = 0x826B39E4;
	sub_825A1588(ctx, base);
	// 826B39E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B39E8: 4873FA41  bl 0x82df3428
	ctx.lr = 0x826B39EC;
	sub_82DF3428(ctx, base);
	// 826B39EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B39F0: 48AF47C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B39F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B39F8 size=196
    let mut pc: u32 = 0x826B39F8;
    'dispatch: loop {
        match pc {
            0x826B39F8 => {
    //   block [0x826B39F8..0x826B3ABC)
	// 826B39F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B39FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3A00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B3A04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3A08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3A0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B3A10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B3A14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826B3A18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B3A1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B3A20: 4BC0CF19  bl 0x822c0938
	ctx.lr = 0x826B3A24;
	sub_822C0938(ctx, base);
	// 826B3A24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B3A28: 41820028  beq 0x826b3a50
	if ctx.cr[0].eq {
	pc = 0x826B3A50; continue 'dispatch;
	}
	// 826B3A2C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3A30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826B3A34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826B3A38: 392B3FEC  addi r9, r11, 0x3fec
	ctx.r[9].s64 = ctx.r[11].s64 + 16364;
	// 826B3A3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826B3A40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826B3A44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826B3A48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826B3A4C: 48000008  b 0x826b3a54
	pc = 0x826B3A54; continue 'dispatch;
	// 826B3A50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B3A54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B3A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B3A5C: 409A0044  bne cr6, 0x826b3aa0
	if !ctx.cr[6].eq {
	pc = 0x826B3AA0; continue 'dispatch;
	}
	// 826B3A60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826B3A64: 419A001C  beq cr6, 0x826b3a80
	if ctx.cr[6].eq {
	pc = 0x826B3A80; continue 'dispatch;
	}
	// 826B3A68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3A6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B3A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B3A74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3A78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B3A7C: 4E800421  bctrl
	ctx.lr = 0x826B3A80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B3A80: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B3A84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B3A88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3A8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826B3A90: 816BAC58  lwz r11, -0x53a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21416 as u32) ) } as u64;
	// 826B3A94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826B3A98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B3A9C: 4BC0C565  bl 0x822c0000
	ctx.lr = 0x826B3AA0;
	sub_822C0000(ctx, base);
	// 826B3AA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B3AA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B3AA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B3AAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B3AB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B3AB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B3AB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B3AC0 size=328
    let mut pc: u32 = 0x826B3AC0;
    'dispatch: loop {
        match pc {
            0x826B3AC0 => {
    //   block [0x826B3AC0..0x826B3C08)
	// 826B3AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3AC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3ACC: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 826B3AD0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826B3AD4: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3ADC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826B3AE0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826B3AE4: 419A0108  beq cr6, 0x826b3bec
	if ctx.cr[6].eq {
	pc = 0x826B3BEC; continue 'dispatch;
	}
	// 826B3AE8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826B3AEC: 4BC1C5C5  bl 0x822d00b0
	ctx.lr = 0x826B3AF0;
	sub_822D00B0(ctx, base);
	// 826B3AF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B3AF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B3AF8: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826B3AFC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826B3B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3B04: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B3B08: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826B3B0C: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826B3B10: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826B3B14: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826B3B18: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826B3B1C: 487C9805  bl 0x82e7d320
	ctx.lr = 0x826B3B20;
	sub_82E7D320(ctx, base);
	// 826B3B20: 817F0254  lwz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 826B3B24: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826B3B28: 409A0044  bne cr6, 0x826b3b6c
	if !ctx.cr[6].eq {
	pc = 0x826B3B6C; continue 'dispatch;
	}
	// 826B3B2C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826B3B30: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3B34: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 826B3B38: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B3B3C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B3B40: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B3B44: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826B3B48: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B3B4C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826B3B50: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B3B54: FC005850  fneg f0, f11
	ctx.f[0].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B3B58: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826B3B5C: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826B3B60: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826B3B64: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B3C08 size=336
    let mut pc: u32 = 0x826B3C08;
    'dispatch: loop {
        match pc {
            0x826B3C08 => {
    //   block [0x826B3C08..0x826B3D58)
	// 826B3C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3C0C: 48AF4561  bl 0x831a816c
	ctx.lr = 0x826B3C10;
	sub_831A8130(ctx, base);
	// 826B3C10: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826B3C14: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826B3C18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3C1C: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 826B3C20: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3C24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B3C28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B3C2C: C00B3FFC  lfs f0, 0x3ffc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16380 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3C30: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B3C34: 48AF5195  bl 0x831a8dc8
	ctx.lr = 0x826B3C38;
	sub_831A8DC8(ctx, base);
	// 826B3C38: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B3C3C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826B3C40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B3C44: C00A967C  lfs f0, -0x6984(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3C48: C3EB9528  lfs f31, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B3C4C: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B3C50: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 826B3C54: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826B3C58: 48AF5171  bl 0x831a8dc8
	ctx.lr = 0x826B3C5C;
	sub_831A8DC8(ctx, base);
	// 826B3C5C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B3C60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B3C64: C00B9670  lfs f0, -0x6990(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27024 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3C68: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B3C6C: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 826B3C70: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826B3C74: 48AF5155  bl 0x831a8dc8
	ctx.lr = 0x826B3C78;
	sub_831A8DC8(ctx, base);
	// 826B3C78: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B3C7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B3C80: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826B3C84: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826B3C88: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3C8C: C1ABDFB0  lfs f13, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B3C90: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826B3C94: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 826B3C98: EC0C07F2  fmuls f0, f12, f31
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 826B3C9C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826B3CA0: 40980098  bge cr6, 0x826b3d38
	if !ctx.cr[6].lt {
	pc = 0x826B3D38; continue 'dispatch;
	}
	// 826B3CA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B3CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3CAC: 4BE5B81D  bl 0x8250f4c8
	ctx.lr = 0x826B3CB0;
	sub_8250F4C8(ctx, base);
	// 826B3CB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B3CB8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B3CBC: 409A0008  bne cr6, 0x826b3cc4
	if !ctx.cr[6].eq {
	pc = 0x826B3CC4; continue 'dispatch;
	}
	// 826B3CC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B3CC4: 4BE54855  bl 0x82508518
	ctx.lr = 0x826B3CC8;
	sub_82508518(ctx, base);
	// 826B3CC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B3CCC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826B3CD0: 4873DFC1  bl 0x82df1c90
	ctx.lr = 0x826B3CD4;
	sub_82DF1C90(ctx, base);
	// 826B3CD4: C1BF024C  lfs f13, 0x24c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B3CD8: EDBF6828  fsubs f13, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B3CDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B3CE0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3CE4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B3CE8: 40990050  ble cr6, 0x826b3d38
	if !ctx.cr[6].gt {
	pc = 0x826B3D38; continue 'dispatch;
	}
	// 826B3CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B3CF0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3CF4: 4BE5DDF5  bl 0x82511ae8
	ctx.lr = 0x826B3CF8;
	sub_82511AE8(ctx, base);
	// 826B3CF8: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B3CFC: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826B3D00: 813E002C  lwz r9, 0x2c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826B3D04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B3D08: 394AAC08  addi r10, r10, -0x53f8
	ctx.r[10].s64 = ctx.r[10].s64 + -21496;
	// 826B3D0C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B3D10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B3D14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B3D18: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826B3D1C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 826B3D20: 4E800421  bctrl
	ctx.lr = 0x826B3D24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B3D24: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B3D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B3D2C: 419A0008  beq cr6, 0x826b3d34
	if ctx.cr[6].eq {
	pc = 0x826B3D34; continue 'dispatch;
	}
	// 826B3D30: 4BC0CB61  bl 0x822c0890
	ctx.lr = 0x826B3D34;
	sub_822C0890(ctx, base);
	// 826B3D34: D3FF024C  stfs f31, 0x24c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), tmp.u32 ) };
	// 826B3D38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B3D3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B3D40: 487C8299  bl 0x82e7bfd8
	ctx.lr = 0x826B3D44;
	sub_82E7BFD8(ctx, base);
	// 826B3D44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B3D48: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826B3D4C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826B3D50: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826B3D54: 48AF4468  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B3D58 size=316
    let mut pc: u32 = 0x826B3D58;
    'dispatch: loop {
        match pc {
            0x826B3D58 => {
    //   block [0x826B3D58..0x826B3E94)
	// 826B3D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3D60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B3D64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3D68: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3D6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B3D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826B3D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3D78: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826B3D7C: 4BFEFB8D  bl 0x826a3908
	ctx.lr = 0x826B3D80;
	sub_826A3908(ctx, base);
	// 826B3D80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 826B3D84: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 826B3D88: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 826B3D8C: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826B3D90: 807F0234  lwz r3, 0x234(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 826B3D94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B3D98: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B3D9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B3DA0: 4E800421  bctrl
	ctx.lr = 0x826B3DA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B3DA4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826B3DA8: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826B3DAC: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3DB0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826B3DB4: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 826B3DB8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 826B3DBC: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3DC0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 826B3DC4: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 826B3DC8: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3DCC: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3DD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B3E98 size=100
    let mut pc: u32 = 0x826B3E98;
    'dispatch: loop {
        match pc {
            0x826B3E98 => {
    //   block [0x826B3E98..0x826B3EFC)
	// 826B3E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3EA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3EAC: 4BFEF855  bl 0x826a3700
	ctx.lr = 0x826B3EB0;
	sub_826A3700(ctx, base);
	// 826B3EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B3EB4: 4BFF19C5  bl 0x826a5878
	ctx.lr = 0x826B3EB8;
	sub_826A5878(ctx, base);
	// 826B3EB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B3EBC: 4182001C  beq 0x826b3ed8
	if ctx.cr[0].eq {
	pc = 0x826B3ED8; continue 'dispatch;
	}
	// 826B3EC0: 897F0251  lbz r11, 0x251(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(593 as u32) ) } as u64;
	// 826B3EC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B3EC8: 41820010  beq 0x826b3ed8
	if ctx.cr[0].eq {
	pc = 0x826B3ED8; continue 'dispatch;
	}
	// 826B3ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B3ED0: 4BFFFBF1  bl 0x826b3ac0
	ctx.lr = 0x826B3ED4;
	sub_826B3AC0(ctx, base);
	// 826B3ED4: 48000014  b 0x826b3ee8
	pc = 0x826B3EE8; continue 'dispatch;
	// 826B3ED8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B3EDC: 807F0234  lwz r3, 0x234(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 826B3EE0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826B3EE4: 4875F37D  bl 0x82e13260
	ctx.lr = 0x826B3EE8;
	sub_82E13260(ctx, base);
	// 826B3EE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B3EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B3EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B3EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B3EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B3F00 size=212
    let mut pc: u32 = 0x826B3F00;
    'dispatch: loop {
        match pc {
            0x826B3F00 => {
    //   block [0x826B3F00..0x826B3FD4)
	// 826B3F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B3F08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B3F0C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B3F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B3F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B3F18: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3F1C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 826B3F20: 4199000C  bgt cr6, 0x826b3f2c
	if ctx.cr[6].gt {
	pc = 0x826B3F2C; continue 'dispatch;
	}
	// 826B3F24: EC200828  fsubs f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 826B3F28: 48000044  b 0x826b3f6c
	pc = 0x826B3F6C; continue 'dispatch;
	// 826B3F2C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B3F30: C84BE3A0  lfd f2, -0x1c60(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) };
	// 826B3F34: 48AF68DD  bl 0x831aa810
	ctx.lr = 0x826B3F38;
	sub_831AA810(ctx, base);
	// 826B3F38: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826B3F3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B3F40: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B3F44: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B3F48: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B3F4C: 4199001C  bgt cr6, 0x826b3f68
	if ctx.cr[6].gt {
	pc = 0x826B3F68; continue 'dispatch;
	}
	// 826B3F50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B3F54: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 826B3F58: C18B08A4  lfs f12, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B3F5C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 826B3F60: 40980008  bge cr6, 0x826b3f68
	if !ctx.cr[6].lt {
	pc = 0x826B3F68; continue 'dispatch;
	}
	// 826B3F64: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 826B3F68: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 826B3F6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B3F70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B3F74: 4BFFFC95  bl 0x826b3c08
	ctx.lr = 0x826B3F78;
	sub_826B3C08(ctx, base);
	// 826B3F78: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826B3F7C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826B3F80: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3F84: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826B3F88: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826B3F8C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826B3F90: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3F94: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826B3F98: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 826B3F9C: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3FA0: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B3FA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B3FD8 size=32
    let mut pc: u32 = 0x826B3FD8;
    'dispatch: loop {
        match pc {
            0x826B3FD8 => {
    //   block [0x826B3FD8..0x826B3FF8)
	// 826B3FD8: 8103023C  lwz r8, 0x23c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(572 as u32) ) } as u64;
	// 826B3FDC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826B3FE0: 3943023C  addi r10, r3, 0x23c
	ctx.r[10].s64 = ctx.r[3].s64 + 572;
	// 826B3FE4: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826B3FE8: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826B3FEC: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826B3FF0: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826B3FF4: 4BC1046C  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B3FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B3FF8 size=164
    let mut pc: u32 = 0x826B3FF8;
    'dispatch: loop {
        match pc {
            0x826B3FF8 => {
    //   block [0x826B3FF8..0x826B409C)
	// 826B3FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B3FFC: 48AF416D  bl 0x831a8168
	ctx.lr = 0x826B4000;
	sub_831A8130(ctx, base);
	// 826B4000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4004: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826B4008: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B400C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B4010: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826B4014: 41820038  beq 0x826b404c
	if ctx.cr[0].eq {
	pc = 0x826B404C; continue 'dispatch;
	}
	// 826B4018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B401C: 48AF596D  bl 0x831a9988
	ctx.lr = 0x826B4020;
	sub_831A9988(ctx, base);
	// 826B4020: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B4024: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4028: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826B402C: 48AF40CD  bl 0x831a80f8
	ctx.lr = 0x826B4030;
	sub_831A80F8(ctx, base);
	// 826B4030: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B4034: 41820018  beq 0x826b404c
	if ctx.cr[0].eq {
	pc = 0x826B404C; continue 'dispatch;
	}
	// 826B4038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B403C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B4040: 4BFFFF99  bl 0x826b3fd8
	ctx.lr = 0x826B4044;
	sub_826B3FD8(ctx, base);
	// 826B4044: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826B4048: 4800004C  b 0x826b4094
	pc = 0x826B4094; continue 'dispatch;
	// 826B404C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B4050: 419A0034  beq cr6, 0x826b4084
	if ctx.cr[6].eq {
	pc = 0x826B4084; continue 'dispatch;
	}
	// 826B4054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4058: 48AF5931  bl 0x831a9988
	ctx.lr = 0x826B405C;
	sub_831A9988(ctx, base);
	// 826B405C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B4060: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4064: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826B4068: 48AF4091  bl 0x831a80f8
	ctx.lr = 0x826B406C;
	sub_831A80F8(ctx, base);
	// 826B406C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B4070: 41820014  beq 0x826b4084
	if ctx.cr[0].eq {
	pc = 0x826B4084; continue 'dispatch;
	}
	// 826B4074: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4078: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B407C: 4BFFFCDD  bl 0x826b3d58
	ctx.lr = 0x826B4080;
	sub_826B3D58(ctx, base);
	// 826B4080: 4BFFFFC4  b 0x826b4044
	pc = 0x826B4044; continue 'dispatch;
	// 826B4084: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826B4088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B408C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4090: 4BFF0CB9  bl 0x826a4d48
	ctx.lr = 0x826B4094;
	sub_826A4D48(ctx, base);
	// 826B4094: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B4098: 48AF4120  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B40A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B40A0 size=260
    let mut pc: u32 = 0x826B40A0;
    'dispatch: loop {
        match pc {
            0x826B40A0 => {
    //   block [0x826B40A0..0x826B41A4)
	// 826B40A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B40A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B40A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B40AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B40B0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B40B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B40B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B40BC: 4BFF0805  bl 0x826a48c0
	ctx.lr = 0x826B40C0;
	sub_826A48C0(ctx, base);
	// 826B40C0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B40C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B40C8: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 826B40CC: 4873F93D  bl 0x82df3a08
	ctx.lr = 0x826B40D0;
	sub_82DF3A08(ctx, base);
	// 826B40D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B40D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B40D8: 388B18B4  addi r4, r11, 0x18b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6324;
	// 826B40DC: 4873F92D  bl 0x82df3a08
	ctx.lr = 0x826B40E0;
	sub_82DF3A08(ctx, base);
	// 826B40E0: 38BF016D  addi r5, r31, 0x16d
	ctx.r[5].s64 = ctx.r[31].s64 + 365;
	// 826B40E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B40E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B40EC: 4BEEEF65  bl 0x825a3050
	ctx.lr = 0x826B40F0;
	sub_825A3050(ctx, base);
	// 826B40F0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B40F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B40F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B40FC: 4BEEE08D  bl 0x825a2188
	ctx.lr = 0x826B4100;
	sub_825A2188(ctx, base);
	// 826B4100: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B4104: 4873F325  bl 0x82df3428
	ctx.lr = 0x826B4108;
	sub_82DF3428(ctx, base);
	// 826B4108: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826B410C: 4BC14BAD  bl 0x822c8cb8
	ctx.lr = 0x826B4110;
	sub_822C8CB8(ctx, base);
	// 826B4110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B4114: 4873F315  bl 0x82df3428
	ctx.lr = 0x826B4118;
	sub_82DF3428(ctx, base);
	// 826B4118: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B411C: 4873F30D  bl 0x82df3428
	ctx.lr = 0x826B4120;
	sub_82DF3428(ctx, base);
	// 826B4120: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826B4124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B4128: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826B412C: 4873F8DD  bl 0x82df3a08
	ctx.lr = 0x826B4130;
	sub_82DF3A08(ctx, base);
	// 826B4130: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B4134: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B4138: 388B18A4  addi r4, r11, 0x18a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6308;
	// 826B413C: 4873F8CD  bl 0x82df3a08
	ctx.lr = 0x826B4140;
	sub_82DF3A08(ctx, base);
	// 826B4140: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826B4144: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826B4148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B414C: 38BF0170  addi r5, r31, 0x170
	ctx.r[5].s64 = ctx.r[31].s64 + 368;
	// 826B4150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B4154: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B4158: 4BEEF2C1  bl 0x825a3418
	ctx.lr = 0x826B415C;
	sub_825A3418(ctx, base);
	// 826B415C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B4160: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826B4164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4168: 4BEEDD71  bl 0x825a1ed8
	ctx.lr = 0x826B416C;
	sub_825A1ED8(ctx, base);
	// 826B416C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826B4170: 4873F2B9  bl 0x82df3428
	ctx.lr = 0x826B4174;
	sub_82DF3428(ctx, base);
	// 826B4174: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826B4178: 4BC14B41  bl 0x822c8cb8
	ctx.lr = 0x826B417C;
	sub_822C8CB8(ctx, base);
	// 826B417C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B4180: 4873F2A9  bl 0x82df3428
	ctx.lr = 0x826B4184;
	sub_82DF3428(ctx, base);
	// 826B4184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B4188: 4873F2A1  bl 0x82df3428
	ctx.lr = 0x826B418C;
	sub_82DF3428(ctx, base);
	// 826B418C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 826B4190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4198: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B419C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B41A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B41A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B41A8 size=244
    let mut pc: u32 = 0x826B41A8;
    'dispatch: loop {
        match pc {
            0x826B41A8 => {
    //   block [0x826B41A8..0x826B429C)
	// 826B41A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B41AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B41B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B41B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B41B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B41BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B41C0: 897F01E4  lbz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 826B41C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B41C8: 418200BC  beq 0x826b4284
	if ctx.cr[0].eq {
	pc = 0x826B4284; continue 'dispatch;
	}
	// 826B41CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826B41D0: 4BD0AE59  bl 0x823bf028
	ctx.lr = 0x826B41D4;
	sub_823BF028(ctx, base);
	// 826B41D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B41D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826B41DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B41E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B41E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826B41E8: 419A0024  beq cr6, 0x826b420c
	if ctx.cr[6].eq {
	pc = 0x826B420C; continue 'dispatch;
	}
	// 826B41EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B41F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B41F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B41F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B41FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B4200: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B4204: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4208: 4082FFE8  bne 0x826b41f0
	if !ctx.cr[0].eq {
	pc = 0x826B41F0; continue 'dispatch;
	}
	// 826B420C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4210: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B4214: 4BE5B2B5  bl 0x8250f4c8
	ctx.lr = 0x826B4218;
	sub_8250F4C8(ctx, base);
	// 826B4218: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B421C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B4220: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B4224: 409A0008  bne cr6, 0x826b422c
	if !ctx.cr[6].eq {
	pc = 0x826B422C; continue 'dispatch;
	}
	// 826B4228: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B422C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B4230: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826B4234: 4BE547E5  bl 0x82508a18
	ctx.lr = 0x826B4238;
	sub_82508A18(ctx, base);
	// 826B4238: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B423C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B4240: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B4244: 388A4000  addi r4, r10, 0x4000
	ctx.r[4].s64 = ctx.r[10].s64 + 16384;
	// 826B4248: 38A00210  li r5, 0x210
	ctx.r[5].s64 = 528;
	// 826B424C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826B4250: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B4254: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B4258: 487A47E9  bl 0x82e58a40
	ctx.lr = 0x826B425C;
	sub_82E58A40(ctx, base);
	// 826B425C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B4260: 4873DA31  bl 0x82df1c90
	ctx.lr = 0x826B4264;
	sub_82DF1C90(ctx, base);
	// 826B4264: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B4268: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B426C: 419A0008  beq cr6, 0x826b4274
	if ctx.cr[6].eq {
	pc = 0x826B4274; continue 'dispatch;
	}
	// 826B4270: 4BC0C621  bl 0x822c0890
	ctx.lr = 0x826B4274;
	sub_822C0890(ctx, base);
	// 826B4274: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B4278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B427C: 419A0008  beq cr6, 0x826b4284
	if ctx.cr[6].eq {
	pc = 0x826B4284; continue 'dispatch;
	}
	// 826B4280: 4BC0C611  bl 0x822c0890
	ctx.lr = 0x826B4284;
	sub_822C0890(ctx, base);
	// 826B4284: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B4288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B428C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4290: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B4294: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B42A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B42A0 size=1100
    let mut pc: u32 = 0x826B42A0;
    'dispatch: loop {
        match pc {
            0x826B42A0 => {
    //   block [0x826B42A0..0x826B46EC)
	// 826B42A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B42A4: 48AF3EB9  bl 0x831a815c
	ctx.lr = 0x826B42A8;
	sub_831A8130(ctx, base);
	// 826B42A8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 826B42AC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B42B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B42B4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B42B8: 4BE5D831  bl 0x82511ae8
	ctx.lr = 0x826B42BC;
	sub_82511AE8(ctx, base);
	// 826B42BC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B42C0: 813F0210  lwz r9, 0x210(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B42C4: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826B42C8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B42CC: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 826B42D0: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B42D4: 393E0050  addi r9, r30, 0x50
	ctx.r[9].s64 = ctx.r[30].s64 + 80;
	// 826B42D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B42DC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826B42E0: 7CAB482E  lwzx r5, r11, r9
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 826B42E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826B42E8: 4E800421  bctrl
	ctx.lr = 0x826B42EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B42EC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826B42F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B42F4: 419A0008  beq cr6, 0x826b42fc
	if ctx.cr[6].eq {
	pc = 0x826B42FC; continue 'dispatch;
	}
	// 826B42F8: 4BC0C599  bl 0x822c0890
	ctx.lr = 0x826B42FC;
	sub_822C0890(ctx, base);
	// 826B42FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4300: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826B4304: 4BE5B1C5  bl 0x8250f4c8
	ctx.lr = 0x826B4308;
	sub_8250F4C8(ctx, base);
	// 826B4308: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B430C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B4310: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 826B4314: 409A0008  bne cr6, 0x826b431c
	if !ctx.cr[6].eq {
	pc = 0x826B431C; continue 'dispatch;
	}
	// 826B4318: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B431C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B4320: 4BE56319  bl 0x8250a638
	ctx.lr = 0x826B4324;
	sub_8250A638(ctx, base);
	// 826B4324: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826B4328: 4873D969  bl 0x82df1c90
	ctx.lr = 0x826B432C;
	sub_82DF1C90(ctx, base);
	// 826B432C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B4330: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B4334: 3B6B4000  addi r27, r11, 0x4000
	ctx.r[27].s64 = ctx.r[11].s64 + 16384;
	// 826B4338: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 826B433C: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826B4340: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826B4344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B4348: 419A0280  beq cr6, 0x826b45c8
	if ctx.cr[6].eq {
	pc = 0x826B45C8; continue 'dispatch;
	}
	// 826B434C: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 826B4350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B4354: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826B4358: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826B435C: 4873F6AD  bl 0x82df3a08
	ctx.lr = 0x826B4360;
	sub_82DF3A08(ctx, base);
	// 826B4360: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B4364: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826B4368: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826B436C: 4810CC9D  bl 0x827c1008
	ctx.lr = 0x826B4370;
	sub_827C1008(ctx, base);
	// 826B4370: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B4374: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B4378: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B437C: 419A0024  beq cr6, 0x826b43a0
	if ctx.cr[6].eq {
	pc = 0x826B43A0; continue 'dispatch;
	}
	// 826B4380: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826B4384: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B4388: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B438C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B4390: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B4394: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B4398: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B439C: 4082FFE8  bne 0x826b4384
	if !ctx.cr[0].eq {
	pc = 0x826B4384; continue 'dispatch;
	}
	// 826B43A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826B43A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B43A8: 419A0008  beq cr6, 0x826b43b0
	if ctx.cr[6].eq {
	pc = 0x826B43B0; continue 'dispatch;
	}
	// 826B43AC: 4BC0C4E5  bl 0x822c0890
	ctx.lr = 0x826B43B0;
	sub_822C0890(ctx, base);
	// 826B43B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B43B4: 4873F075  bl 0x82df3428
	ctx.lr = 0x826B43B8;
	sub_82DF3428(ctx, base);
	// 826B43B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B43BC: 419A01FC  beq cr6, 0x826b45b8
	if ctx.cr[6].eq {
	pc = 0x826B45B8; continue 'dispatch;
	}
	// 826B43C0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 826B43C4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B43C8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 826B43CC: 419A0024  beq cr6, 0x826b43f0
	if ctx.cr[6].eq {
	pc = 0x826B43F0; continue 'dispatch;
	}
	// 826B43D0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826B43D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B43D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B43DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B43E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B43E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B43E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B43EC: 4082FFE8  bne 0x826b43d4
	if !ctx.cr[0].eq {
	pc = 0x826B43D4; continue 'dispatch;
	}
	// 826B43F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B43F4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826B43F8: 4BE5B0D1  bl 0x8250f4c8
	ctx.lr = 0x826B43FC;
	sub_8250F4C8(ctx, base);
	// 826B43FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B4400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B4404: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826B4408: 409A0008  bne cr6, 0x826b4410
	if !ctx.cr[6].eq {
	pc = 0x826B4410; continue 'dispatch;
	}
	// 826B440C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826B4410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4414: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B4418: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 826B441C: 4BE5B0FD  bl 0x8250f518
	ctx.lr = 0x826B4420;
	sub_8250F518(ctx, base);
	// 826B4420: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4428: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 826B442C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B4430: 4BE590D9  bl 0x8250d508
	ctx.lr = 0x826B4434;
	sub_8250D508(ctx, base);
	// 826B4434: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826B4438: 4873D859  bl 0x82df1c90
	ctx.lr = 0x826B443C;
	sub_82DF1C90(ctx, base);
	// 826B443C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826B4440: 4873D851  bl 0x82df1c90
	ctx.lr = 0x826B4444;
	sub_82DF1C90(ctx, base);
	// 826B4444: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 826B4448: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B444C: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826B4450: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B4454: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B4458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B445C: 4E800421  bctrl
	ctx.lr = 0x826B4460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B4460: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4464: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826B4468: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826B446C: 487C785D  bl 0x82e7bcc8
	ctx.lr = 0x826B4470;
	sub_82E7BCC8(ctx, base);
	// 826B4470: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 826B4474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B4478: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826B447C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B4480: 4E800421  bctrl
	ctx.lr = 0x826B4484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B4484: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4488: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826B448C: 487C897D  bl 0x82e7ce08
	ctx.lr = 0x826B4490;
	sub_82E7CE08(ctx, base);
	// 826B4490: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826B4494: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826B4498: 4BCC0641  bl 0x82374ad8
	ctx.lr = 0x826B449C;
	sub_82374AD8(ctx, base);
	// 826B449C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B44A0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826B44A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B44A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B44AC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 826B44B0: 419A0024  beq cr6, 0x826b44d4
	if ctx.cr[6].eq {
	pc = 0x826B44D4; continue 'dispatch;
	}
	// 826B44B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B44B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B44BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B44C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B44C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B44C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B44CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B44D0: 4082FFE8  bne 0x826b44b8
	if !ctx.cr[0].eq {
	pc = 0x826B44B8; continue 'dispatch;
	}
	// 826B44D4: 3BDD0028  addi r30, r29, 0x28
	ctx.r[30].s64 = ctx.r[29].s64 + 40;
	// 826B44D8: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 826B44DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B44E0: 3B210068  addi r25, r1, 0x68
	ctx.r[25].s64 = ctx.r[1].s64 + 104;
	// 826B44E4: 48954AD5  bl 0x83008fb8
	ctx.lr = 0x826B44E8;
	sub_83008FB8(ctx, base);
	// 826B44E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B44EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826B44F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B44F4: 38A00235  li r5, 0x235
	ctx.r[5].s64 = 565;
	// 826B44F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B44FC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 826B4500: 487A4541  bl 0x82e58a40
	ctx.lr = 0x826B4504;
	sub_82E58A40(ctx, base);
	// 826B4504: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826B4508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B450C: 419A0008  beq cr6, 0x826b4514
	if ctx.cr[6].eq {
	pc = 0x826B4514; continue 'dispatch;
	}
	// 826B4510: 4BC0C381  bl 0x822c0890
	ctx.lr = 0x826B4514;
	sub_822C0890(ctx, base);
	// 826B4514: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826B4518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B451C: 419A0008  beq cr6, 0x826b4524
	if ctx.cr[6].eq {
	pc = 0x826B4524; continue 'dispatch;
	}
	// 826B4520: 4BC0C371  bl 0x822c0890
	ctx.lr = 0x826B4524;
	sub_822C0890(ctx, base);
	// 826B4524: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 826B4528: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826B452C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 826B4530: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826B4534: 4BEE7A5D  bl 0x8259bf90
	ctx.lr = 0x826B4538;
	sub_8259BF90(ctx, base);
	// 826B4538: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B453C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B4540: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B4544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B4548: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826B454C: 419A0024  beq cr6, 0x826b4570
	if ctx.cr[6].eq {
	pc = 0x826B4570; continue 'dispatch;
	}
	// 826B4550: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B4554: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B4558: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B455C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B4560: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B4564: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B4568: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B456C: 4082FFE8  bne 0x826b4554
	if !ctx.cr[0].eq {
	pc = 0x826B4554; continue 'dispatch;
	}
	// 826B4570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4574: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 826B4578: 48954A41  bl 0x83008fb8
	ctx.lr = 0x826B457C;
	sub_83008FB8(ctx, base);
	// 826B457C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B4580: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826B4584: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B4588: 38A00236  li r5, 0x236
	ctx.r[5].s64 = 566;
	// 826B458C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B4590: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B4594: 487A44AD  bl 0x82e58a40
	ctx.lr = 0x826B4598;
	sub_82E58A40(ctx, base);
	// 826B4598: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826B459C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B45A0: 419A0008  beq cr6, 0x826b45a8
	if ctx.cr[6].eq {
	pc = 0x826B45A8; continue 'dispatch;
	}
	// 826B45A4: 4BC0C2ED  bl 0x822c0890
	ctx.lr = 0x826B45A8;
	sub_822C0890(ctx, base);
	// 826B45A8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826B45AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B45B0: 419A0008  beq cr6, 0x826b45b8
	if ctx.cr[6].eq {
	pc = 0x826B45B8; continue 'dispatch;
	}
	// 826B45B4: 4BC0C2DD  bl 0x822c0890
	ctx.lr = 0x826B45B8;
	sub_822C0890(ctx, base);
	// 826B45B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826B45BC: 419A000C  beq cr6, 0x826b45c8
	if ctx.cr[6].eq {
	pc = 0x826B45C8; continue 'dispatch;
	}
	// 826B45C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826B45C4: 4BC0C2CD  bl 0x822c0890
	ctx.lr = 0x826B45C8;
	sub_822C0890(ctx, base);
	// 826B45C8: 897F01E4  lbz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 826B45CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B45D0: 418200B4  beq 0x826b4684
	if ctx.cr[0].eq {
	pc = 0x826B4684; continue 'dispatch;
	}
	// 826B45D4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826B45D8: 4BD0AA51  bl 0x823bf028
	ctx.lr = 0x826B45DC;
	sub_823BF028(ctx, base);
	// 826B45DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B45E0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826B45E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826B45E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B45EC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826B45F0: 419A0024  beq cr6, 0x826b4614
	if ctx.cr[6].eq {
	pc = 0x826B4614; continue 'dispatch;
	}
	// 826B45F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826B45F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B45FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4600: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B4604: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B4608: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B460C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4610: 4082FFE8  bne 0x826b45f8
	if !ctx.cr[0].eq {
	pc = 0x826B45F8; continue 'dispatch;
	}
	// 826B4614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4618: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826B461C: 4BE5AEAD  bl 0x8250f4c8
	ctx.lr = 0x826B4620;
	sub_8250F4C8(ctx, base);
	// 826B4620: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B4624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826B4628: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B462C: 409A0008  bne cr6, 0x826b4634
	if !ctx.cr[6].eq {
	pc = 0x826B4634; continue 'dispatch;
	}
	// 826B4630: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826B4634: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B4638: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 826B463C: 4BE543DD  bl 0x82508a18
	ctx.lr = 0x826B4640;
	sub_82508A18(ctx, base);
	// 826B4640: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826B4644: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826B4648: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826B464C: 38A00241  li r5, 0x241
	ctx.r[5].s64 = 577;
	// 826B4650: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826B4654: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826B4658: 487A43E9  bl 0x82e58a40
	ctx.lr = 0x826B465C;
	sub_82E58A40(ctx, base);
	// 826B465C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826B4660: 4873D631  bl 0x82df1c90
	ctx.lr = 0x826B4664;
	sub_82DF1C90(ctx, base);
	// 826B4664: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826B4668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B466C: 419A0008  beq cr6, 0x826b4674
	if ctx.cr[6].eq {
	pc = 0x826B4674; continue 'dispatch;
	}
	// 826B4670: 4BC0C221  bl 0x822c0890
	ctx.lr = 0x826B4674;
	sub_822C0890(ctx, base);
	// 826B4674: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 826B4678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B467C: 419A0008  beq cr6, 0x826b4684
	if ctx.cr[6].eq {
	pc = 0x826B4684; continue 'dispatch;
	}
	// 826B4680: 4BC0C211  bl 0x822c0890
	ctx.lr = 0x826B4684;
	sub_822C0890(ctx, base);
	// 826B4684: 83DF0218  lwz r30, 0x218(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 826B4688: 83BF021C  lwz r29, 0x21c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 826B468C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826B4690: 419A0028  beq cr6, 0x826b46b8
	if ctx.cr[6].eq {
	pc = 0x826B46B8; continue 'dispatch;
	}
	// 826B4694: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826B4698: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B469C: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B46A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826B46A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B46A8: 4BE5BB49  bl 0x825101f0
	ctx.lr = 0x826B46AC;
	sub_825101F0(ctx, base);
	// 826B46AC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826B46B0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826B46B4: 409AFFE4  bne cr6, 0x826b4698
	if !ctx.cr[6].eq {
	pc = 0x826B4698; continue 'dispatch;
	}
	// 826B46B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B46BC: 809F0230  lwz r4, 0x230(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B46C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B46C4: 80AB666C  lwz r5, 0x666c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 826B46C8: 4BE5D611  bl 0x82511cd8
	ctx.lr = 0x826B46CC;
	sub_82511CD8(ctx, base);
	// 826B46CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B46D0: 9B5F0250  stb r26, 0x250(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[26].u8 ) };
	// 826B46D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B46D8: 419A0008  beq cr6, 0x826b46e0
	if ctx.cr[6].eq {
	pc = 0x826B46E0; continue 'dispatch;
	}
	// 826B46DC: 4BC0C1B5  bl 0x822c0890
	ctx.lr = 0x826B46E0;
	sub_822C0890(ctx, base);
	// 826B46E0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 826B46E4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 826B46E8: 48AF3AC4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B46F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B46F0 size=172
    let mut pc: u32 = 0x826B46F0;
    'dispatch: loop {
        match pc {
            0x826B46F0 => {
    //   block [0x826B46F0..0x826B479C)
	// 826B46F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B46F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B46F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B46FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4704: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B4708: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B470C: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B4710: 396B40C4  addi r11, r11, 0x40c4
	ctx.r[11].s64 = ctx.r[11].s64 + 16580;
	// 826B4714: 394A40B0  addi r10, r10, 0x40b0
	ctx.r[10].s64 = ctx.r[10].s64 + 16560;
	// 826B4718: 39294064  addi r9, r9, 0x4064
	ctx.r[9].s64 = ctx.r[9].s64 + 16484;
	// 826B471C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B4720: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B4724: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B4728: 807F0248  lwz r3, 0x248(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 826B472C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4730: 419A0008  beq cr6, 0x826b4738
	if ctx.cr[6].eq {
	pc = 0x826B4738; continue 'dispatch;
	}
	// 826B4734: 4BC0C15D  bl 0x822c0890
	ctx.lr = 0x826B4738;
	sub_822C0890(ctx, base);
	// 826B4738: 807F0240  lwz r3, 0x240(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 826B473C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4740: 419A0008  beq cr6, 0x826b4748
	if ctx.cr[6].eq {
	pc = 0x826B4748; continue 'dispatch;
	}
	// 826B4744: 4BC0C14D  bl 0x822c0890
	ctx.lr = 0x826B4748;
	sub_822C0890(ctx, base);
	// 826B4748: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 826B474C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4750: 419A0008  beq cr6, 0x826b4758
	if ctx.cr[6].eq {
	pc = 0x826B4758; continue 'dispatch;
	}
	// 826B4754: 4BC0C13D  bl 0x822c0890
	ctx.lr = 0x826B4758;
	sub_822C0890(ctx, base);
	// 826B4758: 807F022C  lwz r3, 0x22c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826B475C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4760: 419A0008  beq cr6, 0x826b4768
	if ctx.cr[6].eq {
	pc = 0x826B4768; continue 'dispatch;
	}
	// 826B4764: 4BC33B05  bl 0x822e8268
	ctx.lr = 0x826B4768;
	sub_822E8268(ctx, base);
	// 826B4768: 807F0228  lwz r3, 0x228(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 826B476C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4770: 419A0008  beq cr6, 0x826b4778
	if ctx.cr[6].eq {
	pc = 0x826B4778; continue 'dispatch;
	}
	// 826B4774: 4BC0C11D  bl 0x822c0890
	ctx.lr = 0x826B4778;
	sub_822C0890(ctx, base);
	// 826B4778: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 826B477C: 4BDFCB25  bl 0x824b12a0
	ctx.lr = 0x826B4780;
	sub_824B12A0(ctx, base);
	// 826B4780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4784: 4BFEEF1D  bl 0x826a36a0
	ctx.lr = 0x826B4788;
	sub_826A36A0(ctx, base);
	// 826B4788: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B478C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B47A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B47A0 size=8
    let mut pc: u32 = 0x826B47A0;
    'dispatch: loop {
        match pc {
            0x826B47A0 => {
    //   block [0x826B47A0..0x826B47A8)
	// 826B47A0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826B47A4: 480000C4  b 0x826b4868
	sub_826B4868(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B47A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B47A8 size=8
    let mut pc: u32 = 0x826B47A8;
    'dispatch: loop {
        match pc {
            0x826B47A8 => {
    //   block [0x826B47A8..0x826B47B0)
	// 826B47A8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826B47AC: 480000BC  b 0x826b4868
	sub_826B4868(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B47B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B47B0 size=184
    let mut pc: u32 = 0x826B47B0;
    'dispatch: loop {
        match pc {
            0x826B47B0 => {
    //   block [0x826B47B0..0x826B4868)
	// 826B47B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B47B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B47B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B47BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B47C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B47C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B47C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B47CC: 4BFEF1A5  bl 0x826a3970
	ctx.lr = 0x826B47D0;
	sub_826A3970(ctx, base);
	// 826B47D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B47D4: 93DF0210  stw r30, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[30].u32 ) };
	// 826B47D8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826B47DC: 396B40C4  addi r11, r11, 0x40c4
	ctx.r[11].s64 = ctx.r[11].s64 + 16580;
	// 826B47E0: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826B47E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826B47E8: 394A40B0  addi r10, r10, 0x40b0
	ctx.r[10].s64 = ctx.r[10].s64 + 16560;
	// 826B47EC: 39294064  addi r9, r9, 0x4064
	ctx.r[9].s64 = ctx.r[9].s64 + 16484;
	// 826B47F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B47F4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826B47F8: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826B47FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826B4800: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 826B4804: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826B4808: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 826B480C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4810: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 826B4814: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 826B4818: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 826B481C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B4820: 917F022C  stw r11, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[11].u32 ) };
	// 826B4824: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 826B4828: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 826B482C: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 826B4830: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 826B4834: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 826B4838: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 826B483C: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 826B4840: D01F024C  stfs f0, 0x24c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), tmp.u32 ) };
	// 826B4844: 997F0250  stb r11, 0x250(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[11].u8 ) };
	// 826B4848: 993F0251  stb r9, 0x251(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(593 as u32), ctx.r[9].u8 ) };
	// 826B484C: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 826B4850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B4854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B485C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B4860: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4868 size=76
    let mut pc: u32 = 0x826B4868;
    'dispatch: loop {
        match pc {
            0x826B4868 => {
    //   block [0x826B4868..0x826B48B4)
	// 826B4868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B486C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B4874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B487C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4880: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826B4884: 4BFFFE6D  bl 0x826b46f0
	ctx.lr = 0x826B4888;
	sub_826B46F0(ctx, base);
	// 826B4888: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B488C: 4182000C  beq 0x826b4898
	if ctx.cr[0].eq {
	pc = 0x826B4898; continue 'dispatch;
	}
	// 826B4890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4894: 4873DB45  bl 0x82df23d8
	ctx.lr = 0x826B4898;
	sub_82DF23D8(ctx, base);
	// 826B4898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B489C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B48A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B48A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B48A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B48AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B48B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B48B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B48B8 size=152
    let mut pc: u32 = 0x826B48B8;
    'dispatch: loop {
        match pc {
            0x826B48B8 => {
    //   block [0x826B48B8..0x826B4950)
	// 826B48B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B48BC: 48AF38AD  bl 0x831a8168
	ctx.lr = 0x826B48C0;
	sub_831A8130(ctx, base);
	// 826B48C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B48C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B48C8: 83FE0218  lwz r31, 0x218(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(536 as u32) ) } as u64;
	// 826B48CC: 83BE021C  lwz r29, 0x21c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(540 as u32) ) } as u64;
	// 826B48D0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826B48D4: 419A0028  beq cr6, 0x826b48fc
	if ctx.cr[6].eq {
	pc = 0x826B48FC; continue 'dispatch;
	}
	// 826B48D8: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826B48DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826B48E0: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826B48E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B48E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B48EC: 4BE5C26D  bl 0x82510b58
	ctx.lr = 0x826B48F0;
	sub_82510B58(ctx, base);
	// 826B48F0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826B48F4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826B48F8: 409AFFE4  bne cr6, 0x826b48dc
	if !ctx.cr[6].eq {
	pc = 0x826B48DC; continue 'dispatch;
	}
	// 826B48FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B4900: 4BC305C1  bl 0x822e4ec0
	ctx.lr = 0x826B4904;
	sub_822E4EC0(ctx, base);
	// 826B4904: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826B4908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B490C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826B4910: 808B6854  lwz r4, 0x6854(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26708 as u32) ) } as u64;
	// 826B4914: 4BC3061D  bl 0x822e4f30
	ctx.lr = 0x826B4918;
	sub_822E4F30(ctx, base);
	// 826B4918: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826B491C: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 826B4920: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B4924: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826B4928: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B492C: 4BDD795D  bl 0x8248c288
	ctx.lr = 0x826B4930;
	sub_8248C288(ctx, base);
	// 826B4930: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826B4934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4938: 809E0230  lwz r4, 0x230(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(560 as u32) ) } as u64;
	// 826B493C: 4BE5D39D  bl 0x82511cd8
	ctx.lr = 0x826B4940;
	sub_82511CD8(ctx, base);
	// 826B4940: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B4944: 997E0250  stb r11, 0x250(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(592 as u32), ctx.r[11].u8 ) };
	// 826B4948: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826B494C: 48AF386C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B4950 size=432
    let mut pc: u32 = 0x826B4950;
    'dispatch: loop {
        match pc {
            0x826B4950 => {
    //   block [0x826B4950..0x826B4B00)
	// 826B4950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4954: 48AF3811  bl 0x831a8164
	ctx.lr = 0x826B4958;
	sub_831A8130(ctx, base);
	// 826B4958: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B495C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B4960: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826B4964: 3BCB4000  addi r30, r11, 0x4000
	ctx.r[30].s64 = ctx.r[11].s64 + 16384;
	// 826B4968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B496C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826B4970: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B4974: 38A0012F  li r5, 0x12f
	ctx.r[5].s64 = 303;
	// 826B4978: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826B497C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B4980: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 826B4984: 4873DA65  bl 0x82df23e8
	ctx.lr = 0x826B4988;
	sub_82DF23E8(ctx, base);
	// 826B4988: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B498C: 41820014  beq 0x826b49a0
	if ctx.cr[0].eq {
	pc = 0x826B49A0; continue 'dispatch;
	}
	// 826B4990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4994: 4BFFFE1D  bl 0x826b47b0
	ctx.lr = 0x826B4998;
	sub_826B47B0(ctx, base);
	// 826B4998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B499C: 48000008  b 0x826b49a4
	pc = 0x826B49A4; continue 'dispatch;
	// 826B49A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B49A4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826B49A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B49AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B49B0: 4BFFF049  bl 0x826b39f8
	ctx.lr = 0x826B49B4;
	sub_826B39F8(ctx, base);
	// 826B49B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B49B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B49BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826B49C0: 4BC0B641  bl 0x822c0000
	ctx.lr = 0x826B49C4;
	sub_822C0000(ctx, base);
	// 826B49C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B49C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B49CC: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 826B49D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826B49D4: 4BC0BA05  bl 0x822c03d8
	ctx.lr = 0x826B49D8;
	sub_822C03D8(ctx, base);
	// 826B49D8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826B49DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826B49E0: 418200B4  beq 0x826b4a94
	if ctx.cr[0].eq {
	pc = 0x826B4A94; continue 'dispatch;
	}
	// 826B49E4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826B49E8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826B49EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826B49F0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826B49F4: 409A0008  bne cr6, 0x826b49fc
	if !ctx.cr[6].eq {
	pc = 0x826B49FC; continue 'dispatch;
	}
	// 826B49F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B49FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826B4A00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B4A04: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826B4A08: 419A0024  beq cr6, 0x826b4a2c
	if ctx.cr[6].eq {
	pc = 0x826B4A2C; continue 'dispatch;
	}
	// 826B4A0C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826B4A10: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826B4A14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4A18: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826B4A1C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826B4A20: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B4A24: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4A28: 4082FFE8  bne 0x826b4a10
	if !ctx.cr[0].eq {
	pc = 0x826B4A10; continue 'dispatch;
	}
	// 826B4A2C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826B4A30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B4A34: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826B4A38: 419A0024  beq cr6, 0x826b4a5c
	if ctx.cr[6].eq {
	pc = 0x826B4A5C; continue 'dispatch;
	}
	// 826B4A3C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826B4A40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826B4A44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4A48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826B4A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826B4A50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826B4A54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826B4A58: 4082FFE8  bne 0x826b4a40
	if !ctx.cr[0].eq {
	pc = 0x826B4A40; continue 'dispatch;
	}
	// 826B4A5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B4A60: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826B4A64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826B4A68: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826B4A6C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826B4A70: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826B4A74: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826B4A78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826B4A7C: 480E44B5  bl 0x82798f30
	ctx.lr = 0x826B4A80;
	sub_82798F30(ctx, base);
	// 826B4A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4A88: 480E6BE1  bl 0x8279b668
	ctx.lr = 0x826B4A8C;
	sub_8279B668(ctx, base);
	// 826B4A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4A90: 48000008  b 0x826b4a98
	pc = 0x826B4A98; continue 'dispatch;
	// 826B4A94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826B4A98: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826B4A9C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826B4AA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4AA8: 4BEE31A9  bl 0x82597c50
	ctx.lr = 0x826B4AAC;
	sub_82597C50(ctx, base);
	// 826B4AAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826B4AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B4AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4AB8: 4BC0B549  bl 0x822c0000
	ctx.lr = 0x826B4ABC;
	sub_822C0000(ctx, base);
	// 826B4ABC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B4AC0: 41820024  beq 0x826b4ae4
	if ctx.cr[0].eq {
	pc = 0x826B4AE4; continue 'dispatch;
	}
	// 826B4AC4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826B4AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4ACC: 419A0008  beq cr6, 0x826b4ad4
	if ctx.cr[6].eq {
	pc = 0x826B4AD4; continue 'dispatch;
	}
	// 826B4AD0: 4BC0BDC1  bl 0x822c0890
	ctx.lr = 0x826B4AD4;
	sub_822C0890(ctx, base);
	// 826B4AD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826B4AD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826B4ADC: 419A0008  beq cr6, 0x826b4ae4
	if ctx.cr[6].eq {
	pc = 0x826B4AE4; continue 'dispatch;
	}
	// 826B4AE0: 4BC0BDB1  bl 0x822c0890
	ctx.lr = 0x826B4AE4;
	sub_822C0890(ctx, base);
	// 826B4AE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B4AE8: 419A000C  beq cr6, 0x826b4af4
	if ctx.cr[6].eq {
	pc = 0x826B4AF4; continue 'dispatch;
	}
	// 826B4AEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826B4AF0: 4BC0BDA1  bl 0x822c0890
	ctx.lr = 0x826B4AF4;
	sub_822C0890(ctx, base);
	// 826B4AF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B4AF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826B4AFC: 48AF36B8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4B00 size=52
    let mut pc: u32 = 0x826B4B00;
    'dispatch: loop {
        match pc {
            0x826B4B00 => {
    //   block [0x826B4B00..0x826B4B34)
	// 826B4B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4B08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4B0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4B10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B4B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4B18: 4BFFFE39  bl 0x826b4950
	ctx.lr = 0x826B4B1C;
	sub_826B4950(ctx, base);
	// 826B4B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4B38 size=52
    let mut pc: u32 = 0x826B4B38;
    'dispatch: loop {
        match pc {
            0x826B4B38 => {
    //   block [0x826B4B38..0x826B4B6C)
	// 826B4B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4B44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4B48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B4B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4B50: 4BFFFE01  bl 0x826b4950
	ctx.lr = 0x826B4B54;
	sub_826B4950(ctx, base);
	// 826B4B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4B58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4B5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4B60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4B64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4B68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4B70 size=52
    let mut pc: u32 = 0x826B4B70;
    'dispatch: loop {
        match pc {
            0x826B4B70 => {
    //   block [0x826B4B70..0x826B4BA4)
	// 826B4B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4B78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4B7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4B80: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826B4B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4B88: 4BFFFDC9  bl 0x826b4950
	ctx.lr = 0x826B4B8C;
	sub_826B4950(ctx, base);
	// 826B4B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4BA8 size=52
    let mut pc: u32 = 0x826B4BA8;
    'dispatch: loop {
        match pc {
            0x826B4BA8 => {
    //   block [0x826B4BA8..0x826B4BDC)
	// 826B4BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4BB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4BB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4BB8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826B4BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4BC0: 4BFFFD91  bl 0x826b4950
	ctx.lr = 0x826B4BC4;
	sub_826B4950(ctx, base);
	// 826B4BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4BC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4BE0 size=52
    let mut pc: u32 = 0x826B4BE0;
    'dispatch: loop {
        match pc {
            0x826B4BE0 => {
    //   block [0x826B4BE0..0x826B4C14)
	// 826B4BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4BE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4BEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4BF0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826B4BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4BF8: 4BFFFD59  bl 0x826b4950
	ctx.lr = 0x826B4BFC;
	sub_826B4950(ctx, base);
	// 826B4BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4C00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4C18 size=52
    let mut pc: u32 = 0x826B4C18;
    'dispatch: loop {
        match pc {
            0x826B4C18 => {
    //   block [0x826B4C18..0x826B4C4C)
	// 826B4C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4C28: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826B4C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4C30: 4BFFFD21  bl 0x826b4950
	ctx.lr = 0x826B4C34;
	sub_826B4950(ctx, base);
	// 826B4C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4C38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4C44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4C50 size=52
    let mut pc: u32 = 0x826B4C50;
    'dispatch: loop {
        match pc {
            0x826B4C50 => {
    //   block [0x826B4C50..0x826B4C84)
	// 826B4C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4C5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4C60: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826B4C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4C68: 4BFFFCE9  bl 0x826b4950
	ctx.lr = 0x826B4C6C;
	sub_826B4950(ctx, base);
	// 826B4C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4C70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4C88 size=52
    let mut pc: u32 = 0x826B4C88;
    'dispatch: loop {
        match pc {
            0x826B4C88 => {
    //   block [0x826B4C88..0x826B4CBC)
	// 826B4C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4C90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4C94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4C98: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826B4C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4CA0: 4BFFFCB1  bl 0x826b4950
	ctx.lr = 0x826B4CA4;
	sub_826B4950(ctx, base);
	// 826B4CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4CA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4CAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4CB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4CB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4CC0 size=52
    let mut pc: u32 = 0x826B4CC0;
    'dispatch: loop {
        match pc {
            0x826B4CC0 => {
    //   block [0x826B4CC0..0x826B4CF4)
	// 826B4CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4CD0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826B4CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4CD8: 4BFFFC79  bl 0x826b4950
	ctx.lr = 0x826B4CDC;
	sub_826B4950(ctx, base);
	// 826B4CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4CE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4CE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4CE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B4CF8 size=52
    let mut pc: u32 = 0x826B4CF8;
    'dispatch: loop {
        match pc {
            0x826B4CF8 => {
    //   block [0x826B4CF8..0x826B4D2C)
	// 826B4CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B4D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B4D04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4D08: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 826B4D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4D10: 4BFFFC41  bl 0x826b4950
	ctx.lr = 0x826B4D14;
	sub_826B4950(ctx, base);
	// 826B4D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B4D18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826B4D1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B4D20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B4D24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B4D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B4D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B4D30 size=1480
    let mut pc: u32 = 0x826B4D30;
    'dispatch: loop {
        match pc {
            0x826B4D30 => {
    //   block [0x826B4D30..0x826B52F8)
	// 826B4D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B4D34: 48AF3421  bl 0x831a8154
	ctx.lr = 0x826B4D38;
	sub_831A8130(ctx, base);
	// 826B4D38: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B4D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B4D40: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826B4D44: 4BFEF9E5  bl 0x826a4728
	ctx.lr = 0x826B4D48;
	sub_826A4728(ctx, base);
	// 826B4D48: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826B4D4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B4D50: 3B2B4000  addi r25, r11, 0x4000
	ctx.r[25].s64 = ctx.r[11].s64 + 16384;
	// 826B4D54: 38A0017B  li r5, 0x17b
	ctx.r[5].s64 = 379;
	// 826B4D58: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B4D5C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826B4D60: 4873D689  bl 0x82df23e8
	ctx.lr = 0x826B4D64;
	sub_82DF23E8(ctx, base);
	// 826B4D64: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826B4D68: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 826B4D6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B4D70: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 826B4D74: 41820014  beq 0x826b4d88
	if ctx.cr[0].eq {
	pc = 0x826B4D88; continue 'dispatch;
	}
	// 826B4D78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826B4D7C: 4875E375  bl 0x82e130f0
	ctx.lr = 0x826B4D80;
	sub_82E130F0(ctx, base);
	// 826B4D80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4D84: 48000008  b 0x826b4d8c
	pc = 0x826B4D8C; continue 'dispatch;
	// 826B4D88: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B4D8C: 3B7F0234  addi r27, r31, 0x234
	ctx.r[27].s64 = ctx.r[31].s64 + 564;
	// 826B4D90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826B4D94: 4BC2CFBD  bl 0x822e1d50
	ctx.lr = 0x826B4D98;
	sub_822E1D50(ctx, base);
	// 826B4D98: 809F0234  lwz r4, 0x234(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 826B4D9C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826B4DA0: 4875E091  bl 0x82e12e30
	ctx.lr = 0x826B4DA4;
	sub_82E12E30(ctx, base);
	// 826B4DA4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826B4DA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826B4DAC: 38A0017E  li r5, 0x17e
	ctx.r[5].s64 = 382;
	// 826B4DB0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826B4DB4: 4873D635  bl 0x82df23e8
	ctx.lr = 0x826B4DB8;
	sub_82DF23E8(ctx, base);
	// 826B4DB8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826B4DBC: 4182002C  beq 0x826b4de8
	if ctx.cr[0].eq {
	pc = 0x826B4DE8; continue 'dispatch;
	}
	// 826B4DC0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826B4DC4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826B4DC8: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B4DCC: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826B4DD0: 487C7C19  bl 0x82e7c9e8
	ctx.lr = 0x826B4DD4;
	sub_82E7C9E8(ctx, base);
	// 826B4DD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4DDC: 4875E315  bl 0x82e130f0
	ctx.lr = 0x826B4DE0;
	sub_82E130F0(ctx, base);
	// 826B4DE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B4DE4: 48000008  b 0x826b4dec
	pc = 0x826B4DEC; continue 'dispatch;
	// 826B4DE8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826B4DEC: 3BDF023C  addi r30, r31, 0x23c
	ctx.r[30].s64 = ctx.r[31].s64 + 572;
	// 826B4DF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B4DF4: 4BC2CF5D  bl 0x822e1d50
	ctx.lr = 0x826B4DF8;
	sub_822E1D50(ctx, base);
	// 826B4DF8: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 826B4DFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826B4E00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826B4E04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826B4E08: 4E800421  bctrl
	ctx.lr = 0x826B4E0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826B4E0C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826B4E10: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826B4E14: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B4E18: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826B4E1C: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 826B4E20: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 826B4E24: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B4E28: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 826B4E2C: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 826B4E30: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B4E34: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826B4E38: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B52F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826B52F8 size=12
    let mut pc: u32 = 0x826B52F8;
    'dispatch: loop {
        match pc {
            0x826B52F8 => {
    //   block [0x826B52F8..0x826B5304)
	// 826B52F8: C0030060  lfs f0, 0x60(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B52FC: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826B5300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B5308 size=12
    let mut pc: u32 = 0x826B5308;
    'dispatch: loop {
        match pc {
            0x826B5308 => {
    //   block [0x826B5308..0x826B5314)
	// 826B5308: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826B530C: 99630131  stb r11, 0x131(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(305 as u32), ctx.r[11].u8 ) };
	// 826B5310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B5318 size=12
    let mut pc: u32 = 0x826B5318;
    'dispatch: loop {
        match pc {
            0x826B5318 => {
    //   block [0x826B5318..0x826B5324)
	// 826B5318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826B531C: 99630131  stb r11, 0x131(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(305 as u32), ctx.r[11].u8 ) };
	// 826B5320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B5328 size=12
    let mut pc: u32 = 0x826B5328;
    'dispatch: loop {
        match pc {
            0x826B5328 => {
    //   block [0x826B5328..0x826B5334)
	// 826B5328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826B532C: 99630132  stb r11, 0x132(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(306 as u32), ctx.r[11].u8 ) };
	// 826B5330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826B5338 size=24
    let mut pc: u32 = 0x826B5338;
    'dispatch: loop {
        match pc {
            0x826B5338 => {
    //   block [0x826B5338..0x826B5350)
	// 826B5338: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B533C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826B5340: 99430132  stb r10, 0x132(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(306 as u32), ctx.r[10].u8 ) };
	// 826B5344: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B5348: D003013C  stfs f0, 0x13c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 826B534C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826B5350 size=20
    let mut pc: u32 = 0x826B5350;
    'dispatch: loop {
        match pc {
            0x826B5350 => {
    //   block [0x826B5350..0x826B5364)
	// 826B5350: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B5354: C1A30148  lfs f13, 0x148(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B5358: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 826B535C: D0030134  stfs f0, 0x134(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 826B5360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826B5368 size=28
    let mut pc: u32 = 0x826B5368;
    'dispatch: loop {
        match pc {
            0x826B5368 => {
    //   block [0x826B5368..0x826B5384)
	// 826B5368: C0030134  lfs f0, 0x134(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B536C: C1A30148  lfs f13, 0x148(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B5370: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826B5374: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826B5378: C0030148  lfs f0, 0x148(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B537C: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 826B5380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826B5388 size=12
    let mut pc: u32 = 0x826B5388;
    'dispatch: loop {
        match pc {
            0x826B5388 => {
    //   block [0x826B5388..0x826B5394)
	// 826B5388: C0030134  lfs f0, 0x134(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B538C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826B5390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826B5398 size=444
    let mut pc: u32 = 0x826B5398;
    'dispatch: loop {
        match pc {
            0x826B5398 => {
    //   block [0x826B5398..0x826B5554)
	// 826B5398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B539C: 48AF2DCD  bl 0x831a8168
	ctx.lr = 0x826B53A0;
	sub_831A8130(ctx, base);
	// 826B53A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B53A4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826B53A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826B53AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B53B0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826B53B4: 41820038  beq 0x826b53ec
	if ctx.cr[0].eq {
	pc = 0x826B53EC; continue 'dispatch;
	}
	// 826B53B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B53BC: 48AF45CD  bl 0x831a9988
	ctx.lr = 0x826B53C0;
	sub_831A9988(ctx, base);
	// 826B53C0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B53C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B53C8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826B53CC: 48AF2D2D  bl 0x831a80f8
	ctx.lr = 0x826B53D0;
	sub_831A80F8(ctx, base);
	// 826B53D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B53D4: 41820018  beq 0x826b53ec
	if ctx.cr[0].eq {
	pc = 0x826B53EC; continue 'dispatch;
	}
	// 826B53D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B53DC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B53E0: 4BFFFF29  bl 0x826b5308
	ctx.lr = 0x826B53E4;
	sub_826B5308(ctx, base);
	// 826B53E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826B53E8: 48000164  b 0x826b554c
	pc = 0x826B554C; continue 'dispatch;
	// 826B53EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B53F0: 419A014C  beq cr6, 0x826b553c
	if ctx.cr[6].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B53F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B53F8: 48AF4591  bl 0x831a9988
	ctx.lr = 0x826B53FC;
	sub_831A9988(ctx, base);
	// 826B53FC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826B5400: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B5404: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 826B5408: 48AF2CF1  bl 0x831a80f8
	ctx.lr = 0x826B540C;
	sub_831A80F8(ctx, base);
	// 826B540C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B5410: 41820014  beq 0x826b5424
	if ctx.cr[0].eq {
	pc = 0x826B5424; continue 'dispatch;
	}
	// 826B5414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B5418: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B541C: 4BFFFEFD  bl 0x826b5318
	ctx.lr = 0x826B5420;
	sub_826B5318(ctx, base);
	// 826B5420: 4BFFFFC4  b 0x826b53e4
	pc = 0x826B53E4; continue 'dispatch;
	// 826B5424: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B5428: 419A0114  beq cr6, 0x826b553c
	if ctx.cr[6].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B542C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B5430: 48AF4559  bl 0x831a9988
	ctx.lr = 0x826B5434;
	sub_831A9988(ctx, base);
	// 826B5434: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B5438: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B543C: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 826B5440: 48AF2CB9  bl 0x831a80f8
	ctx.lr = 0x826B5444;
	sub_831A80F8(ctx, base);
	// 826B5444: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B5448: 41820014  beq 0x826b545c
	if ctx.cr[0].eq {
	pc = 0x826B545C; continue 'dispatch;
	}
	// 826B544C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B5450: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B5454: 4BFFFED5  bl 0x826b5328
	ctx.lr = 0x826B5458;
	sub_826B5328(ctx, base);
	// 826B5458: 4BFFFF8C  b 0x826b53e4
	pc = 0x826B53E4; continue 'dispatch;
	// 826B545C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B5460: 419A00DC  beq cr6, 0x826b553c
	if ctx.cr[6].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B5464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B5468: 48AF4521  bl 0x831a9988
	ctx.lr = 0x826B546C;
	sub_831A9988(ctx, base);
	// 826B546C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826B5470: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B5474: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 826B5478: 48AF2C81  bl 0x831a80f8
	ctx.lr = 0x826B547C;
	sub_831A80F8(ctx, base);
	// 826B547C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B5480: 41820014  beq 0x826b5494
	if ctx.cr[0].eq {
	pc = 0x826B5494; continue 'dispatch;
	}
	// 826B5484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B5488: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B548C: 4BFFFEAD  bl 0x826b5338
	ctx.lr = 0x826B5490;
	sub_826B5338(ctx, base);
	// 826B5490: 4BFFFF54  b 0x826b53e4
	pc = 0x826B53E4; continue 'dispatch;
	// 826B5494: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B5498: 419A00A4  beq cr6, 0x826b553c
	if ctx.cr[6].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B549C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B54A0: 48AF44E9  bl 0x831a9988
	ctx.lr = 0x826B54A4;
	sub_831A9988(ctx, base);
	// 826B54A4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826B54A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B54AC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826B54B0: 48AF2C49  bl 0x831a80f8
	ctx.lr = 0x826B54B4;
	sub_831A80F8(ctx, base);
	// 826B54B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B54B8: 41820014  beq 0x826b54cc
	if ctx.cr[0].eq {
	pc = 0x826B54CC; continue 'dispatch;
	}
	// 826B54BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B54C0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B54C4: 4BFFFE8D  bl 0x826b5350
	ctx.lr = 0x826B54C8;
	sub_826B5350(ctx, base);
	// 826B54C8: 4BFFFF1C  b 0x826b53e4
	pc = 0x826B53E4; continue 'dispatch;
	// 826B54CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B54D0: 419A006C  beq cr6, 0x826b553c
	if ctx.cr[6].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B54D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B54D8: 48AF44B1  bl 0x831a9988
	ctx.lr = 0x826B54DC;
	sub_831A9988(ctx, base);
	// 826B54DC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826B54E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B54E4: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 826B54E8: 48AF2C11  bl 0x831a80f8
	ctx.lr = 0x826B54EC;
	sub_831A80F8(ctx, base);
	// 826B54EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B54F0: 41820014  beq 0x826b5504
	if ctx.cr[0].eq {
	pc = 0x826B5504; continue 'dispatch;
	}
	// 826B54F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B54F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B54FC: 4BFFFE6D  bl 0x826b5368
	ctx.lr = 0x826B5500;
	sub_826B5368(ctx, base);
	// 826B5500: 4BFFFEE4  b 0x826b53e4
	pc = 0x826B53E4; continue 'dispatch;
	// 826B5504: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826B5508: 419A0034  beq cr6, 0x826b553c
	if ctx.cr[6].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B550C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B5510: 48AF4479  bl 0x831a9988
	ctx.lr = 0x826B5514;
	sub_831A9988(ctx, base);
	// 826B5514: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826B5518: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B551C: 386B9E7C  addi r3, r11, -0x6184
	ctx.r[3].s64 = ctx.r[11].s64 + -24964;
	// 826B5520: 48AF2BD9  bl 0x831a80f8
	ctx.lr = 0x826B5524;
	sub_831A80F8(ctx, base);
	// 826B5524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826B5528: 41820014  beq 0x826b553c
	if ctx.cr[0].eq {
	pc = 0x826B553C; continue 'dispatch;
	}
	// 826B552C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B5530: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826B5534: 4BFFFE55  bl 0x826b5388
	ctx.lr = 0x826B5538;
	sub_826B5388(ctx, base);
	// 826B5538: 4BFFFEAC  b 0x826b53e4
	pc = 0x826B53E4; continue 'dispatch;
	// 826B553C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826B5540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826B5544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826B5548: 4BE5D0D1  bl 0x82512618
	ctx.lr = 0x826B554C;
	sub_82512618(ctx, base);
	// 826B554C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B5550: 48AF2C68  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826B5558 size=8
    let mut pc: u32 = 0x826B5558;
    'dispatch: loop {
        match pc {
            0x826B5558 => {
    //   block [0x826B5558..0x826B5560)
	// 826B5558: 80630128  lwz r3, 0x128(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(296 as u32) ) } as u64;
	// 826B555C: 4849116C  b 0x82b466c8
	sub_82B466C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B5560 size=132
    let mut pc: u32 = 0x826B5560;
    'dispatch: loop {
        match pc {
            0x826B5560 => {
    //   block [0x826B5560..0x826B55E4)
	// 826B5560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B5564: 48AF2C09  bl 0x831a816c
	ctx.lr = 0x826B5568;
	sub_831A8130(ctx, base);
	// 826B5568: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B556C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826B5570: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826B5574: 3BCB4370  addi r30, r11, 0x4370
	ctx.r[30].s64 = ctx.r[11].s64 + 17264;
	// 826B5578: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826B557C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B5580: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B5584: 4873E485  bl 0x82df3a08
	ctx.lr = 0x826B5588;
	sub_82DF3A08(ctx, base);
	// 826B5588: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826B558C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B5590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B5594: 4BEEBFF5  bl 0x825a1588
	ctx.lr = 0x826B5598;
	sub_825A1588(ctx, base);
	// 826B5598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B559C: 4873DE8D  bl 0x82df3428
	ctx.lr = 0x826B55A0;
	sub_82DF3428(ctx, base);
	// 826B55A0: C1BD0068  lfs f13, 0x68(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B55A4: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 826B55A8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826B55AC: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B55B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826B55B4: 41990028  bgt cr6, 0x826b55dc
	if ctx.cr[6].gt {
	pc = 0x826B55DC; continue 'dispatch;
	}
	// 826B55B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826B55BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B55C0: 4873E449  bl 0x82df3a08
	ctx.lr = 0x826B55C4;
	sub_82DF3A08(ctx, base);
	// 826B55C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826B55C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826B55CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B55D0: 4BEEBFB9  bl 0x825a1588
	ctx.lr = 0x826B55D4;
	sub_825A1588(ctx, base);
	// 826B55D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B55D8: 4873DE51  bl 0x82df3428
	ctx.lr = 0x826B55DC;
	sub_82DF3428(ctx, base);
	// 826B55DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826B55E0: 48AF2BDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B55E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B55E8 size=72
    let mut pc: u32 = 0x826B55E8;
    'dispatch: loop {
        match pc {
            0x826B55E8 => {
    //   block [0x826B55E8..0x826B5630)
	// 826B55E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B55EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B55F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B55F4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B55F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826B55FC: 83E30110  lwz r31, 0x110(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) } as u64;
	// 826B5600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826B5604: C00BCEE4  lfs f0, -0x311c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B5608: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 826B560C: 487C73DD  bl 0x82e7c9e8
	ctx.lr = 0x826B5610;
	sub_82E7C9E8(ctx, base);
	// 826B5610: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826B5614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B5618: 4875DC49  bl 0x82e13260
	ctx.lr = 0x826B561C;
	sub_82E13260(ctx, base);
	// 826B561C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826B5620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B5624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B5628: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B562C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826B5630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826B5630 size=200
    let mut pc: u32 = 0x826B5630;
    'dispatch: loop {
        match pc {
            0x826B5630 => {
    //   block [0x826B5630..0x826B56F8)
	// 826B5630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826B5634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826B5638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826B563C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826B5640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826B5644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826B5648: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826B564C: C01F0134  lfs f0, 0x134(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826B5650: C1ABDFB0  lfs f13, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826B5654: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826B5658: 41990034  bgt cr6, 0x826b568c
	if ctx.cr[6].gt {
	pc = 0x826B568C; continue 'dispatch;
	}
	// 826B565C: 897F0141  lbz r11, 0x141(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 826B5660: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B5664: 4182007C  beq 0x826b56e0
	if ctx.cr[0].eq {
	pc = 0x826B56E0; continue 'dispatch;
	}
	// 826B5668: 897F0142  lbz r11, 0x142(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(322 as u32) ) } as u64;
	// 826B566C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826B5670: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B5674: 9BDF0141  stb r30, 0x141(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(321 as u32), ctx.r[30].u8 ) };
	// 826B5678: 4182000C  beq 0x826b5684
	if ctx.cr[0].eq {
	pc = 0x826B5684; continue 'dispatch;
	}
	// 826B567C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826B5680: 48000044  b 0x826b56c4
	pc = 0x826B56C4; continue 'dispatch;
	// 826B5684: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B5688: 4800004C  b 0x826b56d4
	pc = 0x826B56D4; continue 'dispatch;
	// 826B568C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826B5690: C18B08A8  lfs f12, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826B5694: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 826B5698: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826B569C: 41990044  bgt cr6, 0x826b56e0
	if ctx.cr[6].gt {
	pc = 0x826B56E0; continue 'dispatch;
	}
	// 826B56A0: 897F0141  lbz r11, 0x141(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 826B56A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B56A8: 40820038  bne 0x826b56e0
	if !ctx.cr[0].eq {
	pc = 0x826B56E0; continue 'dispatch;
	}
	// 826B56AC: 897F0142  lbz r11, 0x142(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(322 as u32) ) } as u64;
	// 826B56B0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826B56B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826B56B8: 9BDF0141  stb r30, 0x141(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(321 as u32), ctx.r[30].u8 ) };
	// 826B56BC: 41820014  beq 0x826b56d0
	if ctx.cr[0].eq {
	pc = 0x826B56D0; continue 'dispatch;
	}
	// 826B56C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826B56C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826B56C8: 4BE5A389  bl 0x8250fa50
	ctx.lr = 0x826B56CC;
	sub_8250FA50(ctx, base);
	// 826B56CC: 48000010  b 0x826b56dc
	pc = 0x826B56DC; continue 'dispatch;
	// 826B56D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826B56D4: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 826B56D8: 481124B9  bl 0x827c7b90
	ctx.lr = 0x826B56DC;
	sub_827C7B90(ctx, base);
	// 826B56DC: 9BDF0141  stb r30, 0x141(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(321 as u32), ctx.r[30].u8 ) };
	// 826B56E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826B56E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826B56E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826B56EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826B56F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826B56F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


