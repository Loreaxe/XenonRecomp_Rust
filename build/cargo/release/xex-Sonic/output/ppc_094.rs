pub fn sub_8282D310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D310 size=12
    let mut pc: u32 = 0x8282D310;
    'dispatch: loop {
        match pc {
            0x8282D310 => {
    //   block [0x8282D310..0x8282D31C)
	// 8282D310: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282D314: 386BB248  addi r3, r11, -0x4db8
	ctx.r[3].s64 = ctx.r[11].s64 + -19896;
	// 8282D318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D320 size=12
    let mut pc: u32 = 0x8282D320;
    'dispatch: loop {
        match pc {
            0x8282D320 => {
    //   block [0x8282D320..0x8282D32C)
	// 8282D320: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282D324: 386BAEF4  addi r3, r11, -0x510c
	ctx.r[3].s64 = ctx.r[11].s64 + -20748;
	// 8282D328: 4BFEEC08  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D330 size=12
    let mut pc: u32 = 0x8282D330;
    'dispatch: loop {
        match pc {
            0x8282D330 => {
    //   block [0x8282D330..0x8282D33C)
	// 8282D330: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282D334: 386BAEF4  addi r3, r11, -0x510c
	ctx.r[3].s64 = ctx.r[11].s64 + -20748;
	// 8282D338: 4BFEEC00  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D340 size=16
    let mut pc: u32 = 0x8282D340;
    'dispatch: loop {
        match pc {
            0x8282D340 => {
    //   block [0x8282D340..0x8282D350)
	// 8282D340: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8282D344: 816B7060  lwz r11, 0x7060(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28768 as u32) ) } as u64;
	// 8282D348: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D34C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D350 size=4
    let mut pc: u32 = 0x8282D350;
    'dispatch: loop {
        match pc {
            0x8282D350 => {
    //   block [0x8282D350..0x8282D354)
	// 8282D350: 4BFEC2C0  b 0x82819610
	sub_82819610(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D358 size=28
    let mut pc: u32 = 0x8282D358;
    'dispatch: loop {
        match pc {
            0x8282D358 => {
    //   block [0x8282D358..0x8282D374)
	// 8282D358: 81630270  lwz r11, 0x270(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(624 as u32) ) } as u64;
	// 8282D35C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282D360: 409A0014  bne cr6, 0x8282d374
	if !ctx.cr[6].eq {
		sub_8282D374(ctx, base);
		return;
	}
	// 8282D364: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8282D368: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8282D36C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8282D370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D374(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D374 size=4
    let mut pc: u32 = 0x8282D374;
    'dispatch: loop {
        match pc {
            0x8282D374 => {
    //   block [0x8282D374..0x8282D378)
	// 8282D374: 4BE95174  b 0x826c24e8
	sub_826C24E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D378 size=8
    let mut pc: u32 = 0x8282D378;
    'dispatch: loop {
        match pc {
            0x8282D378 => {
    //   block [0x8282D378..0x8282D380)
	// 8282D378: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8282D37C: 4BFED084  b 0x8281a400
	sub_8281A400(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8282D380 size=24
    let mut pc: u32 = 0x8282D380;
    'dispatch: loop {
        match pc {
            0x8282D380 => {
    //   block [0x8282D380..0x8282D398)
	// 8282D380: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8282D384: C1A30064  lfs f13, 0x64(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282D388: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8282D38C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282D390: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8282D394: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D398 size=8
    let mut pc: u32 = 0x8282D398;
    'dispatch: loop {
        match pc {
            0x8282D398 => {
    //   block [0x8282D398..0x8282D3A0)
	// 8282D398: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8282D39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D3A0 size=88
    let mut pc: u32 = 0x8282D3A0;
    'dispatch: loop {
        match pc {
            0x8282D3A0 => {
    //   block [0x8282D3A0..0x8282D3F8)
	// 8282D3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D3A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282D3AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D3B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D3B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282D3B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282D3BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282D3C0: 396BB7BC  addi r11, r11, -0x4844
	ctx.r[11].s64 = ctx.r[11].s64 + -18500;
	// 8282D3C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D3C8: 4862F1C1  bl 0x82e5c588
	ctx.lr = 0x8282D3CC;
	sub_82E5C588(ctx, base);
	// 8282D3CC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282D3D0: 4182000C  beq 0x8282d3dc
	if ctx.cr[0].eq {
	pc = 0x8282D3DC; continue 'dispatch;
	}
	// 8282D3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D3D8: 485C5001  bl 0x82df23d8
	ctx.lr = 0x8282D3DC;
	sub_82DF23D8(ctx, base);
	// 8282D3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D3E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282D3E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D3E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D3EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282D3F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282D3F8 size=116
    let mut pc: u32 = 0x8282D3F8;
    'dispatch: loop {
        match pc {
            0x8282D3F8 => {
    //   block [0x8282D3F8..0x8282D46C)
	// 8282D3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D404: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D408: 80630280  lwz r3, 0x280(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(640 as u32) ) } as u64;
	// 8282D40C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282D410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282D414: 419A0044  beq cr6, 0x8282d458
	if ctx.cr[6].eq {
	pc = 0x8282D458; continue 'dispatch;
	}
	// 8282D418: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D41C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8282D420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D424: 4E800421  bctrl
	ctx.lr = 0x8282D428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D428: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8282D42C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8282D430: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282D434: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282D438: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8282D43C: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8282D440: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8282D444: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8282D448: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8282D44C: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8282D450: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D470 size=196
    let mut pc: u32 = 0x8282D470;
    'dispatch: loop {
        match pc {
            0x8282D470 => {
    //   block [0x8282D470..0x8282D534)
	// 8282D470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282D47C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D484: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282D488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282D48C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282D490: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282D494: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D498: 4BA934A1  bl 0x822c0938
	ctx.lr = 0x8282D49C;
	sub_822C0938(ctx, base);
	// 8282D49C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282D4A0: 41820028  beq 0x8282d4c8
	if ctx.cr[0].eq {
	pc = 0x8282D4C8; continue 'dispatch;
	}
	// 8282D4A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282D4A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282D4AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282D4B0: 392BB780  addi r9, r11, -0x4880
	ctx.r[9].s64 = ctx.r[11].s64 + -18560;
	// 8282D4B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282D4B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282D4BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282D4C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282D4C4: 48000008  b 0x8282d4cc
	pc = 0x8282D4CC; continue 'dispatch;
	// 8282D4C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282D4CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282D4D4: 409A0044  bne cr6, 0x8282d518
	if !ctx.cr[6].eq {
	pc = 0x8282D518; continue 'dispatch;
	}
	// 8282D4D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282D4DC: 419A001C  beq cr6, 0x8282d4f8
	if ctx.cr[6].eq {
	pc = 0x8282D4F8; continue 'dispatch;
	}
	// 8282D4E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D4E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282D4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D4EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D4F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D4F4: 4E800421  bctrl
	ctx.lr = 0x8282D4F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D4F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282D4FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282D500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282D504: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282D508: 816B0A70  lwz r11, 0xa70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2672 as u32) ) } as u64;
	// 8282D50C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282D510: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282D514: 4BA92AED  bl 0x822c0000
	ctx.lr = 0x8282D518;
	sub_822C0000(ctx, base);
	// 8282D518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282D51C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282D520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D528: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282D52C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D538 size=196
    let mut pc: u32 = 0x8282D538;
    'dispatch: loop {
        match pc {
            0x8282D538 => {
    //   block [0x8282D538..0x8282D5FC)
	// 8282D538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282D544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D54C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282D550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282D554: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282D558: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282D55C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D560: 4BA933D9  bl 0x822c0938
	ctx.lr = 0x8282D564;
	sub_822C0938(ctx, base);
	// 8282D564: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282D568: 41820028  beq 0x8282d590
	if ctx.cr[0].eq {
	pc = 0x8282D590; continue 'dispatch;
	}
	// 8282D56C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282D570: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282D574: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282D578: 392BB794  addi r9, r11, -0x486c
	ctx.r[9].s64 = ctx.r[11].s64 + -18540;
	// 8282D57C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282D580: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282D584: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282D588: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282D58C: 48000008  b 0x8282d594
	pc = 0x8282D594; continue 'dispatch;
	// 8282D590: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282D594: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282D59C: 409A0044  bne cr6, 0x8282d5e0
	if !ctx.cr[6].eq {
	pc = 0x8282D5E0; continue 'dispatch;
	}
	// 8282D5A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282D5A4: 419A001C  beq cr6, 0x8282d5c0
	if ctx.cr[6].eq {
	pc = 0x8282D5C0; continue 'dispatch;
	}
	// 8282D5A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D5AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282D5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D5B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282D5B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D5BC: 4E800421  bctrl
	ctx.lr = 0x8282D5C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D5C0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282D5C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282D5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282D5CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282D5D0: 816B0A70  lwz r11, 0xa70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2672 as u32) ) } as u64;
	// 8282D5D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282D5D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282D5DC: 4BA92A25  bl 0x822c0000
	ctx.lr = 0x8282D5E0;
	sub_822C0000(ctx, base);
	// 8282D5E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282D5E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282D5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D5F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282D5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D600 size=196
    let mut pc: u32 = 0x8282D600;
    'dispatch: loop {
        match pc {
            0x8282D600 => {
    //   block [0x8282D600..0x8282D6C4)
	// 8282D600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282D60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D614: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282D618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282D61C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282D620: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282D624: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D628: 4BA93311  bl 0x822c0938
	ctx.lr = 0x8282D62C;
	sub_822C0938(ctx, base);
	// 8282D62C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282D630: 41820028  beq 0x8282d658
	if ctx.cr[0].eq {
	pc = 0x8282D658; continue 'dispatch;
	}
	// 8282D634: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282D638: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282D63C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282D640: 392BB7A8  addi r9, r11, -0x4858
	ctx.r[9].s64 = ctx.r[11].s64 + -18520;
	// 8282D644: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282D648: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282D64C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282D650: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282D654: 48000008  b 0x8282d65c
	pc = 0x8282D65C; continue 'dispatch;
	// 8282D658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282D65C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282D664: 409A0044  bne cr6, 0x8282d6a8
	if !ctx.cr[6].eq {
	pc = 0x8282D6A8; continue 'dispatch;
	}
	// 8282D668: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282D66C: 419A001C  beq cr6, 0x8282d688
	if ctx.cr[6].eq {
	pc = 0x8282D688; continue 'dispatch;
	}
	// 8282D670: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D674: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282D678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D67C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282D680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D684: 4E800421  bctrl
	ctx.lr = 0x8282D688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D688: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282D68C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282D690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282D694: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282D698: 816B0A70  lwz r11, 0xa70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2672 as u32) ) } as u64;
	// 8282D69C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282D6A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282D6A4: 4BA9295D  bl 0x822c0000
	ctx.lr = 0x8282D6A8;
	sub_822C0000(ctx, base);
	// 8282D6A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282D6AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282D6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D6B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282D6BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D6C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D6C8 size=148
    let mut pc: u32 = 0x8282D6C8;
    'dispatch: loop {
        match pc {
            0x8282D6C8 => {
    //   block [0x8282D6C8..0x8282D75C)
	// 8282D6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D6D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D6D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D6D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282D6DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282D6E0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282D6E4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8282D6E8: 396BB89C  addi r11, r11, -0x4764
	ctx.r[11].s64 = ctx.r[11].s64 + -18276;
	// 8282D6EC: 394AB888  addi r10, r10, -0x4778
	ctx.r[10].s64 = ctx.r[10].s64 + -18296;
	// 8282D6F0: 3929B83C  addi r9, r9, -0x47c4
	ctx.r[9].s64 = ctx.r[9].s64 + -18372;
	// 8282D6F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282D6F8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8282D6FC: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8282D700: 807F029C  lwz r3, 0x29c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 8282D704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282D708: 419A0008  beq cr6, 0x8282d710
	if ctx.cr[6].eq {
	pc = 0x8282D710; continue 'dispatch;
	}
	// 8282D70C: 4BA93185  bl 0x822c0890
	ctx.lr = 0x8282D710;
	sub_822C0890(ctx, base);
	// 8282D710: 807F0294  lwz r3, 0x294(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 8282D714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282D718: 419A0008  beq cr6, 0x8282d720
	if ctx.cr[6].eq {
	pc = 0x8282D720; continue 'dispatch;
	}
	// 8282D71C: 4BA93175  bl 0x822c0890
	ctx.lr = 0x8282D720;
	sub_822C0890(ctx, base);
	// 8282D720: 807F028C  lwz r3, 0x28c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 8282D724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282D728: 419A0008  beq cr6, 0x8282d730
	if ctx.cr[6].eq {
	pc = 0x8282D730; continue 'dispatch;
	}
	// 8282D72C: 4BA93165  bl 0x822c0890
	ctx.lr = 0x8282D730;
	sub_822C0890(ctx, base);
	// 8282D730: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 8282D734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282D738: 419A0008  beq cr6, 0x8282d740
	if ctx.cr[6].eq {
	pc = 0x8282D740; continue 'dispatch;
	}
	// 8282D73C: 4BA93155  bl 0x822c0890
	ctx.lr = 0x8282D740;
	sub_822C0890(ctx, base);
	// 8282D740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D744: 4BFEA735  bl 0x82817e78
	ctx.lr = 0x8282D748;
	sub_82817E78(ctx, base);
	// 8282D748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282D74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D760 size=8
    let mut pc: u32 = 0x8282D760;
    'dispatch: loop {
        match pc {
            0x8282D760 => {
    //   block [0x8282D760..0x8282D768)
	// 8282D760: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8282D764: 48000114  b 0x8282d878
	sub_8282D878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282D768 size=8
    let mut pc: u32 = 0x8282D768;
    'dispatch: loop {
        match pc {
            0x8282D768 => {
    //   block [0x8282D768..0x8282D770)
	// 8282D768: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 8282D76C: 4800010C  b 0x8282d878
	sub_8282D878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282D770 size=168
    let mut pc: u32 = 0x8282D770;
    'dispatch: loop {
        match pc {
            0x8282D770 => {
    //   block [0x8282D770..0x8282D818)
	// 8282D770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282D77C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D780: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D784: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282D788: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282D78C: 388BB91C  addi r4, r11, -0x46e4
	ctx.r[4].s64 = ctx.r[11].s64 + -18148;
	// 8282D790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282D794: 4BFEB515  bl 0x82818ca8
	ctx.lr = 0x8282D798;
	sub_82818CA8(ctx, base);
	// 8282D798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D79C: 481E5EE5  bl 0x82a13680
	ctx.lr = 0x8282D7A0;
	sub_82A13680(ctx, base);
	// 8282D7A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282D7A4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8282D7A8: 396B0AC0  addi r11, r11, 0xac0
	ctx.r[11].s64 = ctx.r[11].s64 + 2752;
	// 8282D7AC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8282D7B0: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 8282D7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D7B8: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8282D7BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8282D7C0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8282D7C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D818 size=92
    let mut pc: u32 = 0x8282D818;
    'dispatch: loop {
        match pc {
            0x8282D818 => {
    //   block [0x8282D818..0x8282D874)
	// 8282D818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D824: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282D82C: 4BFC0F65  bl 0x827ee790
	ctx.lr = 0x8282D830;
	sub_827EE790(ctx, base);
	// 8282D830: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D838: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8282D83C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D840: 4E800421  bctrl
	ctx.lr = 0x8282D844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D844: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8282D848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282D84C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282D850: 419A000C  beq cr6, 0x8282d85c
	if ctx.cr[6].eq {
	pc = 0x8282D85C; continue 'dispatch;
	}
	// 8282D854: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8282D858: 4BA93039  bl 0x822c0890
	ctx.lr = 0x8282D85C;
	sub_822C0890(ctx, base);
	// 8282D85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282D864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282D878 size=76
    let mut pc: u32 = 0x8282D878;
    'dispatch: loop {
        match pc {
            0x8282D878 => {
    //   block [0x8282D878..0x8282D8C4)
	// 8282D878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282D880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282D884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282D888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282D890: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282D894: 4BFFFE35  bl 0x8282d6c8
	ctx.lr = 0x8282D898;
	sub_8282D6C8(ctx, base);
	// 8282D898: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282D89C: 4182000C  beq 0x8282d8a8
	if ctx.cr[0].eq {
	pc = 0x8282D8A8; continue 'dispatch;
	}
	// 8282D8A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D8A4: 485C4B35  bl 0x82df23d8
	ctx.lr = 0x8282D8A8;
	sub_82DF23D8(ctx, base);
	// 8282D8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D8AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282D8B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282D8B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282D8B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282D8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282D8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282D8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282D8C8 size=404
    let mut pc: u32 = 0x8282D8C8;
    'dispatch: loop {
        match pc {
            0x8282D8C8 => {
    //   block [0x8282D8C8..0x8282DA5C)
	// 8282D8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282D8CC: 4897A8A1  bl 0x831a816c
	ctx.lr = 0x8282D8D0;
	sub_831A8130(ctx, base);
	// 8282D8D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282D8D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282D8D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282D8DC: 817F0270  lwz r11, 0x270(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 8282D8E0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8282D8E4: 409A0164  bne cr6, 0x8282da48
	if !ctx.cr[6].eq {
	pc = 0x8282DA48; continue 'dispatch;
	}
	// 8282D8E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D8EC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282D8F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D8F4: 4E800421  bctrl
	ctx.lr = 0x8282D8F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D8F8: 4BFBFF39  bl 0x827ed830
	ctx.lr = 0x8282D8FC;
	sub_827ED830(ctx, base);
	// 8282D8FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282D900: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8282D904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D908: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282D90C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282D910: 4E800421  bctrl
	ctx.lr = 0x8282D914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282D914: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282D918: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282D91C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8282D920: 4BFC10C9  bl 0x827ee9e8
	ctx.lr = 0x8282D924;
	sub_827EE9E8(ctx, base);
	// 8282D924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282D928: 481E5D59  bl 0x82a13680
	ctx.lr = 0x8282D92C;
	sub_82A13680(ctx, base);
	// 8282D92C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8282D930: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282DA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282DA60 size=276
    let mut pc: u32 = 0x8282DA60;
    'dispatch: loop {
        match pc {
            0x8282DA60 => {
    //   block [0x8282DA60..0x8282DB74)
	// 8282DA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282DA64: 4897A709  bl 0x831a816c
	ctx.lr = 0x8282DA68;
	sub_831A8130(ctx, base);
	// 8282DA68: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8282DA6C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282DA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282DA74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282DA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DA7C: 388BB510  addi r4, r11, -0x4af0
	ctx.r[4].s64 = ctx.r[11].s64 + -19184;
	// 8282DA80: 83DF0268  lwz r30, 0x268(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 8282DA84: C3FF0260  lfs f31, 0x260(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8282DA88: 485C5F81  bl 0x82df3a08
	ctx.lr = 0x8282DA8C;
	sub_82DF3A08(ctx, base);
	// 8282DA8C: 817F0254  lwz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 8282DA90: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282DA94: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8282DA98: 394AB758  addi r10, r10, -0x48a8
	ctx.r[10].s64 = ctx.r[10].s64 + -18600;
	// 8282DA9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8282DAA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8282DAA4: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8282DAA8: 485C5F61  bl 0x82df3a08
	ctx.lr = 0x8282DAAC;
	sub_82DF3A08(ctx, base);
	// 8282DAAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282DAB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282DAB4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282DAB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8282DABC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8282DAC0: 4BFF3369  bl 0x82820e28
	ctx.lr = 0x8282DAC4;
	sub_82820E28(ctx, base);
	// 8282DAC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8282DAC8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282DACC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8282DAD0: 388AB1A8  addi r4, r10, -0x4e58
	ctx.r[4].s64 = ctx.r[10].s64 + -20056;
	// 8282DAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8282DAD8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282DADC: 4803820D  bl 0x82865ce8
	ctx.lr = 0x8282DAE0;
	sub_82865CE8(ctx, base);
	// 8282DAE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DAE4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8282DAE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DAF0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8282DAF4: 419A0024  beq cr6, 0x8282db18
	if ctx.cr[6].eq {
	pc = 0x8282DB18; continue 'dispatch;
	}
	// 8282DAF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DAFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DB00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DB04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DB08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DB0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DB10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DB14: 4082FFE8  bne 0x8282dafc
	if !ctx.cr[0].eq {
	pc = 0x8282DAFC; continue 'dispatch;
	}
	// 8282DB18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DB1C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8282DB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DB24: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282DB28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282DB2C: 4E800421  bctrl
	ctx.lr = 0x8282DB30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282DB30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282DB34: 4BFC1B6D  bl 0x827ef6a0
	ctx.lr = 0x8282DB38;
	sub_827EF6A0(ctx, base);
	// 8282DB38: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8282DB3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DB40: 419A0008  beq cr6, 0x8282db48
	if ctx.cr[6].eq {
	pc = 0x8282DB48; continue 'dispatch;
	}
	// 8282DB44: 4BA92D4D  bl 0x822c0890
	ctx.lr = 0x8282DB48;
	sub_822C0890(ctx, base);
	// 8282DB48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8282DB4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DB50: 419A0008  beq cr6, 0x8282db58
	if ctx.cr[6].eq {
	pc = 0x8282DB58; continue 'dispatch;
	}
	// 8282DB54: 4BA92D3D  bl 0x822c0890
	ctx.lr = 0x8282DB58;
	sub_822C0890(ctx, base);
	// 8282DB58: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 8282DB5C: 485C58CD  bl 0x82df3428
	ctx.lr = 0x8282DB60;
	sub_82DF3428(ctx, base);
	// 8282DB60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282DB64: 485C58C5  bl 0x82df3428
	ctx.lr = 0x8282DB68;
	sub_82DF3428(ctx, base);
	// 8282DB68: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8282DB6C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8282DB70: 4897A64C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282DB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282DB78 size=644
    let mut pc: u32 = 0x8282DB78;
    'dispatch: loop {
        match pc {
            0x8282DB78 => {
    //   block [0x8282DB78..0x8282DDFC)
	// 8282DB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282DB7C: 4897A5F1  bl 0x831a816c
	ctx.lr = 0x8282DB80;
	sub_831A8130(ctx, base);
	// 8282DB80: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282DB84: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8282DB88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282DB8C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8282DB90: 409A0264  bne cr6, 0x8282ddf4
	if !ctx.cr[6].eq {
	pc = 0x8282DDF4; continue 'dispatch;
	}
	// 8282DB94: 817F0270  lwz r11, 0x270(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 8282DB98: 3BDF0270  addi r30, r31, 0x270
	ctx.r[30].s64 = ctx.r[31].s64 + 624;
	// 8282DB9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DBA0: 409A0128  bne cr6, 0x8282dcc8
	if !ctx.cr[6].eq {
	pc = 0x8282DCC8; continue 'dispatch;
	}
	// 8282DBA4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8282DBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DBAC: 388BF9A0  addi r4, r11, -0x660
	ctx.r[4].s64 = ctx.r[11].s64 + -1632;
	// 8282DBB0: 485C5E59  bl 0x82df3a08
	ctx.lr = 0x8282DBB4;
	sub_82DF3A08(ctx, base);
	// 8282DBB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282DBB8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8282DBBC: 48035B05  bl 0x828636c0
	ctx.lr = 0x8282DBC0;
	sub_828636C0(ctx, base);
	// 8282DBC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DBC4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8282DBC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DBCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DBD0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8282DBD4: 419A0024  beq cr6, 0x8282dbf8
	if ctx.cr[6].eq {
	pc = 0x8282DBF8; continue 'dispatch;
	}
	// 8282DBD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DBDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DBE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DBE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DBE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DBEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DBF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DBF4: 4082FFE8  bne 0x8282dbdc
	if !ctx.cr[0].eq {
	pc = 0x8282DBDC; continue 'dispatch;
	}
	// 8282DBF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DBFC: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 8282DC00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DC04: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282DC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282DC0C: 4E800421  bctrl
	ctx.lr = 0x8282DC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282DC10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8282DC14: 4BFC1A8D  bl 0x827ef6a0
	ctx.lr = 0x8282DC18;
	sub_827EF6A0(ctx, base);
	// 8282DC18: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8282DC1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DC20: 419A0008  beq cr6, 0x8282dc28
	if ctx.cr[6].eq {
	pc = 0x8282DC28; continue 'dispatch;
	}
	// 8282DC24: 4BA92C6D  bl 0x822c0890
	ctx.lr = 0x8282DC28;
	sub_822C0890(ctx, base);
	// 8282DC28: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8282DC2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DC30: 419A0008  beq cr6, 0x8282dc38
	if ctx.cr[6].eq {
	pc = 0x8282DC38; continue 'dispatch;
	}
	// 8282DC34: 4BA92C5D  bl 0x822c0890
	ctx.lr = 0x8282DC38;
	sub_822C0890(ctx, base);
	// 8282DC38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DC3C: 485C57ED  bl 0x82df3428
	ctx.lr = 0x8282DC40;
	sub_82DF3428(ctx, base);
	// 8282DC40: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8282DC44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282DC48: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8282DC4C: 48035EC5  bl 0x82863b10
	ctx.lr = 0x8282DC50;
	sub_82863B10(ctx, base);
	// 8282DC50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DC54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8282DC58: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DC5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DC60: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8282DC64: 419A0024  beq cr6, 0x8282dc88
	if ctx.cr[6].eq {
	pc = 0x8282DC88; continue 'dispatch;
	}
	// 8282DC68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DC6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DC70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DC74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DC78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DC7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DC80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DC84: 4082FFE8  bne 0x8282dc6c
	if !ctx.cr[0].eq {
	pc = 0x8282DC6C; continue 'dispatch;
	}
	// 8282DC88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DC8C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8282DC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DC94: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282DC98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282DC9C: 4E800421  bctrl
	ctx.lr = 0x8282DCA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282DCA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8282DCA4: 4BFC19FD  bl 0x827ef6a0
	ctx.lr = 0x8282DCA8;
	sub_827EF6A0(ctx, base);
	// 8282DCA8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8282DCAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DCB0: 419A0008  beq cr6, 0x8282dcb8
	if ctx.cr[6].eq {
	pc = 0x8282DCB8; continue 'dispatch;
	}
	// 8282DCB4: 4BA92BDD  bl 0x822c0890
	ctx.lr = 0x8282DCB8;
	sub_822C0890(ctx, base);
	// 8282DCB8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8282DCBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DCC0: 419A0008  beq cr6, 0x8282dcc8
	if ctx.cr[6].eq {
	pc = 0x8282DCC8; continue 'dispatch;
	}
	// 8282DCC4: 4BA92BCD  bl 0x822c0890
	ctx.lr = 0x8282DCC8;
	sub_822C0890(ctx, base);
	// 8282DCC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DCCC: 4BFFFD95  bl 0x8282da60
	ctx.lr = 0x8282DCD0;
	sub_8282DA60(ctx, base);
	// 8282DCD0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282DCD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DCD8: 388BB774  addi r4, r11, -0x488c
	ctx.r[4].s64 = ctx.r[11].s64 + -18572;
	// 8282DCDC: 485C5D2D  bl 0x82df3a08
	ctx.lr = 0x8282DCE0;
	sub_82DF3A08(ctx, base);
	// 8282DCE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282DCE4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8282DCE8: 480359D9  bl 0x828636c0
	ctx.lr = 0x8282DCEC;
	sub_828636C0(ctx, base);
	// 8282DCEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DCF0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8282DCF4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DCF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DCFC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8282DD00: 419A0024  beq cr6, 0x8282dd24
	if ctx.cr[6].eq {
	pc = 0x8282DD24; continue 'dispatch;
	}
	// 8282DD04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DD08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DD0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DD10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DD14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DD18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DD1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DD20: 4082FFE8  bne 0x8282dd08
	if !ctx.cr[0].eq {
	pc = 0x8282DD08; continue 'dispatch;
	}
	// 8282DD24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DD28: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 8282DD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DD30: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282DD34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282DD38: 4E800421  bctrl
	ctx.lr = 0x8282DD3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282DD3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8282DD40: 4BFC1961  bl 0x827ef6a0
	ctx.lr = 0x8282DD44;
	sub_827EF6A0(ctx, base);
	// 8282DD44: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8282DD48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DD4C: 419A0008  beq cr6, 0x8282dd54
	if ctx.cr[6].eq {
	pc = 0x8282DD54; continue 'dispatch;
	}
	// 8282DD50: 4BA92B41  bl 0x822c0890
	ctx.lr = 0x8282DD54;
	sub_822C0890(ctx, base);
	// 8282DD54: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8282DD58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DD5C: 419A0008  beq cr6, 0x8282dd64
	if ctx.cr[6].eq {
	pc = 0x8282DD64; continue 'dispatch;
	}
	// 8282DD60: 4BA92B31  bl 0x822c0890
	ctx.lr = 0x8282DD64;
	sub_822C0890(ctx, base);
	// 8282DD64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DD68: 485C56C1  bl 0x82df3428
	ctx.lr = 0x8282DD6C;
	sub_82DF3428(ctx, base);
	// 8282DD6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8282DD70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282DD74: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8282DD78: 48035D99  bl 0x82863b10
	ctx.lr = 0x8282DD7C;
	sub_82863B10(ctx, base);
	// 8282DD7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DD80: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8282DD84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DD8C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8282DD90: 419A0024  beq cr6, 0x8282ddb4
	if ctx.cr[6].eq {
	pc = 0x8282DDB4; continue 'dispatch;
	}
	// 8282DD94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DD98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DD9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DDA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DDA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DDA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DDAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DDB0: 4082FFE8  bne 0x8282dd98
	if !ctx.cr[0].eq {
	pc = 0x8282DD98; continue 'dispatch;
	}
	// 8282DDB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DDB8: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 8282DDBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DDC0: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282DDC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282DDC8: 4E800421  bctrl
	ctx.lr = 0x8282DDCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282DDCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282DDD0: 4BFC18D1  bl 0x827ef6a0
	ctx.lr = 0x8282DDD4;
	sub_827EF6A0(ctx, base);
	// 8282DDD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8282DDD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DDDC: 419A0008  beq cr6, 0x8282dde4
	if ctx.cr[6].eq {
	pc = 0x8282DDE4; continue 'dispatch;
	}
	// 8282DDE0: 4BA92AB1  bl 0x822c0890
	ctx.lr = 0x8282DDE4;
	sub_822C0890(ctx, base);
	// 8282DDE4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8282DDE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DDEC: 419A0008  beq cr6, 0x8282ddf4
	if ctx.cr[6].eq {
	pc = 0x8282DDF4; continue 'dispatch;
	}
	// 8282DDF0: 4BA92AA1  bl 0x822c0890
	ctx.lr = 0x8282DDF4;
	sub_822C0890(ctx, base);
	// 8282DDF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8282DDF8: 4897A3C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282DE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282DE00 size=332
    let mut pc: u32 = 0x8282DE00;
    'dispatch: loop {
        match pc {
            0x8282DE00 => {
    //   block [0x8282DE00..0x8282DF4C)
	// 8282DE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282DE04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282DE08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282DE0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282DE10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282DE14: 817F0270  lwz r11, 0x270(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 8282DE18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DE1C: 409A0084  bne cr6, 0x8282dea0
	if !ctx.cr[6].eq {
	pc = 0x8282DEA0; continue 'dispatch;
	}
	// 8282DE20: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 8282DE24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DE28: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 8282DE2C: 485C5BDD  bl 0x82df3a08
	ctx.lr = 0x8282DE30;
	sub_82DF3A08(ctx, base);
	// 8282DE30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282DE34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282DE38: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8282DE3C: C02B9584  lfs f1, -0x6a7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282DE40: 480358F9  bl 0x82863738
	ctx.lr = 0x8282DE44;
	sub_82863738(ctx, base);
	// 8282DE44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DE48: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8282DE4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DE50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DE54: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8282DE58: 419A0024  beq cr6, 0x8282de7c
	if ctx.cr[6].eq {
	pc = 0x8282DE7C; continue 'dispatch;
	}
	// 8282DE5C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DE60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DE64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DE68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DE6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DE70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DE74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DE78: 4082FFE8  bne 0x8282de60
	if !ctx.cr[0].eq {
	pc = 0x8282DE60; continue 'dispatch;
	}
	// 8282DE7C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8282DE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DE84: 4BFBEED5  bl 0x827ecd58
	ctx.lr = 0x8282DE88;
	sub_827ECD58(ctx, base);
	// 8282DE88: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8282DE8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DE90: 419A0008  beq cr6, 0x8282de98
	if ctx.cr[6].eq {
	pc = 0x8282DE98; continue 'dispatch;
	}
	// 8282DE94: 4BA929FD  bl 0x822c0890
	ctx.lr = 0x8282DE98;
	sub_822C0890(ctx, base);
	// 8282DE98: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8282DE9C: 48000088  b 0x8282df24
	pc = 0x8282DF24; continue 'dispatch;
	// 8282DEA0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8282DEA4: 409A0094  bne cr6, 0x8282df38
	if !ctx.cr[6].eq {
	pc = 0x8282DF38; continue 'dispatch;
	}
	// 8282DEA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282DEAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DEB0: 388BB76C  addi r4, r11, -0x4894
	ctx.r[4].s64 = ctx.r[11].s64 + -18580;
	// 8282DEB4: 485C5B55  bl 0x82df3a08
	ctx.lr = 0x8282DEB8;
	sub_82DF3A08(ctx, base);
	// 8282DEB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282DEBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282DEC0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282DEC4: C02B9584  lfs f1, -0x6a7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282DEC8: 48035871  bl 0x82863738
	ctx.lr = 0x8282DECC;
	sub_82863738(ctx, base);
	// 8282DECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DED0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8282DED4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282DED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282DEDC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8282DEE0: 419A0024  beq cr6, 0x8282df04
	if ctx.cr[6].eq {
	pc = 0x8282DF04; continue 'dispatch;
	}
	// 8282DEE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282DEE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282DEEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DEF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282DEF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282DEF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282DEFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282DF00: 4082FFE8  bne 0x8282dee8
	if !ctx.cr[0].eq {
	pc = 0x8282DEE8; continue 'dispatch;
	}
	// 8282DF04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8282DF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DF0C: 4BFBEE4D  bl 0x827ecd58
	ctx.lr = 0x8282DF10;
	sub_827ECD58(ctx, base);
	// 8282DF10: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8282DF14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DF18: 419A0008  beq cr6, 0x8282df20
	if ctx.cr[6].eq {
	pc = 0x8282DF20; continue 'dispatch;
	}
	// 8282DF1C: 4BA92975  bl 0x822c0890
	ctx.lr = 0x8282DF20;
	sub_822C0890(ctx, base);
	// 8282DF20: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8282DF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DF28: 419A0008  beq cr6, 0x8282df30
	if ctx.cr[6].eq {
	pc = 0x8282DF30; continue 'dispatch;
	}
	// 8282DF2C: 4BA92965  bl 0x822c0890
	ctx.lr = 0x8282DF30;
	sub_822C0890(ctx, base);
	// 8282DF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DF34: 485C54F5  bl 0x82df3428
	ctx.lr = 0x8282DF38;
	sub_82DF3428(ctx, base);
	// 8282DF38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8282DF3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282DF40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282DF44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282DF48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282DF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282DF50 size=228
    let mut pc: u32 = 0x8282DF50;
    'dispatch: loop {
        match pc {
            0x8282DF50 => {
    //   block [0x8282DF50..0x8282E034)
	// 8282DF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282DF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282DF58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282DF5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282DF60: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8282DF64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282DF68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282DF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DF70: 4BFBF8C1  bl 0x827ed830
	ctx.lr = 0x8282DF74;
	sub_827ED830(ctx, base);
	// 8282DF74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282DF78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282DF7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8282DF80: 4BFC0B29  bl 0x827eeaa8
	ctx.lr = 0x8282DF84;
	sub_827EEAA8(ctx, base);
	// 8282DF84: C0410068  lfs f2, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8282DF88: C0210060  lfs f1, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282DF8C: 4897D02D  bl 0x831aafb8
	ctx.lr = 0x8282DF90;
	sub_831AAFB8(ctx, base);
	// 8282DF90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282DF94: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8282DF98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DF9C: 388BB76C  addi r4, r11, -0x4894
	ctx.r[4].s64 = ctx.r[11].s64 + -18580;
	// 8282DFA0: 485C5A69  bl 0x82df3a08
	ctx.lr = 0x8282DFA4;
	sub_82DF3A08(ctx, base);
	// 8282DFA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282DFA8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8282DFAC: 4BFC17D5  bl 0x827ef780
	ctx.lr = 0x8282DFB0;
	sub_827EF780(ctx, base);
	// 8282DFB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282DFB4: 4BFBC52D  bl 0x827ea4e0
	ctx.lr = 0x8282DFB8;
	sub_827EA4E0(ctx, base);
	// 8282DFB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282DFBC: 485C546D  bl 0x82df3428
	ctx.lr = 0x8282DFC0;
	sub_82DF3428(ctx, base);
	// 8282DFC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282DFC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8282DFC8: 4BFC07C9  bl 0x827ee790
	ctx.lr = 0x8282DFCC;
	sub_827EE790(ctx, base);
	// 8282DFCC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DFD0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282DFD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282DFD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8282DFDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282DFE0: 4E800421  bctrl
	ctx.lr = 0x8282DFE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282DFE4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8282DFE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282DFEC: 419A0008  beq cr6, 0x8282dff4
	if ctx.cr[6].eq {
	pc = 0x8282DFF4; continue 'dispatch;
	}
	// 8282DFF0: 4BA928A1  bl 0x822c0890
	ctx.lr = 0x8282DFF4;
	sub_822C0890(ctx, base);
	// 8282DFF4: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 8282DFF8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282DFFC: C00BB934  lfs f0, -0x46cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282E000: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8282E004: 40990014  ble cr6, 0x8282e018
	if !ctx.cr[6].gt {
	pc = 0x8282E018; continue 'dispatch;
	}
	// 8282E008: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282E010: 388BB194  addi r4, r11, -0x4e6c
	ctx.r[4].s64 = ctx.r[11].s64 + -20076;
	// 8282E014: 4BFEC3D5  bl 0x8281a3e8
	ctx.lr = 0x8282E018;
	sub_8281A3E8(ctx, base);
	// 8282E018: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8282E01C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282E020: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282E024: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8282E028: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282E02C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282E030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282E038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282E038 size=1424
    let mut pc: u32 = 0x8282E038;
    'dispatch: loop {
        match pc {
            0x8282E038 => {
    //   block [0x8282E038..0x8282E5C8)
	// 8282E038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282E03C: 4897A121  bl 0x831a815c
	ctx.lr = 0x8282E040;
	sub_831A8130(ctx, base);
	// 8282E040: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282E044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282E048: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282E04C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8282E050: 4BFEC1E9  bl 0x8281a238
	ctx.lr = 0x8282E054;
	sub_8281A238(ctx, base);
	// 8282E054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282E058: 4BFBD5E1  bl 0x827eb638
	ctx.lr = 0x8282E05C;
	sub_827EB638(ctx, base);
	// 8282E05C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282E060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282E064: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 8282E068: 409A0008  bne cr6, 0x8282e070
	if !ctx.cr[6].eq {
	pc = 0x8282E070; continue 'dispatch;
	}
	// 8282E06C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8282E070: 4BCF9FD1  bl 0x82528040
	ctx.lr = 0x8282E074;
	sub_82528040(ctx, base);
	// 8282E074: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8282E078: 418200A0  beq 0x8282e118
	if ctx.cr[0].eq {
	pc = 0x8282E118; continue 'dispatch;
	}
	// 8282E07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282E080: 481E5601  bl 0x82a13680
	ctx.lr = 0x8282E084;
	sub_82A13680(ctx, base);
	// 8282E084: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282E088: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8282E08C: 396B0AA0  addi r11, r11, 0xaa0
	ctx.r[11].s64 = ctx.r[11].s64 + 2720;
	// 8282E090: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 8282E094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282E098: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8282E09C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282E5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282E5C8 size=884
    let mut pc: u32 = 0x8282E5C8;
    'dispatch: loop {
        match pc {
            0x8282E5C8 => {
    //   block [0x8282E5C8..0x8282E93C)
	// 8282E5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282E5CC: 48979B91  bl 0x831a815c
	ctx.lr = 0x8282E5D0;
	sub_831A8130(ctx, base);
	// 8282E5D0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8282E5D4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8282E5D8: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282E5DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8282E5E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E5E4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8282E5E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8282E5EC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8282E5F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8282E5F4: 388BB940  addi r4, r11, -0x46c0
	ctx.r[4].s64 = ctx.r[11].s64 + -18112;
	// 8282E5F8: 38A0015B  li r5, 0x15b
	ctx.r[5].s64 = 347;
	// 8282E5FC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8282E600: 4BA91DD9  bl 0x822c03d8
	ctx.lr = 0x8282E604;
	sub_822C03D8(ctx, base);
	// 8282E604: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E608: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8282E60C: 3B4BA0D0  addi r26, r11, -0x5f30
	ctx.r[26].s64 = ctx.r[11].s64 + -24368;
	// 8282E610: 41820030  beq 0x8282e640
	if ctx.cr[0].eq {
	pc = 0x8282E640; continue 'dispatch;
	}
	// 8282E614: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8282E618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E61C: 485C53ED  bl 0x82df3a08
	ctx.lr = 0x8282E620;
	sub_82DF3A08(ctx, base);
	// 8282E620: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8282E624: 38BB004C  addi r5, r27, 0x4c
	ctx.r[5].s64 = ctx.r[27].s64 + 76;
	// 8282E628: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282E630: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8282E634: 4BD7DDDD  bl 0x825ac410
	ctx.lr = 0x8282E638;
	sub_825AC410(ctx, base);
	// 8282E638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282E63C: 48000008  b 0x8282e644
	pc = 0x8282E644; continue 'dispatch;
	// 8282E640: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8282E644: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8282E648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282E64C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8282E650: 4BCC4D69  bl 0x824f33b8
	ctx.lr = 0x8282E654;
	sub_824F33B8(ctx, base);
	// 8282E654: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8282E658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282E65C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8282E660: 4BA919A1  bl 0x822c0000
	ctx.lr = 0x8282E664;
	sub_822C0000(ctx, base);
	// 8282E664: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282E668: 4182000C  beq 0x8282e674
	if ctx.cr[0].eq {
	pc = 0x8282E674; continue 'dispatch;
	}
	// 8282E66C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E670: 485C4DB9  bl 0x82df3428
	ctx.lr = 0x8282E674;
	sub_82DF3428(ctx, base);
	// 8282E674: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E678: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8282E67C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8282E680: 3BABB758  addi r29, r11, -0x48a8
	ctx.r[29].s64 = ctx.r[11].s64 + -18600;
	// 8282E684: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8282E688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E68C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282E690: 485C5379  bl 0x82df3a08
	ctx.lr = 0x8282E694;
	sub_82DF3A08(ctx, base);
	// 8282E694: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8282E698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282E69C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8282E6A0: 4BD7D721  bl 0x825abdc0
	ctx.lr = 0x8282E6A4;
	sub_825ABDC0(ctx, base);
	// 8282E6A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E6A8: 485C4D81  bl 0x82df3428
	ctx.lr = 0x8282E6AC;
	sub_82DF3428(ctx, base);
	// 8282E6AC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8282E6B0: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 8282E6B4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8282E6B8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8282E6BC: 4198FFCC  blt cr6, 0x8282e688
	if ctx.cr[6].lt {
	pc = 0x8282E688; continue 'dispatch;
	}
	// 8282E6C0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8282E6C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E6C8: 485C5341  bl 0x82df3a08
	ctx.lr = 0x8282E6CC;
	sub_82DF3A08(ctx, base);
	// 8282E6CC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8282E6D0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 8282E6D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282E6D8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8282E6DC: 419A0024  beq cr6, 0x8282e700
	if ctx.cr[6].eq {
	pc = 0x8282E700; continue 'dispatch;
	}
	// 8282E6E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8282E6E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282E6E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282E6EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282E6F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282E6F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282E6F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282E6FC: 4082FFE8  bne 0x8282e6e4
	if !ctx.cr[0].eq {
	pc = 0x8282E6E4; continue 'dispatch;
	}
	// 8282E700: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8282E704: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E708: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E70C: 4BD73A05  bl 0x825a2110
	ctx.lr = 0x8282E710;
	sub_825A2110(ctx, base);
	// 8282E710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E714: 485C4D15  bl 0x82df3428
	ctx.lr = 0x8282E718;
	sub_82DF3428(ctx, base);
	// 8282E718: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282E71C: 419A000C  beq cr6, 0x8282e728
	if ctx.cr[6].eq {
	pc = 0x8282E728; continue 'dispatch;
	}
	// 8282E720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282E724: 4BA9216D  bl 0x822c0890
	ctx.lr = 0x8282E728;
	sub_822C0890(ctx, base);
	// 8282E728: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E72C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E730: 388BB9E8  addi r4, r11, -0x4618
	ctx.r[4].s64 = ctx.r[11].s64 + -17944;
	// 8282E734: 485C52D5  bl 0x82df3a08
	ctx.lr = 0x8282E738;
	sub_82DF3A08(ctx, base);
	// 8282E738: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282E73C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8282E740: 389B0050  addi r4, r27, 0x50
	ctx.r[4].s64 = ctx.r[27].s64 + 80;
	// 8282E744: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8282E748: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8282E74C: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8282E750: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8282E754: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8282E758: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282E75C: 4BD74A55  bl 0x825a31b0
	ctx.lr = 0x8282E760;
	sub_825A31B0(ctx, base);
	// 8282E760: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282E764: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E768: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E76C: 4BD73005  bl 0x825a1770
	ctx.lr = 0x8282E770;
	sub_825A1770(ctx, base);
	// 8282E770: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 8282E774: 485C4CB5  bl 0x82df3428
	ctx.lr = 0x8282E778;
	sub_82DF3428(ctx, base);
	// 8282E778: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 8282E77C: 4BA9A53D  bl 0x822c8cb8
	ctx.lr = 0x8282E780;
	sub_822C8CB8(ctx, base);
	// 8282E780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E784: 485C4CA5  bl 0x82df3428
	ctx.lr = 0x8282E788;
	sub_82DF3428(ctx, base);
	// 8282E788: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E78C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E790: 388BB9D8  addi r4, r11, -0x4628
	ctx.r[4].s64 = ctx.r[11].s64 + -17960;
	// 8282E794: 485C5275  bl 0x82df3a08
	ctx.lr = 0x8282E798;
	sub_82DF3A08(ctx, base);
	// 8282E798: 389B0054  addi r4, r27, 0x54
	ctx.r[4].s64 = ctx.r[27].s64 + 84;
	// 8282E79C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282E7A0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8282E7A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282E7A8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8282E7AC: 4BD74A05  bl 0x825a31b0
	ctx.lr = 0x8282E7B0;
	sub_825A31B0(ctx, base);
	// 8282E7B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282E7B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E7B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E7BC: 4BD72FB5  bl 0x825a1770
	ctx.lr = 0x8282E7C0;
	sub_825A1770(ctx, base);
	// 8282E7C0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8282E7C4: 485C4C65  bl 0x82df3428
	ctx.lr = 0x8282E7C8;
	sub_82DF3428(ctx, base);
	// 8282E7C8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8282E7CC: 4BA9A4ED  bl 0x822c8cb8
	ctx.lr = 0x8282E7D0;
	sub_822C8CB8(ctx, base);
	// 8282E7D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E7D4: 485C4C55  bl 0x82df3428
	ctx.lr = 0x8282E7D8;
	sub_82DF3428(ctx, base);
	// 8282E7D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E7DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E7E0: 388BB9C8  addi r4, r11, -0x4638
	ctx.r[4].s64 = ctx.r[11].s64 + -17976;
	// 8282E7E4: 485C5225  bl 0x82df3a08
	ctx.lr = 0x8282E7E8;
	sub_82DF3A08(ctx, base);
	// 8282E7E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8282E7EC: 389B0058  addi r4, r27, 0x58
	ctx.r[4].s64 = ctx.r[27].s64 + 88;
	// 8282E7F0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8282E7F4: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 8282E7F8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282E7FC: C3CB6218  lfs f30, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8282E800: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8282E804: 4BD749AD  bl 0x825a31b0
	ctx.lr = 0x8282E808;
	sub_825A31B0(ctx, base);
	// 8282E808: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282E80C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E810: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E814: 4BD72F5D  bl 0x825a1770
	ctx.lr = 0x8282E818;
	sub_825A1770(ctx, base);
	// 8282E818: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 8282E81C: 485C4C0D  bl 0x82df3428
	ctx.lr = 0x8282E820;
	sub_82DF3428(ctx, base);
	// 8282E820: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 8282E824: 4BA9A495  bl 0x822c8cb8
	ctx.lr = 0x8282E828;
	sub_822C8CB8(ctx, base);
	// 8282E828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E82C: 485C4BFD  bl 0x82df3428
	ctx.lr = 0x8282E830;
	sub_82DF3428(ctx, base);
	// 8282E830: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E838: 388BB9B8  addi r4, r11, -0x4648
	ctx.r[4].s64 = ctx.r[11].s64 + -17992;
	// 8282E83C: 485C51CD  bl 0x82df3a08
	ctx.lr = 0x8282E840;
	sub_82DF3A08(ctx, base);
	// 8282E840: 389B005C  addi r4, r27, 0x5c
	ctx.r[4].s64 = ctx.r[27].s64 + 92;
	// 8282E844: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8282E848: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8282E84C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8282E850: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282E854: 4BD7495D  bl 0x825a31b0
	ctx.lr = 0x8282E858;
	sub_825A31B0(ctx, base);
	// 8282E858: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282E85C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E860: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E864: 4BD72F0D  bl 0x825a1770
	ctx.lr = 0x8282E868;
	sub_825A1770(ctx, base);
	// 8282E868: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 8282E86C: 485C4BBD  bl 0x82df3428
	ctx.lr = 0x8282E870;
	sub_82DF3428(ctx, base);
	// 8282E870: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8282E874: 4BA9A445  bl 0x822c8cb8
	ctx.lr = 0x8282E878;
	sub_822C8CB8(ctx, base);
	// 8282E878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E87C: 485C4BAD  bl 0x82df3428
	ctx.lr = 0x8282E880;
	sub_82DF3428(ctx, base);
	// 8282E880: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E888: 388BB68C  addi r4, r11, -0x4974
	ctx.r[4].s64 = ctx.r[11].s64 + -18804;
	// 8282E88C: 485C517D  bl 0x82df3a08
	ctx.lr = 0x8282E890;
	sub_82DF3A08(ctx, base);
	// 8282E890: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8282E894: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 8282E898: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8282E89C: 389B0060  addi r4, r27, 0x60
	ctx.r[4].s64 = ctx.r[27].s64 + 96;
	// 8282E8A0: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 8282E8A4: 4BD74B05  bl 0x825a33a8
	ctx.lr = 0x8282E8A8;
	sub_825A33A8(ctx, base);
	// 8282E8A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282E8AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E8B0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E8B4: 4BD733AD  bl 0x825a1c60
	ctx.lr = 0x8282E8B8;
	sub_825A1C60(ctx, base);
	// 8282E8B8: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 8282E8BC: 485C4B6D  bl 0x82df3428
	ctx.lr = 0x8282E8C0;
	sub_82DF3428(ctx, base);
	// 8282E8C0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 8282E8C4: 4BA9A3F5  bl 0x822c8cb8
	ctx.lr = 0x8282E8C8;
	sub_822C8CB8(ctx, base);
	// 8282E8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E8CC: 485C4B5D  bl 0x82df3428
	ctx.lr = 0x8282E8D0;
	sub_82DF3428(ctx, base);
	// 8282E8D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282E8D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E8D8: 388BB9A4  addi r4, r11, -0x465c
	ctx.r[4].s64 = ctx.r[11].s64 + -18012;
	// 8282E8DC: 485C512D  bl 0x82df3a08
	ctx.lr = 0x8282E8E0;
	sub_82DF3A08(ctx, base);
	// 8282E8E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8282E8E4: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 8282E8E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8282E8EC: 389B0064  addi r4, r27, 0x64
	ctx.r[4].s64 = ctx.r[27].s64 + 100;
	// 8282E8F0: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 8282E8F4: 4BD74AB5  bl 0x825a33a8
	ctx.lr = 0x8282E8F8;
	sub_825A33A8(ctx, base);
	// 8282E8F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282E8FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282E900: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8282E904: 4BD7335D  bl 0x825a1c60
	ctx.lr = 0x8282E908;
	sub_825A1C60(ctx, base);
	// 8282E908: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 8282E90C: 485C4B1D  bl 0x82df3428
	ctx.lr = 0x8282E910;
	sub_82DF3428(ctx, base);
	// 8282E910: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 8282E914: 4BA9A3A5  bl 0x822c8cb8
	ctx.lr = 0x8282E918;
	sub_822C8CB8(ctx, base);
	// 8282E918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282E91C: 485C4B0D  bl 0x82df3428
	ctx.lr = 0x8282E920;
	sub_82DF3428(ctx, base);
	// 8282E920: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8282E924: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8282E928: 4BFEA041  bl 0x82818968
	ctx.lr = 0x8282E92C;
	sub_82818968(ctx, base);
	// 8282E92C: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 8282E930: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8282E934: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8282E938: 48979874  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282E940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282E940 size=1480
    let mut pc: u32 = 0x8282E940;
    'dispatch: loop {
        match pc {
            0x8282E940 => {
    //   block [0x8282E940..0x8282EF08)
	// 8282E940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282E944: 48979821  bl 0x831a8164
	ctx.lr = 0x8282E948;
	sub_831A8130(ctx, base);
	// 8282E948: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8282E94C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282E950: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282E954: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282E958: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282E95C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282E960: 4E800421  bctrl
	ctx.lr = 0x8282E964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282E964: 4BFBEECD  bl 0x827ed830
	ctx.lr = 0x8282E968;
	sub_827ED830(ctx, base);
	// 8282E968: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282E96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282E970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282E974: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282E978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282E97C: 4E800421  bctrl
	ctx.lr = 0x8282E980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282E980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282E984: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8282E988: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8282E98C: 4BFC005D  bl 0x827ee9e8
	ctx.lr = 0x8282E990;
	sub_827EE9E8(ctx, base);
	// 8282E990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282E994: 481E4CED  bl 0x82a13680
	ctx.lr = 0x8282E998;
	sub_82A13680(ctx, base);
	// 8282E998: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 8282E99C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282EF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282EF08 size=244
    let mut pc: u32 = 0x8282EF08;
    'dispatch: loop {
        match pc {
            0x8282EF08 => {
    //   block [0x8282EF08..0x8282EFFC)
	// 8282EF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282EF0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282EF10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282EF14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282EF18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282EF1C: 4BFE90CD  bl 0x82817fe8
	ctx.lr = 0x8282EF20;
	sub_82817FE8(ctx, base);
	// 8282EF20: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282EF24: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8282EF28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282EF2C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8282EF30: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 8282EF34: C1AA89AC  lfs f13, -0x7654(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282EF38: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 8282EF3C: 3CA08208  lis r5, -0x7df8
	ctx.r[5].s64 = -2113404928;
	// 8282EF40: C1899450  lfs f12, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8282EF44: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282EF48: C00BD72C  lfs f0, -0x28d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282EF4C: C16808A8  lfs f11, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8282EF50: 3926B89C  addi r9, r6, -0x4764
	ctx.r[9].s64 = ctx.r[6].s64 + -18276;
	// 8282EF54: C14708A4  lfs f10, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8282EF58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282EF5C: 3905B888  addi r8, r5, -0x4778
	ctx.r[8].s64 = ctx.r[5].s64 + -18296;
	// 8282EF60: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282EF64: 394AB83C  addi r10, r10, -0x47c4
	ctx.r[10].s64 = ctx.r[10].s64 + -18372;
	// 8282EF68: D01F0258  stfs f0, 0x258(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), tmp.u32 ) };
	// 8282EF6C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8282EF70: D1BF025C  stfs f13, 0x25c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), tmp.u32 ) };
	// 8282EF74: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8282EF78: D19F0260  stfs f12, 0x260(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), tmp.u32 ) };
	// 8282EF7C: D17F0264  stfs f11, 0x264(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), tmp.u32 ) };
	// 8282EF80: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 8282EF84: D15F027C  stfs f10, 0x27c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), tmp.u32 ) };
	// 8282EF88: 915F0208  stw r10, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[10].u32 ) };
	// 8282EF8C: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 8282EF90: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 8282EF94: 90FF0268  stw r7, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[7].u32 ) };
	// 8282EF98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282EF9C: 90DF026C  stw r6, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[6].u32 ) };
	// 8282EFA0: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 8282EFA4: 917F0278  stw r11, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 8282EFA8: 917F0280  stw r11, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[11].u32 ) };
	// 8282EFAC: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 8282EFB0: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 8282EFB4: 917F028C  stw r11, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[11].u32 ) };
	// 8282EFB8: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 8282EFBC: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 8282EFC0: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 8282EFC4: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 8282EFC8: 80898644  lwz r4, -0x79bc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31164 as u32) ) } as u64;
	// 8282EFCC: 4BAFD75D  bl 0x8232c728
	ctx.lr = 0x8282EFD0;
	sub_8232C728(ctx, base);
	// 8282EFD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282EFD4: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8282EFD8: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8282EFDC: 4BF8B395  bl 0x827ba370
	ctx.lr = 0x8282EFE0;
	sub_827BA370(ctx, base);
	// 8282EFE0: 907F0274  stw r3, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[3].u32 ) };
	// 8282EFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282EFE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282EFEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282EFF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282EFF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282EFF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F000 size=444
    let mut pc: u32 = 0x8282F000;
    'dispatch: loop {
        match pc {
            0x8282F000 => {
    //   block [0x8282F000..0x8282F1BC)
	// 8282F000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F004: 48979165  bl 0x831a8168
	ctx.lr = 0x8282F008;
	sub_831A8130(ctx, base);
	// 8282F008: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F00C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8282F010: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282F014: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282F018: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8282F01C: 41820038  beq 0x8282f054
	if ctx.cr[0].eq {
	pc = 0x8282F054; continue 'dispatch;
	}
	// 8282F020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F024: 4897A965  bl 0x831a9988
	ctx.lr = 0x8282F028;
	sub_831A9988(ctx, base);
	// 8282F028: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282F02C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F030: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 8282F034: 489790C5  bl 0x831a80f8
	ctx.lr = 0x8282F038;
	sub_831A80F8(ctx, base);
	// 8282F038: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F03C: 41820018  beq 0x8282f054
	if ctx.cr[0].eq {
	pc = 0x8282F054; continue 'dispatch;
	}
	// 8282F040: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F044: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F048: 4BFFE729  bl 0x8282d770
	ctx.lr = 0x8282F04C;
	sub_8282D770(ctx, base);
	// 8282F04C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8282F050: 48000164  b 0x8282f1b4
	pc = 0x8282F1B4; continue 'dispatch;
	// 8282F054: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F058: 419A014C  beq cr6, 0x8282f1a4
	if ctx.cr[6].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F060: 4897A929  bl 0x831a9988
	ctx.lr = 0x8282F064;
	sub_831A9988(ctx, base);
	// 8282F064: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8282F068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F06C: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 8282F070: 48979089  bl 0x831a80f8
	ctx.lr = 0x8282F074;
	sub_831A80F8(ctx, base);
	// 8282F074: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F078: 41820014  beq 0x8282f08c
	if ctx.cr[0].eq {
	pc = 0x8282F08C; continue 'dispatch;
	}
	// 8282F07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F080: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F084: 4BFFE2CD  bl 0x8282d350
	ctx.lr = 0x8282F088;
	sub_8282D350(ctx, base);
	// 8282F088: 4BFFFFC4  b 0x8282f04c
	pc = 0x8282F04C; continue 'dispatch;
	// 8282F08C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F090: 419A0114  beq cr6, 0x8282f1a4
	if ctx.cr[6].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F098: 4897A8F1  bl 0x831a9988
	ctx.lr = 0x8282F09C;
	sub_831A9988(ctx, base);
	// 8282F09C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8282F0A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F0A4: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 8282F0A8: 48979051  bl 0x831a80f8
	ctx.lr = 0x8282F0AC;
	sub_831A80F8(ctx, base);
	// 8282F0AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F0B0: 41820014  beq 0x8282f0c4
	if ctx.cr[0].eq {
	pc = 0x8282F0C4; continue 'dispatch;
	}
	// 8282F0B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F0B8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F0BC: 4BFFE29D  bl 0x8282d358
	ctx.lr = 0x8282F0C0;
	sub_8282D358(ctx, base);
	// 8282F0C0: 4BFFFF8C  b 0x8282f04c
	pc = 0x8282F04C; continue 'dispatch;
	// 8282F0C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F0C8: 419A00DC  beq cr6, 0x8282f1a4
	if ctx.cr[6].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F0D0: 4897A8B9  bl 0x831a9988
	ctx.lr = 0x8282F0D4;
	sub_831A9988(ctx, base);
	// 8282F0D4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8282F0D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F0DC: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 8282F0E0: 48979019  bl 0x831a80f8
	ctx.lr = 0x8282F0E4;
	sub_831A80F8(ctx, base);
	// 8282F0E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F0E8: 41820014  beq 0x8282f0fc
	if ctx.cr[0].eq {
	pc = 0x8282F0FC; continue 'dispatch;
	}
	// 8282F0EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F0F0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F0F4: 4BFFE305  bl 0x8282d3f8
	ctx.lr = 0x8282F0F8;
	sub_8282D3F8(ctx, base);
	// 8282F0F8: 4BFFFF54  b 0x8282f04c
	pc = 0x8282F04C; continue 'dispatch;
	// 8282F0FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F100: 419A00A4  beq cr6, 0x8282f1a4
	if ctx.cr[6].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F108: 4897A881  bl 0x831a9988
	ctx.lr = 0x8282F10C;
	sub_831A9988(ctx, base);
	// 8282F10C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8282F110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F114: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 8282F118: 48978FE1  bl 0x831a80f8
	ctx.lr = 0x8282F11C;
	sub_831A80F8(ctx, base);
	// 8282F11C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F120: 41820014  beq 0x8282f134
	if ctx.cr[0].eq {
	pc = 0x8282F134; continue 'dispatch;
	}
	// 8282F124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F128: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F12C: 4803BDF5  bl 0x8286af20
	ctx.lr = 0x8282F130;
	sub_8286AF20(ctx, base);
	// 8282F130: 4BFFFF1C  b 0x8282f04c
	pc = 0x8282F04C; continue 'dispatch;
	// 8282F134: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F138: 419A006C  beq cr6, 0x8282f1a4
	if ctx.cr[6].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F13C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F140: 4897A849  bl 0x831a9988
	ctx.lr = 0x8282F144;
	sub_831A9988(ctx, base);
	// 8282F144: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8282F148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F14C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 8282F150: 48978FA9  bl 0x831a80f8
	ctx.lr = 0x8282F154;
	sub_831A80F8(ctx, base);
	// 8282F154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F158: 41820014  beq 0x8282f16c
	if ctx.cr[0].eq {
	pc = 0x8282F16C; continue 'dispatch;
	}
	// 8282F15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F160: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F164: 4BFFEA15  bl 0x8282db78
	ctx.lr = 0x8282F168;
	sub_8282DB78(ctx, base);
	// 8282F168: 4BFFFEE4  b 0x8282f04c
	pc = 0x8282F04C; continue 'dispatch;
	// 8282F16C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F170: 419A0034  beq cr6, 0x8282f1a4
	if ctx.cr[6].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F178: 4897A811  bl 0x831a9988
	ctx.lr = 0x8282F17C;
	sub_831A9988(ctx, base);
	// 8282F17C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8282F180: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F184: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 8282F188: 48978F71  bl 0x831a80f8
	ctx.lr = 0x8282F18C;
	sub_831A80F8(ctx, base);
	// 8282F18C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F190: 41820014  beq 0x8282f1a4
	if ctx.cr[0].eq {
	pc = 0x8282F1A4; continue 'dispatch;
	}
	// 8282F194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F198: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282F19C: 4BFFEC65  bl 0x8282de00
	ctx.lr = 0x8282F1A0;
	sub_8282DE00(ctx, base);
	// 8282F1A0: 4BFFFEAC  b 0x8282f04c
	pc = 0x8282F04C; continue 'dispatch;
	// 8282F1A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8282F1A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F1AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282F1B0: 4BFEA681  bl 0x82819830
	ctx.lr = 0x8282F1B4;
	sub_82819830(ctx, base);
	// 8282F1B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8282F1B8: 48979000  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282F1C0 size=476
    let mut pc: u32 = 0x8282F1C0;
    'dispatch: loop {
        match pc {
            0x8282F1C0 => {
    //   block [0x8282F1C0..0x8282F39C)
	// 8282F1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F1C4: 48978FA1  bl 0x831a8164
	ctx.lr = 0x8282F1C8;
	sub_831A8130(ctx, base);
	// 8282F1C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8282F1CC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F1D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F1D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8282F1D8: 3BCBB940  addi r30, r11, -0x46c0
	ctx.r[30].s64 = ctx.r[11].s64 + -18112;
	// 8282F1DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8282F1E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8282F1E4: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 8282F1E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8282F1EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282F1F0: 386002A0  li r3, 0x2a0
	ctx.r[3].s64 = 672;
	// 8282F1F4: 485C31F5  bl 0x82df23e8
	ctx.lr = 0x8282F1F8;
	sub_82DF23E8(ctx, base);
	// 8282F1F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282F1FC: 41820010  beq 0x8282f20c
	if ctx.cr[0].eq {
	pc = 0x8282F20C; continue 'dispatch;
	}
	// 8282F200: 4BFFFD09  bl 0x8282ef08
	ctx.lr = 0x8282F204;
	sub_8282EF08(ctx, base);
	// 8282F204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F208: 48000008  b 0x8282f210
	pc = 0x8282F210; continue 'dispatch;
	// 8282F20C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8282F210: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8282F214: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F218: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8282F21C: 4BFFE255  bl 0x8282d470
	ctx.lr = 0x8282F220;
	sub_8282D470(ctx, base);
	// 8282F220: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8282F224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F228: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8282F22C: 4BA90DD5  bl 0x822c0000
	ctx.lr = 0x8282F230;
	sub_822C0000(ctx, base);
	// 8282F230: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282F234: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8282F238: 38A000A2  li r5, 0xa2
	ctx.r[5].s64 = 162;
	// 8282F23C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8282F240: 4BA91199  bl 0x822c03d8
	ctx.lr = 0x8282F244;
	sub_822C03D8(ctx, base);
	// 8282F244: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8282F248: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8282F24C: 418200E0  beq 0x8282f32c
	if ctx.cr[0].eq {
	pc = 0x8282F32C; continue 'dispatch;
	}
	// 8282F250: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8282F254: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8282F258: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8282F25C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8282F260: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8282F264: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8282F268: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 8282F26C: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282F270: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8282F274: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8282F278: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8282F27C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8282F280: 409A0008  bne cr6, 0x8282f288
	if !ctx.cr[6].eq {
	pc = 0x8282F288; continue 'dispatch;
	}
	// 8282F284: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282F288: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8282F28C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F290: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8282F294: 419A0024  beq cr6, 0x8282f2b8
	if ctx.cr[6].eq {
	pc = 0x8282F2B8; continue 'dispatch;
	}
	// 8282F298: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8282F29C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8282F2A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282F2A4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8282F2A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8282F2AC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282F2B0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282F2B4: 4082FFE8  bne 0x8282f29c
	if !ctx.cr[0].eq {
	pc = 0x8282F29C; continue 'dispatch;
	}
	// 8282F2B8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8282F2BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F2C0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8282F2C4: 419A0024  beq cr6, 0x8282f2e8
	if ctx.cr[6].eq {
	pc = 0x8282F2E8; continue 'dispatch;
	}
	// 8282F2C8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8282F2CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282F2D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282F2D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8282F2D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282F2DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282F2E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282F2E4: 4082FFE8  bne 0x8282f2cc
	if !ctx.cr[0].eq {
	pc = 0x8282F2CC; continue 'dispatch;
	}
	// 8282F2E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8282F2EC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8282F2F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8282F2F4: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282F2F8: 4864D949  bl 0x82e7cc40
	ctx.lr = 0x8282F2FC;
	sub_82E7CC40(ctx, base);
	// 8282F2FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8282F300: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282F304: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8282F308: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8282F30C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8282F310: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8282F314: 4BF69C1D  bl 0x82798f30
	ctx.lr = 0x8282F318;
	sub_82798F30(ctx, base);
	// 8282F318: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F320: 4BF6C349  bl 0x8279b668
	ctx.lr = 0x8282F324;
	sub_8279B668(ctx, base);
	// 8282F324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F328: 48000008  b 0x8282f330
	pc = 0x8282F330; continue 'dispatch;
	// 8282F32C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8282F330: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8282F334: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8282F338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F33C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282F340: 4BD68911  bl 0x82597c50
	ctx.lr = 0x8282F344;
	sub_82597C50(ctx, base);
	// 8282F344: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8282F348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F34C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282F350: 4BA90CB1  bl 0x822c0000
	ctx.lr = 0x8282F354;
	sub_822C0000(ctx, base);
	// 8282F354: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F358: 41820024  beq 0x8282f37c
	if ctx.cr[0].eq {
	pc = 0x8282F37C; continue 'dispatch;
	}
	// 8282F35C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8282F360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282F364: 419A0008  beq cr6, 0x8282f36c
	if ctx.cr[6].eq {
	pc = 0x8282F36C; continue 'dispatch;
	}
	// 8282F368: 4BA91529  bl 0x822c0890
	ctx.lr = 0x8282F36C;
	sub_822C0890(ctx, base);
	// 8282F36C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8282F370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282F374: 419A0008  beq cr6, 0x8282f37c
	if ctx.cr[6].eq {
	pc = 0x8282F37C; continue 'dispatch;
	}
	// 8282F378: 4BA91519  bl 0x822c0890
	ctx.lr = 0x8282F37C;
	sub_822C0890(ctx, base);
	// 8282F37C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8282F380: 419A000C  beq cr6, 0x8282f38c
	if ctx.cr[6].eq {
	pc = 0x8282F38C; continue 'dispatch;
	}
	// 8282F384: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8282F388: 4BA91509  bl 0x822c0890
	ctx.lr = 0x8282F38C;
	sub_822C0890(ctx, base);
	// 8282F38C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8282F390: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8282F394: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8282F398: 48978E1C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8282F3A0 size=12
    let mut pc: u32 = 0x8282F3A0;
    'dispatch: loop {
        match pc {
            0x8282F3A0 => {
    //   block [0x8282F3A0..0x8282F3AC)
	// 8282F3A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F3A4: C02BBA28  lfs f1, -0x45d8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17880 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282F3A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282F3B0 size=204
    let mut pc: u32 = 0x8282F3B0;
    'dispatch: loop {
        match pc {
            0x8282F3B0 => {
    //   block [0x8282F3B0..0x8282F47C)
	// 8282F3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F3B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282F3BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F3C0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8282F3C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F3C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F3CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282F3D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F3D4: 388BBA40  addi r4, r11, -0x45c0
	ctx.r[4].s64 = ctx.r[11].s64 + -17856;
	// 8282F3D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8282F3DC: 485C462D  bl 0x82df3a08
	ctx.lr = 0x8282F3E0;
	sub_82DF3A08(ctx, base);
	// 8282F3E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282F3E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282F3E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F3EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8282F3F0: C3EB9450  lfs f31, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8282F3F4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282F3F8: 4BFBC8C1  bl 0x827ebcb8
	ctx.lr = 0x8282F3FC;
	sub_827EBCB8(ctx, base);
	// 8282F3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F400: 485C4029  bl 0x82df3428
	ctx.lr = 0x8282F404;
	sub_82DF3428(ctx, base);
	// 8282F404: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8282F408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F40C: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8282F410: 485C45F9  bl 0x82df3a08
	ctx.lr = 0x8282F414;
	sub_82DF3A08(ctx, base);
	// 8282F414: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282F418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F41C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282F420: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8282F424: 4BFBC95D  bl 0x827ebd80
	ctx.lr = 0x8282F428;
	sub_827EBD80(ctx, base);
	// 8282F428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F42C: 485C3FFD  bl 0x82df3428
	ctx.lr = 0x8282F430;
	sub_82DF3428(ctx, base);
	// 8282F430: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F438: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 8282F43C: 485C45CD  bl 0x82df3a08
	ctx.lr = 0x8282F440;
	sub_82DF3A08(ctx, base);
	// 8282F440: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F444: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8282F448: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282F44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F450: C02BBA24  lfs f1, -0x45dc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17884 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282F454: 4BFBC92D  bl 0x827ebd80
	ctx.lr = 0x8282F458;
	sub_827EBD80(ctx, base);
	// 8282F458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F45C: 485C3FCD  bl 0x82df3428
	ctx.lr = 0x8282F460;
	sub_82DF3428(ctx, base);
	// 8282F460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8282F464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F46C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8282F470: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282F474: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F480 size=84
    let mut pc: u32 = 0x8282F480;
    'dispatch: loop {
        match pc {
            0x8282F480 => {
    //   block [0x8282F480..0x8282F4D4)
	// 8282F480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F488: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F48C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F490: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F498: 388BB2E4  addi r4, r11, -0x4d1c
	ctx.r[4].s64 = ctx.r[11].s64 + -19740;
	// 8282F49C: 4BFC138D  bl 0x827f0828
	ctx.lr = 0x8282F4A0;
	sub_827F0828(ctx, base);
	// 8282F4A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F4A8: 388BB300  addi r4, r11, -0x4d00
	ctx.r[4].s64 = ctx.r[11].s64 + -19712;
	// 8282F4AC: 4BFC6C45  bl 0x827f60f0
	ctx.lr = 0x8282F4B0;
	sub_827F60F0(ctx, base);
	// 8282F4B0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F4B8: 388BB310  addi r4, r11, -0x4cf0
	ctx.r[4].s64 = ctx.r[11].s64 + -19696;
	// 8282F4BC: 4BFC160D  bl 0x827f0ac8
	ctx.lr = 0x8282F4C0;
	sub_827F0AC8(ctx, base);
	// 8282F4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282F4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F4CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F4D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F4D8 size=72
    let mut pc: u32 = 0x8282F4D8;
    'dispatch: loop {
        match pc {
            0x8282F4D8 => {
    //   block [0x8282F4D8..0x8282F520)
	// 8282F4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F4E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F4E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F4EC: 4BFBD915  bl 0x827ece00
	ctx.lr = 0x8282F4F0;
	sub_827ECE00(ctx, base);
	// 8282F4F0: 485C46B9  bl 0x82df3ba8
	ctx.lr = 0x8282F4F4;
	sub_82DF3BA8(ctx, base);
	// 8282F4F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F4F8: 4182000C  beq 0x8282f504
	if ctx.cr[0].eq {
	pc = 0x8282F504; continue 'dispatch;
	}
	// 8282F4FC: 387F0284  addi r3, r31, 0x284
	ctx.r[3].s64 = ctx.r[31].s64 + 644;
	// 8282F500: 4800000C  b 0x8282f50c
	pc = 0x8282F50C; continue 'dispatch;
	// 8282F504: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F508: 386BB2E4  addi r3, r11, -0x4d1c
	ctx.r[3].s64 = ctx.r[11].s64 + -19740;
	// 8282F50C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282F510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F518: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F520 size=12
    let mut pc: u32 = 0x8282F520;
    'dispatch: loop {
        match pc {
            0x8282F520 => {
    //   block [0x8282F520..0x8282F52C)
	// 8282F520: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F524: 386BB300  addi r3, r11, -0x4d00
	ctx.r[3].s64 = ctx.r[11].s64 + -19712;
	// 8282F528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F530 size=12
    let mut pc: u32 = 0x8282F530;
    'dispatch: loop {
        match pc {
            0x8282F530 => {
    //   block [0x8282F530..0x8282F53C)
	// 8282F530: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F534: 386BB310  addi r3, r11, -0x4cf0
	ctx.r[3].s64 = ctx.r[11].s64 + -19696;
	// 8282F538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F540 size=12
    let mut pc: u32 = 0x8282F540;
    'dispatch: loop {
        match pc {
            0x8282F540 => {
    //   block [0x8282F540..0x8282F54C)
	// 8282F540: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F544: 386BAEB4  addi r3, r11, -0x514c
	ctx.r[3].s64 = ctx.r[11].s64 + -20812;
	// 8282F548: 4BFEC9E8  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F550 size=12
    let mut pc: u32 = 0x8282F550;
    'dispatch: loop {
        match pc {
            0x8282F550 => {
    //   block [0x8282F550..0x8282F55C)
	// 8282F550: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F554: 386BAEB4  addi r3, r11, -0x514c
	ctx.r[3].s64 = ctx.r[11].s64 + -20812;
	// 8282F558: 4BFEC9E0  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F560 size=12
    let mut pc: u32 = 0x8282F560;
    'dispatch: loop {
        match pc {
            0x8282F560 => {
    //   block [0x8282F560..0x8282F56C)
	// 8282F560: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F564: 386BBA4C  addi r3, r11, -0x45b4
	ctx.r[3].s64 = ctx.r[11].s64 + -17844;
	// 8282F568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F570 size=44
    let mut pc: u32 = 0x8282F570;
    'dispatch: loop {
        match pc {
            0x8282F570 => {
    //   block [0x8282F570..0x8282F59C)
	// 8282F570: 896302E5  lbz r11, 0x2e5(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(741 as u32) ) } as u64;
	// 8282F574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282F578: 41820014  beq 0x8282f58c
	if ctx.cr[0].eq {
	pc = 0x8282F58C; continue 'dispatch;
	}
	// 8282F57C: 896302E6  lbz r11, 0x2e6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(742 as u32) ) } as u64;
	// 8282F580: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8282F584: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282F588: 40820008  bne 0x8282f590
	if !ctx.cr[0].eq {
	pc = 0x8282F590; continue 'dispatch;
	}
	// 8282F58C: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 8282F590: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8282F594: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8282F598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F5A0 size=84
    let mut pc: u32 = 0x8282F5A0;
    'dispatch: loop {
        match pc {
            0x8282F5A0 => {
    //   block [0x8282F5A0..0x8282F5F4)
	// 8282F5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F5A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F5AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F5B0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F5B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F5B8: 388BB330  addi r4, r11, -0x4cd0
	ctx.r[4].s64 = ctx.r[11].s64 + -19664;
	// 8282F5BC: 4BFC126D  bl 0x827f0828
	ctx.lr = 0x8282F5C0;
	sub_827F0828(ctx, base);
	// 8282F5C0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F5C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F5C8: 388BB34C  addi r4, r11, -0x4cb4
	ctx.r[4].s64 = ctx.r[11].s64 + -19636;
	// 8282F5CC: 4BFC6B25  bl 0x827f60f0
	ctx.lr = 0x8282F5D0;
	sub_827F60F0(ctx, base);
	// 8282F5D0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F5D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F5D8: 388BB35C  addi r4, r11, -0x4ca4
	ctx.r[4].s64 = ctx.r[11].s64 + -19620;
	// 8282F5DC: 4BFC14ED  bl 0x827f0ac8
	ctx.lr = 0x8282F5E0;
	sub_827F0AC8(ctx, base);
	// 8282F5E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282F5E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F5E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F5EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F5F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F5F8 size=12
    let mut pc: u32 = 0x8282F5F8;
    'dispatch: loop {
        match pc {
            0x8282F5F8 => {
    //   block [0x8282F5F8..0x8282F604)
	// 8282F5F8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F5FC: 386BAEBC  addi r3, r11, -0x5144
	ctx.r[3].s64 = ctx.r[11].s64 + -20804;
	// 8282F600: 4BFEC930  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F608 size=12
    let mut pc: u32 = 0x8282F608;
    'dispatch: loop {
        match pc {
            0x8282F608 => {
    //   block [0x8282F608..0x8282F614)
	// 8282F608: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F60C: 386BAEBC  addi r3, r11, -0x5144
	ctx.r[3].s64 = ctx.r[11].s64 + -20804;
	// 8282F610: 4BFEC928  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F618 size=12
    let mut pc: u32 = 0x8282F618;
    'dispatch: loop {
        match pc {
            0x8282F618 => {
    //   block [0x8282F618..0x8282F624)
	// 8282F618: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282F61C: 386BBA64  addi r3, r11, -0x459c
	ctx.r[3].s64 = ctx.r[11].s64 + -17820;
	// 8282F620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F628 size=12
    let mut pc: u32 = 0x8282F628;
    'dispatch: loop {
        match pc {
            0x8282F628 => {
    //   block [0x8282F628..0x8282F634)
	// 8282F628: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F62C: 386BB34C  addi r3, r11, -0x4cb4
	ctx.r[3].s64 = ctx.r[11].s64 + -19636;
	// 8282F630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F638 size=12
    let mut pc: u32 = 0x8282F638;
    'dispatch: loop {
        match pc {
            0x8282F638 => {
    //   block [0x8282F638..0x8282F644)
	// 8282F638: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F63C: 386BB330  addi r3, r11, -0x4cd0
	ctx.r[3].s64 = ctx.r[11].s64 + -19664;
	// 8282F640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F648 size=12
    let mut pc: u32 = 0x8282F648;
    'dispatch: loop {
        match pc {
            0x8282F648 => {
    //   block [0x8282F648..0x8282F654)
	// 8282F648: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282F64C: 386BB35C  addi r3, r11, -0x4ca4
	ctx.r[3].s64 = ctx.r[11].s64 + -19620;
	// 8282F650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F658 size=12
    let mut pc: u32 = 0x8282F658;
    'dispatch: loop {
        match pc {
            0x8282F658 => {
    //   block [0x8282F658..0x8282F664)
	// 8282F658: 81630298  lwz r11, 0x298(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(664 as u32) ) } as u64;
	// 8282F65C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8282F660: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F664(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282F664 size=8
    let mut pc: u32 = 0x8282F664;
    'dispatch: loop {
        match pc {
            0x8282F664 => {
    //   block [0x8282F664..0x8282F66C)
	// 8282F664: 4BFE9FAC  b 0x82819610
	sub_82819610(ctx, base);
	return;
	// 8282F668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282F670 size=48
    let mut pc: u32 = 0x8282F670;
    'dispatch: loop {
        match pc {
            0x8282F670 => {
    //   block [0x8282F670..0x8282F6A0)
	// 8282F670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F678: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F67C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8282F680: 4BFC0101  bl 0x827ef780
	ctx.lr = 0x8282F684;
	sub_827EF780(ctx, base);
	// 8282F684: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8282F688: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282F68C: 4BFBAC25  bl 0x827ea2b0
	ctx.lr = 0x8282F690;
	sub_827EA2B0(ctx, base);
	// 8282F690: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282F694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F6A0 size=136
    let mut pc: u32 = 0x8282F6A0;
    'dispatch: loop {
        match pc {
            0x8282F6A0 => {
    //   block [0x8282F6A0..0x8282F728)
	// 8282F6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F6A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282F6AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F6B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F6B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282F6B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282F6BC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8282F6C0: 409A0020  bne cr6, 0x8282f6e0
	if !ctx.cr[6].eq {
	pc = 0x8282F6E0; continue 'dispatch;
	}
	// 8282F6C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282F6C8: 419A0048  beq cr6, 0x8282f710
	if ctx.cr[6].eq {
	pc = 0x8282F710; continue 'dispatch;
	}
	// 8282F6CC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8282F6D0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8282F6D4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8282F6D8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8282F6DC: 48000034  b 0x8282f710
	pc = 0x8282F710; continue 'dispatch;
	// 8282F6E0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8282F6E4: 419A002C  beq cr6, 0x8282f710
	if ctx.cr[6].eq {
	pc = 0x8282F710; continue 'dispatch;
	}
	// 8282F6E8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282F6EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F6F0: 388B0EA8  addi r4, r11, 0xea8
	ctx.r[4].s64 = ctx.r[11].s64 + 3752;
	// 8282F6F4: 48978A05  bl 0x831a80f8
	ctx.lr = 0x8282F6F8;
	sub_831A80F8(ctx, base);
	// 8282F6F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F6FC: 4182000C  beq 0x8282f708
	if ctx.cr[0].eq {
	pc = 0x8282F708; continue 'dispatch;
	}
	// 8282F700: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8282F704: 4800000C  b 0x8282f710
	pc = 0x8282F710; continue 'dispatch;
	// 8282F708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282F70C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282F710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282F714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F71C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282F720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F728 size=136
    let mut pc: u32 = 0x8282F728;
    'dispatch: loop {
        match pc {
            0x8282F728 => {
    //   block [0x8282F728..0x8282F7B0)
	// 8282F728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282F734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F73C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282F740: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282F744: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8282F748: 409A0020  bne cr6, 0x8282f768
	if !ctx.cr[6].eq {
	pc = 0x8282F768; continue 'dispatch;
	}
	// 8282F74C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282F750: 419A0048  beq cr6, 0x8282f798
	if ctx.cr[6].eq {
	pc = 0x8282F798; continue 'dispatch;
	}
	// 8282F754: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8282F758: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8282F75C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8282F760: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8282F764: 48000034  b 0x8282f798
	pc = 0x8282F798; continue 'dispatch;
	// 8282F768: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8282F76C: 419A002C  beq cr6, 0x8282f798
	if ctx.cr[6].eq {
	pc = 0x8282F798; continue 'dispatch;
	}
	// 8282F770: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282F774: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F778: 388B0F68  addi r4, r11, 0xf68
	ctx.r[4].s64 = ctx.r[11].s64 + 3944;
	// 8282F77C: 4897897D  bl 0x831a80f8
	ctx.lr = 0x8282F780;
	sub_831A80F8(ctx, base);
	// 8282F780: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F784: 4182000C  beq 0x8282f790
	if ctx.cr[0].eq {
	pc = 0x8282F790; continue 'dispatch;
	}
	// 8282F788: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8282F78C: 4800000C  b 0x8282f798
	pc = 0x8282F798; continue 'dispatch;
	// 8282F790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282F794: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282F798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282F79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F7A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282F7A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F7AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F7B0 size=76
    let mut pc: u32 = 0x8282F7B0;
    'dispatch: loop {
        match pc {
            0x8282F7B0 => {
    //   block [0x8282F7B0..0x8282F7FC)
	// 8282F7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282F7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F7C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282F7CC: 485E2725  bl 0x82e11ef0
	ctx.lr = 0x8282F7D0;
	sub_82E11EF0(ctx, base);
	// 8282F7D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F7D4: 4182000C  beq 0x8282f7e0
	if ctx.cr[0].eq {
	pc = 0x8282F7E0; continue 'dispatch;
	}
	// 8282F7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F7DC: 485C2BFD  bl 0x82df23d8
	ctx.lr = 0x8282F7E0;
	sub_82DF23D8(ctx, base);
	// 8282F7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F7E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282F7E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282F7EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282F7F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282F7F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282F7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282F800 size=116
    let mut pc: u32 = 0x8282F800;
    'dispatch: loop {
        match pc {
            0x8282F800 => {
    //   block [0x8282F800..0x8282F874)
	// 8282F800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282F808: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282F80C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F810: 80630254  lwz r3, 0x254(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(596 as u32) ) } as u64;
	// 8282F814: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282F818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282F81C: 419A0044  beq cr6, 0x8282f860
	if ctx.cr[6].eq {
	pc = 0x8282F860; continue 'dispatch;
	}
	// 8282F820: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F824: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8282F828: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282F82C: 4E800421  bctrl
	ctx.lr = 0x8282F830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282F830: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8282F834: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8282F838: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282F83C: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282F840: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8282F844: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8282F848: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8282F84C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8282F850: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8282F854: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8282F858: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282F878 size=96
    let mut pc: u32 = 0x8282F878;
    'dispatch: loop {
        match pc {
            0x8282F878 => {
    //   block [0x8282F878..0x8282F8D8)
	// 8282F878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F87C: 489788ED  bl 0x831a8168
	ctx.lr = 0x8282F880;
	sub_831A8130(ctx, base);
	// 8282F880: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F888: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 8282F88C: 4814D26D  bl 0x8297caf8
	ctx.lr = 0x8282F890;
	sub_8297CAF8(ctx, base);
	// 8282F890: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F894: 3BDF02D0  addi r30, r31, 0x2d0
	ctx.r[30].s64 = ctx.r[31].s64 + 720;
	// 8282F898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F89C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8282F8A0: 83BF0280  lwz r29, 0x280(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 8282F8A4: 8B9F02E6  lbz r28, 0x2e6(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(742 as u32) ) } as u64;
	// 8282F8A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282F8AC: 4E800421  bctrl
	ctx.lr = 0x8282F8B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282F8B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F8B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282F8B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8282F8BC: 4BFBE85D  bl 0x827ee118
	ctx.lr = 0x8282F8C0;
	sub_827EE118(ctx, base);
	// 8282F8C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F8C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8282F8C8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8282F8CC: 4814D8F5  bl 0x8297d1c0
	ctx.lr = 0x8282F8D0;
	sub_8297D1C0(ctx, base);
	// 8282F8D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8282F8D4: 489788E4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282F8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282F8D8 size=308
    let mut pc: u32 = 0x8282F8D8;
    'dispatch: loop {
        match pc {
            0x8282F8D8 => {
    //   block [0x8282F8D8..0x8282FA0C)
	// 8282F8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282F8DC: 48978885  bl 0x831a8160
	ctx.lr = 0x8282F8E0;
	sub_831A8130(ctx, base);
	// 8282F8E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282F8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282F8E8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8282F8EC: 3B7F02C0  addi r27, r31, 0x2c0
	ctx.r[27].s64 = ctx.r[31].s64 + 704;
	// 8282F8F0: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 8282F8F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8282F8F8: 4BD287F1  bl 0x825580e8
	ctx.lr = 0x8282F8FC;
	sub_825580E8(ctx, base);
	// 8282F8FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282F900: 41820104  beq 0x8282fa04
	if ctx.cr[0].eq {
	pc = 0x8282FA04; continue 'dispatch;
	}
	// 8282F904: 39600033  li r11, 0x33
	ctx.r[11].s64 = 51;
	// 8282F908: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8282F90C: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 8282F910: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 8282F914: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 8282F918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F91C: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 8282F920: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8282F924: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 8282F928: 4BCDFBA1  bl 0x8250f4c8
	ctx.lr = 0x8282F92C;
	sub_8250F4C8(ctx, base);
	// 8282F92C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282F934: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8282F938: 409A0008  bne cr6, 0x8282f940
	if !ctx.cr[6].eq {
	pc = 0x8282F940; continue 'dispatch;
	}
	// 8282F93C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8282F940: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8282F944: 4BCD906D  bl 0x825089b0
	ctx.lr = 0x8282F948;
	sub_825089B0(ctx, base);
	// 8282F948: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282F950: 3BCBFF34  addi r30, r11, -0xcc
	ctx.r[30].s64 = ctx.r[11].s64 + -204;
	// 8282F954: 409A0008  bne cr6, 0x8282f95c
	if !ctx.cr[6].eq {
	pc = 0x8282F95C; continue 'dispatch;
	}
	// 8282F958: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8282F95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282F960: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 8282F964: 481E3D1D  bl 0x82a13680
	ctx.lr = 0x8282F968;
	sub_82A13680(ctx, base);
	// 8282F968: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282F96C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282F970: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8282F974: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8282F978: 4BA98029  bl 0x822c79a0
	ctx.lr = 0x8282F97C;
	sub_822C79A0(ctx, base);
	// 8282F97C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8282F980: 485C2311  bl 0x82df1c90
	ctx.lr = 0x8282F984;
	sub_82DF1C90(ctx, base);
	// 8282F984: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8282F988: 485C2309  bl 0x82df1c90
	ctx.lr = 0x8282F98C;
	sub_82DF1C90(ctx, base);
	// 8282F98C: 9BA10054  stb r29, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u8 ) };
	// 8282F990: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 8282F994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282F998: 9B810056  stb r28, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[28].u8 ) };
	// 8282F99C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282F9A0: 9B810057  stb r28, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[28].u8 ) };
	// 8282F9A4: 4BCDFB25  bl 0x8250f4c8
	ctx.lr = 0x8282F9A8;
	sub_8250F4C8(ctx, base);
	// 8282F9A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282F9B0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8282F9B4: 409A0008  bne cr6, 0x8282f9bc
	if !ctx.cr[6].eq {
	pc = 0x8282F9BC; continue 'dispatch;
	}
	// 8282F9B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8282F9BC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8282F9C0: 4BCD8FF1  bl 0x825089b0
	ctx.lr = 0x8282F9C4;
	sub_825089B0(ctx, base);
	// 8282F9C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282F9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282F9CC: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 8282F9D0: 409A0008  bne cr6, 0x8282f9d8
	if !ctx.cr[6].eq {
	pc = 0x8282F9D8; continue 'dispatch;
	}
	// 8282F9D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8282F9D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282F9DC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8282F9E0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 8282F9E4: 38EABA80  addi r7, r10, -0x4580
	ctx.r[7].s64 = ctx.r[10].s64 + -17792;
	// 8282F9E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8282F9EC: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282F9F0: 4BA98079  bl 0x822c7a68
	ctx.lr = 0x8282F9F4;
	sub_822C7A68(ctx, base);
	// 8282F9F4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8282F9F8: 485C2299  bl 0x82df1c90
	ctx.lr = 0x8282F9FC;
	sub_82DF1C90(ctx, base);
	// 8282F9FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8282FA00: 485C2291  bl 0x82df1c90
	ctx.lr = 0x8282FA04;
	sub_82DF1C90(ctx, base);
	// 8282FA04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8282FA08: 489787A8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8282FA10 size=224
    let mut pc: u32 = 0x8282FA10;
    'dispatch: loop {
        match pc {
            0x8282FA10 => {
    //   block [0x8282FA10..0x8282FAF0)
	// 8282FA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FA14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FA18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FA1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FA20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FA24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282FA28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282FA2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8282FA30: C1BF0294  lfs f13, 0x294(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282FA34: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282FA38: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8282FA3C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282FA40: D1BF0294  stfs f13, 0x294(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 8282FA44: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8282FA48: 40980084  bge cr6, 0x8282facc
	if !ctx.cr[6].lt {
	pc = 0x8282FACC; continue 'dispatch;
	}
	// 8282FA4C: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 8282FA50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282FA54: 409A003C  bne cr6, 0x8282fa90
	if !ctx.cr[6].eq {
	pc = 0x8282FA90; continue 'dispatch;
	}
	// 8282FA58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8282FA5C: C01F028C  lfs f0, 0x28c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282FA60: D01F0294  stfs f0, 0x294(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 8282FA64: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 8282FA68: 4BFBC819  bl 0x827ec280
	ctx.lr = 0x8282FA6C;
	sub_827EC280(ctx, base);
	// 8282FA6C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8282FA70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FA74: 388B2AD4  addi r4, r11, 0x2ad4
	ctx.r[4].s64 = ctx.r[11].s64 + 10964;
	// 8282FA78: 4BFE8991  bl 0x82818408
	ctx.lr = 0x8282FA7C;
	sub_82818408(ctx, base);
	// 8282FA7C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FA84: C02BBA2C  lfs f1, -0x45d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17876 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282FA88: 4BFE7C99  bl 0x82817720
	ctx.lr = 0x8282FA8C;
	sub_82817720(ctx, base);
	// 8282FA8C: 48000040  b 0x8282facc
	pc = 0x8282FACC; continue 'dispatch;
	// 8282FA90: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8282FA94: 409A0038  bne cr6, 0x8282facc
	if !ctx.cr[6].eq {
	pc = 0x8282FACC; continue 'dispatch;
	}
	// 8282FA98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FA9C: C01F0290  lfs f0, 0x290(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282FAA0: D01F0294  stfs f0, 0x294(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 8282FAA4: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 8282FAA8: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 8282FAAC: 4812FAA5  bl 0x8295f550
	ctx.lr = 0x8282FAB0;
	sub_8295F550(ctx, base);
	// 8282FAB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FAB8: 4BFBC7B9  bl 0x827ec270
	ctx.lr = 0x8282FABC;
	sub_827EC270(ctx, base);
	// 8282FABC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FAC4: 388BBAF4  addi r4, r11, -0x450c
	ctx.r[4].s64 = ctx.r[11].s64 + -17676;
	// 8282FAC8: 4BFE8941  bl 0x82818408
	ctx.lr = 0x8282FACC;
	sub_82818408(ctx, base);
	// 8282FACC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282FAD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FAD4: 4BFE7BB5  bl 0x82817688
	ctx.lr = 0x8282FAD8;
	sub_82817688(ctx, base);
	// 8282FAD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FAE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FAE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FAE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282FAEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282FAF0 size=92
    let mut pc: u32 = 0x8282FAF0;
    'dispatch: loop {
        match pc {
            0x8282FAF0 => {
    //   block [0x8282FAF0..0x8282FB4C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FB4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8282FB4C size=8
    let mut pc: u32 = 0x8282FB4C;
    'dispatch: loop {
        match pc {
            0x8282FB4C => {
    //   block [0x8282FB4C..0x8282FB54)
	// 8282FB4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8282FB50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282FB58 size=196
    let mut pc: u32 = 0x8282FB58;
    'dispatch: loop {
        match pc {
            0x8282FB58 => {
    //   block [0x8282FB58..0x8282FC1C)
	// 8282FB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FB68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FB6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282FB70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FB74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282FB78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282FB7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FB80: 4BA90DB9  bl 0x822c0938
	ctx.lr = 0x8282FB84;
	sub_822C0938(ctx, base);
	// 8282FB84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282FB88: 41820028  beq 0x8282fbb0
	if ctx.cr[0].eq {
	pc = 0x8282FBB0; continue 'dispatch;
	}
	// 8282FB8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FB90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282FB94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282FB98: 392BBA80  addi r9, r11, -0x4580
	ctx.r[9].s64 = ctx.r[11].s64 + -17792;
	// 8282FB9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282FBA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282FBA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282FBA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282FBAC: 48000008  b 0x8282fbb4
	pc = 0x8282FBB4; continue 'dispatch;
	// 8282FBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FBB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282FBBC: 409A0044  bne cr6, 0x8282fc00
	if !ctx.cr[6].eq {
	pc = 0x8282FC00; continue 'dispatch;
	}
	// 8282FBC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282FBC4: 419A001C  beq cr6, 0x8282fbe0
	if ctx.cr[6].eq {
	pc = 0x8282FBE0; continue 'dispatch;
	}
	// 8282FBC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FBCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FBD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282FBD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282FBDC: 4E800421  bctrl
	ctx.lr = 0x8282FBE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282FBE0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282FBE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282FBE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282FBEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282FBF0: 816B0C50  lwz r11, 0xc50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3152 as u32) ) } as u64;
	// 8282FBF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282FBF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282FBFC: 4BA90405  bl 0x822c0000
	ctx.lr = 0x8282FC00;
	sub_822C0000(ctx, base);
	// 8282FC00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282FC04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FC08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FC0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FC10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FC14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282FC18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282FC20 size=196
    let mut pc: u32 = 0x8282FC20;
    'dispatch: loop {
        match pc {
            0x8282FC20 => {
    //   block [0x8282FC20..0x8282FCE4)
	// 8282FC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FC30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FC34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282FC38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FC3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282FC40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282FC44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FC48: 4BA90CF1  bl 0x822c0938
	ctx.lr = 0x8282FC4C;
	sub_822C0938(ctx, base);
	// 8282FC4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282FC50: 41820028  beq 0x8282fc78
	if ctx.cr[0].eq {
	pc = 0x8282FC78; continue 'dispatch;
	}
	// 8282FC54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FC58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282FC5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282FC60: 392BBA94  addi r9, r11, -0x456c
	ctx.r[9].s64 = ctx.r[11].s64 + -17772;
	// 8282FC64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282FC68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282FC6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282FC70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282FC74: 48000008  b 0x8282fc7c
	pc = 0x8282FC7C; continue 'dispatch;
	// 8282FC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FC7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282FC84: 409A0044  bne cr6, 0x8282fcc8
	if !ctx.cr[6].eq {
	pc = 0x8282FCC8; continue 'dispatch;
	}
	// 8282FC88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282FC8C: 419A001C  beq cr6, 0x8282fca8
	if ctx.cr[6].eq {
	pc = 0x8282FCA8; continue 'dispatch;
	}
	// 8282FC90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FC94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FC9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282FCA4: 4E800421  bctrl
	ctx.lr = 0x8282FCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282FCA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282FCAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282FCB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282FCB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282FCB8: 816B0C50  lwz r11, 0xc50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3152 as u32) ) } as u64;
	// 8282FCBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282FCC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282FCC4: 4BA9033D  bl 0x822c0000
	ctx.lr = 0x8282FCC8;
	sub_822C0000(ctx, base);
	// 8282FCC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282FCCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FCD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FCD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FCD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FCDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282FCE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282FCE8 size=196
    let mut pc: u32 = 0x8282FCE8;
    'dispatch: loop {
        match pc {
            0x8282FCE8 => {
    //   block [0x8282FCE8..0x8282FDAC)
	// 8282FCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FCEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FCF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FCF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FCF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FCFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282FD00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FD04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282FD08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282FD0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FD10: 4BA90C29  bl 0x822c0938
	ctx.lr = 0x8282FD14;
	sub_822C0938(ctx, base);
	// 8282FD14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282FD18: 41820028  beq 0x8282fd40
	if ctx.cr[0].eq {
	pc = 0x8282FD40; continue 'dispatch;
	}
	// 8282FD1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FD20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282FD24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282FD28: 392BBAA8  addi r9, r11, -0x4558
	ctx.r[9].s64 = ctx.r[11].s64 + -17752;
	// 8282FD2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282FD30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282FD34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282FD38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282FD3C: 48000008  b 0x8282fd44
	pc = 0x8282FD44; continue 'dispatch;
	// 8282FD40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FD44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FD48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282FD4C: 409A0044  bne cr6, 0x8282fd90
	if !ctx.cr[6].eq {
	pc = 0x8282FD90; continue 'dispatch;
	}
	// 8282FD50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282FD54: 419A001C  beq cr6, 0x8282fd70
	if ctx.cr[6].eq {
	pc = 0x8282FD70; continue 'dispatch;
	}
	// 8282FD58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FD5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FD64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FD68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282FD6C: 4E800421  bctrl
	ctx.lr = 0x8282FD70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282FD70: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282FD74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282FD78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282FD7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282FD80: 816B0C50  lwz r11, 0xc50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3152 as u32) ) } as u64;
	// 8282FD84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282FD88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282FD8C: 4BA90275  bl 0x822c0000
	ctx.lr = 0x8282FD90;
	sub_822C0000(ctx, base);
	// 8282FD90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282FD94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FD98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FD9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FDA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FDA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282FDA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282FDB0 size=196
    let mut pc: u32 = 0x8282FDB0;
    'dispatch: loop {
        match pc {
            0x8282FDB0 => {
    //   block [0x8282FDB0..0x8282FE74)
	// 8282FDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FDB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FDB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FDBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FDC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FDC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282FDC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FDCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282FDD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282FDD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FDD8: 4BA90B61  bl 0x822c0938
	ctx.lr = 0x8282FDDC;
	sub_822C0938(ctx, base);
	// 8282FDDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282FDE0: 41820028  beq 0x8282fe08
	if ctx.cr[0].eq {
	pc = 0x8282FE08; continue 'dispatch;
	}
	// 8282FDE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FDE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282FDEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282FDF0: 392BBABC  addi r9, r11, -0x4544
	ctx.r[9].s64 = ctx.r[11].s64 + -17732;
	// 8282FDF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282FDF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282FDFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282FE00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282FE04: 48000008  b 0x8282fe0c
	pc = 0x8282FE0C; continue 'dispatch;
	// 8282FE08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FE0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282FE14: 409A0044  bne cr6, 0x8282fe58
	if !ctx.cr[6].eq {
	pc = 0x8282FE58; continue 'dispatch;
	}
	// 8282FE18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282FE1C: 419A001C  beq cr6, 0x8282fe38
	if ctx.cr[6].eq {
	pc = 0x8282FE38; continue 'dispatch;
	}
	// 8282FE20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FE24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FE28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FE2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282FE30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282FE34: 4E800421  bctrl
	ctx.lr = 0x8282FE38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282FE38: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282FE3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282FE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282FE44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282FE48: 816B0C50  lwz r11, 0xc50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3152 as u32) ) } as u64;
	// 8282FE4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282FE50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282FE54: 4BA901AD  bl 0x822c0000
	ctx.lr = 0x8282FE58;
	sub_822C0000(ctx, base);
	// 8282FE58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282FE5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FE60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FE64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FE68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FE6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282FE70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282FE78 size=196
    let mut pc: u32 = 0x8282FE78;
    'dispatch: loop {
        match pc {
            0x8282FE78 => {
    //   block [0x8282FE78..0x8282FF3C)
	// 8282FE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FE80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FE84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FE88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FE8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282FE90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FE94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282FE98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282FE9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FEA0: 4BA90A99  bl 0x822c0938
	ctx.lr = 0x8282FEA4;
	sub_822C0938(ctx, base);
	// 8282FEA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282FEA8: 41820028  beq 0x8282fed0
	if ctx.cr[0].eq {
	pc = 0x8282FED0; continue 'dispatch;
	}
	// 8282FEAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FEB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282FEB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282FEB8: 392BBAD0  addi r9, r11, -0x4530
	ctx.r[9].s64 = ctx.r[11].s64 + -17712;
	// 8282FEBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282FEC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282FEC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282FEC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282FECC: 48000008  b 0x8282fed4
	pc = 0x8282FED4; continue 'dispatch;
	// 8282FED0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FED4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282FEDC: 409A0044  bne cr6, 0x8282ff20
	if !ctx.cr[6].eq {
	pc = 0x8282FF20; continue 'dispatch;
	}
	// 8282FEE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282FEE4: 419A001C  beq cr6, 0x8282ff00
	if ctx.cr[6].eq {
	pc = 0x8282FF00; continue 'dispatch;
	}
	// 8282FEE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FEEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FEF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282FEF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282FEFC: 4E800421  bctrl
	ctx.lr = 0x8282FF00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282FF00: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282FF04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282FF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282FF0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282FF10: 816B0C50  lwz r11, 0xc50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3152 as u32) ) } as u64;
	// 8282FF14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282FF18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282FF1C: 4BA900E5  bl 0x822c0000
	ctx.lr = 0x8282FF20;
	sub_822C0000(ctx, base);
	// 8282FF20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282FF24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FF30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282FF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8282FF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8282FF40 size=196
    let mut pc: u32 = 0x8282FF40;
    'dispatch: loop {
        match pc {
            0x8282FF40 => {
    //   block [0x8282FF40..0x82830004)
	// 8282FF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282FF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8282FF48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282FF4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8282FF50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282FF54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282FF58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FF5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8282FF60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8282FF64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FF68: 4BA909D1  bl 0x822c0938
	ctx.lr = 0x8282FF6C;
	sub_822C0938(ctx, base);
	// 8282FF6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282FF70: 41820028  beq 0x8282ff98
	if ctx.cr[0].eq {
	pc = 0x8282FF98; continue 'dispatch;
	}
	// 8282FF74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282FF78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282FF7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8282FF80: 392BBAE4  addi r9, r11, -0x451c
	ctx.r[9].s64 = ctx.r[11].s64 + -17692;
	// 8282FF84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8282FF88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282FF8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8282FF90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8282FF94: 48000008  b 0x8282ff9c
	pc = 0x8282FF9C; continue 'dispatch;
	// 8282FF98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282FF9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8282FFA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282FFA4: 409A0044  bne cr6, 0x8282ffe8
	if !ctx.cr[6].eq {
	pc = 0x8282FFE8; continue 'dispatch;
	}
	// 8282FFA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282FFAC: 419A001C  beq cr6, 0x8282ffc8
	if ctx.cr[6].eq {
	pc = 0x8282FFC8; continue 'dispatch;
	}
	// 8282FFB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FFB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282FFB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282FFBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282FFC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282FFC4: 4E800421  bctrl
	ctx.lr = 0x8282FFC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282FFC8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282FFCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8282FFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282FFD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8282FFD8: 816B0C50  lwz r11, 0xc50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3152 as u32) ) } as u64;
	// 8282FFDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8282FFE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282FFE4: 4BA9001D  bl 0x822c0000
	ctx.lr = 0x8282FFE8;
	sub_822C0000(ctx, base);
	// 8282FFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282FFEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282FFF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282FFF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282FFF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282FFFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82830008 size=12
    let mut pc: u32 = 0x82830008;
    'dispatch: loop {
        match pc {
            0x82830008 => {
    //   block [0x82830008..0x82830014)
	// 82830008: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283000C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830010: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830014(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82830014 size=8
    let mut pc: u32 = 0x82830014;
    'dispatch: loop {
        match pc {
            0x82830014 => {
    //   block [0x82830014..0x8283001C)
	// 82830014: 4BFFF8C4  b 0x8282f8d8
	sub_8282F8D8(ctx, base);
	return;
	// 82830018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830020 size=116
    let mut pc: u32 = 0x82830020;
    'dispatch: loop {
        match pc {
            0x82830020 => {
    //   block [0x82830020..0x82830094)
	// 82830020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283002C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830034: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830038: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283003C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82830040: 396BBBEC  addi r11, r11, -0x4414
	ctx.r[11].s64 = ctx.r[11].s64 + -17428;
	// 82830044: 394ABBD8  addi r10, r10, -0x4428
	ctx.r[10].s64 = ctx.r[10].s64 + -17448;
	// 82830048: 3929BB8C  addi r9, r9, -0x4474
	ctx.r[9].s64 = ctx.r[9].s64 + -17524;
	// 8283004C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830050: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82830054: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82830058: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 8283005C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830060: 419A0008  beq cr6, 0x82830068
	if ctx.cr[6].eq {
	pc = 0x82830068; continue 'dispatch;
	}
	// 82830064: 4BA9082D  bl 0x822c0890
	ctx.lr = 0x82830068;
	sub_822C0890(ctx, base);
	// 82830068: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 8283006C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830070: 419A0008  beq cr6, 0x82830078
	if ctx.cr[6].eq {
	pc = 0x82830078; continue 'dispatch;
	}
	// 82830074: 4BA9081D  bl 0x822c0890
	ctx.lr = 0x82830078;
	sub_822C0890(ctx, base);
	// 82830078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283007C: 4BFE7DFD  bl 0x82817e78
	ctx.lr = 0x82830080;
	sub_82817E78(ctx, base);
	// 82830080: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82830084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283008C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82830098 size=8
    let mut pc: u32 = 0x82830098;
    'dispatch: loop {
        match pc {
            0x82830098 => {
    //   block [0x82830098..0x828300A0)
	// 82830098: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8283009C: 48000C54  b 0x82830cf0
	sub_82830CF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828300A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828300A0 size=8
    let mut pc: u32 = 0x828300A0;
    'dispatch: loop {
        match pc {
            0x828300A0 => {
    //   block [0x828300A0..0x828300A8)
	// 828300A0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828300A4: 48000C4C  b 0x82830cf0
	sub_82830CF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828300A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828300A8 size=440
    let mut pc: u32 = 0x828300A8;
    'dispatch: loop {
        match pc {
            0x828300A8 => {
    //   block [0x828300A8..0x82830260)
	// 828300A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828300AC: 489780C1  bl 0x831a816c
	ctx.lr = 0x828300B0;
	sub_831A8130(ctx, base);
	// 828300B0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828300B4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828300B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828300BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828300C0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828300C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828300C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828300CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828300D0: 388BD970  addi r4, r11, -0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + -9872;
	// 828300D4: 485C3935  bl 0x82df3a08
	ctx.lr = 0x828300D8;
	sub_82DF3A08(ctx, base);
	// 828300D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828300DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828300E0: 483847A9  bl 0x82bb4888
	ctx.lr = 0x828300E4;
	sub_82BB4888(ctx, base);
	// 828300E4: 7C7D0734  extsh r29, r3
	ctx.r[29].s64 = ctx.r[3].s16 as i64;
	// 828300E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828300EC: 485C333D  bl 0x82df3428
	ctx.lr = 0x828300F0;
	sub_82DF3428(ctx, base);
	// 828300F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828300F4: 482B379D  bl 0x82ae3890
	ctx.lr = 0x828300F8;
	sub_82AE3890(ctx, base);
	// 828300F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828300FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82830100: 4877F589  bl 0x82faf688
	ctx.lr = 0x82830104;
	sub_82FAF688(ctx, base);
	// 82830104: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82830108: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283010C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82830110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830114: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82830118: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8283011C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82830120: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82830124: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82830128: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8283012C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82830130: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82830134: C009BC70  lfs f0, -0x4390(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82830138: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 8283013C: 4864CB05  bl 0x82e7cc40
	ctx.lr = 0x82830140;
	sub_82E7CC40(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82830260 size=244
    let mut pc: u32 = 0x82830260;
    'dispatch: loop {
        match pc {
            0x82830260 => {
    //   block [0x82830260..0x82830354)
	// 82830260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830264: 48977F09  bl 0x831a816c
	ctx.lr = 0x82830268;
	sub_831A8130(ctx, base);
	// 82830268: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283026C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830270: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82830274: 807F0254  lwz r3, 0x254(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 82830278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283027C: 419A00A4  beq cr6, 0x82830320
	if ctx.cr[6].eq {
	pc = 0x82830320; continue 'dispatch;
	}
	// 82830280: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82830284: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82830288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283028C: 4E800421  bctrl
	ctx.lr = 0x82830290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82830290: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82830294: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82830298: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283029C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828302A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828302A4: C01D003C  lfs f0, 0x3c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828302A8: C1BD0038  lfs f13, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828302AC: C19D0034  lfs f12, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828302B0: C17D0030  lfs f11, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828302B4: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828302B8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828302BC: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828302C0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828302C4: C02B6218  lfs f1, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828302C8: 4BFE8AA1  bl 0x82818d68
	ctx.lr = 0x828302CC;
	sub_82818D68(ctx, base);
	// 828302CC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828302D0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828302D4: C01D0030  lfs f0, 0x30(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828302D8: 396B0C60  addi r11, r11, 0xc60
	ctx.r[11].s64 = ctx.r[11].s64 + 3168;
	// 828302DC: C1BD0034  lfs f13, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828302E0: C19D0038  lfs f12, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828302E4: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828302E8: C17D003C  lfs f11, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828302EC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828302F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828302F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828302F8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828302FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830300: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82830304: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82830308: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8283030C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830358 size=116
    let mut pc: u32 = 0x82830358;
    'dispatch: loop {
        match pc {
            0x82830358 => {
    //   block [0x82830358..0x828303CC)
	// 82830358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283035C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830360: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830364: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830368: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283036C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830370: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82830374: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82830378: 396BBCDC  addi r11, r11, -0x4324
	ctx.r[11].s64 = ctx.r[11].s64 + -17188;
	// 8283037C: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 82830380: 394ABCC8  addi r10, r10, -0x4338
	ctx.r[10].s64 = ctx.r[10].s64 + -17208;
	// 82830384: 3929BC7C  addi r9, r9, -0x4384
	ctx.r[9].s64 = ctx.r[9].s64 + -17284;
	// 82830388: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283038C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82830390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830394: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82830398: 419A0018  beq cr6, 0x828303b0
	if ctx.cr[6].eq {
	pc = 0x828303B0; continue 'dispatch;
	}
	// 8283039C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828303A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828303A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828303A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828303AC: 4E800421  bctrl
	ctx.lr = 0x828303B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828303B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828303B4: 4BFFFC6D  bl 0x82830020
	ctx.lr = 0x828303B8;
	sub_82830020(ctx, base);
	// 828303B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828303BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828303C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828303C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828303C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828303D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828303D0 size=8
    let mut pc: u32 = 0x828303D0;
    'dispatch: loop {
        match pc {
            0x828303D0 => {
    //   block [0x828303D0..0x828303D8)
	// 828303D0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828303D4: 48000BAC  b 0x82830f80
	sub_82830F80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828303D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828303D8 size=8
    let mut pc: u32 = 0x828303D8;
    'dispatch: loop {
        match pc {
            0x828303D8 => {
    //   block [0x828303D8..0x828303E0)
	// 828303D8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828303DC: 48000BA4  b 0x82830f80
	sub_82830F80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828303E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828303E0 size=812
    let mut pc: u32 = 0x828303E0;
    'dispatch: loop {
        match pc {
            0x828303E0 => {
    //   block [0x828303E0..0x8283070C)
	// 828303E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828303E4: 48977D89  bl 0x831a816c
	ctx.lr = 0x828303E8;
	sub_831A8130(ctx, base);
	// 828303E8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828303EC: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828303F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828303F4: 817D02E0  lwz r11, 0x2e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(736 as u32) ) } as u64;
	// 828303F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828303FC: 409A02FC  bne cr6, 0x828306f8
	if !ctx.cr[6].eq {
	pc = 0x828306F8; continue 'dispatch;
	}
	// 82830400: 396002C0  li r11, 0x2c0
	ctx.r[11].s64 = 704;
	// 82830404: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82830408: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 8283040C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82830410: 38896910  addi r4, r9, 0x6910
	ctx.r[4].s64 = ctx.r[9].s64 + 26896;
	// 82830414: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830710 size=100
    let mut pc: u32 = 0x82830710;
    'dispatch: loop {
        match pc {
            0x82830710 => {
    //   block [0x82830710..0x82830774)
	// 82830710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283071C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830720: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830724: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830728: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283072C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82830730: 396BBDC4  addi r11, r11, -0x423c
	ctx.r[11].s64 = ctx.r[11].s64 + -16956;
	// 82830734: 394ABDB0  addi r10, r10, -0x4250
	ctx.r[10].s64 = ctx.r[10].s64 + -16976;
	// 82830738: 3929BD64  addi r9, r9, -0x429c
	ctx.r[9].s64 = ctx.r[9].s64 + -17052;
	// 8283073C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830740: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82830744: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82830748: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 8283074C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830750: 419A0008  beq cr6, 0x82830758
	if ctx.cr[6].eq {
	pc = 0x82830758; continue 'dispatch;
	}
	// 82830754: 4BA9013D  bl 0x822c0890
	ctx.lr = 0x82830758;
	sub_822C0890(ctx, base);
	// 82830758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283075C: 4BFFF8C5  bl 0x82830020
	ctx.lr = 0x82830760;
	sub_82830020(ctx, base);
	// 82830760: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82830764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283076C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82830778 size=8
    let mut pc: u32 = 0x82830778;
    'dispatch: loop {
        match pc {
            0x82830778 => {
    //   block [0x82830778..0x82830780)
	// 82830778: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8283077C: 48000954  b 0x828310d0
	sub_828310D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82830780 size=8
    let mut pc: u32 = 0x82830780;
    'dispatch: loop {
        match pc {
            0x82830780 => {
    //   block [0x82830780..0x82830788)
	// 82830780: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 82830784: 4800094C  b 0x828310d0
	sub_828310D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830788 size=160
    let mut pc: u32 = 0x82830788;
    'dispatch: loop {
        match pc {
            0x82830788 => {
    //   block [0x82830788..0x82830828)
	// 82830788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283078C: 489779D9  bl 0x831a8164
	ctx.lr = 0x82830790;
	sub_831A8130(ctx, base);
	// 82830790: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830798: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283079C: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 828307A0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828307A4: 409A0070  bne cr6, 0x82830814
	if !ctx.cr[6].eq {
	pc = 0x82830814; continue 'dispatch;
	}
	// 828307A8: 83DF0258  lwz r30, 0x258(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 828307AC: 807F0254  lwz r3, 0x254(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 828307B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828307B4: 419A0024  beq cr6, 0x828307d8
	if ctx.cr[6].eq {
	pc = 0x828307D8; continue 'dispatch;
	}
	// 828307B8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828307BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828307C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828307C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828307C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828307CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828307D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828307D4: 4082FFE8  bne 0x828307bc
	if !ctx.cr[0].eq {
	pc = 0x828307BC; continue 'dispatch;
	}
	// 828307D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828307DC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828307E0: 839F0280  lwz r28, 0x280(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 828307E4: 3B6A6910  addi r27, r10, 0x6910
	ctx.r[27].s64 = ctx.r[10].s64 + 26896;
	// 828307E8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828307EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828307F0: 4E800421  bctrl
	ctx.lr = 0x828307F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828307F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828307F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828307FC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82830800: 4812F021  bl 0x8295f820
	ctx.lr = 0x82830804;
	sub_8295F820(ctx, base);
	// 82830804: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82830808: 419A000C  beq cr6, 0x82830814
	if ctx.cr[6].eq {
	pc = 0x82830814; continue 'dispatch;
	}
	// 8283080C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82830810: 4BA90081  bl 0x822c0890
	ctx.lr = 0x82830814;
	sub_822C0890(ctx, base);
	// 82830814: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82830818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283081C: 4BFE7A85  bl 0x828182a0
	ctx.lr = 0x82830820;
	sub_828182A0(ctx, base);
	// 82830820: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82830824: 48977990  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830828 size=88
    let mut pc: u32 = 0x82830828;
    'dispatch: loop {
        match pc {
            0x82830828 => {
    //   block [0x82830828..0x82830880)
	// 82830828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283082C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82830834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283083C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830840: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830844: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82830848: 396BBB0C  addi r11, r11, -0x44f4
	ctx.r[11].s64 = ctx.r[11].s64 + -17652;
	// 8283084C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830850: 4862BD39  bl 0x82e5c588
	ctx.lr = 0x82830854;
	sub_82E5C588(ctx, base);
	// 82830854: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830858: 4182000C  beq 0x82830864
	if ctx.cr[0].eq {
	pc = 0x82830864; continue 'dispatch;
	}
	// 8283085C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830860: 485C1B79  bl 0x82df23d8
	ctx.lr = 0x82830864;
	sub_82DF23D8(ctx, base);
	// 82830864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283086C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830874: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82830878: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283087C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830880 size=88
    let mut pc: u32 = 0x82830880;
    'dispatch: loop {
        match pc {
            0x82830880 => {
    //   block [0x82830880..0x828308D8)
	// 82830880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283088C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830898: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283089C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828308A0: 396BBB4C  addi r11, r11, -0x44b4
	ctx.r[11].s64 = ctx.r[11].s64 + -17588;
	// 828308A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828308A8: 4862BCE1  bl 0x82e5c588
	ctx.lr = 0x828308AC;
	sub_82E5C588(ctx, base);
	// 828308AC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828308B0: 4182000C  beq 0x828308bc
	if ctx.cr[0].eq {
	pc = 0x828308BC; continue 'dispatch;
	}
	// 828308B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828308B8: 485C1B21  bl 0x82df23d8
	ctx.lr = 0x828308BC;
	sub_82DF23D8(ctx, base);
	// 828308BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828308C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828308C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828308C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828308CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828308D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828308D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828308D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828308D8 size=184
    let mut pc: u32 = 0x828308D8;
    'dispatch: loop {
        match pc {
            0x828308D8 => {
    //   block [0x828308D8..0x82830990)
	// 828308D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828308DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828308E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828308E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828308E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828308EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828308F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828308F4: 4BFBDE9D  bl 0x827ee790
	ctx.lr = 0x828308F8;
	sub_827EE790(ctx, base);
	// 828308F8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828308FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82830900: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82830904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82830908: 4E800421  bctrl
	ctx.lr = 0x8283090C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283090C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82830910: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82830914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82830918: 419A000C  beq cr6, 0x82830924
	if ctx.cr[6].eq {
	pc = 0x82830924; continue 'dispatch;
	}
	// 8283091C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82830920: 4BA8FF71  bl 0x822c0890
	ctx.lr = 0x82830924;
	sub_822C0890(ctx, base);
	// 82830924: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830928: 41820050  beq 0x82830978
	if ctx.cr[0].eq {
	pc = 0x82830978; continue 'dispatch;
	}
	// 8283092C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830930: 4BFBCF01  bl 0x827ed830
	ctx.lr = 0x82830934;
	sub_827ED830(ctx, base);
	// 82830934: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82830938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283093C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82830940: 4BFBE169  bl 0x827eeaa8
	ctx.lr = 0x82830944;
	sub_827EEAA8(ctx, base);
	// 82830944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82830948: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283094C: 4BFBDE45  bl 0x827ee790
	ctx.lr = 0x82830950;
	sub_827EE790(ctx, base);
	// 82830950: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82830954: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82830958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283095C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82830960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82830964: 4E800421  bctrl
	ctx.lr = 0x82830968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82830968: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283096C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830970: 419A0008  beq cr6, 0x82830978
	if ctx.cr[6].eq {
	pc = 0x82830978; continue 'dispatch;
	}
	// 82830974: 4BA8FF1D  bl 0x822c0890
	ctx.lr = 0x82830978;
	sub_822C0890(ctx, base);
	// 82830978: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8283097C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830984: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82830988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283098C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82830990 size=548
    let mut pc: u32 = 0x82830990;
    'dispatch: loop {
        match pc {
            0x82830990 => {
    //   block [0x82830990..0x82830BB4)
	// 82830990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830994: 489777D5  bl 0x831a8168
	ctx.lr = 0x82830998;
	sub_831A8130(ctx, base);
	// 82830998: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283099C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828309A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828309A4: D02100F4  stfs f1, 0xf4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 828309A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828309AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828309B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828309B4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828309B8: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828309BC: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828309C0: C3EB9524  lfs f31, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828309C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828309C8: 4098000C  bge cr6, 0x828309d4
	if !ctx.cr[6].lt {
	pc = 0x828309D4; continue 'dispatch;
	}
	// 828309CC: EC0107FA  fmadds f0, f1, f31, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 828309D0: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828309D4: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828309D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828309DC: 40990008  ble cr6, 0x828309e4
	if !ctx.cr[6].gt {
	pc = 0x828309E4; continue 'dispatch;
	}
	// 828309E0: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828309E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828309E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828309EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828309F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828309F4: 4E800421  bctrl
	ctx.lr = 0x828309F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828309F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828309FC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82830A00: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82830A04: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82830A08: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830BB8 size=72
    let mut pc: u32 = 0x82830BB8;
    'dispatch: loop {
        match pc {
            0x82830BB8 => {
    //   block [0x82830BB8..0x82830C00)
	// 82830BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830BBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830BC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830BC4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82830BC8: 419A001C  beq cr6, 0x82830be4
	if ctx.cr[6].eq {
	pc = 0x82830BE4; continue 'dispatch;
	}
	// 82830BCC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82830BD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82830BD4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82830BD8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82830BDC: 4BFFEAC5  bl 0x8282f6a0
	ctx.lr = 0x82830BE0;
	sub_8282F6A0(ctx, base);
	// 82830BE0: 48000010  b 0x82830bf0
	pc = 0x82830BF0; continue 'dispatch;
	// 82830BE4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82830BE8: 396B0EA8  addi r11, r11, 0xea8
	ctx.r[11].s64 = ctx.r[11].s64 + 3752;
	// 82830BEC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830BF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82830BF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830BF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830C00 size=72
    let mut pc: u32 = 0x82830C00;
    'dispatch: loop {
        match pc {
            0x82830C00 => {
    //   block [0x82830C00..0x82830C48)
	// 82830C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830C08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830C0C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82830C10: 419A001C  beq cr6, 0x82830c2c
	if ctx.cr[6].eq {
	pc = 0x82830C2C; continue 'dispatch;
	}
	// 82830C14: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82830C18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82830C1C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82830C20: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82830C24: 4BFFEB05  bl 0x8282f728
	ctx.lr = 0x82830C28;
	sub_8282F728(ctx, base);
	// 82830C28: 48000010  b 0x82830c38
	pc = 0x82830C38; continue 'dispatch;
	// 82830C2C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82830C30: 396B0F68  addi r11, r11, 0xf68
	ctx.r[11].s64 = ctx.r[11].s64 + 3944;
	// 82830C34: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830C38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82830C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830C48 size=164
    let mut pc: u32 = 0x82830C48;
    'dispatch: loop {
        match pc {
            0x82830C48 => {
    //   block [0x82830C48..0x82830CEC)
	// 82830C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830C4C: 4897751D  bl 0x831a8168
	ctx.lr = 0x82830C50;
	sub_831A8130(ctx, base);
	// 82830C50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830C54: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82830C58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82830C5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82830C60: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82830C64: 41820038  beq 0x82830c9c
	if ctx.cr[0].eq {
	pc = 0x82830C9C; continue 'dispatch;
	}
	// 82830C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830C6C: 48978D1D  bl 0x831a9988
	ctx.lr = 0x82830C70;
	sub_831A9988(ctx, base);
	// 82830C70: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82830C74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82830C78: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 82830C7C: 4897747D  bl 0x831a80f8
	ctx.lr = 0x82830C80;
	sub_831A80F8(ctx, base);
	// 82830C80: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830C84: 41820018  beq 0x82830c9c
	if ctx.cr[0].eq {
	pc = 0x82830C9C; continue 'dispatch;
	}
	// 82830C88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82830C8C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82830C90: 4BFFEB71  bl 0x8282f800
	ctx.lr = 0x82830C94;
	sub_8282F800(ctx, base);
	// 82830C94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82830C98: 4800004C  b 0x82830ce4
	pc = 0x82830CE4; continue 'dispatch;
	// 82830C9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82830CA0: 419A0034  beq cr6, 0x82830cd4
	if ctx.cr[6].eq {
	pc = 0x82830CD4; continue 'dispatch;
	}
	// 82830CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830CA8: 48978CE1  bl 0x831a9988
	ctx.lr = 0x82830CAC;
	sub_831A9988(ctx, base);
	// 82830CAC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82830CB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82830CB4: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82830CB8: 48977441  bl 0x831a80f8
	ctx.lr = 0x82830CBC;
	sub_831A80F8(ctx, base);
	// 82830CBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830CC0: 41820014  beq 0x82830cd4
	if ctx.cr[0].eq {
	pc = 0x82830CD4; continue 'dispatch;
	}
	// 82830CC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82830CC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82830CCC: 4BFFF595  bl 0x82830260
	ctx.lr = 0x82830CD0;
	sub_82830260(ctx, base);
	// 82830CD0: 4BFFFFC4  b 0x82830c94
	pc = 0x82830C94; continue 'dispatch;
	// 82830CD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82830CD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82830CDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82830CE0: 4BFE8B51  bl 0x82819830
	ctx.lr = 0x82830CE4;
	sub_82819830(ctx, base);
	// 82830CE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82830CE8: 489774D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830CF0 size=76
    let mut pc: u32 = 0x82830CF0;
    'dispatch: loop {
        match pc {
            0x82830CF0 => {
    //   block [0x82830CF0..0x82830D3C)
	// 82830CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82830CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830D08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82830D0C: 4BFFF315  bl 0x82830020
	ctx.lr = 0x82830D10;
	sub_82830020(ctx, base);
	// 82830D10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830D14: 4182000C  beq 0x82830d20
	if ctx.cr[0].eq {
	pc = 0x82830D20; continue 'dispatch;
	}
	// 82830D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830D1C: 485C16BD  bl 0x82df23d8
	ctx.lr = 0x82830D20;
	sub_82DF23D8(ctx, base);
	// 82830D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830D24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82830D28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830D2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830D30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82830D34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82830D40 size=144
    let mut pc: u32 = 0x82830D40;
    'dispatch: loop {
        match pc {
            0x82830D40 => {
    //   block [0x82830D40..0x82830DD0)
	// 82830D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830D4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830D54: 4BFE7295  bl 0x82817fe8
	ctx.lr = 0x82830D58;
	sub_82817FE8(ctx, base);
	// 82830D58: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830D5C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82830D60: 396BBBEC  addi r11, r11, -0x4414
	ctx.r[11].s64 = ctx.r[11].s64 + -17428;
	// 82830D64: 394ABBD8  addi r10, r10, -0x4428
	ctx.r[10].s64 = ctx.r[10].s64 + -17448;
	// 82830D68: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82830D6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830D70: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82830D74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82830D78: 3929BB8C  addi r9, r9, -0x4474
	ctx.r[9].s64 = ctx.r[9].s64 + -17524;
	// 82830D7C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82830D80: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82830D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830D88: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 82830D8C: 392ABA80  addi r9, r10, -0x4580
	ctx.r[9].s64 = ctx.r[10].s64 + -17792;
	// 82830D90: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 82830D94: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 82830D98: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 82830D9C: C00ABA80  lfs f0, -0x4580(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82830DA0: D01F0270  stfs f0, 0x270(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 82830DA4: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82830DA8: D01F0274  stfs f0, 0x274(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), tmp.u32 ) };
	// 82830DAC: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82830DB0: D01F0278  stfs f0, 0x278(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 82830DB4: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82830DB8: D01F027C  stfs f0, 0x27c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), tmp.u32 ) };
	// 82830DBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82830DC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830DC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830DC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830DD0 size=248
    let mut pc: u32 = 0x82830DD0;
    'dispatch: loop {
        match pc {
            0x82830DD0 => {
    //   block [0x82830DD0..0x82830EC8)
	// 82830DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82830DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830DE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830DE4: 4812F77D  bl 0x82960560
	ctx.lr = 0x82830DE8;
	sub_82960560(ctx, base);
	// 82830DE8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82830DEC: 418200C4  beq 0x82830eb0
	if ctx.cr[0].eq {
	pc = 0x82830EB0; continue 'dispatch;
	}
	// 82830DF0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830DF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82830DF8: 388BBE48  addi r4, r11, -0x41b8
	ctx.r[4].s64 = ctx.r[11].s64 + -16824;
	// 82830DFC: 38A0013E  li r5, 0x13e
	ctx.r[5].s64 = 318;
	// 82830E00: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82830E04: 485C15E5  bl 0x82df23e8
	ctx.lr = 0x82830E08;
	sub_82DF23E8(ctx, base);
	// 82830E08: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82830E0C: 4182001C  beq 0x82830e28
	if ctx.cr[0].eq {
	pc = 0x82830E28; continue 'dispatch;
	}
	// 82830E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830E14: 48031D05  bl 0x82862b18
	ctx.lr = 0x82830E18;
	sub_82862B18(ctx, base);
	// 82830E18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830E1C: 396BBB0C  addi r11, r11, -0x44f4
	ctx.r[11].s64 = ctx.r[11].s64 + -17652;
	// 82830E20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830E24: 48000008  b 0x82830e2c
	pc = 0x82830E2C; continue 'dispatch;
	// 82830E28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82830E2C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82830E30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82830E34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82830E38: 4BFFED21  bl 0x8282fb58
	ctx.lr = 0x82830E3C;
	sub_8282FB58(ctx, base);
	// 82830E3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82830E40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82830E44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82830E48: 4BA8F1B9  bl 0x822c0000
	ctx.lr = 0x82830E4C;
	sub_822C0000(ctx, base);
	// 82830E4C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82830E50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82830E54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82830E58: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82830E5C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82830E60: 419A0024  beq cr6, 0x82830e84
	if ctx.cr[6].eq {
	pc = 0x82830E84; continue 'dispatch;
	}
	// 82830E64: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82830E68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82830E6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82830E70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82830E74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82830E78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82830E7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82830E80: 4082FFE8  bne 0x82830e68
	if !ctx.cr[0].eq {
	pc = 0x82830E68; continue 'dispatch;
	}
	// 82830E84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82830E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82830E8C: 4BFBE815  bl 0x827ef6a0
	ctx.lr = 0x82830E90;
	sub_827EF6A0(ctx, base);
	// 82830E90: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82830E94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82830E98: 419A0008  beq cr6, 0x82830ea0
	if ctx.cr[6].eq {
	pc = 0x82830EA0; continue 'dispatch;
	}
	// 82830E9C: 4BA8F9F5  bl 0x822c0890
	ctx.lr = 0x82830EA0;
	sub_822C0890(ctx, base);
	// 82830EA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82830EA4: 419A000C  beq cr6, 0x82830eb0
	if ctx.cr[6].eq {
	pc = 0x82830EB0; continue 'dispatch;
	}
	// 82830EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830EAC: 4BA8F9E5  bl 0x822c0890
	ctx.lr = 0x82830EB0;
	sub_822C0890(ctx, base);
	// 82830EB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82830EB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830EB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830EBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82830EC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82830EC8 size=184
    let mut pc: u32 = 0x82830EC8;
    'dispatch: loop {
        match pc {
            0x82830EC8 => {
    //   block [0x82830EC8..0x82830F80)
	// 82830EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830ED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82830ED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830EE0: 4BFFFE61  bl 0x82830d40
	ctx.lr = 0x82830EE4;
	sub_82830D40(ctx, base);
	// 82830EE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82830EE8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82830EEC: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82830EF0: 396BBCDC  addi r11, r11, -0x4324
	ctx.r[11].s64 = ctx.r[11].s64 + -17188;
	// 82830EF4: 394ABCC8  addi r10, r10, -0x4338
	ctx.r[10].s64 = ctx.r[10].s64 + -17208;
	// 82830EF8: 3929BC7C  addi r9, r9, -0x4384
	ctx.r[9].s64 = ctx.r[9].s64 + -17284;
	// 82830EFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82830F00: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82830F04: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82830F08: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82830F0C: 387F0284  addi r3, r31, 0x284
	ctx.r[3].s64 = ctx.r[31].s64 + 644;
	// 82830F10: 93DF0280  stw r30, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[30].u32 ) };
	// 82830F14: 4BFBF5ED  bl 0x827f0500
	ctx.lr = 0x82830F18;
	sub_827F0500(ctx, base);
	// 82830F18: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82830F1C: 394002A0  li r10, 0x2a0
	ctx.r[10].s64 = 672;
	// 82830F20: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82830F24: 392002B0  li r9, 0x2b0
	ctx.r[9].s64 = 688;
	// 82830F28: 390002C0  li r8, 0x2c0
	ctx.r[8].s64 = 704;
	// 82830F2C: 38E002D0  li r7, 0x2d0
	ctx.r[7].s64 = 720;
	// 82830F30: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82830F34: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82830F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830F80 size=76
    let mut pc: u32 = 0x82830F80;
    'dispatch: loop {
        match pc {
            0x82830F80 => {
    //   block [0x82830F80..0x82830FCC)
	// 82830F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82830F88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82830F8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82830F90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830F94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82830F98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82830F9C: 4BFFF3BD  bl 0x82830358
	ctx.lr = 0x82830FA0;
	sub_82830358(ctx, base);
	// 82830FA0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830FA4: 4182000C  beq 0x82830fb0
	if ctx.cr[0].eq {
	pc = 0x82830FB0; continue 'dispatch;
	}
	// 82830FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830FAC: 485C142D  bl 0x82df23d8
	ctx.lr = 0x82830FB0;
	sub_82DF23D8(ctx, base);
	// 82830FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830FB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82830FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82830FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82830FC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82830FC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82830FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82830FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82830FD0 size=108
    let mut pc: u32 = 0x82830FD0;
    'dispatch: loop {
        match pc {
            0x82830FD0 => {
    //   block [0x82830FD0..0x8283103C)
	// 82830FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82830FD4: 48977199  bl 0x831a816c
	ctx.lr = 0x82830FD8;
	sub_831A8130(ctx, base);
	// 82830FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82830FDC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82830FE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82830FE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82830FE8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82830FEC: 41820038  beq 0x82831024
	if ctx.cr[0].eq {
	pc = 0x82831024; continue 'dispatch;
	}
	// 82830FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82830FF4: 48978995  bl 0x831a9988
	ctx.lr = 0x82830FF8;
	sub_831A9988(ctx, base);
	// 82830FF8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82830FFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82831000: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82831004: 489770F5  bl 0x831a80f8
	ctx.lr = 0x82831008;
	sub_831A80F8(ctx, base);
	// 82831008: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283100C: 41820018  beq 0x82831024
	if ctx.cr[0].eq {
	pc = 0x82831024; continue 'dispatch;
	}
	// 82831010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831014: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82831018: 4BFFE641  bl 0x8282f658
	ctx.lr = 0x8283101C;
	sub_8282F658(ctx, base);
	// 8283101C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82831020: 48000014  b 0x82831034
	pc = 0x82831034; continue 'dispatch;
	// 82831024: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82831028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283102C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82831030: 4BFFFC19  bl 0x82830c48
	ctx.lr = 0x82831034;
	sub_82830C48(ctx, base);
	// 82831034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82831038: 48977184  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82831040 size=140
    let mut pc: u32 = 0x82831040;
    'dispatch: loop {
        match pc {
            0x82831040 => {
    //   block [0x82831040..0x828310CC)
	// 82831040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82831048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283104C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831054: 4BFFFCED  bl 0x82830d40
	ctx.lr = 0x82831058;
	sub_82830D40(ctx, base);
	// 82831058: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283105C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82831060: 396BBDC4  addi r11, r11, -0x423c
	ctx.r[11].s64 = ctx.r[11].s64 + -16956;
	// 82831064: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82831068: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8283106C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82831070: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82831074: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82831078: 394ABDB0  addi r10, r10, -0x4250
	ctx.r[10].s64 = ctx.r[10].s64 + -16976;
	// 8283107C: 3929BD64  addi r9, r9, -0x429c
	ctx.r[9].s64 = ctx.r[9].s64 + -17052;
	// 82831080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82831084: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82831088: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8283108C: C0089524  lfs f0, -0x6adc(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82831090: 917F0280  stw r11, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[11].u32 ) };
	// 82831094: C1A7D7BC  lfs f13, -0x2844(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82831098: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 8283109C: C18608A4  lfs f12, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828310A0: D01F0288  stfs f0, 0x288(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 828310A4: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 828310A8: D1BF028C  stfs f13, 0x28c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), tmp.u32 ) };
	// 828310AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828310B0: D01F0290  stfs f0, 0x290(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), tmp.u32 ) };
	// 828310B4: D19F0294  stfs f12, 0x294(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 828310B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828310BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828310C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828310C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828310C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828310D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828310D0 size=76
    let mut pc: u32 = 0x828310D0;
    'dispatch: loop {
        match pc {
            0x828310D0 => {
    //   block [0x828310D0..0x8283111C)
	// 828310D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828310D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828310D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828310DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828310E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828310E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828310E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828310EC: 4BFFF625  bl 0x82830710
	ctx.lr = 0x828310F0;
	sub_82830710(ctx, base);
	// 828310F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828310F4: 4182000C  beq 0x82831100
	if ctx.cr[0].eq {
	pc = 0x82831100; continue 'dispatch;
	}
	// 828310F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828310FC: 485C12DD  bl 0x82df23d8
	ctx.lr = 0x82831100;
	sub_82DF23D8(ctx, base);
	// 82831100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82831108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283110C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82831110: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82831114: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82831118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82831120 size=4
    let mut pc: u32 = 0x82831120;
    'dispatch: loop {
        match pc {
            0x82831120 => {
    //   block [0x82831120..0x82831124)
	// 82831120: 4BFFFCB0  b 0x82830dd0
	sub_82830DD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82831128 size=756
    let mut pc: u32 = 0x82831128;
    'dispatch: loop {
        match pc {
            0x82831128 => {
    //   block [0x82831128..0x8283141C)
	// 82831128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283112C: 48977035  bl 0x831a8160
	ctx.lr = 0x82831130;
	sub_831A8130(ctx, base);
	// 82831130: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831134: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82831138: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8283113C: 3B8BBE48  addi r28, r11, -0x41b8
	ctx.r[28].s64 = ctx.r[11].s64 + -16824;
	// 82831140: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82831144: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82831148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283114C: 38A001A6  li r5, 0x1a6
	ctx.r[5].s64 = 422;
	// 82831150: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82831154: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82831158: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8283115C: 4BA8F27D  bl 0x822c03d8
	ctx.lr = 0x82831160;
	sub_822C03D8(ctx, base);
	// 82831160: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82831164: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82831168: 3BAB44A0  addi r29, r11, 0x44a0
	ctx.r[29].s64 = ctx.r[11].s64 + 17568;
	// 8283116C: 41820030  beq 0x8283119c
	if ctx.cr[0].eq {
	pc = 0x8283119C; continue 'dispatch;
	}
	// 82831170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82831174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831178: 485C2891  bl 0x82df3a08
	ctx.lr = 0x8283117C;
	sub_82DF3A08(ctx, base);
	// 8283117C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82831180: 38BB00D8  addi r5, r27, 0xd8
	ctx.r[5].s64 = ctx.r[27].s64 + 216;
	// 82831184: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82831188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283118C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82831190: 4BD7B281  bl 0x825ac410
	ctx.lr = 0x82831194;
	sub_825AC410(ctx, base);
	// 82831194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831198: 48000008  b 0x828311a0
	pc = 0x828311A0; continue 'dispatch;
	// 8283119C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828311A0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828311A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828311A8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828311AC: 4BCC220D  bl 0x824f33b8
	ctx.lr = 0x828311B0;
	sub_824F33B8(ctx, base);
	// 828311B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828311B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828311B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828311BC: 4BA8EE45  bl 0x822c0000
	ctx.lr = 0x828311C0;
	sub_822C0000(ctx, base);
	// 828311C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828311C4: 41820010  beq 0x828311d4
	if ctx.cr[0].eq {
	pc = 0x828311D4; continue 'dispatch;
	}
	// 828311C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828311CC: 57DE003C  rlwinm r30, r30, 0, 0, 0x1e
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 828311D0: 485C2259  bl 0x82df3428
	ctx.lr = 0x828311D4;
	sub_82DF3428(ctx, base);
	// 828311D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828311D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828311DC: 388B77B8  addi r4, r11, 0x77b8
	ctx.r[4].s64 = ctx.r[11].s64 + 30648;
	// 828311E0: 485C2829  bl 0x82df3a08
	ctx.lr = 0x828311E4;
	sub_82DF3A08(ctx, base);
	// 828311E4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828311E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828311EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828311F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828311F4: 4BD7ABCD  bl 0x825abdc0
	ctx.lr = 0x828311F8;
	sub_825ABDC0(ctx, base);
	// 828311F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828311FC: 485C222D  bl 0x82df3428
	ctx.lr = 0x82831200;
	sub_82DF3428(ctx, base);
	// 82831200: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82831204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831208: 388BBA08  addi r4, r11, -0x45f8
	ctx.r[4].s64 = ctx.r[11].s64 + -17912;
	// 8283120C: 485C27FD  bl 0x82df3a08
	ctx.lr = 0x82831210;
	sub_82DF3A08(ctx, base);
	// 82831210: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82831214: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82831218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283121C: 4BD7ABA5  bl 0x825abdc0
	ctx.lr = 0x82831220;
	sub_825ABDC0(ctx, base);
	// 82831220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831224: 485C2205  bl 0x82df3428
	ctx.lr = 0x82831228;
	sub_82DF3428(ctx, base);
	// 82831228: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283122C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831230: 388BB9F8  addi r4, r11, -0x4608
	ctx.r[4].s64 = ctx.r[11].s64 + -17928;
	// 82831234: 485C27D5  bl 0x82df3a08
	ctx.lr = 0x82831238;
	sub_82DF3A08(ctx, base);
	// 82831238: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8283123C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82831240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831244: 4BD7AB7D  bl 0x825abdc0
	ctx.lr = 0x82831248;
	sub_825ABDC0(ctx, base);
	// 82831248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283124C: 485C21DD  bl 0x82df3428
	ctx.lr = 0x82831250;
	sub_82DF3428(ctx, base);
	// 82831250: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82831254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831258: 485C27B1  bl 0x82df3a08
	ctx.lr = 0x8283125C;
	sub_82DF3A08(ctx, base);
	// 8283125C: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82831260: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82831264: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831268: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8283126C: 419A0024  beq cr6, 0x82831290
	if ctx.cr[6].eq {
	pc = 0x82831290; continue 'dispatch;
	}
	// 82831270: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82831274: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82831278: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283127C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82831280: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82831284: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82831288: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283128C: 4082FFE8  bne 0x82831274
	if !ctx.cr[0].eq {
	pc = 0x82831274; continue 'dispatch;
	}
	// 82831290: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82831294: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82831298: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8283129C: 4BD70E75  bl 0x825a2110
	ctx.lr = 0x828312A0;
	sub_825A2110(ctx, base);
	// 828312A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828312A4: 485C2185  bl 0x82df3428
	ctx.lr = 0x828312A8;
	sub_82DF3428(ctx, base);
	// 828312A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828312AC: 419A000C  beq cr6, 0x828312b8
	if ctx.cr[6].eq {
	pc = 0x828312B8; continue 'dispatch;
	}
	// 828312B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828312B4: 4BA8F5DD  bl 0x822c0890
	ctx.lr = 0x828312B8;
	sub_822C0890(ctx, base);
	// 828312B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828312BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828312C0: 38A001AF  li r5, 0x1af
	ctx.r[5].s64 = 431;
	// 828312C4: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 828312C8: 4BA8F111  bl 0x822c03d8
	ctx.lr = 0x828312CC;
	sub_822C03D8(ctx, base);
	// 828312CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828312D0: 41820034  beq 0x82831304
	if ctx.cr[0].eq {
	pc = 0x82831304; continue 'dispatch;
	}
	// 828312D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828312D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828312DC: 388BBED0  addi r4, r11, -0x4130
	ctx.r[4].s64 = ctx.r[11].s64 + -16688;
	// 828312E0: 485C2729  bl 0x82df3a08
	ctx.lr = 0x828312E4;
	sub_82DF3A08(ctx, base);
	// 828312E4: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 828312E8: 38BB00B8  addi r5, r27, 0xb8
	ctx.r[5].s64 = ctx.r[27].s64 + 184;
	// 828312EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828312F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828312F4: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	// 828312F8: 4BD78201  bl 0x825a94f8
	ctx.lr = 0x828312FC;
	sub_825A94F8(ctx, base);
	// 828312FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831300: 48000008  b 0x82831308
	pc = 0x82831308; continue 'dispatch;
	// 82831304: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82831308: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8283130C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831310: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82831314: 4BD764D5  bl 0x825a77e8
	ctx.lr = 0x82831318;
	sub_825A77E8(ctx, base);
	// 82831318: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283131C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831320: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82831324: 4BA8ECDD  bl 0x822c0000
	ctx.lr = 0x82831328;
	sub_822C0000(ctx, base);
	// 82831328: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283132C: 4182000C  beq 0x82831338
	if ctx.cr[0].eq {
	pc = 0x82831338; continue 'dispatch;
	}
	// 82831330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831334: 485C20F5  bl 0x82df3428
	ctx.lr = 0x82831338;
	sub_82DF3428(ctx, base);
	// 82831338: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283133C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831340: 388BBEC4  addi r4, r11, -0x413c
	ctx.r[4].s64 = ctx.r[11].s64 + -16700;
	// 82831344: 485C26C5  bl 0x82df3a08
	ctx.lr = 0x82831348;
	sub_82DF3A08(ctx, base);
	// 82831348: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283134C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82831350: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82831354: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82831358: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8283135C: 419A0024  beq cr6, 0x82831380
	if ctx.cr[6].eq {
	pc = 0x82831380; continue 'dispatch;
	}
	// 82831360: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82831364: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82831368: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283136C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82831370: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82831374: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82831378: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283137C: 4082FFE8  bne 0x82831364
	if !ctx.cr[0].eq {
	pc = 0x82831364; continue 'dispatch;
	}
	// 82831380: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82831384: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82831388: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8283138C: 4BD70D85  bl 0x825a2110
	ctx.lr = 0x82831390;
	sub_825A2110(ctx, base);
	// 82831390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831394: 485C2095  bl 0x82df3428
	ctx.lr = 0x82831398;
	sub_82DF3428(ctx, base);
	// 82831398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283139C: 419A000C  beq cr6, 0x828313a8
	if ctx.cr[6].eq {
	pc = 0x828313A8; continue 'dispatch;
	}
	// 828313A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828313A4: 4BA8F4ED  bl 0x822c0890
	ctx.lr = 0x828313A8;
	sub_822C0890(ctx, base);
	// 828313A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828313AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828313B0: 388BBEB0  addi r4, r11, -0x4150
	ctx.r[4].s64 = ctx.r[11].s64 + -16720;
	// 828313B4: 485C2655  bl 0x82df3a08
	ctx.lr = 0x828313B8;
	sub_82DF3A08(ctx, base);
	// 828313B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828313BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828313C0: 388BBEA4  addi r4, r11, -0x415c
	ctx.r[4].s64 = ctx.r[11].s64 + -16732;
	// 828313C4: 485C2645  bl 0x82df3a08
	ctx.lr = 0x828313C8;
	sub_82DF3A08(ctx, base);
	// 828313C8: 38BB00DD  addi r5, r27, 0xdd
	ctx.r[5].s64 = ctx.r[27].s64 + 221;
	// 828313CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828313D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828313D4: 4BD71C7D  bl 0x825a3050
	ctx.lr = 0x828313D8;
	sub_825A3050(ctx, base);
	// 828313D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828313DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828313E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828313E4: 4BD70DA5  bl 0x825a2188
	ctx.lr = 0x828313E8;
	sub_825A2188(ctx, base);
	// 828313E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828313EC: 485C203D  bl 0x82df3428
	ctx.lr = 0x828313F0;
	sub_82DF3428(ctx, base);
	// 828313F0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828313F4: 4BA978C5  bl 0x822c8cb8
	ctx.lr = 0x828313F8;
	sub_822C8CB8(ctx, base);
	// 828313F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828313FC: 485C202D  bl 0x82df3428
	ctx.lr = 0x82831400;
	sub_82DF3428(ctx, base);
	// 82831400: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82831404: 485C2025  bl 0x82df3428
	ctx.lr = 0x82831408;
	sub_82DF3428(ctx, base);
	// 82831408: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8283140C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82831410: 4BFE7559  bl 0x82818968
	ctx.lr = 0x82831414;
	sub_82818968(ctx, base);
	// 82831414: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82831418: 48976D98  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82831420 size=336
    let mut pc: u32 = 0x82831420;
    'dispatch: loop {
        match pc {
            0x82831420 => {
    //   block [0x82831420..0x82831570)
	// 82831420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82831428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283142C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82831430: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82831434: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82831438: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283143C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82831440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831444: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82831448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283144C: 388BEDA0  addi r4, r11, -0x1260
	ctx.r[4].s64 = ctx.r[11].s64 + -4704;
	// 82831450: 485C25B9  bl 0x82df3a08
	ctx.lr = 0x82831454;
	sub_82DF3A08(ctx, base);
	// 82831454: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82831458: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283145C: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 82831460: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82831464: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82831468: C3CA08AC  lfs f30, 0x8ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2220 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8283146C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82831470: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82831474: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82831478: 4BD71D39  bl 0x825a31b0
	ctx.lr = 0x8283147C;
	sub_825A31B0(ctx, base);
	// 8283147C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82831480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82831488: 4BD702E9  bl 0x825a1770
	ctx.lr = 0x8283148C;
	sub_825A1770(ctx, base);
	// 8283148C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82831490: 485C1F99  bl 0x82df3428
	ctx.lr = 0x82831494;
	sub_82DF3428(ctx, base);
	// 82831494: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82831498: 4BA97821  bl 0x822c8cb8
	ctx.lr = 0x8283149C;
	sub_822C8CB8(ctx, base);
	// 8283149C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828314A0: 485C1F89  bl 0x82df3428
	ctx.lr = 0x828314A4;
	sub_82DF3428(ctx, base);
	// 828314A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828314A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828314AC: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 828314B0: 485C2559  bl 0x82df3a08
	ctx.lr = 0x828314B4;
	sub_82DF3A08(ctx, base);
	// 828314B4: 389F0084  addi r4, r31, 0x84
	ctx.r[4].s64 = ctx.r[31].s64 + 132;
	// 828314B8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828314BC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828314C0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828314C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828314C8: 4BD71CE9  bl 0x825a31b0
	ctx.lr = 0x828314CC;
	sub_825A31B0(ctx, base);
	// 828314CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828314D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828314D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828314D8: 4BD70299  bl 0x825a1770
	ctx.lr = 0x828314DC;
	sub_825A1770(ctx, base);
	// 828314DC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828314E0: 485C1F49  bl 0x82df3428
	ctx.lr = 0x828314E4;
	sub_82DF3428(ctx, base);
	// 828314E4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828314E8: 4BA977D1  bl 0x822c8cb8
	ctx.lr = 0x828314EC;
	sub_822C8CB8(ctx, base);
	// 828314EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828314F0: 485C1F39  bl 0x82df3428
	ctx.lr = 0x828314F4;
	sub_82DF3428(ctx, base);
	// 828314F4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828314F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828314FC: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 82831500: 485C2509  bl 0x82df3a08
	ctx.lr = 0x82831504;
	sub_82DF3A08(ctx, base);
	// 82831504: 389F0088  addi r4, r31, 0x88
	ctx.r[4].s64 = ctx.r[31].s64 + 136;
	// 82831508: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8283150C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82831510: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82831514: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82831518: 4BD71C99  bl 0x825a31b0
	ctx.lr = 0x8283151C;
	sub_825A31B0(ctx, base);
	// 8283151C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82831520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831524: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82831528: 4BD70249  bl 0x825a1770
	ctx.lr = 0x8283152C;
	sub_825A1770(ctx, base);
	// 8283152C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82831530: 485C1EF9  bl 0x82df3428
	ctx.lr = 0x82831534;
	sub_82DF3428(ctx, base);
	// 82831534: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82831538: 4BA97781  bl 0x822c8cb8
	ctx.lr = 0x8283153C;
	sub_822C8CB8(ctx, base);
	// 8283153C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831540: 485C1EE9  bl 0x82df3428
	ctx.lr = 0x82831544;
	sub_82DF3428(ctx, base);
	// 82831544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82831548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283154C: 4BFE741D  bl 0x82818968
	ctx.lr = 0x82831550;
	sub_82818968(ctx, base);
	// 82831550: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82831554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82831558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283155C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82831560: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82831564: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82831568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283156C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82831570 size=152
    let mut pc: u32 = 0x82831570;
    'dispatch: loop {
        match pc {
            0x82831570 => {
    //   block [0x82831570..0x82831608)
	// 82831570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82831578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283157C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831580: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82831584: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82831588: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8283158C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82831590: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82831594: 388ABA40  addi r4, r10, -0x45c0
	ctx.r[4].s64 = ctx.r[10].s64 + -17856;
	// 82831598: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283159C: 4807AA55  bl 0x828abff0
	ctx.lr = 0x828315A0;
	sub_828ABFF0(ctx, base);
	// 828315A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828315A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828315A8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828315AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828315B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828315B4: 419A0024  beq cr6, 0x828315d8
	if ctx.cr[6].eq {
	pc = 0x828315D8; continue 'dispatch;
	}
	// 828315B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828315BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828315C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828315C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828315C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828315CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828315D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828315D4: 4082FFE8  bne 0x828315bc
	if !ctx.cr[0].eq {
	pc = 0x828315BC; continue 'dispatch;
	}
	// 828315D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828315DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828315E0: 4BFBCC49  bl 0x827ee228
	ctx.lr = 0x828315E4;
	sub_827EE228(ctx, base);
	// 828315E4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828315E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828315EC: 419A0008  beq cr6, 0x828315f4
	if ctx.cr[6].eq {
	pc = 0x828315F4; continue 'dispatch;
	}
	// 828315F0: 4BA8F2A1  bl 0x822c0890
	ctx.lr = 0x828315F4;
	sub_822C0890(ctx, base);
	// 828315F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828315F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828315FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82831600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82831604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82831608 size=68
    let mut pc: u32 = 0x82831608;
    'dispatch: loop {
        match pc {
            0x82831608 => {
    //   block [0x82831608..0x8283164C)
	// 82831608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283160C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82831610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82831614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283161C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82831620: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82831624: 396BBEE4  addi r11, r11, -0x411c
	ctx.r[11].s64 = ctx.r[11].s64 + -16668;
	// 82831628: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283162C: 4BC389D5  bl 0x8246a000
	ctx.lr = 0x82831630;
	sub_8246A000(ctx, base);
	// 82831630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831634: 4862AF55  bl 0x82e5c588
	ctx.lr = 0x82831638;
	sub_82E5C588(ctx, base);
	// 82831638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283163C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82831640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82831644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82831648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82831650 size=164
    let mut pc: u32 = 0x82831650;
    'dispatch: loop {
        match pc {
            0x82831650 => {
    //   block [0x82831650..0x828316F4)
	// 82831650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82831658: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283165C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831664: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82831668: 4BFBE119  bl 0x827ef780
	ctx.lr = 0x8283166C;
	sub_827EF780(ctx, base);
	// 8283166C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82831670: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82831674: 4BFB8C3D  bl 0x827ea2b0
	ctx.lr = 0x82831678;
	sub_827EA2B0(ctx, base);
	// 82831678: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283167C: 395F0064  addi r10, r31, 0x64
	ctx.r[10].s64 = ctx.r[31].s64 + 100;
	// 82831680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82831684: 419A005C  beq cr6, 0x828316e0
	if ctx.cr[6].eq {
	pc = 0x828316E0; continue 'dispatch;
	}
	// 82831688: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283168C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82831690: 7D6B2E71  srawi. r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831694: 4182004C  beq 0x828316e0
	if ctx.cr[0].eq {
	pc = 0x828316E0; continue 'dispatch;
	}
	// 82831698: 813F0068  lwz r9, 0x68(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283169C: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 828316A0: 39690020  addi r11, r9, 0x20
	ctx.r[11].s64 = ctx.r[9].s64 + 32;
	// 828316A4: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828316F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828316F8 size=40
    let mut pc: u32 = 0x828316F8;
    'dispatch: loop {
        match pc {
            0x828316F8 => {
    //   block [0x828316F8..0x82831720)
	// 828316F8: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828316FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82831700: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82831720 size=56
    let mut pc: u32 = 0x82831720;
    'dispatch: loop {
        match pc {
            0x82831720 => {
    //   block [0x82831720..0x82831758)
	// 82831720: 3920FFE0  li r9, -0x20
	ctx.r[9].s64 = -32;
	// 82831724: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82831758 size=16
    let mut pc: u32 = 0x82831758;
    'dispatch: loop {
        match pc {
            0x82831758 => {
    //   block [0x82831758..0x82831768)
	// 82831758: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283175C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82831760: 7D6B2E71  srawi. r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831764: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82831768 size=32
    let mut pc: u32 = 0x82831768;
    'dispatch: loop {
        match pc {
            0x82831768 => {
    //   block [0x82831768..0x82831788)
	// 82831768: 81640074  lwz r11, 0x74(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) } as u64;
	// 8283176C: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82831770: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82831774: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82831778: 40980008  bge cr6, 0x82831780
	if !ctx.cr[6].lt {
	pc = 0x82831780; continue 'dispatch;
	}
	// 8283177C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82831780: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82831784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82831788 size=476
    let mut pc: u32 = 0x82831788;
    'dispatch: loop {
        match pc {
            0x82831788 => {
    //   block [0x82831788..0x82831964)
	// 82831788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283178C: 489769D9  bl 0x831a8164
	ctx.lr = 0x82831790;
	sub_831A8130(ctx, base);
	// 82831790: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82831794: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831798: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283179C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828317A0: 3BCBBE48  addi r30, r11, -0x41b8
	ctx.r[30].s64 = ctx.r[11].s64 + -16824;
	// 828317A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828317A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828317AC: 38A0017B  li r5, 0x17b
	ctx.r[5].s64 = 379;
	// 828317B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828317B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828317B8: 386002F0  li r3, 0x2f0
	ctx.r[3].s64 = 752;
	// 828317BC: 485C0C2D  bl 0x82df23e8
	ctx.lr = 0x828317C0;
	sub_82DF23E8(ctx, base);
	// 828317C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828317C4: 41820010  beq 0x828317d4
	if ctx.cr[0].eq {
	pc = 0x828317D4; continue 'dispatch;
	}
	// 828317C8: 4BFFF701  bl 0x82830ec8
	ctx.lr = 0x828317CC;
	sub_82830EC8(ctx, base);
	// 828317CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828317D0: 48000008  b 0x828317d8
	pc = 0x828317D8; continue 'dispatch;
	// 828317D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828317D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828317DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828317E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828317E4: 4BFFE43D  bl 0x8282fc20
	ctx.lr = 0x828317E8;
	sub_8282FC20(ctx, base);
	// 828317E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828317EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828317F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828317F4: 4BA8E80D  bl 0x822c0000
	ctx.lr = 0x828317F8;
	sub_822C0000(ctx, base);
	// 828317F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828317FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82831800: 38A0017C  li r5, 0x17c
	ctx.r[5].s64 = 380;
	// 82831804: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82831808: 4BA8EBD1  bl 0x822c03d8
	ctx.lr = 0x8283180C;
	sub_822C03D8(ctx, base);
	// 8283180C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82831810: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82831814: 418200E0  beq 0x828318f4
	if ctx.cr[0].eq {
	pc = 0x828318F4; continue 'dispatch;
	}
	// 82831818: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283181C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82831820: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82831824: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82831828: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8283182C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82831830: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82831834: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82831838: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8283183C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82831840: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82831844: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82831848: 409A0008  bne cr6, 0x82831850
	if !ctx.cr[6].eq {
	pc = 0x82831850; continue 'dispatch;
	}
	// 8283184C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82831850: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82831854: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831858: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8283185C: 419A0024  beq cr6, 0x82831880
	if ctx.cr[6].eq {
	pc = 0x82831880; continue 'dispatch;
	}
	// 82831860: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82831864: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82831868: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283186C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82831870: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82831874: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82831878: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283187C: 4082FFE8  bne 0x82831864
	if !ctx.cr[0].eq {
	pc = 0x82831864; continue 'dispatch;
	}
	// 82831880: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82831884: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831888: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8283188C: 419A0024  beq cr6, 0x828318b0
	if ctx.cr[6].eq {
	pc = 0x828318B0; continue 'dispatch;
	}
	// 82831890: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82831894: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82831898: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283189C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828318A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828318A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828318A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828318AC: 4082FFE8  bne 0x82831894
	if !ctx.cr[0].eq {
	pc = 0x82831894; continue 'dispatch;
	}
	// 828318B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828318B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828318B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828318BC: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828318C0: 4864B381  bl 0x82e7cc40
	ctx.lr = 0x828318C4;
	sub_82E7CC40(ctx, base);
	// 828318C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828318C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828318CC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828318D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828318D4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828318D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828318DC: 4BF67655  bl 0x82798f30
	ctx.lr = 0x828318E0;
	sub_82798F30(ctx, base);
	// 828318E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828318E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828318E8: 4BF69D81  bl 0x8279b668
	ctx.lr = 0x828318EC;
	sub_8279B668(ctx, base);
	// 828318EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828318F0: 48000008  b 0x828318f8
	pc = 0x828318F8; continue 'dispatch;
	// 828318F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828318F8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828318FC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82831900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831908: 4BD66349  bl 0x82597c50
	ctx.lr = 0x8283190C;
	sub_82597C50(ctx, base);
	// 8283190C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82831910: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831918: 4BA8E6E9  bl 0x822c0000
	ctx.lr = 0x8283191C;
	sub_822C0000(ctx, base);
	// 8283191C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831920: 41820024  beq 0x82831944
	if ctx.cr[0].eq {
	pc = 0x82831944; continue 'dispatch;
	}
	// 82831924: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82831928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283192C: 419A0008  beq cr6, 0x82831934
	if ctx.cr[6].eq {
	pc = 0x82831934; continue 'dispatch;
	}
	// 82831930: 4BA8EF61  bl 0x822c0890
	ctx.lr = 0x82831934;
	sub_822C0890(ctx, base);
	// 82831934: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82831938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283193C: 419A0008  beq cr6, 0x82831944
	if ctx.cr[6].eq {
	pc = 0x82831944; continue 'dispatch;
	}
	// 82831940: 4BA8EF51  bl 0x822c0890
	ctx.lr = 0x82831944;
	sub_822C0890(ctx, base);
	// 82831944: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831948: 419A000C  beq cr6, 0x82831954
	if ctx.cr[6].eq {
	pc = 0x82831954; continue 'dispatch;
	}
	// 8283194C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82831950: 4BA8EF41  bl 0x822c0890
	ctx.lr = 0x82831954;
	sub_822C0890(ctx, base);
	// 82831954: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82831958: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8283195C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82831960: 48976854  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82831968 size=476
    let mut pc: u32 = 0x82831968;
    'dispatch: loop {
        match pc {
            0x82831968 => {
    //   block [0x82831968..0x82831B44)
	// 82831968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283196C: 489767F9  bl 0x831a8164
	ctx.lr = 0x82831970;
	sub_831A8130(ctx, base);
	// 82831970: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82831974: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831978: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283197C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82831980: 3BCBBE48  addi r30, r11, -0x41b8
	ctx.r[30].s64 = ctx.r[11].s64 + -16824;
	// 82831984: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82831988: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283198C: 38A002EF  li r5, 0x2ef
	ctx.r[5].s64 = 751;
	// 82831990: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82831994: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82831998: 386002A0  li r3, 0x2a0
	ctx.r[3].s64 = 672;
	// 8283199C: 485C0A4D  bl 0x82df23e8
	ctx.lr = 0x828319A0;
	sub_82DF23E8(ctx, base);
	// 828319A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828319A4: 41820010  beq 0x828319b4
	if ctx.cr[0].eq {
	pc = 0x828319B4; continue 'dispatch;
	}
	// 828319A8: 4BFFF699  bl 0x82831040
	ctx.lr = 0x828319AC;
	sub_82831040(ctx, base);
	// 828319AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828319B0: 48000008  b 0x828319b8
	pc = 0x828319B8; continue 'dispatch;
	// 828319B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828319B8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828319BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828319C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828319C4: 4BFFE57D  bl 0x8282ff40
	ctx.lr = 0x828319C8;
	sub_8282FF40(ctx, base);
	// 828319C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828319CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828319D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828319D4: 4BA8E62D  bl 0x822c0000
	ctx.lr = 0x828319D8;
	sub_822C0000(ctx, base);
	// 828319D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828319DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828319E0: 38A002F0  li r5, 0x2f0
	ctx.r[5].s64 = 752;
	// 828319E4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828319E8: 4BA8E9F1  bl 0x822c03d8
	ctx.lr = 0x828319EC;
	sub_822C03D8(ctx, base);
	// 828319EC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828319F0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828319F4: 418200E0  beq 0x82831ad4
	if ctx.cr[0].eq {
	pc = 0x82831AD4; continue 'dispatch;
	}
	// 828319F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828319FC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82831A00: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82831A04: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82831A08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82831A0C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82831A10: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82831A14: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82831A18: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82831A1C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82831A20: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82831A24: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82831A28: 409A0008  bne cr6, 0x82831a30
	if !ctx.cr[6].eq {
	pc = 0x82831A30; continue 'dispatch;
	}
	// 82831A2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82831A30: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82831A34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831A38: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82831A3C: 419A0024  beq cr6, 0x82831a60
	if ctx.cr[6].eq {
	pc = 0x82831A60; continue 'dispatch;
	}
	// 82831A40: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82831A44: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82831A48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82831A4C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82831A50: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82831A54: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82831A58: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82831A5C: 4082FFE8  bne 0x82831a44
	if !ctx.cr[0].eq {
	pc = 0x82831A44; continue 'dispatch;
	}
	// 82831A60: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82831A64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831A68: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82831A6C: 419A0024  beq cr6, 0x82831a90
	if ctx.cr[6].eq {
	pc = 0x82831A90; continue 'dispatch;
	}
	// 82831A70: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82831A74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82831A78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82831A7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82831A80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82831A84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82831A88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82831A8C: 4082FFE8  bne 0x82831a74
	if !ctx.cr[0].eq {
	pc = 0x82831A74; continue 'dispatch;
	}
	// 82831A90: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82831A94: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82831A98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82831A9C: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82831AA0: 4864B1A1  bl 0x82e7cc40
	ctx.lr = 0x82831AA4;
	sub_82E7CC40(ctx, base);
	// 82831AA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82831AA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82831AAC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82831AB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82831AB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82831AB8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82831ABC: 4BF67475  bl 0x82798f30
	ctx.lr = 0x82831AC0;
	sub_82798F30(ctx, base);
	// 82831AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82831AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831AC8: 4BF69BA1  bl 0x8279b668
	ctx.lr = 0x82831ACC;
	sub_8279B668(ctx, base);
	// 82831ACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831AD0: 48000008  b 0x82831ad8
	pc = 0x82831AD8; continue 'dispatch;
	// 82831AD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82831AD8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82831ADC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82831AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831AE8: 4BD66169  bl 0x82597c50
	ctx.lr = 0x82831AEC;
	sub_82597C50(ctx, base);
	// 82831AEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82831AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82831AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831AF8: 4BA8E509  bl 0x822c0000
	ctx.lr = 0x82831AFC;
	sub_822C0000(ctx, base);
	// 82831AFC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831B00: 41820024  beq 0x82831b24
	if ctx.cr[0].eq {
	pc = 0x82831B24; continue 'dispatch;
	}
	// 82831B04: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82831B08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82831B0C: 419A0008  beq cr6, 0x82831b14
	if ctx.cr[6].eq {
	pc = 0x82831B14; continue 'dispatch;
	}
	// 82831B10: 4BA8ED81  bl 0x822c0890
	ctx.lr = 0x82831B14;
	sub_822C0890(ctx, base);
	// 82831B14: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82831B18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82831B1C: 419A0008  beq cr6, 0x82831b24
	if ctx.cr[6].eq {
	pc = 0x82831B24; continue 'dispatch;
	}
	// 82831B20: 4BA8ED71  bl 0x822c0890
	ctx.lr = 0x82831B24;
	sub_822C0890(ctx, base);
	// 82831B24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82831B28: 419A000C  beq cr6, 0x82831b34
	if ctx.cr[6].eq {
	pc = 0x82831B34; continue 'dispatch;
	}
	// 82831B2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82831B30: 4BA8ED61  bl 0x822c0890
	ctx.lr = 0x82831B34;
	sub_822C0890(ctx, base);
	// 82831B34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82831B38: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82831B3C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82831B40: 48976674  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82831B48 size=76
    let mut pc: u32 = 0x82831B48;
    'dispatch: loop {
        match pc {
            0x82831B48 => {
    //   block [0x82831B48..0x82831B94)
	// 82831B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82831B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82831B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82831B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831B5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82831B60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82831B64: 4BFFFAA5  bl 0x82831608
	ctx.lr = 0x82831B68;
	sub_82831608(ctx, base);
	// 82831B68: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831B6C: 4182000C  beq 0x82831b78
	if ctx.cr[0].eq {
	pc = 0x82831B78; continue 'dispatch;
	}
	// 82831B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831B74: 485C0865  bl 0x82df23d8
	ctx.lr = 0x82831B78;
	sub_82DF23D8(ctx, base);
	// 82831B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831B7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82831B80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82831B84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82831B88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82831B8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82831B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82831B98 size=712
    let mut pc: u32 = 0x82831B98;
    'dispatch: loop {
        match pc {
            0x82831B98 => {
    //   block [0x82831B98..0x82831E60)
	// 82831B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831B9C: 489765CD  bl 0x831a8168
	ctx.lr = 0x82831BA0;
	sub_831A8130(ctx, base);
	// 82831BA0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82831BA4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82831E60 size=128
    let mut pc: u32 = 0x82831E60;
    'dispatch: loop {
        match pc {
            0x82831E60 => {
    //   block [0x82831E60..0x82831EE0)
	// 82831E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831E64: 48976309  bl 0x831a816c
	ctx.lr = 0x82831E68;
	sub_831A8130(ctx, base);
	// 82831E68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831E6C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82831E70: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82831E74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82831E78: 3BEBB294  addi r31, r11, -0x4d6c
	ctx.r[31].s64 = ctx.r[11].s64 + -19820;
	// 82831E7C: 816AB29C  lwz r11, -0x4d64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19812 as u32) ) } as u64;
	// 82831E80: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82831E84: 40820024  bne 0x82831ea8
	if !ctx.cr[0].eq {
	pc = 0x82831EA8; continue 'dispatch;
	}
	// 82831E88: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82831E8C: 3D008283  lis r8, -0x7d7d
	ctx.r[8].s64 = -2105344000;
	// 82831E90: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82831E94: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82831E98: 39080BB8  addi r8, r8, 0xbb8
	ctx.r[8].s64 = ctx.r[8].s64 + 3000;
	// 82831E9C: 916AB29C  stw r11, -0x4d64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19812 as u32), ctx.r[11].u32 ) };
	// 82831EA0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82831EA4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82831EA8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82831EAC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82831EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831EB4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82831EB8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82831EBC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82831EC0: 4BE22701  bl 0x826545c0
	ctx.lr = 0x82831EC4;
	sub_826545C0(ctx, base);
	// 82831EC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831EC8: 4182000C  beq 0x82831ed4
	if ctx.cr[0].eq {
	pc = 0x82831ED4; continue 'dispatch;
	}
	// 82831ECC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82831ED0: 48000008  b 0x82831ed8
	pc = 0x82831ED8; continue 'dispatch;
	// 82831ED4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82831ED8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82831EDC: 489762E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82831EE0 size=128
    let mut pc: u32 = 0x82831EE0;
    'dispatch: loop {
        match pc {
            0x82831EE0 => {
    //   block [0x82831EE0..0x82831F60)
	// 82831EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831EE4: 48976289  bl 0x831a816c
	ctx.lr = 0x82831EE8;
	sub_831A8130(ctx, base);
	// 82831EE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831EEC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82831EF0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82831EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82831EF8: 3BEBB2A0  addi r31, r11, -0x4d60
	ctx.r[31].s64 = ctx.r[11].s64 + -19808;
	// 82831EFC: 816AB2A8  lwz r11, -0x4d58(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19800 as u32) ) } as u64;
	// 82831F00: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82831F04: 40820024  bne 0x82831f28
	if !ctx.cr[0].eq {
	pc = 0x82831F28; continue 'dispatch;
	}
	// 82831F08: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82831F0C: 3D008283  lis r8, -0x7d7d
	ctx.r[8].s64 = -2105344000;
	// 82831F10: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82831F14: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82831F18: 39080C00  addi r8, r8, 0xc00
	ctx.r[8].s64 = ctx.r[8].s64 + 3072;
	// 82831F1C: 916AB2A8  stw r11, -0x4d58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19800 as u32), ctx.r[11].u32 ) };
	// 82831F20: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82831F24: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82831F28: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82831F2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82831F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831F34: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82831F38: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82831F3C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82831F40: 4BE22681  bl 0x826545c0
	ctx.lr = 0x82831F44;
	sub_826545C0(ctx, base);
	// 82831F44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82831F48: 4182000C  beq 0x82831f54
	if ctx.cr[0].eq {
	pc = 0x82831F54; continue 'dispatch;
	}
	// 82831F4C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82831F50: 48000008  b 0x82831f58
	pc = 0x82831F58; continue 'dispatch;
	// 82831F54: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82831F58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82831F5C: 48976260  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82831F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82831F60 size=684
    let mut pc: u32 = 0x82831F60;
    'dispatch: loop {
        match pc {
            0x82831F60 => {
    //   block [0x82831F60..0x8283220C)
	// 82831F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82831F64: 489761FD  bl 0x831a8160
	ctx.lr = 0x82831F68;
	sub_831A8130(ctx, base);
	// 82831F68: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82831F6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82831F70: 4BFE82C9  bl 0x8281a238
	ctx.lr = 0x82831F74;
	sub_8281A238(ctx, base);
	// 82831F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831F78: 4BFB96C1  bl 0x827eb638
	ctx.lr = 0x82831F7C;
	sub_827EB638(ctx, base);
	// 82831F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82831F80: 4BFBA251  bl 0x827ec1d0
	ctx.lr = 0x82831F84;
	sub_827EC1D0(ctx, base);
	// 82831F84: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82831F88: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82831F8C: 41820094  beq 0x82832020
	if ctx.cr[0].eq {
	pc = 0x82832020; continue 'dispatch;
	}
	// 82831F90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82831F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831F98: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82831F9C: 485C1A6D  bl 0x82df3a08
	ctx.lr = 0x82831FA0;
	sub_82DF3A08(ctx, base);
	// 82831FA0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82831FA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82831FA8: 388BBA40  addi r4, r11, -0x45c0
	ctx.r[4].s64 = ctx.r[11].s64 + -17856;
	// 82831FAC: 485C1A5D  bl 0x82df3a08
	ctx.lr = 0x82831FB0;
	sub_82DF3A08(ctx, base);
	// 82831FB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82831FB4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82831FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82831FBC: 4BFB8365  bl 0x827ea320
	ctx.lr = 0x82831FC0;
	sub_827EA320(ctx, base);
	// 82831FC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82831FC4: 485C1465  bl 0x82df3428
	ctx.lr = 0x82831FC8;
	sub_82DF3428(ctx, base);
	// 82831FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831FCC: 485C145D  bl 0x82df3428
	ctx.lr = 0x82831FD0;
	sub_82DF3428(ctx, base);
	// 82831FD0: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 82831FD4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82831FD8: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82831FDC: 396B00A8  addi r11, r11, 0xa8
	ctx.r[11].s64 = ctx.r[11].s64 + 168;
	// 82831FE0: 388ABF20  addi r4, r10, -0x40e0
	ctx.r[4].s64 = ctx.r[10].s64 + -16608;
	// 82831FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82831FE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82831FEC: 485C1A1D  bl 0x82df3a08
	ctx.lr = 0x82831FF0;
	sub_82DF3A08(ctx, base);
	// 82831FF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82831FF4: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82831FF8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82831FFC: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82832000: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 82832004: 4BFFFE5D  bl 0x82831e60
	ctx.lr = 0x82832008;
	sub_82831E60(ctx, base);
	// 82832008: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8283200C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82832010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832014: 4BFB87F5  bl 0x827ea808
	ctx.lr = 0x82832018;
	sub_827EA808(ctx, base);
	// 82832018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283201C: 485C140D  bl 0x82df3428
	ctx.lr = 0x82832020;
	sub_82DF3428(ctx, base);
	// 82832020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82832024: 4812E53D  bl 0x82960560
	ctx.lr = 0x82832028;
	sub_82960560(ctx, base);
	// 82832028: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8283202C: 41820058  beq 0x82832084
	if ctx.cr[0].eq {
	pc = 0x82832084; continue 'dispatch;
	}
	// 82832030: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82832034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832038: 388BB334  addi r4, r11, -0x4ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -19660;
	// 8283203C: 485C19CD  bl 0x82df3a08
	ctx.lr = 0x82832040;
	sub_82DF3A08(ctx, base);
	// 82832040: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82832044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82832048: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283204C: 4BFBC7D5  bl 0x827ee820
	ctx.lr = 0x82832050;
	sub_827EE820(ctx, base);
	// 82832050: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82832054: 395E0254  addi r10, r30, 0x254
	ctx.r[10].s64 = ctx.r[30].s64 + 596;
	// 82832058: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8283205C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82832060: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832064: 917E0254  stw r11, 0x254(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 82832068: 4BA923F9  bl 0x822c4460
	ctx.lr = 0x8283206C;
	sub_822C4460(ctx, base);
	// 8283206C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82832070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832074: 419A0008  beq cr6, 0x8283207c
	if ctx.cr[6].eq {
	pc = 0x8283207C; continue 'dispatch;
	}
	// 82832078: 4BA8E819  bl 0x822c0890
	ctx.lr = 0x8283207C;
	sub_822C0890(ctx, base);
	// 8283207C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832080: 485C13A9  bl 0x82df3428
	ctx.lr = 0x82832084;
	sub_82DF3428(ctx, base);
	// 82832084: 817E0254  lwz r11, 0x254(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(596 as u32) ) } as u64;
	// 82832088: 3B9E0254  addi r28, r30, 0x254
	ctx.r[28].s64 = ctx.r[30].s64 + 596;
	// 8283208C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82832090: 419A0174  beq cr6, 0x82832204
	if ctx.cr[6].eq {
	pc = 0x82832204; continue 'dispatch;
	}
	// 82832094: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832098: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 8283209C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828320A0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828320A4: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828320A8: 4866E689  bl 0x82ea0730
	ctx.lr = 0x828320AC;
	sub_82EA0730(ctx, base);
	// 828320AC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828320B0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828320B4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828320B8: C02A9450  lfs f1, -0x6bb0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828320BC: 486E8135  bl 0x82f1a1f0
	ctx.lr = 0x828320C0;
	sub_82F1A1F0(ctx, base);
	// 828320C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828320C4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828320C8: 4869A921  bl 0x82ecc9e8
	ctx.lr = 0x828320CC;
	sub_82ECC9E8(ctx, base);
	// 828320CC: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 828320D0: 934100A4  stw r26, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[26].u32 ) };
	// 828320D4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 828320D8: 99610150  stb r11, 0x150(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u8 ) };
	// 828320DC: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 828320E0: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828320E4: 4866E64D  bl 0x82ea0730
	ctx.lr = 0x828320E8;
	sub_82EA0730(ctx, base);
	// 828320E8: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 828320EC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828320F0: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828320F4: 486997ED  bl 0x82ecb8e0
	ctx.lr = 0x828320F8;
	sub_82ECB8E0(ctx, base);
	// 828320F8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 828320FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82832100: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82832104: 388BBE48  addi r4, r11, -0x41b8
	ctx.r[4].s64 = ctx.r[11].s64 + -16824;
	// 82832108: 38A000EE  li r5, 0xee
	ctx.r[5].s64 = 238;
	// 8283210C: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 82832110: 485C02D9  bl 0x82df23e8
	ctx.lr = 0x82832114;
	sub_82DF23E8(ctx, base);
	// 82832114: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82832118: 41820018  beq 0x82832130
	if ctx.cr[0].eq {
	pc = 0x82832130; continue 'dispatch;
	}
	// 8283211C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82832120: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 82832124: 4BABBD8D  bl 0x822edeb0
	ctx.lr = 0x82832128;
	sub_822EDEB0(ctx, base);
	// 82832128: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283212C: 48000008  b 0x82832134
	pc = 0x82832134; continue 'dispatch;
	// 82832130: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82832134: 3BFE025C  addi r31, r30, 0x25c
	ctx.r[31].s64 = ctx.r[30].s64 + 604;
	// 82832138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283213C: 4BB2B1C5  bl 0x8235d300
	ctx.lr = 0x82832140;
	sub_8235D300(ctx, base);
	// 82832140: 807E025C  lwz r3, 0x25c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(604 as u32) ) } as u64;
	// 82832144: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832148: 419A009C  beq cr6, 0x828321e4
	if ctx.cr[6].eq {
	pc = 0x828321E4; continue 'dispatch;
	}
	// 8283214C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82832150: 808B6898  lwz r4, 0x6898(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26776 as u32) ) } as u64;
	// 82832154: 4BC5D24D  bl 0x8248f3a0
	ctx.lr = 0x82832158;
	sub_8248F3A0(ctx, base);
	// 82832158: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283215C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832160: 38802001  li r4, 0x2001
	ctx.r[4].s64 = 8193;
	// 82832164: 80AB8610  lwz r5, -0x79f0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31216 as u32) ) } as u64;
	// 82832168: 4BC5D011  bl 0x8248f178
	ctx.lr = 0x8283216C;
	sub_8248F178(ctx, base);
	// 8283216C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82832170: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832174: 38802006  li r4, 0x2006
	ctx.r[4].s64 = 8198;
	// 82832178: 4BC5D039  bl 0x8248f1b0
	ctx.lr = 0x8283217C;
	sub_8248F1B0(ctx, base);
	// 8283217C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82832180: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82832188: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283218C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82832190: 419A0024  beq cr6, 0x828321b4
	if ctx.cr[6].eq {
	pc = 0x828321B4; continue 'dispatch;
	}
	// 82832194: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82832198: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283219C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828321A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828321A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828321A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828321AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828321B0: 4082FFE8  bne 0x82832198
	if !ctx.cr[0].eq {
	pc = 0x82832198; continue 'dispatch;
	}
	// 828321B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828321B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828321BC: 4BABBDA5  bl 0x822edf60
	ctx.lr = 0x828321C0;
	sub_822EDF60(ctx, base);
	// 828321C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828321C4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828321C8: 481E14B9  bl 0x82a13680
	ctx.lr = 0x828321CC;
	sub_82A13680(ctx, base);
	// 828321CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828321D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828321D4: 4BABB54D  bl 0x822ed720
	ctx.lr = 0x828321D8;
	sub_822ED720(ctx, base);
	// 828321D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828321DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828321E0: 4BCDEB61  bl 0x82510d40
	ctx.lr = 0x828321E4;
	sub_82510D40(ctx, base);
	// 828321E4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828321E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828321EC: 419A0008  beq cr6, 0x828321f4
	if ctx.cr[6].eq {
	pc = 0x828321F4; continue 'dispatch;
	}
	// 828321F0: 4BAB6079  bl 0x822e8268
	ctx.lr = 0x828321F4;
	sub_822E8268(ctx, base);
	// 828321F4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828321F8: 419A000C  beq cr6, 0x82832204
	if ctx.cr[6].eq {
	pc = 0x82832204; continue 'dispatch;
	}
	// 828321FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82832200: 4BAB6069  bl 0x822e8268
	ctx.lr = 0x82832204;
	sub_822E8268(ctx, base);
	// 82832204: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82832208: 48975FA8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82832210 size=96
    let mut pc: u32 = 0x82832210;
    'dispatch: loop {
        match pc {
            0x82832210 => {
    //   block [0x82832210..0x82832270)
	// 82832210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82832214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82832218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283221C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82832220: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82832224: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82832228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283222C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82832230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832234: 388BBF2C  addi r4, r11, -0x40d4
	ctx.r[4].s64 = ctx.r[11].s64 + -16596;
	// 82832238: 485C17D1  bl 0x82df3a08
	ctx.lr = 0x8283223C;
	sub_82DF3A08(ctx, base);
	// 8283223C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82832240: 38BF02E4  addi r5, r31, 0x2e4
	ctx.r[5].s64 = ctx.r[31].s64 + 740;
	// 82832244: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832248: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283224C: 4BDC5E3D  bl 0x825f8088
	ctx.lr = 0x82832250;
	sub_825F8088(ctx, base);
	// 82832250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832254: 485C11D5  bl 0x82df3428
	ctx.lr = 0x82832258;
	sub_82DF3428(ctx, base);
	// 82832258: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283225C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82832260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82832264: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82832268: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283226C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82832270 size=696
    let mut pc: u32 = 0x82832270;
    'dispatch: loop {
        match pc {
            0x82832270 => {
    //   block [0x82832270..0x82832528)
	// 82832270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82832274: 48975EED  bl 0x831a8160
	ctx.lr = 0x82832278;
	sub_831A8130(ctx, base);
	// 82832278: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283227C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82832280: 4BFFFCE1  bl 0x82831f60
	ctx.lr = 0x82832284;
	sub_82831F60(ctx, base);
	// 82832284: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82832288: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283228C: 3BABBE48  addi r29, r11, -0x41b8
	ctx.r[29].s64 = ctx.r[11].s64 + -16824;
	// 82832290: 38A001E4  li r5, 0x1e4
	ctx.r[5].s64 = 484;
	// 82832294: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82832298: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8283229C: 485C014D  bl 0x82df23e8
	ctx.lr = 0x828322A0;
	sub_82DF23E8(ctx, base);
	// 828322A0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828322A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828322A8: 41820020  beq 0x828322c8
	if ctx.cr[0].eq {
	pc = 0x828322C8; continue 'dispatch;
	}
	// 828322AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828322B0: 485DFC29  bl 0x82e11ed8
	ctx.lr = 0x828322B4;
	sub_82E11ED8(ctx, base);
	// 828322B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828322B8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828322BC: 396BBA34  addi r11, r11, -0x45cc
	ctx.r[11].s64 = ctx.r[11].s64 + -17868;
	// 828322C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828322C4: 48000008  b 0x828322cc
	pc = 0x828322CC; continue 'dispatch;
	// 828322C8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828322CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828322D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828322D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828322D8: 4BFFDA11  bl 0x8282fce8
	ctx.lr = 0x828322DC;
	sub_8282FCE8(ctx, base);
	// 828322DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828322E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828322E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828322E8: 4BA8DD19  bl 0x822c0000
	ctx.lr = 0x828322EC;
	sub_822C0000(ctx, base);
	// 828322EC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828322F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828322F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828322F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828322FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82832300: 419A0024  beq cr6, 0x82832324
	if ctx.cr[6].eq {
	pc = 0x82832324; continue 'dispatch;
	}
	// 82832304: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82832308: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283230C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82832310: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82832314: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82832318: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283231C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82832320: 4082FFE8  bne 0x82832308
	if !ctx.cr[0].eq {
	pc = 0x82832308; continue 'dispatch;
	}
	// 82832324: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82832328: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8283232C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82832330: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82832334: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 82832338: 4BCDE6C1  bl 0x825109f8
	ctx.lr = 0x8283233C;
	sub_825109F8(ctx, base);
	// 8283233C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82832340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832344: 419A0008  beq cr6, 0x8283234c
	if ctx.cr[6].eq {
	pc = 0x8283234C; continue 'dispatch;
	}
	// 82832348: 4BA8E549  bl 0x822c0890
	ctx.lr = 0x8283234C;
	sub_822C0890(ctx, base);
	// 8283234C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82832350: 419A000C  beq cr6, 0x8283235c
	if ctx.cr[6].eq {
	pc = 0x8283235C; continue 'dispatch;
	}
	// 82832354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832358: 4BA8E539  bl 0x822c0890
	ctx.lr = 0x8283235C;
	sub_822C0890(ctx, base);
	// 8283235C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82832360: 4BFB9E71  bl 0x827ec1d0
	ctx.lr = 0x82832364;
	sub_827EC1D0(ctx, base);
	// 82832364: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82832368: 41820054  beq 0x828323bc
	if ctx.cr[0].eq {
	pc = 0x828323BC; continue 'dispatch;
	}
	// 8283236C: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 82832370: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82832374: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82832378: 396BF878  addi r11, r11, -0x788
	ctx.r[11].s64 = ctx.r[11].s64 + -1928;
	// 8283237C: 388ABF38  addi r4, r10, -0x40c8
	ctx.r[4].s64 = ctx.r[10].s64 + -16584;
	// 82832380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832384: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82832388: 485C1681  bl 0x82df3a08
	ctx.lr = 0x8283238C;
	sub_82DF3A08(ctx, base);
	// 8283238C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82832390: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82832394: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82832398: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8283239C: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	// 828323A0: 4BFFFB41  bl 0x82831ee0
	ctx.lr = 0x828323A4;
	sub_82831EE0(ctx, base);
	// 828323A4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 828323A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828323AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828323B0: 4BFB8459  bl 0x827ea808
	ctx.lr = 0x828323B4;
	sub_827EA808(ctx, base);
	// 828323B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828323B8: 485C1071  bl 0x82df3428
	ctx.lr = 0x828323BC;
	sub_82DF3428(ctx, base);
	// 828323BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828323C0: 4BFB9E11  bl 0x827ec1d0
	ctx.lr = 0x828323C4;
	sub_827EC1D0(ctx, base);
	// 828323C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828323C8: 4182011C  beq 0x828324e4
	if ctx.cr[0].eq {
	pc = 0x828324E4; continue 'dispatch;
	}
	// 828323CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828323D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828323D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828323D8: 4E800421  bctrl
	ctx.lr = 0x828323DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828323DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828323E0: 41820104  beq 0x828324e4
	if ctx.cr[0].eq {
	pc = 0x828324E4; continue 'dispatch;
	}
	// 828323E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828323E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828323EC: 3B6BB334  addi r27, r11, -0x4ccc
	ctx.r[27].s64 = ctx.r[11].s64 + -19660;
	// 828323F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828323F4: 485C1615  bl 0x82df3a08
	ctx.lr = 0x828323F8;
	sub_82DF3A08(ctx, base);
	// 828323F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828323FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832400: 4837B861  bl 0x82badc60
	ctx.lr = 0x82832404;
	sub_82BADC60(ctx, base);
	// 82832404: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82832408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283240C: 485C101D  bl 0x82df3428
	ctx.lr = 0x82832410;
	sub_82DF3428(ctx, base);
	// 82832410: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82832414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832418: 485C15F1  bl 0x82df3a08
	ctx.lr = 0x8283241C;
	sub_82DF3A08(ctx, base);
	// 8283241C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82832420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832424: 4837B83D  bl 0x82badc60
	ctx.lr = 0x82832428;
	sub_82BADC60(ctx, base);
	// 82832428: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8283242C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832430: 485C0FF9  bl 0x82df3428
	ctx.lr = 0x82832434;
	sub_82DF3428(ctx, base);
	// 82832434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82832438: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283243C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82832440: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82832444: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82832448: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283244C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82832450: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82832454: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82832458: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8283245C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82832460: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82832464: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82832468: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283246C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82832470: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82832474: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82832478: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8283247C: C029D8B0  lfs f1, -0x2750(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82832480: 4814AD71  bl 0x8297d1f0
	ctx.lr = 0x82832484;
	sub_8297D1F0(ctx, base);
	// 82832484: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82832488: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283248C: 38A001F5  li r5, 0x1f5
	ctx.r[5].s64 = 501;
	// 82832490: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82832494: 4BA8DF45  bl 0x822c03d8
	ctx.lr = 0x82832498;
	sub_822C03D8(ctx, base);
	// 82832498: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283249C: 4182001C  beq 0x828324b8
	if ctx.cr[0].eq {
	pc = 0x828324B8; continue 'dispatch;
	}
	// 828324A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828324A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828324A8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828324AC: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828324B0: 4814AD89  bl 0x8297d238
	ctx.lr = 0x828324B4;
	sub_8297D238(ctx, base);
	// 828324B4: 48000008  b 0x828324bc
	pc = 0x828324BC; continue 'dispatch;
	// 828324B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828324BC: 817E0280  lwz r11, 0x280(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(640 as u32) ) } as u64;
	// 828324C0: 907E0280  stw r3, 0x280(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(640 as u32), ctx.r[3].u32 ) };
	// 828324C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828324C8: 419A001C  beq cr6, 0x828324e4
	if ctx.cr[6].eq {
	pc = 0x828324E4; continue 'dispatch;
	}
	// 828324CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828324D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828324D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828324D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828324DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828324E0: 4E800421  bctrl
	ctx.lr = 0x828324E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828324E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828324E8: 481E1199  bl 0x82a13680
	ctx.lr = 0x828324EC;
	sub_82A13680(ctx, base);
	// 828324EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828324F0: 394002B0  li r10, 0x2b0
	ctx.r[10].s64 = 688;
	// 828324F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828324F8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82832528 size=540
    let mut pc: u32 = 0x82832528;
    'dispatch: loop {
        match pc {
            0x82832528 => {
    //   block [0x82832528..0x82832744)
	// 82832528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283252C: 48975C41  bl 0x831a816c
	ctx.lr = 0x82832530;
	sub_831A8130(ctx, base);
	// 82832530: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82832534: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82832538: 4BFFFA29  bl 0x82831f60
	ctx.lr = 0x8283253C;
	sub_82831F60(ctx, base);
	// 8283253C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82832540: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82832544: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82832548: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8283254C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82832550: 4866E1E1  bl 0x82ea0730
	ctx.lr = 0x82832554;
	sub_82EA0730(ctx, base);
	// 82832554: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82832558: 3FA08208  lis r29, -0x7df8
	ctx.r[29].s64 = -2113404928;
	// 8283255C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82832560: C03DBA28  lfs f1, -0x45d8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17880 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82832564: 486E7C8D  bl 0x82f1a1f0
	ctx.lr = 0x82832568;
	sub_82F1A1F0(ctx, base);
	// 82832568: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283256C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82832570: 388BBE48  addi r4, r11, -0x41b8
	ctx.r[4].s64 = ctx.r[11].s64 + -16824;
	// 82832574: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82832578: 38A0031C  li r5, 0x31c
	ctx.r[5].s64 = 796;
	// 8283257C: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82832580: 485BFE69  bl 0x82df23e8
	ctx.lr = 0x82832584;
	sub_82DF23E8(ctx, base);
	// 82832584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82832588: 41820018  beq 0x828325a0
	if ctx.cr[0].eq {
	pc = 0x828325A0; continue 'dispatch;
	}
	// 8283258C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82832590: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82832594: 4812D055  bl 0x8295f5e8
	ctx.lr = 0x82832598;
	sub_8295F5E8(ctx, base);
	// 82832598: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283259C: 48000008  b 0x828325a4
	pc = 0x828325A4; continue 'dispatch;
	// 828325A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828325A4: 3BFE0280  addi r31, r30, 0x280
	ctx.r[31].s64 = ctx.r[30].s64 + 640;
	// 828325A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828325AC: 4BF2604D  bl 0x827585f8
	ctx.lr = 0x828325B0;
	sub_827585F8(ctx, base);
	// 828325B0: 817E0280  lwz r11, 0x280(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(640 as u32) ) } as u64;
	// 828325B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828325B8: 419A0050  beq cr6, 0x82832608
	if ctx.cr[6].eq {
	pc = 0x82832608; continue 'dispatch;
	}
	// 828325BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828325C0: 4812CFD9  bl 0x8295f598
	ctx.lr = 0x828325C4;
	sub_8295F598(ctx, base);
	// 828325C4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828325C8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828325CC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 828325D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828325D4: 816B6720  lwz r11, 0x6720(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26400 as u32) ) } as u64;
	// 828325D8: 814A8614  lwz r10, -0x79ec(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31212 as u32) ) } as u64;
	// 828325DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828325E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828325E4: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 828325E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828325EC: 912B0060  stw r9, 0x60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 828325F0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828325F4: 4812CEB5  bl 0x8295f4a8
	ctx.lr = 0x828325F8;
	sub_8295F4A8(ctx, base);
	// 828325F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828325FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832600: 419A0008  beq cr6, 0x82832608
	if ctx.cr[6].eq {
	pc = 0x82832608; continue 'dispatch;
	}
	// 82832604: 4BA8E28D  bl 0x822c0890
	ctx.lr = 0x82832608;
	sub_822C0890(ctx, base);
	// 82832608: 807E0258  lwz r3, 0x258(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(600 as u32) ) } as u64;
	// 8283260C: 817E0254  lwz r11, 0x254(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(596 as u32) ) } as u64;
	// 82832610: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832614: 419A0024  beq cr6, 0x82832638
	if ctx.cr[6].eq {
	pc = 0x82832638; continue 'dispatch;
	}
	// 82832618: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 8283261C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82832620: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82832624: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82832628: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8283262C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82832630: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82832634: 4082FFE8  bne 0x8283261c
	if !ctx.cr[0].eq {
	pc = 0x8283261C; continue 'dispatch;
	}
	// 82832638: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8283263C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832640: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82832644: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 82832648: 419A0008  beq cr6, 0x82832650
	if ctx.cr[6].eq {
	pc = 0x82832650; continue 'dispatch;
	}
	// 8283264C: 4BA8E245  bl 0x822c0890
	ctx.lr = 0x82832650;
	sub_822C0890(ctx, base);
	// 82832650: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82832654: 418200D0  beq 0x82832724
	if ctx.cr[0].eq {
	pc = 0x82832724; continue 'dispatch;
	}
	// 82832658: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8283265C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832660: 3BEBB2AC  addi r31, r11, -0x4d54
	ctx.r[31].s64 = ctx.r[11].s64 + -19796;
	// 82832664: 816AB2DC  lwz r11, -0x4d24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19748 as u32) ) } as u64;
	// 82832668: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8283266C: 40820074  bne 0x828326e0
	if !ctx.cr[0].eq {
	pc = 0x828326E0; continue 'dispatch;
	}
	// 82832670: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82832674: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82832678: 916AB2DC  stw r11, -0x4d24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19748 as u32), ctx.r[11].u32 ) };
	// 8283267C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832680: 3889B334  addi r4, r9, -0x4ccc
	ctx.r[4].s64 = ctx.r[9].s64 + -19660;
	// 82832684: 485C1385  bl 0x82df3a08
	ctx.lr = 0x82832688;
	sub_82DF3A08(ctx, base);
	// 82832688: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283268C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82832690: 388BBF44  addi r4, r11, -0x40bc
	ctx.r[4].s64 = ctx.r[11].s64 + -16572;
	// 82832694: 485C1375  bl 0x82df3a08
	ctx.lr = 0x82832698;
	sub_82DF3A08(ctx, base);
	// 82832698: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283269C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828326A0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828326A4: 3D008324  lis r8, -0x7cdc
	ctx.r[8].s64 = -2094792704;
	// 828326A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828326AC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828326B0: 3868FB78  addi r3, r8, -0x488
	ctx.r[3].s64 = ctx.r[8].s64 + -1160;
	// 828326B4: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828326B8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828326BC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828326C0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828326C4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828326C8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828326CC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828326D0: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828326D4: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828326D8: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828326DC: 48975DFD  bl 0x831a84d8
	ctx.lr = 0x828326E0;
	sub_831A84D8(ctx, base);
	// 828326E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828326E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828326E8: 4BFB9EE1  bl 0x827ec5c8
	ctx.lr = 0x828326EC;
	sub_827EC5C8(ctx, base);
	// 828326EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828326F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828326F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828326F8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828326FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82832700: 4BFBA141  bl 0x827ec840
	ctx.lr = 0x82832704;
	sub_827EC840(ctx, base);
	// 82832704: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82832708: 4182001C  beq 0x82832724
	if ctx.cr[0].eq {
	pc = 0x82832724; continue 'dispatch;
	}
	// 8283270C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82832710: C03DBA28  lfs f1, -0x45d8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17880 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82832714: 4BFB9B75  bl 0x827ec288
	ctx.lr = 0x82832718;
	sub_827EC288(ctx, base);
	// 82832718: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283271C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82832720: 4BFB9B51  bl 0x827ec270
	ctx.lr = 0x82832724;
	sub_827EC270(ctx, base);
	// 82832724: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82832728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283272C: 388BBAF4  addi r4, r11, -0x450c
	ctx.r[4].s64 = ctx.r[11].s64 + -17676;
	// 82832730: 4BFE5CD9  bl 0x82818408
	ctx.lr = 0x82832734;
	sub_82818408(ctx, base);
	// 82832734: C01E0288  lfs f0, 0x288(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82832738: D01E0294  stfs f0, 0x294(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 8283273C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82832740: 48975A7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82832748 size=272
    let mut pc: u32 = 0x82832748;
    'dispatch: loop {
        match pc {
            0x82832748 => {
    //   block [0x82832748..0x82832858)
	// 82832748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283274C: 48975A21  bl 0x831a816c
	ctx.lr = 0x82832750;
	sub_831A8130(ctx, base);
	// 82832750: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82832754: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283275C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82832760: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82832764: 808B8654  lwz r4, -0x79ac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31148 as u32) ) } as u64;
	// 82832768: 4BAF9FC1  bl 0x8232c728
	ctx.lr = 0x8283276C;
	sub_8232C728(ctx, base);
	// 8283276C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82832770: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82832774: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82832778: 4BF87BF9  bl 0x827ba370
	ctx.lr = 0x8283277C;
	sub_827BA370(ctx, base);
	// 8283277C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82832780: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82832784: 4BF877B5  bl 0x827b9f38
	ctx.lr = 0x82832788;
	sub_827B9F38(ctx, base);
	// 82832788: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283278C: 41820094  beq 0x82832820
	if ctx.cr[0].eq {
	pc = 0x82832820; continue 'dispatch;
	}
	// 82832790: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82832794: 4BFEBD75  bl 0x8281e508
	ctx.lr = 0x82832798;
	sub_8281E508(ctx, base);
	// 82832798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283279C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828327A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828327A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828327A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828327AC: 419A0024  beq cr6, 0x828327d0
	if ctx.cr[6].eq {
	pc = 0x828327D0; continue 'dispatch;
	}
	// 828327B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828327B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828327B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828327BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828327C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828327C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828327C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828327CC: 4082FFE8  bne 0x828327b4
	if !ctx.cr[0].eq {
	pc = 0x828327B4; continue 'dispatch;
	}
	// 828327D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828327D4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828327D8: 487D5951  bl 0x83008128
	ctx.lr = 0x828327DC;
	sub_83008128(ctx, base);
	// 828327DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828327E0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828327E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828327E8: 388ABE48  addi r4, r10, -0x41b8
	ctx.r[4].s64 = ctx.r[10].s64 + -16824;
	// 828327EC: 38A00253  li r5, 0x253
	ctx.r[5].s64 = 595;
	// 828327F0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828327F4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828327F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828327FC: 48626245  bl 0x82e58a40
	ctx.lr = 0x82832800;
	sub_82E58A40(ctx, base);
	// 82832800: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82832804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832808: 419A0008  beq cr6, 0x82832810
	if ctx.cr[6].eq {
	pc = 0x82832810; continue 'dispatch;
	}
	// 8283280C: 4BA8E085  bl 0x822c0890
	ctx.lr = 0x82832810;
	sub_822C0890(ctx, base);
	// 82832810: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82832814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82832818: 419A0008  beq cr6, 0x82832820
	if ctx.cr[6].eq {
	pc = 0x82832820; continue 'dispatch;
	}
	// 8283281C: 4BA8E075  bl 0x822c0890
	ctx.lr = 0x82832820;
	sub_822C0890(ctx, base);
	// 82832820: 897F02E4  lbz r11, 0x2e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 82832824: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82832828: 4082001C  bne 0x82832844
	if !ctx.cr[0].eq {
	pc = 0x82832844; continue 'dispatch;
	}
	// 8283282C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82832830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832834: 4BFE4D95  bl 0x828175c8
	ctx.lr = 0x82832838;
	sub_828175C8(ctx, base);
	// 82832838: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8283283C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832840: 4BFE4D91  bl 0x828175d0
	ctx.lr = 0x82832844;
	sub_828175D0(ctx, base);
	// 82832844: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82832848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283284C: 4BFE6DC5  bl 0x82819610
	ctx.lr = 0x82832850;
	sub_82819610(ctx, base);
	// 82832850: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82832854: 48975968  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82832858 size=136
    let mut pc: u32 = 0x82832858;
    'dispatch: loop {
        match pc {
            0x82832858 => {
    //   block [0x82832858..0x828328E0)
	// 82832858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283285C: 4897590D  bl 0x831a8168
	ctx.lr = 0x82832860;
	sub_831A8130(ctx, base);
	// 82832860: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82832864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82832868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283286C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82832870: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82832874: 480302A5  bl 0x82862b18
	ctx.lr = 0x82832878;
	sub_82862B18(ctx, base);
	// 82832878: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283287C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82832880: 396BBEE4  addi r11, r11, -0x411c
	ctx.r[11].s64 = ctx.r[11].s64 + -16668;
	// 82832884: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82832888: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283288C: 4BFC02AD  bl 0x827f2b38
	ctx.lr = 0x82832890;
	sub_827F2B38(ctx, base);
	// 82832890: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82832894: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 82832898: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 8283289C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 828328A0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828328A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828328A8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828328AC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828328B0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828328B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828328E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828328E0 size=332
    let mut pc: u32 = 0x828328E0;
    'dispatch: loop {
        match pc {
            0x828328E0 => {
    //   block [0x828328E0..0x82832A2C)
	// 828328E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828328E4: 48975885  bl 0x831a8168
	ctx.lr = 0x828328E8;
	sub_831A8130(ctx, base);
	// 828328E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828328EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828328F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828328F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828328F8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828328FC: 41820038  beq 0x82832934
	if ctx.cr[0].eq {
	pc = 0x82832934; continue 'dispatch;
	}
	// 82832900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832904: 48977085  bl 0x831a9988
	ctx.lr = 0x82832908;
	sub_831A9988(ctx, base);
	// 82832908: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8283290C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82832910: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 82832914: 489757E5  bl 0x831a80f8
	ctx.lr = 0x82832918;
	sub_831A80F8(ctx, base);
	// 82832918: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283291C: 41820018  beq 0x82832934
	if ctx.cr[0].eq {
	pc = 0x82832934; continue 'dispatch;
	}
	// 82832920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82832924: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82832928: 4BFFCC49  bl 0x8282f570
	ctx.lr = 0x8283292C;
	sub_8282F570(ctx, base);
	// 8283292C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82832930: 480000F4  b 0x82832a24
	pc = 0x82832A24; continue 'dispatch;
	// 82832934: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82832938: 419A00DC  beq cr6, 0x82832a14
	if ctx.cr[6].eq {
	pc = 0x82832A14; continue 'dispatch;
	}
	// 8283293C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832940: 48977049  bl 0x831a9988
	ctx.lr = 0x82832944;
	sub_831A9988(ctx, base);
	// 82832944: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82832948: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283294C: 386B6BB0  addi r3, r11, 0x6bb0
	ctx.r[3].s64 = ctx.r[11].s64 + 27568;
	// 82832950: 489757A9  bl 0x831a80f8
	ctx.lr = 0x82832954;
	sub_831A80F8(ctx, base);
	// 82832954: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82832958: 41820014  beq 0x8283296c
	if ctx.cr[0].eq {
	pc = 0x8283296C; continue 'dispatch;
	}
	// 8283295C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82832960: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82832964: 4BA8D69D  bl 0x822c0000
	ctx.lr = 0x82832968;
	sub_822C0000(ctx, base);
	// 82832968: 4BFFFFC4  b 0x8283292c
	pc = 0x8283292C; continue 'dispatch;
	// 8283296C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82832970: 419A00A4  beq cr6, 0x82832a14
	if ctx.cr[6].eq {
	pc = 0x82832A14; continue 'dispatch;
	}
	// 82832974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832978: 48977011  bl 0x831a9988
	ctx.lr = 0x8283297C;
	sub_831A9988(ctx, base);
	// 8283297C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82832980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82832984: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 82832988: 48975771  bl 0x831a80f8
	ctx.lr = 0x8283298C;
	sub_831A80F8(ctx, base);
	// 8283298C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82832990: 41820014  beq 0x828329a4
	if ctx.cr[0].eq {
	pc = 0x828329A4; continue 'dispatch;
	}
	// 82832994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82832998: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8283299C: 4BA8D665  bl 0x822c0000
	ctx.lr = 0x828329A0;
	sub_822C0000(ctx, base);
	// 828329A0: 4BFFFF8C  b 0x8283292c
	pc = 0x8283292C; continue 'dispatch;
	// 828329A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828329A8: 419A006C  beq cr6, 0x82832a14
	if ctx.cr[6].eq {
	pc = 0x82832A14; continue 'dispatch;
	}
	// 828329AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828329B0: 48976FD9  bl 0x831a9988
	ctx.lr = 0x828329B4;
	sub_831A9988(ctx, base);
	// 828329B4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828329B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828329BC: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828329C0: 48975739  bl 0x831a80f8
	ctx.lr = 0x828329C4;
	sub_831A80F8(ctx, base);
	// 828329C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828329C8: 41820014  beq 0x828329dc
	if ctx.cr[0].eq {
	pc = 0x828329DC; continue 'dispatch;
	}
	// 828329CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828329D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828329D4: 4BFFFD75  bl 0x82832748
	ctx.lr = 0x828329D8;
	sub_82832748(ctx, base);
	// 828329D8: 4BFFFF54  b 0x8283292c
	pc = 0x8283292C; continue 'dispatch;
	// 828329DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828329E0: 419A0034  beq cr6, 0x82832a14
	if ctx.cr[6].eq {
	pc = 0x82832A14; continue 'dispatch;
	}
	// 828329E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828329E8: 48976FA1  bl 0x831a9988
	ctx.lr = 0x828329EC;
	sub_831A9988(ctx, base);
	// 828329EC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828329F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828329F4: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 828329F8: 48975701  bl 0x831a80f8
	ctx.lr = 0x828329FC;
	sub_831A80F8(ctx, base);
	// 828329FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82832A00: 41820014  beq 0x82832a14
	if ctx.cr[0].eq {
	pc = 0x82832A14; continue 'dispatch;
	}
	// 82832A04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82832A08: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82832A0C: 4BFFD9D5  bl 0x828303e0
	ctx.lr = 0x82832A10;
	sub_828303E0(ctx, base);
	// 82832A10: 4BFFFF1C  b 0x8283292c
	pc = 0x8283292C; continue 'dispatch;
	// 82832A14: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82832A18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82832A1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82832A20: 4BFFE229  bl 0x82830c48
	ctx.lr = 0x82832A24;
	sub_82830C48(ctx, base);
	// 82832A24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82832A28: 48975790  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832A30 size=1232
    let mut pc: u32 = 0x82832A30;
    'dispatch: loop {
        match pc {
            0x82832A30 => {
    //   block [0x82832A30..0x82832F00)
	// 82832A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82832A34: 48975731  bl 0x831a8164
	ctx.lr = 0x82832A38;
	sub_831A8130(ctx, base);
	// 82832A38: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82832A3C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82832A40: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82832F00 size=84
    let mut pc: u32 = 0x82832F00;
    'dispatch: loop {
        match pc {
            0x82832F00 => {
    //   block [0x82832F00..0x82832F54)
	// 82832F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82832F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82832F08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82832F0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82832F10: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82832F18: 388BB408  addi r4, r11, -0x4bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -19448;
	// 82832F1C: 4BFBD90D  bl 0x827f0828
	ctx.lr = 0x82832F20;
	sub_827F0828(ctx, base);
	// 82832F20: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832F28: 388BB424  addi r4, r11, -0x4bdc
	ctx.r[4].s64 = ctx.r[11].s64 + -19420;
	// 82832F2C: 4BFC31C5  bl 0x827f60f0
	ctx.lr = 0x82832F30;
	sub_827F60F0(ctx, base);
	// 82832F30: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832F38: 388BB434  addi r4, r11, -0x4bcc
	ctx.r[4].s64 = ctx.r[11].s64 + -19404;
	// 82832F3C: 4BFBDB8D  bl 0x827f0ac8
	ctx.lr = 0x82832F40;
	sub_827F0AC8(ctx, base);
	// 82832F40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82832F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82832F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82832F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82832F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832F58 size=4
    let mut pc: u32 = 0x82832F58;
    'dispatch: loop {
        match pc {
            0x82832F58 => {
    //   block [0x82832F58..0x82832F5C)
	// 82832F58: 4BFE6B08  b 0x82819a60
	sub_82819A60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832F60 size=12
    let mut pc: u32 = 0x82832F60;
    'dispatch: loop {
        match pc {
            0x82832F60 => {
    //   block [0x82832F60..0x82832F6C)
	// 82832F60: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F64: 386BB424  addi r3, r11, -0x4bdc
	ctx.r[3].s64 = ctx.r[11].s64 + -19420;
	// 82832F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832F70 size=12
    let mut pc: u32 = 0x82832F70;
    'dispatch: loop {
        match pc {
            0x82832F70 => {
    //   block [0x82832F70..0x82832F7C)
	// 82832F70: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F74: 386BB408  addi r3, r11, -0x4bf8
	ctx.r[3].s64 = ctx.r[11].s64 + -19448;
	// 82832F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832F80 size=12
    let mut pc: u32 = 0x82832F80;
    'dispatch: loop {
        match pc {
            0x82832F80 => {
    //   block [0x82832F80..0x82832F8C)
	// 82832F80: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F84: 386BB434  addi r3, r11, -0x4bcc
	ctx.r[3].s64 = ctx.r[11].s64 + -19404;
	// 82832F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832F90 size=12
    let mut pc: u32 = 0x82832F90;
    'dispatch: loop {
        match pc {
            0x82832F90 => {
    //   block [0x82832F90..0x82832F9C)
	// 82832F90: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832F94: 386BAEFC  addi r3, r11, -0x5104
	ctx.r[3].s64 = ctx.r[11].s64 + -20740;
	// 82832F98: 4BFE8F98  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82832FA0 size=12
    let mut pc: u32 = 0x82832FA0;
    'dispatch: loop {
        match pc {
            0x82832FA0 => {
    //   block [0x82832FA0..0x82832FAC)
	// 82832FA0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82832FA4: 386BAEFC  addi r3, r11, -0x5104
	ctx.r[3].s64 = ctx.r[11].s64 + -20740;
	// 82832FA8: 4BFE8F90  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82832FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82832FB0 size=132
    let mut pc: u32 = 0x82832FB0;
    'dispatch: loop {
        match pc {
            0x82832FB0 => {
    //   block [0x82832FB0..0x82833034)
	// 82832FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82832FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82832FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82832FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82832FC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82832FC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82832FC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82832FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832FD0: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82832FD4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82832FD8: 485C0A31  bl 0x82df3a08
	ctx.lr = 0x82832FDC;
	sub_82DF3A08(ctx, base);
	// 82832FDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82832FE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82832FE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82832FE8: 4BFB8C11  bl 0x827ebbf8
	ctx.lr = 0x82832FEC;
	sub_827EBBF8(ctx, base);
	// 82832FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832FF0: 485C0439  bl 0x82df3428
	ctx.lr = 0x82832FF4;
	sub_82DF3428(ctx, base);
	// 82832FF4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82832FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82832FFC: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 82833000: 485C0A09  bl 0x82df3a08
	ctx.lr = 0x82833004;
	sub_82DF3A08(ctx, base);
	// 82833004: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82833008: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283300C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833010: 4BFB8BE9  bl 0x827ebbf8
	ctx.lr = 0x82833014;
	sub_827EBBF8(ctx, base);
	// 82833014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833018: 485C0411  bl 0x82df3428
	ctx.lr = 0x8283301C;
	sub_82DF3428(ctx, base);
	// 8283301C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82833020: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833024: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833028: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283302C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833038 size=104
    let mut pc: u32 = 0x82833038;
    'dispatch: loop {
        match pc {
            0x82833038 => {
    //   block [0x82833038..0x828330A0)
	// 82833038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283303C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82833044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283304C: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82833050: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82833054: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82833058: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8283305C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833060: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82833064: 388A9B58  addi r4, r10, -0x64a8
	ctx.r[4].s64 = ctx.r[10].s64 + -25768;
	// 82833068: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8283306C: 485C099D  bl 0x82df3a08
	ctx.lr = 0x82833070;
	sub_82DF3A08(ctx, base);
	// 82833070: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82833074: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283307C: 4BD6E50D  bl 0x825a1588
	ctx.lr = 0x82833080;
	sub_825A1588(ctx, base);
	// 82833080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833084: 485C03A5  bl 0x82df3428
	ctx.lr = 0x82833088;
	sub_82DF3428(ctx, base);
	// 82833088: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283308C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833094: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82833098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283309C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828330A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828330A0 size=108
    let mut pc: u32 = 0x828330A0;
    'dispatch: loop {
        match pc {
            0x828330A0 => {
    //   block [0x828330A0..0x8283310C)
	// 828330A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828330A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828330A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828330AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828330B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828330B4: 817F0288  lwz r11, 0x288(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 828330B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828330BC: 409A0010  bne cr6, 0x828330cc
	if !ctx.cr[6].eq {
	pc = 0x828330CC; continue 'dispatch;
	}
	// 828330C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828330C4: 388B9B68  addi r4, r11, -0x6498
	ctx.r[4].s64 = ctx.r[11].s64 + -25752;
	// 828330C8: 48000014  b 0x828330dc
	pc = 0x828330DC; continue 'dispatch;
	// 828330CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828330D0: 409A0028  bne cr6, 0x828330f8
	if !ctx.cr[6].eq {
	pc = 0x828330F8; continue 'dispatch;
	}
	// 828330D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828330D8: 388B9C28  addi r4, r11, -0x63d8
	ctx.r[4].s64 = ctx.r[11].s64 + -25560;
	// 828330DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828330E0: 485C0929  bl 0x82df3a08
	ctx.lr = 0x828330E4;
	sub_82DF3A08(ctx, base);
	// 828330E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828330E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828330EC: 4BFB9BFD  bl 0x827ecce8
	ctx.lr = 0x828330F0;
	sub_827ECCE8(ctx, base);
	// 828330F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828330F4: 485C0335  bl 0x82df3428
	ctx.lr = 0x828330F8;
	sub_82DF3428(ctx, base);
	// 828330F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828330FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833100: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82833110 size=4
    let mut pc: u32 = 0x82833110;
    'dispatch: loop {
        match pc {
            0x82833110 => {
    //   block [0x82833110..0x82833114)
	// 82833110: 4BFE5190  b 0x828182a0
	sub_828182A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833118 size=72
    let mut pc: u32 = 0x82833118;
    'dispatch: loop {
        match pc {
            0x82833118 => {
    //   block [0x82833118..0x82833160)
	// 82833118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283311C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283312C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82833130: D03F0280  stfs f1, 0x280(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82833134: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 82833138: 4BFB9149  bl 0x827ec280
	ctx.lr = 0x8283313C;
	sub_827EC280(ctx, base);
	// 8283313C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82833140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833144: 388B2AD4  addi r4, r11, 0x2ad4
	ctx.r[4].s64 = ctx.r[11].s64 + 10964;
	// 82833148: 4BFE52C1  bl 0x82818408
	ctx.lr = 0x8283314C;
	sub_82818408(ctx, base);
	// 8283314C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82833150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283315C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833160 size=68
    let mut pc: u32 = 0x82833160;
    'dispatch: loop {
        match pc {
            0x82833160 => {
    //   block [0x82833160..0x828331A4)
	// 82833160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283316C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82833178: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283317C: D03F0280  stfs f1, 0x280(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82833180: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 82833184: 4BFB90ED  bl 0x827ec270
	ctx.lr = 0x82833188;
	sub_827EC270(ctx, base);
	// 82833188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283318C: 4BFE457D  bl 0x82817708
	ctx.lr = 0x82833190;
	sub_82817708(ctx, base);
	// 82833190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82833194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283319C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828331A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828331A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828331A8 size=12
    let mut pc: u32 = 0x828331A8;
    'dispatch: loop {
        match pc {
            0x828331A8 => {
    //   block [0x828331A8..0x828331B4)
	// 828331A8: 81630284  lwz r11, 0x284(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(644 as u32) ) } as u64;
	// 828331AC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828331B0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828331B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828331B4 size=8
    let mut pc: u32 = 0x828331B4;
    'dispatch: loop {
        match pc {
            0x828331B4 => {
    //   block [0x828331B4..0x828331BC)
	// 828331B4: 4BFE645C  b 0x82819610
	sub_82819610(ctx, base);
	return;
	// 828331B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828331C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828331C0 size=12
    let mut pc: u32 = 0x828331C0;
    'dispatch: loop {
        match pc {
            0x828331C0 => {
    //   block [0x828331C0..0x828331CC)
	// 828331C0: 81630298  lwz r11, 0x298(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(664 as u32) ) } as u64;
	// 828331C4: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828331C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828331D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828331D0 size=136
    let mut pc: u32 = 0x828331D0;
    'dispatch: loop {
        match pc {
            0x828331D0 => {
    //   block [0x828331D0..0x82833258)
	// 828331D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828331D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828331D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828331DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828331E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828331E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828331E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828331EC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828331F0: 409A0020  bne cr6, 0x82833210
	if !ctx.cr[6].eq {
	pc = 0x82833210; continue 'dispatch;
	}
	// 828331F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828331F8: 419A0048  beq cr6, 0x82833240
	if ctx.cr[6].eq {
	pc = 0x82833240; continue 'dispatch;
	}
	// 828331FC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82833200: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82833204: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82833208: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8283320C: 48000034  b 0x82833240
	pc = 0x82833240; continue 'dispatch;
	// 82833210: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82833214: 419A002C  beq cr6, 0x82833240
	if ctx.cr[6].eq {
	pc = 0x82833240; continue 'dispatch;
	}
	// 82833218: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283321C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82833220: 388B1190  addi r4, r11, 0x1190
	ctx.r[4].s64 = ctx.r[11].s64 + 4496;
	// 82833224: 48974ED5  bl 0x831a80f8
	ctx.lr = 0x82833228;
	sub_831A80F8(ctx, base);
	// 82833228: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283322C: 4182000C  beq 0x82833238
	if ctx.cr[0].eq {
	pc = 0x82833238; continue 'dispatch;
	}
	// 82833230: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82833234: 4800000C  b 0x82833240
	pc = 0x82833240; continue 'dispatch;
	// 82833238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283323C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82833240: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82833244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283324C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82833250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833258 size=64
    let mut pc: u32 = 0x82833258;
    'dispatch: loop {
        match pc {
            0x82833258 => {
    //   block [0x82833258..0x82833298)
	// 82833258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283325C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833264: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283326C: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82833270: 4812C1D1  bl 0x8295f440
	ctx.lr = 0x82833274;
	sub_8295F440(ctx, base);
	// 82833274: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82833278: 4182000C  beq 0x82833284
	if ctx.cr[0].eq {
	pc = 0x82833284; continue 'dispatch;
	}
	// 8283327C: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82833280: 4812C2D1  bl 0x8295f550
	ctx.lr = 0x82833284;
	sub_8295F550(ctx, base);
	// 82833284: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82833288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283328C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833298 size=196
    let mut pc: u32 = 0x82833298;
    'dispatch: loop {
        match pc {
            0x82833298 => {
    //   block [0x82833298..0x8283335C)
	// 82833298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283329C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828332A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828332A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828332A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828332AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828332B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828332B4: 807F0254  lwz r3, 0x254(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 828332B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828332BC: 419A0050  beq cr6, 0x8283330c
	if ctx.cr[6].eq {
	pc = 0x8283330C; continue 'dispatch;
	}
	// 828332C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828332C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828332C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828332CC: 4E800421  bctrl
	ctx.lr = 0x828332D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828332D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828332D4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828332D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828332DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828332E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828332E4: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828332E8: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828332EC: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828332F0: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828332F4: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828332F8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828332FC: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82833300: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82833304: C02A6218  lfs f1, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82833308: 4BFE5A61  bl 0x82818d68
	ctx.lr = 0x8283330C;
	sub_82818D68(ctx, base);
	// 8283330C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833314: 388BBFB8  addi r4, r11, -0x4048
	ctx.r[4].s64 = ctx.r[11].s64 + -16456;
	// 82833318: 4BFE5991  bl 0x82818ca8
	ctx.lr = 0x8283331C;
	sub_82818CA8(ctx, base);
	// 8283331C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833320: 481E0361  bl 0x82a13680
	ctx.lr = 0x82833324;
	sub_82A13680(ctx, base);
	// 82833324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82833328: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283332C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833330: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82833334: 4BFE5CFD  bl 0x82819030
	ctx.lr = 0x82833338;
	sub_82819030(ctx, base);
	// 82833338: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283333C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833340: 4BFE63E9  bl 0x82819728
	ctx.lr = 0x82833344;
	sub_82819728(ctx, base);
	// 82833344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82833348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283334C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82833354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833360 size=196
    let mut pc: u32 = 0x82833360;
    'dispatch: loop {
        match pc {
            0x82833360 => {
    //   block [0x82833360..0x82833424)
	// 82833360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283336C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82833378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283337C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82833380: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82833384: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82833388: 4BA8D5B1  bl 0x822c0938
	ctx.lr = 0x8283338C;
	sub_822C0938(ctx, base);
	// 8283338C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82833390: 41820028  beq 0x828333b8
	if ctx.cr[0].eq {
	pc = 0x828333B8; continue 'dispatch;
	}
	// 82833394: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833398: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283339C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828333A0: 392BBFA8  addi r9, r11, -0x4058
	ctx.r[9].s64 = ctx.r[11].s64 + -16472;
	// 828333A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828333A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828333AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828333B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828333B4: 48000008  b 0x828333bc
	pc = 0x828333BC; continue 'dispatch;
	// 828333B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828333BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828333C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828333C4: 409A0044  bne cr6, 0x82833408
	if !ctx.cr[6].eq {
	pc = 0x82833408; continue 'dispatch;
	}
	// 828333C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828333CC: 419A001C  beq cr6, 0x828333e8
	if ctx.cr[6].eq {
	pc = 0x828333E8; continue 'dispatch;
	}
	// 828333D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828333D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828333D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828333DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828333E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828333E4: 4E800421  bctrl
	ctx.lr = 0x828333E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828333E8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828333EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828333F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828333F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828333F8: 816B113C  lwz r11, 0x113c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4412 as u32) ) } as u64;
	// 828333FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82833400: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82833404: 4BA8CBFD  bl 0x822c0000
	ctx.lr = 0x82833408;
	sub_822C0000(ctx, base);
	// 82833408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283340C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82833410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833418: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283341C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833428 size=276
    let mut pc: u32 = 0x82833428;
    'dispatch: loop {
        match pc {
            0x82833428 => {
    //   block [0x82833428..0x8283353C)
	// 82833428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283342C: 48974D3D  bl 0x831a8168
	ctx.lr = 0x82833430;
	sub_831A8130(ctx, base);
	// 82833430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833434: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82833438: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283343C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82833440: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82833444: 41820038  beq 0x8283347c
	if ctx.cr[0].eq {
	pc = 0x8283347C; continue 'dispatch;
	}
	// 82833448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283344C: 4897653D  bl 0x831a9988
	ctx.lr = 0x82833450;
	sub_831A9988(ctx, base);
	// 82833450: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82833454: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82833458: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 8283345C: 48974C9D  bl 0x831a80f8
	ctx.lr = 0x82833460;
	sub_831A80F8(ctx, base);
	// 82833460: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82833464: 41820018  beq 0x8283347c
	if ctx.cr[0].eq {
	pc = 0x8283347C; continue 'dispatch;
	}
	// 82833468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283346C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82833470: 4BFFFD39  bl 0x828331a8
	ctx.lr = 0x82833474;
	sub_828331A8(ctx, base);
	// 82833474: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82833478: 480000BC  b 0x82833534
	pc = 0x82833534; continue 'dispatch;
	// 8283347C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82833480: 419A00A4  beq cr6, 0x82833524
	if ctx.cr[6].eq {
	pc = 0x82833524; continue 'dispatch;
	}
	// 82833484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833488: 48976501  bl 0x831a9988
	ctx.lr = 0x8283348C;
	sub_831A9988(ctx, base);
	// 8283348C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82833490: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82833494: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82833498: 48974C61  bl 0x831a80f8
	ctx.lr = 0x8283349C;
	sub_831A80F8(ctx, base);
	// 8283349C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828334A0: 41820014  beq 0x828334b4
	if ctx.cr[0].eq {
	pc = 0x828334B4; continue 'dispatch;
	}
	// 828334A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828334A8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828334AC: 4BFFFDED  bl 0x82833298
	ctx.lr = 0x828334B0;
	sub_82833298(ctx, base);
	// 828334B0: 4BFFFFC4  b 0x82833474
	pc = 0x82833474; continue 'dispatch;
	// 828334B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828334B8: 419A006C  beq cr6, 0x82833524
	if ctx.cr[6].eq {
	pc = 0x82833524; continue 'dispatch;
	}
	// 828334BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828334C0: 489764C9  bl 0x831a9988
	ctx.lr = 0x828334C4;
	sub_831A9988(ctx, base);
	// 828334C4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828334C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828334CC: 386BFC14  addi r3, r11, -0x3ec
	ctx.r[3].s64 = ctx.r[11].s64 + -1004;
	// 828334D0: 48974C29  bl 0x831a80f8
	ctx.lr = 0x828334D4;
	sub_831A80F8(ctx, base);
	// 828334D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828334D8: 41820014  beq 0x828334ec
	if ctx.cr[0].eq {
	pc = 0x828334EC; continue 'dispatch;
	}
	// 828334DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828334E0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828334E4: 4BFFFCDD  bl 0x828331c0
	ctx.lr = 0x828334E8;
	sub_828331C0(ctx, base);
	// 828334E8: 4BFFFF8C  b 0x82833474
	pc = 0x82833474; continue 'dispatch;
	// 828334EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828334F0: 419A0034  beq cr6, 0x82833524
	if ctx.cr[6].eq {
	pc = 0x82833524; continue 'dispatch;
	}
	// 828334F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828334F8: 48976491  bl 0x831a9988
	ctx.lr = 0x828334FC;
	sub_831A9988(ctx, base);
	// 828334FC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82833500: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82833504: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 82833508: 48974BF1  bl 0x831a80f8
	ctx.lr = 0x8283350C;
	sub_831A80F8(ctx, base);
	// 8283350C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82833510: 41820014  beq 0x82833524
	if ctx.cr[0].eq {
	pc = 0x82833524; continue 'dispatch;
	}
	// 82833514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82833518: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8283351C: 4BFFC2E5  bl 0x8282f800
	ctx.lr = 0x82833520;
	sub_8282F800(ctx, base);
	// 82833520: 4BFFFF54  b 0x82833474
	pc = 0x82833474; continue 'dispatch;
	// 82833524: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82833528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283352C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82833530: 4BFE6301  bl 0x82819830
	ctx.lr = 0x82833534;
	sub_82819830(ctx, base);
	// 82833534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82833538: 48974C80  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833540 size=116
    let mut pc: u32 = 0x82833540;
    'dispatch: loop {
        match pc {
            0x82833540 => {
    //   block [0x82833540..0x828335B4)
	// 82833540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283354C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833554: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833558: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283355C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82833560: 396BC034  addi r11, r11, -0x3fcc
	ctx.r[11].s64 = ctx.r[11].s64 + -16332;
	// 82833564: 394AC020  addi r10, r10, -0x3fe0
	ctx.r[10].s64 = ctx.r[10].s64 + -16352;
	// 82833568: 3929BFD4  addi r9, r9, -0x402c
	ctx.r[9].s64 = ctx.r[9].s64 + -16428;
	// 8283356C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82833570: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82833574: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82833578: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 8283357C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82833580: 419A0008  beq cr6, 0x82833588
	if ctx.cr[6].eq {
	pc = 0x82833588; continue 'dispatch;
	}
	// 82833584: 4BA8D30D  bl 0x822c0890
	ctx.lr = 0x82833588;
	sub_822C0890(ctx, base);
	// 82833588: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 8283358C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82833590: 419A0008  beq cr6, 0x82833598
	if ctx.cr[6].eq {
	pc = 0x82833598; continue 'dispatch;
	}
	// 82833594: 4BA8D2FD  bl 0x822c0890
	ctx.lr = 0x82833598;
	sub_822C0890(ctx, base);
	// 82833598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283359C: 4BFE48DD  bl 0x82817e78
	ctx.lr = 0x828335A0;
	sub_82817E78(ctx, base);
	// 828335A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828335A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828335A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828335AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828335B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828335B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828335B8 size=8
    let mut pc: u32 = 0x828335B8;
    'dispatch: loop {
        match pc {
            0x828335B8 => {
    //   block [0x828335B8..0x828335C0)
	// 828335B8: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828335BC: 48000274  b 0x82833830
	sub_82833830(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828335C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828335C0 size=8
    let mut pc: u32 = 0x828335C0;
    'dispatch: loop {
        match pc {
            0x828335C0 => {
    //   block [0x828335C0..0x828335C8)
	// 828335C0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828335C4: 4800026C  b 0x82833830
	sub_82833830(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828335C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828335C8 size=344
    let mut pc: u32 = 0x828335C8;
    'dispatch: loop {
        match pc {
            0x828335C8 => {
    //   block [0x828335C8..0x82833720)
	// 828335C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828335CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828335D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828335D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828335D8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828335DC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828335E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828335E4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828335E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828335EC: 481E0095  bl 0x82a13680
	ctx.lr = 0x828335F0;
	sub_82A13680(ctx, base);
	// 828335F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828335F4: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828335F8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828335FC: 396BC5E0  addi r11, r11, -0x3a20
	ctx.r[11].s64 = ctx.r[11].s64 + -14880;
	// 82833600: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82833604: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82833608: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8283360C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82833610: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82833614: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833720 size=72
    let mut pc: u32 = 0x82833720;
    'dispatch: loop {
        match pc {
            0x82833720 => {
    //   block [0x82833720..0x82833768)
	// 82833720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833728: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283372C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82833730: 419A001C  beq cr6, 0x8283374c
	if ctx.cr[6].eq {
	pc = 0x8283374C; continue 'dispatch;
	}
	// 82833734: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82833738: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8283373C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82833740: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82833744: 4BFFFA8D  bl 0x828331d0
	ctx.lr = 0x82833748;
	sub_828331D0(ctx, base);
	// 82833748: 48000010  b 0x82833758
	pc = 0x82833758; continue 'dispatch;
	// 8283374C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82833750: 396B1190  addi r11, r11, 0x1190
	ctx.r[11].s64 = ctx.r[11].s64 + 4496;
	// 82833754: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82833758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283375C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833768 size=196
    let mut pc: u32 = 0x82833768;
    'dispatch: loop {
        match pc {
            0x82833768 => {
    //   block [0x82833768..0x8283382C)
	// 82833768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283376C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833774: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283377C: 4BFE486D  bl 0x82817fe8
	ctx.lr = 0x82833780;
	sub_82817FE8(ctx, base);
	// 82833780: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833784: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82833788: 396BC034  addi r11, r11, -0x3fcc
	ctx.r[11].s64 = ctx.r[11].s64 + -16332;
	// 8283378C: 394AC020  addi r10, r10, -0x3fe0
	ctx.r[10].s64 = ctx.r[10].s64 + -16352;
	// 82833790: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82833794: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82833798: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8283379C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828337A0: 3929BFD4  addi r9, r9, -0x402c
	ctx.r[9].s64 = ctx.r[9].s64 + -16428;
	// 828337A4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828337A8: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828337AC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828337B0: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 828337B4: 390ABA80  addi r8, r10, -0x4580
	ctx.r[8].s64 = ctx.r[10].s64 + -17792;
	// 828337B8: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 828337BC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828337C0: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 828337C4: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 828337C8: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 828337CC: C1AABA80  lfs f13, -0x4580(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828337D0: D1BF0270  stfs f13, 0x270(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 828337D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828337D8: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828337DC: D1BF0274  stfs f13, 0x274(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), tmp.u32 ) };
	// 828337E0: C1A80008  lfs f13, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828337E4: D1BF0278  stfs f13, 0x278(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 828337E8: C1A8000C  lfs f13, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828337EC: D1BF027C  stfs f13, 0x27c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), tmp.u32 ) };
	// 828337F0: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 828337F4: C0079524  lfs f0, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828337F8: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 828337FC: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82833800: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 82833804: C166D7BC  lfs f11, -0x2844(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82833808: D19F0280  stfs f12, 0x280(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 8283380C: D01F028C  stfs f0, 0x28c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), tmp.u32 ) };
	// 82833810: D17F0290  stfs f11, 0x290(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), tmp.u32 ) };
	// 82833814: D01F0294  stfs f0, 0x294(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 82833818: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283381C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833824: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82833830 size=76
    let mut pc: u32 = 0x82833830;
    'dispatch: loop {
        match pc {
            0x82833830 => {
    //   block [0x82833830..0x8283387C)
	// 82833830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283383C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833848: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283384C: 4BFFFCF5  bl 0x82833540
	ctx.lr = 0x82833850;
	sub_82833540(ctx, base);
	// 82833850: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82833854: 4182000C  beq 0x82833860
	if ctx.cr[0].eq {
	pc = 0x82833860; continue 'dispatch;
	}
	// 82833858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283385C: 485BEB7D  bl 0x82df23d8
	ctx.lr = 0x82833860;
	sub_82DF23D8(ctx, base);
	// 82833860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82833868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283386C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82833874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82833878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833880 size=292
    let mut pc: u32 = 0x82833880;
    'dispatch: loop {
        match pc {
            0x82833880 => {
    //   block [0x82833880..0x828339A4)
	// 82833880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82833888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283388C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82833890: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833898: 807F0254  lwz r3, 0x254(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 8283389C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828338A0: 419A0028  beq cr6, 0x828338c8
	if ctx.cr[6].eq {
	pc = 0x828338C8; continue 'dispatch;
	}
	// 828338A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828338A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828338AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828338B0: 4E800421  bctrl
	ctx.lr = 0x828338B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828338B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828338B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828338BC: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 828338C0: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 828338C4: 4812BF5D  bl 0x8295f820
	ctx.lr = 0x828338C8;
	sub_8295F820(ctx, base);
	// 828338C8: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 828338CC: 4812BB75  bl 0x8295f440
	ctx.lr = 0x828338D0;
	sub_8295F440(ctx, base);
	// 828338D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828338D4: 418200B8  beq 0x8283398c
	if ctx.cr[0].eq {
	pc = 0x8283398C; continue 'dispatch;
	}
	// 828338D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828338DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828338E0: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 828338E4: 485C0125  bl 0x82df3a08
	ctx.lr = 0x828338E8;
	sub_82DF3A08(ctx, base);
	// 828338E8: 3FC08204  lis r30, -0x7dfc
	ctx.r[30].s64 = -2113667072;
	// 828338EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828338F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828338F4: C03ED7BC  lfs f1, -0x2844(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828338F8: 4802FE41  bl 0x82863738
	ctx.lr = 0x828338FC;
	sub_82863738(ctx, base);
	// 828338FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82833900: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82833904: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82833908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283390C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82833910: 419A0024  beq cr6, 0x82833934
	if ctx.cr[6].eq {
	pc = 0x82833934; continue 'dispatch;
	}
	// 82833914: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82833918: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283391C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833920: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82833924: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82833928: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283392C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833930: 4082FFE8  bne 0x82833918
	if !ctx.cr[0].eq {
	pc = 0x82833918; continue 'dispatch;
	}
	// 82833934: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82833938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283393C: 4BFB941D  bl 0x827ecd58
	ctx.lr = 0x82833940;
	sub_827ECD58(ctx, base);
	// 82833940: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82833944: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82833948: 419A0008  beq cr6, 0x82833950
	if ctx.cr[6].eq {
	pc = 0x82833950; continue 'dispatch;
	}
	// 8283394C: 4BA8CF45  bl 0x822c0890
	ctx.lr = 0x82833950;
	sub_822C0890(ctx, base);
	// 82833950: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82833954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82833958: 419A0008  beq cr6, 0x82833960
	if ctx.cr[6].eq {
	pc = 0x82833960; continue 'dispatch;
	}
	// 8283395C: 4BA8CF35  bl 0x822c0890
	ctx.lr = 0x82833960;
	sub_822C0890(ctx, base);
	// 82833960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833964: 485BFAC5  bl 0x82df3428
	ctx.lr = 0x82833968;
	sub_82DF3428(ctx, base);
	// 82833968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283396C: C01ED7BC  lfs f0, -0x2844(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82833970: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82833974: D01F0280  stfs f0, 0x280(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82833978: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 8283397C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833980: 4BFB88F1  bl 0x827ec270
	ctx.lr = 0x82833984;
	sub_827EC270(ctx, base);
	// 82833984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833988: 4BFE3D81  bl 0x82817708
	ctx.lr = 0x8283398C;
	sub_82817708(ctx, base);
	// 8283398C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82833990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82833994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82833998: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283399C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828339A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828339A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828339A8 size=844
    let mut pc: u32 = 0x828339A8;
    'dispatch: loop {
        match pc {
            0x828339A8 => {
    //   block [0x828339A8..0x82833CF4)
	// 828339A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828339AC: 489747B1  bl 0x831a815c
	ctx.lr = 0x828339B0;
	sub_831A8130(ctx, base);
	// 828339B0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828339B4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828339B8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828339BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828339C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828339C4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828339C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828339CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828339D0: 388BC0F8  addi r4, r11, -0x3f08
	ctx.r[4].s64 = ctx.r[11].s64 + -16136;
	// 828339D4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828339D8: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 828339DC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828339E0: 4BA8C9F9  bl 0x822c03d8
	ctx.lr = 0x828339E4;
	sub_822C03D8(ctx, base);
	// 828339E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828339E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828339EC: 3B4B44A0  addi r26, r11, 0x44a0
	ctx.r[26].s64 = ctx.r[11].s64 + 17568;
	// 828339F0: 41820030  beq 0x82833a20
	if ctx.cr[0].eq {
	pc = 0x82833A20; continue 'dispatch;
	}
	// 828339F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828339F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828339FC: 485C000D  bl 0x82df3a08
	ctx.lr = 0x82833A00;
	sub_82DF3A08(ctx, base);
	// 82833A00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82833A04: 38BB0080  addi r5, r27, 0x80
	ctx.r[5].s64 = ctx.r[27].s64 + 128;
	// 82833A08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833A10: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82833A14: 4BD789FD  bl 0x825ac410
	ctx.lr = 0x82833A18;
	sub_825AC410(ctx, base);
	// 82833A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833A1C: 48000008  b 0x82833a24
	pc = 0x82833A24; continue 'dispatch;
	// 82833A20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82833A24: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82833A28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82833A2C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82833A30: 4BCBF989  bl 0x824f33b8
	ctx.lr = 0x82833A34;
	sub_824F33B8(ctx, base);
	// 82833A34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82833A38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82833A3C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82833A40: 4BA8C5C1  bl 0x822c0000
	ctx.lr = 0x82833A44;
	sub_822C0000(ctx, base);
	// 82833A44: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82833A48: 4182000C  beq 0x82833a54
	if ctx.cr[0].eq {
	pc = 0x82833A54; continue 'dispatch;
	}
	// 82833A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833A50: 485BF9D9  bl 0x82df3428
	ctx.lr = 0x82833A54;
	sub_82DF3428(ctx, base);
	// 82833A54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833A58: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82833A5C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82833A60: 3BABBF90  addi r29, r11, -0x4070
	ctx.r[29].s64 = ctx.r[11].s64 + -16496;
	// 82833A64: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82833A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833A6C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82833A70: 485BFF99  bl 0x82df3a08
	ctx.lr = 0x82833A74;
	sub_82DF3A08(ctx, base);
	// 82833A74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82833A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82833A7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82833A80: 4BD78341  bl 0x825abdc0
	ctx.lr = 0x82833A84;
	sub_825ABDC0(ctx, base);
	// 82833A84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833A88: 485BF9A1  bl 0x82df3428
	ctx.lr = 0x82833A8C;
	sub_82DF3428(ctx, base);
	// 82833A8C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82833A90: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 82833A94: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82833A98: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82833A9C: 4198FFCC  blt cr6, 0x82833a68
	if ctx.cr[6].lt {
	pc = 0x82833A68; continue 'dispatch;
	}
	// 82833AA0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82833AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833AA8: 485BFF61  bl 0x82df3a08
	ctx.lr = 0x82833AAC;
	sub_82DF3A08(ctx, base);
	// 82833AAC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82833AB0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82833AB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82833AB8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82833ABC: 419A0024  beq cr6, 0x82833ae0
	if ctx.cr[6].eq {
	pc = 0x82833AE0; continue 'dispatch;
	}
	// 82833AC0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82833AC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82833AC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833ACC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82833AD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82833AD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82833AD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833ADC: 4082FFE8  bne 0x82833ac4
	if !ctx.cr[0].eq {
	pc = 0x82833AC4; continue 'dispatch;
	}
	// 82833AE0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82833AE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833AE8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82833AEC: 4BD6E625  bl 0x825a2110
	ctx.lr = 0x82833AF0;
	sub_825A2110(ctx, base);
	// 82833AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833AF4: 485BF935  bl 0x82df3428
	ctx.lr = 0x82833AF8;
	sub_82DF3428(ctx, base);
	// 82833AF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82833AFC: 419A000C  beq cr6, 0x82833b08
	if ctx.cr[6].eq {
	pc = 0x82833B08; continue 'dispatch;
	}
	// 82833B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833B04: 4BA8CD8D  bl 0x822c0890
	ctx.lr = 0x82833B08;
	sub_822C0890(ctx, base);
	// 82833B08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833B0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833B10: 388BC0E0  addi r4, r11, -0x3f20
	ctx.r[4].s64 = ctx.r[11].s64 + -16160;
	// 82833B14: 485BFEF5  bl 0x82df3a08
	ctx.lr = 0x82833B18;
	sub_82DF3A08(ctx, base);
	// 82833B18: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82833B1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833B20: 388BEDA0  addi r4, r11, -0x1260
	ctx.r[4].s64 = ctx.r[11].s64 + -4704;
	// 82833B24: 485BFEE5  bl 0x82df3a08
	ctx.lr = 0x82833B28;
	sub_82DF3A08(ctx, base);
	// 82833B28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82833B2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82833B30: 38BB0084  addi r5, r27, 0x84
	ctx.r[5].s64 = ctx.r[27].s64 + 132;
	// 82833B34: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82833B38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82833B3C: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82833B40: C3CA08AC  lfs f30, 0x8ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2220 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82833B44: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82833B48: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82833B4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82833B50: 4BD6F759  bl 0x825a32a8
	ctx.lr = 0x82833B54;
	sub_825A32A8(ctx, base);
	// 82833B54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82833B58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833B5C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82833B60: 4BD6DC11  bl 0x825a1770
	ctx.lr = 0x82833B64;
	sub_825A1770(ctx, base);
	// 82833B64: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82833B68: 485BF8C1  bl 0x82df3428
	ctx.lr = 0x82833B6C;
	sub_82DF3428(ctx, base);
	// 82833B6C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82833B70: 4BA95149  bl 0x822c8cb8
	ctx.lr = 0x82833B74;
	sub_822C8CB8(ctx, base);
	// 82833B74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833B78: 485BF8B1  bl 0x82df3428
	ctx.lr = 0x82833B7C;
	sub_82DF3428(ctx, base);
	// 82833B7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833B80: 485BF8A9  bl 0x82df3428
	ctx.lr = 0x82833B84;
	sub_82DF3428(ctx, base);
	// 82833B84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833B8C: 388BC0CC  addi r4, r11, -0x3f34
	ctx.r[4].s64 = ctx.r[11].s64 + -16180;
	// 82833B90: 485BFE79  bl 0x82df3a08
	ctx.lr = 0x82833B94;
	sub_82DF3A08(ctx, base);
	// 82833B94: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82833B98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833B9C: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 82833BA0: 485BFE69  bl 0x82df3a08
	ctx.lr = 0x82833BA4;
	sub_82DF3A08(ctx, base);
	// 82833BA4: 38BB0088  addi r5, r27, 0x88
	ctx.r[5].s64 = ctx.r[27].s64 + 136;
	// 82833BA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833BAC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82833BB0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82833BB4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82833BB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82833BBC: 4BD6F6ED  bl 0x825a32a8
	ctx.lr = 0x82833BC0;
	sub_825A32A8(ctx, base);
	// 82833BC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82833BC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82833BC8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82833BCC: 4BD6DBA5  bl 0x825a1770
	ctx.lr = 0x82833BD0;
	sub_825A1770(ctx, base);
	// 82833BD0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82833BD4: 485BF855  bl 0x82df3428
	ctx.lr = 0x82833BD8;
	sub_82DF3428(ctx, base);
	// 82833BD8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82833BDC: 4BA950DD  bl 0x822c8cb8
	ctx.lr = 0x82833BE0;
	sub_822C8CB8(ctx, base);
	// 82833BE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833BE4: 485BF845  bl 0x82df3428
	ctx.lr = 0x82833BE8;
	sub_82DF3428(ctx, base);
	// 82833BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833BEC: 485BF83D  bl 0x82df3428
	ctx.lr = 0x82833BF0;
	sub_82DF3428(ctx, base);
	// 82833BF0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833BF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833BF8: 388BC0B4  addi r4, r11, -0x3f4c
	ctx.r[4].s64 = ctx.r[11].s64 + -16204;
	// 82833BFC: 485BFE0D  bl 0x82df3a08
	ctx.lr = 0x82833C00;
	sub_82DF3A08(ctx, base);
	// 82833C00: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82833C04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833C08: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 82833C0C: 485BFDFD  bl 0x82df3a08
	ctx.lr = 0x82833C10;
	sub_82DF3A08(ctx, base);
	// 82833C10: 38BB008C  addi r5, r27, 0x8c
	ctx.r[5].s64 = ctx.r[27].s64 + 140;
	// 82833C14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833C18: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82833C1C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82833C20: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82833C24: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82833C28: 4BD6F681  bl 0x825a32a8
	ctx.lr = 0x82833C2C;
	sub_825A32A8(ctx, base);
	// 82833C2C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82833C30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82833C34: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82833C38: 4BD6DB39  bl 0x825a1770
	ctx.lr = 0x82833C3C;
	sub_825A1770(ctx, base);
	// 82833C3C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82833C40: 485BF7E9  bl 0x82df3428
	ctx.lr = 0x82833C44;
	sub_82DF3428(ctx, base);
	// 82833C44: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82833C48: 4BA95071  bl 0x822c8cb8
	ctx.lr = 0x82833C4C;
	sub_822C8CB8(ctx, base);
	// 82833C4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833C50: 485BF7D9  bl 0x82df3428
	ctx.lr = 0x82833C54;
	sub_82DF3428(ctx, base);
	// 82833C54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833C58: 485BF7D1  bl 0x82df3428
	ctx.lr = 0x82833C5C;
	sub_82DF3428(ctx, base);
	// 82833C5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833C64: 388B9D24  addi r4, r11, -0x62dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25308;
	// 82833C68: 485BFDA1  bl 0x82df3a08
	ctx.lr = 0x82833C6C;
	sub_82DF3A08(ctx, base);
	// 82833C6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833C70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833C74: 388B9B58  addi r4, r11, -0x64a8
	ctx.r[4].s64 = ctx.r[11].s64 + -25768;
	// 82833C78: 485BFD91  bl 0x82df3a08
	ctx.lr = 0x82833C7C;
	sub_82DF3A08(ctx, base);
	// 82833C7C: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 82833C80: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82833C84: 60E7869F  ori r7, r7, 0x869f
	ctx.r[7].u64 = ctx.r[7].u64 | 34463;
	// 82833C88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82833C8C: 38BB0090  addi r5, r27, 0x90
	ctx.r[5].s64 = ctx.r[27].s64 + 144;
	// 82833C90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82833C94: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82833C98: 4BD79EF9  bl 0x825adb90
	ctx.lr = 0x82833C9C;
	sub_825ADB90(ctx, base);
	// 82833C9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82833CA0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82833CA4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82833CA8: 4BD6E111  bl 0x825a1db8
	ctx.lr = 0x82833CAC;
	sub_825A1DB8(ctx, base);
	// 82833CAC: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82833CB0: 485BF779  bl 0x82df3428
	ctx.lr = 0x82833CB4;
	sub_82DF3428(ctx, base);
	// 82833CB4: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82833CB8: 4BA95001  bl 0x822c8cb8
	ctx.lr = 0x82833CBC;
	sub_822C8CB8(ctx, base);
	// 82833CBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82833CC0: 485BF769  bl 0x82df3428
	ctx.lr = 0x82833CC4;
	sub_82DF3428(ctx, base);
	// 82833CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82833CC8: 485BF761  bl 0x82df3428
	ctx.lr = 0x82833CCC;
	sub_82DF3428(ctx, base);
	// 82833CCC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82833CD0: 387BFDF8  addi r3, r27, -0x208
	ctx.r[3].s64 = ctx.r[27].s64 + -520;
	// 82833CD4: 4BFE44C5  bl 0x82818198
	ctx.lr = 0x82833CD8;
	sub_82818198(ctx, base);
	// 82833CD8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82833CDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82833CE0: 4BFE4C89  bl 0x82818968
	ctx.lr = 0x82833CE4;
	sub_82818968(ctx, base);
	// 82833CE4: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82833CE8: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82833CEC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82833CF0: 489744BC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833CF8 size=440
    let mut pc: u32 = 0x82833CF8;
    'dispatch: loop {
        match pc {
            0x82833CF8 => {
    //   block [0x82833CF8..0x82833EB0)
	// 82833CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833CFC: 4897446D  bl 0x831a8168
	ctx.lr = 0x82833D00;
	sub_831A8130(ctx, base);
	// 82833D00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82833D04: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833D08: 3D008283  lis r8, -0x7d7d
	ctx.r[8].s64 = -2105344000;
	// 82833D0C: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 82833D10: 3D208283  lis r9, -0x7d7d
	ctx.r[9].s64 = -2105344000;
	// 82833D14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82833D18: 39083258  addi r8, r8, 0x3258
	ctx.r[8].s64 = ctx.r[8].s64 + 12888;
	// 82833D1C: 396B3118  addi r11, r11, 0x3118
	ctx.r[11].s64 = ctx.r[11].s64 + 12568;
	// 82833D20: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82833D24: 39293160  addi r9, r9, 0x3160
	ctx.r[9].s64 = ctx.r[9].s64 + 12640;
	// 82833D28: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 82833D2C: E8E10070  ld r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82833D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833D34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82833D38: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 82833D3C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82833D40: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82833D44: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82833D48: 396B3880  addi r11, r11, 0x3880
	ctx.r[11].s64 = ctx.r[11].s64 + 14464;
	// 82833D4C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82833D50: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82833D54: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82833D58: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82833D5C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82833D60: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82833D64: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82833D68: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82833D6C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82833D70: F9210080  std r9, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u64 ) };
	// 82833D74: 814A0070  lwz r10, 0x70(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 82833D78: F9010088  std r8, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u64 ) };
	// 82833D7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82833D80: 4E800421  bctrl
	ctx.lr = 0x82833D84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82833D84: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82833D88: 4182002C  beq 0x82833db4
	if ctx.cr[0].eq {
	pc = 0x82833DB4; continue 'dispatch;
	}
	// 82833D8C: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 82833D90: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82833D94: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82833D98: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82833D9C: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82833DA0: 7D68502E  lwzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82833DA4: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82833DA8: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82833DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82833DB0: 4E800421  bctrl
	ctx.lr = 0x82833DB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82833DB4: C01F0280  lfs f0, 0x280(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82833DB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82833DBC: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82833DC0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82833DC4: D01F0280  stfs f0, 0x280(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82833DC8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82833DCC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82833DD0: 4199002C  bgt cr6, 0x82833dfc
	if ctx.cr[6].gt {
	pc = 0x82833DFC; continue 'dispatch;
	}
	// 82833DD4: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 82833DD8: 39410084  addi r10, r1, 0x84
	ctx.r[10].s64 = ctx.r[1].s64 + 132;
	// 82833DDC: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82833DE0: C03F0294  lfs f1, 0x294(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82833DE4: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82833DE8: 7D68502E  lwzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82833DEC: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82833DF0: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82833DF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82833DF8: 4E800421  bctrl
	ctx.lr = 0x82833DFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82833DFC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82833E00: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82833E04: 3BCBB380  addi r30, r11, -0x4c80
	ctx.r[30].s64 = ctx.r[11].s64 + -19584;
	// 82833E08: 816AB3C0  lwz r11, -0x4c40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 82833E0C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82833E10: 40820030  bne 0x82833e40
	if !ctx.cr[0].eq {
	pc = 0x82833E40; continue 'dispatch;
	}
	// 82833E14: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82833E18: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82833E1C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82833E20: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82833E24: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82833E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82833E2C: 916AB3C0  stw r11, -0x4c40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19520 as u32), ctx.r[11].u32 ) };
	// 82833E30: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82833E34: C0090590  lfs f0, 0x590(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82833E38: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82833E3C: 4864819D  bl 0x82e7bfd8
	ctx.lr = 0x82833E40;
	sub_82E7BFD8(ctx, base);
	// 82833E40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82833E44: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82833E48: 485DF419  bl 0x82e13260
	ctx.lr = 0x82833E4C;
	sub_82E13260(ctx, base);
	// 82833E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82833E50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82833E54: 4BCDB6C5  bl 0x8250f518
	ctx.lr = 0x82833E58;
	sub_8250F518(ctx, base);
	// 82833E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82833E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82833E60: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82833E64: 409A0008  bne cr6, 0x82833e6c
	if !ctx.cr[6].eq {
	pc = 0x82833E6C; continue 'dispatch;
	}
	// 82833E68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82833E6C: 4BCF41D5  bl 0x82528040
	ctx.lr = 0x82833E70;
	sub_82528040(ctx, base);
	// 82833E70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82833E74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82833E78: 485BDE19  bl 0x82df1c90
	ctx.lr = 0x82833E7C;
	sub_82DF1C90(ctx, base);
	// 82833E7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82833E80: 419A0018  beq cr6, 0x82833e98
	if ctx.cr[6].eq {
	pc = 0x82833E98; continue 'dispatch;
	}
	// 82833E84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82833E88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82833E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833E90: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82833E94: 4BFFF735  bl 0x828335c8
	ctx.lr = 0x82833E98;
	sub_828335C8(ctx, base);
	// 82833E98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82833E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82833EA0: 4BFE37E9  bl 0x82817688
	ctx.lr = 0x82833EA4;
	sub_82817688(ctx, base);
	// 82833EA4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82833EA8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82833EAC: 4897430C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82833EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82833EB0 size=476
    let mut pc: u32 = 0x82833EB0;
    'dispatch: loop {
        match pc {
            0x82833EB0 => {
    //   block [0x82833EB0..0x8283408C)
	// 82833EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82833EB4: 489742B1  bl 0x831a8164
	ctx.lr = 0x82833EB8;
	sub_831A8130(ctx, base);
	// 82833EB8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82833EBC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82833EC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82833EC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82833EC8: 3BCBC0F8  addi r30, r11, -0x3f08
	ctx.r[30].s64 = ctx.r[11].s64 + -16136;
	// 82833ECC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82833ED0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82833ED4: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 82833ED8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82833EDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82833EE0: 386002A0  li r3, 0x2a0
	ctx.r[3].s64 = 672;
	// 82833EE4: 485BE505  bl 0x82df23e8
	ctx.lr = 0x82833EE8;
	sub_82DF23E8(ctx, base);
	// 82833EE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82833EEC: 41820010  beq 0x82833efc
	if ctx.cr[0].eq {
	pc = 0x82833EFC; continue 'dispatch;
	}
	// 82833EF0: 4BFFF879  bl 0x82833768
	ctx.lr = 0x82833EF4;
	sub_82833768(ctx, base);
	// 82833EF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82833EF8: 48000008  b 0x82833f00
	pc = 0x82833F00; continue 'dispatch;
	// 82833EFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82833F00: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82833F04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82833F08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82833F0C: 4BFFF455  bl 0x82833360
	ctx.lr = 0x82833F10;
	sub_82833360(ctx, base);
	// 82833F10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82833F14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82833F18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82833F1C: 4BA8C0E5  bl 0x822c0000
	ctx.lr = 0x82833F20;
	sub_822C0000(ctx, base);
	// 82833F20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82833F24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82833F28: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 82833F2C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82833F30: 4BA8C4A9  bl 0x822c03d8
	ctx.lr = 0x82833F34;
	sub_822C03D8(ctx, base);
	// 82833F34: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82833F38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82833F3C: 418200E0  beq 0x8283401c
	if ctx.cr[0].eq {
	pc = 0x8283401C; continue 'dispatch;
	}
	// 82833F40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82833F44: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82833F48: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82833F4C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82833F50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82833F54: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82833F58: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82833F5C: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82833F60: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82833F64: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82833F68: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82833F6C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82833F70: 409A0008  bne cr6, 0x82833f78
	if !ctx.cr[6].eq {
	pc = 0x82833F78; continue 'dispatch;
	}
	// 82833F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82833F78: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82833F7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82833F80: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82833F84: 419A0024  beq cr6, 0x82833fa8
	if ctx.cr[6].eq {
	pc = 0x82833FA8; continue 'dispatch;
	}
	// 82833F88: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82833F8C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82833F90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833F94: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82833F98: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82833F9C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82833FA0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833FA4: 4082FFE8  bne 0x82833f8c
	if !ctx.cr[0].eq {
	pc = 0x82833F8C; continue 'dispatch;
	}
	// 82833FA8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82833FAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82833FB0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82833FB4: 419A0024  beq cr6, 0x82833fd8
	if ctx.cr[6].eq {
	pc = 0x82833FD8; continue 'dispatch;
	}
	// 82833FB8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82833FBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82833FC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833FC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82833FC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82833FCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82833FD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82833FD4: 4082FFE8  bne 0x82833fbc
	if !ctx.cr[0].eq {
	pc = 0x82833FBC; continue 'dispatch;
	}
	// 82833FD8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82833FDC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82833FE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82833FE4: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82833FE8: 48648C59  bl 0x82e7cc40
	ctx.lr = 0x82833FEC;
	sub_82E7CC40(ctx, base);
	// 82833FEC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82833FF0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82833FF4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82833FF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82833FFC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82834000: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82834004: 4BF64F2D  bl 0x82798f30
	ctx.lr = 0x82834008;
	sub_82798F30(ctx, base);
	// 82834008: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283400C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834010: 4BF67659  bl 0x8279b668
	ctx.lr = 0x82834014;
	sub_8279B668(ctx, base);
	// 82834014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834018: 48000008  b 0x82834020
	pc = 0x82834020; continue 'dispatch;
	// 8283401C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82834020: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82834024: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82834028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283402C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834030: 4BD63C21  bl 0x82597c50
	ctx.lr = 0x82834034;
	sub_82597C50(ctx, base);
	// 82834034: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82834038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283403C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834040: 4BA8BFC1  bl 0x822c0000
	ctx.lr = 0x82834044;
	sub_822C0000(ctx, base);
	// 82834044: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82834048: 41820024  beq 0x8283406c
	if ctx.cr[0].eq {
	pc = 0x8283406C; continue 'dispatch;
	}
	// 8283404C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82834050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82834054: 419A0008  beq cr6, 0x8283405c
	if ctx.cr[6].eq {
	pc = 0x8283405C; continue 'dispatch;
	}
	// 82834058: 4BA8C839  bl 0x822c0890
	ctx.lr = 0x8283405C;
	sub_822C0890(ctx, base);
	// 8283405C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82834060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82834064: 419A0008  beq cr6, 0x8283406c
	if ctx.cr[6].eq {
	pc = 0x8283406C; continue 'dispatch;
	}
	// 82834068: 4BA8C829  bl 0x822c0890
	ctx.lr = 0x8283406C;
	sub_822C0890(ctx, base);
	// 8283406C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82834070: 419A000C  beq cr6, 0x8283407c
	if ctx.cr[6].eq {
	pc = 0x8283407C; continue 'dispatch;
	}
	// 82834074: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82834078: 4BA8C819  bl 0x822c0890
	ctx.lr = 0x8283407C;
	sub_822C0890(ctx, base);
	// 8283407C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82834080: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82834084: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82834088: 4897412C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834090 size=128
    let mut pc: u32 = 0x82834090;
    'dispatch: loop {
        match pc {
            0x82834090 => {
    //   block [0x82834090..0x82834110)
	// 82834090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834094: 489740D9  bl 0x831a816c
	ctx.lr = 0x82834098;
	sub_831A8130(ctx, base);
	// 82834098: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283409C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828340A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828340A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828340A8: 3BEBB3C4  addi r31, r11, -0x4c3c
	ctx.r[31].s64 = ctx.r[11].s64 + -19516;
	// 828340AC: 816AB3CC  lwz r11, -0x4c34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19508 as u32) ) } as u64;
	// 828340B0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828340B4: 40820024  bne 0x828340d8
	if !ctx.cr[0].eq {
	pc = 0x828340D8; continue 'dispatch;
	}
	// 828340B8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828340BC: 3D008283  lis r8, -0x7d7d
	ctx.r[8].s64 = -2105344000;
	// 828340C0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828340C4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828340C8: 39083720  addi r8, r8, 0x3720
	ctx.r[8].s64 = ctx.r[8].s64 + 14112;
	// 828340CC: 916AB3CC  stw r11, -0x4c34(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19508 as u32), ctx.r[11].u32 ) };
	// 828340D0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828340D4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828340D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828340DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828340E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828340E4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828340E8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828340EC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828340F0: 4BE204D1  bl 0x826545c0
	ctx.lr = 0x828340F4;
	sub_826545C0(ctx, base);
	// 828340F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828340F8: 4182000C  beq 0x82834104
	if ctx.cr[0].eq {
	pc = 0x82834104; continue 'dispatch;
	}
	// 828340FC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82834100: 48000008  b 0x82834108
	pc = 0x82834108; continue 'dispatch;
	// 82834104: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82834108: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283410C: 489740B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82834110 size=936
    let mut pc: u32 = 0x82834110;
    'dispatch: loop {
        match pc {
            0x82834110 => {
    //   block [0x82834110..0x828344B8)
	// 82834110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834114: 4897404D  bl 0x831a8160
	ctx.lr = 0x82834118;
	sub_831A8130(ctx, base);
	// 82834118: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283411C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834120: 4BFE6119  bl 0x8281a238
	ctx.lr = 0x82834124;
	sub_8281A238(ctx, base);
	// 82834124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834128: 4812C439  bl 0x82960560
	ctx.lr = 0x8283412C;
	sub_82960560(ctx, base);
	// 8283412C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834130: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82834134: 3B4BBF6C  addi r26, r11, -0x4094
	ctx.r[26].s64 = ctx.r[11].s64 + -16532;
	// 82834138: 41820054  beq 0x8283418c
	if ctx.cr[0].eq {
	pc = 0x8283418C; continue 'dispatch;
	}
	// 8283413C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82834140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834144: 485BF8C5  bl 0x82df3a08
	ctx.lr = 0x82834148;
	sub_82DF3A08(ctx, base);
	// 82834148: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8283414C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82834150: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82834154: 4BFBA6CD  bl 0x827ee820
	ctx.lr = 0x82834158;
	sub_827EE820(ctx, base);
	// 82834158: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283415C: 395E0254  addi r10, r30, 0x254
	ctx.r[10].s64 = ctx.r[30].s64 + 596;
	// 82834160: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82834164: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82834168: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283416C: 917E0254  stw r11, 0x254(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 82834170: 4BA902F1  bl 0x822c4460
	ctx.lr = 0x82834174;
	sub_822C4460(ctx, base);
	// 82834174: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82834178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283417C: 419A0008  beq cr6, 0x82834184
	if ctx.cr[6].eq {
	pc = 0x82834184; continue 'dispatch;
	}
	// 82834180: 4BA8C711  bl 0x822c0890
	ctx.lr = 0x82834184;
	sub_822C0890(ctx, base);
	// 82834184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834188: 485BF2A1  bl 0x82df3428
	ctx.lr = 0x8283418C;
	sub_82DF3428(ctx, base);
	// 8283418C: 817E0254  lwz r11, 0x254(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(596 as u32) ) } as u64;
	// 82834190: 3BFE0254  addi r31, r30, 0x254
	ctx.r[31].s64 = ctx.r[30].s64 + 596;
	// 82834194: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 82834198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283419C: 419A00C4  beq cr6, 0x82834260
	if ctx.cr[6].eq {
	pc = 0x82834260; continue 'dispatch;
	}
	// 828341A0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828341A4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828341A8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828341AC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828341B0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828341B4: 4866C57D  bl 0x82ea0730
	ctx.lr = 0x828341B8;
	sub_82EA0730(ctx, base);
	// 828341B8: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828341BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828341C0: C02BC664  lfs f1, -0x399c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828341C4: 486E602D  bl 0x82f1a1f0
	ctx.lr = 0x828341C8;
	sub_82F1A1F0(ctx, base);
	// 828341C8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828341CC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828341D0: 4182000C  beq 0x828341dc
	if ctx.cr[0].eq {
	pc = 0x828341DC; continue 'dispatch;
	}
	// 828341D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828341D8: 4BAB4071  bl 0x822e8248
	ctx.lr = 0x828341DC;
	sub_822E8248(ctx, base);
	// 828341DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828341E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828341E4: 388BCB48  addi r4, r11, -0x34b8
	ctx.r[4].s64 = ctx.r[11].s64 + -13496;
	// 828341E8: 485C5349  bl 0x82df9530
	ctx.lr = 0x828341EC;
	sub_82DF9530(ctx, base);
	// 828341EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828341F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828341F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828341F8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828341FC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82834200: 419A0024  beq cr6, 0x82834224
	if ctx.cr[6].eq {
	pc = 0x82834224; continue 'dispatch;
	}
	// 82834204: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82834208: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283420C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82834210: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82834214: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82834218: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283421C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82834220: 4082FFE8  bne 0x82834208
	if !ctx.cr[0].eq {
	pc = 0x82834208; continue 'dispatch;
	}
	// 82834224: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82834228: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8283422C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82834230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82834234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834238: 80CB6894  lwz r6, 0x6894(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26772 as u32) ) } as u64;
	// 8283423C: 4BCDEE25  bl 0x82513060
	ctx.lr = 0x82834240;
	sub_82513060(ctx, base);
	// 82834240: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82834244: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82834248: 419A0008  beq cr6, 0x82834250
	if ctx.cr[6].eq {
	pc = 0x82834250; continue 'dispatch;
	}
	// 8283424C: 4BAB401D  bl 0x822e8268
	ctx.lr = 0x82834250;
	sub_822E8268(ctx, base);
	// 82834250: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82834254: 419A000C  beq cr6, 0x82834260
	if ctx.cr[6].eq {
	pc = 0x82834260; continue 'dispatch;
	}
	// 82834258: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283425C: 4BAB400D  bl 0x822e8268
	ctx.lr = 0x82834260;
	sub_822E8268(ctx, base);
	// 82834260: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834264: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82834268: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8283426C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82834270: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82834274: 4866C4BD  bl 0x82ea0730
	ctx.lr = 0x82834278;
	sub_82EA0730(ctx, base);
	// 82834278: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 8283427C: 3F608208  lis r27, -0x7df8
	ctx.r[27].s64 = -2113404928;
	// 82834280: C03BBF9C  lfs f1, -0x4064(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16484 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82834284: 486E5F6D  bl 0x82f1a1f0
	ctx.lr = 0x82834288;
	sub_82F1A1F0(ctx, base);
	// 82834288: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283428C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834290: 388BC0F8  addi r4, r11, -0x3f08
	ctx.r[4].s64 = ctx.r[11].s64 + -16136;
	// 82834294: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82834298: 38A00098  li r5, 0x98
	ctx.r[5].s64 = 152;
	// 8283429C: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 828342A0: 485BE149  bl 0x82df23e8
	ctx.lr = 0x828342A4;
	sub_82DF23E8(ctx, base);
	// 828342A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828342A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828342AC: 41820018  beq 0x828342c4
	if ctx.cr[0].eq {
	pc = 0x828342C4; continue 'dispatch;
	}
	// 828342B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828342B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828342B8: 4812B331  bl 0x8295f5e8
	ctx.lr = 0x828342BC;
	sub_8295F5E8(ctx, base);
	// 828342BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828342C0: 48000008  b 0x828342c8
	pc = 0x828342C8; continue 'dispatch;
	// 828342C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828342C8: 3BFE025C  addi r31, r30, 0x25c
	ctx.r[31].s64 = ctx.r[30].s64 + 604;
	// 828342CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828342D0: 4BF24329  bl 0x827585f8
	ctx.lr = 0x828342D4;
	sub_827585F8(ctx, base);
	// 828342D4: 817E025C  lwz r11, 0x25c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(604 as u32) ) } as u64;
	// 828342D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828342DC: 419A0050  beq cr6, 0x8283432c
	if ctx.cr[6].eq {
	pc = 0x8283432C; continue 'dispatch;
	}
	// 828342E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828342E4: 4812B2B5  bl 0x8295f598
	ctx.lr = 0x828342E8;
	sub_8295F598(ctx, base);
	// 828342E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828342EC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828342F0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 828342F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828342F8: 816B6720  lwz r11, 0x6720(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26400 as u32) ) } as u64;
	// 828342FC: 814A8614  lwz r10, -0x79ec(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31212 as u32) ) } as u64;
	// 82834300: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82834304: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82834308: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8283430C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82834310: 912B0060  stw r9, 0x60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82834314: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834318: 4812B191  bl 0x8295f4a8
	ctx.lr = 0x8283431C;
	sub_8295F4A8(ctx, base);
	// 8283431C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82834320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82834324: 419A0008  beq cr6, 0x8283432c
	if ctx.cr[6].eq {
	pc = 0x8283432C; continue 'dispatch;
	}
	// 82834328: 4BA8C569  bl 0x822c0890
	ctx.lr = 0x8283432C;
	sub_822C0890(ctx, base);
	// 8283432C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834330: 4BFB7EA1  bl 0x827ec1d0
	ctx.lr = 0x82834334;
	sub_827EC1D0(ctx, base);
	// 82834334: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82834338: 41820054  beq 0x8283438c
	if ctx.cr[0].eq {
	pc = 0x8283438C; continue 'dispatch;
	}
	// 8283433C: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 82834340: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82834344: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82834348: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 8283434C: 388AC15C  addi r4, r10, -0x3ea4
	ctx.r[4].s64 = ctx.r[10].s64 + -16036;
	// 82834350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834354: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82834358: 485BF6B1  bl 0x82df3a08
	ctx.lr = 0x8283435C;
	sub_82DF3A08(ctx, base);
	// 8283435C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82834360: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 82834364: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82834368: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8283436C: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82834370: 4BFFFD21  bl 0x82834090
	ctx.lr = 0x82834374;
	sub_82834090(ctx, base);
	// 82834374: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82834378: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283437C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834380: 4BFB6489  bl 0x827ea808
	ctx.lr = 0x82834384;
	sub_827EA808(ctx, base);
	// 82834384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834388: 485BF0A1  bl 0x82df3428
	ctx.lr = 0x8283438C;
	sub_82DF3428(ctx, base);
	// 8283438C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834390: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82834394: 4BFB8235  bl 0x827ec5c8
	ctx.lr = 0x82834398;
	sub_827EC5C8(ctx, base);
	// 82834398: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8283439C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828343A0: 419A00F8  beq cr6, 0x82834498
	if ctx.cr[6].eq {
	pc = 0x82834498; continue 'dispatch;
	}
	// 828343A4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828343A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828343AC: 3BEBB3D0  addi r31, r11, -0x4c30
	ctx.r[31].s64 = ctx.r[11].s64 + -19504;
	// 828343B0: 816AB400  lwz r11, -0x4c00(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19456 as u32) ) } as u64;
	// 828343B4: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828343B8: 40820070  bne 0x82834428
	if !ctx.cr[0].eq {
	pc = 0x82834428; continue 'dispatch;
	}
	// 828343BC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828343C0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828343C4: 916AB400  stw r11, -0x4c00(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19456 as u32), ctx.r[11].u32 ) };
	// 828343C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828343CC: 485BF63D  bl 0x82df3a08
	ctx.lr = 0x828343D0;
	sub_82DF3A08(ctx, base);
	// 828343D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828343D4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828343D8: 388BBF44  addi r4, r11, -0x40bc
	ctx.r[4].s64 = ctx.r[11].s64 + -16572;
	// 828343DC: 485BF62D  bl 0x82df3a08
	ctx.lr = 0x828343E0;
	sub_82DF3A08(ctx, base);
	// 828343E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828343E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828343E8: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 828343EC: 3D008324  lis r8, -0x7cdc
	ctx.r[8].s64 = -2094792704;
	// 828343F0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828343F4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828343F8: 3868FBB8  addi r3, r8, -0x448
	ctx.r[3].s64 = ctx.r[8].s64 + -1096;
	// 828343FC: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82834400: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82834404: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82834408: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8283440C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82834410: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82834414: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82834418: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8283441C: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82834420: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82834424: 489740B5  bl 0x831a84d8
	ctx.lr = 0x82834428;
	sub_831A84D8(ctx, base);
	// 82834428: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283442C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82834430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834434: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82834438: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8283443C: 419A0024  beq cr6, 0x82834460
	if ctx.cr[6].eq {
	pc = 0x82834460; continue 'dispatch;
	}
	// 82834440: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82834444: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82834448: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283444C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82834450: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82834454: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82834458: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283445C: 4082FFE8  bne 0x82834444
	if !ctx.cr[0].eq {
	pc = 0x82834444; continue 'dispatch;
	}
	// 82834460: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82834464: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82834468: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8283446C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82834470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834474: 4BFB83CD  bl 0x827ec840
	ctx.lr = 0x82834478;
	sub_827EC840(ctx, base);
	// 82834478: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8283447C: 4182001C  beq 0x82834498
	if ctx.cr[0].eq {
	pc = 0x82834498; continue 'dispatch;
	}
	// 82834480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834484: C03BBF9C  lfs f1, -0x4064(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16484 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82834488: 4BFB7E01  bl 0x827ec288
	ctx.lr = 0x8283448C;
	sub_827EC288(ctx, base);
	// 8283448C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834494: 4BFB7DDD  bl 0x827ec270
	ctx.lr = 0x82834498;
	sub_827EC270(ctx, base);
	// 82834498: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283449C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828344A0: 419A0008  beq cr6, 0x828344a8
	if ctx.cr[6].eq {
	pc = 0x828344A8; continue 'dispatch;
	}
	// 828344A4: 4BA8C3ED  bl 0x822c0890
	ctx.lr = 0x828344A8;
	sub_822C0890(ctx, base);
	// 828344A8: C01E028C  lfs f0, 0x28c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828344AC: D01E0280  stfs f0, 0x280(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 828344B0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828344B4: 48973CFC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828344B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828344B8 size=452
    let mut pc: u32 = 0x828344B8;
    'dispatch: loop {
        match pc {
            0x828344B8 => {
    //   block [0x828344B8..0x8283467C)
	// 828344B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828344BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828344C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828344C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828344C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828344CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828344D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828344D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828344D8: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 828344DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828344E0: 485BF529  bl 0x82df3a08
	ctx.lr = 0x828344E4;
	sub_82DF3A08(ctx, base);
	// 828344E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828344E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828344EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828344F0: 4BFB7641  bl 0x827ebb30
	ctx.lr = 0x828344F4;
	sub_827EBB30(ctx, base);
	// 828344F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828344F8: 485BEF31  bl 0x82df3428
	ctx.lr = 0x828344FC;
	sub_82DF3428(ctx, base);
	// 828344FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834504: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 82834508: 485BF501  bl 0x82df3a08
	ctx.lr = 0x8283450C;
	sub_82DF3A08(ctx, base);
	// 8283450C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834514: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834518: 4BFB76E1  bl 0x827ebbf8
	ctx.lr = 0x8283451C;
	sub_827EBBF8(ctx, base);
	// 8283451C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834520: 485BEF09  bl 0x82df3428
	ctx.lr = 0x82834524;
	sub_82DF3428(ctx, base);
	// 82834524: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283452C: 388BC1C0  addi r4, r11, -0x3e40
	ctx.r[4].s64 = ctx.r[11].s64 + -15936;
	// 82834530: 485BF4D9  bl 0x82df3a08
	ctx.lr = 0x82834534;
	sub_82DF3A08(ctx, base);
	// 82834534: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283453C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834540: 4BFB75F1  bl 0x827ebb30
	ctx.lr = 0x82834544;
	sub_827EBB30(ctx, base);
	// 82834544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834548: 485BEEE1  bl 0x82df3428
	ctx.lr = 0x8283454C;
	sub_82DF3428(ctx, base);
	// 8283454C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834554: 388BC1B8  addi r4, r11, -0x3e48
	ctx.r[4].s64 = ctx.r[11].s64 + -15944;
	// 82834558: 485BF4B1  bl 0x82df3a08
	ctx.lr = 0x8283455C;
	sub_82DF3A08(ctx, base);
	// 8283455C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834564: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834568: 4BFB7691  bl 0x827ebbf8
	ctx.lr = 0x8283456C;
	sub_827EBBF8(ctx, base);
	// 8283456C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834570: 485BEEB9  bl 0x82df3428
	ctx.lr = 0x82834574;
	sub_82DF3428(ctx, base);
	// 82834574: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283457C: 388BC1B0  addi r4, r11, -0x3e50
	ctx.r[4].s64 = ctx.r[11].s64 + -15952;
	// 82834580: 485BF489  bl 0x82df3a08
	ctx.lr = 0x82834584;
	sub_82DF3A08(ctx, base);
	// 82834584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283458C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834590: 4BFB75A1  bl 0x827ebb30
	ctx.lr = 0x82834594;
	sub_827EBB30(ctx, base);
	// 82834594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834598: 485BEE91  bl 0x82df3428
	ctx.lr = 0x8283459C;
	sub_82DF3428(ctx, base);
	// 8283459C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828345A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828345A4: 388BC1A0  addi r4, r11, -0x3e60
	ctx.r[4].s64 = ctx.r[11].s64 + -15968;
	// 828345A8: 485BF461  bl 0x82df3a08
	ctx.lr = 0x828345AC;
	sub_82DF3A08(ctx, base);
	// 828345AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828345B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828345B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828345B8: 4BFB7579  bl 0x827ebb30
	ctx.lr = 0x828345BC;
	sub_827EBB30(ctx, base);
	// 828345BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828345C0: 485BEE69  bl 0x82df3428
	ctx.lr = 0x828345C4;
	sub_82DF3428(ctx, base);
	// 828345C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828345C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828345CC: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 828345D0: 485BF439  bl 0x82df3a08
	ctx.lr = 0x828345D4;
	sub_82DF3A08(ctx, base);
	// 828345D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828345D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828345DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828345E0: 4BFB7619  bl 0x827ebbf8
	ctx.lr = 0x828345E4;
	sub_827EBBF8(ctx, base);
	// 828345E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828345E8: 485BEE41  bl 0x82df3428
	ctx.lr = 0x828345EC;
	sub_82DF3428(ctx, base);
	// 828345EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828345F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828345F4: 388BC190  addi r4, r11, -0x3e70
	ctx.r[4].s64 = ctx.r[11].s64 + -15984;
	// 828345F8: 485BF411  bl 0x82df3a08
	ctx.lr = 0x828345FC;
	sub_82DF3A08(ctx, base);
	// 828345FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834600: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834608: 4BFB75F1  bl 0x827ebbf8
	ctx.lr = 0x8283460C;
	sub_827EBBF8(ctx, base);
	// 8283460C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834610: 485BEE19  bl 0x82df3428
	ctx.lr = 0x82834614;
	sub_82DF3428(ctx, base);
	// 82834614: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283461C: 388BC188  addi r4, r11, -0x3e78
	ctx.r[4].s64 = ctx.r[11].s64 + -15992;
	// 82834620: 485BF3E9  bl 0x82df3a08
	ctx.lr = 0x82834624;
	sub_82DF3A08(ctx, base);
	// 82834624: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283462C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834630: 4BFB7501  bl 0x827ebb30
	ctx.lr = 0x82834634;
	sub_827EBB30(ctx, base);
	// 82834634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834638: 485BEDF1  bl 0x82df3428
	ctx.lr = 0x8283463C;
	sub_82DF3428(ctx, base);
	// 8283463C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834644: 388BC17C  addi r4, r11, -0x3e84
	ctx.r[4].s64 = ctx.r[11].s64 + -16004;
	// 82834648: 485BF3C1  bl 0x82df3a08
	ctx.lr = 0x8283464C;
	sub_82DF3A08(ctx, base);
	// 8283464C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834650: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834658: 4BFB74D9  bl 0x827ebb30
	ctx.lr = 0x8283465C;
	sub_827EBB30(ctx, base);
	// 8283465C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834660: 485BEDC9  bl 0x82df3428
	ctx.lr = 0x82834664;
	sub_82DF3428(ctx, base);
	// 82834664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283466C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834670: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834674: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834680 size=72
    let mut pc: u32 = 0x82834680;
    'dispatch: loop {
        match pc {
            0x82834680 => {
    //   block [0x82834680..0x828346C8)
	// 82834680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834688: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283468C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834694: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82834698: 4BFBB0B9  bl 0x827ef750
	ctx.lr = 0x8283469C;
	sub_827EF750(ctx, base);
	// 8283469C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828346A0: 40820014  bne 0x828346b4
	if !ctx.cr[0].eq {
	pc = 0x828346B4; continue 'dispatch;
	}
	// 828346A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828346A8: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 828346AC: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 828346B0: 917F0268  stw r11, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[11].u32 ) };
	// 828346B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828346B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828346BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828346C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828346C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828346C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828346C8 size=128
    let mut pc: u32 = 0x828346C8;
    'dispatch: loop {
        match pc {
            0x828346C8 => {
    //   block [0x828346C8..0x82834748)
	// 828346C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828346CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828346D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828346D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828346D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828346DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828346E0: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 828346E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828346E8: 409A0010  bne cr6, 0x828346f8
	if !ctx.cr[6].eq {
	pc = 0x828346F8; continue 'dispatch;
	}
	// 828346EC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828346F0: 388BCFB0  addi r4, r11, -0x3050
	ctx.r[4].s64 = ctx.r[11].s64 + -12368;
	// 828346F4: 48000014  b 0x82834708
	pc = 0x82834708; continue 'dispatch;
	// 828346F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828346FC: 409A0034  bne cr6, 0x82834730
	if !ctx.cr[6].eq {
	pc = 0x82834730; continue 'dispatch;
	}
	// 82834700: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834704: 388B9B68  addi r4, r11, -0x6498
	ctx.r[4].s64 = ctx.r[11].s64 + -25752;
	// 82834708: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283470C: 485BF2FD  bl 0x82df3a08
	ctx.lr = 0x82834710;
	sub_82DF3A08(ctx, base);
	// 82834710: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834714: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283471C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82834720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834724: 4E800421  bctrl
	ctx.lr = 0x82834728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834728: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283472C: 4BFBAF8D  bl 0x827ef6b8
	ctx.lr = 0x82834730;
	sub_827EF6B8(ctx, base);
	// 82834730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283473C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834748 size=12
    let mut pc: u32 = 0x82834748;
    'dispatch: loop {
        match pc {
            0x82834748 => {
    //   block [0x82834748..0x82834754)
	// 82834748: 8163026C  lwz r11, 0x26c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(620 as u32) ) } as u64;
	// 8283474C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82834750: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834754(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834754 size=8
    let mut pc: u32 = 0x82834754;
    'dispatch: loop {
        match pc {
            0x82834754 => {
    //   block [0x82834754..0x8283475C)
	// 82834754: 4BFE4EBC  b 0x82819610
	sub_82819610(ctx, base);
	return;
	// 82834758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82834760 size=152
    let mut pc: u32 = 0x82834760;
    'dispatch: loop {
        match pc {
            0x82834760 => {
    //   block [0x82834760..0x828347F8)
	// 82834760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283476C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834778: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283477C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834780: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82834784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834788: 4E800421  bctrl
	ctx.lr = 0x8283478C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283478C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82834790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834794: 4BFE4515  bl 0x82818ca8
	ctx.lr = 0x82834798;
	sub_82818CA8(ctx, base);
	// 82834798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283479C: 481DEEE5  bl 0x82a13680
	ctx.lr = 0x828347A0;
	sub_82A13680(ctx, base);
	// 828347A0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828347A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828347A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828347AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828347B0: C02B6218  lfs f1, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828347B4: 4BFE45B5  bl 0x82818d68
	ctx.lr = 0x828347B8;
	sub_82818D68(ctx, base);
	// 828347B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828347BC: 481DEEC5  bl 0x82a13680
	ctx.lr = 0x828347C0;
	sub_82A13680(ctx, base);
	// 828347C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828347C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828347C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828347CC: C02BA9F0  lfs f1, -0x5610(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828347D0: 4BFE4861  bl 0x82819030
	ctx.lr = 0x828347D4;
	sub_82819030(ctx, base);
	// 828347D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828347D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828347DC: 4BFE4F4D  bl 0x82819728
	ctx.lr = 0x828347E0;
	sub_82819728(ctx, base);
	// 828347E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828347E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828347E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828347EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828347F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828347F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828347F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828347F8 size=84
    let mut pc: u32 = 0x828347F8;
    'dispatch: loop {
        match pc {
            0x828347F8 => {
    //   block [0x828347F8..0x8283484C)
	// 828347F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828347FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834804: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834808: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283480C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834810: 388BB454  addi r4, r11, -0x4bac
	ctx.r[4].s64 = ctx.r[11].s64 + -19372;
	// 82834814: 4BFBC015  bl 0x827f0828
	ctx.lr = 0x82834818;
	sub_827F0828(ctx, base);
	// 82834818: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283481C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834820: 388BB470  addi r4, r11, -0x4b90
	ctx.r[4].s64 = ctx.r[11].s64 + -19344;
	// 82834824: 4BFC18CD  bl 0x827f60f0
	ctx.lr = 0x82834828;
	sub_827F60F0(ctx, base);
	// 82834828: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283482C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834830: 388BB480  addi r4, r11, -0x4b80
	ctx.r[4].s64 = ctx.r[11].s64 + -19328;
	// 82834834: 4BFBC295  bl 0x827f0ac8
	ctx.lr = 0x82834838;
	sub_827F0AC8(ctx, base);
	// 82834838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283483C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834850 size=12
    let mut pc: u32 = 0x82834850;
    'dispatch: loop {
        match pc {
            0x82834850 => {
    //   block [0x82834850..0x8283485C)
	// 82834850: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834854: 386BAEC4  addi r3, r11, -0x513c
	ctx.r[3].s64 = ctx.r[11].s64 + -20796;
	// 82834858: 4BFE76D8  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834860 size=12
    let mut pc: u32 = 0x82834860;
    'dispatch: loop {
        match pc {
            0x82834860 => {
    //   block [0x82834860..0x8283486C)
	// 82834860: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834864: 386BAEC4  addi r3, r11, -0x513c
	ctx.r[3].s64 = ctx.r[11].s64 + -20796;
	// 82834868: 4BFE76D0  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834870 size=12
    let mut pc: u32 = 0x82834870;
    'dispatch: loop {
        match pc {
            0x82834870 => {
    //   block [0x82834870..0x8283487C)
	// 82834870: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834874: 386BC1C8  addi r3, r11, -0x3e38
	ctx.r[3].s64 = ctx.r[11].s64 + -15928;
	// 82834878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834880 size=12
    let mut pc: u32 = 0x82834880;
    'dispatch: loop {
        match pc {
            0x82834880 => {
    //   block [0x82834880..0x8283488C)
	// 82834880: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834884: 386BB470  addi r3, r11, -0x4b90
	ctx.r[3].s64 = ctx.r[11].s64 + -19344;
	// 82834888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834890 size=12
    let mut pc: u32 = 0x82834890;
    'dispatch: loop {
        match pc {
            0x82834890 => {
    //   block [0x82834890..0x8283489C)
	// 82834890: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834894: 386BB454  addi r3, r11, -0x4bac
	ctx.r[3].s64 = ctx.r[11].s64 + -19372;
	// 82834898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828348A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828348A0 size=12
    let mut pc: u32 = 0x828348A0;
    'dispatch: loop {
        match pc {
            0x828348A0 => {
    //   block [0x828348A0..0x828348AC)
	// 828348A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828348A4: 386BB480  addi r3, r11, -0x4b80
	ctx.r[3].s64 = ctx.r[11].s64 + -19328;
	// 828348A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828348B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828348B0 size=88
    let mut pc: u32 = 0x828348B0;
    'dispatch: loop {
        match pc {
            0x828348B0 => {
    //   block [0x828348B0..0x82834908)
	// 828348B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828348B4: 489738B9  bl 0x831a816c
	ctx.lr = 0x828348B8;
	sub_831A8130(ctx, base);
	// 828348B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828348BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828348C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828348C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828348C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828348CC: 388BC1E4  addi r4, r11, -0x3e1c
	ctx.r[4].s64 = ctx.r[11].s64 + -15900;
	// 828348D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828348D4: 485BF135  bl 0x82df3a08
	ctx.lr = 0x828348D8;
	sub_82DF3A08(ctx, base);
	// 828348D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828348DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828348E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828348E4: 4BFB7315  bl 0x827ebbf8
	ctx.lr = 0x828348E8;
	sub_827EBBF8(ctx, base);
	// 828348E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828348EC: 485BEB3D  bl 0x82df3428
	ctx.lr = 0x828348F0;
	sub_82DF3428(ctx, base);
	// 828348F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828348F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828348F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828348FC: 4BFFFBBD  bl 0x828344b8
	ctx.lr = 0x82834900;
	sub_828344B8(ctx, base);
	// 82834900: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82834904: 489738B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834908 size=8
    let mut pc: u32 = 0x82834908;
    'dispatch: loop {
        match pc {
            0x82834908 => {
    //   block [0x82834908..0x82834910)
	// 82834908: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283490C: 4BFB7964  b 0x827ec270
	sub_827EC270(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834910 size=84
    let mut pc: u32 = 0x82834910;
    'dispatch: loop {
        match pc {
            0x82834910 => {
    //   block [0x82834910..0x82834964)
	// 82834910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283491C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834920: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834928: 388BB4A0  addi r4, r11, -0x4b60
	ctx.r[4].s64 = ctx.r[11].s64 + -19296;
	// 8283492C: 4BFBBEFD  bl 0x827f0828
	ctx.lr = 0x82834930;
	sub_827F0828(ctx, base);
	// 82834930: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834938: 388BB4BC  addi r4, r11, -0x4b44
	ctx.r[4].s64 = ctx.r[11].s64 + -19268;
	// 8283493C: 4BFC17B5  bl 0x827f60f0
	ctx.lr = 0x82834940;
	sub_827F60F0(ctx, base);
	// 82834940: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82834944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834948: 388BB4CC  addi r4, r11, -0x4b34
	ctx.r[4].s64 = ctx.r[11].s64 + -19252;
	// 8283494C: 4BFBC17D  bl 0x827f0ac8
	ctx.lr = 0x82834950;
	sub_827F0AC8(ctx, base);
	// 82834950: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82834954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283495C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834968 size=12
    let mut pc: u32 = 0x82834968;
    'dispatch: loop {
        match pc {
            0x82834968 => {
    //   block [0x82834968..0x82834974)
	// 82834968: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283496C: 386BAECC  addi r3, r11, -0x5134
	ctx.r[3].s64 = ctx.r[11].s64 + -20788;
	// 82834970: 4BFE75C0  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834978 size=12
    let mut pc: u32 = 0x82834978;
    'dispatch: loop {
        match pc {
            0x82834978 => {
    //   block [0x82834978..0x82834984)
	// 82834978: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283497C: 386BAECC  addi r3, r11, -0x5134
	ctx.r[3].s64 = ctx.r[11].s64 + -20788;
	// 82834980: 4BFE75B8  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834988 size=12
    let mut pc: u32 = 0x82834988;
    'dispatch: loop {
        match pc {
            0x82834988 => {
    //   block [0x82834988..0x82834994)
	// 82834988: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283498C: 386BC1EC  addi r3, r11, -0x3e14
	ctx.r[3].s64 = ctx.r[11].s64 + -15892;
	// 82834990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834998 size=12
    let mut pc: u32 = 0x82834998;
    'dispatch: loop {
        match pc {
            0x82834998 => {
    //   block [0x82834998..0x828349A4)
	// 82834998: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283499C: 386BB4BC  addi r3, r11, -0x4b44
	ctx.r[3].s64 = ctx.r[11].s64 + -19268;
	// 828349A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828349A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828349A8 size=12
    let mut pc: u32 = 0x828349A8;
    'dispatch: loop {
        match pc {
            0x828349A8 => {
    //   block [0x828349A8..0x828349B4)
	// 828349A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828349AC: 386BB4A0  addi r3, r11, -0x4b60
	ctx.r[3].s64 = ctx.r[11].s64 + -19296;
	// 828349B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828349B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828349B8 size=12
    let mut pc: u32 = 0x828349B8;
    'dispatch: loop {
        match pc {
            0x828349B8 => {
    //   block [0x828349B8..0x828349C4)
	// 828349B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828349BC: 386BB4CC  addi r3, r11, -0x4b34
	ctx.r[3].s64 = ctx.r[11].s64 + -19252;
	// 828349C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828349C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828349C8 size=104
    let mut pc: u32 = 0x828349C8;
    'dispatch: loop {
        match pc {
            0x828349C8 => {
    //   block [0x828349C8..0x82834A30)
	// 828349C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828349CC: 489737A1  bl 0x831a816c
	ctx.lr = 0x828349D0;
	sub_831A8130(ctx, base);
	// 828349D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828349D4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 828349D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828349DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828349E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828349E4: 388B56F4  addi r4, r11, 0x56f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22260;
	// 828349E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828349EC: 485BF01D  bl 0x82df3a08
	ctx.lr = 0x828349F0;
	sub_82DF3A08(ctx, base);
	// 828349F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828349F4: C1BF0284  lfs f13, 0x284(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828349F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828349FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834A00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82834A04: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82834A08: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82834A0C: 4BFB72AD  bl 0x827ebcb8
	ctx.lr = 0x82834A10;
	sub_827EBCB8(ctx, base);
	// 82834A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834A14: 485BEA15  bl 0x82df3428
	ctx.lr = 0x82834A18;
	sub_82DF3428(ctx, base);
	// 82834A18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82834A1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82834A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834A24: 4BFFFA95  bl 0x828344b8
	ctx.lr = 0x82834A28;
	sub_828344B8(ctx, base);
	// 82834A28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82834A2C: 48973790  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82834A30 size=20
    let mut pc: u32 = 0x82834A30;
    'dispatch: loop {
        match pc {
            0x82834A30 => {
    //   block [0x82834A30..0x82834A44)
	// 82834A30: 8963009C  lbz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 82834A34: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82834A38: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82834A3C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82834A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834A48 size=88
    let mut pc: u32 = 0x82834A48;
    'dispatch: loop {
        match pc {
            0x82834A48 => {
    //   block [0x82834A48..0x82834AA0)
	// 82834A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834A5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82834A60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834A64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82834A68: 396BC2BC  addi r11, r11, -0x3d44
	ctx.r[11].s64 = ctx.r[11].s64 + -15684;
	// 82834A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834A70: 48627B19  bl 0x82e5c588
	ctx.lr = 0x82834A74;
	sub_82E5C588(ctx, base);
	// 82834A74: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82834A78: 4182000C  beq 0x82834a84
	if ctx.cr[0].eq {
	pc = 0x82834A84; continue 'dispatch;
	}
	// 82834A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834A80: 485BD959  bl 0x82df23d8
	ctx.lr = 0x82834A84;
	sub_82DF23D8(ctx, base);
	// 82834A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834A88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834A8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834A90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834A94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834A98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834A9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82834AA0 size=132
    let mut pc: u32 = 0x82834AA0;
    'dispatch: loop {
        match pc {
            0x82834AA0 => {
    //   block [0x82834AA0..0x82834B24)
	// 82834AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834AA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834AAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834AB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834AB8: 4BFB8D79  bl 0x827ed830
	ctx.lr = 0x82834ABC;
	sub_827ED830(ctx, base);
	// 82834ABC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82834AC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82834AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834AC8: 4BFB9FE1  bl 0x827eeaa8
	ctx.lr = 0x82834ACC;
	sub_827EEAA8(ctx, base);
	// 82834ACC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834B28 size=196
    let mut pc: u32 = 0x82834B28;
    'dispatch: loop {
        match pc {
            0x82834B28 => {
    //   block [0x82834B28..0x82834BEC)
	// 82834B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834B2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834B30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834B34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834B38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834B3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834B44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834B48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834B4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834B50: 4BA8BDE9  bl 0x822c0938
	ctx.lr = 0x82834B54;
	sub_822C0938(ctx, base);
	// 82834B54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82834B58: 41820028  beq 0x82834b80
	if ctx.cr[0].eq {
	pc = 0x82834B80; continue 'dispatch;
	}
	// 82834B5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834B60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82834B64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82834B68: 392BC208  addi r9, r11, -0x3df8
	ctx.r[9].s64 = ctx.r[11].s64 + -15864;
	// 82834B6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82834B70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82834B74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82834B78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82834B7C: 48000008  b 0x82834b84
	pc = 0x82834B84; continue 'dispatch;
	// 82834B80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834B84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834B8C: 409A0044  bne cr6, 0x82834bd0
	if !ctx.cr[6].eq {
	pc = 0x82834BD0; continue 'dispatch;
	}
	// 82834B90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82834B94: 419A001C  beq cr6, 0x82834bb0
	if ctx.cr[6].eq {
	pc = 0x82834BB0; continue 'dispatch;
	}
	// 82834B98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834B9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834BA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82834BA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834BAC: 4E800421  bctrl
	ctx.lr = 0x82834BB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834BB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82834BB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82834BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834BBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82834BC0: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82834BC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82834BC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82834BCC: 4BA8B435  bl 0x822c0000
	ctx.lr = 0x82834BD0;
	sub_822C0000(ctx, base);
	// 82834BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834BD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834BD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834BDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834BE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834BF0 size=196
    let mut pc: u32 = 0x82834BF0;
    'dispatch: loop {
        match pc {
            0x82834BF0 => {
    //   block [0x82834BF0..0x82834CB4)
	// 82834BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834BF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834BF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834BFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834C00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834C04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834C08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834C0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834C10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834C14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834C18: 4BA8BD21  bl 0x822c0938
	ctx.lr = 0x82834C1C;
	sub_822C0938(ctx, base);
	// 82834C1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82834C20: 41820028  beq 0x82834c48
	if ctx.cr[0].eq {
	pc = 0x82834C48; continue 'dispatch;
	}
	// 82834C24: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834C28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82834C2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82834C30: 392BC21C  addi r9, r11, -0x3de4
	ctx.r[9].s64 = ctx.r[11].s64 + -15844;
	// 82834C34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82834C38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82834C3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82834C40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82834C44: 48000008  b 0x82834c4c
	pc = 0x82834C4C; continue 'dispatch;
	// 82834C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834C4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834C54: 409A0044  bne cr6, 0x82834c98
	if !ctx.cr[6].eq {
	pc = 0x82834C98; continue 'dispatch;
	}
	// 82834C58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82834C5C: 419A001C  beq cr6, 0x82834c78
	if ctx.cr[6].eq {
	pc = 0x82834C78; continue 'dispatch;
	}
	// 82834C60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834C64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834C6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82834C70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834C74: 4E800421  bctrl
	ctx.lr = 0x82834C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834C78: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82834C7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82834C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834C84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82834C88: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82834C8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82834C90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82834C94: 4BA8B36D  bl 0x822c0000
	ctx.lr = 0x82834C98;
	sub_822C0000(ctx, base);
	// 82834C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834C9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834CA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834CB8 size=196
    let mut pc: u32 = 0x82834CB8;
    'dispatch: loop {
        match pc {
            0x82834CB8 => {
    //   block [0x82834CB8..0x82834D7C)
	// 82834CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834CC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834CC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834CC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834CCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834CD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834CD4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834CD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834CDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834CE0: 4BA8BC59  bl 0x822c0938
	ctx.lr = 0x82834CE4;
	sub_822C0938(ctx, base);
	// 82834CE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82834CE8: 41820028  beq 0x82834d10
	if ctx.cr[0].eq {
	pc = 0x82834D10; continue 'dispatch;
	}
	// 82834CEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834CF0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82834CF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82834CF8: 392BC230  addi r9, r11, -0x3dd0
	ctx.r[9].s64 = ctx.r[11].s64 + -15824;
	// 82834CFC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82834D00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82834D04: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82834D08: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82834D0C: 48000008  b 0x82834d14
	pc = 0x82834D14; continue 'dispatch;
	// 82834D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834D14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834D1C: 409A0044  bne cr6, 0x82834d60
	if !ctx.cr[6].eq {
	pc = 0x82834D60; continue 'dispatch;
	}
	// 82834D20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82834D24: 419A001C  beq cr6, 0x82834d40
	if ctx.cr[6].eq {
	pc = 0x82834D40; continue 'dispatch;
	}
	// 82834D28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834D2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834D34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82834D38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834D3C: 4E800421  bctrl
	ctx.lr = 0x82834D40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834D40: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82834D44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82834D48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834D4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82834D50: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82834D54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82834D58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82834D5C: 4BA8B2A5  bl 0x822c0000
	ctx.lr = 0x82834D60;
	sub_822C0000(ctx, base);
	// 82834D60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834D64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834D68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834D6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834D70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834D74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834D78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834D80 size=196
    let mut pc: u32 = 0x82834D80;
    'dispatch: loop {
        match pc {
            0x82834D80 => {
    //   block [0x82834D80..0x82834E44)
	// 82834D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834D94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834D9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834DA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834DA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834DA8: 4BA8BB91  bl 0x822c0938
	ctx.lr = 0x82834DAC;
	sub_822C0938(ctx, base);
	// 82834DAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82834DB0: 41820028  beq 0x82834dd8
	if ctx.cr[0].eq {
	pc = 0x82834DD8; continue 'dispatch;
	}
	// 82834DB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834DB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82834DBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82834DC0: 392BC244  addi r9, r11, -0x3dbc
	ctx.r[9].s64 = ctx.r[11].s64 + -15804;
	// 82834DC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82834DC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82834DCC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82834DD0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82834DD4: 48000008  b 0x82834ddc
	pc = 0x82834DDC; continue 'dispatch;
	// 82834DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834DDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834DE4: 409A0044  bne cr6, 0x82834e28
	if !ctx.cr[6].eq {
	pc = 0x82834E28; continue 'dispatch;
	}
	// 82834DE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82834DEC: 419A001C  beq cr6, 0x82834e08
	if ctx.cr[6].eq {
	pc = 0x82834E08; continue 'dispatch;
	}
	// 82834DF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834DF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834DFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834E00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834E04: 4E800421  bctrl
	ctx.lr = 0x82834E08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834E08: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82834E0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82834E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834E14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82834E18: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82834E1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82834E20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82834E24: 4BA8B1DD  bl 0x822c0000
	ctx.lr = 0x82834E28;
	sub_822C0000(ctx, base);
	// 82834E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834E2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834E30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834E34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834E38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834E3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834E48 size=196
    let mut pc: u32 = 0x82834E48;
    'dispatch: loop {
        match pc {
            0x82834E48 => {
    //   block [0x82834E48..0x82834F0C)
	// 82834E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834E5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834E60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834E64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834E68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834E6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834E70: 4BA8BAC9  bl 0x822c0938
	ctx.lr = 0x82834E74;
	sub_822C0938(ctx, base);
	// 82834E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82834E78: 41820028  beq 0x82834ea0
	if ctx.cr[0].eq {
	pc = 0x82834EA0; continue 'dispatch;
	}
	// 82834E7C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834E80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82834E84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82834E88: 392BC258  addi r9, r11, -0x3da8
	ctx.r[9].s64 = ctx.r[11].s64 + -15784;
	// 82834E8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82834E90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82834E94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82834E98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82834E9C: 48000008  b 0x82834ea4
	pc = 0x82834EA4; continue 'dispatch;
	// 82834EA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834EA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834EA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834EAC: 409A0044  bne cr6, 0x82834ef0
	if !ctx.cr[6].eq {
	pc = 0x82834EF0; continue 'dispatch;
	}
	// 82834EB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82834EB4: 419A001C  beq cr6, 0x82834ed0
	if ctx.cr[6].eq {
	pc = 0x82834ED0; continue 'dispatch;
	}
	// 82834EB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834EBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834EC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834ECC: 4E800421  bctrl
	ctx.lr = 0x82834ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834ED0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82834ED4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82834ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834EDC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82834EE0: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82834EE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82834EE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82834EEC: 4BA8B115  bl 0x822c0000
	ctx.lr = 0x82834EF0;
	sub_822C0000(ctx, base);
	// 82834EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834EF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834EF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834EFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834F00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834F04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834F10 size=196
    let mut pc: u32 = 0x82834F10;
    'dispatch: loop {
        match pc {
            0x82834F10 => {
    //   block [0x82834F10..0x82834FD4)
	// 82834F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834F18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834F1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834F20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834F24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834F28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834F2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834F30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834F34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834F38: 4BA8BA01  bl 0x822c0938
	ctx.lr = 0x82834F3C;
	sub_822C0938(ctx, base);
	// 82834F3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82834F40: 41820028  beq 0x82834f68
	if ctx.cr[0].eq {
	pc = 0x82834F68; continue 'dispatch;
	}
	// 82834F44: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82834F48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82834F4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82834F50: 392BC26C  addi r9, r11, -0x3d94
	ctx.r[9].s64 = ctx.r[11].s64 + -15764;
	// 82834F54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82834F58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82834F5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82834F60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82834F64: 48000008  b 0x82834f6c
	pc = 0x82834F6C; continue 'dispatch;
	// 82834F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834F6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82834F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82834F74: 409A0044  bne cr6, 0x82834fb8
	if !ctx.cr[6].eq {
	pc = 0x82834FB8; continue 'dispatch;
	}
	// 82834F78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82834F7C: 419A001C  beq cr6, 0x82834f98
	if ctx.cr[6].eq {
	pc = 0x82834F98; continue 'dispatch;
	}
	// 82834F80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834F84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82834F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82834F8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82834F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82834F94: 4E800421  bctrl
	ctx.lr = 0x82834F98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82834F98: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82834F9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82834FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82834FA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82834FA8: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82834FAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82834FB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82834FB4: 4BA8B04D  bl 0x822c0000
	ctx.lr = 0x82834FB8;
	sub_822C0000(ctx, base);
	// 82834FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82834FBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82834FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82834FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82834FC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82834FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82834FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82834FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82834FD8 size=196
    let mut pc: u32 = 0x82834FD8;
    'dispatch: loop {
        match pc {
            0x82834FD8 => {
    //   block [0x82834FD8..0x8283509C)
	// 82834FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82834FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82834FE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82834FE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82834FE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82834FEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82834FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82834FF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82834FF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82834FFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82835000: 4BA8B939  bl 0x822c0938
	ctx.lr = 0x82835004;
	sub_822C0938(ctx, base);
	// 82835004: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82835008: 41820028  beq 0x82835030
	if ctx.cr[0].eq {
	pc = 0x82835030; continue 'dispatch;
	}
	// 8283500C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835010: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82835014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82835018: 392BC280  addi r9, r11, -0x3d80
	ctx.r[9].s64 = ctx.r[11].s64 + -15744;
	// 8283501C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82835020: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82835024: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82835028: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283502C: 48000008  b 0x82835034
	pc = 0x82835034; continue 'dispatch;
	// 82835030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82835034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82835038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283503C: 409A0044  bne cr6, 0x82835080
	if !ctx.cr[6].eq {
	pc = 0x82835080; continue 'dispatch;
	}
	// 82835040: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82835044: 419A001C  beq cr6, 0x82835060
	if ctx.cr[6].eq {
	pc = 0x82835060; continue 'dispatch;
	}
	// 82835048: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283504C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82835050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835054: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835058: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283505C: 4E800421  bctrl
	ctx.lr = 0x82835060;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835060: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82835064: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82835068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283506C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82835070: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82835074: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82835078: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283507C: 4BA8AF85  bl 0x822c0000
	ctx.lr = 0x82835080;
	sub_822C0000(ctx, base);
	// 82835080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82835084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283508C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828350A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828350A0 size=196
    let mut pc: u32 = 0x828350A0;
    'dispatch: loop {
        match pc {
            0x828350A0 => {
    //   block [0x828350A0..0x82835164)
	// 828350A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828350A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828350A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828350AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828350B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828350B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828350B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828350BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828350C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828350C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828350C8: 4BA8B871  bl 0x822c0938
	ctx.lr = 0x828350CC;
	sub_822C0938(ctx, base);
	// 828350CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828350D0: 41820028  beq 0x828350f8
	if ctx.cr[0].eq {
	pc = 0x828350F8; continue 'dispatch;
	}
	// 828350D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828350D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828350DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828350E0: 392BC294  addi r9, r11, -0x3d6c
	ctx.r[9].s64 = ctx.r[11].s64 + -15724;
	// 828350E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828350E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828350EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828350F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828350F4: 48000008  b 0x828350fc
	pc = 0x828350FC; continue 'dispatch;
	// 828350F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828350FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82835100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835104: 409A0044  bne cr6, 0x82835148
	if !ctx.cr[6].eq {
	pc = 0x82835148; continue 'dispatch;
	}
	// 82835108: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283510C: 419A001C  beq cr6, 0x82835128
	if ctx.cr[6].eq {
	pc = 0x82835128; continue 'dispatch;
	}
	// 82835110: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835114: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82835118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283511C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835124: 4E800421  bctrl
	ctx.lr = 0x82835128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835128: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283512C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82835130: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835134: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82835138: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 8283513C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82835140: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82835144: 4BA8AEBD  bl 0x822c0000
	ctx.lr = 0x82835148;
	sub_822C0000(ctx, base);
	// 82835148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283514C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835158: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283515C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835168 size=196
    let mut pc: u32 = 0x82835168;
    'dispatch: loop {
        match pc {
            0x82835168 => {
    //   block [0x82835168..0x8283522C)
	// 82835168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283516C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82835174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283517C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82835180: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82835184: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82835188: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283518C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82835190: 4BA8B7A9  bl 0x822c0938
	ctx.lr = 0x82835194;
	sub_822C0938(ctx, base);
	// 82835194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82835198: 41820028  beq 0x828351c0
	if ctx.cr[0].eq {
	pc = 0x828351C0; continue 'dispatch;
	}
	// 8283519C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828351A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828351A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828351A8: 392BC2A8  addi r9, r11, -0x3d58
	ctx.r[9].s64 = ctx.r[11].s64 + -15704;
	// 828351AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828351B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828351B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828351B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828351BC: 48000008  b 0x828351c4
	pc = 0x828351C4; continue 'dispatch;
	// 828351C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828351C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828351C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828351CC: 409A0044  bne cr6, 0x82835210
	if !ctx.cr[6].eq {
	pc = 0x82835210; continue 'dispatch;
	}
	// 828351D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828351D4: 419A001C  beq cr6, 0x828351f0
	if ctx.cr[6].eq {
	pc = 0x828351F0; continue 'dispatch;
	}
	// 828351D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828351DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828351E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828351E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828351E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828351EC: 4E800421  bctrl
	ctx.lr = 0x828351F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828351F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828351F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828351F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828351FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82835200: 816B1278  lwz r11, 0x1278(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82835204: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82835208: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283520C: 4BA8ADF5  bl 0x822c0000
	ctx.lr = 0x82835210;
	sub_822C0000(ctx, base);
	// 82835210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82835214: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283521C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835220: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835224: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82835230 size=144
    let mut pc: u32 = 0x82835230;
    'dispatch: loop {
        match pc {
            0x82835230 => {
    //   block [0x82835230..0x828352C0)
	// 82835230: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828352C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828352C0 size=116
    let mut pc: u32 = 0x828352C0;
    'dispatch: loop {
        match pc {
            0x828352C0 => {
    //   block [0x828352C0..0x82835334)
	// 828352C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828352C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828352C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828352CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828352D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828352D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828352D8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828352DC: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828352E0: 396BC364  addi r11, r11, -0x3c9c
	ctx.r[11].s64 = ctx.r[11].s64 + -15516;
	// 828352E4: 394AC350  addi r10, r10, -0x3cb0
	ctx.r[10].s64 = ctx.r[10].s64 + -15536;
	// 828352E8: 3929C304  addi r9, r9, -0x3cfc
	ctx.r[9].s64 = ctx.r[9].s64 + -15612;
	// 828352EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828352F0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828352F4: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828352F8: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 828352FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835300: 419A0008  beq cr6, 0x82835308
	if ctx.cr[6].eq {
	pc = 0x82835308; continue 'dispatch;
	}
	// 82835304: 4BA8B58D  bl 0x822c0890
	ctx.lr = 0x82835308;
	sub_822C0890(ctx, base);
	// 82835308: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 8283530C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835310: 419A0008  beq cr6, 0x82835318
	if ctx.cr[6].eq {
	pc = 0x82835318; continue 'dispatch;
	}
	// 82835314: 4BA8B57D  bl 0x822c0890
	ctx.lr = 0x82835318;
	sub_822C0890(ctx, base);
	// 82835318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283531C: 4BFE2B5D  bl 0x82817e78
	ctx.lr = 0x82835320;
	sub_82817E78(ctx, base);
	// 82835320: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82835324: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835328: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283532C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82835338 size=8
    let mut pc: u32 = 0x82835338;
    'dispatch: loop {
        match pc {
            0x82835338 => {
    //   block [0x82835338..0x82835340)
	// 82835338: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8283533C: 480005DC  b 0x82835918
	sub_82835918(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82835340 size=8
    let mut pc: u32 = 0x82835340;
    'dispatch: loop {
        match pc {
            0x82835340 => {
    //   block [0x82835340..0x82835348)
	// 82835340: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 82835344: 480005D4  b 0x82835918
	sub_82835918(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835348 size=168
    let mut pc: u32 = 0x82835348;
    'dispatch: loop {
        match pc {
            0x82835348 => {
    //   block [0x82835348..0x828353F0)
	// 82835348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283534C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835354: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835358: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 8283535C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82835360: 409A007C  bne cr6, 0x828353dc
	if !ctx.cr[6].eq {
	pc = 0x828353DC; continue 'dispatch;
	}
	// 82835364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82835368: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8283536C: 3BE3FDF8  addi r31, r3, -0x208
	ctx.r[31].s64 = ctx.r[3].s64 + -520;
	// 82835370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835374: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82835378: C1AABF90  lfs f13, -0x4070(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16496 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283537C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82835380: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82835384: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82835388: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283538C: 481DE2FD  bl 0x82a13688
	ctx.lr = 0x82835390;
	sub_82A13688(ctx, base);
	// 82835390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82835394: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82835398: 48646B01  bl 0x82e7be98
	ctx.lr = 0x8283539C;
	sub_82E7BE98(ctx, base);
	// 8283539C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828353A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828353A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828353A8: 48646921  bl 0x82e7bcc8
	ctx.lr = 0x828353AC;
	sub_82E7BCC8(ctx, base);
	// 828353AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828353B0: 481DE2D1  bl 0x82a13680
	ctx.lr = 0x828353B4;
	sub_82A13680(ctx, base);
	// 828353B4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 828353B8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828353BC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828353C0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828353C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828353C8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828353CC: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828353F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828353F0 size=8
    let mut pc: u32 = 0x828353F0;
    'dispatch: loop {
        match pc {
            0x828353F0 => {
    //   block [0x828353F0..0x828353F8)
	// 828353F0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828353F4: 48000C44  b 0x82836038
	sub_82836038(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828353F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828353F8 size=8
    let mut pc: u32 = 0x828353F8;
    'dispatch: loop {
        match pc {
            0x828353F8 => {
    //   block [0x828353F8..0x82835400)
	// 828353F8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828353FC: 48000C3C  b 0x82836038
	sub_82836038(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835400 size=184
    let mut pc: u32 = 0x82835400;
    'dispatch: loop {
        match pc {
            0x82835400 => {
    //   block [0x82835400..0x828354B8)
	// 82835400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835404: 48972D69  bl 0x831a816c
	ctx.lr = 0x82835408;
	sub_831A8130(ctx, base);
	// 82835408: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8283540C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835410: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82835414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82835418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283541C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82835424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835428: 4E800421  bctrl
	ctx.lr = 0x8283542C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283542C: 389E0070  addi r4, r30, 0x70
	ctx.r[4].s64 = ctx.r[30].s64 + 112;
	// 82835430: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82835434: 4BFFFDFD  bl 0x82835230
	ctx.lr = 0x82835438;
	sub_82835230(ctx, base);
	// 82835438: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283543C: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82835440: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82835444: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82835448: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8283544C: 41980060  blt cr6, 0x828354ac
	if ctx.cr[6].lt {
	pc = 0x828354AC; continue 'dispatch;
	}
	// 82835450: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82835454: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82835458: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8283545C: 41990050  bgt cr6, 0x828354ac
	if ctx.cr[6].gt {
	pc = 0x828354AC; continue 'dispatch;
	}
	// 82835460: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82835464: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82835468: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8283546C: 4897395D  bl 0x831a8dc8
	ctx.lr = 0x82835470;
	sub_831A8DC8(ctx, base);
	// 82835470: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82835474: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835478: C1BE0084  lfs f13, 0x84(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283547C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82835480: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82835484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835488: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283548C: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82835490: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82835494: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82835498: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283549C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828354A0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828354A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828354A8: 4E800421  bctrl
	ctx.lr = 0x828354AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828354AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828354B0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828354B4: 48972D08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828354B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828354B8 size=176
    let mut pc: u32 = 0x828354B8;
    'dispatch: loop {
        match pc {
            0x828354B8 => {
    //   block [0x828354B8..0x82835568)
	// 828354B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828354BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828354C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828354C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828354C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828354CC: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 828354D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828354D4: 3BC30064  addi r30, r3, 0x64
	ctx.r[30].s64 = ctx.r[3].s64 + 100;
	// 828354D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828354DC: 419A0058  beq cr6, 0x82835534
	if ctx.cr[6].eq {
	pc = 0x82835534; continue 'dispatch;
	}
	// 828354E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828354E4: 38830070  addi r4, r3, 0x70
	ctx.r[4].s64 = ctx.r[3].s64 + 112;
	// 828354E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828354EC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828354F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828354F4: 4E800421  bctrl
	ctx.lr = 0x828354F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828354F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828354FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835500: 4BFB8B41  bl 0x827ee040
	ctx.lr = 0x82835504;
	sub_827EE040(ctx, base);
	// 82835504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283550C: 4BFB9285  bl 0x827ee790
	ctx.lr = 0x82835510;
	sub_827EE790(ctx, base);
	// 82835510: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835518: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8283551C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835520: 4E800421  bctrl
	ctx.lr = 0x82835524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835524: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82835528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283552C: 419A0008  beq cr6, 0x82835534
	if ctx.cr[6].eq {
	pc = 0x82835534; continue 'dispatch;
	}
	// 82835530: 4BA8B361  bl 0x822c0890
	ctx.lr = 0x82835534;
	sub_822C0890(ctx, base);
	// 82835534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835538: 4BFBA249  bl 0x827ef780
	ctx.lr = 0x8283553C;
	sub_827EF780(ctx, base);
	// 8283553C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82835540: 41820010  beq 0x82835550
	if ctx.cr[0].eq {
	pc = 0x82835550; continue 'dispatch;
	}
	// 82835544: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82835548: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283554C: 4BFB4D65  bl 0x827ea2b0
	ctx.lr = 0x82835550;
	sub_827EA2B0(ctx, base);
	// 82835550: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283555C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835568 size=104
    let mut pc: u32 = 0x82835568;
    'dispatch: loop {
        match pc {
            0x82835568 => {
    //   block [0x82835568..0x828355D0)
	// 82835568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283556C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835574: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283557C: 4BFB9215  bl 0x827ee790
	ctx.lr = 0x82835580;
	sub_827EE790(ctx, base);
	// 82835580: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835584: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835588: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8283558C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835590: 4E800421  bctrl
	ctx.lr = 0x82835594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835594: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82835598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283559C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828355A0: 419A000C  beq cr6, 0x828355ac
	if ctx.cr[6].eq {
	pc = 0x828355AC; continue 'dispatch;
	}
	// 828355A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828355A8: 4BA8B2E9  bl 0x822c0890
	ctx.lr = 0x828355AC;
	sub_822C0890(ctx, base);
	// 828355AC: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828355B0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828355B4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828355B8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 828355BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828355C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828355C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828355C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828355CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828355D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828355D0 size=120
    let mut pc: u32 = 0x828355D0;
    'dispatch: loop {
        match pc {
            0x828355D0 => {
    //   block [0x828355D0..0x82835648)
	// 828355D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828355D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828355D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828355DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828355E0: 4BFB91B1  bl 0x827ee790
	ctx.lr = 0x828355E4;
	sub_827EE790(ctx, base);
	// 828355E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828355E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828355EC: 419A003C  beq cr6, 0x82835628
	if ctx.cr[6].eq {
	pc = 0x82835628; continue 'dispatch;
	}
	// 828355F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828355F4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828355F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828355FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82835600: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82835604: C1A99534  lfs f13, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82835608: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8283560C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82835610: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82835614: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82835618: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283561C: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82835620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835624: 4E800421  bctrl
	ctx.lr = 0x82835628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835628: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283562C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835630: 419A0008  beq cr6, 0x82835638
	if ctx.cr[6].eq {
	pc = 0x82835638; continue 'dispatch;
	}
	// 82835634: 4BA8B25D  bl 0x822c0890
	ctx.lr = 0x82835638;
	sub_822C0890(ctx, base);
	// 82835638: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283563C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835648 size=264
    let mut pc: u32 = 0x82835648;
    'dispatch: loop {
        match pc {
            0x82835648 => {
    //   block [0x82835648..0x82835750)
	// 82835648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283564C: 48972B1D  bl 0x831a8168
	ctx.lr = 0x82835650;
	sub_831A8130(ctx, base);
	// 82835650: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835654: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82835658: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283565C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82835660: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 82835664: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82835668: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 8283566C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835670: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82835674: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82835678: 3BA10090  addi r29, r1, 0x90
	ctx.r[29].s64 = ctx.r[1].s64 + 144;
	// 8283567C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82835680: 3B8100A0  addi r28, r1, 0xa0
	ctx.r[28].s64 = ctx.r[1].s64 + 160;
	// 82835684: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82835688: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283568C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82835690: 13875C07  vcmpneb. (lvlx128) v28, v7, v11
	tmp.u32 = ctx.r[7].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82835694: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82835698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835750 size=108
    let mut pc: u32 = 0x82835750;
    'dispatch: loop {
        match pc {
            0x82835750 => {
    //   block [0x82835750..0x828357BC)
	// 82835750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283575C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835764: 4802D3B5  bl 0x82862b18
	ctx.lr = 0x82835768;
	sub_82862B18(ctx, base);
	// 82835768: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283576C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82835770: 392BC50C  addi r9, r11, -0x3af4
	ctx.r[9].s64 = ctx.r[11].s64 + -15092;
	// 82835774: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82835778: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283577C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82835780: 39200070  li r9, 0x70
	ctx.r[9].s64 = 112;
	// 82835784: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82835788: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8283578C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82835790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835794: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828357C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828357C0 size=76
    let mut pc: u32 = 0x828357C0;
    'dispatch: loop {
        match pc {
            0x828357C0 => {
    //   block [0x828357C0..0x8283580C)
	// 828357C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828357C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828357C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828357CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828357D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828357D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828357D8: 396BC50C  addi r11, r11, -0x3af4
	ctx.r[11].s64 = ctx.r[11].s64 + -15092;
	// 828357DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828357E0: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 828357E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828357E8: 419A0008  beq cr6, 0x828357f0
	if ctx.cr[6].eq {
	pc = 0x828357F0; continue 'dispatch;
	}
	// 828357EC: 4BA8B0A5  bl 0x822c0890
	ctx.lr = 0x828357F0;
	sub_822C0890(ctx, base);
	// 828357F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828357F4: 48626D95  bl 0x82e5c588
	ctx.lr = 0x828357F8;
	sub_82E5C588(ctx, base);
	// 828357F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828357FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835810 size=76
    let mut pc: u32 = 0x82835810;
    'dispatch: loop {
        match pc {
            0x82835810 => {
    //   block [0x82835810..0x8283585C)
	// 82835810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283581C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835828: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283582C: 4BFFFF95  bl 0x828357c0
	ctx.lr = 0x82835830;
	sub_828357C0(ctx, base);
	// 82835830: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82835834: 4182000C  beq 0x82835840
	if ctx.cr[0].eq {
	pc = 0x82835840; continue 'dispatch;
	}
	// 82835838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283583C: 485BCB9D  bl 0x82df23d8
	ctx.lr = 0x82835840;
	sub_82DF23D8(ctx, base);
	// 82835840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835844: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835848: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283584C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835850: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835860 size=180
    let mut pc: u32 = 0x82835860;
    'dispatch: loop {
        match pc {
            0x82835860 => {
    //   block [0x82835860..0x82835914)
	// 82835860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283586C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835878: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283587C: 4BFE276D  bl 0x82817fe8
	ctx.lr = 0x82835880;
	sub_82817FE8(ctx, base);
	// 82835880: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835884: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82835888: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283588C: 396BC364  addi r11, r11, -0x3c9c
	ctx.r[11].s64 = ctx.r[11].s64 + -15516;
	// 82835890: 394AC350  addi r10, r10, -0x3cb0
	ctx.r[10].s64 = ctx.r[10].s64 + -15536;
	// 82835894: 3929C304  addi r9, r9, -0x3cfc
	ctx.r[9].s64 = ctx.r[9].s64 + -15612;
	// 82835898: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283589C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828358A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828358A4: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828358A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828358AC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828358B0: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 828358B4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828358B8: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 828358BC: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 828358C0: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 828358C4: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 828358C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828358CC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828358D0: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 828358D4: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828358D8: 93DF0268  stw r30, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[30].u32 ) };
	// 828358DC: C18889AC  lfs f12, -0x7654(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828358E0: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 828358E4: C167D7BC  lfs f11, -0x2844(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828358E8: 997F0274  stb r11, 0x274(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u8 ) };
	// 828358EC: D01F0270  stfs f0, 0x270(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 828358F0: D1BF0278  stfs f13, 0x278(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 828358F4: D19F027C  stfs f12, 0x27c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), tmp.u32 ) };
	// 828358F8: D17F0280  stfs f11, 0x280(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 828358FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283590C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835918 size=76
    let mut pc: u32 = 0x82835918;
    'dispatch: loop {
        match pc {
            0x82835918 => {
    //   block [0x82835918..0x82835964)
	// 82835918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283591C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82835924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283592C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835930: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82835934: 4BFFF98D  bl 0x828352c0
	ctx.lr = 0x82835938;
	sub_828352C0(ctx, base);
	// 82835938: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283593C: 4182000C  beq 0x82835948
	if ctx.cr[0].eq {
	pc = 0x82835948; continue 'dispatch;
	}
	// 82835940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835944: 485BCA95  bl 0x82df23d8
	ctx.lr = 0x82835948;
	sub_82DF23D8(ctx, base);
	// 82835948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283594C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835950: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835954: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835958: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283595C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835968 size=928
    let mut pc: u32 = 0x82835968;
    'dispatch: loop {
        match pc {
            0x82835968 => {
    //   block [0x82835968..0x82835D08)
	// 82835968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283596C: 489727FD  bl 0x831a8168
	ctx.lr = 0x82835970;
	sub_831A8130(ctx, base);
	// 82835970: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835974: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82835978: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283597C: 897C0274  lbz r11, 0x274(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(628 as u32) ) } as u64;
	// 82835980: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82835984: 4182035C  beq 0x82835ce0
	if ctx.cr[0].eq {
	pc = 0x82835CE0; continue 'dispatch;
	}
	// 82835988: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8283598C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82835990: C02B2534  lfs f1, 0x2534(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9524 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82835994: 4BFB86CD  bl 0x827ee060
	ctx.lr = 0x82835998;
	sub_827EE060(ctx, base);
	// 82835998: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283599C: 41820344  beq 0x82835ce0
	if ctx.cr[0].eq {
	pc = 0x82835CE0; continue 'dispatch;
	}
	// 828359A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828359A4: C03C0280  lfs f1, 0x280(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828359A8: 4BFB8399  bl 0x827edd40
	ctx.lr = 0x828359AC;
	sub_827EDD40(ctx, base);
	// 828359AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828359B0: 41820330  beq 0x82835ce0
	if ctx.cr[0].eq {
	pc = 0x82835CE0; continue 'dispatch;
	}
	// 828359B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828359B8: 4BFB9229  bl 0x827eebe0
	ctx.lr = 0x828359BC;
	sub_827EEBE0(ctx, base);
	// 828359BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828359C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828359C4: 388BC1C0  addi r4, r11, -0x3e40
	ctx.r[4].s64 = ctx.r[11].s64 + -15936;
	// 828359C8: 485BE041  bl 0x82df3a08
	ctx.lr = 0x828359CC;
	sub_82DF3A08(ctx, base);
	// 828359CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828359D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828359D4: 4802DCED  bl 0x828636c0
	ctx.lr = 0x828359D8;
	sub_828636C0(ctx, base);
	// 828359D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828359DC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828359E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828359E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828359E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828359EC: 419A0024  beq cr6, 0x82835a10
	if ctx.cr[6].eq {
	pc = 0x82835A10; continue 'dispatch;
	}
	// 828359F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828359F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828359F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828359FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82835A00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82835A04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82835A08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835A0C: 4082FFE8  bne 0x828359f4
	if !ctx.cr[0].eq {
	pc = 0x828359F4; continue 'dispatch;
	}
	// 82835A10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82835A14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82835A18: 4BFB9C89  bl 0x827ef6a0
	ctx.lr = 0x82835A1C;
	sub_827EF6A0(ctx, base);
	// 82835A1C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82835A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835A24: 419A0008  beq cr6, 0x82835a2c
	if ctx.cr[6].eq {
	pc = 0x82835A2C; continue 'dispatch;
	}
	// 82835A28: 4BA8AE69  bl 0x822c0890
	ctx.lr = 0x82835A2C;
	sub_822C0890(ctx, base);
	// 82835A2C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82835A30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835A34: 419A0008  beq cr6, 0x82835a3c
	if ctx.cr[6].eq {
	pc = 0x82835A3C; continue 'dispatch;
	}
	// 82835A38: 4BA8AE59  bl 0x822c0890
	ctx.lr = 0x82835A3C;
	sub_822C0890(ctx, base);
	// 82835A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835A40: 485BD9E9  bl 0x82df3428
	ctx.lr = 0x82835A44;
	sub_82DF3428(ctx, base);
	// 82835A44: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835A48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82835A4C: 3BCBC548  addi r30, r11, -0x3ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -15032;
	// 82835A50: 38A001A7  li r5, 0x1a7
	ctx.r[5].s64 = 423;
	// 82835A54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82835A58: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82835A5C: 485BC98D  bl 0x82df23e8
	ctx.lr = 0x82835A60;
	sub_82DF23E8(ctx, base);
	// 82835A60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82835A64: 41820010  beq 0x82835a74
	if ctx.cr[0].eq {
	pc = 0x82835A74; continue 'dispatch;
	}
	// 82835A68: 4BFFFCE9  bl 0x82835750
	ctx.lr = 0x82835A6C;
	sub_82835750(ctx, base);
	// 82835A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835A70: 48000008  b 0x82835a78
	pc = 0x82835A78; continue 'dispatch;
	// 82835A74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82835A78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82835A7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835A80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82835A84: 4BFFF0A5  bl 0x82834b28
	ctx.lr = 0x82835A88;
	sub_82834B28(ctx, base);
	// 82835A88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82835A8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835A90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82835A94: 4BA8A56D  bl 0x822c0000
	ctx.lr = 0x82835A98;
	sub_822C0000(ctx, base);
	// 82835A98: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82835A9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82835AA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82835AA4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82835AA8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82835AAC: 419A0024  beq cr6, 0x82835ad0
	if ctx.cr[6].eq {
	pc = 0x82835AD0; continue 'dispatch;
	}
	// 82835AB0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82835AB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82835AB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835ABC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82835AC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82835AC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82835AC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835ACC: 4082FFE8  bne 0x82835ab4
	if !ctx.cr[0].eq {
	pc = 0x82835AB4; continue 'dispatch;
	}
	// 82835AD0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82835AD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82835AD8: 4BFB9BC9  bl 0x827ef6a0
	ctx.lr = 0x82835ADC;
	sub_827EF6A0(ctx, base);
	// 82835ADC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82835AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835AE4: 419A0008  beq cr6, 0x82835aec
	if ctx.cr[6].eq {
	pc = 0x82835AEC; continue 'dispatch;
	}
	// 82835AE8: 4BA8ADA9  bl 0x822c0890
	ctx.lr = 0x82835AEC;
	sub_822C0890(ctx, base);
	// 82835AEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82835AF0: 419A000C  beq cr6, 0x82835afc
	if ctx.cr[6].eq {
	pc = 0x82835AFC; continue 'dispatch;
	}
	// 82835AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835AF8: 4BA8AD99  bl 0x822c0890
	ctx.lr = 0x82835AFC;
	sub_822C0890(ctx, base);
	// 82835AFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835B04: 388BC1B0  addi r4, r11, -0x3e50
	ctx.r[4].s64 = ctx.r[11].s64 + -15952;
	// 82835B08: 485BDF01  bl 0x82df3a08
	ctx.lr = 0x82835B0C;
	sub_82DF3A08(ctx, base);
	// 82835B0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82835B10: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82835B14: 4802DBAD  bl 0x828636c0
	ctx.lr = 0x82835B18;
	sub_828636C0(ctx, base);
	// 82835B18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835B1C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82835B20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82835B24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835B28: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82835B2C: 419A0024  beq cr6, 0x82835b50
	if ctx.cr[6].eq {
	pc = 0x82835B50; continue 'dispatch;
	}
	// 82835B30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82835B34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82835B38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835B3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82835B40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82835B44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82835B48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835B4C: 4082FFE8  bne 0x82835b34
	if !ctx.cr[0].eq {
	pc = 0x82835B34; continue 'dispatch;
	}
	// 82835B50: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82835B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82835B58: 4BFB9B49  bl 0x827ef6a0
	ctx.lr = 0x82835B5C;
	sub_827EF6A0(ctx, base);
	// 82835B5C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82835B60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835B64: 419A0008  beq cr6, 0x82835b6c
	if ctx.cr[6].eq {
	pc = 0x82835B6C; continue 'dispatch;
	}
	// 82835B68: 4BA8AD29  bl 0x822c0890
	ctx.lr = 0x82835B6C;
	sub_822C0890(ctx, base);
	// 82835B6C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82835B70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835B74: 419A0008  beq cr6, 0x82835b7c
	if ctx.cr[6].eq {
	pc = 0x82835B7C; continue 'dispatch;
	}
	// 82835B78: 4BA8AD19  bl 0x822c0890
	ctx.lr = 0x82835B7C;
	sub_822C0890(ctx, base);
	// 82835B7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835B80: 485BD8A9  bl 0x82df3428
	ctx.lr = 0x82835B84;
	sub_82DF3428(ctx, base);
	// 82835B84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835B8C: 388BC1A0  addi r4, r11, -0x3e60
	ctx.r[4].s64 = ctx.r[11].s64 + -15968;
	// 82835B90: 485BDE79  bl 0x82df3a08
	ctx.lr = 0x82835B94;
	sub_82DF3A08(ctx, base);
	// 82835B94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82835B98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82835B9C: 4802DB25  bl 0x828636c0
	ctx.lr = 0x82835BA0;
	sub_828636C0(ctx, base);
	// 82835BA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835BA4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82835BA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82835BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835BB0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82835BB4: 419A0024  beq cr6, 0x82835bd8
	if ctx.cr[6].eq {
	pc = 0x82835BD8; continue 'dispatch;
	}
	// 82835BB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82835BBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82835BC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835BC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82835BC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82835BCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82835BD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835BD4: 4082FFE8  bne 0x82835bbc
	if !ctx.cr[0].eq {
	pc = 0x82835BBC; continue 'dispatch;
	}
	// 82835BD8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82835BDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82835BE0: 4BFB9AC1  bl 0x827ef6a0
	ctx.lr = 0x82835BE4;
	sub_827EF6A0(ctx, base);
	// 82835BE4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82835BE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835BEC: 419A0008  beq cr6, 0x82835bf4
	if ctx.cr[6].eq {
	pc = 0x82835BF4; continue 'dispatch;
	}
	// 82835BF0: 4BA8ACA1  bl 0x822c0890
	ctx.lr = 0x82835BF4;
	sub_822C0890(ctx, base);
	// 82835BF4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82835BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835BFC: 419A0008  beq cr6, 0x82835c04
	if ctx.cr[6].eq {
	pc = 0x82835C04; continue 'dispatch;
	}
	// 82835C00: 4BA8AC91  bl 0x822c0890
	ctx.lr = 0x82835C04;
	sub_822C0890(ctx, base);
	// 82835C04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835C08: 485BD821  bl 0x82df3428
	ctx.lr = 0x82835C0C;
	sub_82DF3428(ctx, base);
	// 82835C0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82835C10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82835C14: 38A001AD  li r5, 0x1ad
	ctx.r[5].s64 = 429;
	// 82835C18: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82835C1C: 485BC7CD  bl 0x82df23e8
	ctx.lr = 0x82835C20;
	sub_82DF23E8(ctx, base);
	// 82835C20: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82835C24: 4182002C  beq 0x82835c50
	if ctx.cr[0].eq {
	pc = 0x82835C50; continue 'dispatch;
	}
	// 82835C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835C2C: 4802CEED  bl 0x82862b18
	ctx.lr = 0x82835C30;
	sub_82862B18(ctx, base);
	// 82835C30: 395C026C  addi r10, r28, 0x26c
	ctx.r[10].s64 = ctx.r[28].s64 + 620;
	// 82835C34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835C38: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82835C3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82835C40: 396BC2BC  addi r11, r11, -0x3d44
	ctx.r[11].s64 = ctx.r[11].s64 + -15684;
	// 82835C44: 915F0068  stw r10, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82835C48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82835C4C: 48000008  b 0x82835c54
	pc = 0x82835C54; continue 'dispatch;
	// 82835C50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82835C54: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82835C58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835C5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82835C60: 4BFFEF91  bl 0x82834bf0
	ctx.lr = 0x82835C64;
	sub_82834BF0(ctx, base);
	// 82835C64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82835C68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835C6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82835C70: 4BA8A391  bl 0x822c0000
	ctx.lr = 0x82835C74;
	sub_822C0000(ctx, base);
	// 82835C74: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82835C78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82835C7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82835C80: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82835C84: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82835C88: 419A0024  beq cr6, 0x82835cac
	if ctx.cr[6].eq {
	pc = 0x82835CAC; continue 'dispatch;
	}
	// 82835C8C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82835C90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82835C94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835C98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82835C9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82835CA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82835CA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835CA8: 4082FFE8  bne 0x82835c90
	if !ctx.cr[0].eq {
	pc = 0x82835C90; continue 'dispatch;
	}
	// 82835CAC: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82835CB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82835CB4: 4BFB99ED  bl 0x827ef6a0
	ctx.lr = 0x82835CB8;
	sub_827EF6A0(ctx, base);
	// 82835CB8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82835CBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835CC0: 419A0008  beq cr6, 0x82835cc8
	if ctx.cr[6].eq {
	pc = 0x82835CC8; continue 'dispatch;
	}
	// 82835CC4: 4BA8ABCD  bl 0x822c0890
	ctx.lr = 0x82835CC8;
	sub_822C0890(ctx, base);
	// 82835CC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82835CCC: 419A000C  beq cr6, 0x82835cd8
	if ctx.cr[6].eq {
	pc = 0x82835CD8; continue 'dispatch;
	}
	// 82835CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835CD4: 4BA8ABBD  bl 0x822c0890
	ctx.lr = 0x82835CD8;
	sub_822C0890(ctx, base);
	// 82835CD8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82835CDC: 48000020  b 0x82835cfc
	pc = 0x82835CFC; continue 'dispatch;
	// 82835CE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82835CE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82835CE8: 4BFFEDB9  bl 0x82834aa0
	ctx.lr = 0x82835CEC;
	sub_82834AA0(ctx, base);
	// 82835CEC: C01C027C  lfs f0, 0x27c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82835CF0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82835CF4: 4099000C  ble cr6, 0x82835d00
	if !ctx.cr[6].gt {
	pc = 0x82835D00; continue 'dispatch;
	}
	// 82835CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82835CFC: 917C026C  stw r11, 0x26c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82835D00: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82835D04: 489724B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835D08 size=116
    let mut pc: u32 = 0x82835D08;
    'dispatch: loop {
        match pc {
            0x82835D08 => {
    //   block [0x82835D08..0x82835D7C)
	// 82835D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82835D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835D1C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82835D20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82835D24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82835D28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835D2C: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 82835D30: 485BBEC9  bl 0x82df1bf8
	ctx.lr = 0x82835D34;
	sub_82DF1BF8(ctx, base);
	// 82835D34: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82835D38: 48311509  bl 0x82b47240
	ctx.lr = 0x82835D3C;
	sub_82B47240(ctx, base);
	// 82835D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835D40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82835D44: 485BBF4D  bl 0x82df1c90
	ctx.lr = 0x82835D48;
	sub_82DF1C90(ctx, base);
	// 82835D48: 807E0254  lwz r3, 0x254(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(596 as u32) ) } as u64;
	// 82835D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835D50: 419A0014  beq cr6, 0x82835d64
	if ctx.cr[6].eq {
	pc = 0x82835D64; continue 'dispatch;
	}
	// 82835D54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82835D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835D5C: 419A0008  beq cr6, 0x82835d64
	if ctx.cr[6].eq {
	pc = 0x82835D64; continue 'dispatch;
	}
	// 82835D60: 48003281  bl 0x82838fe0
	ctx.lr = 0x82835D64;
	sub_82838FE0(ctx, base);
	// 82835D64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835D68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835D6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835D70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835D74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835D78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835D80 size=376
    let mut pc: u32 = 0x82835D80;
    'dispatch: loop {
        match pc {
            0x82835D80 => {
    //   block [0x82835D80..0x82835EF8)
	// 82835D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82835D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835D90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835D94: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82835D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835D9C: 3BC40018  addi r30, r4, 0x18
	ctx.r[30].s64 = ctx.r[4].s64 + 24;
	// 82835DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835DA4: 419A0128  beq cr6, 0x82835ecc
	if ctx.cr[6].eq {
	pc = 0x82835ECC; continue 'dispatch;
	}
	// 82835DA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835DAC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82835DB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835DB4: 4E800421  bctrl
	ctx.lr = 0x82835DB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835DB8: 4BFB8E29  bl 0x827eebe0
	ctx.lr = 0x82835DBC;
	sub_827EEBE0(ctx, base);
	// 82835DBC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82835DC0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835DC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82835DCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82835DD0: 419A0024  beq cr6, 0x82835df4
	if ctx.cr[6].eq {
	pc = 0x82835DF4; continue 'dispatch;
	}
	// 82835DD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82835DD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82835DDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835DE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82835DE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82835DE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82835DEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82835DF0: 4082FFE8  bne 0x82835dd8
	if !ctx.cr[0].eq {
	pc = 0x82835DD8; continue 'dispatch;
	}
	// 82835DF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835DF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82835DFC: 4BFB67CD  bl 0x827ec5c8
	ctx.lr = 0x82835E00;
	sub_827EC5C8(ctx, base);
	// 82835E00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82835E04: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835E08: 485DF2A9  bl 0x82e150b0
	ctx.lr = 0x82835E0C;
	sub_82E150B0(ctx, base);
	// 82835E0C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82835E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835E14: 419A0008  beq cr6, 0x82835e1c
	if ctx.cr[6].eq {
	pc = 0x82835E1C; continue 'dispatch;
	}
	// 82835E18: 4BA8AA79  bl 0x822c0890
	ctx.lr = 0x82835E1C;
	sub_822C0890(ctx, base);
	// 82835E1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835E20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82835E24: 4BCD96A5  bl 0x8250f4c8
	ctx.lr = 0x82835E28;
	sub_8250F4C8(ctx, base);
	// 82835E28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835E30: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82835E34: 409A0008  bne cr6, 0x82835e3c
	if !ctx.cr[6].eq {
	pc = 0x82835E3C; continue 'dispatch;
	}
	// 82835E38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82835E3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82835E40: 48003309  bl 0x82839148
	ctx.lr = 0x82835E44;
	sub_82839148(ctx, base);
	// 82835E44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82835E48: 3BDF0254  addi r30, r31, 0x254
	ctx.r[30].s64 = ctx.r[31].s64 + 596;
	// 82835E4C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82835E50: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82835E54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835E58: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 82835E5C: 4BA8E605  bl 0x822c4460
	ctx.lr = 0x82835E60;
	sub_822C4460(ctx, base);
	// 82835E60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82835E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835E68: 419A0008  beq cr6, 0x82835e70
	if ctx.cr[6].eq {
	pc = 0x82835E70; continue 'dispatch;
	}
	// 82835E6C: 4BA8AA25  bl 0x822c0890
	ctx.lr = 0x82835E70;
	sub_822C0890(ctx, base);
	// 82835E70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82835E74: 485BBE1D  bl 0x82df1c90
	ctx.lr = 0x82835E78;
	sub_82DF1C90(ctx, base);
	// 82835E78: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835E7C: 48003125  bl 0x82838fa0
	ctx.lr = 0x82835E80;
	sub_82838FA0(ctx, base);
	// 82835E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835E84: 4BFB57B5  bl 0x827eb638
	ctx.lr = 0x82835E88;
	sub_827EB638(ctx, base);
	// 82835E88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82835E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835E90: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82835E94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82835E98: 4E800421  bctrl
	ctx.lr = 0x82835E9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82835E9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835EA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82835EA4: 38ABC5A4  addi r5, r11, -0x3a5c
	ctx.r[5].s64 = ctx.r[11].s64 + -14940;
	// 82835EA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82835EAC: 4BFB7305  bl 0x827ed1b0
	ctx.lr = 0x82835EB0;
	sub_827ED1B0(ctx, base);
	// 82835EB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82835EB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835EB8: 419A0008  beq cr6, 0x82835ec0
	if ctx.cr[6].eq {
	pc = 0x82835EC0; continue 'dispatch;
	}
	// 82835EBC: 4BA8A9D5  bl 0x822c0890
	ctx.lr = 0x82835EC0;
	sub_822C0890(ctx, base);
	// 82835EC0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82835EC4: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82835EC8: 48000018  b 0x82835ee0
	pc = 0x82835EE0; continue 'dispatch;
	// 82835ECC: 817F0264  lwz r11, 0x264(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82835ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82835ED4: 419A000C  beq cr6, 0x82835ee0
	if ctx.cr[6].eq {
	pc = 0x82835EE0; continue 'dispatch;
	}
	// 82835ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82835EDC: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 82835EE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82835EE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835EE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835EEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835EF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835EF8 size=96
    let mut pc: u32 = 0x82835EF8;
    'dispatch: loop {
        match pc {
            0x82835EF8 => {
    //   block [0x82835EF8..0x82835F58)
	// 82835EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835F00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835F04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835F0C: 4BFFF955  bl 0x82835860
	ctx.lr = 0x82835F10;
	sub_82835860(ctx, base);
	// 82835F10: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82835F14: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82835F18: 396BC61C  addi r11, r11, -0x39e4
	ctx.r[11].s64 = ctx.r[11].s64 + -14820;
	// 82835F1C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82835F20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82835F24: 394AC608  addi r10, r10, -0x39f8
	ctx.r[10].s64 = ctx.r[10].s64 + -14840;
	// 82835F28: 3929C5BC  addi r9, r9, -0x3a44
	ctx.r[9].s64 = ctx.r[9].s64 + -14916;
	// 82835F2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82835F30: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82835F34: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82835F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835F3C: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 82835F40: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 82835F44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82835F48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835F4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835F50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82835F58 size=8
    let mut pc: u32 = 0x82835F58;
    'dispatch: loop {
        match pc {
            0x82835F58 => {
    //   block [0x82835F58..0x82835F60)
	// 82835F58: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82835F5C: 4800000C  b 0x82835f68
	sub_82835F68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82835F60 size=8
    let mut pc: u32 = 0x82835F60;
    'dispatch: loop {
        match pc {
            0x82835F60 => {
    //   block [0x82835F60..0x82835F68)
	// 82835F60: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 82835F64: 48000004  b 0x82835f68
	sub_82835F68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82835F68 size=96
    let mut pc: u32 = 0x82835F68;
    'dispatch: loop {
        match pc {
            0x82835F68 => {
    //   block [0x82835F68..0x82835FC8)
	// 82835F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82835F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82835F84: 807F0288  lwz r3, 0x288(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 82835F88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82835F8C: 419A0008  beq cr6, 0x82835f94
	if ctx.cr[6].eq {
	pc = 0x82835F94; continue 'dispatch;
	}
	// 82835F90: 4BA8A901  bl 0x822c0890
	ctx.lr = 0x82835F94;
	sub_822C0890(ctx, base);
	// 82835F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835F98: 4BFFF329  bl 0x828352c0
	ctx.lr = 0x82835F9C;
	sub_828352C0(ctx, base);
	// 82835F9C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82835FA0: 4182000C  beq 0x82835fac
	if ctx.cr[0].eq {
	pc = 0x82835FAC; continue 'dispatch;
	}
	// 82835FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835FA8: 485BC431  bl 0x82df23d8
	ctx.lr = 0x82835FAC;
	sub_82DF23D8(ctx, base);
	// 82835FAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82835FB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82835FB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82835FB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82835FBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82835FC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82835FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82835FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82835FC8 size=108
    let mut pc: u32 = 0x82835FC8;
    'dispatch: loop {
        match pc {
            0x82835FC8 => {
    //   block [0x82835FC8..0x82836034)
	// 82835FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82835FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82835FD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82835FD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82835FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82835FDC: 4BFFF885  bl 0x82835860
	ctx.lr = 0x82835FE0;
	sub_82835860(ctx, base);
	// 82835FE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82835FE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82835FE8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82835FEC: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82835FF0: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82835FF4: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82835FF8: 3929C454  addi r9, r9, -0x3bac
	ctx.r[9].s64 = ctx.r[9].s64 + -15276;
	// 82835FFC: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82836000: 3968C440  addi r11, r8, -0x3bc0
	ctx.r[11].s64 = ctx.r[8].s64 + -15296;
	// 82836004: 3947C3F4  addi r10, r7, -0x3c0c
	ctx.r[10].s64 = ctx.r[7].s64 + -15372;
	// 82836008: D01F0284  stfs f0, 0x284(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), tmp.u32 ) };
	// 8283600C: D1BF0288  stfs f13, 0x288(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 82836010: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82836014: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82836018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283601C: 915F0208  stw r10, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[10].u32 ) };
	// 82836020: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82836024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82836028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283602C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82836030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836038 size=112
    let mut pc: u32 = 0x82836038;
    'dispatch: loop {
        match pc {
            0x82836038 => {
    //   block [0x82836038..0x828360A8)
	// 82836038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283603C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82836040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82836044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82836048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283604C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836050: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82836054: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82836058: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283605C: 396BC454  addi r11, r11, -0x3bac
	ctx.r[11].s64 = ctx.r[11].s64 + -15276;
	// 82836060: 394AC440  addi r10, r10, -0x3bc0
	ctx.r[10].s64 = ctx.r[10].s64 + -15296;
	// 82836064: 3929C3F4  addi r9, r9, -0x3c0c
	ctx.r[9].s64 = ctx.r[9].s64 + -15372;
	// 82836068: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283606C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82836070: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82836074: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82836078: 4BFFF249  bl 0x828352c0
	ctx.lr = 0x8283607C;
	sub_828352C0(ctx, base);
	// 8283607C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82836080: 4182000C  beq 0x8283608c
	if ctx.cr[0].eq {
	pc = 0x8283608C; continue 'dispatch;
	}
	// 82836084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836088: 485BC351  bl 0x82df23d8
	ctx.lr = 0x8283608C;
	sub_82DF23D8(ctx, base);
	// 8283608C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82836094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82836098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283609C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828360A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828360A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828360A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828360A8 size=140
    let mut pc: u32 = 0x828360A8;
    'dispatch: loop {
        match pc {
            0x828360A8 => {
    //   block [0x828360A8..0x82836134)
	// 828360A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828360AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828360B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828360B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828360B8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828360BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828360C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828360C4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828360C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828360CC: 4802CA4D  bl 0x82862b18
	ctx.lr = 0x828360D0;
	sub_82862B18(ctx, base);
	// 828360D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828360D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828360D8: 394AC6AC  addi r10, r10, -0x3954
	ctx.r[10].s64 = ctx.r[10].s64 + -14676;
	// 828360DC: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 828360E0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828360E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828360E8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828360EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828360F0: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828360F4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828360F8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828360FC: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82836100: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836138 size=92
    let mut pc: u32 = 0x82836138;
    'dispatch: loop {
        match pc {
            0x82836138 => {
    //   block [0x82836138..0x82836194)
	// 82836138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283613C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82836140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82836144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82836148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283614C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82836150: 396BC6AC  addi r11, r11, -0x3954
	ctx.r[11].s64 = ctx.r[11].s64 + -14676;
	// 82836154: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82836158: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8283615C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82836160: 419A0008  beq cr6, 0x82836168
	if ctx.cr[6].eq {
	pc = 0x82836168; continue 'dispatch;
	}
	// 82836164: 4BA8A72D  bl 0x822c0890
	ctx.lr = 0x82836168;
	sub_822C0890(ctx, base);
	// 82836168: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283616C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82836170: 419A0008  beq cr6, 0x82836178
	if ctx.cr[6].eq {
	pc = 0x82836178; continue 'dispatch;
	}
	// 82836174: 4BA8A71D  bl 0x822c0890
	ctx.lr = 0x82836178;
	sub_822C0890(ctx, base);
	// 82836178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283617C: 4862640D  bl 0x82e5c588
	ctx.lr = 0x82836180;
	sub_82E5C588(ctx, base);
	// 82836180: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82836184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82836188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283618C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82836190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836198 size=76
    let mut pc: u32 = 0x82836198;
    'dispatch: loop {
        match pc {
            0x82836198 => {
    //   block [0x82836198..0x828361E4)
	// 82836198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283619C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828361A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828361A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828361A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828361AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828361B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828361B4: 4BFFFF85  bl 0x82836138
	ctx.lr = 0x828361B8;
	sub_82836138(ctx, base);
	// 828361B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828361BC: 4182000C  beq 0x828361c8
	if ctx.cr[0].eq {
	pc = 0x828361C8; continue 'dispatch;
	}
	// 828361C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828361C4: 485BC215  bl 0x82df23d8
	ctx.lr = 0x828361C8;
	sub_82DF23D8(ctx, base);
	// 828361C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828361CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828361D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828361D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828361D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828361DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828361E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828361E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828361E8 size=460
    let mut pc: u32 = 0x828361E8;
    'dispatch: loop {
        match pc {
            0x828361E8 => {
    //   block [0x828361E8..0x828363B4)
	// 828361E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828361EC: 48971F7D  bl 0x831a8168
	ctx.lr = 0x828361F0;
	sub_831A8130(ctx, base);
	// 828361F0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828361F4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828361F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828361FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82836200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836204: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836208: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283620C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82836210: 4E800421  bctrl
	ctx.lr = 0x82836214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82836214: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82836218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283621C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82836220: 4BFB8571  bl 0x827ee790
	ctx.lr = 0x82836224;
	sub_827EE790(ctx, base);
	// 82836224: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82836228: 395E006C  addi r10, r30, 0x6c
	ctx.r[10].s64 = ctx.r[30].s64 + 108;
	// 8283622C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82836230: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82836234: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836238: 917E006C  stw r11, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8283623C: 4BA8E225  bl 0x822c4460
	ctx.lr = 0x82836240;
	sub_822C4460(ctx, base);
	// 82836240: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82836244: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82836248: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8283624C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82836250: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82836254: 697D0001  xori r29, r11, 1
	ctx.r[29].u64 = ctx.r[11].u64 ^ 1;
	// 82836258: 419A0008  beq cr6, 0x82836260
	if ctx.cr[6].eq {
	pc = 0x82836260; continue 'dispatch;
	}
	// 8283625C: 4BA8A635  bl 0x822c0890
	ctx.lr = 0x82836260;
	sub_822C0890(ctx, base);
	// 82836260: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82836264: 41820070  beq 0x828362d4
	if ctx.cr[0].eq {
	pc = 0x828362D4; continue 'dispatch;
	}
	// 82836268: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283626C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82836270: 388BC548  addi r4, r11, -0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -15032;
	// 82836274: 38A0045D  li r5, 0x45d
	ctx.r[5].s64 = 1117;
	// 82836278: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 8283627C: 485BC16D  bl 0x82df23e8
	ctx.lr = 0x82836280;
	sub_82DF23E8(ctx, base);
	// 82836280: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82836284: 41820010  beq 0x82836294
	if ctx.cr[0].eq {
	pc = 0x82836294; continue 'dispatch;
	}
	// 82836288: 4BFC2AA1  bl 0x827f8d28
	ctx.lr = 0x8283628C;
	sub_827F8D28(ctx, base);
	// 8283628C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82836290: 48000008  b 0x82836298
	pc = 0x82836298; continue 'dispatch;
	// 82836294: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82836298: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8283629C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828362A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828362A4: 4BFB831D  bl 0x827ee5c0
	ctx.lr = 0x828362A8;
	sub_827EE5C0(ctx, base);
	// 828362A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828362AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828362B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828362B4: 4BA89D4D  bl 0x822c0000
	ctx.lr = 0x828362B8;
	sub_822C0000(ctx, base);
	// 828362B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828362BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828362C0: 4BFB7D81  bl 0x827ee040
	ctx.lr = 0x828362C4;
	sub_827EE040(ctx, base);
	// 828362C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828362C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828362CC: 419A0008  beq cr6, 0x828362d4
	if ctx.cr[6].eq {
	pc = 0x828362D4; continue 'dispatch;
	}
	// 828362D0: 4BA8A5C1  bl 0x822c0890
	ctx.lr = 0x828362D4;
	sub_822C0890(ctx, base);
	// 828362D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828362D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828362DC: 4BFB84B5  bl 0x827ee790
	ctx.lr = 0x828362E0;
	sub_827EE790(ctx, base);
	// 828362E0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828362E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828362E8: 419A000C  beq cr6, 0x828362f4
	if ctx.cr[6].eq {
	pc = 0x828362F4; continue 'dispatch;
	}
	// 828362EC: C03E0094  lfs f1, 0x94(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828362F0: 4BFA3CF9  bl 0x827d9fe8
	ctx.lr = 0x828362F4;
	sub_827D9FE8(ctx, base);
	// 828362F4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828362F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828362FC: 419A0008  beq cr6, 0x82836304
	if ctx.cr[6].eq {
	pc = 0x82836304; continue 'dispatch;
	}
	// 82836300: 4BA8A591  bl 0x822c0890
	ctx.lr = 0x82836304;
	sub_822C0890(ctx, base);
	// 82836304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836308: 3BBE0064  addi r29, r30, 0x64
	ctx.r[29].s64 = ctx.r[30].s64 + 100;
	// 8283630C: 4BFE414D  bl 0x8281a458
	ctx.lr = 0x82836310;
	sub_8281A458(ctx, base);
	// 82836310: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82836314: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82836318: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283631C: 4BFC1A7D  bl 0x827f7d98
	ctx.lr = 0x82836320;
	sub_827F7D98(ctx, base);
	// 82836320: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828363B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828363B8 size=120
    let mut pc: u32 = 0x828363B8;
    'dispatch: loop {
        match pc {
            0x828363B8 => {
    //   block [0x828363B8..0x82836430)
	// 828363B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828363BC: 48971DB1  bl 0x831a816c
	ctx.lr = 0x828363C0;
	sub_831A8130(ctx, base);
	// 828363C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828363C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828363C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828363CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828363D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828363D4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828363D8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828363DC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828363E0: 485BC009  bl 0x82df23e8
	ctx.lr = 0x828363E4;
	sub_82DF23E8(ctx, base);
	// 828363E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828363E8: 41820014  beq 0x828363fc
	if ctx.cr[0].eq {
	pc = 0x828363FC; continue 'dispatch;
	}
	// 828363EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828363F0: 48320369  bl 0x82b56758
	ctx.lr = 0x828363F4;
	sub_82B56758(ctx, base);
	// 828363F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828363F8: 48000008  b 0x82836400
	pc = 0x82836400; continue 'dispatch;
	// 828363FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82836400: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82836404: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82836408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283640C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836410: 4BFFEB01  bl 0x82834f10
	ctx.lr = 0x82836414;
	sub_82834F10(ctx, base);
	// 82836414: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82836418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283641C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836420: 4BA89BE1  bl 0x822c0000
	ctx.lr = 0x82836424;
	sub_822C0000(ctx, base);
	// 82836424: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836428: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283642C: 48971D90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836430 size=124
    let mut pc: u32 = 0x82836430;
    'dispatch: loop {
        match pc {
            0x82836430 => {
    //   block [0x82836430..0x828364AC)
	// 82836430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82836434: 48971D39  bl 0x831a816c
	ctx.lr = 0x82836438;
	sub_831A8130(ctx, base);
	// 82836438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283643C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82836440: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82836444: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82836448: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283644C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82836450: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82836454: 485BBF95  bl 0x82df23e8
	ctx.lr = 0x82836458;
	sub_82DF23E8(ctx, base);
	// 82836458: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8283645C: 4182001C  beq 0x82836478
	if ctx.cr[0].eq {
	pc = 0x82836478; continue 'dispatch;
	}
	// 82836460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836464: 4862321D  bl 0x82e59680
	ctx.lr = 0x82836468;
	sub_82E59680(ctx, base);
	// 82836468: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283646C: 396BC2FC  addi r11, r11, -0x3d04
	ctx.r[11].s64 = ctx.r[11].s64 + -15620;
	// 82836470: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82836474: 48000008  b 0x8283647c
	pc = 0x8283647C; continue 'dispatch;
	// 82836478: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283647C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82836480: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82836484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82836488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283648C: 4BFFEB4D  bl 0x82834fd8
	ctx.lr = 0x82836490;
	sub_82834FD8(ctx, base);
	// 82836490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82836494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82836498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283649C: 4BA89B65  bl 0x822c0000
	ctx.lr = 0x828364A0;
	sub_822C0000(ctx, base);
	// 828364A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828364A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828364A8: 48971D14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828364B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828364B0 size=112
    let mut pc: u32 = 0x828364B0;
    'dispatch: loop {
        match pc {
            0x828364B0 => {
    //   block [0x828364B0..0x82836520)
	// 828364B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828364B4: 48971CB9  bl 0x831a816c
	ctx.lr = 0x828364B8;
	sub_831A8130(ctx, base);
	// 828364B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828364BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828364C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828364C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828364C8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828364CC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 828364D0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828364D4: 485BBF15  bl 0x82df23e8
	ctx.lr = 0x828364D8;
	sub_82DF23E8(ctx, base);
	// 828364D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828364DC: 41820010  beq 0x828364ec
	if ctx.cr[0].eq {
	pc = 0x828364EC; continue 'dispatch;
	}
	// 828364E0: 483202D1  bl 0x82b567b0
	ctx.lr = 0x828364E4;
	sub_82B567B0(ctx, base);
	// 828364E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828364E8: 48000008  b 0x828364f0
	pc = 0x828364F0; continue 'dispatch;
	// 828364EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828364F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828364F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828364F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828364FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836500: 4BFFEBA1  bl 0x828350a0
	ctx.lr = 0x82836504;
	sub_828350A0(ctx, base);
	// 82836504: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82836508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283650C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836510: 4BA89AF1  bl 0x822c0000
	ctx.lr = 0x82836514;
	sub_822C0000(ctx, base);
	// 82836514: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283651C: 48971CA0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836520 size=120
    let mut pc: u32 = 0x82836520;
    'dispatch: loop {
        match pc {
            0x82836520 => {
    //   block [0x82836520..0x82836598)
	// 82836520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82836524: 48971C49  bl 0x831a816c
	ctx.lr = 0x82836528;
	sub_831A8130(ctx, base);
	// 82836528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283652C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82836530: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82836534: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82836538: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283653C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82836540: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82836544: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82836548: 485BBEA1  bl 0x82df23e8
	ctx.lr = 0x8283654C;
	sub_82DF23E8(ctx, base);
	// 8283654C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82836550: 41820014  beq 0x82836564
	if ctx.cr[0].eq {
	pc = 0x82836564; continue 'dispatch;
	}
	// 82836554: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836558: 483201B1  bl 0x82b56708
	ctx.lr = 0x8283655C;
	sub_82B56708(ctx, base);
	// 8283655C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836560: 48000008  b 0x82836568
	pc = 0x82836568; continue 'dispatch;
	// 82836564: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82836568: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283656C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82836570: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82836574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836578: 4BFFEBF1  bl 0x82835168
	ctx.lr = 0x8283657C;
	sub_82835168(ctx, base);
	// 8283657C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82836580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82836584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836588: 4BA89A79  bl 0x822c0000
	ctx.lr = 0x8283658C;
	sub_822C0000(ctx, base);
	// 8283658C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836590: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82836594: 48971C28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836598 size=120
    let mut pc: u32 = 0x82836598;
    'dispatch: loop {
        match pc {
            0x82836598 => {
    //   block [0x82836598..0x82836610)
	// 82836598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283659C: 48971BD1  bl 0x831a816c
	ctx.lr = 0x828365A0;
	sub_831A8130(ctx, base);
	// 828365A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828365A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828365A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828365AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828365B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828365B4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828365B8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828365BC: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828365C0: 485BBE29  bl 0x82df23e8
	ctx.lr = 0x828365C4;
	sub_82DF23E8(ctx, base);
	// 828365C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828365C8: 41820014  beq 0x828365dc
	if ctx.cr[0].eq {
	pc = 0x828365DC; continue 'dispatch;
	}
	// 828365CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828365D0: 4831C451  bl 0x82b52a20
	ctx.lr = 0x828365D4;
	sub_82B52A20(ctx, base);
	// 828365D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828365D8: 48000008  b 0x828365e0
	pc = 0x828365E0; continue 'dispatch;
	// 828365DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828365E0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828365E4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828365E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828365EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828365F0: 4BFE17C1  bl 0x82817db0
	ctx.lr = 0x828365F4;
	sub_82817DB0(ctx, base);
	// 828365F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828365F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828365FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836600: 4BA89A01  bl 0x822c0000
	ctx.lr = 0x82836604;
	sub_822C0000(ctx, base);
	// 82836604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283660C: 48971BB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82836610 size=188
    let mut pc: u32 = 0x82836610;
    'dispatch: loop {
        match pc {
            0x82836610 => {
    //   block [0x82836610..0x828366CC)
	// 82836610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82836614: 48971B59  bl 0x831a816c
	ctx.lr = 0x82836618;
	sub_831A8130(ctx, base);
	// 82836618: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283661C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836620: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82836624: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82836628: 4BFFFE09  bl 0x82836430
	ctx.lr = 0x8283662C;
	sub_82836430(ctx, base);
	// 8283662C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836630: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82836634: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82836638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283663C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82836640: 419A0024  beq cr6, 0x82836664
	if ctx.cr[6].eq {
	pc = 0x82836664; continue 'dispatch;
	}
	// 82836644: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82836648: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283664C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82836650: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82836654: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82836658: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283665C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82836660: 4082FFE8  bne 0x82836648
	if !ctx.cr[0].eq {
	pc = 0x82836648; continue 'dispatch;
	}
	// 82836664: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82836668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283666C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82836670: 4BCD23A9  bl 0x82508a18
	ctx.lr = 0x82836674;
	sub_82508A18(ctx, base);
	// 82836674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82836678: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283667C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82836680: 388AC548  addi r4, r10, -0x3ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -15032;
	// 82836684: 38A000F0  li r5, 0xf0
	ctx.r[5].s64 = 240;
	// 82836688: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8283668C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82836690: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82836694: 486223AD  bl 0x82e58a40
	ctx.lr = 0x82836698;
	sub_82E58A40(ctx, base);
	// 82836698: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283669C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828366A0: 419A0008  beq cr6, 0x828366a8
	if ctx.cr[6].eq {
	pc = 0x828366A8; continue 'dispatch;
	}
	// 828366A4: 4BA8A1ED  bl 0x822c0890
	ctx.lr = 0x828366A8;
	sub_822C0890(ctx, base);
	// 828366A8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828366AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828366B0: 419A0008  beq cr6, 0x828366b8
	if ctx.cr[6].eq {
	pc = 0x828366B8; continue 'dispatch;
	}
	// 828366B4: 4BA8A1DD  bl 0x822c0890
	ctx.lr = 0x828366B8;
	sub_822C0890(ctx, base);
	// 828366B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828366BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828366C0: 4BFE33A1  bl 0x82819a60
	ctx.lr = 0x828366C4;
	sub_82819A60(ctx, base);
	// 828366C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828366C8: 48971AF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828366D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828366D0 size=440
    let mut pc: u32 = 0x828366D0;
    'dispatch: loop {
        match pc {
            0x828366D0 => {
    //   block [0x828366D0..0x82836888)
	// 828366D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828366D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828366D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828366DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828366E0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 828366E4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 828366E8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828366EC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828366F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828366F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828366F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828366FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82836700: 388BC728  addi r4, r11, -0x38d8
	ctx.r[4].s64 = ctx.r[11].s64 + -14552;
	// 82836704: 485BD305  bl 0x82df3a08
	ctx.lr = 0x82836708;
	sub_82DF3A08(ctx, base);
	// 82836708: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283670C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82836710: 388B9CE4  addi r4, r11, -0x631c
	ctx.r[4].s64 = ctx.r[11].s64 + -25372;
	// 82836714: 485BD2F5  bl 0x82df3a08
	ctx.lr = 0x82836718;
	sub_82DF3A08(ctx, base);
	// 82836718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283671C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82836720: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82836724: 38BF0074  addi r5, r31, 0x74
	ctx.r[5].s64 = ctx.r[31].s64 + 116;
	// 82836728: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8283672C: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82836730: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82836734: C3AADD6C  lfs f29, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82836738: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8283673C: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82836740: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82836744: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82836748: 4BD6CB61  bl 0x825a32a8
	ctx.lr = 0x8283674C;
	sub_825A32A8(ctx, base);
	// 8283674C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82836750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836754: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82836758: 4BD6B019  bl 0x825a1770
	ctx.lr = 0x8283675C;
	sub_825A1770(ctx, base);
	// 8283675C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82836760: 485BCCC9  bl 0x82df3428
	ctx.lr = 0x82836764;
	sub_82DF3428(ctx, base);
	// 82836764: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82836768: 4BA92551  bl 0x822c8cb8
	ctx.lr = 0x8283676C;
	sub_822C8CB8(ctx, base);
	// 8283676C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82836770: 485BCCB9  bl 0x82df3428
	ctx.lr = 0x82836774;
	sub_82DF3428(ctx, base);
	// 82836774: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82836778: 485BCCB1  bl 0x82df3428
	ctx.lr = 0x8283677C;
	sub_82DF3428(ctx, base);
	// 8283677C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82836780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82836784: 388BC718  addi r4, r11, -0x38e8
	ctx.r[4].s64 = ctx.r[11].s64 + -14568;
	// 82836788: 485BD281  bl 0x82df3a08
	ctx.lr = 0x8283678C;
	sub_82DF3A08(ctx, base);
	// 8283678C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82836790: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82836794: 388B9D04  addi r4, r11, -0x62fc
	ctx.r[4].s64 = ctx.r[11].s64 + -25340;
	// 82836798: 485BD271  bl 0x82df3a08
	ctx.lr = 0x8283679C;
	sub_82DF3A08(ctx, base);
	// 8283679C: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 828367A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828367A4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828367A8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828367AC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828367B0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828367B4: 4BD6CAF5  bl 0x825a32a8
	ctx.lr = 0x828367B8;
	sub_825A32A8(ctx, base);
	// 828367B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828367BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828367C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828367C4: 4BD6AFAD  bl 0x825a1770
	ctx.lr = 0x828367C8;
	sub_825A1770(ctx, base);
	// 828367C8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828367CC: 485BCC5D  bl 0x82df3428
	ctx.lr = 0x828367D0;
	sub_82DF3428(ctx, base);
	// 828367D0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828367D4: 4BA924E5  bl 0x822c8cb8
	ctx.lr = 0x828367D8;
	sub_822C8CB8(ctx, base);
	// 828367D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828367DC: 485BCC4D  bl 0x82df3428
	ctx.lr = 0x828367E0;
	sub_82DF3428(ctx, base);
	// 828367E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828367E4: 485BCC45  bl 0x82df3428
	ctx.lr = 0x828367E8;
	sub_82DF3428(ctx, base);
	// 828367E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828367EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828367F0: 388BC6F8  addi r4, r11, -0x3908
	ctx.r[4].s64 = ctx.r[11].s64 + -14600;
	// 828367F4: 485BD215  bl 0x82df3a08
	ctx.lr = 0x828367F8;
	sub_82DF3A08(ctx, base);
	// 828367F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828367FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82836800: 388BC6E8  addi r4, r11, -0x3918
	ctx.r[4].s64 = ctx.r[11].s64 + -14616;
	// 82836804: 485BD205  bl 0x82df3a08
	ctx.lr = 0x82836808;
	sub_82DF3A08(ctx, base);
	// 82836808: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8283680C: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 82836810: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82836814: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82836818: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8283681C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82836820: C04B6218  lfs f2, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82836824: 4BD6CA85  bl 0x825a32a8
	ctx.lr = 0x82836828;
	sub_825A32A8(ctx, base);
	// 82836828: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8283682C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82836830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836834: 4BD6AF3D  bl 0x825a1770
	ctx.lr = 0x82836838;
	sub_825A1770(ctx, base);
	// 82836838: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8283683C: 485BCBED  bl 0x82df3428
	ctx.lr = 0x82836840;
	sub_82DF3428(ctx, base);
	// 82836840: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82836844: 4BA92475  bl 0x822c8cb8
	ctx.lr = 0x82836848;
	sub_822C8CB8(ctx, base);
	// 82836848: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283684C: 485BCBDD  bl 0x82df3428
	ctx.lr = 0x82836850;
	sub_82DF3428(ctx, base);
	// 82836850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82836854: 485BCBD5  bl 0x82df3428
	ctx.lr = 0x82836858;
	sub_82DF3428(ctx, base);
	// 82836858: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283685C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836860: 4BFE2109  bl 0x82818968
	ctx.lr = 0x82836864;
	sub_82818968(ctx, base);
	// 82836864: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82836868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283686C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82836870: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82836874: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82836878: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8283687C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82836880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82836884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836888 size=248
    let mut pc: u32 = 0x82836888;
    'dispatch: loop {
        match pc {
            0x82836888 => {
    //   block [0x82836888..0x82836980)
	// 82836888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283688C: 489718D9  bl 0x831a8164
	ctx.lr = 0x82836890;
	sub_831A8130(ctx, base);
	// 82836890: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82836894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283689C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828368A0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828368A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828368A8: 4BFFFC09  bl 0x828364b0
	ctx.lr = 0x828368AC;
	sub_828364B0(ctx, base);
	// 828368AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828368B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828368B4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828368B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828368BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828368C0: 4BA8DBA1  bl 0x822c4460
	ctx.lr = 0x828368C4;
	sub_822C4460(ctx, base);
	// 828368C4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828368C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828368CC: 419A0008  beq cr6, 0x828368d4
	if ctx.cr[6].eq {
	pc = 0x828368D4; continue 'dispatch;
	}
	// 828368D0: 4BA89FC1  bl 0x822c0890
	ctx.lr = 0x828368D4;
	sub_822C0890(ctx, base);
	// 828368D4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828368D8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828368DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828368E0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828368E4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828368E8: 419A0024  beq cr6, 0x8283690c
	if ctx.cr[6].eq {
	pc = 0x8283690C; continue 'dispatch;
	}
	// 828368EC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828368F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828368F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828368F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828368FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82836900: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82836904: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82836908: 4082FFE8  bne 0x828368f0
	if !ctx.cr[0].eq {
	pc = 0x828368F0; continue 'dispatch;
	}
	// 8283690C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836910: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 82836914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836918: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8283691C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82836920: 4E800421  bctrl
	ctx.lr = 0x82836924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82836924: 4BFB6F0D  bl 0x827ed830
	ctx.lr = 0x82836928;
	sub_827ED830(ctx, base);
	// 82836928: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283692C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82836930: 388BC548  addi r4, r11, -0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -15032;
	// 82836934: 38A00140  li r5, 0x140
	ctx.r[5].s64 = 320;
	// 82836938: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8283693C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82836940: 486206A9  bl 0x82e56fe8
	ctx.lr = 0x82836944;
	sub_82E56FE8(ctx, base);
	// 82836944: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82836948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283694C: 419A0008  beq cr6, 0x82836954
	if ctx.cr[6].eq {
	pc = 0x82836954; continue 'dispatch;
	}
	// 82836950: 4BA89F41  bl 0x822c0890
	ctx.lr = 0x82836954;
	sub_822C0890(ctx, base);
	// 82836954: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82836958: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8283695C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836960: 997F0274  stb r11, 0x274(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u8 ) };
	// 82836964: 4BFE193D  bl 0x828182a0
	ctx.lr = 0x82836968;
	sub_828182A0(ctx, base);
	// 82836968: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8283696C: 419A000C  beq cr6, 0x82836978
	if ctx.cr[6].eq {
	pc = 0x82836978; continue 'dispatch;
	}
	// 82836970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82836974: 4BA89F1D  bl 0x822c0890
	ctx.lr = 0x82836978;
	sub_822C0890(ctx, base);
	// 82836978: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8283697C: 48971838  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836980 size=176
    let mut pc: u32 = 0x82836980;
    'dispatch: loop {
        match pc {
            0x82836980 => {
    //   block [0x82836980..0x82836A30)
	// 82836980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82836984: 489717E5  bl 0x831a8168
	ctx.lr = 0x82836988;
	sub_831A8130(ctx, base);
	// 82836988: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283698C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836990: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82836994: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82836998: 4BE47D79  bl 0x8267e710
	ctx.lr = 0x8283699C;
	sub_8267E710(ctx, base);
	// 8283699C: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828369A0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828369A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828369A8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828369AC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828369B0: 419A0024  beq cr6, 0x828369d4
	if ctx.cr[6].eq {
	pc = 0x828369D4; continue 'dispatch;
	}
	// 828369B4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828369B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828369BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828369C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828369C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828369C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828369CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828369D0: 4082FFE8  bne 0x828369b8
	if !ctx.cr[0].eq {
	pc = 0x828369B8; continue 'dispatch;
	}
	// 828369D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828369D8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828369DC: 388BC548  addi r4, r11, -0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -15032;
	// 828369E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828369E4: 38A00182  li r5, 0x182
	ctx.r[5].s64 = 386;
	// 828369E8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828369EC: 486205FD  bl 0x82e56fe8
	ctx.lr = 0x828369F0;
	sub_82E56FE8(ctx, base);
	// 828369F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828369F4: 4182000C  beq 0x82836a00
	if ctx.cr[0].eq {
	pc = 0x82836A00; continue 'dispatch;
	}
	// 828369F8: 83FC0018  lwz r31, 0x18(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828369FC: 48000008  b 0x82836a04
	pc = 0x82836A04; continue 'dispatch;
	// 82836A00: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82836A04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82836A08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82836A0C: 419A0008  beq cr6, 0x82836a14
	if ctx.cr[6].eq {
	pc = 0x82836A14; continue 'dispatch;
	}
	// 82836A10: 4BA89E81  bl 0x822c0890
	ctx.lr = 0x82836A14;
	sub_822C0890(ctx, base);
	// 82836A14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82836A18: 419A000C  beq cr6, 0x82836a24
	if ctx.cr[6].eq {
	pc = 0x82836A24; continue 'dispatch;
	}
	// 82836A1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836A20: 4BA89E71  bl 0x822c0890
	ctx.lr = 0x82836A24;
	sub_822C0890(ctx, base);
	// 82836A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836A28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82836A2C: 4897178C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82836A30 size=208
    let mut pc: u32 = 0x82836A30;
    'dispatch: loop {
        match pc {
            0x82836A30 => {
    //   block [0x82836A30..0x82836B00)
	// 82836A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82836A34: 48971735  bl 0x831a8168
	ctx.lr = 0x82836A38;
	sub_831A8130(ctx, base);
	// 82836A38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82836A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836A40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82836A44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82836A48: 4BC64719  bl 0x8249b160
	ctx.lr = 0x82836A4C;
	sub_8249B160(ctx, base);
	// 82836A4C: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82836A50: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82836A54: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82836A58: 419A008C  beq cr6, 0x82836ae4
	if ctx.cr[6].eq {
	pc = 0x82836AE4; continue 'dispatch;
	}
	// 82836A5C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82836A60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82836A64: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82836A68: 419A0024  beq cr6, 0x82836a8c
	if ctx.cr[6].eq {
	pc = 0x82836A8C; continue 'dispatch;
	}
	// 82836A6C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82836A70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82836A74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82836A78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82836A7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82836A80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82836A84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82836A88: 4082FFE8  bne 0x82836a70
	if !ctx.cr[0].eq {
	pc = 0x82836A70; continue 'dispatch;
	}
	// 82836A8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82836A90: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82836A94: 388BC548  addi r4, r11, -0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -15032;
	// 82836A98: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82836A9C: 38A001E5  li r5, 0x1e5
	ctx.r[5].s64 = 485;
	// 82836AA0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82836AA4: 48620545  bl 0x82e56fe8
	ctx.lr = 0x82836AA8;
	sub_82E56FE8(ctx, base);
	// 82836AA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82836AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82836AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82836AB4: 419A000C  beq cr6, 0x82836ac0
	if ctx.cr[6].eq {
	pc = 0x82836AC0; continue 'dispatch;
	}
	// 82836AB8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82836ABC: 4BA89DD5  bl 0x822c0890
	ctx.lr = 0x82836AC0;
	sub_822C0890(ctx, base);
	// 82836AC0: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82836AC4: 41820020  beq 0x82836ae4
	if ctx.cr[0].eq {
	pc = 0x82836AE4; continue 'dispatch;
	}
	// 82836AC8: 83FC0018  lwz r31, 0x18(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82836ACC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82836AD0: 419A000C  beq cr6, 0x82836adc
	if ctx.cr[6].eq {
	pc = 0x82836ADC; continue 'dispatch;
	}
	// 82836AD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836AD8: 4BA89DB9  bl 0x822c0890
	ctx.lr = 0x82836ADC;
	sub_822C0890(ctx, base);
	// 82836ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836AE0: 48000018  b 0x82836af8
	pc = 0x82836AF8; continue 'dispatch;
	// 82836AE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82836AE8: 419A000C  beq cr6, 0x82836af4
	if ctx.cr[6].eq {
	pc = 0x82836AF4; continue 'dispatch;
	}
	// 82836AEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82836AF0: 4BA89DA1  bl 0x822c0890
	ctx.lr = 0x82836AF4;
	sub_822C0890(ctx, base);
	// 82836AF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82836AF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82836AFC: 489716BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82836B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82836B00 size=1684
    let mut pc: u32 = 0x82836B00;
    'dispatch: loop {
        match pc {
            0x82836B00 => {
    //   block [0x82836B00..0x82837194)
	// 82836B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82836B04: 48971659  bl 0x831a815c
	ctx.lr = 0x82836B08;
	sub_831A8130(ctx, base);
	// 82836B08: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82836B0C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82836B10: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82836B14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82836B18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836B1C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82836B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82836B24: 4E800421  bctrl
	ctx.lr = 0x82836B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82836B28: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82836B2C: 41820658  beq 0x82837184
	if ctx.cr[0].eq {
	pc = 0x82837184; continue 'dispatch;
	}
	// 82836B30: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82836B34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82836B38: 917E026C  stw r11, 0x26c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82836B3C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82836B40: 3B5E026C  addi r26, r30, 0x26c
	ctx.r[26].s64 = ctx.r[30].s64 + 620;
	// 82836B44: 4BFB5A85  bl 0x827ec5c8
	ctx.lr = 0x82836B48;
	sub_827EC5C8(ctx, base);
	// 82836B48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82836B4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82836B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82836B54: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836B58: 48275191  bl 0x82aabce8
	ctx.lr = 0x82836B5C;
	sub_82AABCE8(ctx, base);
	// 82836B5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82836B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82836B64: 485DE54D  bl 0x82e150b0
	ctx.lr = 0x82836B68;
	sub_82E150B0(ctx, base);
	// 82836B68: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82836B6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82836B70: 419A0008  beq cr6, 0x82836b78
	if ctx.cr[6].eq {
	pc = 0x82836B78; continue 'dispatch;
	}
	// 82836B74: 4BA89D1D  bl 0x822c0890
	ctx.lr = 0x82836B78;
	sub_822C0890(ctx, base);
	// 82836B78: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82836B7C: 397E0254  addi r11, r30, 0x254
	ctx.r[11].s64 = ctx.r[30].s64 + 596;
	// 82836B80: 937E0254  stw r27, 0x254(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(596 as u32), ctx.r[27].u32 ) };
	// 82836B84: 807E0258  lwz r3, 0x258(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(600 as u32) ) } as u64;
	// 82836B88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82836B8C: 937E0258  stw r27, 0x258(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(600 as u32), ctx.r[27].u32 ) };
	// 82836B90: 419A0008  beq cr6, 0x82836b98
	if ctx.cr[6].eq {
	pc = 0x82836B98; continue 'dispatch;
	}
	// 82836B94: 4BA89CFD  bl 0x822c0890
	ctx.lr = 0x82836B98;
	sub_822C0890(ctx, base);
	// 82836B98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82836B9C: 4BFB6C95  bl 0x827ed830
	ctx.lr = 0x82836BA0;
	sub_827ED830(ctx, base);
	// 82836BA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82836BA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82836BA8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82836BAC: 4BFB7E3D  bl 0x827ee9e8
	ctx.lr = 0x82836BB0;
	sub_827EE9E8(ctx, base);
	// 82836BB0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82836BB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82836BB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82836BBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82836BC0: 4E800421  bctrl
	ctx.lr = 0x82836BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82836BC4: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 82836BC8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82836BCC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82836BD0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82836BD4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82836BD8: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82836BDC: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82836BE0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837198 size=268
    let mut pc: u32 = 0x82837198;
    'dispatch: loop {
        match pc {
            0x82837198 => {
    //   block [0x82837198..0x828372A4)
	// 82837198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283719C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828371A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828371A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828371A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828371AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828371B0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 828371B4: 817F0264  lwz r11, 0x264(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 828371B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828371BC: 419A00D0  beq cr6, 0x8283728c
	if ctx.cr[6].eq {
	pc = 0x8283728C; continue 'dispatch;
	}
	// 828371C0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828371C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828371C8: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 828371CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828371D0: 481DC4B1  bl 0x82a13680
	ctx.lr = 0x828371D4;
	sub_82A13680(ctx, base);
	// 828371D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828371D8: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 828371DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828371E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828371E4: 4BFD4CAD  bl 0x8280be90
	ctx.lr = 0x828371E8;
	sub_8280BE90(ctx, base);
	// 828371E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828371EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828371F0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828371F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828371F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828371FC: 4BA8D265  bl 0x822c4460
	ctx.lr = 0x82837200;
	sub_822C4460(ctx, base);
	// 82837200: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82837204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837208: 419A0008  beq cr6, 0x82837210
	if ctx.cr[6].eq {
	pc = 0x82837210; continue 'dispatch;
	}
	// 8283720C: 4BA89685  bl 0x822c0890
	ctx.lr = 0x82837210;
	sub_822C0890(ctx, base);
	// 82837210: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82837214: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82837218: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8283721C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82837220: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82837224: 419A0024  beq cr6, 0x82837248
	if ctx.cr[6].eq {
	pc = 0x82837248; continue 'dispatch;
	}
	// 82837228: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8283722C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82837230: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837234: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82837238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283723C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82837240: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837244: 4082FFE8  bne 0x8283722c
	if !ctx.cr[0].eq {
	pc = 0x8283722C; continue 'dispatch;
	}
	// 82837248: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283724C: 80DF0264  lwz r6, 0x264(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82837250: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82837254: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82837258: 388AC548  addi r4, r10, -0x3ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -15032;
	// 8283725C: 38A002AF  li r5, 0x2af
	ctx.r[5].s64 = 687;
	// 82837260: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82837264: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82837268: 486217D9  bl 0x82e58a40
	ctx.lr = 0x8283726C;
	sub_82E58A40(ctx, base);
	// 8283726C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82837270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837274: 419A0008  beq cr6, 0x8283727c
	if ctx.cr[6].eq {
	pc = 0x8283727C; continue 'dispatch;
	}
	// 82837278: 4BA89619  bl 0x822c0890
	ctx.lr = 0x8283727C;
	sub_822C0890(ctx, base);
	// 8283727C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82837280: 419A000C  beq cr6, 0x8283728c
	if ctx.cr[6].eq {
	pc = 0x8283728C; continue 'dispatch;
	}
	// 82837284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82837288: 4BA89609  bl 0x822c0890
	ctx.lr = 0x8283728C;
	sub_822C0890(ctx, base);
	// 8283728C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82837290: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82837294: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82837298: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283729C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828372A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828372A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828372A8 size=252
    let mut pc: u32 = 0x828372A8;
    'dispatch: loop {
        match pc {
            0x828372A8 => {
    //   block [0x828372A8..0x828373A4)
	// 828372A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828372AC: 48970EC1  bl 0x831a816c
	ctx.lr = 0x828372B0;
	sub_831A8130(ctx, base);
	// 828372B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828372B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828372B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828372BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828372C0: 388BC1E4  addi r4, r11, -0x3e1c
	ctx.r[4].s64 = ctx.r[11].s64 + -15900;
	// 828372C4: 4BFFF2D5  bl 0x82836598
	ctx.lr = 0x828372C8;
	sub_82836598(ctx, base);
	// 828372C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828372CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828372D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828372D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828372D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828372DC: 419A0024  beq cr6, 0x82837300
	if ctx.cr[6].eq {
	pc = 0x82837300; continue 'dispatch;
	}
	// 828372E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828372E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828372E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828372EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828372F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828372F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828372F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828372FC: 4082FFE8  bne 0x828372e4
	if !ctx.cr[0].eq {
	pc = 0x828372E4; continue 'dispatch;
	}
	// 82837300: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 82837304: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82837308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283730C: 487D1CAD  bl 0x83008fb8
	ctx.lr = 0x82837310;
	sub_83008FB8(ctx, base);
	// 82837310: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82837314: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82837318: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283731C: 388AC548  addi r4, r10, -0x3ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -15032;
	// 82837320: 38A0032C  li r5, 0x32c
	ctx.r[5].s64 = 812;
	// 82837324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837328: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283732C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82837330: 48621711  bl 0x82e58a40
	ctx.lr = 0x82837334;
	sub_82E58A40(ctx, base);
	// 82837334: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82837338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283733C: 419A0008  beq cr6, 0x82837344
	if ctx.cr[6].eq {
	pc = 0x82837344; continue 'dispatch;
	}
	// 82837340: 4BA89551  bl 0x822c0890
	ctx.lr = 0x82837344;
	sub_822C0890(ctx, base);
	// 82837344: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82837348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283734C: 419A0008  beq cr6, 0x82837354
	if ctx.cr[6].eq {
	pc = 0x82837354; continue 'dispatch;
	}
	// 82837350: 4BA89541  bl 0x822c0890
	ctx.lr = 0x82837354;
	sub_822C0890(ctx, base);
	// 82837354: 817E0284  lwz r11, 0x284(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(644 as u32) ) } as u64;
	// 82837358: 3BFE0284  addi r31, r30, 0x284
	ctx.r[31].s64 = ctx.r[30].s64 + 644;
	// 8283735C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82837360: 419A003C  beq cr6, 0x8283739c
	if ctx.cr[6].eq {
	pc = 0x8283739C; continue 'dispatch;
	}
	// 82837364: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82837368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283736C: 388BC760  addi r4, r11, -0x38a0
	ctx.r[4].s64 = ctx.r[11].s64 + -14496;
	// 82837370: 485BC699  bl 0x82df3a08
	ctx.lr = 0x82837374;
	sub_82DF3A08(ctx, base);
	// 82837374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82837378: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8283737C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82837380: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82837384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283738C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82837390: 4BFB4E79  bl 0x827ec208
	ctx.lr = 0x82837394;
	sub_827EC208(ctx, base);
	// 82837394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82837398: 485BC091  bl 0x82df3428
	ctx.lr = 0x8283739C;
	sub_82DF3428(ctx, base);
	// 8283739C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828373A0: 48970E1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828373A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828373A8 size=184
    let mut pc: u32 = 0x828373A8;
    'dispatch: loop {
        match pc {
            0x828373A8 => {
    //   block [0x828373A8..0x82837460)
	// 828373A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828373AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828373B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828373B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828373B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828373BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828373C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828373C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828373C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828373CC: 388BC780  addi r4, r11, -0x3880
	ctx.r[4].s64 = ctx.r[11].s64 + -14464;
	// 828373D0: 485BC639  bl 0x82df3a08
	ctx.lr = 0x828373D4;
	sub_82DF3A08(ctx, base);
	// 828373D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828373D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828373DC: 388BC774  addi r4, r11, -0x388c
	ctx.r[4].s64 = ctx.r[11].s64 + -14476;
	// 828373E0: 485BC629  bl 0x82df3a08
	ctx.lr = 0x828373E4;
	sub_82DF3A08(ctx, base);
	// 828373E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828373E8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828373EC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828373F0: 38BF007C  addi r5, r31, 0x7c
	ctx.r[5].s64 = ctx.r[31].s64 + 124;
	// 828373F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828373F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828373FC: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82837400: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82837404: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82837408: 4BD6BEA1  bl 0x825a32a8
	ctx.lr = 0x8283740C;
	sub_825A32A8(ctx, base);
	// 8283740C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82837410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82837414: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82837418: 4BD6A359  bl 0x825a1770
	ctx.lr = 0x8283741C;
	sub_825A1770(ctx, base);
	// 8283741C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82837420: 485BC009  bl 0x82df3428
	ctx.lr = 0x82837424;
	sub_82DF3428(ctx, base);
	// 82837424: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82837428: 4BA91891  bl 0x822c8cb8
	ctx.lr = 0x8283742C;
	sub_822C8CB8(ctx, base);
	// 8283742C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82837430: 485BBFF9  bl 0x82df3428
	ctx.lr = 0x82837434;
	sub_82DF3428(ctx, base);
	// 82837434: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82837438: 485BBFF1  bl 0x82df3428
	ctx.lr = 0x8283743C;
	sub_82DF3428(ctx, base);
	// 8283743C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837444: 4BFFF28D  bl 0x828366d0
	ctx.lr = 0x82837448;
	sub_828366D0(ctx, base);
	// 82837448: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8283744C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82837450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82837454: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82837458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283745C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837460 size=216
    let mut pc: u32 = 0x82837460;
    'dispatch: loop {
        match pc {
            0x82837460 => {
    //   block [0x82837460..0x82837538)
	// 82837460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82837464: 48970D09  bl 0x831a816c
	ctx.lr = 0x82837468;
	sub_831A8130(ctx, base);
	// 82837468: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283746C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82837470: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82837474: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82837478: 388B56F4  addi r4, r11, 0x56f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22260;
	// 8283747C: 4BFFF11D  bl 0x82836598
	ctx.lr = 0x82837480;
	sub_82836598(ctx, base);
	// 82837480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837484: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82837488: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283748C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82837490: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82837494: 419A0024  beq cr6, 0x828374b8
	if ctx.cr[6].eq {
	pc = 0x828374B8; continue 'dispatch;
	}
	// 82837498: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283749C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828374A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828374A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828374A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828374AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828374B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828374B4: 4082FFE8  bne 0x8283749c
	if !ctx.cr[0].eq {
	pc = 0x8283749C; continue 'dispatch;
	}
	// 828374B8: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 828374BC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828374C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828374C4: 487D1AF5  bl 0x83008fb8
	ctx.lr = 0x828374C8;
	sub_83008FB8(ctx, base);
	// 828374C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828374CC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828374D0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828374D4: 388AC548  addi r4, r10, -0x3ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -15032;
	// 828374D8: 38A003E0  li r5, 0x3e0
	ctx.r[5].s64 = 992;
	// 828374DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828374E0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828374E4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828374E8: 48621559  bl 0x82e58a40
	ctx.lr = 0x828374EC;
	sub_82E58A40(ctx, base);
	// 828374EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828374F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828374F4: 419A0008  beq cr6, 0x828374fc
	if ctx.cr[6].eq {
	pc = 0x828374FC; continue 'dispatch;
	}
	// 828374F8: 4BA89399  bl 0x822c0890
	ctx.lr = 0x828374FC;
	sub_822C0890(ctx, base);
	// 828374FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82837500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837504: 419A0008  beq cr6, 0x8283750c
	if ctx.cr[6].eq {
	pc = 0x8283750C; continue 'dispatch;
	}
	// 82837508: 4BA89389  bl 0x822c0890
	ctx.lr = 0x8283750C;
	sub_822C0890(ctx, base);
	// 8283750C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82837510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837514: 38ABC7A4  addi r5, r11, -0x385c
	ctx.r[5].s64 = ctx.r[11].s64 + -14428;
	// 82837518: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283751C: 4BFB5C95  bl 0x827ed1b0
	ctx.lr = 0x82837520;
	sub_827ED1B0(ctx, base);
	// 82837520: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82837524: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837528: 419A0008  beq cr6, 0x82837530
	if ctx.cr[6].eq {
	pc = 0x82837530; continue 'dispatch;
	}
	// 8283752C: 4BA89365  bl 0x822c0890
	ctx.lr = 0x82837530;
	sub_822C0890(ctx, base);
	// 82837530: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82837534: 48970C88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837538 size=756
    let mut pc: u32 = 0x82837538;
    'dispatch: loop {
        match pc {
            0x82837538 => {
    //   block [0x82837538..0x8283782C)
	// 82837538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283753C: 48970C31  bl 0x831a816c
	ctx.lr = 0x82837540;
	sub_831A8130(ctx, base);
	// 82837540: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837544: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82837548: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283754C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82837550: 4BFB7241  bl 0x827ee790
	ctx.lr = 0x82837554;
	sub_827EE790(ctx, base);
	// 82837554: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82837558: 395D0064  addi r10, r29, 0x64
	ctx.r[10].s64 = ctx.r[29].s64 + 100;
	// 8283755C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82837560: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82837564: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837568: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8283756C: 4BA8CEF5  bl 0x822c4460
	ctx.lr = 0x82837570;
	sub_822C4460(ctx, base);
	// 82837570: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82837574: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82837578: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8283757C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837580: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82837584: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82837588: 419A0008  beq cr6, 0x82837590
	if ctx.cr[6].eq {
	pc = 0x82837590; continue 'dispatch;
	}
	// 8283758C: 4BA89305  bl 0x822c0890
	ctx.lr = 0x82837590;
	sub_822C0890(ctx, base);
	// 82837590: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837594: 41820070  beq 0x82837604
	if ctx.cr[0].eq {
	pc = 0x82837604; continue 'dispatch;
	}
	// 82837598: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283759C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828375A0: 388BC548  addi r4, r11, -0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -15032;
	// 828375A4: 38A003F6  li r5, 0x3f6
	ctx.r[5].s64 = 1014;
	// 828375A8: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 828375AC: 485BAE3D  bl 0x82df23e8
	ctx.lr = 0x828375B0;
	sub_82DF23E8(ctx, base);
	// 828375B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828375B4: 41820010  beq 0x828375c4
	if ctx.cr[0].eq {
	pc = 0x828375C4; continue 'dispatch;
	}
	// 828375B8: 4BFC1771  bl 0x827f8d28
	ctx.lr = 0x828375BC;
	sub_827F8D28(ctx, base);
	// 828375BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828375C0: 48000008  b 0x828375c8
	pc = 0x828375C8; continue 'dispatch;
	// 828375C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828375C8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828375CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828375D0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828375D4: 4BFB6FED  bl 0x827ee5c0
	ctx.lr = 0x828375D8;
	sub_827EE5C0(ctx, base);
	// 828375D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828375DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828375E0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828375E4: 4BA88A1D  bl 0x822c0000
	ctx.lr = 0x828375E8;
	sub_822C0000(ctx, base);
	// 828375E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828375EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828375F0: 4BFB6A51  bl 0x827ee040
	ctx.lr = 0x828375F4;
	sub_827EE040(ctx, base);
	// 828375F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828375F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828375FC: 419A0008  beq cr6, 0x82837604
	if ctx.cr[6].eq {
	pc = 0x82837604; continue 'dispatch;
	}
	// 82837600: 4BA89291  bl 0x822c0890
	ctx.lr = 0x82837604;
	sub_822C0890(ctx, base);
	// 82837604: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837608: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283760C: 4BFB7185  bl 0x827ee790
	ctx.lr = 0x82837610;
	sub_827EE790(ctx, base);
	// 82837610: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82837614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837618: 419A0010  beq cr6, 0x82837628
	if ctx.cr[6].eq {
	pc = 0x82837628; continue 'dispatch;
	}
	// 8283761C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82837620: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82837624: 4BFA29C5  bl 0x827d9fe8
	ctx.lr = 0x82837628;
	sub_827D9FE8(ctx, base);
	// 82837628: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283762C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837630: 419A0008  beq cr6, 0x82837638
	if ctx.cr[6].eq {
	pc = 0x82837638; continue 'dispatch;
	}
	// 82837634: 4BA8925D  bl 0x822c0890
	ctx.lr = 0x82837638;
	sub_822C0890(ctx, base);
	// 82837638: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283763C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82837640: 388BC1B8  addi r4, r11, -0x3e48
	ctx.r[4].s64 = ctx.r[11].s64 + -15944;
	// 82837644: 4BFFEF55  bl 0x82836598
	ctx.lr = 0x82837648;
	sub_82836598(ctx, base);
	// 82837648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283764C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82837650: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82837654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82837658: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283765C: 419A0024  beq cr6, 0x82837680
	if ctx.cr[6].eq {
	pc = 0x82837680; continue 'dispatch;
	}
	// 82837660: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82837664: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82837668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283766C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82837670: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82837674: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82837678: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283767C: 4082FFE8  bne 0x82837664
	if !ctx.cr[0].eq {
	pc = 0x82837664; continue 'dispatch;
	}
	// 82837680: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82837684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837688: 4BFB6BA1  bl 0x827ee228
	ctx.lr = 0x8283768C;
	sub_827EE228(ctx, base);
	// 8283768C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82837690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837694: 419A0008  beq cr6, 0x8283769c
	if ctx.cr[6].eq {
	pc = 0x8283769C; continue 'dispatch;
	}
	// 82837698: 4BA891F9  bl 0x822c0890
	ctx.lr = 0x8283769C;
	sub_822C0890(ctx, base);
	// 8283769C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828376A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828376A4: 38ABC7BC  addi r5, r11, -0x3844
	ctx.r[5].s64 = ctx.r[11].s64 + -14404;
	// 828376A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828376AC: 4BFB861D  bl 0x827efcc8
	ctx.lr = 0x828376B0;
	sub_827EFCC8(ctx, base);
	// 828376B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828376B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828376B8: 419A0008  beq cr6, 0x828376c0
	if ctx.cr[6].eq {
	pc = 0x828376C0; continue 'dispatch;
	}
	// 828376BC: 4BA891D5  bl 0x822c0890
	ctx.lr = 0x828376C0;
	sub_822C0890(ctx, base);
	// 828376C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828376C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828376C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828376CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828376D0: 4E800421  bctrl
	ctx.lr = 0x828376D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828376D4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828376D8: D01D0084  stfs f0, 0x84(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828376DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828376E0: 4BFB6151  bl 0x827ed830
	ctx.lr = 0x828376E4;
	sub_827ED830(ctx, base);
	// 828376E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828376E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828376EC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828376F0: 4BFB73B9  bl 0x827eeaa8
	ctx.lr = 0x828376F4;
	sub_827EEAA8(ctx, base);
	// 828376F4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 828376F8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828376FC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82837700: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82837704: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82837708: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837830 size=456
    let mut pc: u32 = 0x82837830;
    'dispatch: loop {
        match pc {
            0x82837830 => {
    //   block [0x82837830..0x828379F8)
	// 82837830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82837834: 4897092D  bl 0x831a8160
	ctx.lr = 0x82837838;
	sub_831A8130(ctx, base);
	// 82837838: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 8283783C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82837840: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837844: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82837848: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283784C: 4802B2C5  bl 0x82862b10
	ctx.lr = 0x82837850;
	sub_82862B10(ctx, base);
	// 82837850: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82837854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82837858: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8283785C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82837860: 40990188  ble cr6, 0x828379e8
	if !ctx.cr[6].gt {
	pc = 0x828379E8; continue 'dispatch;
	}
	// 82837864: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283786C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82837870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82837874: 4E800421  bctrl
	ctx.lr = 0x82837878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82837878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283787C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82837880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82837884: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828379F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828379F8 size=332
    let mut pc: u32 = 0x828379F8;
    'dispatch: loop {
        match pc {
            0x828379F8 => {
    //   block [0x828379F8..0x82837B44)
	// 828379F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828379FC: 4897076D  bl 0x831a8168
	ctx.lr = 0x82837A00;
	sub_831A8130(ctx, base);
	// 82837A00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837A04: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82837A08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82837A0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82837A10: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82837A14: 41820038  beq 0x82837a4c
	if ctx.cr[0].eq {
	pc = 0x82837A4C; continue 'dispatch;
	}
	// 82837A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837A1C: 48971F6D  bl 0x831a9988
	ctx.lr = 0x82837A20;
	sub_831A9988(ctx, base);
	// 82837A20: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82837A24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82837A28: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82837A2C: 489706CD  bl 0x831a80f8
	ctx.lr = 0x82837A30;
	sub_831A80F8(ctx, base);
	// 82837A30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837A34: 41820018  beq 0x82837a4c
	if ctx.cr[0].eq {
	pc = 0x82837A4C; continue 'dispatch;
	}
	// 82837A38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837A3C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82837A40: 4BFFCD09  bl 0x82834748
	ctx.lr = 0x82837A44;
	sub_82834748(ctx, base);
	// 82837A44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82837A48: 480000F4  b 0x82837b3c
	pc = 0x82837B3C; continue 'dispatch;
	// 82837A4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837A50: 419A00DC  beq cr6, 0x82837b2c
	if ctx.cr[6].eq {
	pc = 0x82837B2C; continue 'dispatch;
	}
	// 82837A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837A58: 48971F31  bl 0x831a9988
	ctx.lr = 0x82837A5C;
	sub_831A9988(ctx, base);
	// 82837A5C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82837A60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82837A64: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82837A68: 48970691  bl 0x831a80f8
	ctx.lr = 0x82837A6C;
	sub_831A80F8(ctx, base);
	// 82837A6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837A70: 41820014  beq 0x82837a84
	if ctx.cr[0].eq {
	pc = 0x82837A84; continue 'dispatch;
	}
	// 82837A74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837A78: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82837A7C: 4BFFCCE5  bl 0x82834760
	ctx.lr = 0x82837A80;
	sub_82834760(ctx, base);
	// 82837A80: 4BFFFFC4  b 0x82837a44
	pc = 0x82837A44; continue 'dispatch;
	// 82837A84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837A88: 419A00A4  beq cr6, 0x82837b2c
	if ctx.cr[6].eq {
	pc = 0x82837B2C; continue 'dispatch;
	}
	// 82837A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837A90: 48971EF9  bl 0x831a9988
	ctx.lr = 0x82837A94;
	sub_831A9988(ctx, base);
	// 82837A94: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82837A98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82837A9C: 386B16A8  addi r3, r11, 0x16a8
	ctx.r[3].s64 = ctx.r[11].s64 + 5800;
	// 82837AA0: 48970659  bl 0x831a80f8
	ctx.lr = 0x82837AA4;
	sub_831A80F8(ctx, base);
	// 82837AA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837AA8: 41820014  beq 0x82837abc
	if ctx.cr[0].eq {
	pc = 0x82837ABC; continue 'dispatch;
	}
	// 82837AAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837AB0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82837AB4: 4BFFE255  bl 0x82835d08
	ctx.lr = 0x82837AB8;
	sub_82835D08(ctx, base);
	// 82837AB8: 4BFFFF8C  b 0x82837a44
	pc = 0x82837A44; continue 'dispatch;
	// 82837ABC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837AC0: 419A006C  beq cr6, 0x82837b2c
	if ctx.cr[6].eq {
	pc = 0x82837B2C; continue 'dispatch;
	}
	// 82837AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837AC8: 48971EC1  bl 0x831a9988
	ctx.lr = 0x82837ACC;
	sub_831A9988(ctx, base);
	// 82837ACC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82837AD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82837AD4: 386B1670  addi r3, r11, 0x1670
	ctx.r[3].s64 = ctx.r[11].s64 + 5744;
	// 82837AD8: 48970621  bl 0x831a80f8
	ctx.lr = 0x82837ADC;
	sub_831A80F8(ctx, base);
	// 82837ADC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837AE0: 41820014  beq 0x82837af4
	if ctx.cr[0].eq {
	pc = 0x82837AF4; continue 'dispatch;
	}
	// 82837AE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837AE8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82837AEC: 4BFFE295  bl 0x82835d80
	ctx.lr = 0x82837AF0;
	sub_82835D80(ctx, base);
	// 82837AF0: 4BFFFF54  b 0x82837a44
	pc = 0x82837A44; continue 'dispatch;
	// 82837AF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837AF8: 419A0034  beq cr6, 0x82837b2c
	if ctx.cr[6].eq {
	pc = 0x82837B2C; continue 'dispatch;
	}
	// 82837AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837B00: 48971E89  bl 0x831a9988
	ctx.lr = 0x82837B04;
	sub_831A9988(ctx, base);
	// 82837B04: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82837B08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82837B0C: 386B9AF8  addi r3, r11, -0x6508
	ctx.r[3].s64 = ctx.r[11].s64 + -25864;
	// 82837B10: 489705E9  bl 0x831a80f8
	ctx.lr = 0x82837B14;
	sub_831A80F8(ctx, base);
	// 82837B14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837B18: 41820014  beq 0x82837b2c
	if ctx.cr[0].eq {
	pc = 0x82837B2C; continue 'dispatch;
	}
	// 82837B1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837B20: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82837B24: 4BFFEFDD  bl 0x82836b00
	ctx.lr = 0x82837B28;
	sub_82836B00(ctx, base);
	// 82837B28: 4BFFFF1C  b 0x82837a44
	pc = 0x82837A44; continue 'dispatch;
	// 82837B2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82837B30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82837B38: 4BFE1CF9  bl 0x82819830
	ctx.lr = 0x82837B3C;
	sub_82819830(ctx, base);
	// 82837B3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82837B40: 48970678  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837B48 size=468
    let mut pc: u32 = 0x82837B48;
    'dispatch: loop {
        match pc {
            0x82837B48 => {
    //   block [0x82837B48..0x82837D1C)
	// 82837B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82837B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82837B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82837B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82837B58: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82837B5C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82837B60: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837B64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82837B68: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82837B6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82837B70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82837B74: 3BCBC548  addi r30, r11, -0x3ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -15032;
	// 82837B78: 809F0264  lwz r4, 0x264(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82837B7C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82837B80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82837B84: 419A00E4  beq cr6, 0x82837c68
	if ctx.cr[6].eq {
	pc = 0x82837C68; continue 'dispatch;
	}
	// 82837B88: 4BFFEEA9  bl 0x82836a30
	ctx.lr = 0x82837B8C;
	sub_82836A30(ctx, base);
	// 82837B8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82837B90: 418200D8  beq 0x82837c68
	if ctx.cr[0].eq {
	pc = 0x82837C68; continue 'dispatch;
	}
	// 82837B94: C01F0270  lfs f0, 0x270(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82837B98: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82837B9C: D01F0270  stfs f0, 0x270(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 82837BA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82837BA4: 409800C4  bge cr6, 0x82837c68
	if !ctx.cr[6].lt {
	pc = 0x82837C68; continue 'dispatch;
	}
	// 82837BA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837BAC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82837BB0: C01F0278  lfs f0, 0x278(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82837BB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837BB8: D01F0270  stfs f0, 0x270(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 82837BBC: 38AAC7CC  addi r5, r10, -0x3834
	ctx.r[5].s64 = ctx.r[10].s64 + -14388;
	// 82837BC0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82837BC4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82837BC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82837BCC: 4E800421  bctrl
	ctx.lr = 0x82837BD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82837BD0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82837BD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837BD8: 419A0008  beq cr6, 0x82837be0
	if ctx.cr[6].eq {
	pc = 0x82837BE0; continue 'dispatch;
	}
	// 82837BDC: 4BA88CB5  bl 0x822c0890
	ctx.lr = 0x82837BE0;
	sub_822C0890(ctx, base);
	// 82837BE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82837BE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82837BE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82837BEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82837BF0: 4BFFE931  bl 0x82836520
	ctx.lr = 0x82837BF4;
	sub_82836520(ctx, base);
	// 82837BF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837BF8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82837BFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82837C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82837C04: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82837C08: 419A0024  beq cr6, 0x82837c2c
	if ctx.cr[6].eq {
	pc = 0x82837C2C; continue 'dispatch;
	}
	// 82837C0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82837C10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82837C14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837C18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82837C1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82837C20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82837C24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837C28: 4082FFE8  bne 0x82837c10
	if !ctx.cr[0].eq {
	pc = 0x82837C10; continue 'dispatch;
	}
	// 82837C2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837C30: 80DF0264  lwz r6, 0x264(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82837C34: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82837C38: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82837C3C: 38A001D3  li r5, 0x1d3
	ctx.r[5].s64 = 467;
	// 82837C40: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82837C44: 48620DFD  bl 0x82e58a40
	ctx.lr = 0x82837C48;
	sub_82E58A40(ctx, base);
	// 82837C48: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82837C4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837C50: 419A0008  beq cr6, 0x82837c58
	if ctx.cr[6].eq {
	pc = 0x82837C58; continue 'dispatch;
	}
	// 82837C54: 4BA88C3D  bl 0x822c0890
	ctx.lr = 0x82837C58;
	sub_822C0890(ctx, base);
	// 82837C58: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82837C5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837C60: 419A0008  beq cr6, 0x82837c68
	if ctx.cr[6].eq {
	pc = 0x82837C68; continue 'dispatch;
	}
	// 82837C64: 4BA88C2D  bl 0x822c0890
	ctx.lr = 0x82837C68;
	sub_822C0890(ctx, base);
	// 82837C68: 807F0254  lwz r3, 0x254(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 82837C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837C70: 419A008C  beq cr6, 0x82837cfc
	if ctx.cr[6].eq {
	pc = 0x82837CFC; continue 'dispatch;
	}
	// 82837C74: 4800137D  bl 0x82838ff0
	ctx.lr = 0x82837C78;
	sub_82838FF0(ctx, base);
	// 82837C78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837C7C: 41820080  beq 0x82837cfc
	if ctx.cr[0].eq {
	pc = 0x82837CFC; continue 'dispatch;
	}
	// 82837C80: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82837C84: 4BFFE7AD  bl 0x82836430
	ctx.lr = 0x82837C88;
	sub_82836430(ctx, base);
	// 82837C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837C8C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82837C90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82837C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82837C98: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82837C9C: 419A0024  beq cr6, 0x82837cc0
	if ctx.cr[6].eq {
	pc = 0x82837CC0; continue 'dispatch;
	}
	// 82837CA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82837CA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82837CA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837CAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82837CB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82837CB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82837CB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837CBC: 4082FFE8  bne 0x82837ca4
	if !ctx.cr[0].eq {
	pc = 0x82837CA4; continue 'dispatch;
	}
	// 82837CC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837CC4: 80DF0264  lwz r6, 0x264(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82837CC8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82837CCC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82837CD0: 38A001DA  li r5, 0x1da
	ctx.r[5].s64 = 474;
	// 82837CD4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82837CD8: 48620D69  bl 0x82e58a40
	ctx.lr = 0x82837CDC;
	sub_82E58A40(ctx, base);
	// 82837CDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82837CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837CE4: 419A0008  beq cr6, 0x82837cec
	if ctx.cr[6].eq {
	pc = 0x82837CEC; continue 'dispatch;
	}
	// 82837CE8: 4BA88BA9  bl 0x822c0890
	ctx.lr = 0x82837CEC;
	sub_822C0890(ctx, base);
	// 82837CEC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82837CF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837CF4: 419A0008  beq cr6, 0x82837cfc
	if ctx.cr[6].eq {
	pc = 0x82837CFC; continue 'dispatch;
	}
	// 82837CF8: 4BA88B99  bl 0x822c0890
	ctx.lr = 0x82837CFC;
	sub_822C0890(ctx, base);
	// 82837CFC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82837D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82837D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82837D08: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82837D0C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82837D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82837D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82837D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82837D20 size=200
    let mut pc: u32 = 0x82837D20;
    'dispatch: loop {
        match pc {
            0x82837D20 => {
    //   block [0x82837D20..0x82837DE8)
	// 82837D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82837D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82837D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82837D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82837D30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837D34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82837D38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82837D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82837D40: 4BFB4419  bl 0x827ec158
	ctx.lr = 0x82837D44;
	sub_827EC158(ctx, base);
	// 82837D44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82837D48: 4BC2E791  bl 0x824664d8
	ctx.lr = 0x82837D4C;
	sub_824664D8(ctx, base);
	// 82837D4C: 817F025C  lwz r11, 0x25c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82837D50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82837D54: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82837D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82837D5C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82837D60: 419A0024  beq cr6, 0x82837d84
	if ctx.cr[6].eq {
	pc = 0x82837D84; continue 'dispatch;
	}
	// 82837D64: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82837D68: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82837D6C: 4BC5A225  bl 0x82491f90
	ctx.lr = 0x82837D70;
	sub_82491F90(ctx, base);
	// 82837D70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82837D74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82837D78: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82837D7C: 4BC5A1D5  bl 0x82491f50
	ctx.lr = 0x82837D80;
	sub_82491F50(ctx, base);
	// 82837D80: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82837D84: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837D88: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82837D8C: 419A002C  beq cr6, 0x82837db8
	if ctx.cr[6].eq {
	pc = 0x82837DB8; continue 'dispatch;
	}
	// 82837D90: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82837D94: 4BFA223D  bl 0x827d9fd0
	ctx.lr = 0x82837D98;
	sub_827D9FD0(ctx, base);
	// 82837D98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82837D9C: 4182000C  beq 0x82837da8
	if ctx.cr[0].eq {
	pc = 0x82837DA8; continue 'dispatch;
	}
	// 82837DA0: 487D1219  bl 0x83008fb8
	ctx.lr = 0x82837DA4;
	sub_83008FB8(ctx, base);
	// 82837DA4: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82837DA8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82837DAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82837DB0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82837DB4: 409AFFDC  bne cr6, 0x82837d90
	if !ctx.cr[6].eq {
	pc = 0x82837D90; continue 'dispatch;
	}
	// 82837DB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82837DBC: 4BBF08C5  bl 0x82428680
	ctx.lr = 0x82837DC0;
	sub_82428680(ctx, base);
	// 82837DC0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82837DC4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82837DC8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82837DCC: 485BA3BD  bl 0x82df2188
	ctx.lr = 0x82837DD0;
	sub_82DF2188(ctx, base);
	// 82837DD0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82837DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82837DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82837DDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82837DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82837DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837DE8 size=480
    let mut pc: u32 = 0x82837DE8;
    'dispatch: loop {
        match pc {
            0x82837DE8 => {
    //   block [0x82837DE8..0x82837FC8)
	// 82837DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82837DEC: 48970379  bl 0x831a8164
	ctx.lr = 0x82837DF0;
	sub_831A8130(ctx, base);
	// 82837DF0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82837DF4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837DF8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82837DFC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82837E00: 3BCBC548  addi r30, r11, -0x3ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -15032;
	// 82837E04: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82837E08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82837E0C: 38A002C2  li r5, 0x2c2
	ctx.r[5].s64 = 706;
	// 82837E10: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82837E14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837E18: 3860028C  li r3, 0x28c
	ctx.r[3].s64 = 652;
	// 82837E1C: 485BA5CD  bl 0x82df23e8
	ctx.lr = 0x82837E20;
	sub_82DF23E8(ctx, base);
	// 82837E20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82837E24: 41820014  beq 0x82837e38
	if ctx.cr[0].eq {
	pc = 0x82837E38; continue 'dispatch;
	}
	// 82837E28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82837E2C: 4BFFE0CD  bl 0x82835ef8
	ctx.lr = 0x82837E30;
	sub_82835EF8(ctx, base);
	// 82837E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82837E34: 48000008  b 0x82837e3c
	pc = 0x82837E3C; continue 'dispatch;
	// 82837E38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82837E3C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82837E40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837E44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82837E48: 4BFFCF39  bl 0x82834d80
	ctx.lr = 0x82837E4C;
	sub_82834D80(ctx, base);
	// 82837E4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82837E50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837E54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82837E58: 4BA881A9  bl 0x822c0000
	ctx.lr = 0x82837E5C;
	sub_822C0000(ctx, base);
	// 82837E5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837E60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82837E64: 38A002C3  li r5, 0x2c3
	ctx.r[5].s64 = 707;
	// 82837E68: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82837E6C: 4BA8856D  bl 0x822c03d8
	ctx.lr = 0x82837E70;
	sub_822C03D8(ctx, base);
	// 82837E70: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82837E74: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82837E78: 418200E0  beq 0x82837f58
	if ctx.cr[0].eq {
	pc = 0x82837F58; continue 'dispatch;
	}
	// 82837E7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82837E80: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82837E84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82837E88: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82837E8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82837E90: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82837E94: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82837E98: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82837E9C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82837EA0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82837EA4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82837EA8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82837EAC: 409A0008  bne cr6, 0x82837eb4
	if !ctx.cr[6].eq {
	pc = 0x82837EB4; continue 'dispatch;
	}
	// 82837EB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82837EB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82837EB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837EBC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82837EC0: 419A0024  beq cr6, 0x82837ee4
	if ctx.cr[6].eq {
	pc = 0x82837EE4; continue 'dispatch;
	}
	// 82837EC4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82837EC8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82837ECC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837ED0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82837ED4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82837ED8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82837EDC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837EE0: 4082FFE8  bne 0x82837ec8
	if !ctx.cr[0].eq {
	pc = 0x82837EC8; continue 'dispatch;
	}
	// 82837EE4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82837EE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837EEC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82837EF0: 419A0024  beq cr6, 0x82837f14
	if ctx.cr[6].eq {
	pc = 0x82837F14; continue 'dispatch;
	}
	// 82837EF4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82837EF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82837EFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837F00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82837F04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82837F08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82837F0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82837F10: 4082FFE8  bne 0x82837ef8
	if !ctx.cr[0].eq {
	pc = 0x82837EF8; continue 'dispatch;
	}
	// 82837F14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82837F18: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82837F1C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82837F20: C02BC7DC  lfs f1, -0x3824(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14372 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82837F24: 48644D1D  bl 0x82e7cc40
	ctx.lr = 0x82837F28;
	sub_82E7CC40(ctx, base);
	// 82837F28: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82837F2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82837F30: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82837F34: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82837F38: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82837F3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82837F40: 4BF60FF1  bl 0x82798f30
	ctx.lr = 0x82837F44;
	sub_82798F30(ctx, base);
	// 82837F44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82837F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82837F4C: 4BF6371D  bl 0x8279b668
	ctx.lr = 0x82837F50;
	sub_8279B668(ctx, base);
	// 82837F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82837F54: 48000008  b 0x82837f5c
	pc = 0x82837F5C; continue 'dispatch;
	// 82837F58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82837F5C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82837F60: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82837F64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82837F6C: 4BD5FCE5  bl 0x82597c50
	ctx.lr = 0x82837F70;
	sub_82597C50(ctx, base);
	// 82837F70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82837F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82837F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82837F7C: 4BA88085  bl 0x822c0000
	ctx.lr = 0x82837F80;
	sub_822C0000(ctx, base);
	// 82837F80: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82837F84: 41820024  beq 0x82837fa8
	if ctx.cr[0].eq {
	pc = 0x82837FA8; continue 'dispatch;
	}
	// 82837F88: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82837F8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837F90: 419A0008  beq cr6, 0x82837f98
	if ctx.cr[6].eq {
	pc = 0x82837F98; continue 'dispatch;
	}
	// 82837F94: 4BA888FD  bl 0x822c0890
	ctx.lr = 0x82837F98;
	sub_822C0890(ctx, base);
	// 82837F98: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82837F9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82837FA0: 419A0008  beq cr6, 0x82837fa8
	if ctx.cr[6].eq {
	pc = 0x82837FA8; continue 'dispatch;
	}
	// 82837FA4: 4BA888ED  bl 0x822c0890
	ctx.lr = 0x82837FA8;
	sub_822C0890(ctx, base);
	// 82837FA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82837FAC: 419A000C  beq cr6, 0x82837fb8
	if ctx.cr[6].eq {
	pc = 0x82837FB8; continue 'dispatch;
	}
	// 82837FB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82837FB4: 4BA888DD  bl 0x822c0890
	ctx.lr = 0x82837FB8;
	sub_822C0890(ctx, base);
	// 82837FB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82837FBC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82837FC0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82837FC4: 489701F0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82837FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82837FC8 size=480
    let mut pc: u32 = 0x82837FC8;
    'dispatch: loop {
        match pc {
            0x82837FC8 => {
    //   block [0x82837FC8..0x828381A8)
	// 82837FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82837FCC: 48970199  bl 0x831a8164
	ctx.lr = 0x82837FD0;
	sub_831A8130(ctx, base);
	// 82837FD0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82837FD4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82837FD8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82837FDC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82837FE0: 3BCBC548  addi r30, r11, -0x3ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -15032;
	// 82837FE4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82837FE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82837FEC: 38A002CB  li r5, 0x2cb
	ctx.r[5].s64 = 715;
	// 82837FF0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82837FF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82837FF8: 3860028C  li r3, 0x28c
	ctx.r[3].s64 = 652;
	// 82837FFC: 485BA3ED  bl 0x82df23e8
	ctx.lr = 0x82838000;
	sub_82DF23E8(ctx, base);
	// 82838000: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82838004: 41820014  beq 0x82838018
	if ctx.cr[0].eq {
	pc = 0x82838018; continue 'dispatch;
	}
	// 82838008: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8283800C: 4BFFDEED  bl 0x82835ef8
	ctx.lr = 0x82838010;
	sub_82835EF8(ctx, base);
	// 82838010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838014: 48000008  b 0x8283801c
	pc = 0x8283801C; continue 'dispatch;
	// 82838018: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283801C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82838020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838024: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82838028: 4BFFCD59  bl 0x82834d80
	ctx.lr = 0x8283802C;
	sub_82834D80(ctx, base);
	// 8283802C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82838030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82838038: 4BA87FC9  bl 0x822c0000
	ctx.lr = 0x8283803C;
	sub_822C0000(ctx, base);
	// 8283803C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82838040: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82838044: 38A002CC  li r5, 0x2cc
	ctx.r[5].s64 = 716;
	// 82838048: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8283804C: 4BA8838D  bl 0x822c03d8
	ctx.lr = 0x82838050;
	sub_822C03D8(ctx, base);
	// 82838050: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82838054: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82838058: 418200E0  beq 0x82838138
	if ctx.cr[0].eq {
	pc = 0x82838138; continue 'dispatch;
	}
	// 8283805C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838060: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82838064: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82838068: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8283806C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82838070: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82838074: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82838078: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283807C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82838080: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82838084: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82838088: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283808C: 409A0008  bne cr6, 0x82838094
	if !ctx.cr[6].eq {
	pc = 0x82838094; continue 'dispatch;
	}
	// 82838090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82838094: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82838098: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283809C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828380A0: 419A0024  beq cr6, 0x828380c4
	if ctx.cr[6].eq {
	pc = 0x828380C4; continue 'dispatch;
	}
	// 828380A4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828380A8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828380AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828380B0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828380B4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828380B8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828380BC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828380C0: 4082FFE8  bne 0x828380a8
	if !ctx.cr[0].eq {
	pc = 0x828380A8; continue 'dispatch;
	}
	// 828380C4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828380C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828380CC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828380D0: 419A0024  beq cr6, 0x828380f4
	if ctx.cr[6].eq {
	pc = 0x828380F4; continue 'dispatch;
	}
	// 828380D4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828380D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828380DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828380E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828380E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828380E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828380EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828380F0: 4082FFE8  bne 0x828380d8
	if !ctx.cr[0].eq {
	pc = 0x828380D8; continue 'dispatch;
	}
	// 828380F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828380F8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828380FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82838100: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82838104: 48644B3D  bl 0x82e7cc40
	ctx.lr = 0x82838108;
	sub_82E7CC40(ctx, base);
	// 82838108: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283810C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82838110: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82838114: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82838118: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8283811C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82838120: 4BF60E11  bl 0x82798f30
	ctx.lr = 0x82838124;
	sub_82798F30(ctx, base);
	// 82838124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283812C: 4BF6353D  bl 0x8279b668
	ctx.lr = 0x82838130;
	sub_8279B668(ctx, base);
	// 82838130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838134: 48000008  b 0x8283813c
	pc = 0x8283813C; continue 'dispatch;
	// 82838138: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283813C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82838140: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82838144: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283814C: 4BD5FB05  bl 0x82597c50
	ctx.lr = 0x82838150;
	sub_82597C50(ctx, base);
	// 82838150: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82838154: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283815C: 4BA87EA5  bl 0x822c0000
	ctx.lr = 0x82838160;
	sub_822C0000(ctx, base);
	// 82838160: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838164: 41820024  beq 0x82838188
	if ctx.cr[0].eq {
	pc = 0x82838188; continue 'dispatch;
	}
	// 82838168: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8283816C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838170: 419A0008  beq cr6, 0x82838178
	if ctx.cr[6].eq {
	pc = 0x82838178; continue 'dispatch;
	}
	// 82838174: 4BA8871D  bl 0x822c0890
	ctx.lr = 0x82838178;
	sub_822C0890(ctx, base);
	// 82838178: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8283817C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838180: 419A0008  beq cr6, 0x82838188
	if ctx.cr[6].eq {
	pc = 0x82838188; continue 'dispatch;
	}
	// 82838184: 4BA8870D  bl 0x822c0890
	ctx.lr = 0x82838188;
	sub_822C0890(ctx, base);
	// 82838188: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283818C: 419A000C  beq cr6, 0x82838198
	if ctx.cr[6].eq {
	pc = 0x82838198; continue 'dispatch;
	}
	// 82838190: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82838194: 4BA886FD  bl 0x822c0890
	ctx.lr = 0x82838198;
	sub_822C0890(ctx, base);
	// 82838198: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283819C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828381A0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828381A4: 48970010  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828381A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828381A8 size=480
    let mut pc: u32 = 0x828381A8;
    'dispatch: loop {
        match pc {
            0x828381A8 => {
    //   block [0x828381A8..0x82838388)
	// 828381A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828381AC: 4896FFB9  bl 0x831a8164
	ctx.lr = 0x828381B0;
	sub_831A8130(ctx, base);
	// 828381B0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828381B4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828381B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828381BC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828381C0: 3BCBC548  addi r30, r11, -0x3ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -15032;
	// 828381C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828381C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828381CC: 38A0034B  li r5, 0x34b
	ctx.r[5].s64 = 843;
	// 828381D0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828381D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828381D8: 3860028C  li r3, 0x28c
	ctx.r[3].s64 = 652;
	// 828381DC: 485BA20D  bl 0x82df23e8
	ctx.lr = 0x828381E0;
	sub_82DF23E8(ctx, base);
	// 828381E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828381E4: 41820014  beq 0x828381f8
	if ctx.cr[0].eq {
	pc = 0x828381F8; continue 'dispatch;
	}
	// 828381E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828381EC: 4BFFDDDD  bl 0x82835fc8
	ctx.lr = 0x828381F0;
	sub_82835FC8(ctx, base);
	// 828381F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828381F4: 48000008  b 0x828381fc
	pc = 0x828381FC; continue 'dispatch;
	// 828381F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828381FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82838200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838204: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82838208: 4BFFCC41  bl 0x82834e48
	ctx.lr = 0x8283820C;
	sub_82834E48(ctx, base);
	// 8283820C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82838210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838214: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82838218: 4BA87DE9  bl 0x822c0000
	ctx.lr = 0x8283821C;
	sub_822C0000(ctx, base);
	// 8283821C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82838220: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82838224: 38A0034C  li r5, 0x34c
	ctx.r[5].s64 = 844;
	// 82838228: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8283822C: 4BA881AD  bl 0x822c03d8
	ctx.lr = 0x82838230;
	sub_822C03D8(ctx, base);
	// 82838230: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82838234: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82838238: 418200E0  beq 0x82838318
	if ctx.cr[0].eq {
	pc = 0x82838318; continue 'dispatch;
	}
	// 8283823C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838240: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82838244: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82838248: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8283824C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82838250: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82838254: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82838258: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283825C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82838260: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82838264: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82838268: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283826C: 409A0008  bne cr6, 0x82838274
	if !ctx.cr[6].eq {
	pc = 0x82838274; continue 'dispatch;
	}
	// 82838270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82838274: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82838278: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283827C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82838280: 419A0024  beq cr6, 0x828382a4
	if ctx.cr[6].eq {
	pc = 0x828382A4; continue 'dispatch;
	}
	// 82838284: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82838288: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8283828C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838290: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82838294: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82838298: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283829C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828382A0: 4082FFE8  bne 0x82838288
	if !ctx.cr[0].eq {
	pc = 0x82838288; continue 'dispatch;
	}
	// 828382A4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828382A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828382AC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828382B0: 419A0024  beq cr6, 0x828382d4
	if ctx.cr[6].eq {
	pc = 0x828382D4; continue 'dispatch;
	}
	// 828382B4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828382B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828382BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828382C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828382C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828382C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828382CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828382D0: 4082FFE8  bne 0x828382b8
	if !ctx.cr[0].eq {
	pc = 0x828382B8; continue 'dispatch;
	}
	// 828382D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828382D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828382DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828382E0: C02BC7DC  lfs f1, -0x3824(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14372 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828382E4: 4864495D  bl 0x82e7cc40
	ctx.lr = 0x828382E8;
	sub_82E7CC40(ctx, base);
	// 828382E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828382EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828382F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828382F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828382F8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828382FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82838300: 4BF60C31  bl 0x82798f30
	ctx.lr = 0x82838304;
	sub_82798F30(ctx, base);
	// 82838304: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283830C: 4BF6335D  bl 0x8279b668
	ctx.lr = 0x82838310;
	sub_8279B668(ctx, base);
	// 82838310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838314: 48000008  b 0x8283831c
	pc = 0x8283831C; continue 'dispatch;
	// 82838318: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283831C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82838320: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82838324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283832C: 4BD5F925  bl 0x82597c50
	ctx.lr = 0x82838330;
	sub_82597C50(ctx, base);
	// 82838330: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82838334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283833C: 4BA87CC5  bl 0x822c0000
	ctx.lr = 0x82838340;
	sub_822C0000(ctx, base);
	// 82838340: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838344: 41820024  beq 0x82838368
	if ctx.cr[0].eq {
	pc = 0x82838368; continue 'dispatch;
	}
	// 82838348: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8283834C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838350: 419A0008  beq cr6, 0x82838358
	if ctx.cr[6].eq {
	pc = 0x82838358; continue 'dispatch;
	}
	// 82838354: 4BA8853D  bl 0x822c0890
	ctx.lr = 0x82838358;
	sub_822C0890(ctx, base);
	// 82838358: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8283835C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838360: 419A0008  beq cr6, 0x82838368
	if ctx.cr[6].eq {
	pc = 0x82838368; continue 'dispatch;
	}
	// 82838364: 4BA8852D  bl 0x822c0890
	ctx.lr = 0x82838368;
	sub_822C0890(ctx, base);
	// 82838368: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283836C: 419A000C  beq cr6, 0x82838378
	if ctx.cr[6].eq {
	pc = 0x82838378; continue 'dispatch;
	}
	// 82838370: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82838374: 4BA8851D  bl 0x822c0890
	ctx.lr = 0x82838378;
	sub_822C0890(ctx, base);
	// 82838378: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283837C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82838380: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82838384: 4896FE30  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838388 size=480
    let mut pc: u32 = 0x82838388;
    'dispatch: loop {
        match pc {
            0x82838388 => {
    //   block [0x82838388..0x82838568)
	// 82838388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283838C: 4896FDD9  bl 0x831a8164
	ctx.lr = 0x82838390;
	sub_831A8130(ctx, base);
	// 82838390: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82838394: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838398: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283839C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828383A0: 3BCBC548  addi r30, r11, -0x3ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -15032;
	// 828383A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828383A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828383AC: 38A00354  li r5, 0x354
	ctx.r[5].s64 = 852;
	// 828383B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828383B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828383B8: 3860028C  li r3, 0x28c
	ctx.r[3].s64 = 652;
	// 828383BC: 485BA02D  bl 0x82df23e8
	ctx.lr = 0x828383C0;
	sub_82DF23E8(ctx, base);
	// 828383C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828383C4: 41820014  beq 0x828383d8
	if ctx.cr[0].eq {
	pc = 0x828383D8; continue 'dispatch;
	}
	// 828383C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828383CC: 4BFFDBFD  bl 0x82835fc8
	ctx.lr = 0x828383D0;
	sub_82835FC8(ctx, base);
	// 828383D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828383D4: 48000008  b 0x828383dc
	pc = 0x828383DC; continue 'dispatch;
	// 828383D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828383DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828383E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828383E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828383E8: 4BFFCA61  bl 0x82834e48
	ctx.lr = 0x828383EC;
	sub_82834E48(ctx, base);
	// 828383EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828383F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828383F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828383F8: 4BA87C09  bl 0x822c0000
	ctx.lr = 0x828383FC;
	sub_822C0000(ctx, base);
	// 828383FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82838400: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82838404: 38A00355  li r5, 0x355
	ctx.r[5].s64 = 853;
	// 82838408: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8283840C: 4BA87FCD  bl 0x822c03d8
	ctx.lr = 0x82838410;
	sub_822C03D8(ctx, base);
	// 82838410: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82838414: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82838418: 418200E0  beq 0x828384f8
	if ctx.cr[0].eq {
	pc = 0x828384F8; continue 'dispatch;
	}
	// 8283841C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838420: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82838424: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82838428: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8283842C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82838430: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82838434: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 82838438: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283843C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82838440: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82838444: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82838448: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283844C: 409A0008  bne cr6, 0x82838454
	if !ctx.cr[6].eq {
	pc = 0x82838454; continue 'dispatch;
	}
	// 82838450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82838454: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82838458: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283845C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82838460: 419A0024  beq cr6, 0x82838484
	if ctx.cr[6].eq {
	pc = 0x82838484; continue 'dispatch;
	}
	// 82838464: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82838468: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8283846C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838470: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82838474: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82838478: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283847C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838480: 4082FFE8  bne 0x82838468
	if !ctx.cr[0].eq {
	pc = 0x82838468; continue 'dispatch;
	}
	// 82838484: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82838488: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283848C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82838490: 419A0024  beq cr6, 0x828384b4
	if ctx.cr[6].eq {
	pc = 0x828384B4; continue 'dispatch;
	}
	// 82838494: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82838498: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283849C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828384A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828384A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828384A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828384AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828384B0: 4082FFE8  bne 0x82838498
	if !ctx.cr[0].eq {
	pc = 0x82838498; continue 'dispatch;
	}
	// 828384B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828384B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828384BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828384C0: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828384C4: 4864477D  bl 0x82e7cc40
	ctx.lr = 0x828384C8;
	sub_82E7CC40(ctx, base);
	// 828384C8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828384CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828384D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828384D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828384D8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828384DC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828384E0: 4BF60A51  bl 0x82798f30
	ctx.lr = 0x828384E4;
	sub_82798F30(ctx, base);
	// 828384E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828384E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828384EC: 4BF6317D  bl 0x8279b668
	ctx.lr = 0x828384F0;
	sub_8279B668(ctx, base);
	// 828384F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828384F4: 48000008  b 0x828384fc
	pc = 0x828384FC; continue 'dispatch;
	// 828384F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828384FC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82838500: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82838504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283850C: 4BD5F745  bl 0x82597c50
	ctx.lr = 0x82838510;
	sub_82597C50(ctx, base);
	// 82838510: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82838514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283851C: 4BA87AE5  bl 0x822c0000
	ctx.lr = 0x82838520;
	sub_822C0000(ctx, base);
	// 82838520: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838524: 41820024  beq 0x82838548
	if ctx.cr[0].eq {
	pc = 0x82838548; continue 'dispatch;
	}
	// 82838528: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8283852C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838530: 419A0008  beq cr6, 0x82838538
	if ctx.cr[6].eq {
	pc = 0x82838538; continue 'dispatch;
	}
	// 82838534: 4BA8835D  bl 0x822c0890
	ctx.lr = 0x82838538;
	sub_822C0890(ctx, base);
	// 82838538: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8283853C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838540: 419A0008  beq cr6, 0x82838548
	if ctx.cr[6].eq {
	pc = 0x82838548; continue 'dispatch;
	}
	// 82838544: 4BA8834D  bl 0x822c0890
	ctx.lr = 0x82838548;
	sub_822C0890(ctx, base);
	// 82838548: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283854C: 419A000C  beq cr6, 0x82838558
	if ctx.cr[6].eq {
	pc = 0x82838558; continue 'dispatch;
	}
	// 82838550: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82838554: 4BA8833D  bl 0x822c0890
	ctx.lr = 0x82838558;
	sub_822C0890(ctx, base);
	// 82838558: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283855C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82838560: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82838564: 4896FC50  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838568 size=872
    let mut pc: u32 = 0x82838568;
    'dispatch: loop {
        match pc {
            0x82838568 => {
    //   block [0x82838568..0x828388D0)
	// 82838568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283856C: 4896FBE9  bl 0x831a8154
	ctx.lr = 0x82838570;
	sub_831A8130(ctx, base);
	// 82838570: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82838574: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283857C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82838580: 4BFE1CB9  bl 0x8281a238
	ctx.lr = 0x82838584;
	sub_8281A238(ctx, base);
	// 82838584: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838588: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 8283858C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82838590: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 82838594: 7C7AD82E  lwzx r3, r26, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82838598: 48668199  bl 0x82ea0730
	ctx.lr = 0x8283859C;
	sub_82EA0730(ctx, base);
	// 8283859C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828385A0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828385A4: 396BC7F0  addi r11, r11, -0x3810
	ctx.r[11].s64 = ctx.r[11].s64 + -14352;
	// 828385A8: 394A2380  addi r10, r10, 0x2380
	ctx.r[10].s64 = ctx.r[10].s64 + 9088;
	// 828385AC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828385B0: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 828385B4: 3B000060  li r24, 0x60
	ctx.r[24].s64 = 96;
	// 828385B8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828385BC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828385C0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828385C4: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828388D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828388D0 size=180
    let mut pc: u32 = 0x828388D0;
    'dispatch: loop {
        match pc {
            0x828388D0 => {
    //   block [0x828388D0..0x82838984)
	// 828388D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828388D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828388D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828388DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828388E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828388E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828388E8: 4BFFFC81  bl 0x82838568
	ctx.lr = 0x828388EC;
	sub_82838568(ctx, base);
	// 828388EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828388F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828388F4: 4BFB3CD5  bl 0x827ec5c8
	ctx.lr = 0x828388F8;
	sub_827EC5C8(ctx, base);
	// 828388F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828388FC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82838904: 419A000C  beq cr6, 0x82838910
	if ctx.cr[6].eq {
	pc = 0x82838910; continue 'dispatch;
	}
	// 82838908: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8283890C: 4BA87F85  bl 0x822c0890
	ctx.lr = 0x82838910;
	sub_822C0890(ctx, base);
	// 82838910: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82838914: 419A0058  beq cr6, 0x8283896c
	if ctx.cr[6].eq {
	pc = 0x8283896C; continue 'dispatch;
	}
	// 82838918: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283891C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82838920: 388BC168  addi r4, r11, -0x3e98
	ctx.r[4].s64 = ctx.r[11].s64 + -16024;
	// 82838924: 485BB0E5  bl 0x82df3a08
	ctx.lr = 0x82838928;
	sub_82DF3A08(ctx, base);
	// 82838928: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8283892C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82838930: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82838934: 485DC6FD  bl 0x82e15030
	ctx.lr = 0x82838938;
	sub_82E15030(ctx, base);
	// 82838938: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283893C: 395F0284  addi r10, r31, 0x284
	ctx.r[10].s64 = ctx.r[31].s64 + 644;
	// 82838940: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82838944: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82838948: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283894C: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 82838950: 4BA8BB11  bl 0x822c4460
	ctx.lr = 0x82838954;
	sub_822C4460(ctx, base);
	// 82838954: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82838958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283895C: 419A0008  beq cr6, 0x82838964
	if ctx.cr[6].eq {
	pc = 0x82838964; continue 'dispatch;
	}
	// 82838960: 4BA87F31  bl 0x822c0890
	ctx.lr = 0x82838964;
	sub_822C0890(ctx, base);
	// 82838964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82838968: 485BAAC1  bl 0x82df3428
	ctx.lr = 0x8283896C;
	sub_82DF3428(ctx, base);
	// 8283896C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82838970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82838974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82838978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283897C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82838980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82838988 size=4
    let mut pc: u32 = 0x82838988;
    'dispatch: loop {
        match pc {
            0x82838988 => {
    //   block [0x82838988..0x8283898C)
	// 82838988: 4BFFFBE0  b 0x82838568
	sub_82838568(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82838990 size=228
    let mut pc: u32 = 0x82838990;
    'dispatch: loop {
        match pc {
            0x82838990 => {
    //   block [0x82838990..0x82838A74)
	// 82838990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82838994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82838998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283899C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828389A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828389A4: 4BFFDFDD  bl 0x82836980
	ctx.lr = 0x828389A8;
	sub_82836980(ctx, base);
	// 828389A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828389AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828389B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828389B4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828389B8: 808B8630  lwz r4, -0x79d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31184 as u32) ) } as u64;
	// 828389BC: 4BAF3D6D  bl 0x8232c728
	ctx.lr = 0x828389C0;
	sub_8232C728(ctx, base);
	// 828389C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828389C4: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828389C8: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828389CC: 4BF819A5  bl 0x827ba370
	ctx.lr = 0x828389D0;
	sub_827BA370(ctx, base);
	// 828389D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828389D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828389D8: 4BF81561  bl 0x827b9f38
	ctx.lr = 0x828389DC;
	sub_827B9F38(ctx, base);
	// 828389DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828389E0: 41820008  beq 0x828389e8
	if ctx.cr[0].eq {
	pc = 0x828389E8; continue 'dispatch;
	}
	// 828389E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828389E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828389EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828389F0: 808B8638  lwz r4, -0x79c8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31176 as u32) ) } as u64;
	// 828389F4: 4BAF3D35  bl 0x8232c728
	ctx.lr = 0x828389F8;
	sub_8232C728(ctx, base);
	// 828389F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828389FC: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82838A00: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82838A04: 4BF8196D  bl 0x827ba370
	ctx.lr = 0x82838A08;
	sub_827BA370(ctx, base);
	// 82838A08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838A10: 4BF81529  bl 0x827b9f38
	ctx.lr = 0x82838A14;
	sub_827B9F38(ctx, base);
	// 82838A14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838A18: 41820008  beq 0x82838a20
	if ctx.cr[0].eq {
	pc = 0x82838A20; continue 'dispatch;
	}
	// 82838A1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82838A20: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82838A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82838A28: 808B8644  lwz r4, -0x79bc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31164 as u32) ) } as u64;
	// 82838A2C: 4BAF3CFD  bl 0x8232c728
	ctx.lr = 0x82838A30;
	sub_8232C728(ctx, base);
	// 82838A30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82838A34: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82838A38: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82838A3C: 4BF81935  bl 0x827ba370
	ctx.lr = 0x82838A40;
	sub_827BA370(ctx, base);
	// 82838A40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838A48: 4BF814F1  bl 0x827b9f38
	ctx.lr = 0x82838A4C;
	sub_827B9F38(ctx, base);
	// 82838A4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838A50: 41820008  beq 0x82838a58
	if ctx.cr[0].eq {
	pc = 0x82838A58; continue 'dispatch;
	}
	// 82838A54: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82838A58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838A5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82838A60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82838A64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82838A68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82838A6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82838A70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838A78 size=236
    let mut pc: u32 = 0x82838A78;
    'dispatch: loop {
        match pc {
            0x82838A78 => {
    //   block [0x82838A78..0x82838B64)
	// 82838A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82838A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82838A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82838A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82838A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838A90: 4BFE0119  bl 0x82818ba8
	ctx.lr = 0x82838A94;
	sub_82818BA8(ctx, base);
	// 82838A94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838A98: 40820010  bne 0x82838aa8
	if !ctx.cr[0].eq {
	pc = 0x82838AA8; continue 'dispatch;
	}
	// 82838A9C: 389F0264  addi r4, r31, 0x264
	ctx.r[4].s64 = ctx.r[31].s64 + 612;
	// 82838AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838AA4: 4BFFF27D  bl 0x82837d20
	ctx.lr = 0x82838AA8;
	sub_82837D20(ctx, base);
	// 82838AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838AAC: 809F0264  lwz r4, 0x264(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82838AB0: 4BFFFEE1  bl 0x82838990
	ctx.lr = 0x82838AB4;
	sub_82838990(ctx, base);
	// 82838AB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82838AB8: 41820094  beq 0x82838b4c
	if ctx.cr[0].eq {
	pc = 0x82838B4C; continue 'dispatch;
	}
	// 82838ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838AC0: 481DABC1  bl 0x82a13680
	ctx.lr = 0x82838AC4;
	sub_82A13680(ctx, base);
	// 82838AC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838AC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82838ACC: 4BFFD8ED  bl 0x828363b8
	ctx.lr = 0x82838AD0;
	sub_828363B8(ctx, base);
	// 82838AD0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82838AD4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82838AD8: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82838ADC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82838AE0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82838AE4: 419A0024  beq cr6, 0x82838b08
	if ctx.cr[6].eq {
	pc = 0x82838B08; continue 'dispatch;
	}
	// 82838AE8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82838AEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82838AF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838AF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82838AF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82838AFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82838B00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838B04: 4082FFE8  bne 0x82838aec
	if !ctx.cr[0].eq {
	pc = 0x82838AEC; continue 'dispatch;
	}
	// 82838B08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838B0C: 80DF0264  lwz r6, 0x264(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82838B10: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82838B14: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82838B18: 388AC548  addi r4, r10, -0x3ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -15032;
	// 82838B1C: 38A001C4  li r5, 0x1c4
	ctx.r[5].s64 = 452;
	// 82838B20: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82838B24: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82838B28: 4861FF19  bl 0x82e58a40
	ctx.lr = 0x82838B2C;
	sub_82E58A40(ctx, base);
	// 82838B2C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82838B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838B34: 419A0008  beq cr6, 0x82838b3c
	if ctx.cr[6].eq {
	pc = 0x82838B3C; continue 'dispatch;
	}
	// 82838B38: 4BA87D59  bl 0x822c0890
	ctx.lr = 0x82838B3C;
	sub_822C0890(ctx, base);
	// 82838B3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82838B40: 419A000C  beq cr6, 0x82838b4c
	if ctx.cr[6].eq {
	pc = 0x82838B4C; continue 'dispatch;
	}
	// 82838B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838B48: 4BA87D49  bl 0x822c0890
	ctx.lr = 0x82838B4C;
	sub_822C0890(ctx, base);
	// 82838B4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82838B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82838B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82838B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82838B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82838B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838B68 size=84
    let mut pc: u32 = 0x82838B68;
    'dispatch: loop {
        match pc {
            0x82838B68 => {
    //   block [0x82838B68..0x82838BBC)
	// 82838B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82838B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82838B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82838B74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838B78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838B7C: 817F0268  lwz r11, 0x268(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 82838B80: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82838B84: 409A000C  bne cr6, 0x82838b90
	if !ctx.cr[6].eq {
	pc = 0x82838B90; continue 'dispatch;
	}
	// 82838B88: 4BFFFEF1  bl 0x82838a78
	ctx.lr = 0x82838B8C;
	sub_82838A78(ctx, base);
	// 82838B8C: 4800001C  b 0x82838ba8
	pc = 0x82838BA8; continue 'dispatch;
	// 82838B90: 4BFFBF11  bl 0x82834aa0
	ctx.lr = 0x82838B94;
	sub_82834AA0(ctx, base);
	// 82838B94: C01F027C  lfs f0, 0x27c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838B98: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82838B9C: 4098000C  bge cr6, 0x82838ba8
	if !ctx.cr[6].lt {
	pc = 0x82838BA8; continue 'dispatch;
	}
	// 82838BA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82838BA4: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82838BA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82838BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82838BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82838BB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82838BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


