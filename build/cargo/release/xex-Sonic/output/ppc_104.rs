pub fn sub_828B3890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3890 size=400
    let mut pc: u32 = 0x828B3890;
    'dispatch: loop {
        match pc {
            0x828B3890 => {
    //   block [0x828B3890..0x828B3A20)
	// 828B3890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3894: 488F48D5  bl 0x831a8168
	ctx.lr = 0x828B3898;
	sub_831A8130(ctx, base);
	// 828B3898: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B389C: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828B38A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B38A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B38A8: 4BF39559  bl 0x827ece00
	ctx.lr = 0x828B38AC;
	sub_827ECE00(ctx, base);
	// 828B38AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B38B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B38B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B38B8: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828B38BC: 4854014D  bl 0x82df3a08
	ctx.lr = 0x828B38C0;
	sub_82DF3A08(ctx, base);
	// 828B38C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B38C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B38C8: 4853F9D9  bl 0x82df32a0
	ctx.lr = 0x828B38CC;
	sub_82DF32A0(ctx, base);
	// 828B38CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B38D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B38D4: 4853FB55  bl 0x82df3428
	ctx.lr = 0x828B38D8;
	sub_82DF3428(ctx, base);
	// 828B38D8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B38DC: 4182013C  beq 0x828b3a18
	if ctx.cr[0].eq {
	pc = 0x828B3A18; continue 'dispatch;
	}
	// 828B38E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B38E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B38E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B38EC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B38F0: 808B2FF8  lwz r4, 0x2ff8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12280 as u32) ) } as u64;
	// 828B38F4: 48540115  bl 0x82df3a08
	ctx.lr = 0x828B38F8;
	sub_82DF3A08(ctx, base);
	// 828B38F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B38FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3900: 4853FA09  bl 0x82df3308
	ctx.lr = 0x828B3904;
	sub_82DF3308(ctx, base);
	// 828B3904: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B3908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B390C: 4853FB1D  bl 0x82df3428
	ctx.lr = 0x828B3910;
	sub_82DF3428(ctx, base);
	// 828B3910: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B3914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3918: 4182004C  beq 0x828b3964
	if ctx.cr[0].eq {
	pc = 0x828B3964; continue 'dispatch;
	}
	// 828B391C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3920: 388BB1DC  addi r4, r11, -0x4e24
	ctx.r[4].s64 = ctx.r[11].s64 + -20004;
	// 828B3924: 485400E5  bl 0x82df3a08
	ctx.lr = 0x828B3928;
	sub_82DF3A08(ctx, base);
	// 828B3928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B392C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828B3930: 4BF388A9  bl 0x827ec1d8
	ctx.lr = 0x828B3934;
	sub_827EC1D8(ctx, base);
	// 828B3934: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B3938: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B393C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3940: 485616F1  bl 0x82e15030
	ctx.lr = 0x828B3944;
	sub_82E15030(ctx, base);
	// 828B3944: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B3948: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828B394C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828B3950: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3954: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828B3958: 4BA10B09  bl 0x822c4460
	ctx.lr = 0x828B395C;
	sub_822C4460(ctx, base);
	// 828B395C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B3960: 48000048  b 0x828b39a8
	pc = 0x828B39A8; continue 'dispatch;
	// 828B3964: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3968: 388BB1D4  addi r4, r11, -0x4e2c
	ctx.r[4].s64 = ctx.r[11].s64 + -20012;
	// 828B396C: 4854009D  bl 0x82df3a08
	ctx.lr = 0x828B3970;
	sub_82DF3A08(ctx, base);
	// 828B3970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3974: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828B3978: 4BF38861  bl 0x827ec1d8
	ctx.lr = 0x828B397C;
	sub_827EC1D8(ctx, base);
	// 828B397C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B3980: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B3984: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3988: 485616A9  bl 0x82e15030
	ctx.lr = 0x828B398C;
	sub_82E15030(ctx, base);
	// 828B398C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B3990: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828B3994: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828B3998: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B399C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828B39A0: 4BA10AC1  bl 0x822c4460
	ctx.lr = 0x828B39A4;
	sub_822C4460(ctx, base);
	// 828B39A4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B39A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B39AC: 419A0008  beq cr6, 0x828b39b4
	if ctx.cr[6].eq {
	pc = 0x828B39B4; continue 'dispatch;
	}
	// 828B39B0: 4BA0CEE1  bl 0x822c0890
	ctx.lr = 0x828B39B4;
	sub_822C0890(ctx, base);
	// 828B39B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B39B8: 4853FA71  bl 0x82df3428
	ctx.lr = 0x828B39BC;
	sub_82DF3428(ctx, base);
	// 828B39BC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B39C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B39C4: 419A0044  beq cr6, 0x828b3a08
	if ctx.cr[6].eq {
	pc = 0x828B3A08; continue 'dispatch;
	}
	// 828B39C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B39CC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828B39D0: 3BEA6910  addi r31, r10, 0x6910
	ctx.r[31].s64 = ctx.r[10].s64 + 26896;
	// 828B39D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B39D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B39DC: 4E800421  bctrl
	ctx.lr = 0x828B39E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B39E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B39E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B39E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B39EC: 485C82DD  bl 0x82e7bcc8
	ctx.lr = 0x828B39F0;
	sub_82E7BCC8(ctx, base);
	// 828B39F0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 828B39F4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 828B39F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828B39FC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3A20 size=468
    let mut pc: u32 = 0x828B3A20;
    'dispatch: loop {
        match pc {
            0x828B3A20 => {
    //   block [0x828B3A20..0x828B3BF4)
	// 828B3A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3A28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B3A2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3A30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3A34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B3A38: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B3A3C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828B3A40: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 828B3A44: 394AEDF4  addi r10, r10, -0x120c
	ctx.r[10].s64 = ctx.r[10].s64 + -4620;
	// 828B3A48: 813E03A4  lwz r9, 0x3a4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(932 as u32) ) } as u64;
	// 828B3A4C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3A50: 1D290288  mulli r9, r9, 0x288
	ctx.r[9].s64 = ctx.r[9].s64 * 648;
	// 828B3A54: 7FE95214  add r31, r9, r10
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828B3A58: 41980184  blt cr6, 0x828b3bdc
	if ctx.cr[6].lt {
	pc = 0x828B3BDC; continue 'dispatch;
	}
	// 828B3A5C: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 828B3A60: 409900B8  ble cr6, 0x828b3b18
	if !ctx.cr[6].gt {
	pc = 0x828B3B18; continue 'dispatch;
	}
	// 828B3A64: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 828B3A68: 41990174  bgt cr6, 0x828b3bdc
	if ctx.cr[6].gt {
	pc = 0x828B3BDC; continue 'dispatch;
	}
	// 828B3A6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3A70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B3A74: 388BB1E8  addi r4, r11, -0x4e18
	ctx.r[4].s64 = ctx.r[11].s64 + -19992;
	// 828B3A78: 38A002B2  li r5, 0x2b2
	ctx.r[5].s64 = 690;
	// 828B3A7C: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828B3A80: 4853E969  bl 0x82df23e8
	ctx.lr = 0x828B3A84;
	sub_82DF23E8(ctx, base);
	// 828B3A84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B3A88: 41820028  beq 0x828b3ab0
	if ctx.cr[0].eq {
	pc = 0x828B3AB0; continue 'dispatch;
	}
	// 828B3A8C: E97F0222  lwa r11, 0x220(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as i32) as i64;
	// 828B3A90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B3A94: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B3A98: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B3A9C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 828B3AA0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828B3AA4: 480068FD  bl 0x828ba3a0
	ctx.lr = 0x828B3AA8;
	sub_828BA3A0(ctx, base);
	// 828B3AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3AAC: 48000008  b 0x828b3ab4
	pc = 0x828B3AB4; continue 'dispatch;
	// 828B3AB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B3AB4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B3AB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3ABC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3AC0: 4BFFE679  bl 0x828b2138
	ctx.lr = 0x828B3AC4;
	sub_828B2138(ctx, base);
	// 828B3AC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3AC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3ACC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3AD0: 4BA0C531  bl 0x822c0000
	ctx.lr = 0x828B3AD4;
	sub_822C0000(ctx, base);
	// 828B3AD4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B3AD8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B3ADC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B3AE0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828B3AE4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828B3AE8: 419A0024  beq cr6, 0x828b3b0c
	if ctx.cr[6].eq {
	pc = 0x828B3B0C; continue 'dispatch;
	}
	// 828B3AEC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828B3AF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B3AF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3AF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B3AFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B3B00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B3B04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3B08: 4082FFE8  bne 0x828b3af0
	if !ctx.cr[0].eq {
	pc = 0x828B3AF0; continue 'dispatch;
	}
	// 828B3B0C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828B3B10: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828B3B14: 480000AC  b 0x828b3bc0
	pc = 0x828B3BC0; continue 'dispatch;
	// 828B3B18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3B1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B3B20: 388BB1E8  addi r4, r11, -0x4e18
	ctx.r[4].s64 = ctx.r[11].s64 + -19992;
	// 828B3B24: 38A002AA  li r5, 0x2aa
	ctx.r[5].s64 = 682;
	// 828B3B28: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828B3B2C: 4853E8BD  bl 0x82df23e8
	ctx.lr = 0x828B3B30;
	sub_82DF23E8(ctx, base);
	// 828B3B30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B3B34: 41820028  beq 0x828b3b5c
	if ctx.cr[0].eq {
	pc = 0x828B3B5C; continue 'dispatch;
	}
	// 828B3B38: E97F0222  lwa r11, 0x220(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as i32) as i64;
	// 828B3B3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B3B40: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B3B44: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B3B48: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 828B3B4C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828B3B50: 48006851  bl 0x828ba3a0
	ctx.lr = 0x828B3B54;
	sub_828BA3A0(ctx, base);
	// 828B3B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3B58: 48000008  b 0x828b3b60
	pc = 0x828B3B60; continue 'dispatch;
	// 828B3B5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B3B60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B3B64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3B68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3B6C: 4BFFE5CD  bl 0x828b2138
	ctx.lr = 0x828B3B70;
	sub_828B2138(ctx, base);
	// 828B3B70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3B74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3B78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3B7C: 4BA0C485  bl 0x822c0000
	ctx.lr = 0x828B3B80;
	sub_822C0000(ctx, base);
	// 828B3B80: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B3B84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B3B88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B3B8C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828B3B90: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B3B94: 419A0024  beq cr6, 0x828b3bb8
	if ctx.cr[6].eq {
	pc = 0x828B3BB8; continue 'dispatch;
	}
	// 828B3B98: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828B3B9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B3BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3BA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B3BA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B3BAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B3BB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3BB4: 4082FFE8  bne 0x828b3b9c
	if !ctx.cr[0].eq {
	pc = 0x828B3B9C; continue 'dispatch;
	}
	// 828B3BB8: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828B3BBC: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 828B3BC0: 4BF385A1  bl 0x827ec160
	ctx.lr = 0x828B3BC4;
	sub_827EC160(ctx, base);
	// 828B3BC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B3BC8: 4BF3C0B1  bl 0x827efc78
	ctx.lr = 0x828B3BCC;
	sub_827EFC78(ctx, base);
	// 828B3BCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B3BD0: 419A000C  beq cr6, 0x828b3bdc
	if ctx.cr[6].eq {
	pc = 0x828B3BDC; continue 'dispatch;
	}
	// 828B3BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3BD8: 4BA0CCB9  bl 0x822c0890
	ctx.lr = 0x828B3BDC;
	sub_822C0890(ctx, base);
	// 828B3BDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B3BE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B3BE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3BE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B3BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3BF8 size=248
    let mut pc: u32 = 0x828B3BF8;
    'dispatch: loop {
        match pc {
            0x828B3BF8 => {
    //   block [0x828B3BF8..0x828B3CF0)
	// 828B3BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3BFC: 488F4571  bl 0x831a816c
	ctx.lr = 0x828B3C00;
	sub_831A8130(ctx, base);
	// 828B3C00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3C04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B3C08: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B3C0C: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828B3C10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B3C14: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B3C18: 815D03A4  lwz r10, 0x3a4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(932 as u32) ) } as u64;
	// 828B3C1C: 3889B1E8  addi r4, r9, -0x4e18
	ctx.r[4].s64 = ctx.r[9].s64 + -19992;
	// 828B3C20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B3C24: 38A002BD  li r5, 0x2bd
	ctx.r[5].s64 = 701;
	// 828B3C28: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828B3C2C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3C30: 1D4A0288  mulli r10, r10, 0x288
	ctx.r[10].s64 = ctx.r[10].s64 * 648;
	// 828B3C34: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B3C38: 4853E7B1  bl 0x82df23e8
	ctx.lr = 0x828B3C3C;
	sub_82DF23E8(ctx, base);
	// 828B3C3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B3C40: 41820028  beq 0x828b3c68
	if ctx.cr[0].eq {
	pc = 0x828B3C68; continue 'dispatch;
	}
	// 828B3C44: E97E0222  lwa r11, 0x220(r30)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(544 as u32) ) } as i32) as i64;
	// 828B3C48: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B3C4C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B3C50: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 828B3C54: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B3C58: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828B3C5C: 48006745  bl 0x828ba3a0
	ctx.lr = 0x828B3C60;
	sub_828BA3A0(ctx, base);
	// 828B3C60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3C64: 48000008  b 0x828b3c6c
	pc = 0x828B3C6C; continue 'dispatch;
	// 828B3C68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B3C6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B3C70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3C74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3C78: 4BFFE4C1  bl 0x828b2138
	ctx.lr = 0x828B3C7C;
	sub_828B2138(ctx, base);
	// 828B3C7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3C80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3C84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3C88: 4BA0C379  bl 0x822c0000
	ctx.lr = 0x828B3C8C;
	sub_822C0000(ctx, base);
	// 828B3C8C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B3C90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B3C94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B3C98: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B3C9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B3CA0: 419A0024  beq cr6, 0x828b3cc4
	if ctx.cr[6].eq {
	pc = 0x828B3CC4; continue 'dispatch;
	}
	// 828B3CA4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828B3CA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B3CAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3CB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B3CB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B3CB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B3CBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3CC0: 4082FFE8  bne 0x828b3ca8
	if !ctx.cr[0].eq {
	pc = 0x828B3CA8; continue 'dispatch;
	}
	// 828B3CC4: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828B3CC8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828B3CCC: 4BF38495  bl 0x827ec160
	ctx.lr = 0x828B3CD0;
	sub_827EC160(ctx, base);
	// 828B3CD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B3CD4: 4BF3BFA5  bl 0x827efc78
	ctx.lr = 0x828B3CD8;
	sub_827EFC78(ctx, base);
	// 828B3CD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B3CDC: 419A000C  beq cr6, 0x828b3ce8
	if ctx.cr[6].eq {
	pc = 0x828B3CE8; continue 'dispatch;
	}
	// 828B3CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3CE4: 4BA0CBAD  bl 0x822c0890
	ctx.lr = 0x828B3CE8;
	sub_822C0890(ctx, base);
	// 828B3CE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B3CEC: 488F44D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3CF0 size=388
    let mut pc: u32 = 0x828B3CF0;
    'dispatch: loop {
        match pc {
            0x828B3CF0 => {
    //   block [0x828B3CF0..0x828B3E74)
	// 828B3CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3CF4: 488F4475  bl 0x831a8168
	ctx.lr = 0x828B3CF8;
	sub_831A8130(ctx, base);
	// 828B3CF8: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3CFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B3D00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3D04: 3B9E00FC  addi r28, r30, 0xfc
	ctx.r[28].s64 = ctx.r[30].s64 + 252;
	// 828B3D08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B3D0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B3D10: 485A6811  bl 0x82e5a520
	ctx.lr = 0x828B3D14;
	sub_82E5A520(ctx, base);
	// 828B3D14: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3D18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B3D1C: 419A0024  beq cr6, 0x828b3d40
	if ctx.cr[6].eq {
	pc = 0x828B3D40; continue 'dispatch;
	}
	// 828B3D20: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828B3D24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B3D28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3D2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B3D30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B3D34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B3D38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3D3C: 4082FFE8  bne 0x828b3d24
	if !ctx.cr[0].eq {
	pc = 0x828B3D24; continue 'dispatch;
	}
	// 828B3D40: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B3D44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3D48: 419A0008  beq cr6, 0x828b3d50
	if ctx.cr[6].eq {
	pc = 0x828B3D50; continue 'dispatch;
	}
	// 828B3D4C: 4BA0CB45  bl 0x822c0890
	ctx.lr = 0x828B3D50;
	sub_822C0890(ctx, base);
	// 828B3D50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3D58: 388BB254  addi r4, r11, -0x4dac
	ctx.r[4].s64 = ctx.r[11].s64 + -19884;
	// 828B3D5C: 4853FCAD  bl 0x82df3a08
	ctx.lr = 0x828B3D60;
	sub_82DF3A08(ctx, base);
	// 828B3D60: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B3D64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B3D68: 3B8B7688  addi r28, r11, 0x7688
	ctx.r[28].s64 = ctx.r[11].s64 + 30344;
	// 828B3D6C: 485A6965  bl 0x82e5a6d0
	ctx.lr = 0x828B3D70;
	sub_82E5A6D0(ctx, base);
	// 828B3D70: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828B3D74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B3D78: 388B5E50  addi r4, r11, 0x5e50
	ctx.r[4].s64 = ctx.r[11].s64 + 24144;
	// 828B3D7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3D80: 4853FF21  bl 0x82df3ca0
	ctx.lr = 0x828B3D84;
	sub_82DF3CA0(ctx, base);
	// 828B3D84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B3D88: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B3D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3D90: 4853FF69  bl 0x82df3cf8
	ctx.lr = 0x828B3D94;
	sub_82DF3CF8(ctx, base);
	// 828B3D94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B3D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3D9C: 4853FB15  bl 0x82df38b0
	ctx.lr = 0x828B3DA0;
	sub_82DF38B0(ctx, base);
	// 828B3DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3DA4: 4853F685  bl 0x82df3428
	ctx.lr = 0x828B3DA8;
	sub_82DF3428(ctx, base);
	// 828B3DA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3DAC: 4853F67D  bl 0x82df3428
	ctx.lr = 0x828B3DB0;
	sub_82DF3428(ctx, base);
	// 828B3DB0: 807E0368  lwz r3, 0x368(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(872 as u32) ) } as u64;
	// 828B3DB4: 4BF364F5  bl 0x827ea2a8
	ctx.lr = 0x828B3DB8;
	sub_827EA2A8(ctx, base);
	// 828B3DB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3DBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B3DC0: 388B8FA0  addi r4, r11, -0x7060
	ctx.r[4].s64 = ctx.r[11].s64 + -28768;
	// 828B3DC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3DC8: 4853FED9  bl 0x82df3ca0
	ctx.lr = 0x828B3DCC;
	sub_82DF3CA0(ctx, base);
	// 828B3DCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B3DD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3DD4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B3DD8: 4853FF21  bl 0x82df3cf8
	ctx.lr = 0x828B3DDC;
	sub_82DF3CF8(ctx, base);
	// 828B3DDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B3DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3DE4: 4853FACD  bl 0x82df38b0
	ctx.lr = 0x828B3DE8;
	sub_82DF38B0(ctx, base);
	// 828B3DE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B3DEC: 4853F63D  bl 0x82df3428
	ctx.lr = 0x828B3DF0;
	sub_82DF3428(ctx, base);
	// 828B3DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3DF4: 4853F635  bl 0x82df3428
	ctx.lr = 0x828B3DF8;
	sub_82DF3428(ctx, base);
	// 828B3DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3DFC: 4815F885  bl 0x82a13680
	ctx.lr = 0x828B3E00;
	sub_82A13680(ctx, base);
	// 828B3E00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B3E04: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B3E08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B3E0C: 388A8F80  addi r4, r10, -0x7080
	ctx.r[4].s64 = ctx.r[10].s64 + -28800;
	// 828B3E10: C06B0008  lfs f3, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828B3E14: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B3E18: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B3E1C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 828B3E20: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 828B3E24: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 828B3E28: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 828B3E2C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 828B3E30: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 828B3E34: 488F4CA5  bl 0x831a8ad8
	ctx.lr = 0x828B3E38;
	sub_831A8AD8(ctx, base);
	// 828B3E38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B3E3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3E40: 4853FBC9  bl 0x82df3a08
	ctx.lr = 0x828B3E44;
	sub_82DF3A08(ctx, base);
	// 828B3E44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B3E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3E4C: 4853FA65  bl 0x82df38b0
	ctx.lr = 0x828B3E50;
	sub_82DF38B0(ctx, base);
	// 828B3E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3E54: 4853F5D5  bl 0x82df3428
	ctx.lr = 0x828B3E58;
	sub_82DF3428(ctx, base);
	// 828B3E58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B3E5C: 419A000C  beq cr6, 0x828b3e68
	if ctx.cr[6].eq {
	pc = 0x828B3E68; continue 'dispatch;
	}
	// 828B3E60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B3E64: 4BA0CA2D  bl 0x822c0890
	ctx.lr = 0x828B3E68;
	sub_822C0890(ctx, base);
	// 828B3E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3E6C: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 828B3E70: 488F4348  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3E78 size=80
    let mut pc: u32 = 0x828B3E78;
    'dispatch: loop {
        match pc {
            0x828B3E78 => {
    //   block [0x828B3E78..0x828B3EC8)
	// 828B3E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3E80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3E84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3E8C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828B3E90: 419A0014  beq cr6, 0x828b3ea4
	if ctx.cr[6].eq {
	pc = 0x828B3EA4; continue 'dispatch;
	}
	// 828B3E94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B3E98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B3E9C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B3EA0: 48000014  b 0x828b3eb4
	pc = 0x828B3EB4; continue 'dispatch;
	// 828B3EA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3EA8: 38ABB264  addi r5, r11, -0x4d9c
	ctx.r[5].s64 = ctx.r[11].s64 + -19868;
	// 828B3EAC: 4BC5E2CD  bl 0x82512178
	ctx.lr = 0x828B3EB0;
	sub_82512178(ctx, base);
	// 828B3EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3EB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B3EB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B3EBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3EC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3EC8 size=132
    let mut pc: u32 = 0x828B3EC8;
    'dispatch: loop {
        match pc {
            0x828B3EC8 => {
    //   block [0x828B3EC8..0x828B3F4C)
	// 828B3EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3ED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3ED4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3ED8: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 828B3EDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3EE0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B3EE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B3EEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B3EF0: 419A0024  beq cr6, 0x828b3f14
	if ctx.cr[6].eq {
	pc = 0x828B3F14; continue 'dispatch;
	}
	// 828B3EF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B3EF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B3EFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3F00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B3F04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B3F08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B3F0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B3F10: 4082FFE8  bne 0x828b3ef8
	if !ctx.cr[0].eq {
	pc = 0x828B3EF8; continue 'dispatch;
	}
	// 828B3F14: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828B3F18: 4BC5F1E1  bl 0x825130f8
	ctx.lr = 0x828B3F1C;
	sub_825130F8(ctx, base);
	// 828B3F1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B3F28: 419A000C  beq cr6, 0x828b3f34
	if ctx.cr[6].eq {
	pc = 0x828B3F34; continue 'dispatch;
	}
	// 828B3F2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B3F30: 4BA0C961  bl 0x822c0890
	ctx.lr = 0x828B3F34;
	sub_822C0890(ctx, base);
	// 828B3F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3F38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B3F3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B3F40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3F50 size=524
    let mut pc: u32 = 0x828B3F50;
    'dispatch: loop {
        match pc {
            0x828B3F50 => {
    //   block [0x828B3F50..0x828B415C)
	// 828B3F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3F54: 488F4215  bl 0x831a8168
	ctx.lr = 0x828B3F58;
	sub_831A8130(ctx, base);
	// 828B3F58: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 828B3F5C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828B3F60: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B3F64: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3F68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B3F6C: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828B3F70: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 828B3F74: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 828B3F78: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 828B3F7C: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 828B3F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3F84: 4815F6FD  bl 0x82a13680
	ctx.lr = 0x828B3F88;
	sub_82A13680(ctx, base);
	// 828B3F88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B3F8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B3F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3F94: 480556C5  bl 0x82909658
	ctx.lr = 0x828B3F98;
	sub_82909658(ctx, base);
	// 828B3F98: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B3F9C: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4160 size=112
    let mut pc: u32 = 0x828B4160;
    'dispatch: loop {
        match pc {
            0x828B4160 => {
    //   block [0x828B4160..0x828B41D0)
	// 828B4160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B4168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B416C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B4170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4174: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B4178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B417C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B4180: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B4184: 4BFFE07D  bl 0x828b2200
	ctx.lr = 0x828B4188;
	sub_828B2200(ctx, base);
	// 828B4188: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B418C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B4190: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B4194: 4BA0BE6D  bl 0x822c0000
	ctx.lr = 0x828B4198;
	sub_822C0000(ctx, base);
	// 828B4198: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B419C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B41A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B41A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B41A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B41AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B41B0: 419A0008  beq cr6, 0x828b41b8
	if ctx.cr[6].eq {
	pc = 0x828B41B8; continue 'dispatch;
	}
	// 828B41B4: 4BA0C6DD  bl 0x822c0890
	ctx.lr = 0x828B41B8;
	sub_822C0890(ctx, base);
	// 828B41B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B41BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B41C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B41C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B41C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B41CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B41D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B41D0 size=112
    let mut pc: u32 = 0x828B41D0;
    'dispatch: loop {
        match pc {
            0x828B41D0 => {
    //   block [0x828B41D0..0x828B4240)
	// 828B41D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B41D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B41D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B41DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B41E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B41E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B41E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B41EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B41F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B41F4: 4BFFE0D5  bl 0x828b22c8
	ctx.lr = 0x828B41F8;
	sub_828B22C8(ctx, base);
	// 828B41F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B41FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B4200: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B4204: 4BA0BDFD  bl 0x822c0000
	ctx.lr = 0x828B4208;
	sub_822C0000(ctx, base);
	// 828B4208: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B420C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B4210: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B4214: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B421C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B4220: 419A0008  beq cr6, 0x828b4228
	if ctx.cr[6].eq {
	pc = 0x828B4228; continue 'dispatch;
	}
	// 828B4224: 4BA0C66D  bl 0x822c0890
	ctx.lr = 0x828B4228;
	sub_822C0890(ctx, base);
	// 828B4228: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B422C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B4230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B4234: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B4238: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B423C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4240 size=112
    let mut pc: u32 = 0x828B4240;
    'dispatch: loop {
        match pc {
            0x828B4240 => {
    //   block [0x828B4240..0x828B42B0)
	// 828B4240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4244: 488F3F29  bl 0x831a816c
	ctx.lr = 0x828B4248;
	sub_831A8130(ctx, base);
	// 828B4248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B424C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4250: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4254: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4258: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B425C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4260: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828B4264: 4853E185  bl 0x82df23e8
	ctx.lr = 0x828B4268;
	sub_82DF23E8(ctx, base);
	// 828B4268: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B426C: 41820010  beq 0x828b427c
	if ctx.cr[0].eq {
	pc = 0x828B427C; continue 'dispatch;
	}
	// 828B4270: 48005E59  bl 0x828ba0c8
	ctx.lr = 0x828B4274;
	sub_828BA0C8(ctx, base);
	// 828B4274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4278: 48000008  b 0x828b4280
	pc = 0x828B4280; continue 'dispatch;
	// 828B427C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4280: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4284: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B428C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4290: 4BFFE101  bl 0x828b2390
	ctx.lr = 0x828B4294;
	sub_828B2390(ctx, base);
	// 828B4294: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4298: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B429C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B42A0: 4BA0BD61  bl 0x822c0000
	ctx.lr = 0x828B42A4;
	sub_822C0000(ctx, base);
	// 828B42A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B42A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B42AC: 488F3F10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B42B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B42B0 size=112
    let mut pc: u32 = 0x828B42B0;
    'dispatch: loop {
        match pc {
            0x828B42B0 => {
    //   block [0x828B42B0..0x828B4320)
	// 828B42B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B42B4: 488F3EB9  bl 0x831a816c
	ctx.lr = 0x828B42B8;
	sub_831A8130(ctx, base);
	// 828B42B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B42BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B42C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B42C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B42C8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B42CC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B42D0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828B42D4: 4853E115  bl 0x82df23e8
	ctx.lr = 0x828B42D8;
	sub_82DF23E8(ctx, base);
	// 828B42D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B42DC: 41820010  beq 0x828b42ec
	if ctx.cr[0].eq {
	pc = 0x828B42EC; continue 'dispatch;
	}
	// 828B42E0: 48007BB9  bl 0x828bbe98
	ctx.lr = 0x828B42E4;
	sub_828BBE98(ctx, base);
	// 828B42E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B42E8: 48000008  b 0x828b42f0
	pc = 0x828B42F0; continue 'dispatch;
	// 828B42EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B42F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B42F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B42F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B42FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4300: 4BFFE159  bl 0x828b2458
	ctx.lr = 0x828B4304;
	sub_828B2458(ctx, base);
	// 828B4304: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4308: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B430C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4310: 4BA0BCF1  bl 0x822c0000
	ctx.lr = 0x828B4314;
	sub_822C0000(ctx, base);
	// 828B4314: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4318: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B431C: 488F3EA0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4320 size=112
    let mut pc: u32 = 0x828B4320;
    'dispatch: loop {
        match pc {
            0x828B4320 => {
    //   block [0x828B4320..0x828B4390)
	// 828B4320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4324: 488F3E49  bl 0x831a816c
	ctx.lr = 0x828B4328;
	sub_831A8130(ctx, base);
	// 828B4328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B432C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4330: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4334: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4338: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B433C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4340: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828B4344: 4853E0A5  bl 0x82df23e8
	ctx.lr = 0x828B4348;
	sub_82DF23E8(ctx, base);
	// 828B4348: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B434C: 41820010  beq 0x828b435c
	if ctx.cr[0].eq {
	pc = 0x828B435C; continue 'dispatch;
	}
	// 828B4350: 48007BA9  bl 0x828bbef8
	ctx.lr = 0x828B4354;
	sub_828BBEF8(ctx, base);
	// 828B4354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4358: 48000008  b 0x828b4360
	pc = 0x828B4360; continue 'dispatch;
	// 828B435C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4360: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4364: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B436C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4370: 4BFFE1B1  bl 0x828b2520
	ctx.lr = 0x828B4374;
	sub_828B2520(ctx, base);
	// 828B4374: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4378: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B437C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4380: 4BA0BC81  bl 0x822c0000
	ctx.lr = 0x828B4384;
	sub_822C0000(ctx, base);
	// 828B4384: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4388: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B438C: 488F3E30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4390 size=112
    let mut pc: u32 = 0x828B4390;
    'dispatch: loop {
        match pc {
            0x828B4390 => {
    //   block [0x828B4390..0x828B4400)
	// 828B4390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4394: 488F3DD9  bl 0x831a816c
	ctx.lr = 0x828B4398;
	sub_831A8130(ctx, base);
	// 828B4398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B439C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B43A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B43A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B43A8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B43AC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B43B0: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 828B43B4: 4853E035  bl 0x82df23e8
	ctx.lr = 0x828B43B8;
	sub_82DF23E8(ctx, base);
	// 828B43B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B43BC: 41820010  beq 0x828b43cc
	if ctx.cr[0].eq {
	pc = 0x828B43CC; continue 'dispatch;
	}
	// 828B43C0: 48005EA1  bl 0x828ba260
	ctx.lr = 0x828B43C4;
	sub_828BA260(ctx, base);
	// 828B43C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B43C8: 48000008  b 0x828b43d0
	pc = 0x828B43D0; continue 'dispatch;
	// 828B43CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B43D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B43D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B43D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B43DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B43E0: 4BFFE209  bl 0x828b25e8
	ctx.lr = 0x828B43E4;
	sub_828B25E8(ctx, base);
	// 828B43E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B43E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B43EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B43F0: 4BA0BC11  bl 0x822c0000
	ctx.lr = 0x828B43F4;
	sub_822C0000(ctx, base);
	// 828B43F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B43F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B43FC: 488F3DC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4400 size=112
    let mut pc: u32 = 0x828B4400;
    'dispatch: loop {
        match pc {
            0x828B4400 => {
    //   block [0x828B4400..0x828B4470)
	// 828B4400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4404: 488F3D69  bl 0x831a816c
	ctx.lr = 0x828B4408;
	sub_831A8130(ctx, base);
	// 828B4408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B440C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4410: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4414: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4418: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B441C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4420: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B4424: 4853DFC5  bl 0x82df23e8
	ctx.lr = 0x828B4428;
	sub_82DF23E8(ctx, base);
	// 828B4428: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B442C: 41820010  beq 0x828b443c
	if ctx.cr[0].eq {
	pc = 0x828B443C; continue 'dispatch;
	}
	// 828B4430: 48007F61  bl 0x828bc390
	ctx.lr = 0x828B4434;
	sub_828BC390(ctx, base);
	// 828B4434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4438: 48000008  b 0x828b4440
	pc = 0x828B4440; continue 'dispatch;
	// 828B443C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4440: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4444: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4448: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B444C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4450: 4BFFE261  bl 0x828b26b0
	ctx.lr = 0x828B4454;
	sub_828B26B0(ctx, base);
	// 828B4454: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B445C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4460: 4BA0BBA1  bl 0x822c0000
	ctx.lr = 0x828B4464;
	sub_822C0000(ctx, base);
	// 828B4464: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4468: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B446C: 488F3D50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4470 size=112
    let mut pc: u32 = 0x828B4470;
    'dispatch: loop {
        match pc {
            0x828B4470 => {
    //   block [0x828B4470..0x828B44E0)
	// 828B4470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4474: 488F3CF9  bl 0x831a816c
	ctx.lr = 0x828B4478;
	sub_831A8130(ctx, base);
	// 828B4478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B447C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4480: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4484: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4488: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B448C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4490: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828B4494: 4853DF55  bl 0x82df23e8
	ctx.lr = 0x828B4498;
	sub_82DF23E8(ctx, base);
	// 828B4498: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B449C: 41820010  beq 0x828b44ac
	if ctx.cr[0].eq {
	pc = 0x828B44AC; continue 'dispatch;
	}
	// 828B44A0: 480063F9  bl 0x828ba898
	ctx.lr = 0x828B44A4;
	sub_828BA898(ctx, base);
	// 828B44A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B44A8: 48000008  b 0x828b44b0
	pc = 0x828B44B0; continue 'dispatch;
	// 828B44AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B44B0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B44B4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B44B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B44BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B44C0: 4BFFE2B9  bl 0x828b2778
	ctx.lr = 0x828B44C4;
	sub_828B2778(ctx, base);
	// 828B44C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B44C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B44CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B44D0: 4BA0BB31  bl 0x822c0000
	ctx.lr = 0x828B44D4;
	sub_822C0000(ctx, base);
	// 828B44D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B44D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B44DC: 488F3CE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B44E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B44E0 size=112
    let mut pc: u32 = 0x828B44E0;
    'dispatch: loop {
        match pc {
            0x828B44E0 => {
    //   block [0x828B44E0..0x828B4550)
	// 828B44E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B44E4: 488F3C89  bl 0x831a816c
	ctx.lr = 0x828B44E8;
	sub_831A8130(ctx, base);
	// 828B44E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B44EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B44F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B44F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B44F8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B44FC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4500: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B4504: 4853DEE5  bl 0x82df23e8
	ctx.lr = 0x828B4508;
	sub_82DF23E8(ctx, base);
	// 828B4508: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B450C: 41820010  beq 0x828b451c
	if ctx.cr[0].eq {
	pc = 0x828B451C; continue 'dispatch;
	}
	// 828B4510: 48005EF1  bl 0x828ba400
	ctx.lr = 0x828B4514;
	sub_828BA400(ctx, base);
	// 828B4514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4518: 48000008  b 0x828b4520
	pc = 0x828B4520; continue 'dispatch;
	// 828B451C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4520: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4524: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B452C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4530: 4BFFE311  bl 0x828b2840
	ctx.lr = 0x828B4534;
	sub_828B2840(ctx, base);
	// 828B4534: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B453C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4540: 4BA0BAC1  bl 0x822c0000
	ctx.lr = 0x828B4544;
	sub_822C0000(ctx, base);
	// 828B4544: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4548: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B454C: 488F3C70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4550 size=112
    let mut pc: u32 = 0x828B4550;
    'dispatch: loop {
        match pc {
            0x828B4550 => {
    //   block [0x828B4550..0x828B45C0)
	// 828B4550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4554: 488F3C19  bl 0x831a816c
	ctx.lr = 0x828B4558;
	sub_831A8130(ctx, base);
	// 828B4558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B455C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4560: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4564: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4568: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B456C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4570: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B4574: 4853DE75  bl 0x82df23e8
	ctx.lr = 0x828B4578;
	sub_82DF23E8(ctx, base);
	// 828B4578: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B457C: 41820010  beq 0x828b458c
	if ctx.cr[0].eq {
	pc = 0x828B458C; continue 'dispatch;
	}
	// 828B4580: 48006019  bl 0x828ba598
	ctx.lr = 0x828B4584;
	sub_828BA598(ctx, base);
	// 828B4584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4588: 48000008  b 0x828b4590
	pc = 0x828B4590; continue 'dispatch;
	// 828B458C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4590: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4594: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B459C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B45A0: 4BFFE369  bl 0x828b2908
	ctx.lr = 0x828B45A4;
	sub_828B2908(ctx, base);
	// 828B45A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B45A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B45AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B45B0: 4BA0BA51  bl 0x822c0000
	ctx.lr = 0x828B45B4;
	sub_822C0000(ctx, base);
	// 828B45B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B45B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B45BC: 488F3C00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B45C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B45C0 size=112
    let mut pc: u32 = 0x828B45C0;
    'dispatch: loop {
        match pc {
            0x828B45C0 => {
    //   block [0x828B45C0..0x828B4630)
	// 828B45C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B45C4: 488F3BA9  bl 0x831a816c
	ctx.lr = 0x828B45C8;
	sub_831A8130(ctx, base);
	// 828B45C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B45CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B45D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B45D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B45D8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B45DC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B45E0: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 828B45E4: 4853DE05  bl 0x82df23e8
	ctx.lr = 0x828B45E8;
	sub_82DF23E8(ctx, base);
	// 828B45E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B45EC: 41820010  beq 0x828b45fc
	if ctx.cr[0].eq {
	pc = 0x828B45FC; continue 'dispatch;
	}
	// 828B45F0: 48006141  bl 0x828ba730
	ctx.lr = 0x828B45F4;
	sub_828BA730(ctx, base);
	// 828B45F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B45F8: 48000008  b 0x828b4600
	pc = 0x828B4600; continue 'dispatch;
	// 828B45FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4600: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4604: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B460C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4610: 4BFFE3C1  bl 0x828b29d0
	ctx.lr = 0x828B4614;
	sub_828B29D0(ctx, base);
	// 828B4614: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B461C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4620: 4BA0B9E1  bl 0x822c0000
	ctx.lr = 0x828B4624;
	sub_822C0000(ctx, base);
	// 828B4624: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4628: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B462C: 488F3B90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4630 size=112
    let mut pc: u32 = 0x828B4630;
    'dispatch: loop {
        match pc {
            0x828B4630 => {
    //   block [0x828B4630..0x828B46A0)
	// 828B4630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4634: 488F3B39  bl 0x831a816c
	ctx.lr = 0x828B4638;
	sub_831A8130(ctx, base);
	// 828B4638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B463C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4640: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4644: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4648: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B464C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4650: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B4654: 4853DD95  bl 0x82df23e8
	ctx.lr = 0x828B4658;
	sub_82DF23E8(ctx, base);
	// 828B4658: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B465C: 41820010  beq 0x828b466c
	if ctx.cr[0].eq {
	pc = 0x828B466C; continue 'dispatch;
	}
	// 828B4660: 48006349  bl 0x828ba9a8
	ctx.lr = 0x828B4664;
	sub_828BA9A8(ctx, base);
	// 828B4664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4668: 48000008  b 0x828b4670
	pc = 0x828B4670; continue 'dispatch;
	// 828B466C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4670: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4674: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B467C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4680: 4BFFE419  bl 0x828b2a98
	ctx.lr = 0x828B4684;
	sub_828B2A98(ctx, base);
	// 828B4684: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B468C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4690: 4BA0B971  bl 0x822c0000
	ctx.lr = 0x828B4694;
	sub_822C0000(ctx, base);
	// 828B4694: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B469C: 488F3B20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B46A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B46A0 size=112
    let mut pc: u32 = 0x828B46A0;
    'dispatch: loop {
        match pc {
            0x828B46A0 => {
    //   block [0x828B46A0..0x828B4710)
	// 828B46A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B46A4: 488F3AC9  bl 0x831a816c
	ctx.lr = 0x828B46A8;
	sub_831A8130(ctx, base);
	// 828B46A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B46AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B46B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B46B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B46B8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B46BC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B46C0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828B46C4: 4853DD25  bl 0x82df23e8
	ctx.lr = 0x828B46C8;
	sub_82DF23E8(ctx, base);
	// 828B46C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B46CC: 41820010  beq 0x828b46dc
	if ctx.cr[0].eq {
	pc = 0x828B46DC; continue 'dispatch;
	}
	// 828B46D0: 48008591  bl 0x828bcc60
	ctx.lr = 0x828B46D4;
	sub_828BCC60(ctx, base);
	// 828B46D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B46D8: 48000008  b 0x828b46e0
	pc = 0x828B46E0; continue 'dispatch;
	// 828B46DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B46E0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B46E4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B46E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B46EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B46F0: 4BFFE471  bl 0x828b2b60
	ctx.lr = 0x828B46F4;
	sub_828B2B60(ctx, base);
	// 828B46F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B46F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B46FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4700: 4BA0B901  bl 0x822c0000
	ctx.lr = 0x828B4704;
	sub_822C0000(ctx, base);
	// 828B4704: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B470C: 488F3AB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4710 size=112
    let mut pc: u32 = 0x828B4710;
    'dispatch: loop {
        match pc {
            0x828B4710 => {
    //   block [0x828B4710..0x828B4780)
	// 828B4710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4714: 488F3A59  bl 0x831a816c
	ctx.lr = 0x828B4718;
	sub_831A8130(ctx, base);
	// 828B4718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B471C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4720: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4724: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4728: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B472C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4730: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828B4734: 4853DCB5  bl 0x82df23e8
	ctx.lr = 0x828B4738;
	sub_82DF23E8(ctx, base);
	// 828B4738: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B473C: 41820010  beq 0x828b474c
	if ctx.cr[0].eq {
	pc = 0x828B474C; continue 'dispatch;
	}
	// 828B4740: 48005AC1  bl 0x828ba200
	ctx.lr = 0x828B4744;
	sub_828BA200(ctx, base);
	// 828B4744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4748: 48000008  b 0x828b4750
	pc = 0x828B4750; continue 'dispatch;
	// 828B474C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4750: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4754: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4758: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B475C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4760: 4BFFE4C9  bl 0x828b2c28
	ctx.lr = 0x828B4764;
	sub_828B2C28(ctx, base);
	// 828B4764: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B476C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4770: 4BA0B891  bl 0x822c0000
	ctx.lr = 0x828B4774;
	sub_822C0000(ctx, base);
	// 828B4774: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4778: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B477C: 488F3A40  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4780 size=112
    let mut pc: u32 = 0x828B4780;
    'dispatch: loop {
        match pc {
            0x828B4780 => {
    //   block [0x828B4780..0x828B47F0)
	// 828B4780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4784: 488F39E9  bl 0x831a816c
	ctx.lr = 0x828B4788;
	sub_831A8130(ctx, base);
	// 828B4788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B478C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4790: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4794: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4798: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B479C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B47A0: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828B47A4: 4853DC45  bl 0x82df23e8
	ctx.lr = 0x828B47A8;
	sub_82DF23E8(ctx, base);
	// 828B47A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B47AC: 41820010  beq 0x828b47bc
	if ctx.cr[0].eq {
	pc = 0x828B47BC; continue 'dispatch;
	}
	// 828B47B0: 48007CB1  bl 0x828bc460
	ctx.lr = 0x828B47B4;
	sub_828BC460(ctx, base);
	// 828B47B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B47B8: 48000008  b 0x828b47c0
	pc = 0x828B47C0; continue 'dispatch;
	// 828B47BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B47C0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B47C4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B47C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B47CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B47D0: 4BFFE521  bl 0x828b2cf0
	ctx.lr = 0x828B47D4;
	sub_828B2CF0(ctx, base);
	// 828B47D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B47D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B47DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B47E0: 4BA0B821  bl 0x822c0000
	ctx.lr = 0x828B47E4;
	sub_822C0000(ctx, base);
	// 828B47E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B47E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B47EC: 488F39D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B47F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B47F0 size=112
    let mut pc: u32 = 0x828B47F0;
    'dispatch: loop {
        match pc {
            0x828B47F0 => {
    //   block [0x828B47F0..0x828B4860)
	// 828B47F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B47F4: 488F3979  bl 0x831a816c
	ctx.lr = 0x828B47F8;
	sub_831A8130(ctx, base);
	// 828B47F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B47FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4800: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4804: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4808: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B480C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4810: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B4814: 4853DBD5  bl 0x82df23e8
	ctx.lr = 0x828B4818;
	sub_82DF23E8(ctx, base);
	// 828B4818: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B481C: 41820010  beq 0x828b482c
	if ctx.cr[0].eq {
	pc = 0x828B482C; continue 'dispatch;
	}
	// 828B4820: 48005909  bl 0x828ba128
	ctx.lr = 0x828B4824;
	sub_828BA128(ctx, base);
	// 828B4824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4828: 48000008  b 0x828b4830
	pc = 0x828B4830; continue 'dispatch;
	// 828B482C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4830: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4834: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B483C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4840: 4BFFE579  bl 0x828b2db8
	ctx.lr = 0x828B4844;
	sub_828B2DB8(ctx, base);
	// 828B4844: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4848: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B484C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4850: 4BA0B7B1  bl 0x822c0000
	ctx.lr = 0x828B4854;
	sub_822C0000(ctx, base);
	// 828B4854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4858: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B485C: 488F3960  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4860 size=112
    let mut pc: u32 = 0x828B4860;
    'dispatch: loop {
        match pc {
            0x828B4860 => {
    //   block [0x828B4860..0x828B48D0)
	// 828B4860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4864: 488F3909  bl 0x831a816c
	ctx.lr = 0x828B4868;
	sub_831A8130(ctx, base);
	// 828B4868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B486C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4870: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4874: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4878: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B487C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4880: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 828B4884: 4853DB65  bl 0x82df23e8
	ctx.lr = 0x828B4888;
	sub_82DF23E8(ctx, base);
	// 828B4888: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B488C: 41820010  beq 0x828b489c
	if ctx.cr[0].eq {
	pc = 0x828B489C; continue 'dispatch;
	}
	// 828B4890: 48071579  bl 0x82925e08
	ctx.lr = 0x828B4894;
	sub_82925E08(ctx, base);
	// 828B4894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4898: 48000008  b 0x828b48a0
	pc = 0x828B48A0; continue 'dispatch;
	// 828B489C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B48A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B48A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B48A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B48AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B48B0: 4BFFE5D1  bl 0x828b2e80
	ctx.lr = 0x828B48B4;
	sub_828B2E80(ctx, base);
	// 828B48B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B48B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B48BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B48C0: 4BA0B741  bl 0x822c0000
	ctx.lr = 0x828B48C4;
	sub_822C0000(ctx, base);
	// 828B48C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B48C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B48CC: 488F38F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B48D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B48D0 size=112
    let mut pc: u32 = 0x828B48D0;
    'dispatch: loop {
        match pc {
            0x828B48D0 => {
    //   block [0x828B48D0..0x828B4940)
	// 828B48D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B48D4: 488F3899  bl 0x831a816c
	ctx.lr = 0x828B48D8;
	sub_831A8130(ctx, base);
	// 828B48D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B48DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B48E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B48E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B48E8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B48EC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B48F0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B48F4: 4853DAF5  bl 0x82df23e8
	ctx.lr = 0x828B48F8;
	sub_82DF23E8(ctx, base);
	// 828B48F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B48FC: 41820010  beq 0x828b490c
	if ctx.cr[0].eq {
	pc = 0x828B490C; continue 'dispatch;
	}
	// 828B4900: 48072B89  bl 0x82927488
	ctx.lr = 0x828B4904;
	sub_82927488(ctx, base);
	// 828B4904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4908: 48000008  b 0x828b4910
	pc = 0x828B4910; continue 'dispatch;
	// 828B490C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4910: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4914: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B491C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4920: 4BFFE629  bl 0x828b2f48
	ctx.lr = 0x828B4924;
	sub_828B2F48(ctx, base);
	// 828B4924: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B492C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4930: 4BA0B6D1  bl 0x822c0000
	ctx.lr = 0x828B4934;
	sub_822C0000(ctx, base);
	// 828B4934: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B493C: 488F3880  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4940 size=112
    let mut pc: u32 = 0x828B4940;
    'dispatch: loop {
        match pc {
            0x828B4940 => {
    //   block [0x828B4940..0x828B49B0)
	// 828B4940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4944: 488F3829  bl 0x831a816c
	ctx.lr = 0x828B4948;
	sub_831A8130(ctx, base);
	// 828B4948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B494C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B4950: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B4954: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4958: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B495C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B4960: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B4964: 4853DA85  bl 0x82df23e8
	ctx.lr = 0x828B4968;
	sub_82DF23E8(ctx, base);
	// 828B4968: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B496C: 41820010  beq 0x828b497c
	if ctx.cr[0].eq {
	pc = 0x828B497C; continue 'dispatch;
	}
	// 828B4970: 48072869  bl 0x829271d8
	ctx.lr = 0x828B4974;
	sub_829271D8(ctx, base);
	// 828B4974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4978: 48000008  b 0x828b4980
	pc = 0x828B4980; continue 'dispatch;
	// 828B497C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B4980: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B4984: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B4988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B498C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4990: 4BFFE681  bl 0x828b3010
	ctx.lr = 0x828B4994;
	sub_828B3010(ctx, base);
	// 828B4994: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B4998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B499C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B49A0: 4BA0B661  bl 0x822c0000
	ctx.lr = 0x828B49A4;
	sub_822C0000(ctx, base);
	// 828B49A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B49A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B49AC: 488F3810  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B49B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B49B0 size=208
    let mut pc: u32 = 0x828B49B0;
    'dispatch: loop {
        match pc {
            0x828B49B0 => {
    //   block [0x828B49B0..0x828B4A80)
	// 828B49B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B49B4: 488F37B9  bl 0x831a816c
	ctx.lr = 0x828B49B8;
	sub_831A8130(ctx, base);
	// 828B49B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B49BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B49C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B49C4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828B49C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B49CC: 4BC53CB5  bl 0x82508680
	ctx.lr = 0x828B49D0;
	sub_82508680(ctx, base);
	// 828B49D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B49D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B49D8: 4BFC1D51  bl 0x82876728
	ctx.lr = 0x828B49DC;
	sub_82876728(ctx, base);
	// 828B49DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B49E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B49E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B49E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B49EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B49F0: 419A0024  beq cr6, 0x828b4a14
	if ctx.cr[6].eq {
	pc = 0x828B4A14; continue 'dispatch;
	}
	// 828B49F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B49F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B49FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B4A00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B4A04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B4A08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B4A0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B4A10: 4082FFE8  bne 0x828b49f8
	if !ctx.cr[0].eq {
	pc = 0x828B49F8; continue 'dispatch;
	}
	// 828B4A14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B4A18: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B4A1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828B4A20: 388AB1E8  addi r4, r10, -0x4e18
	ctx.r[4].s64 = ctx.r[10].s64 + -19992;
	// 828B4A24: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828B4A28: 38A001B8  li r5, 0x1b8
	ctx.r[5].s64 = 440;
	// 828B4A2C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B4A30: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828B4A34: 485A400D  bl 0x82e58a40
	ctx.lr = 0x828B4A38;
	sub_82E58A40(ctx, base);
	// 828B4A38: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B4A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4A40: 419A0008  beq cr6, 0x828b4a48
	if ctx.cr[6].eq {
	pc = 0x828B4A48; continue 'dispatch;
	}
	// 828B4A44: 4BA0BE4D  bl 0x822c0890
	ctx.lr = 0x828B4A48;
	sub_822C0890(ctx, base);
	// 828B4A48: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B4A4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4A50: 419A0008  beq cr6, 0x828b4a58
	if ctx.cr[6].eq {
	pc = 0x828B4A58; continue 'dispatch;
	}
	// 828B4A54: 4BA0BE3D  bl 0x822c0890
	ctx.lr = 0x828B4A58;
	sub_822C0890(ctx, base);
	// 828B4A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4A5C: 4BF376C5  bl 0x827ec120
	ctx.lr = 0x828B4A60;
	sub_827EC120(ctx, base);
	// 828B4A60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B4A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4A68: 480596C9  bl 0x8290e130
	ctx.lr = 0x828B4A6C;
	sub_8290E130(ctx, base);
	// 828B4A6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B4A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4A74: 4805C70D  bl 0x82911180
	ctx.lr = 0x828B4A78;
	sub_82911180(ctx, base);
	// 828B4A78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B4A7C: 488F3740  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B4A80 size=172
    let mut pc: u32 = 0x828B4A80;
    'dispatch: loop {
        match pc {
            0x828B4A80 => {
    //   block [0x828B4A80..0x828B4B2C)
	// 828B4A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B4A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B4A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B4A90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4A98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B4A9C: 817F03A4  lwz r11, 0x3a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 828B4AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B4AA4: 419A0070  beq cr6, 0x828b4b14
	if ctx.cr[6].eq {
	pc = 0x828B4B14; continue 'dispatch;
	}
	// 828B4AA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B4AAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B4AB0: 388B12B0  addi r4, r11, 0x12b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4784;
	// 828B4AB4: 4853EF55  bl 0x82df3a08
	ctx.lr = 0x828B4AB8;
	sub_82DF3A08(ctx, base);
	// 828B4AB8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828B4ABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4AC0: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828B4AC4: 4853EF45  bl 0x82df3a08
	ctx.lr = 0x828B4AC8;
	sub_82DF3A08(ctx, base);
	// 828B4AC8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B4ACC: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 828B4AD0: 80BF03A4  lwz r5, 0x3a4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 828B4AD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4AD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B4ADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B4AE0: 4BCF90B1  bl 0x825adb90
	ctx.lr = 0x828B4AE4;
	sub_825ADB90(ctx, base);
	// 828B4AE4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B4AE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B4AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B4AF0: 4BCED2C9  bl 0x825a1db8
	ctx.lr = 0x828B4AF4;
	sub_825A1DB8(ctx, base);
	// 828B4AF4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828B4AF8: 4853E931  bl 0x82df3428
	ctx.lr = 0x828B4AFC;
	sub_82DF3428(ctx, base);
	// 828B4AFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B4B00: 4BA141B9  bl 0x822c8cb8
	ctx.lr = 0x828B4B04;
	sub_822C8CB8(ctx, base);
	// 828B4B04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4B08: 4853E921  bl 0x82df3428
	ctx.lr = 0x828B4B0C;
	sub_82DF3428(ctx, base);
	// 828B4B0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B4B10: 4853E919  bl 0x82df3428
	ctx.lr = 0x828B4B14;
	sub_82DF3428(ctx, base);
	// 828B4B14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828B4B18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B4B1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B4B20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B4B24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B4B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B4B30 size=880
    let mut pc: u32 = 0x828B4B30;
    'dispatch: loop {
        match pc {
            0x828B4B30 => {
    //   block [0x828B4B30..0x828B4EA0)
	// 828B4B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4B34: 488F3629  bl 0x831a815c
	ctx.lr = 0x828B4B38;
	sub_831A8130(ctx, base);
	// 828B4B38: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828B4B3C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828B4B40: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4B44: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B4B48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B4B4C: 3B3B0038  addi r25, r27, 0x38
	ctx.r[25].s64 = ctx.r[27].s64 + 56;
	// 828B4B50: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B4B54: 48754465  bl 0x83008fb8
	ctx.lr = 0x828B4B58;
	sub_83008FB8(ctx, base);
	// 828B4B58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4B5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4B60: 487535C9  bl 0x83008128
	ctx.lr = 0x828B4B64;
	sub_83008128(ctx, base);
	// 828B4B64: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B4B68: 419A0328  beq cr6, 0x828b4e90
	if ctx.cr[6].eq {
	pc = 0x828B4E90; continue 'dispatch;
	}
	// 828B4B6C: 807B0370  lwz r3, 0x370(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(880 as u32) ) } as u64;
	// 828B4B70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4B74: 419A031C  beq cr6, 0x828b4e90
	if ctx.cr[6].eq {
	pc = 0x828B4E90; continue 'dispatch;
	}
	// 828B4B78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B4B7C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4B80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B4B84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B4B88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4B8C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B4B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B4B94: 4E800421  bctrl
	ctx.lr = 0x828B4B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4B98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B4B9C: 418202F4  beq 0x828b4e90
	if ctx.cr[0].eq {
	pc = 0x828B4E90; continue 'dispatch;
	}
	// 828B4BA0: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828B4BA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4BA8: 809A0B2C  lwz r4, 0xb2c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828B4BAC: 4853EE5D  bl 0x82df3a08
	ctx.lr = 0x828B4BB0;
	sub_82DF3A08(ctx, base);
	// 828B4BB0: 3B9B010C  addi r28, r27, 0x10c
	ctx.r[28].s64 = ctx.r[27].s64 + 268;
	// 828B4BB4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828B4BB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B4BBC: 485A5B15  bl 0x82e5a6d0
	ctx.lr = 0x828B4BC0;
	sub_82E5A6D0(ctx, base);
	// 828B4BC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B4BC4: 4853E6DD  bl 0x82df32a0
	ctx.lr = 0x828B4BC8;
	sub_82DF32A0(ctx, base);
	// 828B4BC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4BCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4BD0: 4853E859  bl 0x82df3428
	ctx.lr = 0x828B4BD4;
	sub_82DF3428(ctx, base);
	// 828B4BD4: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B4BD8: 418202B8  beq 0x828b4e90
	if ctx.cr[0].eq {
	pc = 0x828B4E90; continue 'dispatch;
	}
	// 828B4BDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B4BE0: 83FB0380  lwz r31, 0x380(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(896 as u32) ) } as u64;
	// 828B4BE4: 485A5AED  bl 0x82e5a6d0
	ctx.lr = 0x828B4BE8;
	sub_82E5A6D0(ctx, base);
	// 828B4BE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B4BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4BF0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B4BF4: 4806D49D  bl 0x82922090
	ctx.lr = 0x828B4BF8;
	sub_82922090(ctx, base);
	// 828B4BF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B4BFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B4C00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B4C04: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B4C08: C3CAD5B8  lfs f30, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B4C0C: 418201DC  beq 0x828b4de8
	if ctx.cr[0].eq {
	pc = 0x828B4DE8; continue 'dispatch;
	}
	// 828B4C10: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828B4C14: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B4C18: 814A85E4  lwz r10, -0x7a1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31260 as u32) ) } as u64;
	// 828B4C1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B4C20: 419A0014  beq cr6, 0x828b4c34
	if ctx.cr[6].eq {
	pc = 0x828B4C34; continue 'dispatch;
	}
	// 828B4C24: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828B4C28: 814A85E8  lwz r10, -0x7a18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31256 as u32) ) } as u64;
	// 828B4C2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B4C30: 409A0010  bne cr6, 0x828b4c40
	if !ctx.cr[6].eq {
	pc = 0x828B4C40; continue 'dispatch;
	}
	// 828B4C34: 387B0010  addi r3, r27, 0x10
	ctx.r[3].s64 = ctx.r[27].s64 + 16;
	// 828B4C38: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B4C3C: 4BC5D02D  bl 0x82511c68
	ctx.lr = 0x828B4C40;
	sub_82511C68(ctx, base);
	// 828B4C40: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828B4C44: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B4C48: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828B4C4C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4C50: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4C54: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828B4C58: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828B4C5C: 41820014  beq 0x828b4c70
	if ctx.cr[0].eq {
	pc = 0x828B4C70; continue 'dispatch;
	}
	// 828B4C60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B4C64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B4C68: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B4C6C: 419AFFE0  beq cr6, 0x828b4c4c
	if ctx.cr[6].eq {
	pc = 0x828B4C4C; continue 'dispatch;
	}
	// 828B4C70: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B4C74: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 828B4C78: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828B4C7C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4C80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B4C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4C88: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B4C8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B4C90: 4082007C  bne 0x828b4d0c
	if !ctx.cr[0].eq {
	pc = 0x828B4D0C; continue 'dispatch;
	}
	// 828B4C94: 4E800421  bctrl
	ctx.lr = 0x828B4C98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4C9C: 480541BD  bl 0x82908e58
	ctx.lr = 0x828B4CA0;
	sub_82908E58(ctx, base);
	// 828B4CA0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828B4CA4: 41990144  bgt cr6, 0x828b4de8
	if ctx.cr[6].gt {
	pc = 0x828B4DE8; continue 'dispatch;
	}
	// 828B4CA8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B4CAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4CB0: 808B25A0  lwz r4, 0x25a0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9632 as u32) ) } as u64;
	// 828B4CB4: 4853ED55  bl 0x82df3a08
	ctx.lr = 0x828B4CB8;
	sub_82DF3A08(ctx, base);
	// 828B4CB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4CBC: 4BF374A5  bl 0x827ec160
	ctx.lr = 0x828B4CC0;
	sub_827EC160(ctx, base);
	// 828B4CC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4CC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B4CC8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B4CCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B4CD0: 4E800421  bctrl
	ctx.lr = 0x828B4CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4CD8: 4853E751  bl 0x82df3428
	ctx.lr = 0x828B4CDC;
	sub_82DF3428(ctx, base);
	// 828B4CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B4CE0: 809A0B2C  lwz r4, 0xb2c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828B4CE4: 4853ED25  bl 0x82df3a08
	ctx.lr = 0x828B4CE8;
	sub_82DF3A08(ctx, base);
	// 828B4CE8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B4CEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4CF0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B4CF4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B4CF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B4CFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B4D00: 485A9C61  bl 0x82e5e960
	ctx.lr = 0x828B4D04;
	sub_82E5E960(ctx, base);
	// 828B4D04: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B4D08: 480000D4  b 0x828b4ddc
	pc = 0x828B4DDC; continue 'dispatch;
	// 828B4D0C: 4E800421  bctrl
	ctx.lr = 0x828B4D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4D10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B4D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4D18: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B4D1C: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B4D20: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B4D24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B4D28: 4E800421  bctrl
	ctx.lr = 0x828B4D2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4D2C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 828B4D30: 40980034  bge cr6, 0x828b4d64
	if !ctx.cr[6].lt {
	pc = 0x828B4D64; continue 'dispatch;
	}
	// 828B4D34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4D38: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B4D3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B4D40: 38AAB27C  addi r5, r10, -0x4d84
	ctx.r[5].s64 = ctx.r[10].s64 + -19844;
	// 828B4D44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B4D48: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828B4D4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B4D50: 4E800421  bctrl
	ctx.lr = 0x828B4D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4D54: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B4D58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4D5C: 419A0008  beq cr6, 0x828b4d64
	if ctx.cr[6].eq {
	pc = 0x828B4D64; continue 'dispatch;
	}
	// 828B4D60: 4BA0BB31  bl 0x822c0890
	ctx.lr = 0x828B4D64;
	sub_822C0890(ctx, base);
	// 828B4D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B4D68: 4BF373F9  bl 0x827ec160
	ctx.lr = 0x828B4D6C;
	sub_827EC160(ctx, base);
	// 828B4D6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B4D70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B4D74: 48062025  bl 0x82916d98
	ctx.lr = 0x828B4D78;
	sub_82916D98(ctx, base);
	// 828B4D78: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828B4D7C: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B4D80: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828B4D84: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828B4D88: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828B4D8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B4D90: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B4D94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B4EA0 size=1536
    let mut pc: u32 = 0x828B4EA0;
    'dispatch: loop {
        match pc {
            0x828B4EA0 => {
    //   block [0x828B4EA0..0x828B54A0)
	// 828B4EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4EA4: 488F32BD  bl 0x831a8160
	ctx.lr = 0x828B4EA8;
	sub_831A8130(ctx, base);
	// 828B4EA8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828B4EAC: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4EB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B4EB4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828B4EB8: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828B4EBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4EC0: 419A05D4  beq cr6, 0x828b5494
	if ctx.cr[6].eq {
	pc = 0x828B5494; continue 'dispatch;
	}
	// 828B4EC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B4EC8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 828B4ECC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828B4ED0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4ED4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B4ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B4EDC: 4E800421  bctrl
	ctx.lr = 0x828B4EE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B4EE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B4EE4: 418205B0  beq 0x828b5494
	if ctx.cr[0].eq {
	pc = 0x828B5494; continue 'dispatch;
	}
	// 828B4EE8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828B4EEC: 895B001C  lbz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B4EF0: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 828B4EF4: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 828B4EF8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B4EFC: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B54A0 size=564
    let mut pc: u32 = 0x828B54A0;
    'dispatch: loop {
        match pc {
            0x828B54A0 => {
    //   block [0x828B54A0..0x828B56D4)
	// 828B54A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B54A4: 488F2CAD  bl 0x831a8150
	ctx.lr = 0x828B54A8;
	sub_831A8130(ctx, base);
	// 828B54A8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B54AC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B54B0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828B54B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B54B8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828B54BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B54C0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828B54C4: 409A0008  bne cr6, 0x828b54cc
	if !ctx.cr[6].eq {
	pc = 0x828B54CC; continue 'dispatch;
	}
	// 828B54C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B54CC: 4BC72BBD  bl 0x82528088
	ctx.lr = 0x828B54D0;
	sub_82528088(ctx, base);
	// 828B54D0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B54D4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828B54D8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828B54DC: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 828B54E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B54E4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B54E8: 485EB249  bl 0x82ea0730
	ctx.lr = 0x828B54EC;
	sub_82EA0730(ctx, base);
	// 828B54EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B54F0: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 828B54F4: 396BB2A0  addi r11, r11, -0x4d60
	ctx.r[11].s64 = ctx.r[11].s64 + -19808;
	// 828B54F8: 394A4BC0  addi r10, r10, 0x4bc0
	ctx.r[10].s64 = ctx.r[10].s64 + 19392;
	// 828B54FC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828B5500: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828B5504: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 828B5508: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B550C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 828B5510: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B5514: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828B56D8 size=44
    let mut pc: u32 = 0x828B56D8;
    'dispatch: loop {
        match pc {
            0x828B56D8 => {
    //   block [0x828B56D8..0x828B5704)
	// 828B56D8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B56DC: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B56E0: C0690014  lfs f3, 0x14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828B56E4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B56E8: C0490010  lfs f2, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B56EC: 80E90018  lwz r7, 0x18(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B56F0: C029000C  lfs f1, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B56F4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B56F8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B56FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828B5700: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5708 size=72
    let mut pc: u32 = 0x828B5708;
    'dispatch: loop {
        match pc {
            0x828B5708 => {
    //   block [0x828B5708..0x828B5750)
	// 828B5708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B570C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5710: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5714: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828B5718: 419A001C  beq cr6, 0x828b5734
	if ctx.cr[6].eq {
	pc = 0x828B5734; continue 'dispatch;
	}
	// 828B571C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B5720: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B5724: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B5728: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B572C: 4BFFDF8D  bl 0x828b36b8
	ctx.lr = 0x828B5730;
	sub_828B36B8(ctx, base);
	// 828B5730: 48000010  b 0x828b5740
	pc = 0x828B5740; continue 'dispatch;
	// 828B5734: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B5738: 396B2288  addi r11, r11, 0x2288
	ctx.r[11].s64 = ctx.r[11].s64 + 8840;
	// 828B573C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B5740: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B5744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B574C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5750 size=64
    let mut pc: u32 = 0x828B5750;
    'dispatch: loop {
        match pc {
            0x828B5750 => {
    //   block [0x828B5750..0x828B5790)
	// 828B5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5758: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B575C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B5760: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5764: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B5768: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B576C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B5770: 38650008  addi r3, r5, 8
	ctx.r[3].s64 = ctx.r[5].s64 + 8;
	// 828B5774: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B5778: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B577C: 4BFFE09D  bl 0x828b3818
	ctx.lr = 0x828B5780;
	sub_828B3818(ctx, base);
	// 828B5780: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B5784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B578C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5790 size=72
    let mut pc: u32 = 0x828B5790;
    'dispatch: loop {
        match pc {
            0x828B5790 => {
    //   block [0x828B5790..0x828B57D8)
	// 828B5790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5798: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B579C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828B57A0: 419A001C  beq cr6, 0x828b57bc
	if ctx.cr[6].eq {
	pc = 0x828B57BC; continue 'dispatch;
	}
	// 828B57A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B57A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B57AC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B57B0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B57B4: 4BFFDFB5  bl 0x828b3768
	ctx.lr = 0x828B57B8;
	sub_828B3768(ctx, base);
	// 828B57B8: 48000010  b 0x828b57c8
	pc = 0x828B57C8; continue 'dispatch;
	// 828B57BC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B57C0: 396B2360  addi r11, r11, 0x2360
	ctx.r[11].s64 = ctx.r[11].s64 + 9056;
	// 828B57C4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B57C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B57CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B57D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B57D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B57D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B57D8 size=252
    let mut pc: u32 = 0x828B57D8;
    'dispatch: loop {
        match pc {
            0x828B57D8 => {
    //   block [0x828B57D8..0x828B58D4)
	// 828B57D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B57DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B57E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B57E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B57E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B57EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B57F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B57F4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828B57F8: 396BB48C  addi r11, r11, -0x4b74
	ctx.r[11].s64 = ctx.r[11].s64 + -19316;
	// 828B57FC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B5800: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828B5804: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B5808: 394AB2CC  addi r10, r10, -0x4d34
	ctx.r[10].s64 = ctx.r[10].s64 + -19764;
	// 828B580C: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 828B5810: 3929B2B4  addi r9, r9, -0x4d4c
	ctx.r[9].s64 = ctx.r[9].s64 + -19788;
	// 828B5814: 3968B470  addi r11, r8, -0x4b90
	ctx.r[11].s64 = ctx.r[8].s64 + -19344;
	// 828B5818: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828B581C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828B5820: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828B5824: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828B5828: 4BA0AA41  bl 0x822c0268
	ctx.lr = 0x828B582C;
	sub_822C0268(ctx, base);
	// 828B582C: 387F03A8  addi r3, r31, 0x3a8
	ctx.r[3].s64 = ctx.r[31].s64 + 936;
	// 828B5830: 4BB72E51  bl 0x82428680
	ctx.lr = 0x828B5834;
	sub_82428680(ctx, base);
	// 828B5834: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828B5838: 809F03AC  lwz r4, 0x3ac(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) } as u64;
	// 828B583C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 828B5840: 4853C949  bl 0x82df2188
	ctx.lr = 0x828B5844;
	sub_82DF2188(ctx, base);
	// 828B5844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5848: 917F03AC  stw r11, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[11].u32 ) };
	// 828B584C: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 828B5850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5854: 419A0008  beq cr6, 0x828b585c
	if ctx.cr[6].eq {
	pc = 0x828B585C; continue 'dispatch;
	}
	// 828B5858: 4BA0B039  bl 0x822c0890
	ctx.lr = 0x828B585C;
	sub_822C0890(ctx, base);
	// 828B585C: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B5860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5864: 419A0008  beq cr6, 0x828b586c
	if ctx.cr[6].eq {
	pc = 0x828B586C; continue 'dispatch;
	}
	// 828B5868: 4BA0B029  bl 0x822c0890
	ctx.lr = 0x828B586C;
	sub_822C0890(ctx, base);
	// 828B586C: 807F038C  lwz r3, 0x38c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828B5870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5874: 419A0008  beq cr6, 0x828b587c
	if ctx.cr[6].eq {
	pc = 0x828B587C; continue 'dispatch;
	}
	// 828B5878: 4BA0B019  bl 0x822c0890
	ctx.lr = 0x828B587C;
	sub_822C0890(ctx, base);
	// 828B587C: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 828B5880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5884: 419A0008  beq cr6, 0x828b588c
	if ctx.cr[6].eq {
	pc = 0x828B588C; continue 'dispatch;
	}
	// 828B5888: 4BA0B009  bl 0x822c0890
	ctx.lr = 0x828B588C;
	sub_822C0890(ctx, base);
	// 828B588C: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828B5890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5894: 419A0008  beq cr6, 0x828b589c
	if ctx.cr[6].eq {
	pc = 0x828B589C; continue 'dispatch;
	}
	// 828B5898: 4BA0AFF9  bl 0x822c0890
	ctx.lr = 0x828B589C;
	sub_822C0890(ctx, base);
	// 828B589C: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 828B58A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B58A4: 419A0008  beq cr6, 0x828b58ac
	if ctx.cr[6].eq {
	pc = 0x828B58AC; continue 'dispatch;
	}
	// 828B58A8: 4BA0AFE9  bl 0x822c0890
	ctx.lr = 0x828B58AC;
	sub_822C0890(ctx, base);
	// 828B58AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B58B0: 4805B3E1  bl 0x82910c90
	ctx.lr = 0x828B58B4;
	sub_82910C90(ctx, base);
	// 828B58B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B58B8: 4BEF1DA1  bl 0x827a7658
	ctx.lr = 0x828B58BC;
	sub_827A7658(ctx, base);
	// 828B58BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B58C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B58C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B58C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B58CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B58D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B58D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B58D8 size=8
    let mut pc: u32 = 0x828B58D8;
    'dispatch: loop {
        match pc {
            0x828B58D8 => {
    //   block [0x828B58D8..0x828B58E0)
	// 828B58D8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828B58DC: 480002BC  b 0x828b5b98
	sub_828B5B98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B58E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B58E0 size=8
    let mut pc: u32 = 0x828B58E0;
    'dispatch: loop {
        match pc {
            0x828B58E0 => {
    //   block [0x828B58E0..0x828B58E8)
	// 828B58E0: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828B58E4: 480002B4  b 0x828b5b98
	sub_828B5B98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B58E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B58E8 size=8
    let mut pc: u32 = 0x828B58E8;
    'dispatch: loop {
        match pc {
            0x828B58E8 => {
    //   block [0x828B58E8..0x828B58F0)
	// 828B58E8: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828B58EC: 480002AC  b 0x828b5b98
	sub_828B5B98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B58F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B58F0 size=64
    let mut pc: u32 = 0x828B58F0;
    'dispatch: loop {
        match pc {
            0x828B58F0 => {
    //   block [0x828B58F0..0x828B5930)
	// 828B58F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B58F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B58F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B58FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5904: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B5908: 48752821  bl 0x83008128
	ctx.lr = 0x828B590C;
	sub_83008128(ctx, base);
	// 828B590C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828B5910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B5914: 387F03A8  addi r3, r31, 0x3a8
	ctx.r[3].s64 = ctx.r[31].s64 + 936;
	// 828B5918: 4BBB1121  bl 0x82466a38
	ctx.lr = 0x828B591C;
	sub_82466A38(ctx, base);
	// 828B591C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B592C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5930 size=612
    let mut pc: u32 = 0x828B5930;
    'dispatch: loop {
        match pc {
            0x828B5930 => {
    //   block [0x828B5930..0x828B5B94)
	// 828B5930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5934: 488F2835  bl 0x831a8168
	ctx.lr = 0x828B5938;
	sub_831A8130(ctx, base);
	// 828B5938: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B593C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828B5940: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B5944: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B5948: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828B594C: 41820038  beq 0x828b5984
	if ctx.cr[0].eq {
	pc = 0x828B5984; continue 'dispatch;
	}
	// 828B5950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5954: 488F4035  bl 0x831a9988
	ctx.lr = 0x828B5958;
	sub_831A9988(ctx, base);
	// 828B5958: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828B595C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5960: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828B5964: 488F2795  bl 0x831a80f8
	ctx.lr = 0x828B5968;
	sub_831A80F8(ctx, base);
	// 828B5968: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B596C: 41820018  beq 0x828b5984
	if ctx.cr[0].eq {
	pc = 0x828B5984; continue 'dispatch;
	}
	// 828B5970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5974: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5978: 481DEEA1  bl 0x82a94818
	ctx.lr = 0x828B597C;
	sub_82A94818(ctx, base);
	// 828B597C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B5980: 4800020C  b 0x828b5b8c
	pc = 0x828B5B8C; continue 'dispatch;
	// 828B5984: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5988: 419A01F4  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B598C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5990: 488F3FF9  bl 0x831a9988
	ctx.lr = 0x828B5994;
	sub_831A9988(ctx, base);
	// 828B5994: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828B5998: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B599C: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828B59A0: 488F2759  bl 0x831a80f8
	ctx.lr = 0x828B59A4;
	sub_831A80F8(ctx, base);
	// 828B59A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B59A8: 41820014  beq 0x828b59bc
	if ctx.cr[0].eq {
	pc = 0x828B59BC; continue 'dispatch;
	}
	// 828B59AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B59B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828B59B4: 4802452D  bl 0x828d9ee0
	ctx.lr = 0x828B59B8;
	sub_828D9EE0(ctx, base);
	// 828B59B8: 4BFFFFC4  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B59BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B59C0: 419A01BC  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B59C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B59C8: 488F3FC1  bl 0x831a9988
	ctx.lr = 0x828B59CC;
	sub_831A9988(ctx, base);
	// 828B59CC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B59D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B59D4: 386BD5B0  addi r3, r11, -0x2a50
	ctx.r[3].s64 = ctx.r[11].s64 + -10832;
	// 828B59D8: 488F2721  bl 0x831a80f8
	ctx.lr = 0x828B59DC;
	sub_831A80F8(ctx, base);
	// 828B59DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B59E0: 41820014  beq 0x828b59f4
	if ctx.cr[0].eq {
	pc = 0x828B59F4; continue 'dispatch;
	}
	// 828B59E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B59E8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B59EC: 4BDABD0D  bl 0x826616f8
	ctx.lr = 0x828B59F0;
	sub_826616F8(ctx, base);
	// 828B59F0: 4BFFFF8C  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B59F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B59F8: 419A0184  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B59FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5A00: 488F3F89  bl 0x831a9988
	ctx.lr = 0x828B5A04;
	sub_831A9988(ctx, base);
	// 828B5A04: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B5A08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5A0C: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828B5A10: 488F26E9  bl 0x831a80f8
	ctx.lr = 0x828B5A14;
	sub_831A80F8(ctx, base);
	// 828B5A14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5A18: 41820014  beq 0x828b5a2c
	if ctx.cr[0].eq {
	pc = 0x828B5A2C; continue 'dispatch;
	}
	// 828B5A1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5A20: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5A24: 4BF3559D  bl 0x827eafc0
	ctx.lr = 0x828B5A28;
	sub_827EAFC0(ctx, base);
	// 828B5A28: 4BFFFF54  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5A2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5A30: 419A014C  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5A38: 488F3F51  bl 0x831a9988
	ctx.lr = 0x828B5A3C;
	sub_831A9988(ctx, base);
	// 828B5A3C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828B5A40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5A44: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828B5A48: 488F26B1  bl 0x831a80f8
	ctx.lr = 0x828B5A4C;
	sub_831A80F8(ctx, base);
	// 828B5A4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5A50: 41820014  beq 0x828b5a64
	if ctx.cr[0].eq {
	pc = 0x828B5A64; continue 'dispatch;
	}
	// 828B5A54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5A58: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5A5C: 480191CD  bl 0x828cec28
	ctx.lr = 0x828B5A60;
	sub_828CEC28(ctx, base);
	// 828B5A60: 4BFFFF1C  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5A64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5A68: 419A0114  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5A70: 488F3F19  bl 0x831a9988
	ctx.lr = 0x828B5A74;
	sub_831A9988(ctx, base);
	// 828B5A74: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B5A78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5A7C: 386B24B8  addi r3, r11, 0x24b8
	ctx.r[3].s64 = ctx.r[11].s64 + 9400;
	// 828B5A80: 488F2679  bl 0x831a80f8
	ctx.lr = 0x828B5A84;
	sub_831A80F8(ctx, base);
	// 828B5A84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5A88: 41820014  beq 0x828b5a9c
	if ctx.cr[0].eq {
	pc = 0x828B5A9C; continue 'dispatch;
	}
	// 828B5A8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5A90: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5A94: 4BFFDF8D  bl 0x828b3a20
	ctx.lr = 0x828B5A98;
	sub_828B3A20(ctx, base);
	// 828B5A98: 4BFFFEE4  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5A9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5AA0: 419A00DC  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5AA8: 488F3EE1  bl 0x831a9988
	ctx.lr = 0x828B5AAC;
	sub_831A9988(ctx, base);
	// 828B5AAC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B5AB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5AB4: 386B2490  addi r3, r11, 0x2490
	ctx.r[3].s64 = ctx.r[11].s64 + 9360;
	// 828B5AB8: 488F2641  bl 0x831a80f8
	ctx.lr = 0x828B5ABC;
	sub_831A80F8(ctx, base);
	// 828B5ABC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5AC0: 41820014  beq 0x828b5ad4
	if ctx.cr[0].eq {
	pc = 0x828B5AD4; continue 'dispatch;
	}
	// 828B5AC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5AC8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5ACC: 4BFFE12D  bl 0x828b3bf8
	ctx.lr = 0x828B5AD0;
	sub_828B3BF8(ctx, base);
	// 828B5AD0: 4BFFFEAC  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5AD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5AD8: 419A00A4  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5AE0: 488F3EA9  bl 0x831a9988
	ctx.lr = 0x828B5AE4;
	sub_831A9988(ctx, base);
	// 828B5AE4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 828B5AE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5AEC: 386BE758  addi r3, r11, -0x18a8
	ctx.r[3].s64 = ctx.r[11].s64 + -6312;
	// 828B5AF0: 488F2609  bl 0x831a80f8
	ctx.lr = 0x828B5AF4;
	sub_831A80F8(ctx, base);
	// 828B5AF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5AF8: 41820014  beq 0x828b5b0c
	if ctx.cr[0].eq {
	pc = 0x828B5B0C; continue 'dispatch;
	}
	// 828B5AFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5B00: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5B04: 4BFFFDED  bl 0x828b58f0
	ctx.lr = 0x828B5B08;
	sub_828B58F0(ctx, base);
	// 828B5B08: 4BFFFE74  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5B0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5B10: 419A006C  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5B18: 488F3E71  bl 0x831a9988
	ctx.lr = 0x828B5B1C;
	sub_831A9988(ctx, base);
	// 828B5B1C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828B5B20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5B24: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828B5B28: 488F25D1  bl 0x831a80f8
	ctx.lr = 0x828B5B2C;
	sub_831A80F8(ctx, base);
	// 828B5B2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5B30: 41820014  beq 0x828b5b44
	if ctx.cr[0].eq {
	pc = 0x828B5B44; continue 'dispatch;
	}
	// 828B5B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5B38: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5B3C: 4BFFC245  bl 0x828b1d80
	ctx.lr = 0x828B5B40;
	sub_828B1D80(ctx, base);
	// 828B5B40: 4BFFFE3C  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5B44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B5B48: 419A0034  beq cr6, 0x828b5b7c
	if ctx.cr[6].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5B50: 488F3E39  bl 0x831a9988
	ctx.lr = 0x828B5B54;
	sub_831A9988(ctx, base);
	// 828B5B54: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B5B58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5B5C: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828B5B60: 488F2599  bl 0x831a80f8
	ctx.lr = 0x828B5B64;
	sub_831A80F8(ctx, base);
	// 828B5B64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5B68: 41820014  beq 0x828b5b7c
	if ctx.cr[0].eq {
	pc = 0x828B5B7C; continue 'dispatch;
	}
	// 828B5B6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5B70: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828B5B74: 48018EAD  bl 0x828cea20
	ctx.lr = 0x828B5B78;
	sub_828CEA20(ctx, base);
	// 828B5B78: 4BFFFE04  b 0x828b597c
	pc = 0x828B597C; continue 'dispatch;
	// 828B5B7C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B5B80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5B84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5B88: 48059F09  bl 0x8290fa90
	ctx.lr = 0x828B5B8C;
	sub_8290FA90(ctx, base);
	// 828B5B8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B5B90: 488F2628  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5B98 size=76
    let mut pc: u32 = 0x828B5B98;
    'dispatch: loop {
        match pc {
            0x828B5B98 => {
    //   block [0x828B5B98..0x828B5BE4)
	// 828B5B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5BA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B5BA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B5BA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5BAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5BB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B5BB4: 4BFFFC25  bl 0x828b57d8
	ctx.lr = 0x828B5BB8;
	sub_828B57D8(ctx, base);
	// 828B5BB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5BBC: 4182000C  beq 0x828b5bc8
	if ctx.cr[0].eq {
	pc = 0x828B5BC8; continue 'dispatch;
	}
	// 828B5BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5BC4: 4853C815  bl 0x82df23d8
	ctx.lr = 0x828B5BC8;
	sub_82DF23D8(ctx, base);
	// 828B5BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5BCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5BD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5BD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5BD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B5BDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B5BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5BE8 size=244
    let mut pc: u32 = 0x828B5BE8;
    'dispatch: loop {
        match pc {
            0x828B5BE8 => {
    //   block [0x828B5BE8..0x828B5CDC)
	// 828B5BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B5BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B5BF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5C00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B5C04: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828B5C08: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828B5C0C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 828B5C10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B5C14: 4805AF05  bl 0x82910b18
	ctx.lr = 0x828B5C18;
	sub_82910B18(ctx, base);
	// 828B5C18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B5C1C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828B5C20: 396BB48C  addi r11, r11, -0x4b74
	ctx.r[11].s64 = ctx.r[11].s64 + -19316;
	// 828B5C24: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B5C28: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828B5C2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B5C30: 394AB2CC  addi r10, r10, -0x4d34
	ctx.r[10].s64 = ctx.r[10].s64 + -19764;
	// 828B5C34: 3929B2B4  addi r9, r9, -0x4d4c
	ctx.r[9].s64 = ctx.r[9].s64 + -19788;
	// 828B5C38: 3968B470  addi r11, r8, -0x4b90
	ctx.r[11].s64 = ctx.r[8].s64 + -19344;
	// 828B5C3C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828B5C40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B5C44: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828B5C48: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828B5C4C: 387F03A8  addi r3, r31, 0x3a8
	ctx.r[3].s64 = ctx.r[31].s64 + 936;
	// 828B5C50: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 828B5C54: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 828B5C58: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 828B5C5C: 93DF037C  stw r30, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[30].u32 ) };
	// 828B5C60: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 828B5C64: 93DF0384  stw r30, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[30].u32 ) };
	// 828B5C68: 93DF0388  stw r30, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[30].u32 ) };
	// 828B5C6C: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 828B5C70: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 828B5C74: 93DF0394  stw r30, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u32 ) };
	// 828B5C78: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828B5C7C: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 828B5C80: 4BBB0859  bl 0x824664d8
	ctx.lr = 0x828B5C84;
	sub_824664D8(ctx, base);
	// 828B5C84: 907F03AC  stw r3, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[3].u32 ) };
	// 828B5C88: 93DF03B0  stw r30, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[30].u32 ) };
	// 828B5C8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B5C90: 93DF03B4  stw r30, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[30].u32 ) };
	// 828B5C94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B5C98: 388BB1E8  addi r4, r11, -0x4e18
	ctx.r[4].s64 = ctx.r[11].s64 + -19992;
	// 828B5C9C: 38A00088  li r5, 0x88
	ctx.r[5].s64 = 136;
	// 828B5CA0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B5CA4: 4BA0A735  bl 0x822c03d8
	ctx.lr = 0x828B5CA8;
	sub_822C03D8(ctx, base);
	// 828B5CA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B5CAC: 4182000C  beq 0x828b5cb8
	if ctx.cr[0].eq {
	pc = 0x828B5CB8; continue 'dispatch;
	}
	// 828B5CB0: 4BFF6861  bl 0x828ac510
	ctx.lr = 0x828B5CB4;
	sub_828AC510(ctx, base);
	// 828B5CB4: 48000008  b 0x828b5cbc
	pc = 0x828B5CBC; continue 'dispatch;
	// 828B5CB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5CBC: 907F03A4  stw r3, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[3].u32 ) };
	// 828B5CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5CC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5CC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5CCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5CD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B5CD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B5CD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B5CE0 size=456
    let mut pc: u32 = 0x828B5CE0;
    'dispatch: loop {
        match pc {
            0x828B5CE0 => {
    //   block [0x828B5CE0..0x828B5EA8)
	// 828B5CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5CE4: 488F2481  bl 0x831a8164
	ctx.lr = 0x828B5CE8;
	sub_831A8130(ctx, base);
	// 828B5CE8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5CEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B5CF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B5CF4: 3BCBB1E8  addi r30, r11, -0x4e18
	ctx.r[30].s64 = ctx.r[11].s64 + -19992;
	// 828B5CF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B5CFC: 38A00072  li r5, 0x72
	ctx.r[5].s64 = 114;
	// 828B5D00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5D04: 386003C0  li r3, 0x3c0
	ctx.r[3].s64 = 960;
	// 828B5D08: 4853C6E1  bl 0x82df23e8
	ctx.lr = 0x828B5D0C;
	sub_82DF23E8(ctx, base);
	// 828B5D0C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B5D10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B5D14: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828B5D18: 4182001C  beq 0x828b5d34
	if ctx.cr[0].eq {
	pc = 0x828B5D34; continue 'dispatch;
	}
	// 828B5D1C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828B5D20: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B5D24: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828B5D28: 4BFFFEC1  bl 0x828b5be8
	ctx.lr = 0x828B5D2C;
	sub_828B5BE8(ctx, base);
	// 828B5D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5D30: 48000008  b 0x828b5d38
	pc = 0x828B5D38; continue 'dispatch;
	// 828B5D34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B5D38: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B5D3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5D40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B5D44: 4BFFC32D  bl 0x828b2070
	ctx.lr = 0x828B5D48;
	sub_828B2070(ctx, base);
	// 828B5D48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B5D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5D50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B5D54: 4BA0A2AD  bl 0x822c0000
	ctx.lr = 0x828B5D58;
	sub_822C0000(ctx, base);
	// 828B5D58: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B5D5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B5D60: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B5D64: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828B5D68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B5D6C: 419A0024  beq cr6, 0x828b5d90
	if ctx.cr[6].eq {
	pc = 0x828B5D90; continue 'dispatch;
	}
	// 828B5D70: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 828B5D74: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B5D78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B5D7C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B5D80: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B5D84: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B5D88: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B5D8C: 4082FFE8  bne 0x828b5d74
	if !ctx.cr[0].eq {
	pc = 0x828B5D74; continue 'dispatch;
	}
	// 828B5D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5D94: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828B5D98: 409A0008  bne cr6, 0x828b5da0
	if !ctx.cr[6].eq {
	pc = 0x828B5DA0; continue 'dispatch;
	}
	// 828B5D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5DA0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828B5DA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B5DA8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828B5DAC: 419A0024  beq cr6, 0x828b5dd0
	if ctx.cr[6].eq {
	pc = 0x828B5DD0; continue 'dispatch;
	}
	// 828B5DB0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828B5DB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B5DB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B5DBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B5DC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B5DC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B5DC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B5DCC: 4082FFE8  bne 0x828b5db4
	if !ctx.cr[0].eq {
	pc = 0x828B5DB4; continue 'dispatch;
	}
	// 828B5DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B5DD4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828B5DD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B5DDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B5DE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B5DE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5DE8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B5DEC: 4BEE3145  bl 0x82798f30
	ctx.lr = 0x828B5DF0;
	sub_82798F30(ctx, base);
	// 828B5DF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B5DF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B5DF8: C1810090  lfs f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B5DFC: C1610094  lfs f11, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B5E00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5E04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B5E08: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 828B5E0C: C00B9C28  lfs f0, -0x63d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5E10: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B5E14: C1AA9D1C  lfs f13, -0x62e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B5E18: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 828B5E1C: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 828B5E20: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828B5E24: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828B5E28: 4BA0A5B1  bl 0x822c03d8
	ctx.lr = 0x828B5E2C;
	sub_822C03D8(ctx, base);
	// 828B5E2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B5E30: 41820014  beq 0x828b5e44
	if ctx.cr[0].eq {
	pc = 0x828B5E44; continue 'dispatch;
	}
	// 828B5E34: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5E38: 4BEE5831  bl 0x8279b668
	ctx.lr = 0x828B5E3C;
	sub_8279B668(ctx, base);
	// 828B5E3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5E40: 48000008  b 0x828b5e48
	pc = 0x828B5E48; continue 'dispatch;
	// 828B5E44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B5E48: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B5E4C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828B5E50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5E54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5E58: 4BCE1DF9  bl 0x82597c50
	ctx.lr = 0x828B5E5C;
	sub_82597C50(ctx, base);
	// 828B5E5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B5E60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5E68: 4BA0A199  bl 0x822c0000
	ctx.lr = 0x828B5E6C;
	sub_822C0000(ctx, base);
	// 828B5E6C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B5E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5E74: 419A0008  beq cr6, 0x828b5e7c
	if ctx.cr[6].eq {
	pc = 0x828B5E7C; continue 'dispatch;
	}
	// 828B5E78: 4BA0AA19  bl 0x822c0890
	ctx.lr = 0x828B5E7C;
	sub_822C0890(ctx, base);
	// 828B5E7C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5E84: 419A0008  beq cr6, 0x828b5e8c
	if ctx.cr[6].eq {
	pc = 0x828B5E8C; continue 'dispatch;
	}
	// 828B5E88: 4BA0AA09  bl 0x822c0890
	ctx.lr = 0x828B5E8C;
	sub_822C0890(ctx, base);
	// 828B5E8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B5E90: 419A000C  beq cr6, 0x828b5e9c
	if ctx.cr[6].eq {
	pc = 0x828B5E9C; continue 'dispatch;
	}
	// 828B5E94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B5E98: 4BA0A9F9  bl 0x822c0890
	ctx.lr = 0x828B5E9C;
	sub_822C0890(ctx, base);
	// 828B5E9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B5EA0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828B5EA4: 488F2310  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5EA8 size=92
    let mut pc: u32 = 0x828B5EA8;
    'dispatch: loop {
        match pc {
            0x828B5EA8 => {
    //   block [0x828B5EA8..0x828B5F04)
	// 828B5EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5EAC: 488F22C1  bl 0x831a816c
	ctx.lr = 0x828B5EB0;
	sub_831A8130(ctx, base);
	// 828B5EB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5EB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5EB8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B5EBC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B5EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5EC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B5EC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5ECC: 388A4240  addi r4, r10, 0x4240
	ctx.r[4].s64 = ctx.r[10].s64 + 16960;
	// 828B5ED0: 4BAA9BA1  bl 0x8235fa70
	ctx.lr = 0x828B5ED4;
	sub_8235FA70(ctx, base);
	// 828B5ED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B5EDC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B5EE0: 4853DD21  bl 0x82df3c00
	ctx.lr = 0x828B5EE4;
	sub_82DF3C00(ctx, base);
	// 828B5EE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5EEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B5EF0: 485A6269  bl 0x82e5c158
	ctx.lr = 0x828B5EF4;
	sub_82E5C158(ctx, base);
	// 828B5EF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5EF8: 4853D531  bl 0x82df3428
	ctx.lr = 0x828B5EFC;
	sub_82DF3428(ctx, base);
	// 828B5EFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B5F00: 488F22BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5F08 size=92
    let mut pc: u32 = 0x828B5F08;
    'dispatch: loop {
        match pc {
            0x828B5F08 => {
    //   block [0x828B5F08..0x828B5F64)
	// 828B5F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5F0C: 488F2261  bl 0x831a816c
	ctx.lr = 0x828B5F10;
	sub_831A8130(ctx, base);
	// 828B5F10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5F14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5F18: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B5F1C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B5F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5F24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B5F28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5F2C: 388A42B0  addi r4, r10, 0x42b0
	ctx.r[4].s64 = ctx.r[10].s64 + 17072;
	// 828B5F30: 4BAA9B41  bl 0x8235fa70
	ctx.lr = 0x828B5F34;
	sub_8235FA70(ctx, base);
	// 828B5F34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B5F3C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B5F40: 4853DCC1  bl 0x82df3c00
	ctx.lr = 0x828B5F44;
	sub_82DF3C00(ctx, base);
	// 828B5F44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5F4C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B5F50: 485A6209  bl 0x82e5c158
	ctx.lr = 0x828B5F54;
	sub_82E5C158(ctx, base);
	// 828B5F54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5F58: 4853D4D1  bl 0x82df3428
	ctx.lr = 0x828B5F5C;
	sub_82DF3428(ctx, base);
	// 828B5F5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B5F60: 488F225C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5F68 size=92
    let mut pc: u32 = 0x828B5F68;
    'dispatch: loop {
        match pc {
            0x828B5F68 => {
    //   block [0x828B5F68..0x828B5FC4)
	// 828B5F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5F6C: 488F2201  bl 0x831a816c
	ctx.lr = 0x828B5F70;
	sub_831A8130(ctx, base);
	// 828B5F70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5F78: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B5F7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B5F80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5F84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B5F88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5F8C: 388A4320  addi r4, r10, 0x4320
	ctx.r[4].s64 = ctx.r[10].s64 + 17184;
	// 828B5F90: 4BAA9AE1  bl 0x8235fa70
	ctx.lr = 0x828B5F94;
	sub_8235FA70(ctx, base);
	// 828B5F94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B5F9C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B5FA0: 4853DC61  bl 0x82df3c00
	ctx.lr = 0x828B5FA4;
	sub_82DF3C00(ctx, base);
	// 828B5FA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5FAC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B5FB0: 485A61A9  bl 0x82e5c158
	ctx.lr = 0x828B5FB4;
	sub_82E5C158(ctx, base);
	// 828B5FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5FB8: 4853D471  bl 0x82df3428
	ctx.lr = 0x828B5FBC;
	sub_82DF3428(ctx, base);
	// 828B5FBC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B5FC0: 488F21FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5FC8 size=92
    let mut pc: u32 = 0x828B5FC8;
    'dispatch: loop {
        match pc {
            0x828B5FC8 => {
    //   block [0x828B5FC8..0x828B6024)
	// 828B5FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5FCC: 488F21A1  bl 0x831a816c
	ctx.lr = 0x828B5FD0;
	sub_831A8130(ctx, base);
	// 828B5FD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5FD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5FD8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B5FDC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B5FE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5FE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B5FE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5FEC: 388A4390  addi r4, r10, 0x4390
	ctx.r[4].s64 = ctx.r[10].s64 + 17296;
	// 828B5FF0: 4BAA9A81  bl 0x8235fa70
	ctx.lr = 0x828B5FF4;
	sub_8235FA70(ctx, base);
	// 828B5FF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B5FFC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6000: 4853DC01  bl 0x82df3c00
	ctx.lr = 0x828B6004;
	sub_82DF3C00(ctx, base);
	// 828B6004: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B600C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6010: 485A6149  bl 0x82e5c158
	ctx.lr = 0x828B6014;
	sub_82E5C158(ctx, base);
	// 828B6014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6018: 4853D411  bl 0x82df3428
	ctx.lr = 0x828B601C;
	sub_82DF3428(ctx, base);
	// 828B601C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6020: 488F219C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6028 size=92
    let mut pc: u32 = 0x828B6028;
    'dispatch: loop {
        match pc {
            0x828B6028 => {
    //   block [0x828B6028..0x828B6084)
	// 828B6028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B602C: 488F2141  bl 0x831a816c
	ctx.lr = 0x828B6030;
	sub_831A8130(ctx, base);
	// 828B6030: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6038: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B603C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6044: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6048: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B604C: 388A3540  addi r4, r10, 0x3540
	ctx.r[4].s64 = ctx.r[10].s64 + 13632;
	// 828B6050: 4BAA9A21  bl 0x8235fa70
	ctx.lr = 0x828B6054;
	sub_8235FA70(ctx, base);
	// 828B6054: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B605C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6060: 4853DBA1  bl 0x82df3c00
	ctx.lr = 0x828B6064;
	sub_82DF3C00(ctx, base);
	// 828B6064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B606C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6070: 485A60E9  bl 0x82e5c158
	ctx.lr = 0x828B6074;
	sub_82E5C158(ctx, base);
	// 828B6074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6078: 4853D3B1  bl 0x82df3428
	ctx.lr = 0x828B607C;
	sub_82DF3428(ctx, base);
	// 828B607C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6080: 488F213C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6088 size=92
    let mut pc: u32 = 0x828B6088;
    'dispatch: loop {
        match pc {
            0x828B6088 => {
    //   block [0x828B6088..0x828B60E4)
	// 828B6088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B608C: 488F20E1  bl 0x831a816c
	ctx.lr = 0x828B6090;
	sub_831A8130(ctx, base);
	// 828B6090: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6094: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6098: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B609C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B60A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B60A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B60A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B60AC: 388A4400  addi r4, r10, 0x4400
	ctx.r[4].s64 = ctx.r[10].s64 + 17408;
	// 828B60B0: 4BAA99C1  bl 0x8235fa70
	ctx.lr = 0x828B60B4;
	sub_8235FA70(ctx, base);
	// 828B60B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B60B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B60BC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B60C0: 4853DB41  bl 0x82df3c00
	ctx.lr = 0x828B60C4;
	sub_82DF3C00(ctx, base);
	// 828B60C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B60C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B60CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B60D0: 485A6089  bl 0x82e5c158
	ctx.lr = 0x828B60D4;
	sub_82E5C158(ctx, base);
	// 828B60D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B60D8: 4853D351  bl 0x82df3428
	ctx.lr = 0x828B60DC;
	sub_82DF3428(ctx, base);
	// 828B60DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B60E0: 488F20DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B60E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B60E8 size=92
    let mut pc: u32 = 0x828B60E8;
    'dispatch: loop {
        match pc {
            0x828B60E8 => {
    //   block [0x828B60E8..0x828B6144)
	// 828B60E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B60EC: 488F2081  bl 0x831a816c
	ctx.lr = 0x828B60F0;
	sub_831A8130(ctx, base);
	// 828B60F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B60F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B60F8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B60FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6104: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6108: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B610C: 388A4470  addi r4, r10, 0x4470
	ctx.r[4].s64 = ctx.r[10].s64 + 17520;
	// 828B6110: 4BAA9961  bl 0x8235fa70
	ctx.lr = 0x828B6114;
	sub_8235FA70(ctx, base);
	// 828B6114: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B611C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6120: 4853DAE1  bl 0x82df3c00
	ctx.lr = 0x828B6124;
	sub_82DF3C00(ctx, base);
	// 828B6124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B612C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6130: 485A6029  bl 0x82e5c158
	ctx.lr = 0x828B6134;
	sub_82E5C158(ctx, base);
	// 828B6134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6138: 4853D2F1  bl 0x82df3428
	ctx.lr = 0x828B613C;
	sub_82DF3428(ctx, base);
	// 828B613C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6140: 488F207C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6148 size=92
    let mut pc: u32 = 0x828B6148;
    'dispatch: loop {
        match pc {
            0x828B6148 => {
    //   block [0x828B6148..0x828B61A4)
	// 828B6148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B614C: 488F2021  bl 0x831a816c
	ctx.lr = 0x828B6150;
	sub_831A8130(ctx, base);
	// 828B6150: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6154: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6158: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B615C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6168: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B616C: 388A44E0  addi r4, r10, 0x44e0
	ctx.r[4].s64 = ctx.r[10].s64 + 17632;
	// 828B6170: 4BAA9901  bl 0x8235fa70
	ctx.lr = 0x828B6174;
	sub_8235FA70(ctx, base);
	// 828B6174: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B617C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6180: 4853DA81  bl 0x82df3c00
	ctx.lr = 0x828B6184;
	sub_82DF3C00(ctx, base);
	// 828B6184: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B618C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6190: 485A5FC9  bl 0x82e5c158
	ctx.lr = 0x828B6194;
	sub_82E5C158(ctx, base);
	// 828B6194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6198: 4853D291  bl 0x82df3428
	ctx.lr = 0x828B619C;
	sub_82DF3428(ctx, base);
	// 828B619C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B61A0: 488F201C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B61A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B61A8 size=92
    let mut pc: u32 = 0x828B61A8;
    'dispatch: loop {
        match pc {
            0x828B61A8 => {
    //   block [0x828B61A8..0x828B6204)
	// 828B61A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B61AC: 488F1FC1  bl 0x831a816c
	ctx.lr = 0x828B61B0;
	sub_831A8130(ctx, base);
	// 828B61B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B61B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B61B8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B61BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B61C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B61C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B61C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B61CC: 388A4550  addi r4, r10, 0x4550
	ctx.r[4].s64 = ctx.r[10].s64 + 17744;
	// 828B61D0: 4BAA98A1  bl 0x8235fa70
	ctx.lr = 0x828B61D4;
	sub_8235FA70(ctx, base);
	// 828B61D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B61D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B61DC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B61E0: 4853DA21  bl 0x82df3c00
	ctx.lr = 0x828B61E4;
	sub_82DF3C00(ctx, base);
	// 828B61E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B61E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B61EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B61F0: 485A5F69  bl 0x82e5c158
	ctx.lr = 0x828B61F4;
	sub_82E5C158(ctx, base);
	// 828B61F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B61F8: 4853D231  bl 0x82df3428
	ctx.lr = 0x828B61FC;
	sub_82DF3428(ctx, base);
	// 828B61FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6200: 488F1FBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6208 size=92
    let mut pc: u32 = 0x828B6208;
    'dispatch: loop {
        match pc {
            0x828B6208 => {
    //   block [0x828B6208..0x828B6264)
	// 828B6208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B620C: 488F1F61  bl 0x831a816c
	ctx.lr = 0x828B6210;
	sub_831A8130(ctx, base);
	// 828B6210: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6214: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6218: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B621C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6224: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6228: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B622C: 388A45C0  addi r4, r10, 0x45c0
	ctx.r[4].s64 = ctx.r[10].s64 + 17856;
	// 828B6230: 4BAA9841  bl 0x8235fa70
	ctx.lr = 0x828B6234;
	sub_8235FA70(ctx, base);
	// 828B6234: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B623C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6240: 4853D9C1  bl 0x82df3c00
	ctx.lr = 0x828B6244;
	sub_82DF3C00(ctx, base);
	// 828B6244: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B624C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6250: 485A5F09  bl 0x82e5c158
	ctx.lr = 0x828B6254;
	sub_82E5C158(ctx, base);
	// 828B6254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6258: 4853D1D1  bl 0x82df3428
	ctx.lr = 0x828B625C;
	sub_82DF3428(ctx, base);
	// 828B625C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6260: 488F1F5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6268 size=92
    let mut pc: u32 = 0x828B6268;
    'dispatch: loop {
        match pc {
            0x828B6268 => {
    //   block [0x828B6268..0x828B62C4)
	// 828B6268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B626C: 488F1F01  bl 0x831a816c
	ctx.lr = 0x828B6270;
	sub_831A8130(ctx, base);
	// 828B6270: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6274: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6278: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B627C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6284: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6288: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B628C: 388A4630  addi r4, r10, 0x4630
	ctx.r[4].s64 = ctx.r[10].s64 + 17968;
	// 828B6290: 4BAA97E1  bl 0x8235fa70
	ctx.lr = 0x828B6294;
	sub_8235FA70(ctx, base);
	// 828B6294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B629C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B62A0: 4853D961  bl 0x82df3c00
	ctx.lr = 0x828B62A4;
	sub_82DF3C00(ctx, base);
	// 828B62A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B62A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B62AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B62B0: 485A5EA9  bl 0x82e5c158
	ctx.lr = 0x828B62B4;
	sub_82E5C158(ctx, base);
	// 828B62B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B62B8: 4853D171  bl 0x82df3428
	ctx.lr = 0x828B62BC;
	sub_82DF3428(ctx, base);
	// 828B62BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B62C0: 488F1EFC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B62C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B62C8 size=92
    let mut pc: u32 = 0x828B62C8;
    'dispatch: loop {
        match pc {
            0x828B62C8 => {
    //   block [0x828B62C8..0x828B6324)
	// 828B62C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B62CC: 488F1EA1  bl 0x831a816c
	ctx.lr = 0x828B62D0;
	sub_831A8130(ctx, base);
	// 828B62D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B62D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B62D8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B62DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B62E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B62E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B62E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B62EC: 388A46A0  addi r4, r10, 0x46a0
	ctx.r[4].s64 = ctx.r[10].s64 + 18080;
	// 828B62F0: 4BAA9781  bl 0x8235fa70
	ctx.lr = 0x828B62F4;
	sub_8235FA70(ctx, base);
	// 828B62F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B62F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B62FC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6300: 4853D901  bl 0x82df3c00
	ctx.lr = 0x828B6304;
	sub_82DF3C00(ctx, base);
	// 828B6304: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B630C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6310: 485A5E49  bl 0x82e5c158
	ctx.lr = 0x828B6314;
	sub_82E5C158(ctx, base);
	// 828B6314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6318: 4853D111  bl 0x82df3428
	ctx.lr = 0x828B631C;
	sub_82DF3428(ctx, base);
	// 828B631C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6320: 488F1E9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6328 size=92
    let mut pc: u32 = 0x828B6328;
    'dispatch: loop {
        match pc {
            0x828B6328 => {
    //   block [0x828B6328..0x828B6384)
	// 828B6328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B632C: 488F1E41  bl 0x831a816c
	ctx.lr = 0x828B6330;
	sub_831A8130(ctx, base);
	// 828B6330: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6334: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6338: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B633C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6344: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6348: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B634C: 388A4710  addi r4, r10, 0x4710
	ctx.r[4].s64 = ctx.r[10].s64 + 18192;
	// 828B6350: 4BAA9721  bl 0x8235fa70
	ctx.lr = 0x828B6354;
	sub_8235FA70(ctx, base);
	// 828B6354: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B635C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6360: 4853D8A1  bl 0x82df3c00
	ctx.lr = 0x828B6364;
	sub_82DF3C00(ctx, base);
	// 828B6364: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B636C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6370: 485A5DE9  bl 0x82e5c158
	ctx.lr = 0x828B6374;
	sub_82E5C158(ctx, base);
	// 828B6374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6378: 4853D0B1  bl 0x82df3428
	ctx.lr = 0x828B637C;
	sub_82DF3428(ctx, base);
	// 828B637C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6380: 488F1E3C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6388 size=92
    let mut pc: u32 = 0x828B6388;
    'dispatch: loop {
        match pc {
            0x828B6388 => {
    //   block [0x828B6388..0x828B63E4)
	// 828B6388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B638C: 488F1DE1  bl 0x831a816c
	ctx.lr = 0x828B6390;
	sub_831A8130(ctx, base);
	// 828B6390: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6398: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B639C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B63A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B63A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B63A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B63AC: 388A4780  addi r4, r10, 0x4780
	ctx.r[4].s64 = ctx.r[10].s64 + 18304;
	// 828B63B0: 4BAA96C1  bl 0x8235fa70
	ctx.lr = 0x828B63B4;
	sub_8235FA70(ctx, base);
	// 828B63B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B63B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B63BC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B63C0: 4853D841  bl 0x82df3c00
	ctx.lr = 0x828B63C4;
	sub_82DF3C00(ctx, base);
	// 828B63C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B63C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B63CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B63D0: 485A5D89  bl 0x82e5c158
	ctx.lr = 0x828B63D4;
	sub_82E5C158(ctx, base);
	// 828B63D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B63D8: 4853D051  bl 0x82df3428
	ctx.lr = 0x828B63DC;
	sub_82DF3428(ctx, base);
	// 828B63DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B63E0: 488F1DDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B63E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B63E8 size=92
    let mut pc: u32 = 0x828B63E8;
    'dispatch: loop {
        match pc {
            0x828B63E8 => {
    //   block [0x828B63E8..0x828B6444)
	// 828B63E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B63EC: 488F1D81  bl 0x831a816c
	ctx.lr = 0x828B63F0;
	sub_831A8130(ctx, base);
	// 828B63F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B63F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B63F8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B63FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6404: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6408: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B640C: 388A47F0  addi r4, r10, 0x47f0
	ctx.r[4].s64 = ctx.r[10].s64 + 18416;
	// 828B6410: 4BAA9661  bl 0x8235fa70
	ctx.lr = 0x828B6414;
	sub_8235FA70(ctx, base);
	// 828B6414: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B641C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6420: 4853D7E1  bl 0x82df3c00
	ctx.lr = 0x828B6424;
	sub_82DF3C00(ctx, base);
	// 828B6424: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B642C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6430: 485A5D29  bl 0x82e5c158
	ctx.lr = 0x828B6434;
	sub_82E5C158(ctx, base);
	// 828B6434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6438: 4853CFF1  bl 0x82df3428
	ctx.lr = 0x828B643C;
	sub_82DF3428(ctx, base);
	// 828B643C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6440: 488F1D7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6448 size=92
    let mut pc: u32 = 0x828B6448;
    'dispatch: loop {
        match pc {
            0x828B6448 => {
    //   block [0x828B6448..0x828B64A4)
	// 828B6448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B644C: 488F1D21  bl 0x831a816c
	ctx.lr = 0x828B6450;
	sub_831A8130(ctx, base);
	// 828B6450: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6454: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6458: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B645C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6464: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6468: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B646C: 388A4860  addi r4, r10, 0x4860
	ctx.r[4].s64 = ctx.r[10].s64 + 18528;
	// 828B6470: 4BAA9601  bl 0x8235fa70
	ctx.lr = 0x828B6474;
	sub_8235FA70(ctx, base);
	// 828B6474: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B647C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6480: 4853D781  bl 0x82df3c00
	ctx.lr = 0x828B6484;
	sub_82DF3C00(ctx, base);
	// 828B6484: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B648C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6490: 485A5CC9  bl 0x82e5c158
	ctx.lr = 0x828B6494;
	sub_82E5C158(ctx, base);
	// 828B6494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6498: 4853CF91  bl 0x82df3428
	ctx.lr = 0x828B649C;
	sub_82DF3428(ctx, base);
	// 828B649C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B64A0: 488F1D1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B64A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B64A8 size=92
    let mut pc: u32 = 0x828B64A8;
    'dispatch: loop {
        match pc {
            0x828B64A8 => {
    //   block [0x828B64A8..0x828B6504)
	// 828B64A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B64AC: 488F1CC1  bl 0x831a816c
	ctx.lr = 0x828B64B0;
	sub_831A8130(ctx, base);
	// 828B64B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B64B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B64B8: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B64BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B64C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B64C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B64C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B64CC: 388A48D0  addi r4, r10, 0x48d0
	ctx.r[4].s64 = ctx.r[10].s64 + 18640;
	// 828B64D0: 4BAA95A1  bl 0x8235fa70
	ctx.lr = 0x828B64D4;
	sub_8235FA70(ctx, base);
	// 828B64D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B64D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B64DC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B64E0: 4853D721  bl 0x82df3c00
	ctx.lr = 0x828B64E4;
	sub_82DF3C00(ctx, base);
	// 828B64E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B64E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B64EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B64F0: 485A5C69  bl 0x82e5c158
	ctx.lr = 0x828B64F4;
	sub_82E5C158(ctx, base);
	// 828B64F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B64F8: 4853CF31  bl 0x82df3428
	ctx.lr = 0x828B64FC;
	sub_82DF3428(ctx, base);
	// 828B64FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6500: 488F1CBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6508 size=92
    let mut pc: u32 = 0x828B6508;
    'dispatch: loop {
        match pc {
            0x828B6508 => {
    //   block [0x828B6508..0x828B6564)
	// 828B6508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B650C: 488F1C61  bl 0x831a816c
	ctx.lr = 0x828B6510;
	sub_831A8130(ctx, base);
	// 828B6510: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6518: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828B651C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6524: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B6528: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B652C: 388A4940  addi r4, r10, 0x4940
	ctx.r[4].s64 = ctx.r[10].s64 + 18752;
	// 828B6530: 4BAA9541  bl 0x8235fa70
	ctx.lr = 0x828B6534;
	sub_8235FA70(ctx, base);
	// 828B6534: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B653C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B6540: 4853D6C1  bl 0x82df3c00
	ctx.lr = 0x828B6544;
	sub_82DF3C00(ctx, base);
	// 828B6544: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B654C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B6550: 485A5C09  bl 0x82e5c158
	ctx.lr = 0x828B6554;
	sub_82E5C158(ctx, base);
	// 828B6554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6558: 4853CED1  bl 0x82df3428
	ctx.lr = 0x828B655C;
	sub_82DF3428(ctx, base);
	// 828B655C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B6560: 488F1C5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6568 size=128
    let mut pc: u32 = 0x828B6568;
    'dispatch: loop {
        match pc {
            0x828B6568 => {
    //   block [0x828B6568..0x828B65E8)
	// 828B6568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B656C: 488F1C01  bl 0x831a816c
	ctx.lr = 0x828B6570;
	sub_831A8130(ctx, base);
	// 828B6570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6574: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828B6578: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B657C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B6580: 3BEB0744  addi r31, r11, 0x744
	ctx.r[31].s64 = ctx.r[11].s64 + 1860;
	// 828B6584: 816A074C  lwz r11, 0x74c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1868 as u32) ) } as u64;
	// 828B6588: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B658C: 40820024  bne 0x828b65b0
	if !ctx.cr[0].eq {
	pc = 0x828B65B0; continue 'dispatch;
	}
	// 828B6590: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828B6594: 3D00828B  lis r8, -0x7d75
	ctx.r[8].s64 = -2104819712;
	// 828B6598: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B659C: 392956D8  addi r9, r9, 0x56d8
	ctx.r[9].s64 = ctx.r[9].s64 + 22232;
	// 828B65A0: 39085708  addi r8, r8, 0x5708
	ctx.r[8].s64 = ctx.r[8].s64 + 22280;
	// 828B65A4: 916A074C  stw r11, 0x74c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1868 as u32), ctx.r[11].u32 ) };
	// 828B65A8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B65AC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B65B0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B65B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B65B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B65BC: 391E0008  addi r8, r30, 8
	ctx.r[8].s64 = ctx.r[30].s64 + 8;
	// 828B65C0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828B65C4: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B65C8: 4BFF0101  bl 0x828a66c8
	ctx.lr = 0x828B65CC;
	sub_828A66C8(ctx, base);
	// 828B65CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B65D0: 4182000C  beq 0x828b65dc
	if ctx.cr[0].eq {
	pc = 0x828B65DC; continue 'dispatch;
	}
	// 828B65D4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B65D8: 48000008  b 0x828b65e0
	pc = 0x828B65E0; continue 'dispatch;
	// 828B65DC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B65E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B65E4: 488F1BD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B65E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B65E8 size=128
    let mut pc: u32 = 0x828B65E8;
    'dispatch: loop {
        match pc {
            0x828B65E8 => {
    //   block [0x828B65E8..0x828B6668)
	// 828B65E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B65EC: 488F1B81  bl 0x831a816c
	ctx.lr = 0x828B65F0;
	sub_831A8130(ctx, base);
	// 828B65F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B65F4: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828B65F8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B65FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B6600: 3BEB0750  addi r31, r11, 0x750
	ctx.r[31].s64 = ctx.r[11].s64 + 1872;
	// 828B6604: 816A0758  lwz r11, 0x758(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1880 as u32) ) } as u64;
	// 828B6608: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B660C: 40820024  bne 0x828b6630
	if !ctx.cr[0].eq {
	pc = 0x828B6630; continue 'dispatch;
	}
	// 828B6610: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828B6614: 3D00828B  lis r8, -0x7d75
	ctx.r[8].s64 = -2104819712;
	// 828B6618: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B661C: 392990E8  addi r9, r9, -0x6f18
	ctx.r[9].s64 = ctx.r[9].s64 + -28440;
	// 828B6620: 39083628  addi r8, r8, 0x3628
	ctx.r[8].s64 = ctx.r[8].s64 + 13864;
	// 828B6624: 916A0758  stw r11, 0x758(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1880 as u32), ctx.r[11].u32 ) };
	// 828B6628: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B662C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B6630: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B6634: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B6638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B663C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828B6640: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828B6644: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B6648: 4BD9DF79  bl 0x826545c0
	ctx.lr = 0x828B664C;
	sub_826545C0(ctx, base);
	// 828B664C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6650: 4182000C  beq 0x828b665c
	if ctx.cr[0].eq {
	pc = 0x828B665C; continue 'dispatch;
	}
	// 828B6654: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B6658: 48000008  b 0x828b6660
	pc = 0x828B6660; continue 'dispatch;
	// 828B665C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B6660: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B6664: 488F1B58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6668 size=128
    let mut pc: u32 = 0x828B6668;
    'dispatch: loop {
        match pc {
            0x828B6668 => {
    //   block [0x828B6668..0x828B66E8)
	// 828B6668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B666C: 488F1B01  bl 0x831a816c
	ctx.lr = 0x828B6670;
	sub_831A8130(ctx, base);
	// 828B6670: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6674: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828B6678: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B667C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B6680: 3BEB075C  addi r31, r11, 0x75c
	ctx.r[31].s64 = ctx.r[11].s64 + 1884;
	// 828B6684: 816A0764  lwz r11, 0x764(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1892 as u32) ) } as u64;
	// 828B6688: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B668C: 40820024  bne 0x828b66b0
	if !ctx.cr[0].eq {
	pc = 0x828B66B0; continue 'dispatch;
	}
	// 828B6690: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828B6694: 3D00828B  lis r8, -0x7d75
	ctx.r[8].s64 = -2104819712;
	// 828B6698: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B669C: 39295750  addi r9, r9, 0x5750
	ctx.r[9].s64 = ctx.r[9].s64 + 22352;
	// 828B66A0: 39085790  addi r8, r8, 0x5790
	ctx.r[8].s64 = ctx.r[8].s64 + 22416;
	// 828B66A4: 916A0764  stw r11, 0x764(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1892 as u32), ctx.r[11].u32 ) };
	// 828B66A8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B66AC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B66B0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B66B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B66B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B66BC: 391E0008  addi r8, r30, 8
	ctx.r[8].s64 = ctx.r[30].s64 + 8;
	// 828B66C0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828B66C4: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B66C8: 4BFF0001  bl 0x828a66c8
	ctx.lr = 0x828B66CC;
	sub_828A66C8(ctx, base);
	// 828B66CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B66D0: 4182000C  beq 0x828b66dc
	if ctx.cr[0].eq {
	pc = 0x828B66DC; continue 'dispatch;
	}
	// 828B66D4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B66D8: 48000008  b 0x828b66e0
	pc = 0x828B66E0; continue 'dispatch;
	// 828B66DC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B66E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B66E4: 488F1AD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B66E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B66E8 size=128
    let mut pc: u32 = 0x828B66E8;
    'dispatch: loop {
        match pc {
            0x828B66E8 => {
    //   block [0x828B66E8..0x828B6768)
	// 828B66E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B66EC: 488F1A81  bl 0x831a816c
	ctx.lr = 0x828B66F0;
	sub_831A8130(ctx, base);
	// 828B66F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B66F4: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828B66F8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B66FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B6700: 3BEB0768  addi r31, r11, 0x768
	ctx.r[31].s64 = ctx.r[11].s64 + 1896;
	// 828B6704: 816A0770  lwz r11, 0x770(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1904 as u32) ) } as u64;
	// 828B6708: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B670C: 40820024  bne 0x828b6730
	if !ctx.cr[0].eq {
	pc = 0x828B6730; continue 'dispatch;
	}
	// 828B6710: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 828B6714: 3D00828B  lis r8, -0x7d75
	ctx.r[8].s64 = -2104819712;
	// 828B6718: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B671C: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 828B6720: 39083670  addi r8, r8, 0x3670
	ctx.r[8].s64 = ctx.r[8].s64 + 13936;
	// 828B6724: 916A0770  stw r11, 0x770(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1904 as u32), ctx.r[11].u32 ) };
	// 828B6728: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B672C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B6730: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B6734: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B6738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B673C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828B6740: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828B6744: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B6748: 4BD9DE79  bl 0x826545c0
	ctx.lr = 0x828B674C;
	sub_826545C0(ctx, base);
	// 828B674C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6750: 4182000C  beq 0x828b675c
	if ctx.cr[0].eq {
	pc = 0x828B675C; continue 'dispatch;
	}
	// 828B6754: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B6758: 48000008  b 0x828b6760
	pc = 0x828B6760; continue 'dispatch;
	// 828B675C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B6760: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B6764: 488F1A58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B6768 size=7192
    let mut pc: u32 = 0x828B6768;
    'dispatch: loop {
        match pc {
            0x828B6768 => {
    //   block [0x828B6768..0x828B8380)
	// 828B6768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B676C: 488F19C5  bl 0x831a8130
	ctx.lr = 0x828B6770;
	sub_831A8130(ctx, base);
	// 828B6770: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 828B6774: 488F22FD  bl 0x831a8a70
	ctx.lr = 0x828B6778;
	sub_831A8A40(ctx, base);
	// 828B6778: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B677C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828B6780: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B6784: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828B6788: 9361022C  stw r27, 0x22c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[27].u32 ) };
	// 828B678C: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 828B6790: 93A10234  stw r29, 0x234(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(564 as u32), ctx.r[29].u32 ) };
	// 828B6794: 9381023C  stw r28, 0x23c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(572 as u32), ctx.r[28].u32 ) };
	// 828B6798: 4805A5F9  bl 0x82910d90
	ctx.lr = 0x828B679C;
	sub_82910D90(ctx, base);
	// 828B679C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828B67A0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B67A4: 4BC58BCD  bl 0x8250f370
	ctx.lr = 0x828B67A8;
	sub_8250F370(ctx, base);
	// 828B67A8: 35D1FFF0  addic. r14, r17, -0x10
	ctx.xer.ca = (ctx.r[17].u32 > (!(-16 as u32)));
	ctx.r[14].s64 = ctx.r[17].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 828B67AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B67B0: 7E3F8B78  mr r31, r17
	ctx.r[31].u64 = ctx.r[17].u64;
	// 828B67B4: 40820008  bne 0x828b67bc
	if !ctx.cr[0].eq {
	pc = 0x828B67BC; continue 'dispatch;
	}
	// 828B67B8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B67BC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828B67C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B67C4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828B67C8: 4853D241  bl 0x82df3a08
	ctx.lr = 0x828B67CC;
	sub_82DF3A08(ctx, base);
	// 828B67CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B67D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B67D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B67D8: 4BC51FA9  bl 0x82508780
	ctx.lr = 0x828B67DC;
	sub_82508780(ctx, base);
	// 828B67DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B67E0: 4853CC49  bl 0x82df3428
	ctx.lr = 0x828B67E4;
	sub_82DF3428(ctx, base);
	// 828B67E4: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B67E8: 38910028  addi r4, r17, 0x28
	ctx.r[4].s64 = ctx.r[17].s64 + 40;
	// 828B67EC: 409A0008  bne cr6, 0x828b67f4
	if !ctx.cr[6].eq {
	pc = 0x828B67F4; continue 'dispatch;
	}
	// 828B67F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B67F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B67F8: 4BC51FA9  bl 0x825087a0
	ctx.lr = 0x828B67FC;
	sub_825087A0(ctx, base);
	// 828B67FC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828B6800: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B6804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6808: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B680C: 808A261C  lwz r4, 0x261c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9756 as u32) ) } as u64;
	// 828B6810: 81510394  lwz r10, 0x394(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B6814: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6818: 1D4A0288  mulli r10, r10, 0x288
	ctx.r[10].s64 = ctx.r[10].s64 * 648;
	// 828B681C: 7DEA5A14  add r15, r10, r11
	ctx.r[15].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B6820: 4853D1E9  bl 0x82df3a08
	ctx.lr = 0x828B6824;
	sub_82DF3A08(ctx, base);
	// 828B6824: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B6828: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B682C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B6830: 48059DD1  bl 0x82910600
	ctx.lr = 0x828B6834;
	sub_82910600(ctx, base);
	// 828B6834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6838: 4853CBF1  bl 0x82df3428
	ctx.lr = 0x828B683C;
	sub_82DF3428(ctx, base);
	// 828B683C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B6840: 4805A081  bl 0x829108c0
	ctx.lr = 0x828B6844;
	sub_829108C0(ctx, base);
	// 828B6844: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6848: 41820010  beq 0x828b6858
	if ctx.cr[0].eq {
	pc = 0x828B6858; continue 'dispatch;
	}
	// 828B684C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B6850: 4BC59D81  bl 0x825105d0
	ctx.lr = 0x828B6854;
	sub_825105D0(ctx, base);
	// 828B6854: 48001B1C  b 0x828b8370
	pc = 0x828B8370; continue 'dispatch;
	// 828B6858: 3BB1FFF0  addi r29, r17, -0x10
	ctx.r[29].s64 = ctx.r[17].s64 + -16;
	// 828B685C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B6860: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6864: 4BFFEC3D  bl 0x828b54a0
	ctx.lr = 0x828B6868;
	sub_828B54A0(ctx, base);
	// 828B6868: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B686C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6870: 388BB1E8  addi r4, r11, -0x4e18
	ctx.r[4].s64 = ctx.r[11].s64 + -19992;
	// 828B6874: 38A000D2  li r5, 0xd2
	ctx.r[5].s64 = 210;
	// 828B6878: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828B687C: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 828B6880: 4BA09B59  bl 0x822c03d8
	ctx.lr = 0x828B6884;
	sub_822C03D8(ctx, base);
	// 828B6884: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B6888: 41820020  beq 0x828b68a8
	if ctx.cr[0].eq {
	pc = 0x828B68A8; continue 'dispatch;
	}
	// 828B688C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6890: 4BF34421  bl 0x827eacb0
	ctx.lr = 0x828B6894;
	sub_827EACB0(ctx, base);
	// 828B6894: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B6898: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B689C: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828B68A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B68A4: 48000008  b 0x828b68ac
	pc = 0x828B68AC; continue 'dispatch;
	// 828B68A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B68AC: 3BF10368  addi r31, r17, 0x368
	ctx.r[31].s64 = ctx.r[17].s64 + 872;
	// 828B68B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B68B4: 4BFB19CD  bl 0x82868280
	ctx.lr = 0x828B68B8;
	sub_82868280(ctx, base);
	// 828B68B8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B68BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B68C0: 808B2620  lwz r4, 0x2620(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9760 as u32) ) } as u64;
	// 828B68C4: 4853D145  bl 0x82df3a08
	ctx.lr = 0x828B68C8;
	sub_82DF3A08(ctx, base);
	// 828B68C8: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828B68CC: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828B68D0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828B68D4: 83710368  lwz r27, 0x368(r17)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(872 as u32) ) } as u64;
	// 828B68D8: 4BC58BF1  bl 0x8250f4c8
	ctx.lr = 0x828B68DC;
	sub_8250F4C8(ctx, base);
	// 828B68DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B68E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B68E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B68E8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B68EC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B68F0: 4BF34079  bl 0x827ea968
	ctx.lr = 0x828B68F4;
	sub_827EA968(ctx, base);
	// 828B68F4: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828B68F8: 4853B399  bl 0x82df1c90
	ctx.lr = 0x828B68FC;
	sub_82DF1C90(ctx, base);
	// 828B68FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6900: 4853CB29  bl 0x82df3428
	ctx.lr = 0x828B6904;
	sub_82DF3428(ctx, base);
	// 828B6904: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B6908: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828B690C: 80710368  lwz r3, 0x368(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(872 as u32) ) } as u64;
	// 828B6910: 388A2628  addi r4, r10, 0x2628
	ctx.r[4].s64 = ctx.r[10].s64 + 9768;
	// 828B6914: 80ABB810  lwz r5, -0x47f0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18416 as u32) ) } as u64;
	// 828B6918: 4BF33DA9  bl 0x827ea6c0
	ctx.lr = 0x828B691C;
	sub_827EA6C0(ctx, base);
	// 828B691C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828B6920: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828B6924: 4BF35CA5  bl 0x827ec5c8
	ctx.lr = 0x828B6928;
	sub_827EC5C8(ctx, base);
	// 828B6928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B692C: 80710368  lwz r3, 0x368(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(872 as u32) ) } as u64;
	// 828B6930: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6934: 4BF33D95  bl 0x827ea6c8
	ctx.lr = 0x828B6938;
	sub_827EA6C8(ctx, base);
	// 828B6938: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 828B693C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B6940: 419A0008  beq cr6, 0x828b6948
	if ctx.cr[6].eq {
	pc = 0x828B6948; continue 'dispatch;
	}
	// 828B6944: 4BA09F4D  bl 0x822c0890
	ctx.lr = 0x828B6948;
	sub_822C0890(ctx, base);
	// 828B6948: 3F40832C  lis r26, -0x7cd4
	ctx.r[26].s64 = -2094268416;
	// 828B694C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6950: 809A25B4  lwz r4, 0x25b4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(9652 as u32) ) } as u64;
	// 828B6954: 4853D0B5  bl 0x82df3a08
	ctx.lr = 0x828B6958;
	sub_82DF3A08(ctx, base);
	// 828B6958: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B695C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6960: 4BF33C39  bl 0x827ea598
	ctx.lr = 0x828B6964;
	sub_827EA598(ctx, base);
	// 828B6964: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B6968: C02B03E8  lfs f1, 0x3e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1000 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B696C: 48302105  bl 0x82bb8a70
	ctx.lr = 0x828B6970;
	sub_82BB8A70(ctx, base);
	// 828B6970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6974: 4853CAB5  bl 0x82df3428
	ctx.lr = 0x828B6978;
	sub_82DF3428(ctx, base);
	// 828B6978: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B697C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6980: 808B258C  lwz r4, 0x258c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9612 as u32) ) } as u64;
	// 828B6984: 4853D085  bl 0x82df3a08
	ctx.lr = 0x828B6988;
	sub_82DF3A08(ctx, base);
	// 828B6988: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828B698C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6994: C3CB7BC8  lfs f30, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B6998: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B699C: 4BF3399D  bl 0x827ea338
	ctx.lr = 0x828B69A0;
	sub_827EA338(ctx, base);
	// 828B69A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B69A4: 4853CA85  bl 0x82df3428
	ctx.lr = 0x828B69A8;
	sub_82DF3428(ctx, base);
	// 828B69A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B69AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B69B0: 808B2590  lwz r4, 0x2590(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9616 as u32) ) } as u64;
	// 828B69B4: 4853D055  bl 0x82df3a08
	ctx.lr = 0x828B69B8;
	sub_82DF3A08(ctx, base);
	// 828B69B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B69BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B69C0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B69C4: 4BF33975  bl 0x827ea338
	ctx.lr = 0x828B69C8;
	sub_827EA338(ctx, base);
	// 828B69C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B69CC: 4853CA5D  bl 0x82df3428
	ctx.lr = 0x828B69D0;
	sub_82DF3428(ctx, base);
	// 828B69D0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B69D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B69D8: 808B2594  lwz r4, 0x2594(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9620 as u32) ) } as u64;
	// 828B69DC: 4853D02D  bl 0x82df3a08
	ctx.lr = 0x828B69E0;
	sub_82DF3A08(ctx, base);
	// 828B69E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B69E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B69E8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B69EC: 4BF3394D  bl 0x827ea338
	ctx.lr = 0x828B69F0;
	sub_827EA338(ctx, base);
	// 828B69F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B69F4: 4853CA35  bl 0x82df3428
	ctx.lr = 0x828B69F8;
	sub_82DF3428(ctx, base);
	// 828B69F8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B69FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A00: 808B2598  lwz r4, 0x2598(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9624 as u32) ) } as u64;
	// 828B6A04: 4853D005  bl 0x82df3a08
	ctx.lr = 0x828B6A08;
	sub_82DF3A08(ctx, base);
	// 828B6A08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6A0C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6A10: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6A14: 4BF33925  bl 0x827ea338
	ctx.lr = 0x828B6A18;
	sub_827EA338(ctx, base);
	// 828B6A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A1C: 4853CA0D  bl 0x82df3428
	ctx.lr = 0x828B6A20;
	sub_82DF3428(ctx, base);
	// 828B6A20: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A28: 808B259C  lwz r4, 0x259c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9628 as u32) ) } as u64;
	// 828B6A2C: 4853CFDD  bl 0x82df3a08
	ctx.lr = 0x828B6A30;
	sub_82DF3A08(ctx, base);
	// 828B6A30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B6A34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6A3C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B6A40: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6A44: 4BF338F5  bl 0x827ea338
	ctx.lr = 0x828B6A48;
	sub_827EA338(ctx, base);
	// 828B6A48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A4C: 4853C9DD  bl 0x82df3428
	ctx.lr = 0x828B6A50;
	sub_82DF3428(ctx, base);
	// 828B6A50: 3EC0832C  lis r22, -0x7cd4
	ctx.r[22].s64 = -2094268416;
	// 828B6A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A58: 809625A0  lwz r4, 0x25a0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(9632 as u32) ) } as u64;
	// 828B6A5C: 4853CFAD  bl 0x82df3a08
	ctx.lr = 0x828B6A60;
	sub_82DF3A08(ctx, base);
	// 828B6A60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6A64: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6A68: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6A6C: 4BF338CD  bl 0x827ea338
	ctx.lr = 0x828B6A70;
	sub_827EA338(ctx, base);
	// 828B6A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A74: 4853C9B5  bl 0x82df3428
	ctx.lr = 0x828B6A78;
	sub_82DF3428(ctx, base);
	// 828B6A78: 3F20832C  lis r25, -0x7cd4
	ctx.r[25].s64 = -2094268416;
	// 828B6A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A80: 809925B8  lwz r4, 0x25b8(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828B6A84: 4853CF85  bl 0x82df3a08
	ctx.lr = 0x828B6A88;
	sub_82DF3A08(ctx, base);
	// 828B6A88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6A8C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6A90: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6A94: 4BF338A5  bl 0x827ea338
	ctx.lr = 0x828B6A98;
	sub_827EA338(ctx, base);
	// 828B6A98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6A9C: 4853C98D  bl 0x82df3428
	ctx.lr = 0x828B6AA0;
	sub_82DF3428(ctx, base);
	// 828B6AA0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6AA8: 808B25FC  lwz r4, 0x25fc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9724 as u32) ) } as u64;
	// 828B6AAC: 4853CF5D  bl 0x82df3a08
	ctx.lr = 0x828B6AB0;
	sub_82DF3A08(ctx, base);
	// 828B6AB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6AB4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6AB8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6ABC: 4BF3387D  bl 0x827ea338
	ctx.lr = 0x828B6AC0;
	sub_827EA338(ctx, base);
	// 828B6AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6AC4: 4853C965  bl 0x82df3428
	ctx.lr = 0x828B6AC8;
	sub_82DF3428(ctx, base);
	// 828B6AC8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6ACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6AD0: 808B2600  lwz r4, 0x2600(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9728 as u32) ) } as u64;
	// 828B6AD4: 4853CF35  bl 0x82df3a08
	ctx.lr = 0x828B6AD8;
	sub_82DF3A08(ctx, base);
	// 828B6AD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6ADC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6AE0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6AE4: 4BF33855  bl 0x827ea338
	ctx.lr = 0x828B6AE8;
	sub_827EA338(ctx, base);
	// 828B6AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6AEC: 4853C93D  bl 0x82df3428
	ctx.lr = 0x828B6AF0;
	sub_82DF3428(ctx, base);
	// 828B6AF0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6AF8: 808B2608  lwz r4, 0x2608(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9736 as u32) ) } as u64;
	// 828B6AFC: 4853CF0D  bl 0x82df3a08
	ctx.lr = 0x828B6B00;
	sub_82DF3A08(ctx, base);
	// 828B6B00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6B04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6B08: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6B0C: 4BF3382D  bl 0x827ea338
	ctx.lr = 0x828B6B10;
	sub_827EA338(ctx, base);
	// 828B6B10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B14: 4853C915  bl 0x82df3428
	ctx.lr = 0x828B6B18;
	sub_82DF3428(ctx, base);
	// 828B6B18: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6B1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B20: 808B2604  lwz r4, 0x2604(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) } as u64;
	// 828B6B24: 4853CEE5  bl 0x82df3a08
	ctx.lr = 0x828B6B28;
	sub_82DF3A08(ctx, base);
	// 828B6B28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6B2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6B30: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6B34: 4BF33805  bl 0x827ea338
	ctx.lr = 0x828B6B38;
	sub_827EA338(ctx, base);
	// 828B6B38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B3C: 4853C8ED  bl 0x82df3428
	ctx.lr = 0x828B6B40;
	sub_82DF3428(ctx, base);
	// 828B6B40: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6B44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B48: 808B25EC  lwz r4, 0x25ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9708 as u32) ) } as u64;
	// 828B6B4C: 4853CEBD  bl 0x82df3a08
	ctx.lr = 0x828B6B50;
	sub_82DF3A08(ctx, base);
	// 828B6B50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6B54: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6B58: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6B5C: 4BF337DD  bl 0x827ea338
	ctx.lr = 0x828B6B60;
	sub_827EA338(ctx, base);
	// 828B6B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B64: 4853C8C5  bl 0x82df3428
	ctx.lr = 0x828B6B68;
	sub_82DF3428(ctx, base);
	// 828B6B68: 3E60832C  lis r19, -0x7cd4
	ctx.r[19].s64 = -2094268416;
	// 828B6B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B70: 809325E0  lwz r4, 0x25e0(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(9696 as u32) ) } as u64;
	// 828B6B74: 4853CE95  bl 0x82df3a08
	ctx.lr = 0x828B6B78;
	sub_82DF3A08(ctx, base);
	// 828B6B78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6B7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6B80: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6B84: 4BF337B5  bl 0x827ea338
	ctx.lr = 0x828B6B88;
	sub_827EA338(ctx, base);
	// 828B6B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B8C: 4853C89D  bl 0x82df3428
	ctx.lr = 0x828B6B90;
	sub_82DF3428(ctx, base);
	// 828B6B90: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6B94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6B98: 808B2578  lwz r4, 0x2578(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9592 as u32) ) } as u64;
	// 828B6B9C: 4853CE6D  bl 0x82df3a08
	ctx.lr = 0x828B6BA0;
	sub_82DF3A08(ctx, base);
	// 828B6BA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6BA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6BA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6BAC: 4BF3378D  bl 0x827ea338
	ctx.lr = 0x828B6BB0;
	sub_827EA338(ctx, base);
	// 828B6BB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6BB4: 4853C875  bl 0x82df3428
	ctx.lr = 0x828B6BB8;
	sub_82DF3428(ctx, base);
	// 828B6BB8: 3E40832C  lis r18, -0x7cd4
	ctx.r[18].s64 = -2094268416;
	// 828B6BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6BC0: 8092257C  lwz r4, 0x257c(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(9596 as u32) ) } as u64;
	// 828B6BC4: 4853CE45  bl 0x82df3a08
	ctx.lr = 0x828B6BC8;
	sub_82DF3A08(ctx, base);
	// 828B6BC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B6BCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6BD0: C3AB6150  lfs f29, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B6BD4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6BD8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B6BDC: 4BF3375D  bl 0x827ea338
	ctx.lr = 0x828B6BE0;
	sub_827EA338(ctx, base);
	// 828B6BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6BE4: 4853C845  bl 0x82df3428
	ctx.lr = 0x828B6BE8;
	sub_82DF3428(ctx, base);
	// 828B6BE8: 3E00832C  lis r16, -0x7cd4
	ctx.r[16].s64 = -2094268416;
	// 828B6BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6BF0: 80902588  lwz r4, 0x2588(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(9608 as u32) ) } as u64;
	// 828B6BF4: 4853CE15  bl 0x82df3a08
	ctx.lr = 0x828B6BF8;
	sub_82DF3A08(ctx, base);
	// 828B6BF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6BFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C00: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6C04: 4BF33735  bl 0x827ea338
	ctx.lr = 0x828B6C08;
	sub_827EA338(ctx, base);
	// 828B6C08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C0C: 4853C81D  bl 0x82df3428
	ctx.lr = 0x828B6C10;
	sub_82DF3428(ctx, base);
	// 828B6C10: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6C14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C18: 808B25BC  lwz r4, 0x25bc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9660 as u32) ) } as u64;
	// 828B6C1C: 4853CDED  bl 0x82df3a08
	ctx.lr = 0x828B6C20;
	sub_82DF3A08(ctx, base);
	// 828B6C20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6C24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C28: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6C2C: 4BF3370D  bl 0x827ea338
	ctx.lr = 0x828B6C30;
	sub_827EA338(ctx, base);
	// 828B6C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C34: 4853C7F5  bl 0x82df3428
	ctx.lr = 0x828B6C38;
	sub_82DF3428(ctx, base);
	// 828B6C38: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6C3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C40: 808B25DC  lwz r4, 0x25dc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9692 as u32) ) } as u64;
	// 828B6C44: 4853CDC5  bl 0x82df3a08
	ctx.lr = 0x828B6C48;
	sub_82DF3A08(ctx, base);
	// 828B6C48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B6C4C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6C54: 3B8BAFAC  addi r28, r11, -0x5054
	ctx.r[28].s64 = ctx.r[11].s64 + -20564;
	// 828B6C58: C03C0004  lfs f1, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B6C5C: 4BF336DD  bl 0x827ea338
	ctx.lr = 0x828B6C60;
	sub_827EA338(ctx, base);
	// 828B6C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C64: 4853C7C5  bl 0x82df3428
	ctx.lr = 0x828B6C68;
	sub_82DF3428(ctx, base);
	// 828B6C68: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6C6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C70: 808B25D8  lwz r4, 0x25d8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9688 as u32) ) } as u64;
	// 828B6C74: 4853CD95  bl 0x82df3a08
	ctx.lr = 0x828B6C78;
	sub_82DF3A08(ctx, base);
	// 828B6C78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6C7C: C03C0004  lfs f1, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B6C80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C84: 4BF336B5  bl 0x827ea338
	ctx.lr = 0x828B6C88;
	sub_827EA338(ctx, base);
	// 828B6C88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C8C: 4853C79D  bl 0x82df3428
	ctx.lr = 0x828B6C90;
	sub_82DF3428(ctx, base);
	// 828B6C90: 3F00832C  lis r24, -0x7cd4
	ctx.r[24].s64 = -2094268416;
	// 828B6C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6C98: 80982570  lwz r4, 0x2570(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828B6C9C: 4853CD6D  bl 0x82df3a08
	ctx.lr = 0x828B6CA0;
	sub_82DF3A08(ctx, base);
	// 828B6CA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6CA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CA8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6CAC: 4BF3368D  bl 0x827ea338
	ctx.lr = 0x828B6CB0;
	sub_827EA338(ctx, base);
	// 828B6CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6CB4: 4853C775  bl 0x82df3428
	ctx.lr = 0x828B6CB8;
	sub_82DF3428(ctx, base);
	// 828B6CB8: 3F60832C  lis r27, -0x7cd4
	ctx.r[27].s64 = -2094268416;
	// 828B6CBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6CC0: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B6CC4: 4853CD45  bl 0x82df3a08
	ctx.lr = 0x828B6CC8;
	sub_82DF3A08(ctx, base);
	// 828B6CC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6CCC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CD0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6CD4: 4BF33665  bl 0x827ea338
	ctx.lr = 0x828B6CD8;
	sub_827EA338(ctx, base);
	// 828B6CD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6CDC: 4853C74D  bl 0x82df3428
	ctx.lr = 0x828B6CE0;
	sub_82DF3428(ctx, base);
	// 828B6CE0: 3EE0832C  lis r23, -0x7cd4
	ctx.r[23].s64 = -2094268416;
	// 828B6CE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6CE8: 809725AC  lwz r4, 0x25ac(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(9644 as u32) ) } as u64;
	// 828B6CEC: 4853CD1D  bl 0x82df3a08
	ctx.lr = 0x828B6CF0;
	sub_82DF3A08(ctx, base);
	// 828B6CF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6CF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CF8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B6CFC: 4BF3363D  bl 0x827ea338
	ctx.lr = 0x828B6D00;
	sub_827EA338(ctx, base);
	// 828B6D00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D04: 4853C725  bl 0x82df3428
	ctx.lr = 0x828B6D08;
	sub_82DF3428(ctx, base);
	// 828B6D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D0C: 809A25B4  lwz r4, 0x25b4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(9652 as u32) ) } as u64;
	// 828B6D10: 4853CCF9  bl 0x82df3a08
	ctx.lr = 0x828B6D14;
	sub_82DF3A08(ctx, base);
	// 828B6D14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B6D18: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6D20: C3AB964C  lfs f29, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B6D24: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B6D28: 4BF33611  bl 0x827ea338
	ctx.lr = 0x828B6D2C;
	sub_827EA338(ctx, base);
	// 828B6D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D30: 4853C6F9  bl 0x82df3428
	ctx.lr = 0x828B6D34;
	sub_82DF3428(ctx, base);
	// 828B6D34: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D3C: 808B25C4  lwz r4, 0x25c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9668 as u32) ) } as u64;
	// 828B6D40: 4853CCC9  bl 0x82df3a08
	ctx.lr = 0x828B6D44;
	sub_82DF3A08(ctx, base);
	// 828B6D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6D48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D4C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6D50: 4BF335E9  bl 0x827ea338
	ctx.lr = 0x828B6D54;
	sub_827EA338(ctx, base);
	// 828B6D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D58: 4853C6D1  bl 0x82df3428
	ctx.lr = 0x828B6D5C;
	sub_82DF3428(ctx, base);
	// 828B6D5C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D64: 808B25C0  lwz r4, 0x25c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9664 as u32) ) } as u64;
	// 828B6D68: 4853CCA1  bl 0x82df3a08
	ctx.lr = 0x828B6D6C;
	sub_82DF3A08(ctx, base);
	// 828B6D6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6D70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D74: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6D78: 4BF335C1  bl 0x827ea338
	ctx.lr = 0x828B6D7C;
	sub_827EA338(ctx, base);
	// 828B6D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D80: 4853C6A9  bl 0x82df3428
	ctx.lr = 0x828B6D84;
	sub_82DF3428(ctx, base);
	// 828B6D84: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D8C: 808B25CC  lwz r4, 0x25cc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9676 as u32) ) } as u64;
	// 828B6D90: 4853CC79  bl 0x82df3a08
	ctx.lr = 0x828B6D94;
	sub_82DF3A08(ctx, base);
	// 828B6D94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6D98: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D9C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6DA0: 4BF33599  bl 0x827ea338
	ctx.lr = 0x828B6DA4;
	sub_827EA338(ctx, base);
	// 828B6DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6DA8: 4853C681  bl 0x82df3428
	ctx.lr = 0x828B6DAC;
	sub_82DF3428(ctx, base);
	// 828B6DAC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6DB4: 808B25C8  lwz r4, 0x25c8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9672 as u32) ) } as u64;
	// 828B6DB8: 4853CC51  bl 0x82df3a08
	ctx.lr = 0x828B6DBC;
	sub_82DF3A08(ctx, base);
	// 828B6DBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6DC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6DC4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6DC8: 4BF33571  bl 0x827ea338
	ctx.lr = 0x828B6DCC;
	sub_827EA338(ctx, base);
	// 828B6DCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6DD0: 4853C659  bl 0x82df3428
	ctx.lr = 0x828B6DD4;
	sub_82DF3428(ctx, base);
	// 828B6DD4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6DDC: 808B25D0  lwz r4, 0x25d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9680 as u32) ) } as u64;
	// 828B6DE0: 4853CC29  bl 0x82df3a08
	ctx.lr = 0x828B6DE4;
	sub_82DF3A08(ctx, base);
	// 828B6DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6DE8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6DEC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6DF0: 4BF33549  bl 0x827ea338
	ctx.lr = 0x828B6DF4;
	sub_827EA338(ctx, base);
	// 828B6DF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6DF8: 4853C631  bl 0x82df3428
	ctx.lr = 0x828B6DFC;
	sub_82DF3428(ctx, base);
	// 828B6DFC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E04: 808B25D4  lwz r4, 0x25d4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9684 as u32) ) } as u64;
	// 828B6E08: 4853CC01  bl 0x82df3a08
	ctx.lr = 0x828B6E0C;
	sub_82DF3A08(ctx, base);
	// 828B6E0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6E10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6E14: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6E18: 4BF33521  bl 0x827ea338
	ctx.lr = 0x828B6E1C;
	sub_827EA338(ctx, base);
	// 828B6E1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E20: 4853C609  bl 0x82df3428
	ctx.lr = 0x828B6E24;
	sub_82DF3428(ctx, base);
	// 828B6E24: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B6E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E2C: 808B25A8  lwz r4, 0x25a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9640 as u32) ) } as u64;
	// 828B6E30: 4853CBD9  bl 0x82df3a08
	ctx.lr = 0x828B6E34;
	sub_82DF3A08(ctx, base);
	// 828B6E34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6E38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6E3C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828B6E40: 4BF334F9  bl 0x827ea338
	ctx.lr = 0x828B6E44;
	sub_827EA338(ctx, base);
	// 828B6E44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E48: 4853C5E1  bl 0x82df3428
	ctx.lr = 0x828B6E4C;
	sub_82DF3428(ctx, base);
	// 828B6E4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6E50: 809925B8  lwz r4, 0x25b8(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828B6E54: 4853CBB5  bl 0x82df3a08
	ctx.lr = 0x828B6E58;
	sub_82DF3A08(ctx, base);
	// 828B6E58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B6E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E60: 3AABB51C  addi r21, r11, -0x4ae4
	ctx.r[21].s64 = ctx.r[11].s64 + -19172;
	// 828B6E64: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828B6E68: 4853CBA1  bl 0x82df3a08
	ctx.lr = 0x828B6E6C;
	sub_82DF3A08(ctx, base);
	// 828B6E6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B6E70: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B6E74: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6E78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6E7C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6E80: 4BF334D9  bl 0x827ea358
	ctx.lr = 0x828B6E84;
	sub_827EA358(ctx, base);
	// 828B6E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E88: 4853C5A1  bl 0x82df3428
	ctx.lr = 0x828B6E8C;
	sub_82DF3428(ctx, base);
	// 828B6E8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6E90: 4853C599  bl 0x82df3428
	ctx.lr = 0x828B6E94;
	sub_82DF3428(ctx, base);
	// 828B6E94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6E98: 809925B8  lwz r4, 0x25b8(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828B6E9C: 4853CB6D  bl 0x82df3a08
	ctx.lr = 0x828B6EA0;
	sub_82DF3A08(ctx, base);
	// 828B6EA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B6EA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6EA8: 3A8BB504  addi r20, r11, -0x4afc
	ctx.r[20].s64 = ctx.r[11].s64 + -19196;
	// 828B6EAC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828B6EB0: 4853CB59  bl 0x82df3a08
	ctx.lr = 0x828B6EB4;
	sub_82DF3A08(ctx, base);
	// 828B6EB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B6EB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B6EBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6EC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6EC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6EC8: 4BF33491  bl 0x827ea358
	ctx.lr = 0x828B6ECC;
	sub_827EA358(ctx, base);
	// 828B6ECC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6ED0: 4853C559  bl 0x82df3428
	ctx.lr = 0x828B6ED4;
	sub_82DF3428(ctx, base);
	// 828B6ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6ED8: 4853C551  bl 0x82df3428
	ctx.lr = 0x828B6EDC;
	sub_82DF3428(ctx, base);
	// 828B6EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6EE0: 809925B8  lwz r4, 0x25b8(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828B6EE4: 4853CB25  bl 0x82df3a08
	ctx.lr = 0x828B6EE8;
	sub_82DF3A08(ctx, base);
	// 828B6EE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B6EEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6EF0: 3B2BB4EC  addi r25, r11, -0x4b14
	ctx.r[25].s64 = ctx.r[11].s64 + -19220;
	// 828B6EF4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B6EF8: 4853CB11  bl 0x82df3a08
	ctx.lr = 0x828B6EFC;
	sub_82DF3A08(ctx, base);
	// 828B6EFC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B6F00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B6F04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6F08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6F0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B6F10: 4BF33449  bl 0x827ea358
	ctx.lr = 0x828B6F14;
	sub_827EA358(ctx, base);
	// 828B6F14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6F18: 4853C511  bl 0x82df3428
	ctx.lr = 0x828B6F1C;
	sub_82DF3428(ctx, base);
	// 828B6F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6F20: 4853C509  bl 0x82df3428
	ctx.lr = 0x828B6F24;
	sub_82DF3428(ctx, base);
	// 828B6F24: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B6F28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6F2C: 809625A0  lwz r4, 0x25a0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(9632 as u32) ) } as u64;
	// 828B6F30: 396B3F50  addi r11, r11, 0x3f50
	ctx.r[11].s64 = ctx.r[11].s64 + 16208;
	// 828B6F34: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828B6F38: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6F3C: 4853CACD  bl 0x82df3a08
	ctx.lr = 0x828B6F40;
	sub_82DF3A08(ctx, base);
	// 828B6F40: D3C10070  stfs f30, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B6F44: 80E10070  lwz r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B6F48: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B6F4C: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B6F50: D3A10050  stfs f29, 0x50(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828B6F54: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B6F58: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B6F5C: 80A10070  lwz r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B6F60: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828B6F64: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828B6F68: 392100E8  addi r9, r1, 0xe8
	ctx.r[9].s64 = ctx.r[1].s64 + 232;
	// 828B6F6C: 90E1008C  stw r7, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[7].u32 ) };
	// 828B6F70: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828B6F74: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828B6F78: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828B6F7C: 90A10088  stw r5, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[5].u32 ) };
	// 828B6F80: F8C100E0  std r6, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[6].u64 ) };
	// 828B6F84: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 828B6F88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B6F8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6F90: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B6F94: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B6F98: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828B6F9C: 4200FFF0  bdnz 0x828b6f8c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828B6F8C; continue 'dispatch;
	}
	// 828B6FA0: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B6FA4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B6FA8: E88100E0  ld r4, 0xe0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828B6FAC: E8A100E8  ld r5, 0xe8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 828B6FB0: E8C100F0  ld r6, 0xf0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 828B6FB4: E8E100F8  ld r7, 0xf8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 828B6FB8: 4BFFF5B1  bl 0x828b6568
	ctx.lr = 0x828B6FBC;
	sub_828B6568(ctx, base);
	// 828B6FBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B6FC0: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B6FC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6FC8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6FCC: C02B3364  lfs f1, 0x3364(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B6FD0: 4BF337E1  bl 0x827ea7b0
	ctx.lr = 0x828B6FD4;
	sub_827EA7B0(ctx, base);
	// 828B6FD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6FD8: 4853C451  bl 0x82df3428
	ctx.lr = 0x828B6FDC;
	sub_82DF3428(ctx, base);
	// 828B6FDC: 3D608295  lis r11, -0x7d6b
	ctx.r[11].s64 = -2104164352;
	// 828B6FE0: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 828B6FE4: 80982570  lwz r4, 0x2570(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828B6FE8: 396B6890  addi r11, r11, 0x6890
	ctx.r[11].s64 = ctx.r[11].s64 + 26768;
	// 828B6FEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6FF0: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 828B6FF4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B6FF8: 4853CA11  bl 0x82df3a08
	ctx.lr = 0x828B6FFC;
	sub_82DF3A08(ctx, base);
	// 828B6FFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7000: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B7004: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828B7008: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 828B700C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B7010: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828B7014: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B7018: 4BFFF5D1  bl 0x828b65e8
	ctx.lr = 0x828B701C;
	sub_828B65E8(ctx, base);
	// 828B701C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7020: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7024: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B7028: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B702C: C3ABD72C  lfs f29, -0x28d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B7030: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B7034: 4BF3377D  bl 0x827ea7b0
	ctx.lr = 0x828B7038;
	sub_827EA7B0(ctx, base);
	// 828B7038: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B703C: 4853C3ED  bl 0x82df3428
	ctx.lr = 0x828B7040;
	sub_82DF3428(ctx, base);
	// 828B7040: 3D608295  lis r11, -0x7d6b
	ctx.r[11].s64 = -2104164352;
	// 828B7044: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7048: 80982570  lwz r4, 0x2570(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828B704C: 396B6890  addi r11, r11, 0x6890
	ctx.r[11].s64 = ctx.r[11].s64 + 26768;
	// 828B7050: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 828B7054: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B7058: 4853C9B1  bl 0x82df3a08
	ctx.lr = 0x828B705C;
	sub_82DF3A08(ctx, base);
	// 828B705C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B7060: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828B7064: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B7068: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B706C: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 828B7070: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828B7074: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B7078: 4BFFF571  bl 0x828b65e8
	ctx.lr = 0x828B707C;
	sub_828B65E8(ctx, base);
	// 828B707C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7080: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7084: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B7088: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B708C: C02BEF50  lfs f1, -0x10b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B7090: 4BF33721  bl 0x827ea7b0
	ctx.lr = 0x828B7094;
	sub_827EA7B0(ctx, base);
	// 828B7094: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7098: 4853C391  bl 0x82df3428
	ctx.lr = 0x828B709C;
	sub_82DF3428(ctx, base);
	// 828B709C: 3D608295  lis r11, -0x7d6b
	ctx.r[11].s64 = -2104164352;
	// 828B70A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B70A4: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B70A8: 396B6890  addi r11, r11, 0x6890
	ctx.r[11].s64 = ctx.r[11].s64 + 26768;
	// 828B70AC: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 828B70B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B70B4: 4853C955  bl 0x82df3a08
	ctx.lr = 0x828B70B8;
	sub_82DF3A08(ctx, base);
	// 828B70B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B70BC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B70C0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B70C4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828B70C8: 99610064  stb r11, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 828B70CC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B70D0: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B70D4: 4BFFF515  bl 0x828b65e8
	ctx.lr = 0x828B70D8;
	sub_828B65E8(ctx, base);
	// 828B70D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B70DC: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B70E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B70E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B70E8: 4BF336C9  bl 0x827ea7b0
	ctx.lr = 0x828B70EC;
	sub_827EA7B0(ctx, base);
	// 828B70EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B70F0: 4853C339  bl 0x82df3428
	ctx.lr = 0x828B70F4;
	sub_82DF3428(ctx, base);
	// 828B70F4: 3D608295  lis r11, -0x7d6b
	ctx.r[11].s64 = -2104164352;
	// 828B70F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B70FC: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B7100: 396B6890  addi r11, r11, 0x6890
	ctx.r[11].s64 = ctx.r[11].s64 + 26768;
	// 828B7104: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 828B7108: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B710C: 4853C8FD  bl 0x82df3a08
	ctx.lr = 0x828B7110;
	sub_82DF3A08(ctx, base);
	// 828B7110: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B7114: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828B7118: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B711C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B7120: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 828B7124: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828B7128: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B712C: 4BFFF4BD  bl 0x828b65e8
	ctx.lr = 0x828B7130;
	sub_828B65E8(ctx, base);
	// 828B7130: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7134: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7138: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B713C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7140: C02B967C  lfs f1, -0x6984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B7144: 4BF3366D  bl 0x827ea7b0
	ctx.lr = 0x828B7148;
	sub_827EA7B0(ctx, base);
	// 828B7148: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B714C: 4853C2DD  bl 0x82df3428
	ctx.lr = 0x828B7150;
	sub_82DF3428(ctx, base);
	// 828B7150: 3D608295  lis r11, -0x7d6b
	ctx.r[11].s64 = -2104164352;
	// 828B7154: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7158: 809725AC  lwz r4, 0x25ac(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(9644 as u32) ) } as u64;
	// 828B715C: 396B6890  addi r11, r11, 0x6890
	ctx.r[11].s64 = ctx.r[11].s64 + 26768;
	// 828B7160: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 828B7164: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B7168: 4853C8A1  bl 0x82df3a08
	ctx.lr = 0x828B716C;
	sub_82DF3A08(ctx, base);
	// 828B716C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7170: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828B7174: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B7178: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B717C: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 828B7180: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828B7184: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B7188: 4BFFF461  bl 0x828b65e8
	ctx.lr = 0x828B718C;
	sub_828B65E8(ctx, base);
	// 828B718C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B7190: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7194: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B7198: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B719C: C02B093C  lfs f1, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B71A0: 4BF33611  bl 0x827ea7b0
	ctx.lr = 0x828B71A4;
	sub_827EA7B0(ctx, base);
	// 828B71A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B71A8: 4853C281  bl 0x82df3428
	ctx.lr = 0x828B71AC;
	sub_82DF3428(ctx, base);
	// 828B71AC: 3D608295  lis r11, -0x7d6b
	ctx.r[11].s64 = -2104164352;
	// 828B71B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B71B4: 809A25B4  lwz r4, 0x25b4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(9652 as u32) ) } as u64;
	// 828B71B8: 396B6890  addi r11, r11, 0x6890
	ctx.r[11].s64 = ctx.r[11].s64 + 26768;
	// 828B71BC: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 828B71C0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B71C4: 4853C845  bl 0x82df3a08
	ctx.lr = 0x828B71C8;
	sub_82DF3A08(ctx, base);
	// 828B71C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B71CC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828B71D0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B71D4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B71D8: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 828B71DC: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828B71E0: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828B71E4: 4BFFF405  bl 0x828b65e8
	ctx.lr = 0x828B71E8;
	sub_828B65E8(ctx, base);
	// 828B71E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B71EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B71F0: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828B71F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B71F8: C02BD7BC  lfs f1, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B71FC: 4BF335B5  bl 0x827ea7b0
	ctx.lr = 0x828B7200;
	sub_827EA7B0(ctx, base);
	// 828B7200: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7204: 4853C225  bl 0x82df3428
	ctx.lr = 0x828B7208;
	sub_82DF3428(ctx, base);
	// 828B7208: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B720C: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 828B7210: 409A0008  bne cr6, 0x828b7218
	if !ctx.cr[6].eq {
	pc = 0x828B7218; continue 'dispatch;
	}
	// 828B7214: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 828B7218: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B721C: 80982570  lwz r4, 0x2570(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828B7220: 4853C7E9  bl 0x82df3a08
	ctx.lr = 0x828B7224;
	sub_82DF3A08(ctx, base);
	// 828B7224: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B7228: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B722C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7230: 386F00F4  addi r3, r15, 0xf4
	ctx.r[3].s64 = ctx.r[15].s64 + 244;
	// 828B7234: 480A0925  bl 0x82957b58
	ctx.lr = 0x828B7238;
	sub_82957B58(ctx, base);
	// 828B7238: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B723C: 4853C1ED  bl 0x82df3428
	ctx.lr = 0x828B7240;
	sub_82DF3428(ctx, base);
	// 828B7240: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B7244: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 828B7248: 409A0008  bne cr6, 0x828b7250
	if !ctx.cr[6].eq {
	pc = 0x828B7250; continue 'dispatch;
	}
	// 828B724C: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 828B7250: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7254: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B7258: 4853C7B1  bl 0x82df3a08
	ctx.lr = 0x828B725C;
	sub_82DF3A08(ctx, base);
	// 828B725C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B7260: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B7264: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7268: 386F0134  addi r3, r15, 0x134
	ctx.r[3].s64 = ctx.r[15].s64 + 308;
	// 828B726C: 480A08ED  bl 0x82957b58
	ctx.lr = 0x828B7270;
	sub_82957B58(ctx, base);
	// 828B7270: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7274: 4853C1B5  bl 0x82df3428
	ctx.lr = 0x828B7278;
	sub_82DF3428(ctx, base);
	// 828B7278: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B727C: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 828B7280: 409A0008  bne cr6, 0x828b7288
	if !ctx.cr[6].eq {
	pc = 0x828B7288; continue 'dispatch;
	}
	// 828B7284: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 828B7288: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B728C: 809325E0  lwz r4, 0x25e0(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(9696 as u32) ) } as u64;
	// 828B7290: 4853C779  bl 0x82df3a08
	ctx.lr = 0x828B7294;
	sub_82DF3A08(ctx, base);
	// 828B7294: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B7298: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B729C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B72A0: 386F0174  addi r3, r15, 0x174
	ctx.r[3].s64 = ctx.r[15].s64 + 372;
	// 828B72A4: 480A0865  bl 0x82957b08
	ctx.lr = 0x828B72A8;
	sub_82957B08(ctx, base);
	// 828B72A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B72AC: 4853C17D  bl 0x82df3428
	ctx.lr = 0x828B72B0;
	sub_82DF3428(ctx, base);
	// 828B72B0: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B72B4: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 828B72B8: 409A0008  bne cr6, 0x828b72c0
	if !ctx.cr[6].eq {
	pc = 0x828B72C0; continue 'dispatch;
	}
	// 828B72BC: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 828B72C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B72C4: 8092257C  lwz r4, 0x257c(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(9596 as u32) ) } as u64;
	// 828B72C8: 4853C741  bl 0x82df3a08
	ctx.lr = 0x828B72CC;
	sub_82DF3A08(ctx, base);
	// 828B72CC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B72D0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B72D4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B72D8: 386F0198  addi r3, r15, 0x198
	ctx.r[3].s64 = ctx.r[15].s64 + 408;
	// 828B72DC: 480A082D  bl 0x82957b08
	ctx.lr = 0x828B72E0;
	sub_82957B08(ctx, base);
	// 828B72E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B72E4: 4853C145  bl 0x82df3428
	ctx.lr = 0x828B72E8;
	sub_82DF3428(ctx, base);
	// 828B72E8: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B72EC: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 828B72F0: 409A0008  bne cr6, 0x828b72f8
	if !ctx.cr[6].eq {
	pc = 0x828B72F8; continue 'dispatch;
	}
	// 828B72F4: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 828B72F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B72FC: 80902588  lwz r4, 0x2588(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(9608 as u32) ) } as u64;
	// 828B7300: 4853C709  bl 0x82df3a08
	ctx.lr = 0x828B7304;
	sub_82DF3A08(ctx, base);
	// 828B7304: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B7308: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B730C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7310: 386F01BC  addi r3, r15, 0x1bc
	ctx.r[3].s64 = ctx.r[15].s64 + 444;
	// 828B7314: 480A07F5  bl 0x82957b08
	ctx.lr = 0x828B7318;
	sub_82957B08(ctx, base);
	// 828B7318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B731C: 4853C10D  bl 0x82df3428
	ctx.lr = 0x828B7320;
	sub_82DF3428(ctx, base);
	// 828B7320: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B7324: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 828B7328: 409A0008  bne cr6, 0x828b7330
	if !ctx.cr[6].eq {
	pc = 0x828B7330; continue 'dispatch;
	}
	// 828B732C: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 828B7330: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7334: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7338: 808B2584  lwz r4, 0x2584(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9604 as u32) ) } as u64;
	// 828B733C: 4853C6CD  bl 0x82df3a08
	ctx.lr = 0x828B7340;
	sub_82DF3A08(ctx, base);
	// 828B7340: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B7344: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7348: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B734C: 386F01E0  addi r3, r15, 0x1e0
	ctx.r[3].s64 = ctx.r[15].s64 + 480;
	// 828B7350: 480A07B9  bl 0x82957b08
	ctx.lr = 0x828B7354;
	sub_82957B08(ctx, base);
	// 828B7354: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7358: 4853C0D1  bl 0x82df3428
	ctx.lr = 0x828B735C;
	sub_82DF3428(ctx, base);
	// 828B735C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7360: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7364: 80982570  lwz r4, 0x2570(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828B7368: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B736C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7370: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7374: 4853C695  bl 0x82df3a08
	ctx.lr = 0x828B7378;
	sub_82DF3A08(ctx, base);
	// 828B7378: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B737C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7380: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7384: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B7388: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828B738C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B7390: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828B7394: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B7398: 3B4AF818  addi r26, r10, -0x7e8
	ctx.r[26].s64 = ctx.r[10].s64 + -2024;
	// 828B739C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B73A0: C3CBA1C4  lfs f30, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B73A4: 914100F0  stw r10, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 828B73A8: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B73AC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B73B0: 934100E4  stw r26, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[26].u32 ) };
	// 828B73B4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B73B8: 914100EC  stw r10, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 828B73BC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B73C0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B73C4: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B73C8: 912100E8  stw r9, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 828B73CC: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 828B73D0: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B73D4: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B73D8: 488F1139  bl 0x831a8510
	ctx.lr = 0x828B73DC;
	sub_831A8510(ctx, base);
	// 828B73DC: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B73E0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B73E4: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B73E8: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B73EC: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B73F0: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B73F4: 4BFFF275  bl 0x828b6668
	ctx.lr = 0x828B73F8;
	sub_828B6668(ctx, base);
	// 828B73F8: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B73FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7400: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7404: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B7408: 4BF333A9  bl 0x827ea7b0
	ctx.lr = 0x828B740C;
	sub_827EA7B0(ctx, base);
	// 828B740C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7410: 4853C019  bl 0x82df3428
	ctx.lr = 0x828B7414;
	sub_82DF3428(ctx, base);
	// 828B7414: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7418: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B741C: 80982570  lwz r4, 0x2570(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828B7420: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7424: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7428: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B742C: 4853C5DD  bl 0x82df3a08
	ctx.lr = 0x828B7430;
	sub_82DF3A08(ctx, base);
	// 828B7430: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7434: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7438: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B743C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B7440: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7444: 4BFFF2A5  bl 0x828b66e8
	ctx.lr = 0x828B7448;
	sub_828B66E8(ctx, base);
	// 828B7448: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B744C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7450: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7454: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7458: C02BB4E8  lfs f1, -0x4b18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19224 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B745C: 4BF33355  bl 0x827ea7b0
	ctx.lr = 0x828B7460;
	sub_827EA7B0(ctx, base);
	// 828B7460: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7464: 4853BFC5  bl 0x82df3428
	ctx.lr = 0x828B7468;
	sub_82DF3428(ctx, base);
	// 828B7468: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B746C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7470: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7474: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7478: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B747C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7480: 4853C589  bl 0x82df3a08
	ctx.lr = 0x828B7484;
	sub_82DF3A08(ctx, base);
	// 828B7484: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7488: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B748C: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7490: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B7494: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7498: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 828B749C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B74A0: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B74A4: 3908F820  addi r8, r8, -0x7e0
	ctx.r[8].s64 = ctx.r[8].s64 + -2016;
	// 828B74A8: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B74AC: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B74B0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B74B4: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 828B74B8: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B74BC: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B74C0: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B74C4: 910100E4  stw r8, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 828B74C8: 90E100E8  stw r7, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[7].u32 ) };
	// 828B74CC: 914100EC  stw r10, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 828B74D0: 912100F4  stw r9, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 828B74D4: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B74D8: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B74DC: 488F1035  bl 0x831a8510
	ctx.lr = 0x828B74E0;
	sub_831A8510(ctx, base);
	// 828B74E0: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B74E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B74E8: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B74EC: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B74F0: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B74F4: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B74F8: 4BFFF171  bl 0x828b6668
	ctx.lr = 0x828B74FC;
	sub_828B6668(ctx, base);
	// 828B74FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7500: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7504: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7508: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B750C: C3ABE25C  lfs f29, -0x1da4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7588 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B7510: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B7514: 4BF3329D  bl 0x827ea7b0
	ctx.lr = 0x828B7518;
	sub_827EA7B0(ctx, base);
	// 828B7518: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B751C: 4853BF0D  bl 0x82df3428
	ctx.lr = 0x828B7520;
	sub_82DF3428(ctx, base);
	// 828B7520: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7524: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7528: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B752C: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7530: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7534: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7538: 4853C4D1  bl 0x82df3a08
	ctx.lr = 0x828B753C;
	sub_82DF3A08(ctx, base);
	// 828B753C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7540: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7544: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7548: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B754C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7550: 4BFFF199  bl 0x828b66e8
	ctx.lr = 0x828B7554;
	sub_828B66E8(ctx, base);
	// 828B7554: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B7558: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B755C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7560: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7564: C38BB4E4  lfs f28, -0x4b1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19228 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828B7568: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828B756C: 4BF33245  bl 0x827ea7b0
	ctx.lr = 0x828B7570;
	sub_827EA7B0(ctx, base);
	// 828B7570: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7574: 4853BEB5  bl 0x82df3428
	ctx.lr = 0x828B7578;
	sub_82DF3428(ctx, base);
	// 828B7578: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B757C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7580: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B7584: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7588: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B758C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7590: 4853C479  bl 0x82df3a08
	ctx.lr = 0x828B7594;
	sub_82DF3A08(ctx, base);
	// 828B7594: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7598: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B759C: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B75A0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B75A4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B75A8: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B75AC: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B75B0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B75B4: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B75B8: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828B75BC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B75C0: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B75C4: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B75C8: 934100E4  stw r26, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[26].u32 ) };
	// 828B75CC: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B75D0: 910100E8  stw r8, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 828B75D4: 914100F4  stw r10, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 828B75D8: 912100F0  stw r9, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[9].u32 ) };
	// 828B75DC: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B75E0: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B75E4: 488F0F2D  bl 0x831a8510
	ctx.lr = 0x828B75E8;
	sub_831A8510(ctx, base);
	// 828B75E8: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B75EC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B75F0: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B75F4: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B75F8: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B75FC: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B7600: 4BFFF069  bl 0x828b6668
	ctx.lr = 0x828B7604;
	sub_828B6668(ctx, base);
	// 828B7604: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7608: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B760C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7610: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B7614: 4BF3319D  bl 0x827ea7b0
	ctx.lr = 0x828B7618;
	sub_827EA7B0(ctx, base);
	// 828B7618: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B761C: 4853BE0D  bl 0x82df3428
	ctx.lr = 0x828B7620;
	sub_82DF3428(ctx, base);
	// 828B7620: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7624: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7628: 809B2574  lwz r4, 0x2574(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828B762C: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7630: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7634: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7638: 4853C3D1  bl 0x82df3a08
	ctx.lr = 0x828B763C;
	sub_82DF3A08(ctx, base);
	// 828B763C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7640: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7644: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7648: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B764C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7650: 4BFFF099  bl 0x828b66e8
	ctx.lr = 0x828B7654;
	sub_828B66E8(ctx, base);
	// 828B7654: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7658: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B765C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7660: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828B7664: 4BF3314D  bl 0x827ea7b0
	ctx.lr = 0x828B7668;
	sub_827EA7B0(ctx, base);
	// 828B7668: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B766C: 4853BDBD  bl 0x82df3428
	ctx.lr = 0x828B7670;
	sub_82DF3428(ctx, base);
	// 828B7670: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7674: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828B7678: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B767C: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7680: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7684: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7688: 4853C381  bl 0x82df3a08
	ctx.lr = 0x828B768C;
	sub_82DF3A08(ctx, base);
	// 828B768C: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7690: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B7694: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7698: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B769C: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B76A0: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B76A4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B76A8: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B76AC: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B76B0: 910100F0  stw r8, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[8].u32 ) };
	// 828B76B4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B76B8: 81010070  lwz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B76BC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B76C0: 934100E4  stw r26, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[26].u32 ) };
	// 828B76C4: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B76C8: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828B76CC: 914100E8  stw r10, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 828B76D0: E9210080  ld r9, 0x80(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B76D4: 910100F4  stw r8, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[8].u32 ) };
	// 828B76D8: F92100C0  std r9, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[9].u64 ) };
	// 828B76DC: 488F0E35  bl 0x831a8510
	ctx.lr = 0x828B76E0;
	sub_831A8510(ctx, base);
	// 828B76E0: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B76E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B76E8: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B76EC: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B76F0: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B76F4: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B76F8: 4BFFEF71  bl 0x828b6668
	ctx.lr = 0x828B76FC;
	sub_828B6668(ctx, base);
	// 828B76FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7700: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7704: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7708: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B770C: C34B0A98  lfs f26, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 828B7710: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 828B7714: 4BF3309D  bl 0x827ea7b0
	ctx.lr = 0x828B7718;
	sub_827EA7B0(ctx, base);
	// 828B7718: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B771C: 4853BD0D  bl 0x82df3428
	ctx.lr = 0x828B7720;
	sub_82DF3428(ctx, base);
	// 828B7720: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7724: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828B7728: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B772C: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7730: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7734: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7738: 4853C2D1  bl 0x82df3a08
	ctx.lr = 0x828B773C;
	sub_82DF3A08(ctx, base);
	// 828B773C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7740: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7744: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7748: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B774C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7750: 4BFFEF99  bl 0x828b66e8
	ctx.lr = 0x828B7754;
	sub_828B66E8(ctx, base);
	// 828B7754: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7758: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B775C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7760: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7764: C02B9D1C  lfs f1, -0x62e4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B7768: 4BF33049  bl 0x827ea7b0
	ctx.lr = 0x828B776C;
	sub_827EA7B0(ctx, base);
	// 828B776C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7770: 4853BCB9  bl 0x82df3428
	ctx.lr = 0x828B7774;
	sub_82DF3428(ctx, base);
	// 828B7774: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7778: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828B777C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7780: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7784: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7788: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B778C: 4853C27D  bl 0x82df3a08
	ctx.lr = 0x828B7790;
	sub_82DF3A08(ctx, base);
	// 828B7790: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7794: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B7798: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B779C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B77A0: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B77A4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B77A8: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B77AC: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B77B0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B77B4: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 828B77B8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B77BC: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B77C0: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B77C4: 934100E4  stw r26, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[26].u32 ) };
	// 828B77C8: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B77CC: 910100E8  stw r8, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 828B77D0: 912100F4  stw r9, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 828B77D4: 914100EC  stw r10, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 828B77D8: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B77DC: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B77E0: 488F0D31  bl 0x831a8510
	ctx.lr = 0x828B77E4;
	sub_831A8510(ctx, base);
	// 828B77E4: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B77E8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B77EC: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B77F0: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B77F4: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B77F8: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B77FC: 4BFFEE6D  bl 0x828b6668
	ctx.lr = 0x828B7800;
	sub_828B6668(ctx, base);
	// 828B7800: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7804: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7808: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B780C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7810: C02B9590  lfs f1, -0x6a70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B7814: 4BF32F9D  bl 0x827ea7b0
	ctx.lr = 0x828B7818;
	sub_827EA7B0(ctx, base);
	// 828B7818: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B781C: 4853BC0D  bl 0x82df3428
	ctx.lr = 0x828B7820;
	sub_82DF3428(ctx, base);
	// 828B7820: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7824: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828B7828: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B782C: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7834: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7838: 4853C1D1  bl 0x82df3a08
	ctx.lr = 0x828B783C;
	sub_82DF3A08(ctx, base);
	// 828B783C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7840: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7844: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7848: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B784C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7850: 4BFFEE99  bl 0x828b66e8
	ctx.lr = 0x828B7854;
	sub_828B66E8(ctx, base);
	// 828B7854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B7858: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B785C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7860: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7864: C02B0940  lfs f1, 0x940(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2368 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B7868: 4BF32F49  bl 0x827ea7b0
	ctx.lr = 0x828B786C;
	sub_827EA7B0(ctx, base);
	// 828B786C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7870: 4853BBB9  bl 0x82df3428
	ctx.lr = 0x828B7874;
	sub_82DF3428(ctx, base);
	// 828B7874: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7878: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B787C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7880: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7884: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7888: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B788C: 4853C17D  bl 0x82df3a08
	ctx.lr = 0x828B7890;
	sub_82DF3A08(ctx, base);
	// 828B7890: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B7894: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7898: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B789C: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B78A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B78A4: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B78A8: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 828B78AC: 910100E8  stw r8, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 828B78B0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B78B4: 81010070  lwz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B78B8: C3AAFD2C  lfs f29, -0x2d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-724 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B78BC: 39293F2C  addi r9, r9, 0x3f2c
	ctx.r[9].s64 = ctx.r[9].s64 + 16172;
	// 828B78C0: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B78C4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B78C8: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B78CC: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 828B78D0: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B78D4: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B78D8: 912100E4  stw r9, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 828B78DC: 914100F0  stw r10, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 828B78E0: 910100EC  stw r8, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[8].u32 ) };
	// 828B78E4: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B78E8: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B78EC: 488F0C25  bl 0x831a8510
	ctx.lr = 0x828B78F0;
	sub_831A8510(ctx, base);
	// 828B78F0: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B78F4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B78F8: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B78FC: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B7900: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B7904: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B7908: 4BFFED61  bl 0x828b6668
	ctx.lr = 0x828B790C;
	sub_828B6668(ctx, base);
	// 828B790C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B7910: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7914: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7918: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B791C: C38B2784  lfs f28, 0x2784(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10116 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828B7920: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828B7924: 4BF32E8D  bl 0x827ea7b0
	ctx.lr = 0x828B7928;
	sub_827EA7B0(ctx, base);
	// 828B7928: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B792C: 4853BAFD  bl 0x82df3428
	ctx.lr = 0x828B7930;
	sub_82DF3428(ctx, base);
	// 828B7930: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7934: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B7938: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B793C: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7940: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7944: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7948: 4853C0C1  bl 0x82df3a08
	ctx.lr = 0x828B794C;
	sub_82DF3A08(ctx, base);
	// 828B794C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7950: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 828B7954: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7958: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 828B795C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7960: 4BFFED89  bl 0x828b66e8
	ctx.lr = 0x828B7964;
	sub_828B66E8(ctx, base);
	// 828B7964: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B7968: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B796C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7970: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7974: C36B8DC0  lfs f27, -0x7240(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29248 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828B7978: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 828B797C: 4BF32E35  bl 0x827ea7b0
	ctx.lr = 0x828B7980;
	sub_827EA7B0(ctx, base);
	// 828B7980: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7984: 4853BAA5  bl 0x82df3428
	ctx.lr = 0x828B7988;
	sub_82DF3428(ctx, base);
	// 828B7988: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B798C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B7990: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7994: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7998: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B799C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B79A0: 4853C069  bl 0x82df3a08
	ctx.lr = 0x828B79A4;
	sub_82DF3A08(ctx, base);
	// 828B79A4: D3C10060  stfs f30, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B79A8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B79AC: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B79B0: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B79B4: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B79B8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B79BC: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828B79C0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B79C4: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 828B79C8: 39292DB8  addi r9, r9, 0x2db8
	ctx.r[9].s64 = ctx.r[9].s64 + 11704;
	// 828B79CC: 910100F0  stw r8, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[8].u32 ) };
	// 828B79D0: 81010070  lwz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B79D4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B79D8: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B79DC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B79E0: 912100E4  stw r9, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 828B79E4: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B79E8: 914100E8  stw r10, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 828B79EC: 910100EC  stw r8, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[8].u32 ) };
	// 828B79F0: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B79F4: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B79F8: 488F0B19  bl 0x831a8510
	ctx.lr = 0x828B79FC;
	sub_831A8510(ctx, base);
	// 828B79FC: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7A00: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7A04: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B7A08: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B7A0C: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B7A10: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B7A14: 4BFFEC55  bl 0x828b6668
	ctx.lr = 0x828B7A18;
	sub_828B6668(ctx, base);
	// 828B7A18: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7A1C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7A20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7A24: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828B7A28: 4BF32D89  bl 0x827ea7b0
	ctx.lr = 0x828B7A2C;
	sub_827EA7B0(ctx, base);
	// 828B7A2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7A30: 4853B9F9  bl 0x82df3428
	ctx.lr = 0x828B7A34;
	sub_82DF3428(ctx, base);
	// 828B7A34: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7A38: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B7A3C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7A40: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7A44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7A48: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7A4C: 4853BFBD  bl 0x82df3a08
	ctx.lr = 0x828B7A50;
	sub_82DF3A08(ctx, base);
	// 828B7A50: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7A54: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7A58: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7A5C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B7A60: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7A64: 4BFFEC85  bl 0x828b66e8
	ctx.lr = 0x828B7A68;
	sub_828B66E8(ctx, base);
	// 828B7A68: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7A6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7A70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7A74: FC20D890  fmr f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[27].f64;
	// 828B7A78: 4BF32D39  bl 0x827ea7b0
	ctx.lr = 0x828B7A7C;
	sub_827EA7B0(ctx, base);
	// 828B7A7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7A80: 4853B9A9  bl 0x82df3428
	ctx.lr = 0x828B7A84;
	sub_82DF3428(ctx, base);
	// 828B7A84: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7A88: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B7A8C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7A90: 396B31F8  addi r11, r11, 0x31f8
	ctx.r[11].s64 = ctx.r[11].s64 + 12792;
	// 828B7A94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7A98: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7A9C: 4853BF6D  bl 0x82df3a08
	ctx.lr = 0x828B7AA0;
	sub_82DF3A08(ctx, base);
	// 828B7AA0: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7AA4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B7AA8: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7AAC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B7AB0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B7AB4: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B7AB8: D3A10070  stfs f29, 0x70(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B7ABC: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828B7AC0: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 828B7AC4: 394AC604  addi r10, r10, -0x39fc
	ctx.r[10].s64 = ctx.r[10].s64 + -14844;
	// 828B7AC8: 914100E4  stw r10, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 828B7ACC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828B7AD0: 912100F4  stw r9, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 828B7AD4: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828B7AD8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B7ADC: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 828B7AE0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B7AE4: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828B7AE8: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7AEC: 914100F0  stw r10, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 828B7AF0: 912100E8  stw r9, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 828B7AF4: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 828B7AF8: 488F0A19  bl 0x831a8510
	ctx.lr = 0x828B7AFC;
	sub_831A8510(ctx, base);
	// 828B7AFC: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7B00: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7B04: E88100C0  ld r4, 0xc0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828B7B08: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828B7B0C: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828B7B10: E8E100D8  ld r7, 0xd8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828B7B14: 4BFFEB55  bl 0x828b6668
	ctx.lr = 0x828B7B18;
	sub_828B6668(ctx, base);
	// 828B7B18: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7B1C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7B20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7B24: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828B7B28: 4BF32C89  bl 0x827ea7b0
	ctx.lr = 0x828B7B2C;
	sub_827EA7B0(ctx, base);
	// 828B7B2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7B30: 4853B8F9  bl 0x82df3428
	ctx.lr = 0x828B7B34;
	sub_82DF3428(ctx, base);
	// 828B7B34: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7B38: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B7B3C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B7B40: 396B1FF0  addi r11, r11, 0x1ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 8176;
	// 828B7B44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7B48: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B7B4C: 4853BEBD  bl 0x82df3a08
	ctx.lr = 0x828B7B50;
	sub_82DF3A08(ctx, base);
	// 828B7B50: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7B54: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B7B58: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828B7B5C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B7B60: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7B64: 4BFFEB85  bl 0x828b66e8
	ctx.lr = 0x828B7B68;
	sub_828B66E8(ctx, base);
	// 828B7B68: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828B7B6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7B70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B7B74: FC20D890  fmr f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[27].f64;
	// 828B7B78: 4BF32C39  bl 0x827ea7b0
	ctx.lr = 0x828B7B7C;
	sub_827EA7B0(ctx, base);
	// 828B7B7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B7B80: 4853B8A9  bl 0x82df3428
	ctx.lr = 0x828B7B84;
	sub_82DF3428(ctx, base);
	// 828B7B84: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B7B88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B7B8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B7B90: 38A00136  li r5, 0x136
	ctx.r[5].s64 = 310;
	// 828B7B94: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 828B7B98: 4BA08841  bl 0x822c03d8
	ctx.lr = 0x828B7B9C;
	sub_822C03D8(ctx, base);
	// 828B7B9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B7BA0: 41820020  beq 0x828b7bc0
	if ctx.cr[0].eq {
	pc = 0x828B7BC0; continue 'dispatch;
	}
	// 828B7BA4: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B7BA8: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828B7BAC: 409A0008  bne cr6, 0x828b7bb4
	if !ctx.cr[6].eq {
	pc = 0x828B7BB4; continue 'dispatch;
	}
	// 828B7BB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B7BB4: 480010ED  bl 0x828b8ca0
	ctx.lr = 0x828B7BB8;
	sub_828B8CA0(ctx, base);
	// 828B7BB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7BBC: 48000008  b 0x828b7bc4
	pc = 0x828B7BC4; continue 'dispatch;
	// 828B7BC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B7BC4: 3BB100E4  addi r29, r17, 0xe4
	ctx.r[29].s64 = ctx.r[17].s64 + 228;
	// 828B7BC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B7BCC: 4BFFC595  bl 0x828b4160
	ctx.lr = 0x828B7BD0;
	sub_828B4160(ctx, base);
	// 828B7BD0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B7BD4: 4BF3458D  bl 0x827ec160
	ctx.lr = 0x828B7BD8;
	sub_827EC160(ctx, base);
	// 828B7BD8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828B7BDC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B7BE0: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7BE4: 4815BA9D  bl 0x82a13680
	ctx.lr = 0x828B7BE8;
	sub_82A13680(ctx, base);
	// 828B7BE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7BEC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B7BF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B7BF8: 4E800421  bctrl
	ctx.lr = 0x828B7BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7BFC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B7C00: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C04: 4815BA85  bl 0x82a13688
	ctx.lr = 0x828B7C08;
	sub_82A13688(ctx, base);
	// 828B7C08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7C0C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B7C10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B7C18: 4E800421  bctrl
	ctx.lr = 0x828B7C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7C1C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B7C20: 48069759  bl 0x82921378
	ctx.lr = 0x828B7C24;
	sub_82921378(ctx, base);
	// 828B7C24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7C28: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7C2C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 828B7C30: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828B7C34: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B7C38: D3410084  stfs f26, 0x84(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828B7C3C: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828B7C40: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7C44: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7C48: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828B7C4C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C50: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B7C54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B7C58: 4E800421  bctrl
	ctx.lr = 0x828B7C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7C5C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B7C60: 4BF34501  bl 0x827ec160
	ctx.lr = 0x828B7C64;
	sub_827EC160(ctx, base);
	// 828B7C64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7C68: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828B7C6C: 4805F12D  bl 0x82916d98
	ctx.lr = 0x828B7C70;
	sub_82916D98(ctx, base);
	// 828B7C70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B7C74: C00B0A94  lfs f0, 0xa94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7C78: 81610110  lwz r11, 0x110(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 828B7C7C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828B7C80: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828B7C84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B7C88: 419A0008  beq cr6, 0x828b7c90
	if ctx.cr[6].eq {
	pc = 0x828B7C90; continue 'dispatch;
	}
	// 828B7C8C: 4BA08C05  bl 0x822c0890
	ctx.lr = 0x828B7C90;
	sub_822C0890(ctx, base);
	// 828B7C90: 817100FC  lwz r11, 0xfc(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(252 as u32) ) } as u64;
	// 828B7C94: 3BF100FC  addi r31, r17, 0xfc
	ctx.r[31].s64 = ctx.r[17].s64 + 252;
	// 828B7C98: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7CA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7CA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B7CA8: 4E800421  bctrl
	ctx.lr = 0x828B7CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7CAC: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828B7CB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7CB4: 809A0AF0  lwz r4, 0xaf0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828B7CB8: 4853BD51  bl 0x82df3a08
	ctx.lr = 0x828B7CBC;
	sub_82DF3A08(ctx, base);
	// 828B7CBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7CC4: 4BFFE1E5  bl 0x828b5ea8
	ctx.lr = 0x828B7CC8;
	sub_828B5EA8(ctx, base);
	// 828B7CC8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7CCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7CD0: 808B2FEC  lwz r4, 0x2fec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12268 as u32) ) } as u64;
	// 828B7CD4: 4853BD35  bl 0x82df3a08
	ctx.lr = 0x828B7CD8;
	sub_82DF3A08(ctx, base);
	// 828B7CD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7CE0: 4BFFE229  bl 0x828b5f08
	ctx.lr = 0x828B7CE4;
	sub_828B5F08(ctx, base);
	// 828B7CE4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7CE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7CEC: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828B7CF0: 4853BD19  bl 0x82df3a08
	ctx.lr = 0x828B7CF4;
	sub_82DF3A08(ctx, base);
	// 828B7CF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7CFC: 4BFFE20D  bl 0x828b5f08
	ctx.lr = 0x828B7D00;
	sub_828B5F08(ctx, base);
	// 828B7D00: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7D04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7D08: 808B2FF0  lwz r4, 0x2ff0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12272 as u32) ) } as u64;
	// 828B7D0C: 4853BCFD  bl 0x82df3a08
	ctx.lr = 0x828B7D10;
	sub_82DF3A08(ctx, base);
	// 828B7D10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7D18: 4BFFE251  bl 0x828b5f68
	ctx.lr = 0x828B7D1C;
	sub_828B5F68(ctx, base);
	// 828B7D1C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7D20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7D24: 808B2FF4  lwz r4, 0x2ff4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12276 as u32) ) } as u64;
	// 828B7D28: 4853BCE1  bl 0x82df3a08
	ctx.lr = 0x828B7D2C;
	sub_82DF3A08(ctx, base);
	// 828B7D2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7D34: 4BFFE295  bl 0x828b5fc8
	ctx.lr = 0x828B7D38;
	sub_828B5FC8(ctx, base);
	// 828B7D38: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7D3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7D40: 808B2FF8  lwz r4, 0x2ff8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12280 as u32) ) } as u64;
	// 828B7D44: 4853BCC5  bl 0x82df3a08
	ctx.lr = 0x828B7D48;
	sub_82DF3A08(ctx, base);
	// 828B7D48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7D50: 4BFFE2D9  bl 0x828b6028
	ctx.lr = 0x828B7D54;
	sub_828B6028(ctx, base);
	// 828B7D54: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7D58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7D5C: 808B2FFC  lwz r4, 0x2ffc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12284 as u32) ) } as u64;
	// 828B7D60: 4853BCA9  bl 0x82df3a08
	ctx.lr = 0x828B7D64;
	sub_82DF3A08(ctx, base);
	// 828B7D64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7D6C: 4BFFE31D  bl 0x828b6088
	ctx.lr = 0x828B7D70;
	sub_828B6088(ctx, base);
	// 828B7D70: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7D74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7D78: 808B300C  lwz r4, 0x300c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12300 as u32) ) } as u64;
	// 828B7D7C: 4853BC8D  bl 0x82df3a08
	ctx.lr = 0x828B7D80;
	sub_82DF3A08(ctx, base);
	// 828B7D80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7D88: 4BFFE361  bl 0x828b60e8
	ctx.lr = 0x828B7D8C;
	sub_828B60E8(ctx, base);
	// 828B7D8C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7D90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7D94: 808B3000  lwz r4, 0x3000(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12288 as u32) ) } as u64;
	// 828B7D98: 4853BC71  bl 0x82df3a08
	ctx.lr = 0x828B7D9C;
	sub_82DF3A08(ctx, base);
	// 828B7D9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7DA4: 4BFFE3A5  bl 0x828b6148
	ctx.lr = 0x828B7DA8;
	sub_828B6148(ctx, base);
	// 828B7DA8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7DAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7DB0: 808B3004  lwz r4, 0x3004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12292 as u32) ) } as u64;
	// 828B7DB4: 4853BC55  bl 0x82df3a08
	ctx.lr = 0x828B7DB8;
	sub_82DF3A08(ctx, base);
	// 828B7DB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7DC0: 4BFFE3E9  bl 0x828b61a8
	ctx.lr = 0x828B7DC4;
	sub_828B61A8(ctx, base);
	// 828B7DC4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B7DC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7DCC: 808B3008  lwz r4, 0x3008(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12296 as u32) ) } as u64;
	// 828B7DD0: 4853BC39  bl 0x82df3a08
	ctx.lr = 0x828B7DD4;
	sub_82DF3A08(ctx, base);
	// 828B7DD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7DDC: 4BFFE42D  bl 0x828b6208
	ctx.lr = 0x828B7DE0;
	sub_828B6208(ctx, base);
	// 828B7DE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7DE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7DE8: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828B7DEC: 4853BC1D  bl 0x82df3a08
	ctx.lr = 0x828B7DF0;
	sub_82DF3A08(ctx, base);
	// 828B7DF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7DF8: 4BFFE471  bl 0x828b6268
	ctx.lr = 0x828B7DFC;
	sub_828B6268(ctx, base);
	// 828B7DFC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7E00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7E04: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828B7E08: 4853BC01  bl 0x82df3a08
	ctx.lr = 0x828B7E0C;
	sub_82DF3A08(ctx, base);
	// 828B7E0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7E14: 4BFFE455  bl 0x828b6268
	ctx.lr = 0x828B7E18;
	sub_828B6268(ctx, base);
	// 828B7E18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7E1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7E20: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828B7E24: 4853BBE5  bl 0x82df3a08
	ctx.lr = 0x828B7E28;
	sub_82DF3A08(ctx, base);
	// 828B7E28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7E30: 4BFFE499  bl 0x828b62c8
	ctx.lr = 0x828B7E34;
	sub_828B62C8(ctx, base);
	// 828B7E34: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7E38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7E3C: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828B7E40: 4853BBC9  bl 0x82df3a08
	ctx.lr = 0x828B7E44;
	sub_82DF3A08(ctx, base);
	// 828B7E44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7E4C: 4BFFE4DD  bl 0x828b6328
	ctx.lr = 0x828B7E50;
	sub_828B6328(ctx, base);
	// 828B7E50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7E54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7E58: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828B7E5C: 4853BBAD  bl 0x82df3a08
	ctx.lr = 0x828B7E60;
	sub_82DF3A08(ctx, base);
	// 828B7E60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7E68: 4BFFE521  bl 0x828b6388
	ctx.lr = 0x828B7E6C;
	sub_828B6388(ctx, base);
	// 828B7E6C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7E70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7E74: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828B7E78: 4853BB91  bl 0x82df3a08
	ctx.lr = 0x828B7E7C;
	sub_82DF3A08(ctx, base);
	// 828B7E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7E84: 4BFFE565  bl 0x828b63e8
	ctx.lr = 0x828B7E88;
	sub_828B63E8(ctx, base);
	// 828B7E88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7E8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7E90: 808B0BC4  lwz r4, 0xbc4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3012 as u32) ) } as u64;
	// 828B7E94: 4853BB75  bl 0x82df3a08
	ctx.lr = 0x828B7E98;
	sub_82DF3A08(ctx, base);
	// 828B7E98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7EA0: 4BFFE5A9  bl 0x828b6448
	ctx.lr = 0x828B7EA4;
	sub_828B6448(ctx, base);
	// 828B7EA4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7EA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7EAC: 808B0BC8  lwz r4, 0xbc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3016 as u32) ) } as u64;
	// 828B7EB0: 4853BB59  bl 0x82df3a08
	ctx.lr = 0x828B7EB4;
	sub_82DF3A08(ctx, base);
	// 828B7EB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7EBC: 4BFFE5ED  bl 0x828b64a8
	ctx.lr = 0x828B7EC0;
	sub_828B64A8(ctx, base);
	// 828B7EC0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7EC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7EC8: 808B0BCC  lwz r4, 0xbcc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3020 as u32) ) } as u64;
	// 828B7ECC: 4853BB3D  bl 0x82df3a08
	ctx.lr = 0x828B7ED0;
	sub_82DF3A08(ctx, base);
	// 828B7ED0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7ED8: 4BFFE631  bl 0x828b6508
	ctx.lr = 0x828B7EDC;
	sub_828B6508(ctx, base);
	// 828B7EDC: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7EE0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828B7EE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7EE8: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 828B7EEC: 4BFB11BD  bl 0x828690a8
	ctx.lr = 0x828B7EF0;
	sub_828690A8(ctx, base);
	// 828B7EF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7EF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7EF8: 3B2100A0  addi r25, r1, 0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + 160;
	// 828B7EFC: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828B7F00: 4853BB09  bl 0x82df3a08
	ctx.lr = 0x828B7F04;
	sub_82DF3A08(ctx, base);
	// 828B7F04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7F0C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B7F10: 485A4249  bl 0x82e5c158
	ctx.lr = 0x828B7F14;
	sub_82E5C158(ctx, base);
	// 828B7F14: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7F18: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828B7F1C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7F20: 388B8420  addi r4, r11, -0x7be0
	ctx.r[4].s64 = ctx.r[11].s64 + -31712;
	// 828B7F24: 4BFB1185  bl 0x828690a8
	ctx.lr = 0x828B7F28;
	sub_828690A8(ctx, base);
	// 828B7F28: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7F2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7F30: 3B2100A0  addi r25, r1, 0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + 160;
	// 828B7F34: 808B0BA8  lwz r4, 0xba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 828B7F38: 4853BAD1  bl 0x82df3a08
	ctx.lr = 0x828B7F3C;
	sub_82DF3A08(ctx, base);
	// 828B7F3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7F44: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B7F48: 485A4211  bl 0x82e5c158
	ctx.lr = 0x828B7F4C;
	sub_82E5C158(ctx, base);
	// 828B7F4C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7F50: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828B7F54: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7F58: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 828B7F5C: 4BFB114D  bl 0x828690a8
	ctx.lr = 0x828B7F60;
	sub_828690A8(ctx, base);
	// 828B7F60: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7F64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7F68: 3B2100A0  addi r25, r1, 0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + 160;
	// 828B7F6C: 808B0BA4  lwz r4, 0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2980 as u32) ) } as u64;
	// 828B7F70: 4853BA99  bl 0x82df3a08
	ctx.lr = 0x828B7F74;
	sub_82DF3A08(ctx, base);
	// 828B7F74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7F7C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B7F80: 485A41D9  bl 0x82e5c158
	ctx.lr = 0x828B7F84;
	sub_82E5C158(ctx, base);
	// 828B7F84: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7F88: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828B7F8C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7F90: 388B5028  addi r4, r11, 0x5028
	ctx.r[4].s64 = ctx.r[11].s64 + 20520;
	// 828B7F94: 4BFB1115  bl 0x828690a8
	ctx.lr = 0x828B7F98;
	sub_828690A8(ctx, base);
	// 828B7F98: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7F9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7FA0: 3B2100A0  addi r25, r1, 0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + 160;
	// 828B7FA4: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 828B7FA8: 4853BA61  bl 0x82df3a08
	ctx.lr = 0x828B7FAC;
	sub_82DF3A08(ctx, base);
	// 828B7FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7FB4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B7FB8: 485A41A1  bl 0x82e5c158
	ctx.lr = 0x828B7FBC;
	sub_82E5C158(ctx, base);
	// 828B7FBC: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B7FC0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828B7FC4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B7FC8: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828B7FCC: 4BFB10DD  bl 0x828690a8
	ctx.lr = 0x828B7FD0;
	sub_828690A8(ctx, base);
	// 828B7FD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B7FD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7FD8: 3B2100A0  addi r25, r1, 0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + 160;
	// 828B7FDC: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828B7FE0: 4853BA29  bl 0x82df3a08
	ctx.lr = 0x828B7FE4;
	sub_82DF3A08(ctx, base);
	// 828B7FE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7FEC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B7FF0: 485A4169  bl 0x82e5c158
	ctx.lr = 0x828B7FF4;
	sub_82E5C158(ctx, base);
	// 828B7FF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7FF8: 809A0AF0  lwz r4, 0xaf0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828B7FFC: 4853BA0D  bl 0x82df3a08
	ctx.lr = 0x828B8000;
	sub_82DF3A08(ctx, base);
	// 828B8000: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B8004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8008: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B800C: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 828B8010: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B8014: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B8018: 485A6949  bl 0x82e5e960
	ctx.lr = 0x828B801C;
	sub_82E5E960(ctx, base);
	// 828B801C: 80610144  lwz r3, 0x144(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 828B8020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8024: 419A0008  beq cr6, 0x828b802c
	if ctx.cr[6].eq {
	pc = 0x828B802C; continue 'dispatch;
	}
	// 828B8028: 4BA08869  bl 0x822c0890
	ctx.lr = 0x828B802C;
	sub_822C0890(ctx, base);
	// 828B802C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B8030: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B8034: 38A00177  li r5, 0x177
	ctx.r[5].s64 = 375;
	// 828B8038: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B803C: 4BA0839D  bl 0x822c03d8
	ctx.lr = 0x828B8040;
	sub_822C03D8(ctx, base);
	// 828B8040: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B8044: 4182002C  beq 0x828b8070
	if ctx.cr[0].eq {
	pc = 0x828B8070; continue 'dispatch;
	}
	// 828B8048: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B804C: 4BF34115  bl 0x827ec160
	ctx.lr = 0x828B8050;
	sub_827EC160(ctx, base);
	// 828B8050: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B8054: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828B8058: 8081023C  lwz r4, 0x23c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 828B805C: 38ABAFD0  addi r5, r11, -0x5030
	ctx.r[5].s64 = ctx.r[11].s64 + -20528;
	// 828B8060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8064: 4806A75D  bl 0x829227c0
	ctx.lr = 0x828B8068;
	sub_829227C0(ctx, base);
	// 828B8068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B806C: 48000008  b 0x828b8074
	pc = 0x828B8074; continue 'dispatch;
	// 828B8070: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8074: 38710370  addi r3, r17, 0x370
	ctx.r[3].s64 = ctx.r[17].s64 + 880;
	// 828B8078: 4BFB0F41  bl 0x82868fb8
	ctx.lr = 0x828B807C;
	sub_82868FB8(ctx, base);
	// 828B807C: 81710164  lwz r11, 0x164(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(356 as u32) ) } as u64;
	// 828B8080: 3BF10164  addi r31, r17, 0x164
	ctx.r[31].s64 = ctx.r[17].s64 + 356;
	// 828B8084: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B808C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8094: 4E800421  bctrl
	ctx.lr = 0x828B8098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8098: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B809C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828B80A0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B80A4: 388BE1E0  addi r4, r11, -0x1e20
	ctx.r[4].s64 = ctx.r[11].s64 + -7712;
	// 828B80A8: 4BFB1001  bl 0x828690a8
	ctx.lr = 0x828B80AC;
	sub_828690A8(ctx, base);
	// 828B80AC: 3FA0832D  lis r29, -0x7cd3
	ctx.r[29].s64 = -2094202880;
	// 828B80B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B80B4: 3B4100A0  addi r26, r1, 0xa0
	ctx.r[26].s64 = ctx.r[1].s64 + 160;
	// 828B80B8: 809D0BD8  lwz r4, 0xbd8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828B80BC: 4853B94D  bl 0x82df3a08
	ctx.lr = 0x828B80C0;
	sub_82DF3A08(ctx, base);
	// 828B80C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B80C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B80C8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828B80CC: 485A408D  bl 0x82e5c158
	ctx.lr = 0x828B80D0;
	sub_82E5C158(ctx, base);
	// 828B80D0: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 828B80D4: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828B80D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828B80DC: 388BE378  addi r4, r11, -0x1c88
	ctx.r[4].s64 = ctx.r[11].s64 + -7304;
	// 828B80E0: 4BFB0FC9  bl 0x828690a8
	ctx.lr = 0x828B80E4;
	sub_828690A8(ctx, base);
	// 828B80E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B80E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B80EC: 3B4100A0  addi r26, r1, 0xa0
	ctx.r[26].s64 = ctx.r[1].s64 + 160;
	// 828B80F0: 808B0BF4  lwz r4, 0xbf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3060 as u32) ) } as u64;
	// 828B80F4: 4853B915  bl 0x82df3a08
	ctx.lr = 0x828B80F8;
	sub_82DF3A08(ctx, base);
	// 828B80F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B80FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8100: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828B8104: 485A4055  bl 0x82e5c158
	ctx.lr = 0x828B8108;
	sub_82E5C158(ctx, base);
	// 828B8108: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B810C: 809D0BD8  lwz r4, 0xbd8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828B8110: 4853B8F9  bl 0x82df3a08
	ctx.lr = 0x828B8114;
	sub_82DF3A08(ctx, base);
	// 828B8114: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B8118: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B811C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B8120: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 828B8124: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B8128: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B812C: 485A6835  bl 0x82e5e960
	ctx.lr = 0x828B8130;
	sub_82E5E960(ctx, base);
	// 828B8130: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 828B8134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8138: 419A0008  beq cr6, 0x828b8140
	if ctx.cr[6].eq {
	pc = 0x828B8140; continue 'dispatch;
	}
	// 828B813C: 4BA08755  bl 0x822c0890
	ctx.lr = 0x828B8140;
	sub_822C0890(ctx, base);
	// 828B8140: 83A10234  lwz r29, 0x234(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 828B8144: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B8148: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B814C: 48055EB5  bl 0x8290e000
	ctx.lr = 0x828B8150;
	sub_8290E000(ctx, base);
	// 828B8150: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B8154: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B8158: 38A0018D  li r5, 0x18d
	ctx.r[5].s64 = 397;
	// 828B815C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828B8160: 4BA08279  bl 0x822c03d8
	ctx.lr = 0x828B8164;
	sub_822C03D8(ctx, base);
	// 828B8164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B8168: 41820020  beq 0x828b8188
	if ctx.cr[0].eq {
	pc = 0x828B8188; continue 'dispatch;
	}
	// 828B816C: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B8170: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828B8174: 409A0008  bne cr6, 0x828b817c
	if !ctx.cr[6].eq {
	pc = 0x828B817C; continue 'dispatch;
	}
	// 828B8178: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B817C: 4808BA1D  bl 0x82943b98
	ctx.lr = 0x828B8180;
	sub_82943B98(ctx, base);
	// 828B8180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8184: 48000008  b 0x828b818c
	pc = 0x828B818C; continue 'dispatch;
	// 828B8188: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B818C: 93E10100  stw r31, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[31].u32 ) };
	// 828B8190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8194: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 828B8198: 4BFAE7F1  bl 0x82866988
	ctx.lr = 0x828B819C;
	sub_82866988(ctx, base);
	// 828B819C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B81A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B81A4: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 828B81A8: 4BA07E59  bl 0x822c0000
	ctx.lr = 0x828B81AC;
	sub_822C0000(ctx, base);
	// 828B81AC: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 828B81B0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828B81B4: 4BFB021D  bl 0x828683d0
	ctx.lr = 0x828B81B8;
	sub_828683D0(ctx, base);
	// 828B81B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B81BC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828B81C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B81C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B81C8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828B81CC: 419A0024  beq cr6, 0x828b81f0
	if ctx.cr[6].eq {
	pc = 0x828B81F0; continue 'dispatch;
	}
	// 828B81D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B81D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B81D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B81DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B81E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B81E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B81E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B81EC: 4082FFE8  bne 0x828b81d4
	if !ctx.cr[0].eq {
	pc = 0x828B81D4; continue 'dispatch;
	}
	// 828B81F0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B81F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B81F8: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B81FC: 480532ED  bl 0x8290b4e8
	ctx.lr = 0x828B8200;
	sub_8290B4E8(ctx, base);
	// 828B8200: 8061012C  lwz r3, 0x12c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 828B8204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8208: 419A0008  beq cr6, 0x828b8210
	if ctx.cr[6].eq {
	pc = 0x828B8210; continue 'dispatch;
	}
	// 828B820C: 4BA08685  bl 0x822c0890
	ctx.lr = 0x828B8210;
	sub_822C0890(ctx, base);
	// 828B8210: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828B8214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8218: 419A0008  beq cr6, 0x828b8220
	if ctx.cr[6].eq {
	pc = 0x828B8220; continue 'dispatch;
	}
	// 828B821C: 4BA08675  bl 0x822c0890
	ctx.lr = 0x828B8220;
	sub_822C0890(ctx, base);
	// 828B8220: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B8224: C02F0030  lfs f1, 0x30(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B8228: 48056229  bl 0x8290e450
	ctx.lr = 0x828B822C;
	sub_8290E450(ctx, base);
	// 828B822C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B8230: C03C0004  lfs f1, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B8234: C0AF000C  lfs f5, 0xc(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828B8238: C08F0008  lfs f4, 8(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828B823C: C06F0004  lfs f3, 4(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828B8240: C04F0000  lfs f2, 0(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B8244: 48058065  bl 0x829102a8
	ctx.lr = 0x828B8248;
	sub_829102A8(ctx, base);
	// 828B8248: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828B824C: 48086D1D  bl 0x8293ef68
	ctx.lr = 0x828B8250;
	sub_8293EF68(ctx, base);
	// 828B8250: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B8254: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 828B8258: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B825C: D34100E4  stfs f26, 0xe4(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 828B8260: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B8264: 38A001A1  li r5, 0x1a1
	ctx.r[5].s64 = 417;
	// 828B8268: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828B826C: 4BA0816D  bl 0x822c03d8
	ctx.lr = 0x828B8270;
	sub_822C03D8(ctx, base);
	// 828B8270: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B8274: 41820024  beq 0x828b8298
	if ctx.cr[0].eq {
	pc = 0x828B8298; continue 'dispatch;
	}
	// 828B8278: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B827C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828B8280: 409A0008  bne cr6, 0x828b8288
	if !ctx.cr[6].eq {
	pc = 0x828B8288; continue 'dispatch;
	}
	// 828B8284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8288: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 828B828C: 48087E45  bl 0x829400d0
	ctx.lr = 0x828B8290;
	sub_829400D0(ctx, base);
	// 828B8290: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B8294: 48000008  b 0x828b829c
	pc = 0x828B829C; continue 'dispatch;
	// 828B8298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B829C: 38710380  addi r3, r17, 0x380
	ctx.r[3].s64 = ctx.r[17].s64 + 896;
	// 828B82A0: 4BFB01A9  bl 0x82868448
	ctx.lr = 0x828B82A4;
	sub_82868448(ctx, base);
	// 828B82A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B82A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B82AC: 38A001A6  li r5, 0x1a6
	ctx.r[5].s64 = 422;
	// 828B82B0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828B82B4: 4BA08125  bl 0x822c03d8
	ctx.lr = 0x828B82B8;
	sub_822C03D8(ctx, base);
	// 828B82B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B82BC: 41820014  beq 0x828b82d0
	if ctx.cr[0].eq {
	pc = 0x828B82D0; continue 'dispatch;
	}
	// 828B82C0: 8081022C  lwz r4, 0x22c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) } as u64;
	// 828B82C4: 4BBD8E2D  bl 0x824910f0
	ctx.lr = 0x828B82C8;
	sub_824910F0(ctx, base);
	// 828B82C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B82CC: 48000008  b 0x828b82d4
	pc = 0x828B82D4; continue 'dispatch;
	// 828B82D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B82D4: 38710388  addi r3, r17, 0x388
	ctx.r[3].s64 = ctx.r[17].s64 + 904;
	// 828B82D8: 4BA52409  bl 0x8230a6e0
	ctx.lr = 0x828B82DC;
	sub_8230A6E0(ctx, base);
	// 828B82DC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828B82E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B82E4: 4BC5039D  bl 0x82508680
	ctx.lr = 0x828B82E8;
	sub_82508680(ctx, base);
	// 828B82E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B82EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B82F0: 388BAFB4  addi r4, r11, -0x504c
	ctx.r[4].s64 = ctx.r[11].s64 + -20556;
	// 828B82F4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828B82F8: 4BFED8C9  bl 0x828a5bc0
	ctx.lr = 0x828B82FC;
	sub_828A5BC0(ctx, base);
	// 828B82FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8300: 91610108  stw r11, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 828B8304: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B830C: 9161010C  stw r11, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 828B8310: 419A0024  beq cr6, 0x828b8334
	if ctx.cr[6].eq {
	pc = 0x828B8334; continue 'dispatch;
	}
	// 828B8314: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B8318: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B831C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8320: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B8324: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B8328: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B832C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8330: 4082FFE8  bne 0x828b8318
	if !ctx.cr[0].eq {
	pc = 0x828B8318; continue 'dispatch;
	}
	// 828B8334: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B8338: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B833C: 38E10108  addi r7, r1, 0x108
	ctx.r[7].s64 = ctx.r[1].s64 + 264;
	// 828B8340: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B8344: 38A001AC  li r5, 0x1ac
	ctx.r[5].s64 = 428;
	// 828B8348: 38710028  addi r3, r17, 0x28
	ctx.r[3].s64 = ctx.r[17].s64 + 40;
	// 828B834C: 485A06F5  bl 0x82e58a40
	ctx.lr = 0x828B8350;
	sub_82E58A40(ctx, base);
	// 828B8350: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828B8354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8358: 419A0008  beq cr6, 0x828b8360
	if ctx.cr[6].eq {
	pc = 0x828B8360; continue 'dispatch;
	}
	// 828B835C: 4BA08535  bl 0x822c0890
	ctx.lr = 0x828B8360;
	sub_822C0890(ctx, base);
	// 828B8360: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 828B8364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8368: 419A0008  beq cr6, 0x828b8370
	if ctx.cr[6].eq {
	pc = 0x828B8370; continue 'dispatch;
	}
	// 828B836C: 4BA08525  bl 0x822c0890
	ctx.lr = 0x828B8370;
	sub_822C0890(ctx, base);
	// 828B8370: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 828B8374: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 828B8378: 488F0745  bl 0x831a8abc
	ctx.lr = 0x828B837C;
	sub_831A8A8C(ctx, base);
	// 828B837C: 488EFE04  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8380 size=80
    let mut pc: u32 = 0x828B8380;
    'dispatch: loop {
        match pc {
            0x828B8380 => {
    //   block [0x828B8380..0x828B83D0)
	// 828B8380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8384: 488EFDE9  bl 0x831a816c
	ctx.lr = 0x828B8388;
	sub_831A8130(ctx, base);
	// 828B8388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B838C: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 828B8390: 3BE303A8  addi r31, r3, 0x3a8
	ctx.r[31].s64 = ctx.r[3].s64 + 936;
	// 828B8394: 83C303AC  lwz r30, 0x3ac(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(940 as u32) ) } as u64;
	// 828B8398: 38C1008C  addi r6, r1, 0x8c
	ctx.r[6].s64 = ctx.r[1].s64 + 140;
	// 828B839C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B83A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B83A4: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B83A8: 4BCA1959  bl 0x82559d00
	ctx.lr = 0x828B83AC;
	sub_82559D00(ctx, base);
	// 828B83AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B83B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B83B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B83B8: 48311A41  bl 0x82bc9df8
	ctx.lr = 0x828B83BC;
	sub_82BC9DF8(ctx, base);
	// 828B83BC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828B83C0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B83C4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B83C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B83CC: 488EFDF0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B83D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B83D0 size=68
    let mut pc: u32 = 0x828B83D0;
    'dispatch: loop {
        match pc {
            0x828B83D0 => {
    //   block [0x828B83D0..0x828B8414)
	// 828B83D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B83D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B83D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B83DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B83E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B83E4: 4805D1BD  bl 0x829155a0
	ctx.lr = 0x828B83E8;
	sub_829155A0(ctx, base);
	// 828B83E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B83EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B83F0: 396BB548  addi r11, r11, -0x4ab8
	ctx.r[11].s64 = ctx.r[11].s64 + -19128;
	// 828B83F4: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 828B83F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B83FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B8400: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B840C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8418 size=8
    let mut pc: u32 = 0x828B8418;
    'dispatch: loop {
        match pc {
            0x828B8418 => {
    //   block [0x828B8418..0x828B8420)
	// 828B8418: 98830018  stb r4, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u8 ) };
	// 828B841C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8420 size=88
    let mut pc: u32 = 0x828B8420;
    'dispatch: loop {
        match pc {
            0x828B8420 => {
    //   block [0x828B8420..0x828B8478)
	// 828B8420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B842C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8438: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B843C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B8440: 396BB548  addi r11, r11, -0x4ab8
	ctx.r[11].s64 = ctx.r[11].s64 + -19128;
	// 828B8444: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B8448: 4805D141  bl 0x82915588
	ctx.lr = 0x828B844C;
	sub_82915588(ctx, base);
	// 828B844C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8450: 4182000C  beq 0x828b845c
	if ctx.cr[0].eq {
	pc = 0x828B845C; continue 'dispatch;
	}
	// 828B8454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8458: 4BA07E11  bl 0x822c0268
	ctx.lr = 0x828B845C;
	sub_822C0268(ctx, base);
	// 828B845C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8460: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B8464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B846C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B8470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8478 size=116
    let mut pc: u32 = 0x828B8478;
    'dispatch: loop {
        match pc {
            0x828B8478 => {
    //   block [0x828B8478..0x828B84EC)
	// 828B8478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B847C: 488EFCF1  bl 0x831a816c
	ctx.lr = 0x828B8480;
	sub_831A8130(ctx, base);
	// 828B8480: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8484: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B8488: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B848C: 3BEB24EC  addi r31, r11, 0x24ec
	ctx.r[31].s64 = ctx.r[11].s64 + 9452;
	// 828B8490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8494: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B8498: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B849C: 48541095  bl 0x82df9530
	ctx.lr = 0x828B84A0;
	sub_82DF9530(ctx, base);
	// 828B84A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B84A4: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B84A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B84AC: 419A0034  beq cr6, 0x828b84e0
	if ctx.cr[6].eq {
	pc = 0x828B84E0; continue 'dispatch;
	}
	// 828B84B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B84B4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B84B8: 48541079  bl 0x82df9530
	ctx.lr = 0x828B84BC;
	sub_82DF9530(ctx, base);
	// 828B84BC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B84C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B84C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B84C8: 419A0018  beq cr6, 0x828b84e0
	if ctx.cr[6].eq {
	pc = 0x828B84E0; continue 'dispatch;
	}
	// 828B84CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B84D0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B84D4: 4854105D  bl 0x82df9530
	ctx.lr = 0x828B84D8;
	sub_82DF9530(ctx, base);
	// 828B84D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B84DC: 48000008  b 0x828b84e4
	pc = 0x828B84E4; continue 'dispatch;
	// 828B84E0: 887D0018  lbz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B84E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B84E8: 488EFCD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B84F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B84F0 size=48
    let mut pc: u32 = 0x828B84F0;
    'dispatch: loop {
        match pc {
            0x828B84F0 => {
    //   block [0x828B84F0..0x828B8520)
	// 828B84F0: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B84F4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B84F8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828B84FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8500: 409A0030  bne cr6, 0x828b8530
	if !ctx.cr[6].eq {
		sub_828B8520(ctx, base);
		return;
	}
	// 828B8504: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8508: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B850C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B8510: 40980010  bge cr6, 0x828b8520
	if !ctx.cr[6].lt {
		sub_828B8520(ctx, base);
		return;
	}
	// 828B8514: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 828B8518: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B851C: 48000008  b 0x828b8524
	sub_828B8520(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8520 size=60
    let mut pc: u32 = 0x828B8520;
    'dispatch: loop {
        match pc {
            0x828B8520 => {
    //   block [0x828B8520..0x828B855C)
	// 828B8520: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8524: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828B8528: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B852C: 419AFFDC  beq cr6, 0x828b8508
	if ctx.cr[6].eq {
		sub_828B84F0(ctx, base);
		return;
	}
	// 828B8530: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8534: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8538: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828B853C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B8540: 409A0030  bne cr6, 0x828b8570
	if !ctx.cr[6].eq {
		sub_828B855C(ctx, base);
		return;
	}
	// 828B8544: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8548: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B854C: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B8550: 4098000C  bge cr6, 0x828b855c
	if !ctx.cr[6].lt {
		sub_828B855C(ctx, base);
		return;
	}
	// 828B8554: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8558: 4800000C  b 0x828b8564
	sub_828B855C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B855C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B855C size=32
    let mut pc: u32 = 0x828B855C;
    'dispatch: loop {
        match pc {
            0x828B855C => {
    //   block [0x828B855C..0x828B857C)
	// 828B855C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B8560: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8564: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828B8568: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B856C: 419AFFDC  beq cr6, 0x828b8548
	if ctx.cr[6].eq {
		sub_828B8520(ctx, base);
		return;
	}
	// 828B8570: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8574: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828B8578: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8580 size=132
    let mut pc: u32 = 0x828B8580;
    'dispatch: loop {
        match pc {
            0x828B8580 => {
    //   block [0x828B8580..0x828B8604)
	// 828B8580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8584: 488EFBE5  bl 0x831a8168
	ctx.lr = 0x828B8588;
	sub_831A8130(ctx, base);
	// 828B8588: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B858C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B8590: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 828B8594: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B8598: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 828B859C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B85A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B85A4: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B85A8: 409A0044  bne cr6, 0x828b85ec
	if !ctx.cr[6].eq {
	pc = 0x828B85EC; continue 'dispatch;
	}
	// 828B85AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B85B0: 409A003C  bne cr6, 0x828b85ec
	if !ctx.cr[6].eq {
	pc = 0x828B85EC; continue 'dispatch;
	}
	// 828B85B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B85B8: 480698F9  bl 0x82921eb0
	ctx.lr = 0x828B85BC;
	sub_82921EB0(ctx, base);
	// 828B85BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B85C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B85C4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B85C8: 48000030  b 0x828b85f8
	pc = 0x828B85F8; continue 'dispatch;
	// 828B85CC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 828B85D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828B85D4: 4BC30ABD  bl 0x824e9090
	ctx.lr = 0x828B85D8;
	sub_824E9090(ctx, base);
	// 828B85D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B85DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B85E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B85E4: 48800035  bl 0x830b8618
	ctx.lr = 0x828B85E8;
	sub_830B8618(ctx, base);
	// 828B85E8: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828B85EC: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828B85F0: 409AFFDC  bne cr6, 0x828b85cc
	if !ctx.cr[6].eq {
	pc = 0x828B85CC; continue 'dispatch;
	}
	// 828B85F4: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 828B85F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B85FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B8600: 488EFBB8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B8608 size=924
    let mut pc: u32 = 0x828B8608;
    'dispatch: loop {
        match pc {
            0x828B8608 => {
    //   block [0x828B8608..0x828B89A4)
	// 828B8608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B860C: 488EFB3D  bl 0x831a8148
	ctx.lr = 0x828B8610;
	sub_831A8130(ctx, base);
	// 828B8610: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 828B8614: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 828B8618: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B861C: 82CD0000  lwz r22, 0(r13)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8620: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828B8624: 3AA00014  li r21, 0x14
	ctx.r[21].s64 = 20;
	// 828B8628: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B862C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828B8630: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828B8634: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828B8638: 836B6820  lwz r27, 0x6820(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828B863C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828B8640: 7C75B02E  lwzx r3, r21, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 828B8644: 485E80ED  bl 0x82ea0730
	ctx.lr = 0x828B8648;
	sub_82EA0730(ctx, base);
	// 828B8648: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 828B864C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B8650: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 828B8654: C02BC658  lfs f1, -0x39a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14760 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B8658: 48661B99  bl 0x82f1a1f0
	ctx.lr = 0x828B865C;
	sub_82F1A1F0(ctx, base);
	// 828B865C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B8660: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B8664: 4182000C  beq 0x828b8670
	if ctx.cr[0].eq {
	pc = 0x828B8670; continue 'dispatch;
	}
	// 828B8668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B866C: 4BA2FBDD  bl 0x822e8248
	ctx.lr = 0x828B8670;
	sub_822E8248(ctx, base);
	// 828B8670: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B8674: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8678: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B867C: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8680: 3BEB0778  addi r31, r11, 0x778
	ctx.r[31].s64 = ctx.r[11].s64 + 1912;
	// 828B8684: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828B8688: 4855C9A9  bl 0x82e15030
	ctx.lr = 0x828B868C;
	sub_82E15030(ctx, base);
	// 828B868C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B8690: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 828B8694: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8698: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B869C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B86A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B86A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B86A8: 4E800421  bctrl
	ctx.lr = 0x828B86AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B86AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B86B0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B86B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B86B8: 419A000C  beq cr6, 0x828b86c4
	if ctx.cr[6].eq {
	pc = 0x828B86C4; continue 'dispatch;
	}
	// 828B86BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B86C0: 4BA2FBA9  bl 0x822e8268
	ctx.lr = 0x828B86C4;
	sub_822E8268(ctx, base);
	// 828B86C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B86C8: 3A9A0004  addi r20, r26, 4
	ctx.r[20].s64 = ctx.r[26].s64 + 4;
	// 828B86CC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828B86D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B86D4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828B86D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B86DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B86E0: 4BFB2A41  bl 0x8286b120
	ctx.lr = 0x828B86E4;
	sub_8286B120(ctx, base);
	// 828B86E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B86E8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828B86EC: 419A000C  beq cr6, 0x828b86f8
	if ctx.cr[6].eq {
	pc = 0x828B86F8; continue 'dispatch;
	}
	// 828B86F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B86F4: 4BA2FB75  bl 0x822e8268
	ctx.lr = 0x828B86F8;
	sub_822E8268(ctx, base);
	// 828B86F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828B86FC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B8700: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B8704: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 828B8708: 832B6818  lwz r25, 0x6818(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26648 as u32) ) } as u64;
	// 828B870C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B8710: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B8714: C3CBC65C  lfs f30, -0x39a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14756 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B8718: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828B871C: 7C75B02E  lwzx r3, r21, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 828B8720: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828B8724: 485E800D  bl 0x82ea0730
	ctx.lr = 0x828B8728;
	sub_82EA0730(ctx, base);
	// 828B8728: 7B8B0020  clrldi r11, r28, 0x20
	ctx.r[11].u64 = ctx.r[28].u64 & 0x00000000FFFFFFFFu64;
	// 828B872C: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 828B8730: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828B8734: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828B8738: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 828B873C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828B8740: EC20F7FC  fnmsubs f1, f0, f31, f30
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 828B8744: 48661AAD  bl 0x82f1a1f0
	ctx.lr = 0x828B8748;
	sub_82F1A1F0(ctx, base);
	// 828B8748: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828B874C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828B8750: 4182000C  beq 0x828b875c
	if ctx.cr[0].eq {
	pc = 0x828B875C; continue 'dispatch;
	}
	// 828B8754: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8758: 4BA2FAF1  bl 0x822e8248
	ctx.lr = 0x828B875C;
	sub_822E8248(ctx, base);
	// 828B875C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828B8760: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B8768: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B876C: 4855C8C5  bl 0x82e15030
	ctx.lr = 0x828B8770;
	sub_82E15030(ctx, base);
	// 828B8770: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B8774: 817E00C8  lwz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 828B8778: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 828B877C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B8780: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8784: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B878C: 4E800421  bctrl
	ctx.lr = 0x828B8790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8790: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B8798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B879C: 419A000C  beq cr6, 0x828b87a8
	if ctx.cr[6].eq {
	pc = 0x828B87A8; continue 'dispatch;
	}
	// 828B87A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B87A4: 4BA2FAC5  bl 0x822e8268
	ctx.lr = 0x828B87A8;
	sub_822E8268(ctx, base);
	// 828B87A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B87AC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B87B0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828B87B4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828B87B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B87BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B87C0: 4BFB2961  bl 0x8286b120
	ctx.lr = 0x828B87C4;
	sub_8286B120(ctx, base);
	// 828B87C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828B87C8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828B87CC: 2B1C0006  cmplwi cr6, r28, 6
	ctx.cr[6].compare_u32(ctx.r[28].u32, 6 as u32, &mut ctx.xer);
	// 828B87D0: 409A0008  bne cr6, 0x828b87d8
	if !ctx.cr[6].eq {
	pc = 0x828B87D8; continue 'dispatch;
	}
	// 828B87D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B87D8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828B87DC: 419A000C  beq cr6, 0x828b87e8
	if ctx.cr[6].eq {
	pc = 0x828B87E8; continue 'dispatch;
	}
	// 828B87E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B87E4: 4BA2FA85  bl 0x822e8268
	ctx.lr = 0x828B87E8;
	sub_822E8268(ctx, base);
	// 828B87E8: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828B87EC: 4082FF2C  bne 0x828b8718
	if !ctx.cr[0].eq {
	pc = 0x828B8718; continue 'dispatch;
	}
	// 828B87F0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828B87F4: 7C75B02E  lwzx r3, r21, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 828B87F8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 828B87FC: 485E7F35  bl 0x82ea0730
	ctx.lr = 0x828B8800;
	sub_82EA0730(ctx, base);
	// 828B8800: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B8804: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828B8808: 396BB590  addi r11, r11, -0x4a70
	ctx.r[11].s64 = ctx.r[11].s64 + -19056;
	// 828B880C: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 828B8810: 3F408332  lis r26, -0x7cce
	ctx.r[26].s64 = -2093875200;
	// 828B8814: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 828B8818: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B881C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B89A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B89A8 size=488
    let mut pc: u32 = 0x828B89A8;
    'dispatch: loop {
        match pc {
            0x828B89A8 => {
    //   block [0x828B89A8..0x828B8B90)
	// 828B89A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B89AC: 488EF7B1  bl 0x831a815c
	ctx.lr = 0x828B89B0;
	sub_831A8130(ctx, base);
	// 828B89B0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B89B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B89B8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B89BC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 828B89C0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828B89C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B89C8: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B89CC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828B89D0: C06A9524  lfs f3, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828B89D4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828B89D8: 834967FC  lwz r26, 0x67fc(r9)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26620 as u32) ) } as u64;
	// 828B89DC: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 828B89E0: 485C3639  bl 0x82e7c018
	ctx.lr = 0x828B89E4;
	sub_82E7C018(ctx, base);
	// 828B89E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B89E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B89EC: 388BB5A0  addi r4, r11, -0x4a60
	ctx.r[4].s64 = ctx.r[11].s64 + -19040;
	// 828B89F0: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 828B89F4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 828B89F8: 485399F1  bl 0x82df23e8
	ctx.lr = 0x828B89FC;
	sub_82DF23E8(ctx, base);
	// 828B89FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B8A00: 41820014  beq 0x828b8a14
	if ctx.cr[0].eq {
	pc = 0x828B8A14; continue 'dispatch;
	}
	// 828B8A04: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B8A08: 4855A6E9  bl 0x82e130f0
	ctx.lr = 0x828B8A0C;
	sub_82E130F0(ctx, base);
	// 828B8A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8A10: 48000008  b 0x828b8a18
	pc = 0x828B8A18; continue 'dispatch;
	// 828B8A14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B8A18: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828B8A1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8A20: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828B8A24: 4BA285F5  bl 0x822e1018
	ctx.lr = 0x828B8A28;
	sub_822E1018(ctx, base);
	// 828B8A28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8A2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8A30: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828B8A34: 4BA075CD  bl 0x822c0000
	ctx.lr = 0x828B8A38;
	sub_822C0000(ctx, base);
	// 828B8A38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B8A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8A40: 388BB1DC  addi r4, r11, -0x4e24
	ctx.r[4].s64 = ctx.r[11].s64 + -20004;
	// 828B8A44: 4853AFC5  bl 0x82df3a08
	ctx.lr = 0x828B8A48;
	sub_82DF3A08(ctx, base);
	// 828B8A48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B8A4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B8A50: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8A54: 4855C5DD  bl 0x82e15030
	ctx.lr = 0x828B8A58;
	sub_82E15030(ctx, base);
	// 828B8A58: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B8A5C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8A64: 4855A3CD  bl 0x82e12e30
	ctx.lr = 0x828B8A68;
	sub_82E12E30(ctx, base);
	// 828B8A68: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B8A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8A70: 419A0008  beq cr6, 0x828b8a78
	if ctx.cr[6].eq {
	pc = 0x828B8A78; continue 'dispatch;
	}
	// 828B8A74: 4BA07E1D  bl 0x822c0890
	ctx.lr = 0x828B8A78;
	sub_822C0890(ctx, base);
	// 828B8A78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8A7C: 4853A9AD  bl 0x82df3428
	ctx.lr = 0x828B8A80;
	sub_82DF3428(ctx, base);
	// 828B8A80: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8A84: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828B8A88: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828B8A8C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828B8A90: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B8A94: 485E7C9D  bl 0x82ea0730
	ctx.lr = 0x828B8A98;
	sub_82EA0730(ctx, base);
	// 828B8A98: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828B8A9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B8AA0: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828B8AA4: C02AD1B8  lfs f1, -0x2e48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B8AA8: 48661749  bl 0x82f1a1f0
	ctx.lr = 0x828B8AAC;
	sub_82F1A1F0(ctx, base);
	// 828B8AAC: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828B8AB0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828B8AB4: 4182000C  beq 0x828b8ac0
	if ctx.cr[0].eq {
	pc = 0x828B8AC0; continue 'dispatch;
	}
	// 828B8AB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B8ABC: 4BA2F78D  bl 0x822e8248
	ctx.lr = 0x828B8AC0;
	sub_822E8248(ctx, base);
	// 828B8AC0: 3FC0832C  lis r30, -0x7cd4
	ctx.r[30].s64 = -2094268416;
	// 828B8AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8AC8: 809E24F8  lwz r4, 0x24f8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9464 as u32) ) } as u64;
	// 828B8ACC: 48540A65  bl 0x82df9530
	ctx.lr = 0x828B8AD0;
	sub_82DF9530(ctx, base);
	// 828B8AD0: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B8AD4: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828B8AD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B8ADC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 828B8AE0: 419A0024  beq cr6, 0x828b8b04
	if ctx.cr[6].eq {
	pc = 0x828B8B04; continue 'dispatch;
	}
	// 828B8AE4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828B8AE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B8AEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8AF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B8AF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B8AF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8AFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8B00: 4082FFE8  bne 0x828b8ae8
	if !ctx.cr[0].eq {
	pc = 0x828B8AE8; continue 'dispatch;
	}
	// 828B8B04: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8B08: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 828B8B0C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828B8B10: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B8B14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B8B18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8B1C: 816B00C8  lwz r11, 0xc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 828B8B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8B24: 4E800421  bctrl
	ctx.lr = 0x828B8B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8B28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8B34: 419A000C  beq cr6, 0x828b8b40
	if ctx.cr[6].eq {
	pc = 0x828B8B40; continue 'dispatch;
	}
	// 828B8B38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B8B3C: 4BA2F72D  bl 0x822e8268
	ctx.lr = 0x828B8B40;
	sub_822E8268(ctx, base);
	// 828B8B40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8B44: 809E24F8  lwz r4, 0x24f8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9464 as u32) ) } as u64;
	// 828B8B48: 485409E9  bl 0x82df9530
	ctx.lr = 0x828B8B4C;
	sub_82DF9530(ctx, base);
	// 828B8B4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B8B50: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 828B8B54: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828B8B58: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 828B8B5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8B60: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828B8B64: 4BFB25BD  bl 0x8286b120
	ctx.lr = 0x828B8B68;
	sub_8286B120(ctx, base);
	// 828B8B68: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B8B6C: 419A000C  beq cr6, 0x828b8b78
	if ctx.cr[6].eq {
	pc = 0x828B8B78; continue 'dispatch;
	}
	// 828B8B70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B8B74: 4BA2F6F5  bl 0x822e8268
	ctx.lr = 0x828B8B78;
	sub_822E8268(ctx, base);
	// 828B8B78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B8B7C: 419A000C  beq cr6, 0x828b8b88
	if ctx.cr[6].eq {
	pc = 0x828B8B88; continue 'dispatch;
	}
	// 828B8B80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8B84: 4BA07D0D  bl 0x822c0890
	ctx.lr = 0x828B8B88;
	sub_822C0890(ctx, base);
	// 828B8B88: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828B8B8C: 488EF620  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8B90 size=100
    let mut pc: u32 = 0x828B8B90;
    'dispatch: loop {
        match pc {
            0x828B8B90 => {
    //   block [0x828B8B90..0x828B8BF4)
	// 828B8B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8B94: 488EF5D9  bl 0x831a816c
	ctx.lr = 0x828B8B98;
	sub_831A8130(ctx, base);
	// 828B8B98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8B9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B8BA0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828B8BA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B8BA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8BAC: 4BFFF945  bl 0x828b84f0
	ctx.lr = 0x828B8BB0;
	sub_828B84F0(ctx, base);
	// 828B8BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8BB4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B8BB8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B8BBC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B8BC0: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B8BC4: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B8BC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8BCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8BD0: 4BBA1B49  bl 0x8245a718
	ctx.lr = 0x828B8BD4;
	sub_8245A718(ctx, base);
	// 828B8BD4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B8BD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B8BDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B8BE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8BE4: 4BFFF99D  bl 0x828b8580
	ctx.lr = 0x828B8BE8;
	sub_828B8580(ctx, base);
	// 828B8BE8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8BEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B8BF0: 488EF5CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8BF8 size=164
    let mut pc: u32 = 0x828B8BF8;
    'dispatch: loop {
        match pc {
            0x828B8BF8 => {
    //   block [0x828B8BF8..0x828B8C9C)
	// 828B8BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8BFC: 488EF56D  bl 0x831a8168
	ctx.lr = 0x828B8C00;
	sub_831A8130(ctx, base);
	// 828B8C00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8C04: 3FC0832C  lis r30, -0x7cd4
	ctx.r[30].s64 = -2094268416;
	// 828B8C08: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B8C0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8C10: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B8C14: 809E24F8  lwz r4, 0x24f8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9464 as u32) ) } as u64;
	// 828B8C18: 48540919  bl 0x82df9530
	ctx.lr = 0x828B8C1C;
	sub_82DF9530(ctx, base);
	// 828B8C1C: 3BFC0004  addi r31, r28, 4
	ctx.r[31].s64 = ctx.r[28].s64 + 4;
	// 828B8C20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B8C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8C28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8C2C: 4BFB2435  bl 0x8286b060
	ctx.lr = 0x828B8C30;
	sub_8286B060(ctx, base);
	// 828B8C30: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8C34: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8C38: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B8C3C: 419A0058  beq cr6, 0x828b8c94
	if ctx.cr[6].eq {
	pc = 0x828B8C94; continue 'dispatch;
	}
	// 828B8C40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8C44: 809E24F8  lwz r4, 0x24f8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9464 as u32) ) } as u64;
	// 828B8C48: 485408E9  bl 0x82df9530
	ctx.lr = 0x828B8C4C;
	sub_82DF9530(ctx, base);
	// 828B8C4C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B8C50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8C54: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828B8C58: 4BFB2409  bl 0x8286b060
	ctx.lr = 0x828B8C5C;
	sub_8286B060(ctx, base);
	// 828B8C5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B8C60: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8C68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8C6C: 814A00CC  lwz r10, 0xcc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(204 as u32) ) } as u64;
	// 828B8C70: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B8C74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B8C78: 4E800421  bctrl
	ctx.lr = 0x828B8C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8C80: 809E24F8  lwz r4, 0x24f8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9464 as u32) ) } as u64;
	// 828B8C84: 485408AD  bl 0x82df9530
	ctx.lr = 0x828B8C88;
	sub_82DF9530(ctx, base);
	// 828B8C88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B8C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8C90: 4BFFFF01  bl 0x828b8b90
	ctx.lr = 0x828B8C94;
	sub_828B8B90(ctx, base);
	// 828B8C94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B8C98: 488EF520  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8CA0 size=68
    let mut pc: u32 = 0x828B8CA0;
    'dispatch: loop {
        match pc {
            0x828B8CA0 => {
    //   block [0x828B8CA0..0x828B8CE4)
	// 828B8CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8CA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8CAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8CB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8CB4: 4805E225  bl 0x82916ed8
	ctx.lr = 0x828B8CB8;
	sub_82916ED8(ctx, base);
	// 828B8CB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B8CBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B8CC0: 396BB644  addi r11, r11, -0x49bc
	ctx.r[11].s64 = ctx.r[11].s64 + -18876;
	// 828B8CC4: 995F00C0  stb r10, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u8 ) };
	// 828B8CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8CCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B8CD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8CD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8CD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8CE8 size=16
    let mut pc: u32 = 0x828B8CE8;
    'dispatch: loop {
        match pc {
            0x828B8CE8 => {
    //   block [0x828B8CE8..0x828B8CF8)
	// 828B8CE8: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B8CEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8CF0: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 828B8CF4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8CF8 size=8
    let mut pc: u32 = 0x828B8CF8;
    'dispatch: loop {
        match pc {
            0x828B8CF8 => {
    //   block [0x828B8CF8..0x828B8D00)
	// 828B8CF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8CFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828B8D00 size=48
    let mut pc: u32 = 0x828B8D00;
    'dispatch: loop {
        match pc {
            0x828B8D00 => {
    //   block [0x828B8D00..0x828B8D30)
	// 828B8D00: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B8D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D08: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 828B8D0C: 409A0008  bne cr6, 0x828b8d14
	if !ctx.cr[6].eq {
	pc = 0x828B8D14; continue 'dispatch;
	}
	// 828B8D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8D14: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B8D18: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B8D1C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828B8D20: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B8D24: 81690080  lwz r11, 0x80(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B8D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8D2C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D30 size=24
    let mut pc: u32 = 0x828B8D30;
    'dispatch: loop {
        match pc {
            0x828B8D30 => {
    //   block [0x828B8D30..0x828B8D48)
	// 828B8D30: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B8D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D38: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 828B8D3C: 409A0008  bne cr6, 0x828b8d44
	if !ctx.cr[6].eq {
	pc = 0x828B8D44; continue 'dispatch;
	}
	// 828B8D40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8D44: 4BFF8D4C  b 0x828b1a90
	sub_828B1A90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D48 size=40
    let mut pc: u32 = 0x828B8D48;
    'dispatch: loop {
        match pc {
            0x828B8D48 => {
    //   block [0x828B8D48..0x828B8D70)
	// 828B8D48: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B8D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D50: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 828B8D54: 409A0008  bne cr6, 0x828b8d5c
	if !ctx.cr[6].eq {
	pc = 0x828B8D5C; continue 'dispatch;
	}
	// 828B8D58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8D5C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B8D60: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828B8D64: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 828B8D68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8D6C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D70 size=24
    let mut pc: u32 = 0x828B8D70;
    'dispatch: loop {
        match pc {
            0x828B8D70 => {
    //   block [0x828B8D70..0x828B8D88)
	// 828B8D70: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B8D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D78: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 828B8D7C: 409A0008  bne cr6, 0x828b8d84
	if !ctx.cr[6].eq {
	pc = 0x828B8D84; continue 'dispatch;
	}
	// 828B8D80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8D84: 4BFFF5FC  b 0x828b8380
	sub_828B8380(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D88 size=24
    let mut pc: u32 = 0x828B8D88;
    'dispatch: loop {
        match pc {
            0x828B8D88 => {
    //   block [0x828B8D88..0x828B8DA0)
	// 828B8D88: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B8D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D90: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 828B8D94: 409A0008  bne cr6, 0x828b8d9c
	if !ctx.cr[6].eq {
	pc = 0x828B8D9C; continue 'dispatch;
	}
	// 828B8D98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8D9C: 4BFF924C  b 0x828b1fe8
	sub_828B1FE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8DA0 size=88
    let mut pc: u32 = 0x828B8DA0;
    'dispatch: loop {
        match pc {
            0x828B8DA0 => {
    //   block [0x828B8DA0..0x828B8DF8)
	// 828B8DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B8DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8DB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8DB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B8DBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B8DC0: 396BB644  addi r11, r11, -0x49bc
	ctx.r[11].s64 = ctx.r[11].s64 + -18876;
	// 828B8DC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B8DC8: 4805DDA1  bl 0x82916b68
	ctx.lr = 0x828B8DCC;
	sub_82916B68(ctx, base);
	// 828B8DCC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8DD0: 4182000C  beq 0x828b8ddc
	if ctx.cr[0].eq {
	pc = 0x828B8DDC; continue 'dispatch;
	}
	// 828B8DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8DD8: 4BA07491  bl 0x822c0268
	ctx.lr = 0x828B8DDC;
	sub_822C0268(ctx, base);
	// 828B8DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8DE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B8DE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8DE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8DEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B8DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B8DF8 size=476
    let mut pc: u32 = 0x828B8DF8;
    'dispatch: loop {
        match pc {
            0x828B8DF8 => {
    //   block [0x828B8DF8..0x828B8FD4)
	// 828B8DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8DFC: 488EF371  bl 0x831a816c
	ctx.lr = 0x828B8E00;
	sub_831A8130(ctx, base);
	// 828B8E00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8E04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8E08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B8E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8E10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B8E14: 4BF36A3D  bl 0x827ef850
	ctx.lr = 0x828B8E18;
	sub_827EF850(ctx, base);
	// 828B8E18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B8E1C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B8E20: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828B8E24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B8E28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8E2C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B8FD8 size=508
    let mut pc: u32 = 0x828B8FD8;
    'dispatch: loop {
        match pc {
            0x828B8FD8 => {
    //   block [0x828B8FD8..0x828B91D4)
	// 828B8FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8FE4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 828B8FE8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B8FEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8FF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B8FF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B8FF8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828B8FFC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828B9000: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828B9004: C1ABD72C  lfs f13, -0x28d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B9008: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 828B900C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B9010: C18AD86C  lfs f12, -0x2794(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B9014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9018: C169D0F8  lfs f11, -0x2f08(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B901C: C1480A98  lfs f10, 0xa98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2712 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828B9020: C3C7959C  lfs f30, -0x6a64(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B9024: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 828B9028: C0066150  lfs f0, 0x6150(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B902C: C3EB08A8  lfs f31, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B9030: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B9034: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828B9038: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828B903C: D15F000C  stfs f10, 0xc(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828B9040: D3DF0010  stfs f30, 0x10(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B9044: D3DF0014  stfs f30, 0x14(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B9048: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828B904C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828B9050: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828B9054: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828B9058: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828B905C: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828B9060: 480A0EB1  bl 0x82959f10
	ctx.lr = 0x828B9064;
	sub_82959F10(ctx, base);
	// 828B9064: 387F00A8  addi r3, r31, 0xa8
	ctx.r[3].s64 = ctx.r[31].s64 + 168;
	// 828B9068: 4809EB91  bl 0x82957bf8
	ctx.lr = 0x828B906C;
	sub_82957BF8(ctx, base);
	// 828B906C: 387F00B8  addi r3, r31, 0xb8
	ctx.r[3].s64 = ctx.r[31].s64 + 184;
	// 828B9070: 4809EB89  bl 0x82957bf8
	ctx.lr = 0x828B9074;
	sub_82957BF8(ctx, base);
	// 828B9074: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 828B9078: 4809EB81  bl 0x82957bf8
	ctx.lr = 0x828B907C;
	sub_82957BF8(ctx, base);
	// 828B907C: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 828B9080: 4BF50701  bl 0x82809780
	ctx.lr = 0x828B9084;
	sub_82809780(ctx, base);
	// 828B9084: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 828B9088: 4809D651  bl 0x829566d8
	ctx.lr = 0x828B908C;
	sub_829566D8(ctx, base);
	// 828B908C: 387F0134  addi r3, r31, 0x134
	ctx.r[3].s64 = ctx.r[31].s64 + 308;
	// 828B9090: 4809D649  bl 0x829566d8
	ctx.lr = 0x828B9094;
	sub_829566D8(ctx, base);
	// 828B9094: 387F0174  addi r3, r31, 0x174
	ctx.r[3].s64 = ctx.r[31].s64 + 372;
	// 828B9098: 4809D5F1  bl 0x82956688
	ctx.lr = 0x828B909C;
	sub_82956688(ctx, base);
	// 828B909C: 387F0198  addi r3, r31, 0x198
	ctx.r[3].s64 = ctx.r[31].s64 + 408;
	// 828B90A0: 4809D5E9  bl 0x82956688
	ctx.lr = 0x828B90A4;
	sub_82956688(ctx, base);
	// 828B90A4: 387F01BC  addi r3, r31, 0x1bc
	ctx.r[3].s64 = ctx.r[31].s64 + 444;
	// 828B90A8: 4809D5E1  bl 0x82956688
	ctx.lr = 0x828B90AC;
	sub_82956688(ctx, base);
	// 828B90AC: 387F01E0  addi r3, r31, 0x1e0
	ctx.r[3].s64 = ctx.r[31].s64 + 480;
	// 828B90B0: 4809D5D9  bl 0x82956688
	ctx.lr = 0x828B90B4;
	sub_82956688(ctx, base);
	// 828B90B4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B90B8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828B90BC: D3FF0210  stfs f31, 0x210(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 828B90C0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 828B90C4: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 828B90C8: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 828B90CC: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 828B90D0: 913F0204  stw r9, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[9].u32 ) };
	// 828B90D4: C3EA9450  lfs f31, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B90D8: 911F020C  stw r8, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[8].u32 ) };
	// 828B90DC: D3FF0214  stfs f31, 0x214(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), tmp.u32 ) };
	// 828B90E0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828B90E4: 90FF0220  stw r7, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[7].u32 ) };
	// 828B90E8: 387F0224  addi r3, r31, 0x224
	ctx.r[3].s64 = ctx.r[31].s64 + 548;
	// 828B90EC: 4808A26D  bl 0x82943358
	ctx.lr = 0x828B90F0;
	sub_82943358(ctx, base);
	// 828B90F0: 387F0234  addi r3, r31, 0x234
	ctx.r[3].s64 = ctx.r[31].s64 + 564;
	// 828B90F4: 4808833D  bl 0x82941430
	ctx.lr = 0x828B90F8;
	sub_82941430(ctx, base);
	// 828B90F8: 387F0250  addi r3, r31, 0x250
	ctx.r[3].s64 = ctx.r[31].s64 + 592;
	// 828B90FC: 480897F5  bl 0x829428f0
	ctx.lr = 0x828B9100;
	sub_829428F0(ctx, base);
	// 828B9100: 387F0260  addi r3, r31, 0x260
	ctx.r[3].s64 = ctx.r[31].s64 + 608;
	// 828B9104: 480A1B4D  bl 0x8295ac50
	ctx.lr = 0x828B9108;
	sub_8295AC50(ctx, base);
	// 828B9108: 387F026C  addi r3, r31, 0x26c
	ctx.r[3].s64 = ctx.r[31].s64 + 620;
	// 828B910C: 480A1BBD  bl 0x8295acc8
	ctx.lr = 0x828B9110;
	sub_8295ACC8(ctx, base);
	// 828B9110: 387F027C  addi r3, r31, 0x27c
	ctx.r[3].s64 = ctx.r[31].s64 + 636;
	// 828B9114: 480A22E5  bl 0x8295b3f8
	ctx.lr = 0x828B9118;
	sub_8295B3F8(ctx, base);
	// 828B9118: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B911C: D3DF0250  stfs f30, 0x250(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), tmp.u32 ) };
	// 828B9120: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 828B9124: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828B9128: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828B912C: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 828B9130: C1AB093C  lfs f13, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B9134: 3CA08209  lis r5, -0x7df7
	ctx.r[5].s64 = -2113339392;
	// 828B9138: C0089524  lfs f0, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B913C: 39600096  li r11, 0x96
	ctx.r[11].s64 = 150;
	// 828B9140: C18795A0  lfs f12, -0x6a60(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B9144: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828B9148: C166DD6C  lfs f11, -0x2294(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B914C: 3905B1D4  addi r8, r5, -0x4e2c
	ctx.r[8].s64 = ctx.r[5].s64 + -20012;
	// 828B9150: D3FF0254  stfs f31, 0x254(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), tmp.u32 ) };
	// 828B9154: D3FF0258  stfs f31, 0x258(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), tmp.u32 ) };
	// 828B9158: 993F0078  stb r9, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[9].u8 ) };
	// 828B915C: D3FF025C  stfs f31, 0x25c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), tmp.u32 ) };
	// 828B9160: 993F0088  stb r9, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u8 ) };
	// 828B9164: D1BF0234  stfs f13, 0x234(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 828B9168: 993F0098  stb r9, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[9].u8 ) };
	// 828B916C: D01F024C  stfs f0, 0x24c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), tmp.u32 ) };
	// 828B9170: 915F00A8  stw r10, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 828B9174: D19F0238  stfs f12, 0x238(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 828B9178: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 828B917C: D01F023C  stfs f0, 0x23c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 828B9180: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 828B9184: D3FF0240  stfs f31, 0x240(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 828B9188: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 828B918C: D17F0030  stfs f11, 0x30(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828B9190: 915F00B8  stw r10, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 828B9194: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 828B9198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B919C: 915F00C0  stw r10, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 828B91A0: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 828B91A4: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 828B91A8: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 828B91AC: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 828B91B0: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 828B91B4: 911F0284  stw r8, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[8].u32 ) };
	// 828B91B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B91BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B91C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B91C4: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828B91C8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B91CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B91D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B91D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B91D8 size=3664
    let mut pc: u32 = 0x828B91D8;
    'dispatch: loop {
        match pc {
            0x828B91D8 => {
    //   block [0x828B91D8..0x828BA028)
	// 828B91D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B91DC: 488EEF89  bl 0x831a8164
	ctx.lr = 0x828B91E0;
	sub_831A8130(ctx, base);
	// 828B91E0: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 828B91E4: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 828B91E8: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828B91EC: 9421FBF0  stwu r1, -0x410(r1)
	ea = ctx.r[1].u32.wrapping_add(-1040 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B91F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B91F4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828B91F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B91FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9200: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9204: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 828B9208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B920C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828B9210: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828B9214: 419A0024  beq cr6, 0x828b9238
	if ctx.cr[6].eq {
	pc = 0x828B9238; continue 'dispatch;
	}
	// 828B9218: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B921C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9220: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9224: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9228: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B922C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9230: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9234: 4082FFE8  bne 0x828b921c
	if !ctx.cr[0].eq {
	pc = 0x828B921C; continue 'dispatch;
	}
	// 828B9238: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B923C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 828B9240: 480A18D9  bl 0x8295ab18
	ctx.lr = 0x828B9244;
	sub_8295AB18(ctx, base);
	// 828B9244: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9248: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B924C: 388BBF94  addi r4, r11, -0x406c
	ctx.r[4].s64 = ctx.r[11].s64 + -16492;
	// 828B9250: 4853A7B9  bl 0x82df3a08
	ctx.lr = 0x828B9254;
	sub_82DF3A08(ctx, base);
	// 828B9254: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9258: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B925C: 388BA984  addi r4, r11, -0x567c
	ctx.r[4].s64 = ctx.r[11].s64 + -22140;
	// 828B9260: 4853A7A9  bl 0x82df3a08
	ctx.lr = 0x828B9264;
	sub_82DF3A08(ctx, base);
	// 828B9264: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828B9268: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B926C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9270: 4BD11291  bl 0x825ca500
	ctx.lr = 0x828B9274;
	sub_825CA500(ctx, base);
	// 828B9274: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B9278: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B927C: 4853A1AD  bl 0x82df3428
	ctx.lr = 0x828B9280;
	sub_82DF3428(ctx, base);
	// 828B9280: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9284: 4853A1A5  bl 0x82df3428
	ctx.lr = 0x828B9288;
	sub_82DF3428(ctx, base);
	// 828B9288: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B928C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9290: 388BBF7C  addi r4, r11, -0x4084
	ctx.r[4].s64 = ctx.r[11].s64 + -16516;
	// 828B9294: 4853A775  bl 0x82df3a08
	ctx.lr = 0x828B9298;
	sub_82DF3A08(ctx, base);
	// 828B9298: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B929C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B92A0: 388BBF68  addi r4, r11, -0x4098
	ctx.r[4].s64 = ctx.r[11].s64 + -16536;
	// 828B92A4: 4853A765  bl 0x82df3a08
	ctx.lr = 0x828B92A8;
	sub_82DF3A08(ctx, base);
	// 828B92A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B92AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B92B0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B92B4: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828B92B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B92BC: C3CB9528  lfs f30, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B92C0: 38610340  addi r3, r1, 0x340
	ctx.r[3].s64 = ctx.r[1].s64 + 832;
	// 828B92C4: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B92C8: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B92CC: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B92D0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828B92D4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B92D8: 4BCE9FD1  bl 0x825a32a8
	ctx.lr = 0x828B92DC;
	sub_825A32A8(ctx, base);
	// 828B92DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B92E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B92E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B92E8: 4BCE8489  bl 0x825a1770
	ctx.lr = 0x828B92EC;
	sub_825A1770(ctx, base);
	// 828B92EC: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 828B92F0: 4853A139  bl 0x82df3428
	ctx.lr = 0x828B92F4;
	sub_82DF3428(ctx, base);
	// 828B92F4: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 828B92F8: 4BA0F9C1  bl 0x822c8cb8
	ctx.lr = 0x828B92FC;
	sub_822C8CB8(ctx, base);
	// 828B92FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9300: 4853A129  bl 0x82df3428
	ctx.lr = 0x828B9304;
	sub_82DF3428(ctx, base);
	// 828B9304: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9308: 4853A121  bl 0x82df3428
	ctx.lr = 0x828B930C;
	sub_82DF3428(ctx, base);
	// 828B930C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9314: 388BBF54  addi r4, r11, -0x40ac
	ctx.r[4].s64 = ctx.r[11].s64 + -16556;
	// 828B9318: 4853A6F1  bl 0x82df3a08
	ctx.lr = 0x828B931C;
	sub_82DF3A08(ctx, base);
	// 828B931C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9320: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9324: 388BBF40  addi r4, r11, -0x40c0
	ctx.r[4].s64 = ctx.r[11].s64 + -16576;
	// 828B9328: 4853A6E1  bl 0x82df3a08
	ctx.lr = 0x828B932C;
	sub_82DF3A08(ctx, base);
	// 828B932C: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828B9330: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B9334: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B9338: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 828B933C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828B9340: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B9344: 4BCE9F65  bl 0x825a32a8
	ctx.lr = 0x828B9348;
	sub_825A32A8(ctx, base);
	// 828B9348: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B934C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B9350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9354: 4BCE841D  bl 0x825a1770
	ctx.lr = 0x828B9358;
	sub_825A1770(ctx, base);
	// 828B9358: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 828B935C: 4853A0CD  bl 0x82df3428
	ctx.lr = 0x828B9360;
	sub_82DF3428(ctx, base);
	// 828B9360: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 828B9364: 4BA0F955  bl 0x822c8cb8
	ctx.lr = 0x828B9368;
	sub_822C8CB8(ctx, base);
	// 828B9368: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B936C: 4853A0BD  bl 0x82df3428
	ctx.lr = 0x828B9370;
	sub_82DF3428(ctx, base);
	// 828B9370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9374: 4853A0B5  bl 0x82df3428
	ctx.lr = 0x828B9378;
	sub_82DF3428(ctx, base);
	// 828B9378: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B937C: 388BBF28  addi r4, r11, -0x40d8
	ctx.r[4].s64 = ctx.r[11].s64 + -16600;
	// 828B9380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9384: 4853A685  bl 0x82df3a08
	ctx.lr = 0x828B9388;
	sub_82DF3A08(ctx, base);
	// 828B9388: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B938C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9390: 388BBF18  addi r4, r11, -0x40e8
	ctx.r[4].s64 = ctx.r[11].s64 + -16616;
	// 828B9394: 4853A675  bl 0x82df3a08
	ctx.lr = 0x828B9398;
	sub_82DF3A08(ctx, base);
	// 828B9398: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828B939C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B93A0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B93A4: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 828B93A8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828B93AC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B93B0: 4BCE9EF9  bl 0x825a32a8
	ctx.lr = 0x828B93B4;
	sub_825A32A8(ctx, base);
	// 828B93B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B93B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B93BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B93C0: 4BCE83B1  bl 0x825a1770
	ctx.lr = 0x828B93C4;
	sub_825A1770(ctx, base);
	// 828B93C4: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 828B93C8: 4853A061  bl 0x82df3428
	ctx.lr = 0x828B93CC;
	sub_82DF3428(ctx, base);
	// 828B93CC: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 828B93D0: 4BA0F8E9  bl 0x822c8cb8
	ctx.lr = 0x828B93D4;
	sub_822C8CB8(ctx, base);
	// 828B93D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B93D8: 4853A051  bl 0x82df3428
	ctx.lr = 0x828B93DC;
	sub_82DF3428(ctx, base);
	// 828B93DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B93E0: 4853A049  bl 0x82df3428
	ctx.lr = 0x828B93E4;
	sub_82DF3428(ctx, base);
	// 828B93E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B93E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B93EC: 388BBEFC  addi r4, r11, -0x4104
	ctx.r[4].s64 = ctx.r[11].s64 + -16644;
	// 828B93F0: 4853A619  bl 0x82df3a08
	ctx.lr = 0x828B93F4;
	sub_82DF3A08(ctx, base);
	// 828B93F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B93F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B93FC: 388BBEE8  addi r4, r11, -0x4118
	ctx.r[4].s64 = ctx.r[11].s64 + -16664;
	// 828B9400: 4853A609  bl 0x82df3a08
	ctx.lr = 0x828B9404;
	sub_82DF3A08(ctx, base);
	// 828B9404: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828B9408: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B940C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B9410: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9414: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828B9418: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B941C: 4BCE9E8D  bl 0x825a32a8
	ctx.lr = 0x828B9420;
	sub_825A32A8(ctx, base);
	// 828B9420: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9424: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9428: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B942C: 4BCE8345  bl 0x825a1770
	ctx.lr = 0x828B9430;
	sub_825A1770(ctx, base);
	// 828B9430: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828B9434: 48539FF5  bl 0x82df3428
	ctx.lr = 0x828B9438;
	sub_82DF3428(ctx, base);
	// 828B9438: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828B943C: 4BA0F87D  bl 0x822c8cb8
	ctx.lr = 0x828B9440;
	sub_822C8CB8(ctx, base);
	// 828B9440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9444: 48539FE5  bl 0x82df3428
	ctx.lr = 0x828B9448;
	sub_82DF3428(ctx, base);
	// 828B9448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B944C: 48539FDD  bl 0x82df3428
	ctx.lr = 0x828B9450;
	sub_82DF3428(ctx, base);
	// 828B9450: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9458: 388BBED0  addi r4, r11, -0x4130
	ctx.r[4].s64 = ctx.r[11].s64 + -16688;
	// 828B945C: 4853A5AD  bl 0x82df3a08
	ctx.lr = 0x828B9460;
	sub_82DF3A08(ctx, base);
	// 828B9460: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9464: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9468: 388BBEC0  addi r4, r11, -0x4140
	ctx.r[4].s64 = ctx.r[11].s64 + -16704;
	// 828B946C: 4853A59D  bl 0x82df3a08
	ctx.lr = 0x828B9470;
	sub_82DF3A08(ctx, base);
	// 828B9470: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828B9474: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B9478: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B947C: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 828B9480: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828B9484: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B9488: 4BCE9E21  bl 0x825a32a8
	ctx.lr = 0x828B948C;
	sub_825A32A8(ctx, base);
	// 828B948C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9490: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B9494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9498: 4BCE82D9  bl 0x825a1770
	ctx.lr = 0x828B949C;
	sub_825A1770(ctx, base);
	// 828B949C: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 828B94A0: 48539F89  bl 0x82df3428
	ctx.lr = 0x828B94A4;
	sub_82DF3428(ctx, base);
	// 828B94A4: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 828B94A8: 4BA0F811  bl 0x822c8cb8
	ctx.lr = 0x828B94AC;
	sub_822C8CB8(ctx, base);
	// 828B94AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B94B0: 48539F79  bl 0x82df3428
	ctx.lr = 0x828B94B4;
	sub_82DF3428(ctx, base);
	// 828B94B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B94B8: 48539F71  bl 0x82df3428
	ctx.lr = 0x828B94BC;
	sub_82DF3428(ctx, base);
	// 828B94BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B94C0: 388BBEA8  addi r4, r11, -0x4158
	ctx.r[4].s64 = ctx.r[11].s64 + -16728;
	// 828B94C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B94C8: 4853A541  bl 0x82df3a08
	ctx.lr = 0x828B94CC;
	sub_82DF3A08(ctx, base);
	// 828B94CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B94D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B94D4: 388BBE98  addi r4, r11, -0x4168
	ctx.r[4].s64 = ctx.r[11].s64 + -16744;
	// 828B94D8: 4853A531  bl 0x82df3a08
	ctx.lr = 0x828B94DC;
	sub_82DF3A08(ctx, base);
	// 828B94DC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B94E0: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828B94E4: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B94E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B94EC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B94F0: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 828B94F4: C04B6218  lfs f2, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B94F8: 4BCE9DB1  bl 0x825a32a8
	ctx.lr = 0x828B94FC;
	sub_825A32A8(ctx, base);
	// 828B94FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9500: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B9504: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9508: 4BCE8269  bl 0x825a1770
	ctx.lr = 0x828B950C;
	sub_825A1770(ctx, base);
	// 828B950C: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 828B9510: 48539F19  bl 0x82df3428
	ctx.lr = 0x828B9514;
	sub_82DF3428(ctx, base);
	// 828B9514: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 828B9518: 4BA0F7A1  bl 0x822c8cb8
	ctx.lr = 0x828B951C;
	sub_822C8CB8(ctx, base);
	// 828B951C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9520: 48539F09  bl 0x82df3428
	ctx.lr = 0x828B9524;
	sub_82DF3428(ctx, base);
	// 828B9524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9528: 48539F01  bl 0x82df3428
	ctx.lr = 0x828B952C;
	sub_82DF3428(ctx, base);
	// 828B952C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9530: 4BD107A1  bl 0x825c9cd0
	ctx.lr = 0x828B9534;
	sub_825C9CD0(ctx, base);
	// 828B9534: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B953C: 388BBE88  addi r4, r11, -0x4178
	ctx.r[4].s64 = ctx.r[11].s64 + -16760;
	// 828B9540: 4853A4C9  bl 0x82df3a08
	ctx.lr = 0x828B9544;
	sub_82DF3A08(ctx, base);
	// 828B9544: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9548: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B954C: 388BB1AC  addi r4, r11, -0x4e54
	ctx.r[4].s64 = ctx.r[11].s64 + -20052;
	// 828B9550: 4853A4B9  bl 0x82df3a08
	ctx.lr = 0x828B9554;
	sub_82DF3A08(ctx, base);
	// 828B9554: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9558: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B955C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9560: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B9564: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B9568: 419A0024  beq cr6, 0x828b958c
	if ctx.cr[6].eq {
	pc = 0x828B958C; continue 'dispatch;
	}
	// 828B956C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9570: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9574: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9578: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B957C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9580: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9584: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9588: 4082FFE8  bne 0x828b9570
	if !ctx.cr[0].eq {
	pc = 0x828B9570; continue 'dispatch;
	}
	// 828B958C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B9590: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B9594: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9598: 387F00A8  addi r3, r31, 0xa8
	ctx.r[3].s64 = ctx.r[31].s64 + 168;
	// 828B959C: 4809E675  bl 0x82957c10
	ctx.lr = 0x828B95A0;
	sub_82957C10(ctx, base);
	// 828B95A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B95A4: 48539E85  bl 0x82df3428
	ctx.lr = 0x828B95A8;
	sub_82DF3428(ctx, base);
	// 828B95A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B95AC: 48539E7D  bl 0x82df3428
	ctx.lr = 0x828B95B0;
	sub_82DF3428(ctx, base);
	// 828B95B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B95B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B95B8: 388BBE7C  addi r4, r11, -0x4184
	ctx.r[4].s64 = ctx.r[11].s64 + -16772;
	// 828B95BC: 4853A44D  bl 0x82df3a08
	ctx.lr = 0x828B95C0;
	sub_82DF3A08(ctx, base);
	// 828B95C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B95C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B95C8: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 828B95CC: 4853A43D  bl 0x82df3a08
	ctx.lr = 0x828B95D0;
	sub_82DF3A08(ctx, base);
	// 828B95D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B95D4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B95D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B95DC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B95E0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B95E4: 419A0024  beq cr6, 0x828b9608
	if ctx.cr[6].eq {
	pc = 0x828B9608; continue 'dispatch;
	}
	// 828B95E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B95EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B95F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B95F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B95FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9600: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9604: 4082FFE8  bne 0x828b95ec
	if !ctx.cr[0].eq {
	pc = 0x828B95EC; continue 'dispatch;
	}
	// 828B9608: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B960C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B9610: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9614: 387F00B8  addi r3, r31, 0xb8
	ctx.r[3].s64 = ctx.r[31].s64 + 184;
	// 828B9618: 4809E5F9  bl 0x82957c10
	ctx.lr = 0x828B961C;
	sub_82957C10(ctx, base);
	// 828B961C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9620: 48539E09  bl 0x82df3428
	ctx.lr = 0x828B9624;
	sub_82DF3428(ctx, base);
	// 828B9624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9628: 48539E01  bl 0x82df3428
	ctx.lr = 0x828B962C;
	sub_82DF3428(ctx, base);
	// 828B962C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9634: 388BBE6C  addi r4, r11, -0x4194
	ctx.r[4].s64 = ctx.r[11].s64 + -16788;
	// 828B9638: 4853A3D1  bl 0x82df3a08
	ctx.lr = 0x828B963C;
	sub_82DF3A08(ctx, base);
	// 828B963C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9640: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9644: 388BB198  addi r4, r11, -0x4e68
	ctx.r[4].s64 = ctx.r[11].s64 + -20072;
	// 828B9648: 4853A3C1  bl 0x82df3a08
	ctx.lr = 0x828B964C;
	sub_82DF3A08(ctx, base);
	// 828B964C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9650: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9658: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B965C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B9660: 419A0024  beq cr6, 0x828b9684
	if ctx.cr[6].eq {
	pc = 0x828B9684; continue 'dispatch;
	}
	// 828B9664: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9668: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B966C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9670: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9674: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9678: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B967C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9680: 4082FFE8  bne 0x828b9668
	if !ctx.cr[0].eq {
	pc = 0x828B9668; continue 'dispatch;
	}
	// 828B9684: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B9688: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B968C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9690: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 828B9694: 4809E57D  bl 0x82957c10
	ctx.lr = 0x828B9698;
	sub_82957C10(ctx, base);
	// 828B9698: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B969C: 48539D8D  bl 0x82df3428
	ctx.lr = 0x828B96A0;
	sub_82DF3428(ctx, base);
	// 828B96A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B96A4: 48539D85  bl 0x82df3428
	ctx.lr = 0x828B96A8;
	sub_82DF3428(ctx, base);
	// 828B96A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B96AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B96B0: 388BBE5C  addi r4, r11, -0x41a4
	ctx.r[4].s64 = ctx.r[11].s64 + -16804;
	// 828B96B4: 4853A355  bl 0x82df3a08
	ctx.lr = 0x828B96B8;
	sub_82DF3A08(ctx, base);
	// 828B96B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B96BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B96C0: 388BBE50  addi r4, r11, -0x41b0
	ctx.r[4].s64 = ctx.r[11].s64 + -16816;
	// 828B96C4: 4853A345  bl 0x82df3a08
	ctx.lr = 0x828B96C8;
	sub_82DF3A08(ctx, base);
	// 828B96C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B96CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B96D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B96D4: 4BD10E2D  bl 0x825ca500
	ctx.lr = 0x828B96D8;
	sub_825CA500(ctx, base);
	// 828B96D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B96DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B96E0: 48539D49  bl 0x82df3428
	ctx.lr = 0x828B96E4;
	sub_82DF3428(ctx, base);
	// 828B96E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B96E8: 48539D41  bl 0x82df3428
	ctx.lr = 0x828B96EC;
	sub_82DF3428(ctx, base);
	// 828B96EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B96F0: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 828B96F4: 4BF50D3D  bl 0x8280a430
	ctx.lr = 0x828B96F8;
	sub_8280A430(ctx, base);
	// 828B96F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B96FC: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 828B9700: 388B83F8  addi r4, r11, -0x7c08
	ctx.r[4].s64 = ctx.r[11].s64 + -31752;
	// 828B9704: 4853A175  bl 0x82df3878
	ctx.lr = 0x828B9708;
	sub_82DF3878(ctx, base);
	// 828B9708: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B970C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 828B9710: 388B83D4  addi r4, r11, -0x7c2c
	ctx.r[4].s64 = ctx.r[11].s64 + -31788;
	// 828B9714: 4853A165  bl 0x82df3878
	ctx.lr = 0x828B9718;
	sub_82DF3878(ctx, base);
	// 828B9718: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B971C: 4BD105B5  bl 0x825c9cd0
	ctx.lr = 0x828B9720;
	sub_825C9CD0(ctx, base);
	// 828B9720: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9728: 388BBE40  addi r4, r11, -0x41c0
	ctx.r[4].s64 = ctx.r[11].s64 + -16832;
	// 828B972C: 4853A2DD  bl 0x82df3a08
	ctx.lr = 0x828B9730;
	sub_82DF3A08(ctx, base);
	// 828B9730: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9734: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9738: 388BA7FC  addi r4, r11, -0x5804
	ctx.r[4].s64 = ctx.r[11].s64 + -22532;
	// 828B973C: 4853A2CD  bl 0x82df3a08
	ctx.lr = 0x828B9740;
	sub_82DF3A08(ctx, base);
	// 828B9740: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9744: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B9748: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B974C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B9750: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9754: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B9758: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B975C: 4E800421  bctrl
	ctx.lr = 0x828B9760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9760: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9764: 48539CC5  bl 0x82df3428
	ctx.lr = 0x828B9768;
	sub_82DF3428(ctx, base);
	// 828B9768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B976C: 48539CBD  bl 0x82df3428
	ctx.lr = 0x828B9770;
	sub_82DF3428(ctx, base);
	// 828B9770: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9778: 388BBE30  addi r4, r11, -0x41d0
	ctx.r[4].s64 = ctx.r[11].s64 + -16848;
	// 828B977C: 4853A28D  bl 0x82df3a08
	ctx.lr = 0x828B9780;
	sub_82DF3A08(ctx, base);
	// 828B9780: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9784: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9788: 388BBE24  addi r4, r11, -0x41dc
	ctx.r[4].s64 = ctx.r[11].s64 + -16860;
	// 828B978C: 4853A27D  bl 0x82df3a08
	ctx.lr = 0x828B9790;
	sub_82DF3A08(ctx, base);
	// 828B9790: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B9794: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B9798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B979C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B97A0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B97A4: 419A0024  beq cr6, 0x828b97c8
	if ctx.cr[6].eq {
	pc = 0x828B97C8; continue 'dispatch;
	}
	// 828B97A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B97AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B97B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B97B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B97BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B97C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97C4: 4082FFE8  bne 0x828b97ac
	if !ctx.cr[0].eq {
	pc = 0x828B97AC; continue 'dispatch;
	}
	// 828B97C8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 828B97CC: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 828B97D0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B97D4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B97D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B97DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B97E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B97E4: 4E800421  bctrl
	ctx.lr = 0x828B97E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B97E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B97EC: 48539C3D  bl 0x82df3428
	ctx.lr = 0x828B97F0;
	sub_82DF3428(ctx, base);
	// 828B97F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B97F4: 48539C35  bl 0x82df3428
	ctx.lr = 0x828B97F8;
	sub_82DF3428(ctx, base);
	// 828B97F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B97FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9800: 388BA880  addi r4, r11, -0x5780
	ctx.r[4].s64 = ctx.r[11].s64 + -22400;
	// 828B9804: 4853A205  bl 0x82df3a08
	ctx.lr = 0x828B9808;
	sub_82DF3A08(ctx, base);
	// 828B9808: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B980C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9810: 388BA7F4  addi r4, r11, -0x580c
	ctx.r[4].s64 = ctx.r[11].s64 + -22540;
	// 828B9814: 4853A1F5  bl 0x82df3a08
	ctx.lr = 0x828B9818;
	sub_82DF3A08(ctx, base);
	// 828B9818: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B981C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B9820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9824: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B9828: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B982C: 419A0024  beq cr6, 0x828b9850
	if ctx.cr[6].eq {
	pc = 0x828B9850; continue 'dispatch;
	}
	// 828B9830: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9834: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9838: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B983C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9840: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9844: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9848: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B984C: 4082FFE8  bne 0x828b9834
	if !ctx.cr[0].eq {
	pc = 0x828B9834; continue 'dispatch;
	}
	// 828B9850: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 828B9854: 387F0134  addi r3, r31, 0x134
	ctx.r[3].s64 = ctx.r[31].s64 + 308;
	// 828B9858: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B985C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B9860: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9864: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B986C: 4E800421  bctrl
	ctx.lr = 0x828B9870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9870: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9874: 48539BB5  bl 0x82df3428
	ctx.lr = 0x828B9878;
	sub_82DF3428(ctx, base);
	// 828B9878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B987C: 48539BAD  bl 0x82df3428
	ctx.lr = 0x828B9880;
	sub_82DF3428(ctx, base);
	// 828B9880: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9888: 388BBE08  addi r4, r11, -0x41f8
	ctx.r[4].s64 = ctx.r[11].s64 + -16888;
	// 828B988C: 4853A17D  bl 0x82df3a08
	ctx.lr = 0x828B9890;
	sub_82DF3A08(ctx, base);
	// 828B9890: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9894: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9898: 388BBDF4  addi r4, r11, -0x420c
	ctx.r[4].s64 = ctx.r[11].s64 + -16908;
	// 828B989C: 4853A16D  bl 0x82df3a08
	ctx.lr = 0x828B98A0;
	sub_82DF3A08(ctx, base);
	// 828B98A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B98A4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B98A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B98AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B98B0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B98B4: 419A0024  beq cr6, 0x828b98d8
	if ctx.cr[6].eq {
	pc = 0x828B98D8; continue 'dispatch;
	}
	// 828B98B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B98BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B98C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B98C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B98CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B98D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98D4: 4082FFE8  bne 0x828b98bc
	if !ctx.cr[0].eq {
	pc = 0x828B98BC; continue 'dispatch;
	}
	// 828B98D8: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 828B98DC: 387F0174  addi r3, r31, 0x174
	ctx.r[3].s64 = ctx.r[31].s64 + 372;
	// 828B98E0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B98E4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B98E8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B98EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B98F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B98F4: 4E800421  bctrl
	ctx.lr = 0x828B98F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B98F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B98FC: 48539B2D  bl 0x82df3428
	ctx.lr = 0x828B9900;
	sub_82DF3428(ctx, base);
	// 828B9900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9904: 48539B25  bl 0x82df3428
	ctx.lr = 0x828B9908;
	sub_82DF3428(ctx, base);
	// 828B9908: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B990C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9910: 388BBDD8  addi r4, r11, -0x4228
	ctx.r[4].s64 = ctx.r[11].s64 + -16936;
	// 828B9914: 4853A0F5  bl 0x82df3a08
	ctx.lr = 0x828B9918;
	sub_82DF3A08(ctx, base);
	// 828B9918: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B991C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9920: 388BBDC4  addi r4, r11, -0x423c
	ctx.r[4].s64 = ctx.r[11].s64 + -16956;
	// 828B9924: 4853A0E5  bl 0x82df3a08
	ctx.lr = 0x828B9928;
	sub_82DF3A08(ctx, base);
	// 828B9928: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B992C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B9930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9934: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B9938: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B993C: 419A0024  beq cr6, 0x828b9960
	if ctx.cr[6].eq {
	pc = 0x828B9960; continue 'dispatch;
	}
	// 828B9940: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9944: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9948: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B994C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9950: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9954: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9958: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B995C: 4082FFE8  bne 0x828b9944
	if !ctx.cr[0].eq {
	pc = 0x828B9944; continue 'dispatch;
	}
	// 828B9960: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 828B9964: 387F0198  addi r3, r31, 0x198
	ctx.r[3].s64 = ctx.r[31].s64 + 408;
	// 828B9968: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B996C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B9970: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9974: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B997C: 4E800421  bctrl
	ctx.lr = 0x828B9980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9980: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9984: 48539AA5  bl 0x82df3428
	ctx.lr = 0x828B9988;
	sub_82DF3428(ctx, base);
	// 828B9988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B998C: 48539A9D  bl 0x82df3428
	ctx.lr = 0x828B9990;
	sub_82DF3428(ctx, base);
	// 828B9990: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9998: 388BBDA8  addi r4, r11, -0x4258
	ctx.r[4].s64 = ctx.r[11].s64 + -16984;
	// 828B999C: 4853A06D  bl 0x82df3a08
	ctx.lr = 0x828B99A0;
	sub_82DF3A08(ctx, base);
	// 828B99A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B99A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B99A8: 388BBD90  addi r4, r11, -0x4270
	ctx.r[4].s64 = ctx.r[11].s64 + -17008;
	// 828B99AC: 4853A05D  bl 0x82df3a08
	ctx.lr = 0x828B99B0;
	sub_82DF3A08(ctx, base);
	// 828B99B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B99B4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B99B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B99BC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B99C0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B99C4: 419A0024  beq cr6, 0x828b99e8
	if ctx.cr[6].eq {
	pc = 0x828B99E8; continue 'dispatch;
	}
	// 828B99C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B99CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B99D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B99D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B99D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B99DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B99E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B99E4: 4082FFE8  bne 0x828b99cc
	if !ctx.cr[0].eq {
	pc = 0x828B99CC; continue 'dispatch;
	}
	// 828B99E8: 817F01BC  lwz r11, 0x1bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 828B99EC: 387F01BC  addi r3, r31, 0x1bc
	ctx.r[3].s64 = ctx.r[31].s64 + 444;
	// 828B99F0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B99F4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B99F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B99FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9A00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B9A04: 4E800421  bctrl
	ctx.lr = 0x828B9A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9A08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9A0C: 48539A1D  bl 0x82df3428
	ctx.lr = 0x828B9A10;
	sub_82DF3428(ctx, base);
	// 828B9A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9A14: 48539A15  bl 0x82df3428
	ctx.lr = 0x828B9A18;
	sub_82DF3428(ctx, base);
	// 828B9A18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9A20: 388BBD74  addi r4, r11, -0x428c
	ctx.r[4].s64 = ctx.r[11].s64 + -17036;
	// 828B9A24: 48539FE5  bl 0x82df3a08
	ctx.lr = 0x828B9A28;
	sub_82DF3A08(ctx, base);
	// 828B9A28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9A2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9A30: 388BBD5C  addi r4, r11, -0x42a4
	ctx.r[4].s64 = ctx.r[11].s64 + -17060;
	// 828B9A34: 48539FD5  bl 0x82df3a08
	ctx.lr = 0x828B9A38;
	sub_82DF3A08(ctx, base);
	// 828B9A38: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B9A3C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828B9A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9A44: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B9A48: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828B9A4C: 419A0024  beq cr6, 0x828b9a70
	if ctx.cr[6].eq {
	pc = 0x828B9A70; continue 'dispatch;
	}
	// 828B9A50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9A54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9A58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9A5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9A60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9A64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9A68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9A6C: 4082FFE8  bne 0x828b9a54
	if !ctx.cr[0].eq {
	pc = 0x828B9A54; continue 'dispatch;
	}
	// 828B9A70: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 828B9A74: 387F01E0  addi r3, r31, 0x1e0
	ctx.r[3].s64 = ctx.r[31].s64 + 480;
	// 828B9A78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828B9A7C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828B9A80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9A84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9A88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B9A8C: 4E800421  bctrl
	ctx.lr = 0x828B9A90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9A90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9A94: 48539995  bl 0x82df3428
	ctx.lr = 0x828B9A98;
	sub_82DF3428(ctx, base);
	// 828B9A98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9A9C: 4853998D  bl 0x82df3428
	ctx.lr = 0x828B9AA0;
	sub_82DF3428(ctx, base);
	// 828B9AA0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828B9AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B9AA8: 419A0008  beq cr6, 0x828b9ab0
	if ctx.cr[6].eq {
	pc = 0x828B9AB0; continue 'dispatch;
	}
	// 828B9AAC: 4BA06DE5  bl 0x822c0890
	ctx.lr = 0x828B9AB0;
	sub_822C0890(ctx, base);
	// 828B9AB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9AB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9AB8: 388BBD4C  addi r4, r11, -0x42b4
	ctx.r[4].s64 = ctx.r[11].s64 + -17076;
	// 828B9ABC: 48539F4D  bl 0x82df3a08
	ctx.lr = 0x828B9AC0;
	sub_82DF3A08(ctx, base);
	// 828B9AC0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828B9AC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9AC8: 388B74E8  addi r4, r11, 0x74e8
	ctx.r[4].s64 = ctx.r[11].s64 + 29928;
	// 828B9ACC: 48539F3D  bl 0x82df3a08
	ctx.lr = 0x828B9AD0;
	sub_82DF3A08(ctx, base);
	// 828B9AD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B9AD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B9AD8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9ADC: 4BD10A25  bl 0x825ca500
	ctx.lr = 0x828B9AE0;
	sub_825CA500(ctx, base);
	// 828B9AE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B9AE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9AE8: 48539941  bl 0x82df3428
	ctx.lr = 0x828B9AEC;
	sub_82DF3428(ctx, base);
	// 828B9AEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9AF0: 48539939  bl 0x82df3428
	ctx.lr = 0x828B9AF4;
	sub_82DF3428(ctx, base);
	// 828B9AF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9AF8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9AFC: 388BBD34  addi r4, r11, -0x42cc
	ctx.r[4].s64 = ctx.r[11].s64 + -17100;
	// 828B9B00: 48539F09  bl 0x82df3a08
	ctx.lr = 0x828B9B04;
	sub_82DF3A08(ctx, base);
	// 828B9B04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9B08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9B0C: 388BBD1C  addi r4, r11, -0x42e4
	ctx.r[4].s64 = ctx.r[11].s64 + -17124;
	// 828B9B10: 48539EF9  bl 0x82df3a08
	ctx.lr = 0x828B9B14;
	sub_82DF3A08(ctx, base);
	// 828B9B14: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B9B18: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 828B9B1C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B9B20: 38BF0204  addi r5, r31, 0x204
	ctx.r[5].s64 = ctx.r[31].s64 + 516;
	// 828B9B24: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9B28: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828B9B2C: 4BCE98ED  bl 0x825a3418
	ctx.lr = 0x828B9B30;
	sub_825A3418(ctx, base);
	// 828B9B30: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9B34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9B38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9B3C: 4BCE8125  bl 0x825a1c60
	ctx.lr = 0x828B9B40;
	sub_825A1C60(ctx, base);
	// 828B9B40: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828B9B44: 485398E5  bl 0x82df3428
	ctx.lr = 0x828B9B48;
	sub_82DF3428(ctx, base);
	// 828B9B48: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828B9B4C: 4BA0F16D  bl 0x822c8cb8
	ctx.lr = 0x828B9B50;
	sub_822C8CB8(ctx, base);
	// 828B9B50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9B54: 485398D5  bl 0x82df3428
	ctx.lr = 0x828B9B58;
	sub_82DF3428(ctx, base);
	// 828B9B58: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9B5C: 485398CD  bl 0x82df3428
	ctx.lr = 0x828B9B60;
	sub_82DF3428(ctx, base);
	// 828B9B60: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9B64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9B68: 388BBD04  addi r4, r11, -0x42fc
	ctx.r[4].s64 = ctx.r[11].s64 + -17148;
	// 828B9B6C: 48539E9D  bl 0x82df3a08
	ctx.lr = 0x828B9B70;
	sub_82DF3A08(ctx, base);
	// 828B9B70: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9B74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9B78: 388BBCEC  addi r4, r11, -0x4314
	ctx.r[4].s64 = ctx.r[11].s64 + -17172;
	// 828B9B7C: 48539E8D  bl 0x82df3a08
	ctx.lr = 0x828B9B80;
	sub_82DF3A08(ctx, base);
	// 828B9B80: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B9B84: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 828B9B88: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B9B8C: 38BF0208  addi r5, r31, 0x208
	ctx.r[5].s64 = ctx.r[31].s64 + 520;
	// 828B9B90: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9B94: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828B9B98: 4BCE9881  bl 0x825a3418
	ctx.lr = 0x828B9B9C;
	sub_825A3418(ctx, base);
	// 828B9B9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9BA0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9BA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9BA8: 4BCE80B9  bl 0x825a1c60
	ctx.lr = 0x828B9BAC;
	sub_825A1C60(ctx, base);
	// 828B9BAC: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 828B9BB0: 48539879  bl 0x82df3428
	ctx.lr = 0x828B9BB4;
	sub_82DF3428(ctx, base);
	// 828B9BB4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828B9BB8: 4BA0F101  bl 0x822c8cb8
	ctx.lr = 0x828B9BBC;
	sub_822C8CB8(ctx, base);
	// 828B9BBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9BC0: 48539869  bl 0x82df3428
	ctx.lr = 0x828B9BC4;
	sub_82DF3428(ctx, base);
	// 828B9BC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9BC8: 48539861  bl 0x82df3428
	ctx.lr = 0x828B9BCC;
	sub_82DF3428(ctx, base);
	// 828B9BCC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9BD0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9BD4: 388BBCD4  addi r4, r11, -0x432c
	ctx.r[4].s64 = ctx.r[11].s64 + -17196;
	// 828B9BD8: 48539E31  bl 0x82df3a08
	ctx.lr = 0x828B9BDC;
	sub_82DF3A08(ctx, base);
	// 828B9BDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9BE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9BE4: 388BBCBC  addi r4, r11, -0x4344
	ctx.r[4].s64 = ctx.r[11].s64 + -17220;
	// 828B9BE8: 48539E21  bl 0x82df3a08
	ctx.lr = 0x828B9BEC;
	sub_82DF3A08(ctx, base);
	// 828B9BEC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B9BF0: 38E003E8  li r7, 0x3e8
	ctx.r[7].s64 = 1000;
	// 828B9BF4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B9BF8: 38BF020C  addi r5, r31, 0x20c
	ctx.r[5].s64 = ctx.r[31].s64 + 524;
	// 828B9BFC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9C00: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 828B9C04: 4BCE9815  bl 0x825a3418
	ctx.lr = 0x828B9C08;
	sub_825A3418(ctx, base);
	// 828B9C08: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9C10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9C14: 4BCE804D  bl 0x825a1c60
	ctx.lr = 0x828B9C18;
	sub_825A1C60(ctx, base);
	// 828B9C18: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 828B9C1C: 4853980D  bl 0x82df3428
	ctx.lr = 0x828B9C20;
	sub_82DF3428(ctx, base);
	// 828B9C20: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 828B9C24: 4BA0F095  bl 0x822c8cb8
	ctx.lr = 0x828B9C28;
	sub_822C8CB8(ctx, base);
	// 828B9C28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9C2C: 485397FD  bl 0x82df3428
	ctx.lr = 0x828B9C30;
	sub_82DF3428(ctx, base);
	// 828B9C30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9C34: 485397F5  bl 0x82df3428
	ctx.lr = 0x828B9C38;
	sub_82DF3428(ctx, base);
	// 828B9C38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9C3C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9C40: 388BBCA4  addi r4, r11, -0x435c
	ctx.r[4].s64 = ctx.r[11].s64 + -17244;
	// 828B9C44: 48539DC5  bl 0x82df3a08
	ctx.lr = 0x828B9C48;
	sub_82DF3A08(ctx, base);
	// 828B9C48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9C4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9C50: 388BBC8C  addi r4, r11, -0x4374
	ctx.r[4].s64 = ctx.r[11].s64 + -17268;
	// 828B9C54: 48539DB5  bl 0x82df3a08
	ctx.lr = 0x828B9C58;
	sub_82DF3A08(ctx, base);
	// 828B9C58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B9C5C: 38BF0210  addi r5, r31, 0x210
	ctx.r[5].s64 = ctx.r[31].s64 + 528;
	// 828B9C60: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828B9C64: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9C68: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B9C6C: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 828B9C70: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B9C74: 4BCE9635  bl 0x825a32a8
	ctx.lr = 0x828B9C78;
	sub_825A32A8(ctx, base);
	// 828B9C78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9C7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9C80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9C84: 4BCE7AED  bl 0x825a1770
	ctx.lr = 0x828B9C88;
	sub_825A1770(ctx, base);
	// 828B9C88: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 828B9C8C: 4853979D  bl 0x82df3428
	ctx.lr = 0x828B9C90;
	sub_82DF3428(ctx, base);
	// 828B9C90: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 828B9C94: 4BA0F025  bl 0x822c8cb8
	ctx.lr = 0x828B9C98;
	sub_822C8CB8(ctx, base);
	// 828B9C98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9C9C: 4853978D  bl 0x82df3428
	ctx.lr = 0x828B9CA0;
	sub_82DF3428(ctx, base);
	// 828B9CA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9CA4: 48539785  bl 0x82df3428
	ctx.lr = 0x828B9CA8;
	sub_82DF3428(ctx, base);
	// 828B9CA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9CAC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9CB0: 388BBC74  addi r4, r11, -0x438c
	ctx.r[4].s64 = ctx.r[11].s64 + -17292;
	// 828B9CB4: 48539D55  bl 0x82df3a08
	ctx.lr = 0x828B9CB8;
	sub_82DF3A08(ctx, base);
	// 828B9CB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9CBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9CC0: 388BBC58  addi r4, r11, -0x43a8
	ctx.r[4].s64 = ctx.r[11].s64 + -17320;
	// 828B9CC4: 48539D45  bl 0x82df3a08
	ctx.lr = 0x828B9CC8;
	sub_82DF3A08(ctx, base);
	// 828B9CC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B9CCC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B9CD0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828B9CD4: 38BF0214  addi r5, r31, 0x214
	ctx.r[5].s64 = ctx.r[31].s64 + 532;
	// 828B9CD8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9CDC: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 828B9CE0: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B9CE4: C02A964C  lfs f1, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B9CE8: 4BCE95C1  bl 0x825a32a8
	ctx.lr = 0x828B9CEC;
	sub_825A32A8(ctx, base);
	// 828B9CEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9CF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9CF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9CF8: 4BCE7A79  bl 0x825a1770
	ctx.lr = 0x828B9CFC;
	sub_825A1770(ctx, base);
	// 828B9CFC: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 828B9D00: 48539729  bl 0x82df3428
	ctx.lr = 0x828B9D04;
	sub_82DF3428(ctx, base);
	// 828B9D04: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 828B9D08: 4BA0EFB1  bl 0x822c8cb8
	ctx.lr = 0x828B9D0C;
	sub_822C8CB8(ctx, base);
	// 828B9D0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9D10: 48539719  bl 0x82df3428
	ctx.lr = 0x828B9D14;
	sub_82DF3428(ctx, base);
	// 828B9D14: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9D18: 48539711  bl 0x82df3428
	ctx.lr = 0x828B9D1C;
	sub_82DF3428(ctx, base);
	// 828B9D1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9D20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9D24: 388BBC34  addi r4, r11, -0x43cc
	ctx.r[4].s64 = ctx.r[11].s64 + -17356;
	// 828B9D28: 48539CE1  bl 0x82df3a08
	ctx.lr = 0x828B9D2C;
	sub_82DF3A08(ctx, base);
	// 828B9D2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9D34: 388BBC1C  addi r4, r11, -0x43e4
	ctx.r[4].s64 = ctx.r[11].s64 + -17380;
	// 828B9D38: 48539CD1  bl 0x82df3a08
	ctx.lr = 0x828B9D3C;
	sub_82DF3A08(ctx, base);
	// 828B9D3C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B9D40: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 828B9D44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B9D48: 38BF0218  addi r5, r31, 0x218
	ctx.r[5].s64 = ctx.r[31].s64 + 536;
	// 828B9D4C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9D50: 38610300  addi r3, r1, 0x300
	ctx.r[3].s64 = ctx.r[1].s64 + 768;
	// 828B9D54: 4BCE96C5  bl 0x825a3418
	ctx.lr = 0x828B9D58;
	sub_825A3418(ctx, base);
	// 828B9D58: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9D5C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9D60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9D64: 4BCE8175  bl 0x825a1ed8
	ctx.lr = 0x828B9D68;
	sub_825A1ED8(ctx, base);
	// 828B9D68: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 828B9D6C: 485396BD  bl 0x82df3428
	ctx.lr = 0x828B9D70;
	sub_82DF3428(ctx, base);
	// 828B9D70: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 828B9D74: 4BA0EF45  bl 0x822c8cb8
	ctx.lr = 0x828B9D78;
	sub_822C8CB8(ctx, base);
	// 828B9D78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9D7C: 485396AD  bl 0x82df3428
	ctx.lr = 0x828B9D80;
	sub_82DF3428(ctx, base);
	// 828B9D80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9D84: 485396A5  bl 0x82df3428
	ctx.lr = 0x828B9D88;
	sub_82DF3428(ctx, base);
	// 828B9D88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9D8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B9D90: 388BBBA8  addi r4, r11, -0x4458
	ctx.r[4].s64 = ctx.r[11].s64 + -17496;
	// 828B9D94: 38A000BF  li r5, 0xbf
	ctx.r[5].s64 = 191;
	// 828B9D98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B9D9C: 4BA0663D  bl 0x822c03d8
	ctx.lr = 0x828B9DA0;
	sub_822C03D8(ctx, base);
	// 828B9DA0: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828B9DA4: 41820034  beq 0x828b9dd8
	if ctx.cr[0].eq {
	pc = 0x828B9DD8; continue 'dispatch;
	}
	// 828B9DA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9DAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9DB0: 388BBB84  addi r4, r11, -0x447c
	ctx.r[4].s64 = ctx.r[11].s64 + -17532;
	// 828B9DB4: 48539C55  bl 0x82df3a08
	ctx.lr = 0x828B9DB8;
	sub_82DF3A08(ctx, base);
	// 828B9DB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B9DBC: 38BF021C  addi r5, r31, 0x21c
	ctx.r[5].s64 = ctx.r[31].s64 + 540;
	// 828B9DC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9DC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B9DC8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828B9DCC: 4BCF2645  bl 0x825ac410
	ctx.lr = 0x828B9DD0;
	sub_825AC410(ctx, base);
	// 828B9DD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B9DD4: 48000008  b 0x828b9ddc
	pc = 0x828B9DDC; continue 'dispatch;
	// 828B9DD8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B9DDC: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828B9DE0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B9DE4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828B9DE8: 4BC395D1  bl 0x824f33b8
	ctx.lr = 0x828B9DEC;
	sub_824F33B8(ctx, base);
	// 828B9DEC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B9DF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B9DF4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828B9DF8: 4BA06209  bl 0x822c0000
	ctx.lr = 0x828B9DFC;
	sub_822C0000(ctx, base);
	// 828B9DFC: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9E00: 4182000C  beq 0x828b9e0c
	if ctx.cr[0].eq {
	pc = 0x828B9E0C; continue 'dispatch;
	}
	// 828B9E04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9E08: 48539621  bl 0x82df3428
	ctx.lr = 0x828B9E0C;
	sub_82DF3428(ctx, base);
	// 828B9E0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9E10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9E14: 388BBB70  addi r4, r11, -0x4490
	ctx.r[4].s64 = ctx.r[11].s64 + -17552;
	// 828B9E18: 48539BF1  bl 0x82df3a08
	ctx.lr = 0x828B9E1C;
	sub_82DF3A08(ctx, base);
	// 828B9E1C: 83610068  lwz r27, 0x68(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B9E20: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828B9E24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B9E28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B9E2C: 4BCF1F95  bl 0x825abdc0
	ctx.lr = 0x828B9E30;
	sub_825ABDC0(ctx, base);
	// 828B9E30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9E34: 485395F5  bl 0x82df3428
	ctx.lr = 0x828B9E38;
	sub_82DF3428(ctx, base);
	// 828B9E38: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828B9E3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9E40: 388B7540  addi r4, r11, 0x7540
	ctx.r[4].s64 = ctx.r[11].s64 + 30016;
	// 828B9E44: 48539BC5  bl 0x82df3a08
	ctx.lr = 0x828B9E48;
	sub_82DF3A08(ctx, base);
	// 828B9E48: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828B9E4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B9E50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B9E54: 4BCF1F6D  bl 0x825abdc0
	ctx.lr = 0x828B9E58;
	sub_825ABDC0(ctx, base);
	// 828B9E58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9E5C: 485395CD  bl 0x82df3428
	ctx.lr = 0x828B9E60;
	sub_82DF3428(ctx, base);
	// 828B9E60: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9E64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9E68: 388BBB54  addi r4, r11, -0x44ac
	ctx.r[4].s64 = ctx.r[11].s64 + -17580;
	// 828B9E6C: 48539B9D  bl 0x82df3a08
	ctx.lr = 0x828B9E70;
	sub_82DF3A08(ctx, base);
	// 828B9E70: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B9E74: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 828B9E78: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B9E7C: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 828B9E80: 419A0024  beq cr6, 0x828b9ea4
	if ctx.cr[6].eq {
	pc = 0x828B9EA4; continue 'dispatch;
	}
	// 828B9E84: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828B9E88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9E8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9E90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9E94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9E98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9E9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9EA0: 4082FFE8  bne 0x828b9e88
	if !ctx.cr[0].eq {
	pc = 0x828B9E88; continue 'dispatch;
	}
	// 828B9EA4: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 828B9EA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9EAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9EB0: 4BCE8261  bl 0x825a2110
	ctx.lr = 0x828B9EB4;
	sub_825A2110(ctx, base);
	// 828B9EB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9EB8: 48539571  bl 0x82df3428
	ctx.lr = 0x828B9EBC;
	sub_82DF3428(ctx, base);
	// 828B9EBC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9EC0: 4BD0FE11  bl 0x825c9cd0
	ctx.lr = 0x828B9EC4;
	sub_825C9CD0(ctx, base);
	// 828B9EC4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B9EC8: 419A000C  beq cr6, 0x828b9ed4
	if ctx.cr[6].eq {
	pc = 0x828B9ED4; continue 'dispatch;
	}
	// 828B9ECC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B9ED0: 4BA069C1  bl 0x822c0890
	ctx.lr = 0x828B9ED4;
	sub_822C0890(ctx, base);
	// 828B9ED4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9EDC: 388BBB4C  addi r4, r11, -0x44b4
	ctx.r[4].s64 = ctx.r[11].s64 + -17588;
	// 828B9EE0: 48539B29  bl 0x82df3a08
	ctx.lr = 0x828B9EE4;
	sub_82DF3A08(ctx, base);
	// 828B9EE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9EE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9EEC: 388BBB3C  addi r4, r11, -0x44c4
	ctx.r[4].s64 = ctx.r[11].s64 + -17604;
	// 828B9EF0: 48539B19  bl 0x82df3a08
	ctx.lr = 0x828B9EF4;
	sub_82DF3A08(ctx, base);
	// 828B9EF4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B9EF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B9EFC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9F00: 4BD10601  bl 0x825ca500
	ctx.lr = 0x828B9F04;
	sub_825CA500(ctx, base);
	// 828B9F04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B9F08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B9F0C: 4853951D  bl 0x82df3428
	ctx.lr = 0x828B9F10;
	sub_82DF3428(ctx, base);
	// 828B9F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9F14: 48539515  bl 0x82df3428
	ctx.lr = 0x828B9F18;
	sub_82DF3428(ctx, base);
	// 828B9F18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9F1C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9F20: 388BBB1C  addi r4, r11, -0x44e4
	ctx.r[4].s64 = ctx.r[11].s64 + -17636;
	// 828B9F24: 48539AE5  bl 0x82df3a08
	ctx.lr = 0x828B9F28;
	sub_82DF3A08(ctx, base);
	// 828B9F28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B9F2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9F30: 388BBB00  addi r4, r11, -0x4500
	ctx.r[4].s64 = ctx.r[11].s64 + -17664;
	// 828B9F34: 48539AD5  bl 0x82df3a08
	ctx.lr = 0x828B9F38;
	sub_82DF3A08(ctx, base);
	// 828B9F38: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B9F3C: 38E02710  li r7, 0x2710
	ctx.r[7].s64 = 10000;
	// 828B9F40: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B9F44: 38BF0220  addi r5, r31, 0x220
	ctx.r[5].s64 = ctx.r[31].s64 + 544;
	// 828B9F48: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828B9F4C: 38610380  addi r3, r1, 0x380
	ctx.r[3].s64 = ctx.r[1].s64 + 896;
	// 828B9F50: 4BCE94C9  bl 0x825a3418
	ctx.lr = 0x828B9F54;
	sub_825A3418(ctx, base);
	// 828B9F54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B9F58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B9F5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B9F60: 4BCE7D01  bl 0x825a1c60
	ctx.lr = 0x828B9F64;
	sub_825A1C60(ctx, base);
	// 828B9F64: 386103B8  addi r3, r1, 0x3b8
	ctx.r[3].s64 = ctx.r[1].s64 + 952;
	// 828B9F68: 485394C1  bl 0x82df3428
	ctx.lr = 0x828B9F6C;
	sub_82DF3428(ctx, base);
	// 828B9F6C: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 828B9F70: 4BA0ED49  bl 0x822c8cb8
	ctx.lr = 0x828B9F74;
	sub_822C8CB8(ctx, base);
	// 828B9F74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9F78: 485394B1  bl 0x82df3428
	ctx.lr = 0x828B9F7C;
	sub_82DF3428(ctx, base);
	// 828B9F7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B9F80: 485394A9  bl 0x82df3428
	ctx.lr = 0x828B9F84;
	sub_82DF3428(ctx, base);
	// 828B9F84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9F88: 4BD0FD49  bl 0x825c9cd0
	ctx.lr = 0x828B9F8C;
	sub_825C9CD0(ctx, base);
	// 828B9F8C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9F90: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9F98: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 828B9F9C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828B9FA0: 419A0024  beq cr6, 0x828b9fc4
	if ctx.cr[6].eq {
	pc = 0x828B9FC4; continue 'dispatch;
	}
	// 828B9FA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9FA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9FAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9FB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9FB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9FB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9FBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9FC0: 4082FFE8  bne 0x828b9fa8
	if !ctx.cr[0].eq {
	pc = 0x828B9FA8; continue 'dispatch;
	}
	// 828B9FC4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828B9FC8: 387F0260  addi r3, r31, 0x260
	ctx.r[3].s64 = ctx.r[31].s64 + 608;
	// 828B9FCC: 480A125D  bl 0x8295b228
	ctx.lr = 0x828B9FD0;
	sub_8295B228(ctx, base);
	// 828B9FD0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9FD4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9FDC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 828B9FE0: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828B9FE4: 419A0024  beq cr6, 0x828ba008
	if ctx.cr[6].eq {
	pc = 0x828BA008; continue 'dispatch;
	}
	// 828B9FE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9FEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9FF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9FF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9FF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B9FFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BA000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BA004: 4082FFE8  bne 0x828b9fec
	if !ctx.cr[0].eq {
	pc = 0x828B9FEC; continue 'dispatch;
	}
	// 828BA008: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828BA00C: 387F026C  addi r3, r31, 0x26c
	ctx.r[3].s64 = ctx.r[31].s64 + 620;
	// 828BA010: 480A1169  bl 0x8295b178
	ctx.lr = 0x828BA014;
	sub_8295B178(ctx, base);
	// 828BA014: 38210410  addi r1, r1, 0x410
	ctx.r[1].s64 = ctx.r[1].s64 + 1040;
	// 828BA018: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828BA01C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828BA020: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828BA024: 488EE190  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA028 size=72
    let mut pc: u32 = 0x828BA028;
    'dispatch: loop {
        match pc {
            0x828BA028 => {
    //   block [0x828BA028..0x828BA070)
	// 828BA028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA034: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA03C: 485A28ED  bl 0x82e5c928
	ctx.lr = 0x828BA040;
	sub_82E5C928(ctx, base);
	// 828BA040: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BA044: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BA048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA04C: 394ABFC4  addi r10, r10, -0x403c
	ctx.r[10].s64 = ctx.r[10].s64 + -16444;
	// 828BA050: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA054: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BA058: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BA05C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BA060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA06C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA070 size=84
    let mut pc: u32 = 0x828BA070;
    'dispatch: loop {
        match pc {
            0x828BA070 => {
    //   block [0x828BA070..0x828BA0C4)
	// 828BA070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA07C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA080: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BA084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA08C: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828BA090: 48539979  bl 0x82df3a08
	ctx.lr = 0x828BA094;
	sub_82DF3A08(ctx, base);
	// 828BA094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA098: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828BA09C: 4889A565  bl 0x83154600
	ctx.lr = 0x828BA0A0;
	sub_83154600(ctx, base);
	// 828BA0A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BA0A4: 4BF3569D  bl 0x827ef740
	ctx.lr = 0x828BA0A8;
	sub_827EF740(ctx, base);
	// 828BA0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA0AC: 4853937D  bl 0x82df3428
	ctx.lr = 0x828BA0B0;
	sub_82DF3428(ctx, base);
	// 828BA0B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA0BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA0C8 size=96
    let mut pc: u32 = 0x828BA0C8;
    'dispatch: loop {
        match pc {
            0x828BA0C8 => {
    //   block [0x828BA0C8..0x828BA128)
	// 828BA0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA0D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA0DC: 4BFFFF4D  bl 0x828ba028
	ctx.lr = 0x828BA0E0;
	sub_828BA028(ctx, base);
	// 828BA0E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA0E4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828BA0E8: 396BBFEC  addi r11, r11, -0x4014
	ctx.r[11].s64 = ctx.r[11].s64 + -16404;
	// 828BA0EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA0F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA0F4: 808A0AF0  lwz r4, 0xaf0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828BA0F8: 48539911  bl 0x82df3a08
	ctx.lr = 0x828BA0FC;
	sub_82DF3A08(ctx, base);
	// 828BA0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA100: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA104: 4859F5E5  bl 0x82e596e8
	ctx.lr = 0x828BA108;
	sub_82E596E8(ctx, base);
	// 828BA108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA10C: 4853931D  bl 0x82df3428
	ctx.lr = 0x828BA110;
	sub_82DF3428(ctx, base);
	// 828BA110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA11C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA120: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA128 size=96
    let mut pc: u32 = 0x828BA128;
    'dispatch: loop {
        match pc {
            0x828BA128 => {
    //   block [0x828BA128..0x828BA188)
	// 828BA128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA134: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA13C: 485A27ED  bl 0x82e5c928
	ctx.lr = 0x828BA140;
	sub_82E5C928(ctx, base);
	// 828BA140: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA144: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828BA148: 396BC014  addi r11, r11, -0x3fec
	ctx.r[11].s64 = ctx.r[11].s64 + -16364;
	// 828BA14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA150: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA154: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828BA158: 485398B1  bl 0x82df3a08
	ctx.lr = 0x828BA15C;
	sub_82DF3A08(ctx, base);
	// 828BA15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA160: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA164: 4859F585  bl 0x82e596e8
	ctx.lr = 0x828BA168;
	sub_82E596E8(ctx, base);
	// 828BA168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA16C: 485392BD  bl 0x82df3428
	ctx.lr = 0x828BA170;
	sub_82DF3428(ctx, base);
	// 828BA170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA174: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA178: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA17C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA180: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA188 size=120
    let mut pc: u32 = 0x828BA188;
    'dispatch: loop {
        match pc {
            0x828BA188 => {
    //   block [0x828BA188..0x828BA200)
	// 828BA188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA194: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA198: 4889A469  bl 0x83154600
	ctx.lr = 0x828BA19C;
	sub_83154600(ctx, base);
	// 828BA19C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA1A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA1A4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BA1A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA1AC: 4E800421  bctrl
	ctx.lr = 0x828BA1B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA1B0: 4BF30161  bl 0x827ea310
	ctx.lr = 0x828BA1B4;
	sub_827EA310(ctx, base);
	// 828BA1B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA1B8: 41820034  beq 0x828ba1ec
	if ctx.cr[0].eq {
	pc = 0x828BA1EC; continue 'dispatch;
	}
	// 828BA1BC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BA1C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA1C4: 808B25BC  lwz r4, 0x25bc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9660 as u32) ) } as u64;
	// 828BA1C8: 48539841  bl 0x82df3a08
	ctx.lr = 0x828BA1CC;
	sub_82DF3A08(ctx, base);
	// 828BA1CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA1D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA1D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA1D8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BA1DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA1E0: 4E800421  bctrl
	ctx.lr = 0x828BA1E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA1E8: 48539241  bl 0x82df3428
	ctx.lr = 0x828BA1EC;
	sub_82DF3428(ctx, base);
	// 828BA1EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA1F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA1F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA1F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA1FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA200 size=96
    let mut pc: u32 = 0x828BA200;
    'dispatch: loop {
        match pc {
            0x828BA200 => {
    //   block [0x828BA200..0x828BA260)
	// 828BA200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA20C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA214: 485A2715  bl 0x82e5c928
	ctx.lr = 0x828BA218;
	sub_82E5C928(ctx, base);
	// 828BA218: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA21C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828BA220: 396BC03C  addi r11, r11, -0x3fc4
	ctx.r[11].s64 = ctx.r[11].s64 + -16324;
	// 828BA224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA228: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA22C: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828BA230: 485397D9  bl 0x82df3a08
	ctx.lr = 0x828BA234;
	sub_82DF3A08(ctx, base);
	// 828BA234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA238: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA23C: 4859F4AD  bl 0x82e596e8
	ctx.lr = 0x828BA240;
	sub_82E596E8(ctx, base);
	// 828BA240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA244: 485391E5  bl 0x82df3428
	ctx.lr = 0x828BA248;
	sub_82DF3428(ctx, base);
	// 828BA248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA24C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA258: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA25C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA260 size=96
    let mut pc: u32 = 0x828BA260;
    'dispatch: loop {
        match pc {
            0x828BA260 => {
    //   block [0x828BA260..0x828BA2C0)
	// 828BA260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA26C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA274: 485A26B5  bl 0x82e5c928
	ctx.lr = 0x828BA278;
	sub_82E5C928(ctx, base);
	// 828BA278: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA27C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BA280: 396BC064  addi r11, r11, -0x3f9c
	ctx.r[11].s64 = ctx.r[11].s64 + -16284;
	// 828BA284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA288: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA28C: 808A2FF4  lwz r4, 0x2ff4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12276 as u32) ) } as u64;
	// 828BA290: 48539779  bl 0x82df3a08
	ctx.lr = 0x828BA294;
	sub_82DF3A08(ctx, base);
	// 828BA294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA298: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA29C: 4859F44D  bl 0x82e596e8
	ctx.lr = 0x828BA2A0;
	sub_82E596E8(ctx, base);
	// 828BA2A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA2A4: 48539185  bl 0x82df3428
	ctx.lr = 0x828BA2A8;
	sub_82DF3428(ctx, base);
	// 828BA2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA2AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA2B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA2B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA2B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA2C0 size=128
    let mut pc: u32 = 0x828BA2C0;
    'dispatch: loop {
        match pc {
            0x828BA2C0 => {
    //   block [0x828BA2C0..0x828BA340)
	// 828BA2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA2C4: 488EDEA9  bl 0x831a816c
	ctx.lr = 0x828BA2C8;
	sub_831A8130(ctx, base);
	// 828BA2C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA2CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BA2D0: 4889A331  bl 0x83154600
	ctx.lr = 0x828BA2D4;
	sub_83154600(ctx, base);
	// 828BA2D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA2D8: 4BFFEA11  bl 0x828b8ce8
	ctx.lr = 0x828BA2DC;
	sub_828B8CE8(ctx, base);
	// 828BA2DC: 4BFF7CF5  bl 0x828b1fd0
	ctx.lr = 0x828BA2E0;
	sub_828B1FD0(ctx, base);
	// 828BA2E0: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BA2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA2E8: 419A0050  beq cr6, 0x828ba338
	if ctx.cr[6].eq {
	pc = 0x828BA338; continue 'dispatch;
	}
	// 828BA2EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BA2F0: 4BFFE9F9  bl 0x828b8ce8
	ctx.lr = 0x828BA2F4;
	sub_828B8CE8(ctx, base);
	// 828BA2F4: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828BA2F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA2FC: 4BC551CD  bl 0x8250f4c8
	ctx.lr = 0x828BA300;
	sub_8250F4C8(ctx, base);
	// 828BA300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA308: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 828BA30C: 409A0008  bne cr6, 0x828ba314
	if !ctx.cr[6].eq {
	pc = 0x828BA314; continue 'dispatch;
	}
	// 828BA310: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BA314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BA318: 83DD0070  lwz r30, 0x70(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BA31C: 4BFFE9CD  bl 0x828b8ce8
	ctx.lr = 0x828BA320;
	sub_828B8CE8(ctx, base);
	// 828BA320: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BA324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BA328: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BA32C: 4BF31F65  bl 0x827ec290
	ctx.lr = 0x828BA330;
	sub_827EC290(ctx, base);
	// 828BA330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA334: 4853795D  bl 0x82df1c90
	ctx.lr = 0x828BA338;
	sub_82DF1C90(ctx, base);
	// 828BA338: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA33C: 488EDE80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA340 size=96
    let mut pc: u32 = 0x828BA340;
    'dispatch: loop {
        match pc {
            0x828BA340 => {
    //   block [0x828BA340..0x828BA3A0)
	// 828BA340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA34C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA354: 485A25D5  bl 0x82e5c928
	ctx.lr = 0x828BA358;
	sub_82E5C928(ctx, base);
	// 828BA358: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA35C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BA360: 396BC08C  addi r11, r11, -0x3f74
	ctx.r[11].s64 = ctx.r[11].s64 + -16244;
	// 828BA364: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA368: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA36C: 808A2FF8  lwz r4, 0x2ff8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12280 as u32) ) } as u64;
	// 828BA370: 48539699  bl 0x82df3a08
	ctx.lr = 0x828BA374;
	sub_82DF3A08(ctx, base);
	// 828BA374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA378: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA37C: 4859F36D  bl 0x82e596e8
	ctx.lr = 0x828BA380;
	sub_82E596E8(ctx, base);
	// 828BA380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA384: 485390A5  bl 0x82df3428
	ctx.lr = 0x828BA388;
	sub_82DF3428(ctx, base);
	// 828BA388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA38C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA398: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA3A0 size=92
    let mut pc: u32 = 0x828BA3A0;
    'dispatch: loop {
        match pc {
            0x828BA3A0 => {
    //   block [0x828BA3A0..0x828BA3FC)
	// 828BA3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA3A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BA3AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA3B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828BA3B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA3B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA3BC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828BA3C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BA3C4: 485A2565  bl 0x82e5c928
	ctx.lr = 0x828BA3C8;
	sub_82E5C928(ctx, base);
	// 828BA3C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA3CC: D3FF0064  stfs f31, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828BA3D0: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828BA3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA3D8: 396BC08C  addi r11, r11, -0x3f74
	ctx.r[11].s64 = ctx.r[11].s64 + -16244;
	// 828BA3DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA3E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA3E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA3E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA3EC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828BA3F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BA3F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA400 size=96
    let mut pc: u32 = 0x828BA400;
    'dispatch: loop {
        match pc {
            0x828BA400 => {
    //   block [0x828BA400..0x828BA460)
	// 828BA400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA40C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA414: 485A2515  bl 0x82e5c928
	ctx.lr = 0x828BA418;
	sub_82E5C928(ctx, base);
	// 828BA418: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA41C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BA420: 396BC0B4  addi r11, r11, -0x3f4c
	ctx.r[11].s64 = ctx.r[11].s64 + -16204;
	// 828BA424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA428: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA42C: 808A3000  lwz r4, 0x3000(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12288 as u32) ) } as u64;
	// 828BA430: 485395D9  bl 0x82df3a08
	ctx.lr = 0x828BA434;
	sub_82DF3A08(ctx, base);
	// 828BA434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA438: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA43C: 4859F2AD  bl 0x82e596e8
	ctx.lr = 0x828BA440;
	sub_82E596E8(ctx, base);
	// 828BA440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA444: 48538FE5  bl 0x82df3428
	ctx.lr = 0x828BA448;
	sub_82DF3428(ctx, base);
	// 828BA448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA44C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA45C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA460 size=108
    let mut pc: u32 = 0x828BA460;
    'dispatch: loop {
        match pc {
            0x828BA460 => {
    //   block [0x828BA460..0x828BA4CC)
	// 828BA460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA46C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA470: 4889A191  bl 0x83154600
	ctx.lr = 0x828BA474;
	sub_83154600(ctx, base);
	// 828BA474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA47C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BA480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA484: 4E800421  bctrl
	ctx.lr = 0x828BA488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA488: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BA48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA490: 808B2570  lwz r4, 0x2570(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9584 as u32) ) } as u64;
	// 828BA494: 48539575  bl 0x82df3a08
	ctx.lr = 0x828BA498;
	sub_82DF3A08(ctx, base);
	// 828BA498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA49C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA4A4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BA4A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA4AC: 4E800421  bctrl
	ctx.lr = 0x828BA4B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA4B4: 48538F75  bl 0x82df3428
	ctx.lr = 0x828BA4B8;
	sub_82DF3428(ctx, base);
	// 828BA4B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA4BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA4C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA4C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA4D0 size=200
    let mut pc: u32 = 0x828BA4D0;
    'dispatch: loop {
        match pc {
            0x828BA4D0 => {
    //   block [0x828BA4D0..0x828BA598)
	// 828BA4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA4D4: 488EDC99  bl 0x831a816c
	ctx.lr = 0x828BA4D8;
	sub_831A8130(ctx, base);
	// 828BA4D8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828BA4DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA4E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA4E4: 4889A11D  bl 0x83154600
	ctx.lr = 0x828BA4E8;
	sub_83154600(ctx, base);
	// 828BA4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA4EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA4F0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BA4F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA4F8: 4E800421  bctrl
	ctx.lr = 0x828BA4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA4FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BA500: 4BF2FE09  bl 0x827ea308
	ctx.lr = 0x828BA504;
	sub_827EA308(ctx, base);
	// 828BA504: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828BA508: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA50C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828BA510: 40990048  ble cr6, 0x828ba558
	if !ctx.cr[6].gt {
	pc = 0x828BA558; continue 'dispatch;
	}
	// 828BA514: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BA518: 4BF2FDF1  bl 0x827ea308
	ctx.lr = 0x828BA51C;
	sub_827EA308(ctx, base);
	// 828BA51C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA520: C00BB4E8  lfs f0, -0x4b18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA524: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828BA528: 40980030  bge cr6, 0x828ba558
	if !ctx.cr[6].lt {
	pc = 0x828BA558; continue 'dispatch;
	}
	// 828BA52C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BA530: 4859F239  bl 0x82e59768
	ctx.lr = 0x828BA534;
	sub_82E59768(ctx, base);
	// 828BA534: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BA538: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BA53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA540: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BA544: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA548: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BA54C: 4BFFE79D  bl 0x828b8ce8
	ctx.lr = 0x828BA550;
	sub_828B8CE8(ctx, base);
	// 828BA550: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BA554: 4BFF8DC5  bl 0x828b3318
	ctx.lr = 0x828BA558;
	sub_828B3318(ctx, base);
	// 828BA558: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BA55C: 4BF2FDB5  bl 0x827ea310
	ctx.lr = 0x828BA560;
	sub_827EA310(ctx, base);
	// 828BA560: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA564: 41820028  beq 0x828ba58c
	if ctx.cr[0].eq {
	pc = 0x828BA58C; continue 'dispatch;
	}
	// 828BA568: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BA56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA570: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BA574: 48539495  bl 0x82df3a08
	ctx.lr = 0x828BA578;
	sub_82DF3A08(ctx, base);
	// 828BA578: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA580: 4BF351C1  bl 0x827ef740
	ctx.lr = 0x828BA584;
	sub_827EF740(ctx, base);
	// 828BA584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA588: 48538EA1  bl 0x82df3428
	ctx.lr = 0x828BA58C;
	sub_82DF3428(ctx, base);
	// 828BA58C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA590: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828BA594: 488EDC28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA598 size=96
    let mut pc: u32 = 0x828BA598;
    'dispatch: loop {
        match pc {
            0x828BA598 => {
    //   block [0x828BA598..0x828BA5F8)
	// 828BA598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA5A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA5A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA5AC: 485A237D  bl 0x82e5c928
	ctx.lr = 0x828BA5B0;
	sub_82E5C928(ctx, base);
	// 828BA5B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA5B4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BA5B8: 396BC0DC  addi r11, r11, -0x3f24
	ctx.r[11].s64 = ctx.r[11].s64 + -16164;
	// 828BA5BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA5C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA5C4: 808A3004  lwz r4, 0x3004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12292 as u32) ) } as u64;
	// 828BA5C8: 48539441  bl 0x82df3a08
	ctx.lr = 0x828BA5CC;
	sub_82DF3A08(ctx, base);
	// 828BA5CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA5D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA5D4: 4859F115  bl 0x82e596e8
	ctx.lr = 0x828BA5D8;
	sub_82E596E8(ctx, base);
	// 828BA5D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA5DC: 48538E4D  bl 0x82df3428
	ctx.lr = 0x828BA5E0;
	sub_82DF3428(ctx, base);
	// 828BA5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA5E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA5F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA5F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA5F8 size=108
    let mut pc: u32 = 0x828BA5F8;
    'dispatch: loop {
        match pc {
            0x828BA5F8 => {
    //   block [0x828BA5F8..0x828BA664)
	// 828BA5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA604: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA608: 48899FF9  bl 0x83154600
	ctx.lr = 0x828BA60C;
	sub_83154600(ctx, base);
	// 828BA60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA610: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA614: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BA618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA61C: 4E800421  bctrl
	ctx.lr = 0x828BA620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA620: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BA624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA628: 808B2574  lwz r4, 0x2574(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9588 as u32) ) } as u64;
	// 828BA62C: 485393DD  bl 0x82df3a08
	ctx.lr = 0x828BA630;
	sub_82DF3A08(ctx, base);
	// 828BA630: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA634: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA63C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BA640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA644: 4E800421  bctrl
	ctx.lr = 0x828BA648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA64C: 48538DDD  bl 0x82df3428
	ctx.lr = 0x828BA650;
	sub_82DF3428(ctx, base);
	// 828BA650: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA654: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA658: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA668 size=200
    let mut pc: u32 = 0x828BA668;
    'dispatch: loop {
        match pc {
            0x828BA668 => {
    //   block [0x828BA668..0x828BA730)
	// 828BA668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA66C: 488EDB01  bl 0x831a816c
	ctx.lr = 0x828BA670;
	sub_831A8130(ctx, base);
	// 828BA670: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828BA674: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA678: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA67C: 48899F85  bl 0x83154600
	ctx.lr = 0x828BA680;
	sub_83154600(ctx, base);
	// 828BA680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA684: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA688: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BA68C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA690: 4E800421  bctrl
	ctx.lr = 0x828BA694;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA694: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BA698: 4BF2FC71  bl 0x827ea308
	ctx.lr = 0x828BA69C;
	sub_827EA308(ctx, base);
	// 828BA69C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828BA6A0: C00B8DA0  lfs f0, -0x7260(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA6A4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828BA6A8: 40990048  ble cr6, 0x828ba6f0
	if !ctx.cr[6].gt {
	pc = 0x828BA6F0; continue 'dispatch;
	}
	// 828BA6AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BA6B0: 4BF2FC59  bl 0x827ea308
	ctx.lr = 0x828BA6B4;
	sub_827EA308(ctx, base);
	// 828BA6B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA6B8: C00BC100  lfs f0, -0x3f00(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA6BC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828BA6C0: 40980030  bge cr6, 0x828ba6f0
	if !ctx.cr[6].lt {
	pc = 0x828BA6F0; continue 'dispatch;
	}
	// 828BA6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BA6C8: 4859F0A1  bl 0x82e59768
	ctx.lr = 0x828BA6CC;
	sub_82E59768(ctx, base);
	// 828BA6CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BA6D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828BA6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA6D8: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BA6DC: C00A89AC  lfs f0, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA6E0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BA6E4: 4BFFE605  bl 0x828b8ce8
	ctx.lr = 0x828BA6E8;
	sub_828B8CE8(ctx, base);
	// 828BA6E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BA6EC: 4BFF8C2D  bl 0x828b3318
	ctx.lr = 0x828BA6F0;
	sub_828B3318(ctx, base);
	// 828BA6F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BA6F4: 4BF2FC1D  bl 0x827ea310
	ctx.lr = 0x828BA6F8;
	sub_827EA310(ctx, base);
	// 828BA6F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA6FC: 41820028  beq 0x828ba724
	if ctx.cr[0].eq {
	pc = 0x828BA724; continue 'dispatch;
	}
	// 828BA700: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BA704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA708: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BA70C: 485392FD  bl 0x82df3a08
	ctx.lr = 0x828BA710;
	sub_82DF3A08(ctx, base);
	// 828BA710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA718: 4BF35029  bl 0x827ef740
	ctx.lr = 0x828BA71C;
	sub_827EF740(ctx, base);
	// 828BA71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA720: 48538D09  bl 0x82df3428
	ctx.lr = 0x828BA724;
	sub_82DF3428(ctx, base);
	// 828BA724: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA728: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828BA72C: 488EDA90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA730 size=96
    let mut pc: u32 = 0x828BA730;
    'dispatch: loop {
        match pc {
            0x828BA730 => {
    //   block [0x828BA730..0x828BA790)
	// 828BA730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA73C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA744: 485A21E5  bl 0x82e5c928
	ctx.lr = 0x828BA748;
	sub_82E5C928(ctx, base);
	// 828BA748: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA74C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BA750: 396BC108  addi r11, r11, -0x3ef8
	ctx.r[11].s64 = ctx.r[11].s64 + -16120;
	// 828BA754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA758: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA75C: 808A3008  lwz r4, 0x3008(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12296 as u32) ) } as u64;
	// 828BA760: 485392A9  bl 0x82df3a08
	ctx.lr = 0x828BA764;
	sub_82DF3A08(ctx, base);
	// 828BA764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA768: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA76C: 4859EF7D  bl 0x82e596e8
	ctx.lr = 0x828BA770;
	sub_82E596E8(ctx, base);
	// 828BA770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA774: 48538CB5  bl 0x82df3428
	ctx.lr = 0x828BA778;
	sub_82DF3428(ctx, base);
	// 828BA778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA77C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA78C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA790 size=204
    let mut pc: u32 = 0x828BA790;
    'dispatch: loop {
        match pc {
            0x828BA790 => {
    //   block [0x828BA790..0x828BA85C)
	// 828BA790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BA79C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA7A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA7A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA7A8: 48899E59  bl 0x83154600
	ctx.lr = 0x828BA7AC;
	sub_83154600(ctx, base);
	// 828BA7AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA7B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA7B4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BA7B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA7BC: 4E800421  bctrl
	ctx.lr = 0x828BA7C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA7C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA7C4: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 828BA7C8: 396BC130  addi r11, r11, -0x3ed0
	ctx.r[11].s64 = ctx.r[11].s64 + -16080;
	// 828BA7CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BA7D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BA7D4: 913F0060  stw r9, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 828BA7D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BA7DC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA860 size=52
    let mut pc: u32 = 0x828BA860;
    'dispatch: loop {
        match pc {
            0x828BA860 => {
    //   block [0x828BA860..0x828BA894)
	// 828BA860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA86C: 48899D95  bl 0x83154600
	ctx.lr = 0x828BA870;
	sub_83154600(ctx, base);
	// 828BA870: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA874: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BA878: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BA87C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BA880: 4E800421  bctrl
	ctx.lr = 0x828BA884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA884: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BA888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA88C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA898 size=96
    let mut pc: u32 = 0x828BA898;
    'dispatch: loop {
        match pc {
            0x828BA898 => {
    //   block [0x828BA898..0x828BA8F8)
	// 828BA898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA89C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA8A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA8A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA8A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA8AC: 485A207D  bl 0x82e5c928
	ctx.lr = 0x828BA8B0;
	sub_82E5C928(ctx, base);
	// 828BA8B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA8B4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BA8B8: 396BC144  addi r11, r11, -0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + -16060;
	// 828BA8BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA8C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA8C4: 808A300C  lwz r4, 0x300c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12300 as u32) ) } as u64;
	// 828BA8C8: 48539141  bl 0x82df3a08
	ctx.lr = 0x828BA8CC;
	sub_82DF3A08(ctx, base);
	// 828BA8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA8D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA8D4: 4859EE15  bl 0x82e596e8
	ctx.lr = 0x828BA8D8;
	sub_82E596E8(ctx, base);
	// 828BA8D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA8DC: 48538B4D  bl 0x82df3428
	ctx.lr = 0x828BA8E0;
	sub_82DF3428(ctx, base);
	// 828BA8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA8F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA8F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA8F8 size=56
    let mut pc: u32 = 0x828BA8F8;
    'dispatch: loop {
        match pc {
            0x828BA8F8 => {
    //   block [0x828BA8F8..0x828BA930)
	// 828BA8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA904: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA90C: 48899CF5  bl 0x83154600
	ctx.lr = 0x828BA910;
	sub_83154600(ctx, base);
	// 828BA910: 4BFFE421  bl 0x828b8d30
	ctx.lr = 0x828BA914;
	sub_828B8D30(ctx, base);
	// 828BA914: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA918: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BA91C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BA920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA92C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA930 size=120
    let mut pc: u32 = 0x828BA930;
    'dispatch: loop {
        match pc {
            0x828BA930 => {
    //   block [0x828BA930..0x828BA9A8)
	// 828BA930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA93C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA944: 4859EE25  bl 0x82e59768
	ctx.lr = 0x828BA948;
	sub_82E59768(ctx, base);
	// 828BA948: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA94C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BA950: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BA954: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BA958: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BA95C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BA960: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828BA964: 40980030  bge cr6, 0x828ba994
	if !ctx.cr[6].lt {
	pc = 0x828BA994; continue 'dispatch;
	}
	// 828BA968: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BA96C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA970: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BA974: 48539095  bl 0x82df3a08
	ctx.lr = 0x828BA978;
	sub_82DF3A08(ctx, base);
	// 828BA978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA97C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828BA980: 48899C81  bl 0x83154600
	ctx.lr = 0x828BA984;
	sub_83154600(ctx, base);
	// 828BA984: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BA988: 4BF34DB9  bl 0x827ef740
	ctx.lr = 0x828BA98C;
	sub_827EF740(ctx, base);
	// 828BA98C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA990: 48538A99  bl 0x82df3428
	ctx.lr = 0x828BA994;
	sub_82DF3428(ctx, base);
	// 828BA994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA9A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA9A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA9A8 size=96
    let mut pc: u32 = 0x828BA9A8;
    'dispatch: loop {
        match pc {
            0x828BA9A8 => {
    //   block [0x828BA9A8..0x828BAA08)
	// 828BA9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA9B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA9B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA9B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA9BC: 485A1F6D  bl 0x82e5c928
	ctx.lr = 0x828BA9C0;
	sub_82E5C928(ctx, base);
	// 828BA9C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BA9C4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828BA9C8: 396BC16C  addi r11, r11, -0x3e94
	ctx.r[11].s64 = ctx.r[11].s64 + -16020;
	// 828BA9CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA9D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BA9D4: 808A0B2C  lwz r4, 0xb2c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828BA9D8: 48539031  bl 0x82df3a08
	ctx.lr = 0x828BA9DC;
	sub_82DF3A08(ctx, base);
	// 828BA9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA9E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA9E4: 4859ED05  bl 0x82e596e8
	ctx.lr = 0x828BA9E8;
	sub_82E596E8(ctx, base);
	// 828BA9E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA9EC: 48538A3D  bl 0x82df3428
	ctx.lr = 0x828BA9F0;
	sub_82DF3428(ctx, base);
	// 828BA9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA9F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BA9F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA9FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BAA00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BAA04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BAA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BAA08 size=48
    let mut pc: u32 = 0x828BAA08;
    'dispatch: loop {
        match pc {
            0x828BAA08 => {
    //   block [0x828BAA08..0x828BAA38)
	// 828BAA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BAA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BAA10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAA14: 48899BED  bl 0x83154600
	ctx.lr = 0x828BAA18;
	sub_83154600(ctx, base);
	// 828BAA18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAA1C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BAA20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BAA24: 4E800421  bctrl
	ctx.lr = 0x828BAA28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BAA28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BAA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BAA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BAA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BAA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BAA38 size=120
    let mut pc: u32 = 0x828BAA38;
    'dispatch: loop {
        match pc {
            0x828BAA38 => {
    //   block [0x828BAA38..0x828BAAB0)
	// 828BAA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BAA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BAA40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BAA44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BAA48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAA4C: 48899BB5  bl 0x83154600
	ctx.lr = 0x828BAA50;
	sub_83154600(ctx, base);
	// 828BAA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BAA54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAA58: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BAA5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BAA60: 4E800421  bctrl
	ctx.lr = 0x828BAA64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BAA64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BAA68: 4BF2F8A9  bl 0x827ea310
	ctx.lr = 0x828BAA6C;
	sub_827EA310(ctx, base);
	// 828BAA6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAA70: 40820014  bne 0x828baa84
	if !ctx.cr[0].eq {
	pc = 0x828BAA84; continue 'dispatch;
	}
	// 828BAA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BAA78: 4BF2F8A1  bl 0x827ea318
	ctx.lr = 0x828BAA7C;
	sub_827EA318(ctx, base);
	// 828BAA7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAA80: 41820018  beq 0x828baa98
	if ctx.cr[0].eq {
	pc = 0x828BAA98; continue 'dispatch;
	}
	// 828BAA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAA88: 4BFFE261  bl 0x828b8ce8
	ctx.lr = 0x828BAA8C;
	sub_828B8CE8(ctx, base);
	// 828BAA8C: 4BFF89BD  bl 0x828b3448
	ctx.lr = 0x828BAA90;
	sub_828B3448(ctx, base);
	// 828BAA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAA94: 4BFFE2B5  bl 0x828b8d48
	ctx.lr = 0x828BAA98;
	sub_828B8D48(ctx, base);
	// 828BAA98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BAA9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BAAA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BAAA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BAAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BAAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BAAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BAAB0 size=412
    let mut pc: u32 = 0x828BAAB0;
    'dispatch: loop {
        match pc {
            0x828BAAB0 => {
    //   block [0x828BAAB0..0x828BAC4C)
	// 828BAAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BAAB4: 488ED6B1  bl 0x831a8164
	ctx.lr = 0x828BAAB8;
	sub_831A8130(ctx, base);
	// 828BAAB8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828BAABC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAAC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BAAC4: 48899B3D  bl 0x83154600
	ctx.lr = 0x828BAAC8;
	sub_83154600(ctx, base);
	// 828BAAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BAACC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAAD0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BAAD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BAAD8: 4E800421  bctrl
	ctx.lr = 0x828BAADC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BAADC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BAAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAAE4: 4BFFE24D  bl 0x828b8d30
	ctx.lr = 0x828BAAE8;
	sub_828B8D30(ctx, base);
	// 828BAAE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BAAEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BAAF0: 4859EC79  bl 0x82e59768
	ctx.lr = 0x828BAAF4;
	sub_82E59768(ctx, base);
	// 828BAAF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BAAF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAAFC: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BAB00: 4BFFE1E9  bl 0x828b8ce8
	ctx.lr = 0x828BAB04;
	sub_828B8CE8(ctx, base);
	// 828BAB04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BAB08: 4BFF8811  bl 0x828b3318
	ctx.lr = 0x828BAB0C;
	sub_828B3318(ctx, base);
	// 828BAB0C: 3FC0832C  lis r30, -0x7cd4
	ctx.r[30].s64 = -2094268416;
	// 828BAB10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAB14: 809E25BC  lwz r4, 0x25bc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9660 as u32) ) } as u64;
	// 828BAB18: 48538EF1  bl 0x82df3a08
	ctx.lr = 0x828BAB1C;
	sub_82DF3A08(ctx, base);
	// 828BAB1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BAB20: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828BAB24: 4BF2F785  bl 0x827ea2a8
	ctx.lr = 0x828BAB28;
	sub_827EA2A8(ctx, base);
	// 828BAB28: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BAB2C: 485387DD  bl 0x82df3308
	ctx.lr = 0x828BAB30;
	sub_82DF3308(ctx, base);
	// 828BAB30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BAB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAB38: 485388F1  bl 0x82df3428
	ctx.lr = 0x828BAB3C;
	sub_82DF3428(ctx, base);
	// 828BAB3C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAB40: 418200D4  beq 0x828bac14
	if ctx.cr[0].eq {
	pc = 0x828BAC14; continue 'dispatch;
	}
	// 828BAB44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BAB48: 4BF2F7C9  bl 0x827ea310
	ctx.lr = 0x828BAB4C;
	sub_827EA310(ctx, base);
	// 828BAB4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAB50: 418200F0  beq 0x828bac40
	if ctx.cr[0].eq {
	pc = 0x828BAC40; continue 'dispatch;
	}
	// 828BAB54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAB5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAB60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BAB64: 4E800421  bctrl
	ctx.lr = 0x828BAB68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BAB68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BAB6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BAB70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BAB74: 4BFF1355  bl 0x828abec8
	ctx.lr = 0x828BAB78;
	sub_828ABEC8(ctx, base);
	// 828BAB78: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BAB7C: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BAC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BAC50 size=388
    let mut pc: u32 = 0x828BAC50;
    'dispatch: loop {
        match pc {
            0x828BAC50 => {
    //   block [0x828BAC50..0x828BADD4)
	// 828BAC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BAC54: 488ED519  bl 0x831a816c
	ctx.lr = 0x828BAC58;
	sub_831A8130(ctx, base);
	// 828BAC58: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828BAC5C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAC60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BAC64: 4889999D  bl 0x83154600
	ctx.lr = 0x828BAC68;
	sub_83154600(ctx, base);
	// 828BAC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BAC6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAC70: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BAC74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BAC78: 4E800421  bctrl
	ctx.lr = 0x828BAC7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BAC7C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BAC80: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828BAC84: 419800FC  blt cr6, 0x828bad80
	if ctx.cr[6].lt {
	pc = 0x828BAD80; continue 'dispatch;
	}
	// 828BAC88: 409A0140  bne cr6, 0x828badc8
	if !ctx.cr[6].eq {
	pc = 0x828BADC8; continue 'dispatch;
	}
	// 828BAC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAC90: 4BFFE059  bl 0x828b8ce8
	ctx.lr = 0x828BAC94;
	sub_828B8CE8(ctx, base);
	// 828BAC94: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BAC98: C03E0064  lfs f1, 0x64(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BAC9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BACA0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BACA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BACA8: 4E800421  bctrl
	ctx.lr = 0x828BACAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BACAC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BACB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BACB4: 808B25F4  lwz r4, 0x25f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9716 as u32) ) } as u64;
	// 828BACB8: 48538D51  bl 0x82df3a08
	ctx.lr = 0x828BACBC;
	sub_82DF3A08(ctx, base);
	// 828BACBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BACC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BACC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BACC8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BACCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BACD0: 4E800421  bctrl
	ctx.lr = 0x828BACD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BACD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BACD8: 48538751  bl 0x82df3428
	ctx.lr = 0x828BACDC;
	sub_82DF3428(ctx, base);
	// 828BACDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BACE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BACE4: 388BC190  addi r4, r11, -0x3e70
	ctx.r[4].s64 = ctx.r[11].s64 + -15984;
	// 828BACE8: 48538D21  bl 0x82df3a08
	ctx.lr = 0x828BACEC;
	sub_82DF3A08(ctx, base);
	// 828BACEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BACF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BACF4: 388BB1DC  addi r4, r11, -0x4e24
	ctx.r[4].s64 = ctx.r[11].s64 + -20004;
	// 828BACF8: 48538D11  bl 0x82df3a08
	ctx.lr = 0x828BACFC;
	sub_82DF3A08(ctx, base);
	// 828BACFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAD00: 4BFFDFE9  bl 0x828b8ce8
	ctx.lr = 0x828BAD04;
	sub_828B8CE8(ctx, base);
	// 828BAD04: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828BAD08: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BAD0C: 4BF318BD  bl 0x827ec5c8
	ctx.lr = 0x828BAD10;
	sub_827EC5C8(ctx, base);
	// 828BAD10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BAD14: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828BAD18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BAD1C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828BAD20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAD24: 4855A30D  bl 0x82e15030
	ctx.lr = 0x828BAD28;
	sub_82E15030(ctx, base);
	// 828BAD28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BAD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAD30: 4BFFDFB9  bl 0x828b8ce8
	ctx.lr = 0x828BAD34;
	sub_828B8CE8(ctx, base);
	// 828BAD34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BAD38: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BAD3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BAD40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BAD44: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828BAD48: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BAD4C: 4BF314AD  bl 0x827ec1f8
	ctx.lr = 0x828BAD50;
	sub_827EC1F8(ctx, base);
	// 828BAD50: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BAD54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BAD58: 419A0008  beq cr6, 0x828bad60
	if ctx.cr[6].eq {
	pc = 0x828BAD60; continue 'dispatch;
	}
	// 828BAD5C: 4BA05B35  bl 0x822c0890
	ctx.lr = 0x828BAD60;
	sub_822C0890(ctx, base);
	// 828BAD60: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BAD64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BAD68: 419A0008  beq cr6, 0x828bad70
	if ctx.cr[6].eq {
	pc = 0x828BAD70; continue 'dispatch;
	}
	// 828BAD6C: 4BA05B25  bl 0x822c0890
	ctx.lr = 0x828BAD70;
	sub_822C0890(ctx, base);
	// 828BAD70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BAD74: 485386B5  bl 0x82df3428
	ctx.lr = 0x828BAD78;
	sub_82DF3428(ctx, base);
	// 828BAD78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAD7C: 48000048  b 0x828badc4
	pc = 0x828BADC4; continue 'dispatch;
	// 828BAD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAD84: C3FE0064  lfs f31, 0x64(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BAD88: 4BFFDF61  bl 0x828b8ce8
	ctx.lr = 0x828BAD8C;
	sub_828B8CE8(ctx, base);
	// 828BAD8C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BAD90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BAD94: 4804E0D5  bl 0x82908e68
	ctx.lr = 0x828BAD98;
	sub_82908E68(ctx, base);
	// 828BAD98: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BAD9C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BADA0: 808B25A4  lwz r4, 0x25a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9636 as u32) ) } as u64;
	// 828BADA4: 48538C65  bl 0x82df3a08
	ctx.lr = 0x828BADA8;
	sub_82DF3A08(ctx, base);
	// 828BADA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BADAC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828BADB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BADB4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BADB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BADBC: 4E800421  bctrl
	ctx.lr = 0x828BADC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BADC0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BADC4: 48538665  bl 0x82df3428
	ctx.lr = 0x828BADC8;
	sub_82DF3428(ctx, base);
	// 828BADC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BADCC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828BADD0: 488ED3EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BADD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BADD8 size=1292
    let mut pc: u32 = 0x828BADD8;
    'dispatch: loop {
        match pc {
            0x828BADD8 => {
    //   block [0x828BADD8..0x828BB2E4)
	// 828BADD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BADDC: 488ED389  bl 0x831a8164
	ctx.lr = 0x828BADE0;
	sub_831A8130(ctx, base);
	// 828BADE0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828BADE4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BB2E8 size=436
    let mut pc: u32 = 0x828BB2E8;
    'dispatch: loop {
        match pc {
            0x828BB2E8 => {
    //   block [0x828BB2E8..0x828BB49C)
	// 828BB2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB2EC: 488ECE81  bl 0x831a816c
	ctx.lr = 0x828BB2F0;
	sub_831A8130(ctx, base);
	// 828BB2F0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828BB2F4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB2F8: 48899309  bl 0x83154600
	ctx.lr = 0x828BB2FC;
	sub_83154600(ctx, base);
	// 828BB2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB300: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB304: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BB308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB30C: 4E800421  bctrl
	ctx.lr = 0x828BB310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB310: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB318: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB31C: 4805BA7D  bl 0x82916d98
	ctx.lr = 0x828BB320;
	sub_82916D98(ctx, base);
	// 828BB320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB324: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828BB328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB32C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB330: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB338: 4E800421  bctrl
	ctx.lr = 0x828BB33C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB33C: 394000E0  li r10, 0xe0
	ctx.r[10].s64 = 224;
	// 828BB340: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BB344: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828BB348: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BB34C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB350: 13DD50C7  vcmpequd (lvx128) v30, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BB4A0 size=580
    let mut pc: u32 = 0x828BB4A0;
    'dispatch: loop {
        match pc {
            0x828BB4A0 => {
    //   block [0x828BB4A0..0x828BB6E4)
	// 828BB4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB4A4: 488ECCC5  bl 0x831a8168
	ctx.lr = 0x828BB4A8;
	sub_831A8130(ctx, base);
	// 828BB4A8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828BB4AC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828BB4B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB4B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB4B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB4BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB4C0: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BB4C4: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828BB4C8: 915E0068  stw r10, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828BB4CC: 917E0070  stw r11, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828BB4D0: 48899131  bl 0x83154600
	ctx.lr = 0x828BB4D4;
	sub_83154600(ctx, base);
	// 828BB4D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB4D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB4DC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BB4E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB4E4: 4E800421  bctrl
	ctx.lr = 0x828BB4E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB4EC: 4BFFD845  bl 0x828b8d30
	ctx.lr = 0x828BB4F0;
	sub_828B8D30(ctx, base);
	// 828BB4F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BB4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB4F8: C01D0214  lfs f0, 0x214(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BB4FC: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828BB500: 4BFFD7E9  bl 0x828b8ce8
	ctx.lr = 0x828BB504;
	sub_828B8CE8(ctx, base);
	// 828BB504: 4BFF7C85  bl 0x828b3188
	ctx.lr = 0x828BB508;
	sub_828B3188(ctx, base);
	// 828BB508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB50C: 4BFFD7F5  bl 0x828b8d00
	ctx.lr = 0x828BB510;
	sub_828B8D00(ctx, base);
	// 828BB510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB514: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828BB518: 4BFFD871  bl 0x828b8d88
	ctx.lr = 0x828BB51C;
	sub_828B8D88(ctx, base);
	// 828BB51C: 815D020C  lwz r10, 0x20c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(524 as u32) ) } as u64;
	// 828BB520: 817D0208  lwz r11, 0x208(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(520 as u32) ) } as u64;
	// 828BB524: 7D435050  subf r10, r3, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 828BB528: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828BB52C: 41980008  blt cr6, 0x828bb534
	if ctx.cr[6].lt {
	pc = 0x828BB534; continue 'dispatch;
	}
	// 828BB530: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828BB534: 813D0204  lwz r9, 0x204(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(516 as u32) ) } as u64;
	// 828BB538: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828BB53C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BB540: 41980008  blt cr6, 0x828bb548
	if ctx.cr[6].lt {
	pc = 0x828BB548; continue 'dispatch;
	}
	// 828BB544: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828BB548: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB54C: 409A002C  bne cr6, 0x828bb578
	if !ctx.cr[6].eq {
	pc = 0x828BB578; continue 'dispatch;
	}
	// 828BB550: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BB554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB558: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BB55C: 485384AD  bl 0x82df3a08
	ctx.lr = 0x828BB560;
	sub_82DF3A08(ctx, base);
	// 828BB560: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BB564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB568: 4BF341D9  bl 0x827ef740
	ctx.lr = 0x828BB56C;
	sub_827EF740(ctx, base);
	// 828BB56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB570: 48537EB9  bl 0x82df3428
	ctx.lr = 0x828BB574;
	sub_82DF3428(ctx, base);
	// 828BB574: 48000160  b 0x828bb6d4
	pc = 0x828BB6D4; continue 'dispatch;
	// 828BB578: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828BB57C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828BB580: C3E808A8  lfs f31, 0x8a8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BB584: 419A0034  beq cr6, 0x828bb5b8
	if ctx.cr[6].eq {
	pc = 0x828BB5B8; continue 'dispatch;
	}
	// 828BB588: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BB58C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 828BB590: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828BB594: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BB598: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 828BB59C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828BB5A0: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 828BB5A4: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 828BB5A8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 828BB5AC: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 828BB5B0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BB5B4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BB5B8: 917E0068  stw r11, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828BB5BC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BB5C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB5C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB5C8: 409A0010  bne cr6, 0x828bb5d8
	if !ctx.cr[6].eq {
	pc = 0x828BB5D8; continue 'dispatch;
	}
	// 828BB5CC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BB5D0: 808B25E0  lwz r4, 0x25e0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9696 as u32) ) } as u64;
	// 828BB5D4: 4800000C  b 0x828bb5e0
	pc = 0x828BB5E0; continue 'dispatch;
	// 828BB5D8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BB5DC: 808B257C  lwz r4, 0x257c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9596 as u32) ) } as u64;
	// 828BB5E0: 48538429  bl 0x82df3a08
	ctx.lr = 0x828BB5E4;
	sub_82DF3A08(ctx, base);
	// 828BB5E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB5EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BB5F0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BB5F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB5F8: 4E800421  bctrl
	ctx.lr = 0x828BB5FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB5FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB600: 48537E29  bl 0x82df3428
	ctx.lr = 0x828BB604;
	sub_82DF3428(ctx, base);
	// 828BB604: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BB608: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB60C: 388BC1D8  addi r4, r11, -0x3e28
	ctx.r[4].s64 = ctx.r[11].s64 + -15912;
	// 828BB610: 485383F9  bl 0x82df3a08
	ctx.lr = 0x828BB614;
	sub_82DF3A08(ctx, base);
	// 828BB614: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BB618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB61C: 388B1EDC  addi r4, r11, 0x1edc
	ctx.r[4].s64 = ctx.r[11].s64 + 7900;
	// 828BB620: 485383E9  bl 0x82df3a08
	ctx.lr = 0x828BB624;
	sub_82DF3A08(ctx, base);
	// 828BB624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB628: 4BFFD6C1  bl 0x828b8ce8
	ctx.lr = 0x828BB62C;
	sub_828B8CE8(ctx, base);
	// 828BB62C: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828BB630: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BB634: 4BF30F95  bl 0x827ec5c8
	ctx.lr = 0x828BB638;
	sub_827EC5C8(ctx, base);
	// 828BB638: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BB63C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BB640: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BB644: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 828BB648: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB64C: 485599E5  bl 0x82e15030
	ctx.lr = 0x828BB650;
	sub_82E15030(ctx, base);
	// 828BB650: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BB654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB658: 4BFFD691  bl 0x828b8ce8
	ctx.lr = 0x828BB65C;
	sub_828B8CE8(ctx, base);
	// 828BB65C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BB660: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BB664: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BB668: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BB66C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828BB670: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BB674: 4BF30B95  bl 0x827ec208
	ctx.lr = 0x828BB678;
	sub_827EC208(ctx, base);
	// 828BB678: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BB67C: 907E0070  stw r3, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 828BB680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB684: 419A000C  beq cr6, 0x828bb690
	if ctx.cr[6].eq {
	pc = 0x828BB690; continue 'dispatch;
	}
	// 828BB688: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BB68C: 4BA05205  bl 0x822c0890
	ctx.lr = 0x828BB690;
	sub_822C0890(ctx, base);
	// 828BB690: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BB694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB698: 419A0008  beq cr6, 0x828bb6a0
	if ctx.cr[6].eq {
	pc = 0x828BB6A0; continue 'dispatch;
	}
	// 828BB69C: 4BA051F5  bl 0x822c0890
	ctx.lr = 0x828BB6A0;
	sub_822C0890(ctx, base);
	// 828BB6A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB6A4: 48537D85  bl 0x82df3428
	ctx.lr = 0x828BB6A8;
	sub_82DF3428(ctx, base);
	// 828BB6A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB6AC: 48537D7D  bl 0x82df3428
	ctx.lr = 0x828BB6B0;
	sub_82DF3428(ctx, base);
	// 828BB6B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BB6B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB6B8: 38ABC1C0  addi r5, r11, -0x3e40
	ctx.r[5].s64 = ctx.r[11].s64 + -15936;
	// 828BB6BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BB6C0: 4BF34609  bl 0x827efcc8
	ctx.lr = 0x828BB6C4;
	sub_827EFCC8(ctx, base);
	// 828BB6C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828BB6C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB6CC: 419A0008  beq cr6, 0x828bb6d4
	if ctx.cr[6].eq {
	pc = 0x828BB6D4; continue 'dispatch;
	}
	// 828BB6D0: 4BA051C1  bl 0x822c0890
	ctx.lr = 0x828BB6D4;
	sub_822C0890(ctx, base);
	// 828BB6D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BB6D8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828BB6DC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828BB6E0: 488ECAD8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BB6E8 size=908
    let mut pc: u32 = 0x828BB6E8;
    'dispatch: loop {
        match pc {
            0x828BB6E8 => {
    //   block [0x828BB6E8..0x828BBA74)
	// 828BB6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB6EC: 488ECA7D  bl 0x831a8168
	ctx.lr = 0x828BB6F0;
	sub_831A8130(ctx, base);
	// 828BB6F0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828BB6F4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828BB6F8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BBA78 size=332
    let mut pc: u32 = 0x828BBA78;
    'dispatch: loop {
        match pc {
            0x828BBA78 => {
    //   block [0x828BBA78..0x828BBBC4)
	// 828BBA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBA7C: 488EC6ED  bl 0x831a8168
	ctx.lr = 0x828BBA80;
	sub_831A8130(ctx, base);
	// 828BBA80: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828BBA84: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBA88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BBA8C: 48898B75  bl 0x83154600
	ctx.lr = 0x828BBA90;
	sub_83154600(ctx, base);
	// 828BBA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBA94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBA98: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BBA9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBAA0: 4E800421  bctrl
	ctx.lr = 0x828BBAA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBAA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBAA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBAAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBAB0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BBAB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBAB8: 4E800421  bctrl
	ctx.lr = 0x828BBABC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBABC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BBAC0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BBAC4: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828BBAC8: 419900B4  bgt cr6, 0x828bbb7c
	if ctx.cr[6].gt {
	pc = 0x828BBB7C; continue 'dispatch;
	}
	// 828BBACC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBAD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BBAD4: 388B25A0  addi r4, r11, 0x25a0
	ctx.r[4].s64 = ctx.r[11].s64 + 9632;
	// 828BBAD8: 4BFA75C9  bl 0x828630a0
	ctx.lr = 0x828BBADC;
	sub_828630A0(ctx, base);
	// 828BBADC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBAE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BBAE4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBAEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BBAF0: 419A0024  beq cr6, 0x828bbb14
	if ctx.cr[6].eq {
	pc = 0x828BBB14; continue 'dispatch;
	}
	// 828BBAF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BBAF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BBAFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BBB00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BBB04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BBB08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BBB0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BBB10: 4082FFE8  bne 0x828bbaf8
	if !ctx.cr[0].eq {
	pc = 0x828BBAF8; continue 'dispatch;
	}
	// 828BBB14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBB18: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828BBB1C: 4BF31D05  bl 0x827ed820
	ctx.lr = 0x828BBB20;
	sub_827ED820(ctx, base);
	// 828BBB20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BBB24: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828BBB28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BBB2C: 388BC200  addi r4, r11, -0x3e00
	ctx.r[4].s64 = ctx.r[11].s64 + -15872;
	// 828BBB30: 38A000A8  li r5, 0xa8
	ctx.r[5].s64 = 168;
	// 828BBB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBB38: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828BBB3C: 4BF3401D  bl 0x827efb58
	ctx.lr = 0x828BBB40;
	sub_827EFB58(ctx, base);
	// 828BBB40: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BBB44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BBB48: 419A0008  beq cr6, 0x828bbb50
	if ctx.cr[6].eq {
	pc = 0x828BBB50; continue 'dispatch;
	}
	// 828BBB4C: 4BA04D45  bl 0x822c0890
	ctx.lr = 0x828BBB50;
	sub_822C0890(ctx, base);
	// 828BBB50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BBB54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBB58: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828BBB5C: 48537EAD  bl 0x82df3a08
	ctx.lr = 0x828BBB60;
	sub_82DF3A08(ctx, base);
	// 828BBB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBB64: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828BBB68: 48898A99  bl 0x83154600
	ctx.lr = 0x828BBB6C;
	sub_83154600(ctx, base);
	// 828BBB6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BBB70: 4BF33BD1  bl 0x827ef740
	ctx.lr = 0x828BBB74;
	sub_827EF740(ctx, base);
	// 828BBB74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBB78: 485378B1  bl 0x82df3428
	ctx.lr = 0x828BBB7C;
	sub_82DF3428(ctx, base);
	// 828BBB7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BBB80: 4BF2E791  bl 0x827ea310
	ctx.lr = 0x828BBB84;
	sub_827EA310(ctx, base);
	// 828BBB84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBB88: 41820030  beq 0x828bbbb8
	if ctx.cr[0].eq {
	pc = 0x828BBBB8; continue 'dispatch;
	}
	// 828BBB8C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BBB90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBB94: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BBB98: 48537E71  bl 0x82df3a08
	ctx.lr = 0x828BBB9C;
	sub_82DF3A08(ctx, base);
	// 828BBB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBBA0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828BBBA4: 48898A5D  bl 0x83154600
	ctx.lr = 0x828BBBA8;
	sub_83154600(ctx, base);
	// 828BBBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BBBAC: 4BF33B95  bl 0x827ef740
	ctx.lr = 0x828BBBB0;
	sub_827EF740(ctx, base);
	// 828BBBB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBBB4: 48537875  bl 0x82df3428
	ctx.lr = 0x828BBBB8;
	sub_82DF3428(ctx, base);
	// 828BBBB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BBBBC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828BBBC0: 488EC5F8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BBBC8 size=716
    let mut pc: u32 = 0x828BBBC8;
    'dispatch: loop {
        match pc {
            0x828BBBC8 => {
    //   block [0x828BBBC8..0x828BBE94)
	// 828BBBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBBCC: 488EC599  bl 0x831a8164
	ctx.lr = 0x828BBBD0;
	sub_831A8130(ctx, base);
	// 828BBBD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBBD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BBBD8: 48898A29  bl 0x83154600
	ctx.lr = 0x828BBBDC;
	sub_83154600(ctx, base);
	// 828BBBDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBBE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBBE4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BBBE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBBEC: 4E800421  bctrl
	ctx.lr = 0x828BBBF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBBF0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BBBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBBF8: 4BFFD139  bl 0x828b8d30
	ctx.lr = 0x828BBBFC;
	sub_828B8D30(ctx, base);
	// 828BBBFC: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BBC00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBC04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBC08: 409A004C  bne cr6, 0x828bbc54
	if !ctx.cr[6].eq {
	pc = 0x828BBC54; continue 'dispatch;
	}
	// 828BBC0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBC10: 4BF2E701  bl 0x827ea310
	ctx.lr = 0x828BBC14;
	sub_827EA310(ctx, base);
	// 828BBC14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBC18: 41820274  beq 0x828bbe8c
	if ctx.cr[0].eq {
	pc = 0x828BBE8C; continue 'dispatch;
	}
	// 828BBC1C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBC20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBC24: 808B2580  lwz r4, 0x2580(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9600 as u32) ) } as u64;
	// 828BBC28: 48537DE1  bl 0x82df3a08
	ctx.lr = 0x828BBC2C;
	sub_82DF3A08(ctx, base);
	// 828BBC2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBC30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BBC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBC38: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BBC3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBC40: 4E800421  bctrl
	ctx.lr = 0x828BBC44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBC48: 485377E1  bl 0x82df3428
	ctx.lr = 0x828BBC4C;
	sub_82DF3428(ctx, base);
	// 828BBC4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BBC50: 480001F8  b 0x828bbe48
	pc = 0x828BBE48; continue 'dispatch;
	// 828BBC54: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BBC58: 409A0060  bne cr6, 0x828bbcb8
	if !ctx.cr[6].eq {
	pc = 0x828BBCB8; continue 'dispatch;
	}
	// 828BBC5C: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BBC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBC64: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BBC68: 409A0010  bne cr6, 0x828bbc78
	if !ctx.cr[6].eq {
	pc = 0x828BBC78; continue 'dispatch;
	}
	// 828BBC6C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBC70: 808B2578  lwz r4, 0x2578(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9592 as u32) ) } as u64;
	// 828BBC74: 4800000C  b 0x828bbc80
	pc = 0x828BBC80; continue 'dispatch;
	// 828BBC78: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBC7C: 808B2580  lwz r4, 0x2580(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9600 as u32) ) } as u64;
	// 828BBC80: 48537D89  bl 0x82df3a08
	ctx.lr = 0x828BBC84;
	sub_82DF3A08(ctx, base);
	// 828BBC84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBC88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBC8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BBC90: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BBC94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBC98: 4E800421  bctrl
	ctx.lr = 0x828BBC9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBC9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBCA0: 48537789  bl 0x82df3428
	ctx.lr = 0x828BBCA4;
	sub_82DF3428(ctx, base);
	// 828BBCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBCA8: 4BFFD041  bl 0x828b8ce8
	ctx.lr = 0x828BBCAC;
	sub_828B8CE8(ctx, base);
	// 828BBCAC: 4BFF6325  bl 0x828b1fd0
	ctx.lr = 0x828BBCB0;
	sub_828B1FD0(ctx, base);
	// 828BBCB0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828BBCB4: 48000194  b 0x828bbe48
	pc = 0x828BBE48; continue 'dispatch;
	// 828BBCB8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828BBCBC: 409A0064  bne cr6, 0x828bbd20
	if !ctx.cr[6].eq {
	pc = 0x828BBD20; continue 'dispatch;
	}
	// 828BBCC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BBCC4: C1BE006C  lfs f13, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BBCC8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BBCCC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828BBCD0: 40980020  bge cr6, 0x828bbcf0
	if !ctx.cr[6].lt {
	pc = 0x828BBCF0; continue 'dispatch;
	}
	// 828BBCD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBCD8: 4BFFFA11  bl 0x828bb6e8
	ctx.lr = 0x828BBCDC;
	sub_828BB6E8(ctx, base);
	// 828BBCDC: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BBCE0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BBCE4: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828BBCE8: C01D0214  lfs f0, 0x214(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BBCEC: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828BBCF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBCF4: 4859DA75  bl 0x82e59768
	ctx.lr = 0x828BBCF8;
	sub_82E59768(ctx, base);
	// 828BBCF8: C01E006C  lfs f0, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BBCFC: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BBD00: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BBD04: 815E0068  lwz r10, 0x68(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BBD08: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BBD0C: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828BBD10: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828BBD14: 41980178  blt cr6, 0x828bbe8c
	if ctx.cr[6].lt {
	pc = 0x828BBE8C; continue 'dispatch;
	}
	// 828BBD18: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828BBD1C: 4800012C  b 0x828bbe48
	pc = 0x828BBE48; continue 'dispatch;
	// 828BBD20: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828BBD24: 409A012C  bne cr6, 0x828bbe50
	if !ctx.cr[6].eq {
	pc = 0x828BBE50; continue 'dispatch;
	}
	// 828BBD28: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BBD2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBD30: 419A0058  beq cr6, 0x828bbd88
	if ctx.cr[6].eq {
	pc = 0x828BBD88; continue 'dispatch;
	}
	// 828BBD34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBD38: 4BFFCFB1  bl 0x828b8ce8
	ctx.lr = 0x828BBD3C;
	sub_828B8CE8(ctx, base);
	// 828BBD3C: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828BBD40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BBD44: 4BC53785  bl 0x8250f4c8
	ctx.lr = 0x828BBD48;
	sub_8250F4C8(ctx, base);
	// 828BBD48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBD4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBD50: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 828BBD54: 409A0008  bne cr6, 0x828bbd5c
	if !ctx.cr[6].eq {
	pc = 0x828BBD5C; continue 'dispatch;
	}
	// 828BBD58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BBD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBD60: 837E0070  lwz r27, 0x70(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BBD64: 4BFFCF85  bl 0x828b8ce8
	ctx.lr = 0x828BBD68;
	sub_828B8CE8(ctx, base);
	// 828BBD68: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BBD6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBD70: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828BBD74: 4BF3051D  bl 0x827ec290
	ctx.lr = 0x828BBD78;
	sub_827EC290(ctx, base);
	// 828BBD78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BBD7C: 48535F15  bl 0x82df1c90
	ctx.lr = 0x828BBD80;
	sub_82DF1C90(ctx, base);
	// 828BBD80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BBD84: 917E0070  stw r11, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828BBD88: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBD8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBD90: 808B2578  lwz r4, 0x2578(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9592 as u32) ) } as u64;
	// 828BBD94: 48537C75  bl 0x82df3a08
	ctx.lr = 0x828BBD98;
	sub_82DF3A08(ctx, base);
	// 828BBD98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBD9C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828BBDA0: 4BF2E509  bl 0x827ea2a8
	ctx.lr = 0x828BBDA4;
	sub_827EA2A8(ctx, base);
	// 828BBDA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBDA8: 48537561  bl 0x82df3308
	ctx.lr = 0x828BBDAC;
	sub_82DF3308(ctx, base);
	// 828BBDAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBDB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBDB4: 48537675  bl 0x82df3428
	ctx.lr = 0x828BBDB8;
	sub_82DF3428(ctx, base);
	// 828BBDB8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBDBC: 41820020  beq 0x828bbddc
	if ctx.cr[0].eq {
	pc = 0x828BBDDC; continue 'dispatch;
	}
	// 828BBDC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBDC4: 4BF2E54D  bl 0x827ea310
	ctx.lr = 0x828BBDC8;
	sub_827EA310(ctx, base);
	// 828BBDC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBDCC: 418200C0  beq 0x828bbe8c
	if ctx.cr[0].eq {
	pc = 0x828BBE8C; continue 'dispatch;
	}
	// 828BBDD0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBDD4: 808B2588  lwz r4, 0x2588(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9608 as u32) ) } as u64;
	// 828BBDD8: 48000044  b 0x828bbe1c
	pc = 0x828BBE1C; continue 'dispatch;
	// 828BBDDC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBDE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBDE4: 808B2580  lwz r4, 0x2580(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9600 as u32) ) } as u64;
	// 828BBDE8: 48537C21  bl 0x82df3a08
	ctx.lr = 0x828BBDEC;
	sub_82DF3A08(ctx, base);
	// 828BBDEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBDF0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828BBDF4: 4BF2E4B5  bl 0x827ea2a8
	ctx.lr = 0x828BBDF8;
	sub_827EA2A8(ctx, base);
	// 828BBDF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBDFC: 4853750D  bl 0x82df3308
	ctx.lr = 0x828BBE00;
	sub_82DF3308(ctx, base);
	// 828BBE00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBE08: 48537621  bl 0x82df3428
	ctx.lr = 0x828BBE0C;
	sub_82DF3428(ctx, base);
	// 828BBE0C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBE10: 4182007C  beq 0x828bbe8c
	if ctx.cr[0].eq {
	pc = 0x828BBE8C; continue 'dispatch;
	}
	// 828BBE14: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BBE18: 808B2584  lwz r4, 0x2584(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9604 as u32) ) } as u64;
	// 828BBE1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBE20: 48537BE9  bl 0x82df3a08
	ctx.lr = 0x828BBE24;
	sub_82DF3A08(ctx, base);
	// 828BBE24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBE28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BBE2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBE30: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BBE34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBE38: 4E800421  bctrl
	ctx.lr = 0x828BBE3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBE40: 485375E9  bl 0x82df3428
	ctx.lr = 0x828BBE44;
	sub_82DF3428(ctx, base);
	// 828BBE44: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828BBE48: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BBE4C: 48000040  b 0x828bbe8c
	pc = 0x828BBE8C; continue 'dispatch;
	// 828BBE50: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBE54: 409A0038  bne cr6, 0x828bbe8c
	if !ctx.cr[6].eq {
	pc = 0x828BBE8C; continue 'dispatch;
	}
	// 828BBE58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBE5C: 4BF2E4B5  bl 0x827ea310
	ctx.lr = 0x828BBE60;
	sub_827EA310(ctx, base);
	// 828BBE60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBE64: 41820028  beq 0x828bbe8c
	if ctx.cr[0].eq {
	pc = 0x828BBE8C; continue 'dispatch;
	}
	// 828BBE68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BBE6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBE70: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BBE74: 48537B95  bl 0x82df3a08
	ctx.lr = 0x828BBE78;
	sub_82DF3A08(ctx, base);
	// 828BBE78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BBE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBE80: 4BF338C1  bl 0x827ef740
	ctx.lr = 0x828BBE84;
	sub_827EF740(ctx, base);
	// 828BBE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBE88: 485375A1  bl 0x82df3428
	ctx.lr = 0x828BBE8C;
	sub_82DF3428(ctx, base);
	// 828BBE8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BBE90: 488EC324  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BBE98 size=96
    let mut pc: u32 = 0x828BBE98;
    'dispatch: loop {
        match pc {
            0x828BBE98 => {
    //   block [0x828BBE98..0x828BBEF8)
	// 828BBE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BBEA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BBEA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBEA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBEAC: 485A0A7D  bl 0x82e5c928
	ctx.lr = 0x828BBEB0;
	sub_82E5C928(ctx, base);
	// 828BBEB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BBEB4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BBEB8: 396BC280  addi r11, r11, -0x3d80
	ctx.r[11].s64 = ctx.r[11].s64 + -15744;
	// 828BBEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBEC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BBEC4: 808A2FEC  lwz r4, 0x2fec(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12268 as u32) ) } as u64;
	// 828BBEC8: 48537B41  bl 0x82df3a08
	ctx.lr = 0x828BBECC;
	sub_82DF3A08(ctx, base);
	// 828BBECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBED0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BBED4: 4859D815  bl 0x82e596e8
	ctx.lr = 0x828BBED8;
	sub_82E596E8(ctx, base);
	// 828BBED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBEDC: 4853754D  bl 0x82df3428
	ctx.lr = 0x828BBEE0;
	sub_82DF3428(ctx, base);
	// 828BBEE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBEE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BBEE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BBEEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BBEF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BBEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BBEF8 size=96
    let mut pc: u32 = 0x828BBEF8;
    'dispatch: loop {
        match pc {
            0x828BBEF8 => {
    //   block [0x828BBEF8..0x828BBF58)
	// 828BBEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BBF00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BBF04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBF08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBF0C: 485A0A1D  bl 0x82e5c928
	ctx.lr = 0x828BBF10;
	sub_82E5C928(ctx, base);
	// 828BBF10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BBF14: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BBF18: 396BC2A8  addi r11, r11, -0x3d58
	ctx.r[11].s64 = ctx.r[11].s64 + -15704;
	// 828BBF1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBF20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BBF24: 808A2FF0  lwz r4, 0x2ff0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12272 as u32) ) } as u64;
	// 828BBF28: 48537AE1  bl 0x82df3a08
	ctx.lr = 0x828BBF2C;
	sub_82DF3A08(ctx, base);
	// 828BBF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBF30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BBF34: 4859D7B5  bl 0x82e596e8
	ctx.lr = 0x828BBF38;
	sub_82E596E8(ctx, base);
	// 828BBF38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BBF3C: 485374ED  bl 0x82df3428
	ctx.lr = 0x828BBF40;
	sub_82DF3428(ctx, base);
	// 828BBF40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBF44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BBF48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BBF4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BBF50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BBF54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BBF58 size=360
    let mut pc: u32 = 0x828BBF58;
    'dispatch: loop {
        match pc {
            0x828BBF58 => {
    //   block [0x828BBF58..0x828BC0C0)
	// 828BBF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBF5C: 488EC20D  bl 0x831a8168
	ctx.lr = 0x828BBF60;
	sub_831A8130(ctx, base);
	// 828BBF60: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 828BBF64: 488ECB15  bl 0x831a8a78
	ctx.lr = 0x828BBF68;
	sub_831A8A40(ctx, base);
	// 828BBF68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBF6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBF70: 48898691  bl 0x83154600
	ctx.lr = 0x828BBF74;
	sub_83154600(ctx, base);
	// 828BBF74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BBF78: 4BFFCD71  bl 0x828b8ce8
	ctx.lr = 0x828BBF7C;
	sub_828B8CE8(ctx, base);
	// 828BBF7C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBF80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BBF84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBF88: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BBF8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BBF90: 4E800421  bctrl
	ctx.lr = 0x828BBF94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBF94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBF98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBF9C: 4BFFCD95  bl 0x828b8d30
	ctx.lr = 0x828BBFA0;
	sub_828B8D30(ctx, base);
	// 828BBFA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BBFA4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BBFA8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BBFAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBFB0: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BBFB4: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BBFB8: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BBFBC: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BBFC0: C3AB0008  lfs f29, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828BBFC4: C38B0000  lfs f28, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828BBFC8: 4804D5B9  bl 0x82909580
	ctx.lr = 0x828BBFCC;
	sub_82909580(ctx, base);
	// 828BBFCC: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828BBFD0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828BBFD4: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828BBFD8: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 828BBFDC: 4805FDFD  bl 0x8291bdd8
	ctx.lr = 0x828BBFE0;
	sub_8291BDD8(ctx, base);
	// 828BBFE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBFE4: 4182000C  beq 0x828bbff0
	if ctx.cr[0].eq {
	pc = 0x828BBFF0; continue 'dispatch;
	}
	// 828BBFE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BBFEC: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 828BBFF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BBFF4: 4BF2E31D  bl 0x827ea310
	ctx.lr = 0x828BBFF8;
	sub_827EA310(ctx, base);
	// 828BBFF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BBFFC: 418200B4  beq 0x828bc0b0
	if ctx.cr[0].eq {
	pc = 0x828BC0B0; continue 'dispatch;
	}
	// 828BC000: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BC004: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BC008: 4182005C  beq 0x828bc064
	if ctx.cr[0].eq {
	pc = 0x828BC064; continue 'dispatch;
	}
	// 828BC00C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC010: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828BC014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC018: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BC01C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BC020: 48052D59  bl 0x8290ed78
	ctx.lr = 0x828BC024;
	sub_8290ED78(ctx, base);
	// 828BC024: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BC028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC02C: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828BC030: 485379D9  bl 0x82df3a08
	ctx.lr = 0x828BC034;
	sub_82DF3A08(ctx, base);
	// 828BC034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC03C: 4874C0ED  bl 0x83008128
	ctx.lr = 0x828BC040;
	sub_83008128(ctx, base);
	// 828BC040: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BC044: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BC048: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BC04C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC050: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC054: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BC058: 485A2909  bl 0x82e5e960
	ctx.lr = 0x828BC05C;
	sub_82E5E960(ctx, base);
	// 828BC05C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC060: 48000044  b 0x828bc0a4
	pc = 0x828BC0A4; continue 'dispatch;
	// 828BC064: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BC068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC06C: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828BC070: 48537999  bl 0x82df3a08
	ctx.lr = 0x828BC074;
	sub_82DF3A08(ctx, base);
	// 828BC074: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC07C: 4874C0AD  bl 0x83008128
	ctx.lr = 0x828BC080;
	sub_83008128(ctx, base);
	// 828BC080: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC084: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BC088: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC08C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC090: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC094: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BC098: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BC09C: 485A28C5  bl 0x82e5e960
	ctx.lr = 0x828BC0A0;
	sub_82E5E960(ctx, base);
	// 828BC0A0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BC0A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC0A8: 419A0008  beq cr6, 0x828bc0b0
	if ctx.cr[6].eq {
	pc = 0x828BC0B0; continue 'dispatch;
	}
	// 828BC0AC: 4BA047E5  bl 0x822c0890
	ctx.lr = 0x828BC0B0;
	sub_822C0890(ctx, base);
	// 828BC0B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BC0B4: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 828BC0B8: 488ECA0D  bl 0x831a8ac4
	ctx.lr = 0x828BC0BC;
	sub_831A8A8C(ctx, base);
	// 828BC0BC: 488EC0FC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BC0C0 size=172
    let mut pc: u32 = 0x828BC0C0;
    'dispatch: loop {
        match pc {
            0x828BC0C0 => {
    //   block [0x828BC0C0..0x828BC16C)
	// 828BC0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC0C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BC0CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BC0D0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828BC0D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC0DC: 48898525  bl 0x83154600
	ctx.lr = 0x828BC0E0;
	sub_83154600(ctx, base);
	// 828BC0E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC0E4: 4859D685  bl 0x82e59768
	ctx.lr = 0x828BC0E8;
	sub_82E59768(ctx, base);
	// 828BC0E8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BC0EC: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BC0F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC0F4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BC0F8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BC0FC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BC100: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828BC104: 4098004C  bge cr6, 0x828bc150
	if !ctx.cr[6].lt {
	pc = 0x828BC150; continue 'dispatch;
	}
	// 828BC108: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BC10C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC110: 808B2FF0  lwz r4, 0x2ff0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12272 as u32) ) } as u64;
	// 828BC114: 485378F5  bl 0x82df3a08
	ctx.lr = 0x828BC118;
	sub_82DF3A08(ctx, base);
	// 828BC118: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC11C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC120: 4874C009  bl 0x83008128
	ctx.lr = 0x828BC124;
	sub_83008128(ctx, base);
	// 828BC124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BC128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BC12C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BC130: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC134: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC138: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BC13C: 485A2825  bl 0x82e5e960
	ctx.lr = 0x828BC140;
	sub_82E5E960(ctx, base);
	// 828BC140: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC144: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC148: 419A0008  beq cr6, 0x828bc150
	if ctx.cr[6].eq {
	pc = 0x828BC150; continue 'dispatch;
	}
	// 828BC14C: 4BA04745  bl 0x822c0890
	ctx.lr = 0x828BC150;
	sub_822C0890(ctx, base);
	// 828BC150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BC158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BC15C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828BC160: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BC164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BC168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BC170 size=256
    let mut pc: u32 = 0x828BC170;
    'dispatch: loop {
        match pc {
            0x828BC170 => {
    //   block [0x828BC170..0x828BC270)
	// 828BC170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC174: 488EBFF5  bl 0x831a8168
	ctx.lr = 0x828BC178;
	sub_831A8130(ctx, base);
	// 828BC178: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC17C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BC180: 48898481  bl 0x83154600
	ctx.lr = 0x828BC184;
	sub_83154600(ctx, base);
	// 828BC184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC188: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC18C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BC190: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC194: 4E800421  bctrl
	ctx.lr = 0x828BC198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC198: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BC19C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC1A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC1A4: 3BCB25FC  addi r30, r11, 0x25fc
	ctx.r[30].s64 = ctx.r[11].s64 + 9724;
	// 828BC1A8: 808B25FC  lwz r4, 0x25fc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9724 as u32) ) } as u64;
	// 828BC1AC: 4853785D  bl 0x82df3a08
	ctx.lr = 0x828BC1B0;
	sub_82DF3A08(ctx, base);
	// 828BC1B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC1B4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828BC1B8: 4BF2E0F1  bl 0x827ea2a8
	ctx.lr = 0x828BC1BC;
	sub_827EA2A8(ctx, base);
	// 828BC1BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BC1C0: 485370E1  bl 0x82df32a0
	ctx.lr = 0x828BC1C4;
	sub_82DF32A0(ctx, base);
	// 828BC1C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC1C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC1CC: 4853725D  bl 0x82df3428
	ctx.lr = 0x828BC1D0;
	sub_82DF3428(ctx, base);
	// 828BC1D0: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC1D4: 41820088  beq 0x828bc25c
	if ctx.cr[0].eq {
	pc = 0x828BC25C; continue 'dispatch;
	}
	// 828BC1D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC1DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BC1E0: 4BFA6EC1  bl 0x828630a0
	ctx.lr = 0x828BC1E4;
	sub_828630A0(ctx, base);
	// 828BC1E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC1E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BC1EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC1F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BC1F8: 419A0024  beq cr6, 0x828bc21c
	if ctx.cr[6].eq {
	pc = 0x828BC21C; continue 'dispatch;
	}
	// 828BC1FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BC200: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BC204: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC208: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BC20C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BC210: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BC214: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC218: 4082FFE8  bne 0x828bc200
	if !ctx.cr[0].eq {
	pc = 0x828BC200; continue 'dispatch;
	}
	// 828BC21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC220: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828BC224: 4BF315FD  bl 0x827ed820
	ctx.lr = 0x828BC228;
	sub_827ED820(ctx, base);
	// 828BC228: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC22C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BC230: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828BC234: 388AC2D0  addi r4, r10, -0x3d30
	ctx.r[4].s64 = ctx.r[10].s64 + -15664;
	// 828BC238: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 828BC23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC240: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BC244: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828BC248: 4BF33911  bl 0x827efb58
	ctx.lr = 0x828BC24C;
	sub_827EFB58(ctx, base);
	// 828BC24C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC254: 419A0008  beq cr6, 0x828bc25c
	if ctx.cr[6].eq {
	pc = 0x828BC25C; continue 'dispatch;
	}
	// 828BC258: 4BA04639  bl 0x822c0890
	ctx.lr = 0x828BC25C;
	sub_822C0890(ctx, base);
	// 828BC25C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC260: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BC264: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BC268: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BC26C: 488EBF4C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BC270 size=248
    let mut pc: u32 = 0x828BC270;
    'dispatch: loop {
        match pc {
            0x828BC270 => {
    //   block [0x828BC270..0x828BC368)
	// 828BC270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC274: 488EBEF9  bl 0x831a816c
	ctx.lr = 0x828BC278;
	sub_831A8130(ctx, base);
	// 828BC278: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC27C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BC280: 99630060  stb r11, 0x60(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 828BC284: 4889837D  bl 0x83154600
	ctx.lr = 0x828BC288;
	sub_83154600(ctx, base);
	// 828BC288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC28C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC290: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BC294: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC298: 4E800421  bctrl
	ctx.lr = 0x828BC29C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC29C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BC2A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BC2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC2A8: 3BCB25EC  addi r30, r11, 0x25ec
	ctx.r[30].s64 = ctx.r[11].s64 + 9708;
	// 828BC2AC: 808B25EC  lwz r4, 0x25ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9708 as u32) ) } as u64;
	// 828BC2B0: 48537759  bl 0x82df3a08
	ctx.lr = 0x828BC2B4;
	sub_82DF3A08(ctx, base);
	// 828BC2B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BC2B8: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828BC2BC: 4BF2DFED  bl 0x827ea2a8
	ctx.lr = 0x828BC2C0;
	sub_827EA2A8(ctx, base);
	// 828BC2C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC2C4: 48536FDD  bl 0x82df32a0
	ctx.lr = 0x828BC2C8;
	sub_82DF32A0(ctx, base);
	// 828BC2C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BC2CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC2D0: 48537159  bl 0x82df3428
	ctx.lr = 0x828BC2D4;
	sub_82DF3428(ctx, base);
	// 828BC2D4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC2D8: 41820088  beq 0x828bc360
	if ctx.cr[0].eq {
	pc = 0x828BC360; continue 'dispatch;
	}
	// 828BC2DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC2E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BC2E4: 4BFA6DBD  bl 0x828630a0
	ctx.lr = 0x828BC2E8;
	sub_828630A0(ctx, base);
	// 828BC2E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC2EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BC2F0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC2F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC2F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BC2FC: 419A0024  beq cr6, 0x828bc320
	if ctx.cr[6].eq {
	pc = 0x828BC320; continue 'dispatch;
	}
	// 828BC300: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BC304: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BC308: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC30C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BC310: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BC314: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BC318: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC31C: 4082FFE8  bne 0x828bc304
	if !ctx.cr[0].eq {
	pc = 0x828BC304; continue 'dispatch;
	}
	// 828BC320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC324: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828BC328: 4BF314F9  bl 0x827ed820
	ctx.lr = 0x828BC32C;
	sub_827ED820(ctx, base);
	// 828BC32C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC330: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BC334: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828BC338: 388AC2D0  addi r4, r10, -0x3d30
	ctx.r[4].s64 = ctx.r[10].s64 + -15664;
	// 828BC33C: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 828BC340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC344: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BC348: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828BC34C: 4BF3380D  bl 0x827efb58
	ctx.lr = 0x828BC350;
	sub_827EFB58(ctx, base);
	// 828BC350: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC358: 419A0008  beq cr6, 0x828bc360
	if ctx.cr[6].eq {
	pc = 0x828BC360; continue 'dispatch;
	}
	// 828BC35C: 4BA04535  bl 0x822c0890
	ctx.lr = 0x828BC360;
	sub_822C0890(ctx, base);
	// 828BC360: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC364: 488EBE58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC368 size=36
    let mut pc: u32 = 0x828BC368;
    'dispatch: loop {
        match pc {
            0x828BC368 => {
    //   block [0x828BC368..0x828BC38C)
	// 828BC368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC374: 4889828D  bl 0x83154600
	ctx.lr = 0x828BC378;
	sub_83154600(ctx, base);
	// 828BC378: 4BFFC971  bl 0x828b8ce8
	ctx.lr = 0x828BC37C;
	sub_828B8CE8(ctx, base);
	// 828BC37C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BC380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BC384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BC388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC390 size=96
    let mut pc: u32 = 0x828BC390;
    'dispatch: loop {
        match pc {
            0x828BC390 => {
    //   block [0x828BC390..0x828BC3F0)
	// 828BC390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC398: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BC39C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC3A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC3A4: 485A0585  bl 0x82e5c928
	ctx.lr = 0x828BC3A8;
	sub_82E5C928(ctx, base);
	// 828BC3A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BC3AC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BC3B0: 396BC350  addi r11, r11, -0x3cb0
	ctx.r[11].s64 = ctx.r[11].s64 + -15536;
	// 828BC3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC3B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BC3BC: 808A2FFC  lwz r4, 0x2ffc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12284 as u32) ) } as u64;
	// 828BC3C0: 48537649  bl 0x82df3a08
	ctx.lr = 0x828BC3C4;
	sub_82DF3A08(ctx, base);
	// 828BC3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC3C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC3CC: 4859D31D  bl 0x82e596e8
	ctx.lr = 0x828BC3D0;
	sub_82E596E8(ctx, base);
	// 828BC3D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC3D4: 48537055  bl 0x82df3428
	ctx.lr = 0x828BC3D8;
	sub_82DF3428(ctx, base);
	// 828BC3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC3DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BC3E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BC3E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BC3E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BC3EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC3F0 size=108
    let mut pc: u32 = 0x828BC3F0;
    'dispatch: loop {
        match pc {
            0x828BC3F0 => {
    //   block [0x828BC3F0..0x828BC45C)
	// 828BC3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC3F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BC3FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC400: 48898201  bl 0x83154600
	ctx.lr = 0x828BC404;
	sub_83154600(ctx, base);
	// 828BC404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC408: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC40C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BC410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC414: 4E800421  bctrl
	ctx.lr = 0x828BC418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC418: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BC41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC420: 808B25A8  lwz r4, 0x25a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9640 as u32) ) } as u64;
	// 828BC424: 485375E5  bl 0x82df3a08
	ctx.lr = 0x828BC428;
	sub_82DF3A08(ctx, base);
	// 828BC428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC42C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC434: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BC438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC43C: 4E800421  bctrl
	ctx.lr = 0x828BC440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC444: 48536FE5  bl 0x82df3428
	ctx.lr = 0x828BC448;
	sub_82DF3428(ctx, base);
	// 828BC448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BC44C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BC450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BC454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BC458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC460 size=108
    let mut pc: u32 = 0x828BC460;
    'dispatch: loop {
        match pc {
            0x828BC460 => {
    //   block [0x828BC460..0x828BC4CC)
	// 828BC460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BC46C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC474: 485A04B5  bl 0x82e5c928
	ctx.lr = 0x828BC478;
	sub_82E5C928(ctx, base);
	// 828BC478: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BC47C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BC480: 394AC378  addi r10, r10, -0x3c88
	ctx.r[10].s64 = ctx.r[10].s64 + -15496;
	// 828BC484: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828BC488: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BC48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC490: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BC494: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828BC498: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828BC49C: 4853756D  bl 0x82df3a08
	ctx.lr = 0x828BC4A0;
	sub_82DF3A08(ctx, base);
	// 828BC4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC4A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC4A8: 4859D241  bl 0x82e596e8
	ctx.lr = 0x828BC4AC;
	sub_82E596E8(ctx, base);
	// 828BC4AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC4B0: 48536F79  bl 0x82df3428
	ctx.lr = 0x828BC4B4;
	sub_82DF3428(ctx, base);
	// 828BC4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC4B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BC4BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BC4C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BC4C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BC4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BC4D0 size=748
    let mut pc: u32 = 0x828BC4D0;
    'dispatch: loop {
        match pc {
            0x828BC4D0 => {
    //   block [0x828BC4D0..0x828BC7BC)
	// 828BC4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC4D4: 488EBC95  bl 0x831a8168
	ctx.lr = 0x828BC4D8;
	sub_831A8130(ctx, base);
	// 828BC4D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC4DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC4E0: 48898121  bl 0x83154600
	ctx.lr = 0x828BC4E4;
	sub_83154600(ctx, base);
	// 828BC4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC4E8: 4BFFC801  bl 0x828b8ce8
	ctx.lr = 0x828BC4EC;
	sub_828B8CE8(ctx, base);
	// 828BC4EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC4F4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BC4F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC4FC: 4E800421  bctrl
	ctx.lr = 0x828BC500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC500: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC508: 4805A261  bl 0x82916768
	ctx.lr = 0x828BC50C;
	sub_82916768(ctx, base);
	// 828BC50C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC510: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828BC514: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BC518: 48052861  bl 0x8290ed78
	ctx.lr = 0x828BC51C;
	sub_8290ED78(ctx, base);
	// 828BC51C: 3FA0832C  lis r29, -0x7cd4
	ctx.r[29].s64 = -2094268416;
	// 828BC520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC524: 809D25B8  lwz r4, 0x25b8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828BC528: 485374E1  bl 0x82df3a08
	ctx.lr = 0x828BC52C;
	sub_82DF3A08(ctx, base);
	// 828BC52C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC530: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828BC534: 4BF2DD75  bl 0x827ea2a8
	ctx.lr = 0x828BC538;
	sub_827EA2A8(ctx, base);
	// 828BC538: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BC53C: 48536D65  bl 0x82df32a0
	ctx.lr = 0x828BC540;
	sub_82DF32A0(ctx, base);
	// 828BC540: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC548: 48536EE1  bl 0x82df3428
	ctx.lr = 0x828BC54C;
	sub_82DF3428(ctx, base);
	// 828BC54C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC550: 41820030  beq 0x828bc580
	if ctx.cr[0].eq {
	pc = 0x828BC580; continue 'dispatch;
	}
	// 828BC554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC558: 809D25B8  lwz r4, 0x25b8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828BC55C: 485374AD  bl 0x82df3a08
	ctx.lr = 0x828BC560;
	sub_82DF3A08(ctx, base);
	// 828BC560: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC564: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC56C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BC570: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC574: 4E800421  bctrl
	ctx.lr = 0x828BC578;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC57C: 48536EAD  bl 0x82df3428
	ctx.lr = 0x828BC580;
	sub_82DF3428(ctx, base);
	// 828BC580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC584: 4BFFC77D  bl 0x828b8d00
	ctx.lr = 0x828BC588;
	sub_828B8D00(ctx, base);
	// 828BC588: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BC58C: C1ABA1C4  lfs f13, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BC590: EC010372  fmuls f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 828BC594: D01E0068  stfs f0, 0x68(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828BC598: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828BC59C: 41990014  bgt cr6, 0x828bc5b0
	if ctx.cr[6].gt {
	pc = 0x828BC5B0; continue 'dispatch;
	}
	// 828BC5A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BC5A4: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BC5A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828BC5AC: 40980008  bge cr6, 0x828bc5b4
	if !ctx.cr[6].lt {
	pc = 0x828BC5B4; continue 'dispatch;
	}
	// 828BC5B0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 828BC5B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BC5B8: D01E0068  stfs f0, 0x68(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828BC5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC5C0: 939E0060  stw r28, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828BC5C4: 939E0064  stw r28, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828BC5C8: 4805A1A1  bl 0x82916768
	ctx.lr = 0x828BC5CC;
	sub_82916768(ctx, base);
	// 828BC5CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC5D0: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BC5D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC5D8: 4E800421  bctrl
	ctx.lr = 0x828BC5DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC5DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC5E0: 480837B1  bl 0x8293fd90
	ctx.lr = 0x828BC5E4;
	sub_8293FD90(ctx, base);
	// 828BC5E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC5E8: 480849F1  bl 0x82940fd8
	ctx.lr = 0x828BC5EC;
	sub_82940FD8(ctx, base);
	// 828BC5EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BC5F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC5F4: 3BABC3A0  addi r29, r11, -0x3c60
	ctx.r[29].s64 = ctx.r[11].s64 + -15456;
	// 828BC5F8: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 828BC5FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC600: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 828BC604: 4BA03DD5  bl 0x822c03d8
	ctx.lr = 0x828BC608;
	sub_822C03D8(ctx, base);
	// 828BC608: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BC60C: 41820018  beq 0x828bc624
	if ctx.cr[0].eq {
	pc = 0x828BC624; continue 'dispatch;
	}
	// 828BC610: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BC618: 480849E9  bl 0x82941000
	ctx.lr = 0x828BC61C;
	sub_82941000(ctx, base);
	// 828BC61C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC620: 48000008  b 0x828bc628
	pc = 0x828BC628; continue 'dispatch;
	// 828BC624: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC628: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC62C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC630: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC634: 4BFB56F5  bl 0x82871d28
	ctx.lr = 0x828BC638;
	sub_82871D28(ctx, base);
	// 828BC638: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC63C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC644: 4BA039BD  bl 0x822c0000
	ctx.lr = 0x828BC648;
	sub_822C0000(ctx, base);
	// 828BC648: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC650: 48083851  bl 0x8293fea0
	ctx.lr = 0x828BC654;
	sub_8293FEA0(ctx, base);
	// 828BC654: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC658: 480868F9  bl 0x82942f50
	ctx.lr = 0x828BC65C;
	sub_82942F50(ctx, base);
	// 828BC65C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC660: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC664: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828BC668: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BC66C: 4BA03D6D  bl 0x822c03d8
	ctx.lr = 0x828BC670;
	sub_822C03D8(ctx, base);
	// 828BC670: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BC674: 41820018  beq 0x828bc68c
	if ctx.cr[0].eq {
	pc = 0x828BC68C; continue 'dispatch;
	}
	// 828BC678: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC67C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BC680: 480868F1  bl 0x82942f70
	ctx.lr = 0x828BC684;
	sub_82942F70(ctx, base);
	// 828BC684: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC688: 48000008  b 0x828bc690
	pc = 0x828BC690; continue 'dispatch;
	// 828BC68C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC690: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC694: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC698: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC69C: 4BFB5755  bl 0x82871df0
	ctx.lr = 0x828BC6A0;
	sub_82871DF0(ctx, base);
	// 828BC6A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC6A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC6A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC6AC: 4BA03955  bl 0x822c0000
	ctx.lr = 0x828BC6B0;
	sub_822C0000(ctx, base);
	// 828BC6B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC6B8: 480837E9  bl 0x8293fea0
	ctx.lr = 0x828BC6BC;
	sub_8293FEA0(ctx, base);
	// 828BC6BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC6C0: 48086C99  bl 0x82943358
	ctx.lr = 0x828BC6C4;
	sub_82943358(ctx, base);
	// 828BC6C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC6C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC6CC: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 828BC6D0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828BC6D4: 4BA03D05  bl 0x822c03d8
	ctx.lr = 0x828BC6D8;
	sub_822C03D8(ctx, base);
	// 828BC6D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BC6DC: 41820018  beq 0x828bc6f4
	if ctx.cr[0].eq {
	pc = 0x828BC6F4; continue 'dispatch;
	}
	// 828BC6E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC6E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BC6E8: 48086CA1  bl 0x82943388
	ctx.lr = 0x828BC6EC;
	sub_82943388(ctx, base);
	// 828BC6EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC6F0: 48000008  b 0x828bc6f8
	pc = 0x828BC6F8; continue 'dispatch;
	// 828BC6F4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC6F8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC6FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC700: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC704: 4BFB57B5  bl 0x82871eb8
	ctx.lr = 0x828BC708;
	sub_82871EB8(ctx, base);
	// 828BC708: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC70C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC710: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC714: 4BA038ED  bl 0x822c0000
	ctx.lr = 0x828BC718;
	sub_822C0000(ctx, base);
	// 828BC718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC720: 48083781  bl 0x8293fea0
	ctx.lr = 0x828BC724;
	sub_8293FEA0(ctx, base);
	// 828BC724: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC728: 480861C9  bl 0x829428f0
	ctx.lr = 0x828BC72C;
	sub_829428F0(ctx, base);
	// 828BC72C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828BC730: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BC734: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828BC738: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC73C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BC740: C1AB614C  lfs f13, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BC744: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 828BC748: C18AC664  lfs f12, -0x399c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828BC74C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828BC750: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BC754: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BC758: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828BC75C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828BC760: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828BC764: 4BA03C75  bl 0x822c03d8
	ctx.lr = 0x828BC768;
	sub_822C03D8(ctx, base);
	// 828BC768: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BC76C: 41820018  beq 0x828bc784
	if ctx.cr[0].eq {
	pc = 0x828BC784; continue 'dispatch;
	}
	// 828BC770: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC774: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BC778: 480861A9  bl 0x82942920
	ctx.lr = 0x828BC77C;
	sub_82942920(ctx, base);
	// 828BC77C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC780: 48000008  b 0x828bc788
	pc = 0x828BC788; continue 'dispatch;
	// 828BC784: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC788: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC790: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC794: 4BFB57ED  bl 0x82871f80
	ctx.lr = 0x828BC798;
	sub_82871F80(ctx, base);
	// 828BC798: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BC79C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC7A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BC7A4: 4BA0385D  bl 0x822c0000
	ctx.lr = 0x828BC7A8;
	sub_822C0000(ctx, base);
	// 828BC7A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC7B0: 480836F1  bl 0x8293fea0
	ctx.lr = 0x828BC7B4;
	sub_8293FEA0(ctx, base);
	// 828BC7B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BC7B8: 488EBA00  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BC7C0 size=340
    let mut pc: u32 = 0x828BC7C0;
    'dispatch: loop {
        match pc {
            0x828BC7C0 => {
    //   block [0x828BC7C0..0x828BC914)
	// 828BC7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC7C4: 488EB9A1  bl 0x831a8164
	ctx.lr = 0x828BC7C8;
	sub_831A8130(ctx, base);
	// 828BC7C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828BC7CC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC7D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC7D4: 48897E2D  bl 0x83154600
	ctx.lr = 0x828BC7D8;
	sub_83154600(ctx, base);
	// 828BC7D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC7DC: 4BFFC50D  bl 0x828b8ce8
	ctx.lr = 0x828BC7E0;
	sub_828B8CE8(ctx, base);
	// 828BC7E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BC7E4: 4BFF52AD  bl 0x828b1a90
	ctx.lr = 0x828BC7E8;
	sub_828B1A90(ctx, base);
	// 828BC7E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BC7EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC7F0: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 828BC7F4: 4859CF85  bl 0x82e59778
	ctx.lr = 0x828BC7F8;
	sub_82E59778(ctx, base);
	// 828BC7F8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BC7FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC800: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828BC804: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BC808: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC80C: 4E800421  bctrl
	ctx.lr = 0x828BC810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC810: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BC814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC818: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BC81C: 48083415  bl 0x8293fc30
	ctx.lr = 0x828BC820;
	sub_8293FC30(ctx, base);
	// 828BC820: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC824: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC828: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC82C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC830: 4E800421  bctrl
	ctx.lr = 0x828BC834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC834: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC838: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC83C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC840: 4804CE19  bl 0x82909658
	ctx.lr = 0x828BC844;
	sub_82909658(ctx, base);
	// 828BC844: 138018C7  vcmpequd (lvx128) v28, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BC848: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BC84C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BC918 size=532
    let mut pc: u32 = 0x828BC918;
    'dispatch: loop {
        match pc {
            0x828BC918 => {
    //   block [0x828BC918..0x828BCB2C)
	// 828BC918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC91C: 488EB84D  bl 0x831a8168
	ctx.lr = 0x828BC920;
	sub_831A8130(ctx, base);
	// 828BC920: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828BC924: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC928: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC92C: 48897CD5  bl 0x83154600
	ctx.lr = 0x828BC930;
	sub_83154600(ctx, base);
	// 828BC930: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BC934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC938: 48897CC9  bl 0x83154600
	ctx.lr = 0x828BC93C;
	sub_83154600(ctx, base);
	// 828BC93C: 4BFFC3AD  bl 0x828b8ce8
	ctx.lr = 0x828BC940;
	sub_828B8CE8(ctx, base);
	// 828BC940: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BC948: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BC94C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BC950: 4E800421  bctrl
	ctx.lr = 0x828BC954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BC954: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BC958: 3BFE0064  addi r31, r30, 0x64
	ctx.r[31].s64 = ctx.r[30].s64 + 100;
	// 828BC95C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC960: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC964: 41820038  beq 0x828bc99c
	if ctx.cr[0].eq {
	pc = 0x828BC99C; continue 'dispatch;
	}
	// 828BC968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC96C: 4859CDFD  bl 0x82e59768
	ctx.lr = 0x828BC970;
	sub_82E59768(ctx, base);
	// 828BC970: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BC974: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BC978: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BC97C: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BC980: C00AA1C4  lfs f0, -0x5e3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BC984: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BC988: 4BFFC361  bl 0x828b8ce8
	ctx.lr = 0x828BC98C;
	sub_828B8CE8(ctx, base);
	// 828BC98C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BC990: 4BFF6989  bl 0x828b3318
	ctx.lr = 0x828BC994;
	sub_828B3318(ctx, base);
	// 828BC994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BC998: 48000078  b 0x828bca10
	pc = 0x828BCA10; continue 'dispatch;
	// 828BC99C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BC9A0: 556AD7FF  rlwinm. r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BC9A4: 4182001C  beq 0x828bc9c0
	if ctx.cr[0].eq {
	pc = 0x828BC9C0; continue 'dispatch;
	}
	// 828BC9A8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC9AC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BC9B0: 556B06B0  rlwinm r11, r11, 0, 0x1a, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BC9B4: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BC9B8: 808A25D0  lwz r4, 0x25d0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9680 as u32) ) } as u64;
	// 828BC9BC: 480000D8  b 0x828bca94
	pc = 0x828BCA94; continue 'dispatch;
	// 828BC9C0: 556ADFFF  rlwinm. r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BC9C4: 4182001C  beq 0x828bc9e0
	if ctx.cr[0].eq {
	pc = 0x828BC9E0; continue 'dispatch;
	}
	// 828BC9C8: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BC9CC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BC9D0: 556B06F2  rlwinm r11, r11, 0, 0x1b, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BC9D4: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BC9D8: 808A25BC  lwz r4, 0x25bc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9660 as u32) ) } as u64;
	// 828BC9DC: 480000B8  b 0x828bca94
	pc = 0x828BCA94; continue 'dispatch;
	// 828BC9E0: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BC9E4: 4182001C  beq 0x828bca00
	if ctx.cr[0].eq {
	pc = 0x828BCA00; continue 'dispatch;
	}
	// 828BC9E8: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BC9EC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BC9F0: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BC9F4: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BC9F8: 808A25D4  lwz r4, 0x25d4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9684 as u32) ) } as u64;
	// 828BC9FC: 48000098  b 0x828bca94
	pc = 0x828BCA94; continue 'dispatch;
	// 828BCA00: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BCA04: 41820014  beq 0x828bca18
	if ctx.cr[0].eq {
	pc = 0x828BCA18; continue 'dispatch;
	}
	// 828BCA08: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BCA0C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCA10: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BCA14: 480000B4  b 0x828bcac8
	pc = 0x828BCAC8; continue 'dispatch;
	// 828BCA18: 556AC7FF  rlwinm. r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BCA1C: 4182001C  beq 0x828bca38
	if ctx.cr[0].eq {
	pc = 0x828BCA38; continue 'dispatch;
	}
	// 828BCA20: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BCA24: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BCA28: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCA2C: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BCA30: 808A25C4  lwz r4, 0x25c4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9668 as u32) ) } as u64;
	// 828BCA34: 48000060  b 0x828bca94
	pc = 0x828BCA94; continue 'dispatch;
	// 828BCA38: 556AE7FF  rlwinm. r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BCA3C: 4182001C  beq 0x828bca58
	if ctx.cr[0].eq {
	pc = 0x828BCA58; continue 'dispatch;
	}
	// 828BCA40: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BCA44: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BCA48: 556B0734  rlwinm r11, r11, 0, 0x1c, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCA4C: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BCA50: 808A25C0  lwz r4, 0x25c0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9664 as u32) ) } as u64;
	// 828BCA54: 48000040  b 0x828bca94
	pc = 0x828BCA94; continue 'dispatch;
	// 828BCA58: 556ACFFF  rlwinm. r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BCA5C: 4182001C  beq 0x828bca78
	if ctx.cr[0].eq {
	pc = 0x828BCA78; continue 'dispatch;
	}
	// 828BCA60: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BCA64: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BCA68: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCA6C: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BCA70: 808A25CC  lwz r4, 0x25cc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9676 as u32) ) } as u64;
	// 828BCA74: 48000020  b 0x828bca94
	pc = 0x828BCA94; continue 'dispatch;
	// 828BCA78: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCA7C: 4182004C  beq 0x828bcac8
	if ctx.cr[0].eq {
	pc = 0x828BCAC8; continue 'dispatch;
	}
	// 828BCA80: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BCA84: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BCA88: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCA8C: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BCA90: 808A25C8  lwz r4, 0x25c8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9672 as u32) ) } as u64;
	// 828BCA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCA98: 48536F71  bl 0x82df3a08
	ctx.lr = 0x828BCA9C;
	sub_82DF3A08(ctx, base);
	// 828BCA9C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCAA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BCAA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BCAA8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BCAAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BCAB0: 4E800421  bctrl
	ctx.lr = 0x828BCAB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BCAB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCAB8: 48536971  bl 0x82df3428
	ctx.lr = 0x828BCABC;
	sub_82DF3428(ctx, base);
	// 828BCABC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCAC0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828BCAC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCAC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCACC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCAD0: 41820050  beq 0x828bcb20
	if ctx.cr[0].eq {
	pc = 0x828BCB20; continue 'dispatch;
	}
	// 828BCAD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCAD8: 4BF2D839  bl 0x827ea310
	ctx.lr = 0x828BCADC;
	sub_827EA310(ctx, base);
	// 828BCADC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCAE0: 41820040  beq 0x828bcb20
	if ctx.cr[0].eq {
	pc = 0x828BCB20; continue 'dispatch;
	}
	// 828BCAE4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCAEC: 808B25B8  lwz r4, 0x25b8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9656 as u32) ) } as u64;
	// 828BCAF0: 48536F19  bl 0x82df3a08
	ctx.lr = 0x828BCAF4;
	sub_82DF3A08(ctx, base);
	// 828BCAF4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCAF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BCAFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BCB00: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BCB04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BCB08: 4E800421  bctrl
	ctx.lr = 0x828BCB0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BCB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCB10: 48536919  bl 0x82df3428
	ctx.lr = 0x828BCB14;
	sub_82DF3428(ctx, base);
	// 828BCB14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCB18: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCB1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCB20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BCB24: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828BCB28: 488EB690  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BCB30 size=304
    let mut pc: u32 = 0x828BCB30;
    'dispatch: loop {
        match pc {
            0x828BCB30 => {
    //   block [0x828BCB30..0x828BCC60)
	// 828BCB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCB34: 488EB639  bl 0x831a816c
	ctx.lr = 0x828BCB38;
	sub_831A8130(ctx, base);
	// 828BCB38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCB40: 48897AC1  bl 0x83154600
	ctx.lr = 0x828BCB44;
	sub_83154600(ctx, base);
	// 828BCB44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BCB48: 4BFFC1A1  bl 0x828b8ce8
	ctx.lr = 0x828BCB4C;
	sub_828B8CE8(ctx, base);
	// 828BCB4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCB50: 4BFFC1E1  bl 0x828b8d30
	ctx.lr = 0x828BCB54;
	sub_828B8D30(ctx, base);
	// 828BCB54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BCB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCB5C: 4BFFFC65  bl 0x828bc7c0
	ctx.lr = 0x828BCB60;
	sub_828BC7C0(ctx, base);
	// 828BCB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCB64: 4BFFFDB5  bl 0x828bc918
	ctx.lr = 0x828BCB68;
	sub_828BC918(ctx, base);
	// 828BCB68: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BCB6C: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BCB70: 408200E8  bne 0x828bcc58
	if !ctx.cr[0].eq {
	pc = 0x828BCC58; continue 'dispatch;
	}
	// 828BCB74: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCB78: 41820010  beq 0x828bcb88
	if ctx.cr[0].eq {
	pc = 0x828BCB88; continue 'dispatch;
	}
	// 828BCB7C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BCB80: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828BCB84: 480000B8  b 0x828bcc3c
	pc = 0x828BCC3C; continue 'dispatch;
	// 828BCB88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCB8C: 4859CBDD  bl 0x82e59768
	ctx.lr = 0x828BCB90;
	sub_82E59768(ctx, base);
	// 828BCB90: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BCB94: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BCB98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BCB9C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BCBA0: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828BCBA4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BCBA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828BCBAC: 409800AC  bge cr6, 0x828bcc58
	if !ctx.cr[6].lt {
	pc = 0x828BCC58; continue 'dispatch;
	}
	// 828BCBB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCBB4: 4BFFC14D  bl 0x828b8d00
	ctx.lr = 0x828BCBB8;
	sub_828B8D00(ctx, base);
	// 828BCBB8: C01D0024  lfs f0, 0x24(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BCBBC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828BCBC0: 40980010  bge cr6, 0x828bcbd0
	if !ctx.cr[6].lt {
	pc = 0x828BCBD0; continue 'dispatch;
	}
	// 828BCBC4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCBC8: 808B2FF4  lwz r4, 0x2ff4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12276 as u32) ) } as u64;
	// 828BCBCC: 48000070  b 0x828bcc3c
	pc = 0x828BCC3C; continue 'dispatch;
	// 828BCBD0: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828BCBD4: C1BD0018  lfs f13, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BCBD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828BCBDC: 40980010  bge cr6, 0x828bcbec
	if !ctx.cr[6].lt {
	pc = 0x828BCBEC; continue 'dispatch;
	}
	// 828BCBE0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCBE4: 808B3000  lwz r4, 0x3000(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12288 as u32) ) } as u64;
	// 828BCBE8: 48000054  b 0x828bcc3c
	pc = 0x828BCC3C; continue 'dispatch;
	// 828BCBEC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BCBF0: C1BD001C  lfs f13, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BCBF4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828BCBF8: 40980010  bge cr6, 0x828bcc08
	if !ctx.cr[6].lt {
	pc = 0x828BCC08; continue 'dispatch;
	}
	// 828BCBFC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCC00: 808B3004  lwz r4, 0x3004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12292 as u32) ) } as u64;
	// 828BCC04: 48000038  b 0x828bcc3c
	pc = 0x828BCC3C; continue 'dispatch;
	// 828BCC08: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BCC0C: C1BD0020  lfs f13, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BCC10: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828BCC14: 40980010  bge cr6, 0x828bcc24
	if !ctx.cr[6].lt {
	pc = 0x828BCC24; continue 'dispatch;
	}
	// 828BCC18: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCC1C: 808B3008  lwz r4, 0x3008(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12296 as u32) ) } as u64;
	// 828BCC20: 4800001C  b 0x828bcc3c
	pc = 0x828BCC3C; continue 'dispatch;
	// 828BCC24: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BCC28: C1BD0028  lfs f13, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BCC2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828BCC30: 40980028  bge cr6, 0x828bcc58
	if !ctx.cr[6].lt {
	pc = 0x828BCC58; continue 'dispatch;
	}
	// 828BCC34: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCC38: 808B300C  lwz r4, 0x300c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12300 as u32) ) } as u64;
	// 828BCC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCC40: 48536DC9  bl 0x82df3a08
	ctx.lr = 0x828BCC44;
	sub_82DF3A08(ctx, base);
	// 828BCC44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BCC48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCC4C: 4BF32AF5  bl 0x827ef740
	ctx.lr = 0x828BCC50;
	sub_827EF740(ctx, base);
	// 828BCC50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCC54: 485367D5  bl 0x82df3428
	ctx.lr = 0x828BCC58;
	sub_82DF3428(ctx, base);
	// 828BCC58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BCC5C: 488EB560  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BCC60 size=96
    let mut pc: u32 = 0x828BCC60;
    'dispatch: loop {
        match pc {
            0x828BCC60 => {
    //   block [0x828BCC60..0x828BCCC0)
	// 828BCC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BCC68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BCC6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCC70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCC74: 4859FCB5  bl 0x82e5c928
	ctx.lr = 0x828BCC78;
	sub_82E5C928(ctx, base);
	// 828BCC78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BCC7C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828BCC80: 396BC420  addi r11, r11, -0x3be0
	ctx.r[11].s64 = ctx.r[11].s64 + -15328;
	// 828BCC84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCC88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCC8C: 808A0AFC  lwz r4, 0xafc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828BCC90: 48536D79  bl 0x82df3a08
	ctx.lr = 0x828BCC94;
	sub_82DF3A08(ctx, base);
	// 828BCC94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCC98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BCC9C: 4859CA4D  bl 0x82e596e8
	ctx.lr = 0x828BCCA0;
	sub_82E596E8(ctx, base);
	// 828BCCA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCCA4: 48536785  bl 0x82df3428
	ctx.lr = 0x828BCCA8;
	sub_82DF3428(ctx, base);
	// 828BCCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCCAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BCCB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BCCB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BCCB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BCCBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BCCC0 size=116
    let mut pc: u32 = 0x828BCCC0;
    'dispatch: loop {
        match pc {
            0x828BCCC0 => {
    //   block [0x828BCCC0..0x828BCD34)
	// 828BCCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCCC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BCCC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BCCCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BCCD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCCD4: 4889792D  bl 0x83154600
	ctx.lr = 0x828BCCD8;
	sub_83154600(ctx, base);
	// 828BCCD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BCCDC: 4BFFC00D  bl 0x828b8ce8
	ctx.lr = 0x828BCCE0;
	sub_828B8CE8(ctx, base);
	// 828BCCE0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BCCE4: 4804C8A5  bl 0x82909588
	ctx.lr = 0x828BCCE8;
	sub_82909588(ctx, base);
	// 828BCCE8: 480837C1  bl 0x829404a8
	ctx.lr = 0x828BCCEC;
	sub_829404A8(ctx, base);
	// 828BCCEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BCCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCCF4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCCF8: 4BF32B59  bl 0x827ef850
	ctx.lr = 0x828BCCFC;
	sub_827EF850(ctx, base);
	// 828BCCFC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828BCD00: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BCD04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BCD08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCD0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BCD10: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BCD14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BCD18: 4E800421  bctrl
	ctx.lr = 0x828BCD1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BCD1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BCD20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BCD24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BCD28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BCD2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BCD30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BCD38 size=532
    let mut pc: u32 = 0x828BCD38;
    'dispatch: loop {
        match pc {
            0x828BCD38 => {
    //   block [0x828BCD38..0x828BCF4C)
	// 828BCD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCD3C: 488EB425  bl 0x831a8160
	ctx.lr = 0x828BCD40;
	sub_831A8130(ctx, base);
	// 828BCD40: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828BCD44: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCD48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCD4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BCD50: 488978B1  bl 0x83154600
	ctx.lr = 0x828BCD54;
	sub_83154600(ctx, base);
	// 828BCD54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BCD58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCD5C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BCD60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BCD64: 4E800421  bctrl
	ctx.lr = 0x828BCD68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BCD68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BCD6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCD70: 4BFFBF79  bl 0x828b8ce8
	ctx.lr = 0x828BCD74;
	sub_828B8CE8(ctx, base);
	// 828BCD74: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BCD78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCD7C: 4BFFBFB5  bl 0x828b8d30
	ctx.lr = 0x828BCD80;
	sub_828B8D30(ctx, base);
	// 828BCD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCD84: 4859C9E5  bl 0x82e59768
	ctx.lr = 0x828BCD88;
	sub_82E59768(ctx, base);
	// 828BCD88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BCD8C: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BCD90: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BCD94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BCD98: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BCD9C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828BCDA0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BCDA4: 808A25DC  lwz r4, 0x25dc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9692 as u32) ) } as u64;
	// 828BCDA8: 48536C61  bl 0x82df3a08
	ctx.lr = 0x828BCDAC;
	sub_82DF3A08(ctx, base);
	// 828BCDAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BCDB0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828BCDB4: 3B410054  addi r26, r1, 0x54
	ctx.r[26].s64 = ctx.r[1].s64 + 84;
	// 828BCDB8: 4BF2D4F1  bl 0x827ea2a8
	ctx.lr = 0x828BCDBC;
	sub_827EA2A8(ctx, base);
	// 828BCDBC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BCDC0: 485364E1  bl 0x82df32a0
	ctx.lr = 0x828BCDC4;
	sub_82DF32A0(ctx, base);
	// 828BCDC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCDC8: 40820038  bne 0x828bce00
	if !ctx.cr[0].eq {
	pc = 0x828BCE00; continue 'dispatch;
	}
	// 828BCDCC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCDD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCDD4: 808B25D8  lwz r4, 0x25d8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9688 as u32) ) } as u64;
	// 828BCDD8: 48536C31  bl 0x82df3a08
	ctx.lr = 0x828BCDDC;
	sub_82DF3A08(ctx, base);
	// 828BCDDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BCDE0: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 828BCDE4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828BCDE8: 4BF2D4C1  bl 0x827ea2a8
	ctx.lr = 0x828BCDEC;
	sub_827EA2A8(ctx, base);
	// 828BCDEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BCDF0: 485364B1  bl 0x82df32a0
	ctx.lr = 0x828BCDF4;
	sub_82DF32A0(ctx, base);
	// 828BCDF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCDF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BCDFC: 41820008  beq 0x828bce04
	if ctx.cr[0].eq {
	pc = 0x828BCE04; continue 'dispatch;
	}
	// 828BCE00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BCE04: 578A07BD  rlwinm. r10, r28, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BCE08: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BCE0C: 41820010  beq 0x828bce1c
	if ctx.cr[0].eq {
	pc = 0x828BCE1C; continue 'dispatch;
	}
	// 828BCE10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BCE14: 579C07FA  rlwinm r28, r28, 0, 0x1f, 0x1d
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 828BCE18: 48536611  bl 0x82df3428
	ctx.lr = 0x828BCE1C;
	sub_82DF3428(ctx, base);
	// 828BCE1C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCE20: 4182000C  beq 0x828bce2c
	if ctx.cr[0].eq {
	pc = 0x828BCE2C; continue 'dispatch;
	}
	// 828BCE24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BCE28: 48536601  bl 0x82df3428
	ctx.lr = 0x828BCE2C;
	sub_82DF3428(ctx, base);
	// 828BCE2C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCE30: 418200D0  beq 0x828bcf00
	if ctx.cr[0].eq {
	pc = 0x828BCF00; continue 'dispatch;
	}
	// 828BCE34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BCE38: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BCE3C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BCE40: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828BCE44: 4098004C  bge cr6, 0x828bce90
	if !ctx.cr[6].lt {
	pc = 0x828BCE90; continue 'dispatch;
	}
	// 828BCE48: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BCE4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BCE50: 808B2FF0  lwz r4, 0x2ff0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12272 as u32) ) } as u64;
	// 828BCE54: 48536BB5  bl 0x82df3a08
	ctx.lr = 0x828BCE58;
	sub_82DF3A08(ctx, base);
	// 828BCE58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BCE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCE60: 4874B2C9  bl 0x83008128
	ctx.lr = 0x828BCE64;
	sub_83008128(ctx, base);
	// 828BCE64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BCE68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BCE6C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BCE70: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BCE74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BCE78: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BCE7C: 485A1AE5  bl 0x82e5e960
	ctx.lr = 0x828BCE80;
	sub_82E5E960(ctx, base);
	// 828BCE80: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BCE84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BCE88: 419A0008  beq cr6, 0x828bce90
	if ctx.cr[6].eq {
	pc = 0x828BCE90; continue 'dispatch;
	}
	// 828BCE8C: 4BA03A05  bl 0x822c0890
	ctx.lr = 0x828BCE90;
	sub_822C0890(ctx, base);
	// 828BCE90: 3BBB0010  addi r29, r27, 0x10
	ctx.r[29].s64 = ctx.r[27].s64 + 16;
	// 828BCE94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BCE98: 4804C6E9  bl 0x82909580
	ctx.lr = 0x828BCE9C;
	sub_82909580(ctx, base);
	// 828BCE9C: 4805EF7D  bl 0x8291be18
	ctx.lr = 0x828BCEA0;
	sub_8291BE18(ctx, base);
	// 828BCEA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BCEA4: 4182005C  beq 0x828bcf00
	if ctx.cr[0].eq {
	pc = 0x828BCF00; continue 'dispatch;
	}
	// 828BCEA8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828BCEAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BCEB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BCEB4: 48051EC5  bl 0x8290ed78
	ctx.lr = 0x828BCEB8;
	sub_8290ED78(ctx, base);
	// 828BCEB8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BCEBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BCEC0: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828BCEC4: 48536B45  bl 0x82df3a08
	ctx.lr = 0x828BCEC8;
	sub_82DF3A08(ctx, base);
	// 828BCEC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BCECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCED0: 4874B259  bl 0x83008128
	ctx.lr = 0x828BCED4;
	sub_83008128(ctx, base);
	// 828BCED4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BCED8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCEDC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BCEE0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BCEE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BCEE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BCEEC: 485A1A75  bl 0x82e5e960
	ctx.lr = 0x828BCEF0;
	sub_82E5E960(ctx, base);
	// 828BCEF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BCEF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BCEF8: 419A0008  beq cr6, 0x828bcf00
	if ctx.cr[6].eq {
	pc = 0x828BCF00; continue 'dispatch;
	}
	// 828BCEFC: 4BA03995  bl 0x822c0890
	ctx.lr = 0x828BCF00;
	sub_822C0890(ctx, base);
	// 828BCF00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCF04: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 828BCF08: 4859C871  bl 0x82e59778
	ctx.lr = 0x828BCF0C;
	sub_82E59778(ctx, base);
	// 828BCF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCF10: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828BCF14: 4804C675  bl 0x82909588
	ctx.lr = 0x828BCF18;
	sub_82909588(ctx, base);
	// 828BCF18: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BCF1C: 480833FD  bl 0x82940318
	ctx.lr = 0x828BCF20;
	sub_82940318(ctx, base);
	// 828BCF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BCF24: 4804C665  bl 0x82909588
	ctx.lr = 0x828BCF28;
	sub_82909588(ctx, base);
	// 828BCF28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BCF2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BCF30: 480832D9  bl 0x82940208
	ctx.lr = 0x828BCF34;
	sub_82940208(ctx, base);
	// 828BCF34: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828BCF38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BCF3C: 4BFFBEBD  bl 0x828b8df8
	ctx.lr = 0x828BCF40;
	sub_828B8DF8(ctx, base);
	// 828BCF40: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCF44: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828BCF48: 488EB268  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BCF50 size=620
    let mut pc: u32 = 0x828BCF50;
    'dispatch: loop {
        match pc {
            0x828BCF50 => {
    //   block [0x828BCF50..0x828BD1BC)
	// 828BCF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCF54: 488EB205  bl 0x831a8158
	ctx.lr = 0x828BCF58;
	sub_831A8130(ctx, base);
	// 828BCF58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCF5C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828BCF60: 488976A1  bl 0x83154600
	ctx.lr = 0x828BCF64;
	sub_83154600(ctx, base);
	// 828BCF64: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BCF68: 4BFFBD81  bl 0x828b8ce8
	ctx.lr = 0x828BCF6C;
	sub_828B8CE8(ctx, base);
	// 828BCF6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCF70: 4BFF4B21  bl 0x828b1a90
	ctx.lr = 0x828BCF74;
	sub_828B1A90(ctx, base);
	// 828BCF74: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCF78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BCF7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BCF80: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BCF84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BCF88: 4E800421  bctrl
	ctx.lr = 0x828BCF8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BCF8C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BCF90: 4804C5F9  bl 0x82909588
	ctx.lr = 0x828BCF94;
	sub_82909588(ctx, base);
	// 828BCF94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCF98: 48083511  bl 0x829404a8
	ctx.lr = 0x828BCF9C;
	sub_829404A8(ctx, base);
	// 828BCF9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BCFA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BCFA4: 3BABC448  addi r29, r11, -0x3bb8
	ctx.r[29].s64 = ctx.r[11].s64 + -15288;
	// 828BCFA8: 38A00046  li r5, 0x46
	ctx.r[5].s64 = 70;
	// 828BCFAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BCFB0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828BCFB4: 4BA03425  bl 0x822c03d8
	ctx.lr = 0x828BCFB8;
	sub_822C03D8(ctx, base);
	// 828BCFB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BCFBC: 41820018  beq 0x828bcfd4
	if ctx.cr[0].eq {
	pc = 0x828BCFD4; continue 'dispatch;
	}
	// 828BCFC0: 38BC0224  addi r5, r28, 0x224
	ctx.r[5].s64 = ctx.r[28].s64 + 548;
	// 828BCFC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BCFC8: 480863C1  bl 0x82943388
	ctx.lr = 0x828BCFCC;
	sub_82943388(ctx, base);
	// 828BCFCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BCFD0: 48000008  b 0x828bcfd8
	pc = 0x828BCFD8; continue 'dispatch;
	// 828BCFD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BCFD8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BCFDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BCFE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BCFE4: 4BFB4ED5  bl 0x82871eb8
	ctx.lr = 0x828BCFE8;
	sub_82871EB8(ctx, base);
	// 828BCFE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BCFEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BCFF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BCFF4: 4BA0300D  bl 0x822c0000
	ctx.lr = 0x828BCFF8;
	sub_822C0000(ctx, base);
	// 828BCFF8: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BCFFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BD000: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828BD004: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 828BD008: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BD00C: 419A0024  beq cr6, 0x828bd030
	if ctx.cr[6].eq {
	pc = 0x828BD030; continue 'dispatch;
	}
	// 828BD010: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 828BD014: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BD018: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD01C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BD020: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BD024: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BD028: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD02C: 4082FFE8  bne 0x828bd014
	if !ctx.cr[0].eq {
	pc = 0x828BD014; continue 'dispatch;
	}
	// 828BD030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD038: 48083479  bl 0x829404b0
	ctx.lr = 0x828BD03C;
	sub_829404B0(ctx, base);
	// 828BD03C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD040: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BD044: 38A0004A  li r5, 0x4a
	ctx.r[5].s64 = 74;
	// 828BD048: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828BD04C: 4BA0338D  bl 0x822c03d8
	ctx.lr = 0x828BD050;
	sub_822C03D8(ctx, base);
	// 828BD050: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BD054: 41820018  beq 0x828bd06c
	if ctx.cr[0].eq {
	pc = 0x828BD06C; continue 'dispatch;
	}
	// 828BD058: 38BC0234  addi r5, r28, 0x234
	ctx.r[5].s64 = ctx.r[28].s64 + 564;
	// 828BD05C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD060: 48084EA9  bl 0x82941f08
	ctx.lr = 0x828BD064;
	sub_82941F08(ctx, base);
	// 828BD064: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD068: 48000008  b 0x828bd070
	pc = 0x828BD070; continue 'dispatch;
	// 828BD06C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BD070: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BD074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD078: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BD07C: 4BFB5D2D  bl 0x82872da8
	ctx.lr = 0x828BD080;
	sub_82872DA8(ctx, base);
	// 828BD080: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BD084: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD088: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BD08C: 4BA02F75  bl 0x822c0000
	ctx.lr = 0x828BD090;
	sub_822C0000(ctx, base);
	// 828BD090: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BD094: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BD098: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BD09C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828BD0A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BD0A4: 419A0024  beq cr6, 0x828bd0c8
	if ctx.cr[6].eq {
	pc = 0x828BD0C8; continue 'dispatch;
	}
	// 828BD0A8: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828BD0AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BD0B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD0B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BD0B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BD0BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BD0C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD0C4: 4082FFE8  bne 0x828bd0ac
	if !ctx.cr[0].eq {
	pc = 0x828BD0AC; continue 'dispatch;
	}
	// 828BD0C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD0D0: 480833E1  bl 0x829404b0
	ctx.lr = 0x828BD0D4;
	sub_829404B0(ctx, base);
	// 828BD0D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD0D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BD0DC: 38A0004E  li r5, 0x4e
	ctx.r[5].s64 = 78;
	// 828BD0E0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828BD0E4: 4BA032F5  bl 0x822c03d8
	ctx.lr = 0x828BD0E8;
	sub_822C03D8(ctx, base);
	// 828BD0E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BD0EC: 41820018  beq 0x828bd104
	if ctx.cr[0].eq {
	pc = 0x828BD104; continue 'dispatch;
	}
	// 828BD0F0: 38BC0250  addi r5, r28, 0x250
	ctx.r[5].s64 = ctx.r[28].s64 + 592;
	// 828BD0F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD0F8: 48085829  bl 0x82942920
	ctx.lr = 0x828BD0FC;
	sub_82942920(ctx, base);
	// 828BD0FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD100: 48000008  b 0x828bd108
	pc = 0x828BD108; continue 'dispatch;
	// 828BD104: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BD108: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BD10C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD110: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BD114: 4BFB4E6D  bl 0x82871f80
	ctx.lr = 0x828BD118;
	sub_82871F80(ctx, base);
	// 828BD118: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BD11C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD120: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BD124: 4BA02EDD  bl 0x822c0000
	ctx.lr = 0x828BD128;
	sub_822C0000(ctx, base);
	// 828BD128: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BD12C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BD130: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BD134: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828BD138: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BD13C: 419A0024  beq cr6, 0x828bd160
	if ctx.cr[6].eq {
	pc = 0x828BD160; continue 'dispatch;
	}
	// 828BD140: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828BD144: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BD148: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD14C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BD150: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BD154: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BD158: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD15C: 4082FFE8  bne 0x828bd144
	if !ctx.cr[0].eq {
	pc = 0x828BD144; continue 'dispatch;
	}
	// 828BD160: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD168: 48083349  bl 0x829404b0
	ctx.lr = 0x828BD16C;
	sub_829404B0(ctx, base);
	// 828BD16C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BD170: 419A000C  beq cr6, 0x828bd17c
	if ctx.cr[6].eq {
	pc = 0x828BD17C; continue 'dispatch;
	}
	// 828BD174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD178: 4BA03719  bl 0x822c0890
	ctx.lr = 0x828BD17C;
	sub_822C0890(ctx, base);
	// 828BD17C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BD180: 419A000C  beq cr6, 0x828bd18c
	if ctx.cr[6].eq {
	pc = 0x828BD18C; continue 'dispatch;
	}
	// 828BD184: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BD188: 4BA03709  bl 0x822c0890
	ctx.lr = 0x828BD18C;
	sub_822C0890(ctx, base);
	// 828BD18C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828BD190: 419A000C  beq cr6, 0x828bd19c
	if ctx.cr[6].eq {
	pc = 0x828BD19C; continue 'dispatch;
	}
	// 828BD194: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828BD198: 4BA036F9  bl 0x822c0890
	ctx.lr = 0x828BD19C;
	sub_822C0890(ctx, base);
	// 828BD19C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD1A0: 4BFFBB61  bl 0x828b8d00
	ctx.lr = 0x828BD1A4;
	sub_828B8D00(ctx, base);
	// 828BD1A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828BD1A8: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BD1AC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BD1B0: D0190060  stfs f0, 0x60(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BD1B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BD1B8: 488EAFF0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD1C0 size=8
    let mut pc: u32 = 0x828BD1C0;
    'dispatch: loop {
        match pc {
            0x828BD1C0 => {
    //   block [0x828BD1C0..0x828BD1C8)
	// 828BD1C0: 386303D4  addi r3, r3, 0x3d4
	ctx.r[3].s64 = ctx.r[3].s64 + 980;
	// 828BD1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD1C8 size=20
    let mut pc: u32 = 0x828BD1C8;
    'dispatch: loop {
        match pc {
            0x828BD1C8 => {
    //   block [0x828BD1C8..0x828BD1DC)
	// 828BD1C8: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828BD1CC: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828BD1D0: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BD1D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD1D8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD1E0 size=12
    let mut pc: u32 = 0x828BD1E0;
    'dispatch: loop {
        match pc {
            0x828BD1E0 => {
    //   block [0x828BD1E0..0x828BD1EC)
	// 828BD1E0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BD1E4: 386B0BA0  addi r3, r11, 0xba0
	ctx.r[3].s64 = ctx.r[11].s64 + 2976;
	// 828BD1E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD1F0 size=112
    let mut pc: u32 = 0x828BD1F0;
    'dispatch: loop {
        match pc {
            0x828BD1F0 => {
    //   block [0x828BD1F0..0x828BD260)
	// 828BD1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD1F4: 488EAF79  bl 0x831a816c
	ctx.lr = 0x828BD1F8;
	sub_831A8130(ctx, base);
	// 828BD1F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD1FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD200: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BD204: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828BD208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD20C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BD210: C03D000C  lfs f1, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BD214: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BD218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD21C: 4E800421  bctrl
	ctx.lr = 0x828BD220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD220: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BD224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD228: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD22C: 816B00FC  lwz r11, 0xfc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 828BD230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD234: 4E800421  bctrl
	ctx.lr = 0x828BD238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD23C: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BD240: 48156441  bl 0x82a13680
	ctx.lr = 0x828BD244;
	sub_82A13680(ctx, base);
	// 828BD244: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BD248: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 828BD24C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD254: 4E800421  bctrl
	ctx.lr = 0x828BD258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD258: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD25C: 488EAF60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD260 size=164
    let mut pc: u32 = 0x828BD260;
    'dispatch: loop {
        match pc {
            0x828BD260 => {
    //   block [0x828BD260..0x828BD304)
	// 828BD260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD264: 488EAF09  bl 0x831a816c
	ctx.lr = 0x828BD268;
	sub_831A8130(ctx, base);
	// 828BD268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD26C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BD270: 3BC40018  addi r30, r4, 0x18
	ctx.r[30].s64 = ctx.r[4].s64 + 24;
	// 828BD274: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BD278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD27C: 83EB0BA0  lwz r31, 0xba0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2976 as u32) ) } as u64;
	// 828BD280: 48535F31  bl 0x82df31b0
	ctx.lr = 0x828BD284;
	sub_82DF31B0(ctx, base);
	// 828BD284: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD288: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD28C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BD290: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BD294: 41820014  beq 0x828bd2a8
	if ctx.cr[0].eq {
	pc = 0x828BD2A8; continue 'dispatch;
	}
	// 828BD298: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828BD29C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828BD2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BD2A4: 419AFFE0  beq cr6, 0x828bd284
	if ctx.cr[6].eq {
	pc = 0x828BD284; continue 'dispatch;
	}
	// 828BD2A8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BD2AC: 41820050  beq 0x828bd2fc
	if ctx.cr[0].eq {
	pc = 0x828BD2FC; continue 'dispatch;
	}
	// 828BD2B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BD2B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD2B8: 83EB0B80  lwz r31, 0xb80(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2944 as u32) ) } as u64;
	// 828BD2BC: 48535EF5  bl 0x82df31b0
	ctx.lr = 0x828BD2C0;
	sub_82DF31B0(ctx, base);
	// 828BD2C0: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD2C4: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD2C8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BD2CC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BD2D0: 41820014  beq 0x828bd2e4
	if ctx.cr[0].eq {
	pc = 0x828BD2E4; continue 'dispatch;
	}
	// 828BD2D4: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828BD2D8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828BD2DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BD2E0: 419AFFE0  beq cr6, 0x828bd2c0
	if ctx.cr[6].eq {
	pc = 0x828BD2C0; continue 'dispatch;
	}
	// 828BD2E4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BD2E8: 41820014  beq 0x828bd2fc
	if ctx.cr[0].eq {
	pc = 0x828BD2FC; continue 'dispatch;
	}
	// 828BD2EC: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828BD2F0: 4BF2EE71  bl 0x827ec160
	ctx.lr = 0x828BD2F4;
	sub_827EC160(ctx, base);
	// 828BD2F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD2F8: 4BF32449  bl 0x827ef740
	ctx.lr = 0x828BD2FC;
	sub_827EF740(ctx, base);
	// 828BD2FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD300: 488EAEBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD308 size=4
    let mut pc: u32 = 0x828BD308;
    'dispatch: loop {
        match pc {
            0x828BD308 => {
    //   block [0x828BD308..0x828BD30C)
	// 828BD308: 4BC55800  b 0x82512b08
	sub_82512B08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD310 size=12
    let mut pc: u32 = 0x828BD310;
    'dispatch: loop {
        match pc {
            0x828BD310 => {
    //   block [0x828BD310..0x828BD31C)
	// 828BD310: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BD314: 386BC580  addi r3, r11, -0x3a80
	ctx.r[3].s64 = ctx.r[11].s64 + -14976;
	// 828BD318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD320 size=12
    let mut pc: u32 = 0x828BD320;
    'dispatch: loop {
        match pc {
            0x828BD320 => {
    //   block [0x828BD320..0x828BD32C)
	// 828BD320: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD324: 806B33F8  lwz r3, 0x33f8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13304 as u32) ) } as u64;
	// 828BD328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD330 size=12
    let mut pc: u32 = 0x828BD330;
    'dispatch: loop {
        match pc {
            0x828BD330 => {
    //   block [0x828BD330..0x828BD33C)
	// 828BD330: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD334: 806B3404  lwz r3, 0x3404(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13316 as u32) ) } as u64;
	// 828BD338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD340 size=12
    let mut pc: u32 = 0x828BD340;
    'dispatch: loop {
        match pc {
            0x828BD340 => {
    //   block [0x828BD340..0x828BD34C)
	// 828BD340: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BD344: 386B0850  addi r3, r11, 0x850
	ctx.r[3].s64 = ctx.r[11].s64 + 2128;
	// 828BD348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD350 size=12
    let mut pc: u32 = 0x828BD350;
    'dispatch: loop {
        match pc {
            0x828BD350 => {
    //   block [0x828BD350..0x828BD35C)
	// 828BD350: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BD354: 386BC598  addi r3, r11, -0x3a68
	ctx.r[3].s64 = ctx.r[11].s64 + -14952;
	// 828BD358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD360 size=16
    let mut pc: u32 = 0x828BD360;
    'dispatch: loop {
        match pc {
            0x828BD360 => {
    //   block [0x828BD360..0x828BD370)
	// 828BD360: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD364: 396B33F8  addi r11, r11, 0x33f8
	ctx.r[11].s64 = ctx.r[11].s64 + 13304;
	// 828BD368: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BD36C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD370 size=16
    let mut pc: u32 = 0x828BD370;
    'dispatch: loop {
        match pc {
            0x828BD370 => {
    //   block [0x828BD370..0x828BD380)
	// 828BD370: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD374: 396B3404  addi r11, r11, 0x3404
	ctx.r[11].s64 = ctx.r[11].s64 + 13316;
	// 828BD378: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BD37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD380 size=12
    let mut pc: u32 = 0x828BD380;
    'dispatch: loop {
        match pc {
            0x828BD380 => {
    //   block [0x828BD380..0x828BD38C)
	// 828BD380: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BD384: 386B0968  addi r3, r11, 0x968
	ctx.r[3].s64 = ctx.r[11].s64 + 2408;
	// 828BD388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD390 size=12
    let mut pc: u32 = 0x828BD390;
    'dispatch: loop {
        match pc {
            0x828BD390 => {
    //   block [0x828BD390..0x828BD39C)
	// 828BD390: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BD394: 386BC5B4  addi r3, r11, -0x3a4c
	ctx.r[3].s64 = ctx.r[11].s64 + -14924;
	// 828BD398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD3A0 size=16
    let mut pc: u32 = 0x828BD3A0;
    'dispatch: loop {
        match pc {
            0x828BD3A0 => {
    //   block [0x828BD3A0..0x828BD3B0)
	// 828BD3A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD3A4: 396B33F8  addi r11, r11, 0x33f8
	ctx.r[11].s64 = ctx.r[11].s64 + 13304;
	// 828BD3A8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BD3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD3B0 size=16
    let mut pc: u32 = 0x828BD3B0;
    'dispatch: loop {
        match pc {
            0x828BD3B0 => {
    //   block [0x828BD3B0..0x828BD3C0)
	// 828BD3B0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD3B4: 396B3404  addi r11, r11, 0x3404
	ctx.r[11].s64 = ctx.r[11].s64 + 13316;
	// 828BD3B8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BD3BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD3C0 size=12
    let mut pc: u32 = 0x828BD3C0;
    'dispatch: loop {
        match pc {
            0x828BD3C0 => {
    //   block [0x828BD3C0..0x828BD3CC)
	// 828BD3C0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BD3C4: 386B0A80  addi r3, r11, 0xa80
	ctx.r[3].s64 = ctx.r[11].s64 + 2688;
	// 828BD3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BD3D0 size=16
    let mut pc: u32 = 0x828BD3D0;
    'dispatch: loop {
        match pc {
            0x828BD3D0 => {
    //   block [0x828BD3D0..0x828BD3E0)
	// 828BD3D0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BD3D4: 396B0A80  addi r11, r11, 0xa80
	ctx.r[11].s64 = ctx.r[11].s64 + 2688;
	// 828BD3D8: 386B0108  addi r3, r11, 0x108
	ctx.r[3].s64 = ctx.r[11].s64 + 264;
	// 828BD3DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD3E0 size=116
    let mut pc: u32 = 0x828BD3E0;
    'dispatch: loop {
        match pc {
            0x828BD3E0 => {
    //   block [0x828BD3E0..0x828BD454)
	// 828BD3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD3E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD3EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD3F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD3F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD3F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD3FC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828BD400: 409A000C  bne cr6, 0x828bd40c
	if !ctx.cr[6].eq {
	pc = 0x828BD40C; continue 'dispatch;
	}
	// 828BD404: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD408: 48000030  b 0x828bd438
	pc = 0x828BD438; continue 'dispatch;
	// 828BD40C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828BD410: 419A0024  beq cr6, 0x828bd434
	if ctx.cr[6].eq {
	pc = 0x828BD434; continue 'dispatch;
	}
	// 828BD414: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD418: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD41C: 388B3570  addi r4, r11, 0x3570
	ctx.r[4].s64 = ctx.r[11].s64 + 13680;
	// 828BD420: 488EACD9  bl 0x831a80f8
	ctx.lr = 0x828BD424;
	sub_831A80F8(ctx, base);
	// 828BD424: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BD428: 4182000C  beq 0x828bd434
	if ctx.cr[0].eq {
	pc = 0x828BD434; continue 'dispatch;
	}
	// 828BD42C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828BD430: 4800000C  b 0x828bd43c
	pc = 0x828BD43C; continue 'dispatch;
	// 828BD434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD43C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD448: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD44C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD458 size=116
    let mut pc: u32 = 0x828BD458;
    'dispatch: loop {
        match pc {
            0x828BD458 => {
    //   block [0x828BD458..0x828BD4CC)
	// 828BD458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD46C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD470: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD474: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828BD478: 409A000C  bne cr6, 0x828bd484
	if !ctx.cr[6].eq {
	pc = 0x828BD484; continue 'dispatch;
	}
	// 828BD47C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD480: 48000030  b 0x828bd4b0
	pc = 0x828BD4B0; continue 'dispatch;
	// 828BD484: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828BD488: 419A0024  beq cr6, 0x828bd4ac
	if ctx.cr[6].eq {
	pc = 0x828BD4AC; continue 'dispatch;
	}
	// 828BD48C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD490: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD494: 388B35C0  addi r4, r11, 0x35c0
	ctx.r[4].s64 = ctx.r[11].s64 + 13760;
	// 828BD498: 488EAC61  bl 0x831a80f8
	ctx.lr = 0x828BD49C;
	sub_831A80F8(ctx, base);
	// 828BD49C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BD4A0: 4182000C  beq 0x828bd4ac
	if ctx.cr[0].eq {
	pc = 0x828BD4AC; continue 'dispatch;
	}
	// 828BD4A4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828BD4A8: 4800000C  b 0x828bd4b4
	pc = 0x828BD4B4; continue 'dispatch;
	// 828BD4AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD4B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD4B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD4B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD4BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD4C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD4C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD4D0 size=116
    let mut pc: u32 = 0x828BD4D0;
    'dispatch: loop {
        match pc {
            0x828BD4D0 => {
    //   block [0x828BD4D0..0x828BD544)
	// 828BD4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD4D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD4DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD4E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD4E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD4E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD4EC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828BD4F0: 409A000C  bne cr6, 0x828bd4fc
	if !ctx.cr[6].eq {
	pc = 0x828BD4FC; continue 'dispatch;
	}
	// 828BD4F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD4F8: 48000030  b 0x828bd528
	pc = 0x828BD528; continue 'dispatch;
	// 828BD4FC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828BD500: 419A0024  beq cr6, 0x828bd524
	if ctx.cr[6].eq {
	pc = 0x828BD524; continue 'dispatch;
	}
	// 828BD504: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD508: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD50C: 388B3610  addi r4, r11, 0x3610
	ctx.r[4].s64 = ctx.r[11].s64 + 13840;
	// 828BD510: 488EABE9  bl 0x831a80f8
	ctx.lr = 0x828BD514;
	sub_831A80F8(ctx, base);
	// 828BD514: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BD518: 4182000C  beq 0x828bd524
	if ctx.cr[0].eq {
	pc = 0x828BD524; continue 'dispatch;
	}
	// 828BD51C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828BD520: 4800000C  b 0x828bd52c
	pc = 0x828BD52C; continue 'dispatch;
	// 828BD524: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD528: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD52C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD53C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD548 size=136
    let mut pc: u32 = 0x828BD548;
    'dispatch: loop {
        match pc {
            0x828BD548 => {
    //   block [0x828BD548..0x828BD5D0)
	// 828BD548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD55C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD560: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD564: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828BD568: 409A0020  bne cr6, 0x828bd588
	if !ctx.cr[6].eq {
	pc = 0x828BD588; continue 'dispatch;
	}
	// 828BD56C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BD570: 419A0048  beq cr6, 0x828bd5b8
	if ctx.cr[6].eq {
	pc = 0x828BD5B8; continue 'dispatch;
	}
	// 828BD574: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828BD578: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828BD57C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828BD580: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828BD584: 48000034  b 0x828bd5b8
	pc = 0x828BD5B8; continue 'dispatch;
	// 828BD588: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828BD58C: 419A002C  beq cr6, 0x828bd5b8
	if ctx.cr[6].eq {
	pc = 0x828BD5B8; continue 'dispatch;
	}
	// 828BD590: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD594: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD598: 388B3660  addi r4, r11, 0x3660
	ctx.r[4].s64 = ctx.r[11].s64 + 13920;
	// 828BD59C: 488EAB5D  bl 0x831a80f8
	ctx.lr = 0x828BD5A0;
	sub_831A80F8(ctx, base);
	// 828BD5A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BD5A4: 4182000C  beq 0x828bd5b0
	if ctx.cr[0].eq {
	pc = 0x828BD5B0; continue 'dispatch;
	}
	// 828BD5A8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828BD5AC: 4800000C  b 0x828bd5b8
	pc = 0x828BD5B8; continue 'dispatch;
	// 828BD5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD5B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD5B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD5BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD5C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD5C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD5C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD5CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD5D0 size=148
    let mut pc: u32 = 0x828BD5D0;
    'dispatch: loop {
        match pc {
            0x828BD5D0 => {
    //   block [0x828BD5D0..0x828BD664)
	// 828BD5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD5D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD5DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD5E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD5E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD5E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD5EC: 480A1B35  bl 0x8295f120
	ctx.lr = 0x828BD5F0;
	sub_8295F120(ctx, base);
	// 828BD5F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD5F4: 4BF2EB6D  bl 0x827ec160
	ctx.lr = 0x828BD5F8;
	sub_827EC160(ctx, base);
	// 828BD5F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD5FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BD600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD604: 4E800421  bctrl
	ctx.lr = 0x828BD608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD608: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BD60C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD610: 48204981  bl 0x82ac1f90
	ctx.lr = 0x828BD614;
	sub_82AC1F90(ctx, base);
	// 828BD614: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD618: 4BF2EB49  bl 0x827ec160
	ctx.lr = 0x828BD61C;
	sub_827EC160(ctx, base);
	// 828BD61C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD620: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BD624: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD628: 4E800421  bctrl
	ctx.lr = 0x828BD62C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD62C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BD630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD634: 481EDEA5  bl 0x82aab4d8
	ctx.lr = 0x828BD638;
	sub_82AAB4D8(ctx, base);
	// 828BD638: 807E0388  lwz r3, 0x388(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(904 as u32) ) } as u64;
	// 828BD63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BD640: 419A000C  beq cr6, 0x828bd64c
	if ctx.cr[6].eq {
	pc = 0x828BD64C; continue 'dispatch;
	}
	// 828BD644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD648: 48065331  bl 0x82922978
	ctx.lr = 0x828BD64C;
	sub_82922978(ctx, base);
	// 828BD64C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD658: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD668 size=116
    let mut pc: u32 = 0x828BD668;
    'dispatch: loop {
        match pc {
            0x828BD668 => {
    //   block [0x828BD668..0x828BD6DC)
	// 828BD668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD674: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BD67C: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828BD680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BD684: 419A0008  beq cr6, 0x828bd68c
	if ctx.cr[6].eq {
	pc = 0x828BD68C; continue 'dispatch;
	}
	// 828BD688: 4BF0D111  bl 0x827ca798
	ctx.lr = 0x828BD68C;
	sub_827CA798(ctx, base);
	// 828BD68C: 807F03C0  lwz r3, 0x3c0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BD690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BD694: 419A0014  beq cr6, 0x828bd6a8
	if ctx.cr[6].eq {
	pc = 0x828BD6A8; continue 'dispatch;
	}
	// 828BD698: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD69C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BD6A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD6A4: 4E800421  bctrl
	ctx.lr = 0x828BD6A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD6A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD6B0: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BD6B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD6B8: 4E800421  bctrl
	ctx.lr = 0x828BD6BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD6BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BD6C0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BD6C4: 480A19F5  bl 0x8295f0b8
	ctx.lr = 0x828BD6C8;
	sub_8295F0B8(ctx, base);
	// 828BD6C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BD6CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD6D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD6D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD6E0 size=84
    let mut pc: u32 = 0x828BD6E0;
    'dispatch: loop {
        match pc {
            0x828BD6E0 => {
    //   block [0x828BD6E0..0x828BD734)
	// 828BD6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD6E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD6EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD6F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BD6F4: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828BD6F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BD6FC: 419A0008  beq cr6, 0x828bd704
	if ctx.cr[6].eq {
	pc = 0x828BD704; continue 'dispatch;
	}
	// 828BD700: 4BF0D139  bl 0x827ca838
	ctx.lr = 0x828BD704;
	sub_827CA838(ctx, base);
	// 828BD704: 807F03C0  lwz r3, 0x3c0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BD708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BD70C: 419A000C  beq cr6, 0x828bd718
	if ctx.cr[6].eq {
	pc = 0x828BD718; continue 'dispatch;
	}
	// 828BD710: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BD714: 485C413D  bl 0x82e81850
	ctx.lr = 0x828BD718;
	sub_82E81850(ctx, base);
	// 828BD718: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BD71C: 480A18E5  bl 0x8295f000
	ctx.lr = 0x828BD720;
	sub_8295F000(ctx, base);
	// 828BD720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BD724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD738 size=128
    let mut pc: u32 = 0x828BD738;
    'dispatch: loop {
        match pc {
            0x828BD738 => {
    //   block [0x828BD738..0x828BD7B8)
	// 828BD738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD744: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BD74C: 817F03A0  lwz r11, 0x3a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828BD750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BD754: 419A003C  beq cr6, 0x828bd790
	if ctx.cr[6].eq {
	pc = 0x828BD790; continue 'dispatch;
	}
	// 828BD758: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BD75C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BD760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD764: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BD768: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BD76C: C1AAC664  lfs f13, -0x399c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BD770: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828BD774: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828BD778: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828BD77C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828BD780: 485BE859  bl 0x82e7bfd8
	ctx.lr = 0x828BD784;
	sub_82E7BFD8(ctx, base);
	// 828BD784: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BD788: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828BD78C: 48555AD5  bl 0x82e13260
	ctx.lr = 0x828BD790;
	sub_82E13260(ctx, base);
	// 828BD790: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD798: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BD79C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD7A0: 4E800421  bctrl
	ctx.lr = 0x828BD7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD7A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD7A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD7AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD7B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD7B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD7B8 size=100
    let mut pc: u32 = 0x828BD7B8;
    'dispatch: loop {
        match pc {
            0x828BD7B8 => {
    //   block [0x828BD7B8..0x828BD81C)
	// 828BD7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD7C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD7C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD7C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BD7CC: 817F03A0  lwz r11, 0x3a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828BD7D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BD7D4: 419A0020  beq cr6, 0x828bd7f4
	if ctx.cr[6].eq {
	pc = 0x828BD7F4; continue 'dispatch;
	}
	// 828BD7D8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828BD7DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD7E0: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828BD7E4: 485BE7F5  bl 0x82e7bfd8
	ctx.lr = 0x828BD7E8;
	sub_82E7BFD8(ctx, base);
	// 828BD7E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD7EC: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828BD7F0: 48555A71  bl 0x82e13260
	ctx.lr = 0x828BD7F4;
	sub_82E13260(ctx, base);
	// 828BD7F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD7FC: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BD800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD804: 4E800421  bctrl
	ctx.lr = 0x828BD808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD808: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BD80C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD810: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD814: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD818: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD820 size=72
    let mut pc: u32 = 0x828BD820;
    'dispatch: loop {
        match pc {
            0x828BD820 => {
    //   block [0x828BD820..0x828BD868)
	// 828BD820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD828: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD82C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BD834: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828BD838: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BD83C: 419A0008  beq cr6, 0x828bd844
	if ctx.cr[6].eq {
	pc = 0x828BD844; continue 'dispatch;
	}
	// 828BD840: 480A1D11  bl 0x8295f550
	ctx.lr = 0x828BD844;
	sub_8295F550(ctx, base);
	// 828BD844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD848: 4BFFFE99  bl 0x828bd6e0
	ctx.lr = 0x828BD84C;
	sub_828BD6E0(ctx, base);
	// 828BD84C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD850: 997F03F8  stb r11, 0x3f8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u8 ) };
	// 828BD854: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BD858: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD85C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD860: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD868 size=196
    let mut pc: u32 = 0x828BD868;
    'dispatch: loop {
        match pc {
            0x828BD868 => {
    //   block [0x828BD868..0x828BD92C)
	// 828BD868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD87C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD880: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD884: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BD888: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD88C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD890: 4BA030A9  bl 0x822c0938
	ctx.lr = 0x828BD894;
	sub_822C0938(ctx, base);
	// 828BD894: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BD898: 41820028  beq 0x828bd8c0
	if ctx.cr[0].eq {
	pc = 0x828BD8C0; continue 'dispatch;
	}
	// 828BD89C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BD8A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BD8A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BD8A8: 392BC5D4  addi r9, r11, -0x3a2c
	ctx.r[9].s64 = ctx.r[11].s64 + -14892;
	// 828BD8AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BD8B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BD8B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BD8B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828BD8BC: 48000008  b 0x828bd8c4
	pc = 0x828BD8C4; continue 'dispatch;
	// 828BD8C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD8C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD8C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BD8CC: 409A0044  bne cr6, 0x828bd910
	if !ctx.cr[6].eq {
	pc = 0x828BD910; continue 'dispatch;
	}
	// 828BD8D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BD8D4: 419A001C  beq cr6, 0x828bd8f0
	if ctx.cr[6].eq {
	pc = 0x828BD8F0; continue 'dispatch;
	}
	// 828BD8D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BD8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD8E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD8EC: 4E800421  bctrl
	ctx.lr = 0x828BD8F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD8F0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD8F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BD8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD8FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828BD900: 816B341C  lwz r11, 0x341c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13340 as u32) ) } as u64;
	// 828BD904: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828BD908: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BD90C: 4BA026F5  bl 0x822c0000
	ctx.lr = 0x828BD910;
	sub_822C0000(ctx, base);
	// 828BD910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD91C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD920: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD924: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD930 size=196
    let mut pc: u32 = 0x828BD930;
    'dispatch: loop {
        match pc {
            0x828BD930 => {
    //   block [0x828BD930..0x828BD9F4)
	// 828BD930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD93C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD944: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD94C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BD950: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD954: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD958: 4BA02FE1  bl 0x822c0938
	ctx.lr = 0x828BD95C;
	sub_822C0938(ctx, base);
	// 828BD95C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BD960: 41820028  beq 0x828bd988
	if ctx.cr[0].eq {
	pc = 0x828BD988; continue 'dispatch;
	}
	// 828BD964: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BD968: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BD96C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BD970: 392BC5E8  addi r9, r11, -0x3a18
	ctx.r[9].s64 = ctx.r[11].s64 + -14872;
	// 828BD974: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BD978: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BD97C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BD980: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828BD984: 48000008  b 0x828bd98c
	pc = 0x828BD98C; continue 'dispatch;
	// 828BD988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BD98C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BD990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BD994: 409A0044  bne cr6, 0x828bd9d8
	if !ctx.cr[6].eq {
	pc = 0x828BD9D8; continue 'dispatch;
	}
	// 828BD998: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BD99C: 419A001C  beq cr6, 0x828bd9b8
	if ctx.cr[6].eq {
	pc = 0x828BD9B8; continue 'dispatch;
	}
	// 828BD9A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD9A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BD9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD9AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD9B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BD9B4: 4E800421  bctrl
	ctx.lr = 0x828BD9B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BD9B8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BD9BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BD9C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD9C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828BD9C8: 816B341C  lwz r11, 0x341c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13340 as u32) ) } as u64;
	// 828BD9CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828BD9D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BD9D4: 4BA0262D  bl 0x822c0000
	ctx.lr = 0x828BD9D8;
	sub_822C0000(ctx, base);
	// 828BD9D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD9DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BD9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD9E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD9EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD9F8 size=196
    let mut pc: u32 = 0x828BD9F8;
    'dispatch: loop {
        match pc {
            0x828BD9F8 => {
    //   block [0x828BD9F8..0x828BDABC)
	// 828BD9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD9FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDA00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BDA04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BDA08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDA0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BDA10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BDA14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BDA18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BDA1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDA20: 4BA02F19  bl 0x822c0938
	ctx.lr = 0x828BDA24;
	sub_822C0938(ctx, base);
	// 828BDA24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BDA28: 41820028  beq 0x828bda50
	if ctx.cr[0].eq {
	pc = 0x828BDA50; continue 'dispatch;
	}
	// 828BDA2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDA30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BDA34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BDA38: 392BC5FC  addi r9, r11, -0x3a04
	ctx.r[9].s64 = ctx.r[11].s64 + -14852;
	// 828BDA3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BDA40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BDA44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BDA48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828BDA4C: 48000008  b 0x828bda54
	pc = 0x828BDA54; continue 'dispatch;
	// 828BDA50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BDA54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDA5C: 409A0044  bne cr6, 0x828bdaa0
	if !ctx.cr[6].eq {
	pc = 0x828BDAA0; continue 'dispatch;
	}
	// 828BDA60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BDA64: 419A001C  beq cr6, 0x828bda80
	if ctx.cr[6].eq {
	pc = 0x828BDA80; continue 'dispatch;
	}
	// 828BDA68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDA6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BDA70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BDA74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDA78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BDA7C: 4E800421  bctrl
	ctx.lr = 0x828BDA80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BDA80: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BDA84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BDA88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDA8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828BDA90: 816B341C  lwz r11, 0x341c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13340 as u32) ) } as u64;
	// 828BDA94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828BDA98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BDA9C: 4BA02565  bl 0x822c0000
	ctx.lr = 0x828BDAA0;
	sub_822C0000(ctx, base);
	// 828BDAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BDAA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BDAA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDAAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDAB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BDAB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDAB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDAC0 size=196
    let mut pc: u32 = 0x828BDAC0;
    'dispatch: loop {
        match pc {
            0x828BDAC0 => {
    //   block [0x828BDAC0..0x828BDB84)
	// 828BDAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BDACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BDAD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDAD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BDAD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BDADC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BDAE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BDAE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDAE8: 4BA02E51  bl 0x822c0938
	ctx.lr = 0x828BDAEC;
	sub_822C0938(ctx, base);
	// 828BDAEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BDAF0: 41820028  beq 0x828bdb18
	if ctx.cr[0].eq {
	pc = 0x828BDB18; continue 'dispatch;
	}
	// 828BDAF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDAF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BDAFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BDB00: 392BC610  addi r9, r11, -0x39f0
	ctx.r[9].s64 = ctx.r[11].s64 + -14832;
	// 828BDB04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BDB08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BDB0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BDB10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828BDB14: 48000008  b 0x828bdb1c
	pc = 0x828BDB1C; continue 'dispatch;
	// 828BDB18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BDB1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDB24: 409A0044  bne cr6, 0x828bdb68
	if !ctx.cr[6].eq {
	pc = 0x828BDB68; continue 'dispatch;
	}
	// 828BDB28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BDB2C: 419A001C  beq cr6, 0x828bdb48
	if ctx.cr[6].eq {
	pc = 0x828BDB48; continue 'dispatch;
	}
	// 828BDB30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDB34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828BDB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BDB3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDB40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BDB44: 4E800421  bctrl
	ctx.lr = 0x828BDB48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BDB48: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BDB4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BDB50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDB54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828BDB58: 816B341C  lwz r11, 0x341c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13340 as u32) ) } as u64;
	// 828BDB5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828BDB60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BDB64: 4BA0249D  bl 0x822c0000
	ctx.lr = 0x828BDB68;
	sub_822C0000(ctx, base);
	// 828BDB68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BDB6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BDB70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDB74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDB78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BDB7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDB80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDB88 size=72
    let mut pc: u32 = 0x828BDB88;
    'dispatch: loop {
        match pc {
            0x828BDB88 => {
    //   block [0x828BDB88..0x828BDBD0)
	// 828BDB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDB90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDB94: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828BDB98: 419A001C  beq cr6, 0x828bdbb4
	if ctx.cr[6].eq {
	pc = 0x828BDBB4; continue 'dispatch;
	}
	// 828BDB9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BDBA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BDBA4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828BDBA8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BDBAC: 4BFFF835  bl 0x828bd3e0
	ctx.lr = 0x828BDBB0;
	sub_828BD3E0(ctx, base);
	// 828BDBB0: 48000010  b 0x828bdbc0
	pc = 0x828BDBC0; continue 'dispatch;
	// 828BDBB4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BDBB8: 396B3570  addi r11, r11, 0x3570
	ctx.r[11].s64 = ctx.r[11].s64 + 13680;
	// 828BDBBC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDBC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BDBC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDBC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDBCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDBD0 size=72
    let mut pc: u32 = 0x828BDBD0;
    'dispatch: loop {
        match pc {
            0x828BDBD0 => {
    //   block [0x828BDBD0..0x828BDC18)
	// 828BDBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDBD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDBDC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828BDBE0: 419A001C  beq cr6, 0x828bdbfc
	if ctx.cr[6].eq {
	pc = 0x828BDBFC; continue 'dispatch;
	}
	// 828BDBE4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BDBE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BDBEC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828BDBF0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BDBF4: 4BFFF865  bl 0x828bd458
	ctx.lr = 0x828BDBF8;
	sub_828BD458(ctx, base);
	// 828BDBF8: 48000010  b 0x828bdc08
	pc = 0x828BDC08; continue 'dispatch;
	// 828BDBFC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BDC00: 396B35C0  addi r11, r11, 0x35c0
	ctx.r[11].s64 = ctx.r[11].s64 + 13760;
	// 828BDC04: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDC08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BDC0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDC10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDC18 size=72
    let mut pc: u32 = 0x828BDC18;
    'dispatch: loop {
        match pc {
            0x828BDC18 => {
    //   block [0x828BDC18..0x828BDC60)
	// 828BDC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDC20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDC24: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828BDC28: 419A001C  beq cr6, 0x828bdc44
	if ctx.cr[6].eq {
	pc = 0x828BDC44; continue 'dispatch;
	}
	// 828BDC2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BDC30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BDC34: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828BDC38: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BDC3C: 4BFFF895  bl 0x828bd4d0
	ctx.lr = 0x828BDC40;
	sub_828BD4D0(ctx, base);
	// 828BDC40: 48000010  b 0x828bdc50
	pc = 0x828BDC50; continue 'dispatch;
	// 828BDC44: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BDC48: 396B3610  addi r11, r11, 0x3610
	ctx.r[11].s64 = ctx.r[11].s64 + 13840;
	// 828BDC4C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDC50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BDC54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDC58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDC5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDC60 size=376
    let mut pc: u32 = 0x828BDC60;
    'dispatch: loop {
        match pc {
            0x828BDC60 => {
    //   block [0x828BDC60..0x828BDDD8)
	// 828BDC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDC68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BDC6C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDC70: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDC78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BDC7C: 388BC64C  addi r4, r11, -0x39b4
	ctx.r[4].s64 = ctx.r[11].s64 + -14772;
	// 828BDC80: 48535D89  bl 0x82df3a08
	ctx.lr = 0x828BDC84;
	sub_82DF3A08(ctx, base);
	// 828BDC84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828BDC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDC8C: 388B24C0  addi r4, r11, 0x24c0
	ctx.r[4].s64 = ctx.r[11].s64 + 9408;
	// 828BDC90: 48535D79  bl 0x82df3a08
	ctx.lr = 0x828BDC94;
	sub_82DF3A08(ctx, base);
	// 828BDC94: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDC98: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 828BDC9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BDCA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BDCA4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDCA8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BDCAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BDCB0: 4E800421  bctrl
	ctx.lr = 0x828BDCB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BDCB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDCB8: 48535771  bl 0x82df3428
	ctx.lr = 0x828BDCBC;
	sub_82DF3428(ctx, base);
	// 828BDCBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BDCC0: 48535769  bl 0x82df3428
	ctx.lr = 0x828BDCC4;
	sub_82DF3428(ctx, base);
	// 828BDCC4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BDCC8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BDCCC: 386B0850  addi r3, r11, 0x850
	ctx.r[3].s64 = ctx.r[11].s64 + 2128;
	// 828BDCD0: 48005621  bl 0x828c32f0
	ctx.lr = 0x828BDCD4;
	sub_828C32F0(ctx, base);
	// 828BDCD4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BDCD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDCDC: 419A0008  beq cr6, 0x828bdce4
	if ctx.cr[6].eq {
	pc = 0x828BDCE4; continue 'dispatch;
	}
	// 828BDCE0: 4BA02BB1  bl 0x822c0890
	ctx.lr = 0x828BDCE4;
	sub_822C0890(ctx, base);
	// 828BDCE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDCE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDCEC: 388BC640  addi r4, r11, -0x39c0
	ctx.r[4].s64 = ctx.r[11].s64 + -14784;
	// 828BDCF0: 48535D19  bl 0x82df3a08
	ctx.lr = 0x828BDCF4;
	sub_82DF3A08(ctx, base);
	// 828BDCF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDCF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BDCFC: 388BC634  addi r4, r11, -0x39cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14796;
	// 828BDD00: 48535D09  bl 0x82df3a08
	ctx.lr = 0x828BDD04;
	sub_82DF3A08(ctx, base);
	// 828BDD04: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDD08: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BDD0C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828BDD10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BDD14: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDD18: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BDD1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BDD20: 4E800421  bctrl
	ctx.lr = 0x828BDD24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BDD24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BDD28: 48535701  bl 0x82df3428
	ctx.lr = 0x828BDD2C;
	sub_82DF3428(ctx, base);
	// 828BDD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDD30: 485356F9  bl 0x82df3428
	ctx.lr = 0x828BDD34;
	sub_82DF3428(ctx, base);
	// 828BDD34: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BDD38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BDD3C: 386B0968  addi r3, r11, 0x968
	ctx.r[3].s64 = ctx.r[11].s64 + 2408;
	// 828BDD40: 480055B1  bl 0x828c32f0
	ctx.lr = 0x828BDD44;
	sub_828C32F0(ctx, base);
	// 828BDD44: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BDD48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDD4C: 419A0008  beq cr6, 0x828bdd54
	if ctx.cr[6].eq {
	pc = 0x828BDD54; continue 'dispatch;
	}
	// 828BDD50: 4BA02B41  bl 0x822c0890
	ctx.lr = 0x828BDD54;
	sub_822C0890(ctx, base);
	// 828BDD54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDD5C: 388BC628  addi r4, r11, -0x39d8
	ctx.r[4].s64 = ctx.r[11].s64 + -14808;
	// 828BDD60: 48535CA9  bl 0x82df3a08
	ctx.lr = 0x828BDD64;
	sub_82DF3A08(ctx, base);
	// 828BDD64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDD68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BDD6C: 388BC620  addi r4, r11, -0x39e0
	ctx.r[4].s64 = ctx.r[11].s64 + -14816;
	// 828BDD70: 48535C99  bl 0x82df3a08
	ctx.lr = 0x828BDD74;
	sub_82DF3A08(ctx, base);
	// 828BDD74: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDD78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BDD7C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828BDD80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BDD84: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDD88: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BDD8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BDD90: 4E800421  bctrl
	ctx.lr = 0x828BDD94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BDD94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BDD98: 48535691  bl 0x82df3428
	ctx.lr = 0x828BDD9C;
	sub_82DF3428(ctx, base);
	// 828BDD9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDDA0: 48535689  bl 0x82df3428
	ctx.lr = 0x828BDDA4;
	sub_82DF3428(ctx, base);
	// 828BDDA4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BDDA8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828BDDAC: 386B0A80  addi r3, r11, 0xa80
	ctx.r[3].s64 = ctx.r[11].s64 + 2688;
	// 828BDDB0: 48005549  bl 0x828c32f8
	ctx.lr = 0x828BDDB4;
	sub_828C32F8(ctx, base);
	// 828BDDB4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BDDB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDDBC: 419A0008  beq cr6, 0x828bddc4
	if ctx.cr[6].eq {
	pc = 0x828BDDC4; continue 'dispatch;
	}
	// 828BDDC0: 4BA02AD1  bl 0x822c0890
	ctx.lr = 0x828BDDC4;
	sub_822C0890(ctx, base);
	// 828BDDC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BDDC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDDCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDDD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDDD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDDD8 size=244
    let mut pc: u32 = 0x828BDDD8;
    'dispatch: loop {
        match pc {
            0x828BDDD8 => {
    //   block [0x828BDDD8..0x828BDECC)
	// 828BDDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDDDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDDE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BDDE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BDDE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDDEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDDF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDDF4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BDDF8: 396BC834  addi r11, r11, -0x37cc
	ctx.r[11].s64 = ctx.r[11].s64 + -14284;
	// 828BDDFC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BDE00: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BDE04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDE08: 394AC674  addi r10, r10, -0x398c
	ctx.r[10].s64 = ctx.r[10].s64 + -14732;
	// 828BDE0C: 3929C65C  addi r9, r9, -0x39a4
	ctx.r[9].s64 = ctx.r[9].s64 + -14756;
	// 828BDE10: 3968C818  addi r11, r8, -0x37e8
	ctx.r[11].s64 = ctx.r[8].s64 + -14312;
	// 828BDE14: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BDE18: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BDE1C: 387F03CC  addi r3, r31, 0x3cc
	ctx.r[3].s64 = ctx.r[31].s64 + 972;
	// 828BDE20: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BDE24: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828BDE28: 48535601  bl 0x82df3428
	ctx.lr = 0x828BDE2C;
	sub_82DF3428(ctx, base);
	// 828BDE2C: 387F03C8  addi r3, r31, 0x3c8
	ctx.r[3].s64 = ctx.r[31].s64 + 968;
	// 828BDE30: 485355F9  bl 0x82df3428
	ctx.lr = 0x828BDE34;
	sub_82DF3428(ctx, base);
	// 828BDE34: 807F03C4  lwz r3, 0x3c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828BDE38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE3C: 419A0008  beq cr6, 0x828bde44
	if ctx.cr[6].eq {
	pc = 0x828BDE44; continue 'dispatch;
	}
	// 828BDE40: 4BA02A51  bl 0x822c0890
	ctx.lr = 0x828BDE44;
	sub_822C0890(ctx, base);
	// 828BDE44: 807F03BC  lwz r3, 0x3bc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828BDE48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE4C: 419A0008  beq cr6, 0x828bde54
	if ctx.cr[6].eq {
	pc = 0x828BDE54; continue 'dispatch;
	}
	// 828BDE50: 4BA02A41  bl 0x822c0890
	ctx.lr = 0x828BDE54;
	sub_822C0890(ctx, base);
	// 828BDE54: 807F03B4  lwz r3, 0x3b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828BDE58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE5C: 419A0008  beq cr6, 0x828bde64
	if ctx.cr[6].eq {
	pc = 0x828BDE64; continue 'dispatch;
	}
	// 828BDE60: 4BA02A31  bl 0x822c0890
	ctx.lr = 0x828BDE64;
	sub_822C0890(ctx, base);
	// 828BDE64: 807F03AC  lwz r3, 0x3ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) } as u64;
	// 828BDE68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE6C: 419A0008  beq cr6, 0x828bde74
	if ctx.cr[6].eq {
	pc = 0x828BDE74; continue 'dispatch;
	}
	// 828BDE70: 4BA02A21  bl 0x822c0890
	ctx.lr = 0x828BDE74;
	sub_822C0890(ctx, base);
	// 828BDE74: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 828BDE78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE7C: 419A0008  beq cr6, 0x828bde84
	if ctx.cr[6].eq {
	pc = 0x828BDE84; continue 'dispatch;
	}
	// 828BDE80: 4BA02A11  bl 0x822c0890
	ctx.lr = 0x828BDE84;
	sub_822C0890(ctx, base);
	// 828BDE84: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 828BDE88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE8C: 419A0008  beq cr6, 0x828bde94
	if ctx.cr[6].eq {
	pc = 0x828BDE94; continue 'dispatch;
	}
	// 828BDE90: 4BA02A01  bl 0x822c0890
	ctx.lr = 0x828BDE94;
	sub_822C0890(ctx, base);
	// 828BDE94: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828BDE98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDE9C: 419A0008  beq cr6, 0x828bdea4
	if ctx.cr[6].eq {
	pc = 0x828BDEA4; continue 'dispatch;
	}
	// 828BDEA0: 4BA029F1  bl 0x822c0890
	ctx.lr = 0x828BDEA4;
	sub_822C0890(ctx, base);
	// 828BDEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BDEA8: 480A13F1  bl 0x8295f298
	ctx.lr = 0x828BDEAC;
	sub_8295F298(ctx, base);
	// 828BDEAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BDEB0: 4BEE97A9  bl 0x827a7658
	ctx.lr = 0x828BDEB4;
	sub_827A7658(ctx, base);
	// 828BDEB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BDEB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDEBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDEC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BDEC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BDED0 size=8
    let mut pc: u32 = 0x828BDED0;
    'dispatch: loop {
        match pc {
            0x828BDED0 => {
    //   block [0x828BDED0..0x828BDED8)
	// 828BDED0: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828BDED4: 480005DC  b 0x828be4b0
	sub_828BE4B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BDED8 size=8
    let mut pc: u32 = 0x828BDED8;
    'dispatch: loop {
        match pc {
            0x828BDED8 => {
    //   block [0x828BDED8..0x828BDEE0)
	// 828BDED8: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828BDEDC: 480005D4  b 0x828be4b0
	sub_828BE4B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BDEE0 size=8
    let mut pc: u32 = 0x828BDEE0;
    'dispatch: loop {
        match pc {
            0x828BDEE0 => {
    //   block [0x828BDEE0..0x828BDEE8)
	// 828BDEE0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828BDEE4: 480005CC  b 0x828be4b0
	sub_828BE4B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BDEE8 size=208
    let mut pc: u32 = 0x828BDEE8;
    'dispatch: loop {
        match pc {
            0x828BDEE8 => {
    //   block [0x828BDEE8..0x828BDFB8)
	// 828BDEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDEEC: 488EA281  bl 0x831a816c
	ctx.lr = 0x828BDEF0;
	sub_831A8130(ctx, base);
	// 828BDEF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDEF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BDEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDEFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BDF00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDF04: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 828BDF08: 48535B01  bl 0x82df3a08
	ctx.lr = 0x828BDF0C;
	sub_82DF3A08(ctx, base);
	// 828BDF0C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BDF10: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828BDF14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BDF18: 4BF2E2C1  bl 0x827ec1d8
	ctx.lr = 0x828BDF1C;
	sub_827EC1D8(ctx, base);
	// 828BDF1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BDF20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BDF24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BDF28: 48557109  bl 0x82e15030
	ctx.lr = 0x828BDF2C;
	sub_82E15030(ctx, base);
	// 828BDF2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BDF30: 485354F9  bl 0x82df3428
	ctx.lr = 0x828BDF34;
	sub_82DF3428(ctx, base);
	// 828BDF34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BDF38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDF3C: 419A004C  beq cr6, 0x828bdf88
	if ctx.cr[6].eq {
	pc = 0x828BDF88; continue 'dispatch;
	}
	// 828BDF40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDF44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BDF48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BDF4C: 4E800421  bctrl
	ctx.lr = 0x828BDF50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BDF50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BDF54: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BDF58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDF5C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BDF60: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BDF64: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828BDF68: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828BDF6C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828BDF70: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828BDF74: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828BDF78: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828BDF7C: 419A0030  beq cr6, 0x828bdfac
	if ctx.cr[6].eq {
	pc = 0x828BDFAC; continue 'dispatch;
	}
	// 828BDF80: 4BA02911  bl 0x822c0890
	ctx.lr = 0x828BDF84;
	sub_822C0890(ctx, base);
	// 828BDF84: 48000028  b 0x828bdfac
	pc = 0x828BDFAC; continue 'dispatch;
	// 828BDF88: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BDF8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BDF90: 419A0008  beq cr6, 0x828bdf98
	if ctx.cr[6].eq {
	pc = 0x828BDF98; continue 'dispatch;
	}
	// 828BDF94: 4BA028FD  bl 0x822c0890
	ctx.lr = 0x828BDF98;
	sub_822C0890(ctx, base);
	// 828BDF98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BDF9C: 481556E5  bl 0x82a13680
	ctx.lr = 0x828BDFA0;
	sub_82A13680(ctx, base);
	// 828BDFA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BDFA4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BDFB8 size=196
    let mut pc: u32 = 0x828BDFB8;
    'dispatch: loop {
        match pc {
            0x828BDFB8 => {
    //   block [0x828BDFB8..0x828BE07C)
	// 828BDFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDFBC: 488EA1B1  bl 0x831a816c
	ctx.lr = 0x828BDFC0;
	sub_831A8130(ctx, base);
	// 828BDFC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDFC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BDFC8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828BDFCC: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 828BDFD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BDFD4: 38CB5DCC  addi r6, r11, 0x5dcc
	ctx.r[6].s64 = ctx.r[11].s64 + 24012;
	// 828BDFD8: 38AAC8DC  addi r5, r10, -0x3724
	ctx.r[5].s64 = ctx.r[10].s64 + -14116;
	// 828BDFDC: 807D00F4  lwz r3, 0xf4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 828BDFE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828BDFE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BDFE8: 488EBF61  bl 0x831a9f48
	ctx.lr = 0x828BDFEC;
	sub_831A9F48(ctx, base);
	// 828BDFEC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828BDFF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BDFF4: 4805903D  bl 0x82917030
	ctx.lr = 0x828BDFF8;
	sub_82917030(ctx, base);
	// 828BDFF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BDFFC: 40820018  bne 0x828be014
	if !ctx.cr[0].eq {
	pc = 0x828BE014; continue 'dispatch;
	}
	// 828BE000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE004: 48058AFD  bl 0x82916b00
	ctx.lr = 0x828BE008;
	sub_82916B00(ctx, base);
	// 828BE008: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE00C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BE010: 41820008  beq 0x828be018
	if ctx.cr[0].eq {
	pc = 0x828BE018; continue 'dispatch;
	}
	// 828BE014: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BE018: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 828BE01C: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BE020: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BE024: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828BE028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE02C: 4BFFFEBD  bl 0x828bdee8
	ctx.lr = 0x828BE030;
	sub_828BDEE8(ctx, base);
	// 828BE030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BE034: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 828BE038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE03C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE080 size=144
    let mut pc: u32 = 0x828BE080;
    'dispatch: loop {
        match pc {
            0x828BE080 => {
    //   block [0x828BE080..0x828BE110)
	// 828BE080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE08C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE090: 81630270  lwz r11, 0x270(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(624 as u32) ) } as u64;
	// 828BE094: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BE098: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 828BE09C: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 828BE0A0: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 828BE0A4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE0A8: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 828BE0AC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE0B0: 911F0024  stw r8, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 828BE0B4: 13EB48C7  vcmpequd (lvx128) v31, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE110 size=64
    let mut pc: u32 = 0x828BE110;
    'dispatch: loop {
        match pc {
            0x828BE110 => {
    //   block [0x828BE110..0x828BE150)
	// 828BE110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE11C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE120: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BE124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BE128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE12C: 4BFFFDBD  bl 0x828bdee8
	ctx.lr = 0x828BE130;
	sub_828BDEE8(ctx, base);
	// 828BE130: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828BE134: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE150 size=8
    let mut pc: u32 = 0x828BE150;
    'dispatch: loop {
        match pc {
            0x828BE150 => {
    //   block [0x828BE150..0x828BE158)
	// 828BE150: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828BE154: 480009EC  b 0x828beb40
	sub_828BEB40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE158 size=8
    let mut pc: u32 = 0x828BE158;
    'dispatch: loop {
        match pc {
            0x828BE158 => {
    //   block [0x828BE158..0x828BE160)
	// 828BE158: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828BE15C: 480009E4  b 0x828beb40
	sub_828BEB40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE160 size=8
    let mut pc: u32 = 0x828BE160;
    'dispatch: loop {
        match pc {
            0x828BE160 => {
    //   block [0x828BE160..0x828BE168)
	// 828BE160: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828BE164: 480009DC  b 0x828beb40
	sub_828BEB40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE168 size=8
    let mut pc: u32 = 0x828BE168;
    'dispatch: loop {
        match pc {
            0x828BE168 => {
    //   block [0x828BE168..0x828BE170)
	// 828BE168: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828BE16C: 48000ACC  b 0x828bec38
	sub_828BEC38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE170 size=8
    let mut pc: u32 = 0x828BE170;
    'dispatch: loop {
        match pc {
            0x828BE170 => {
    //   block [0x828BE170..0x828BE178)
	// 828BE170: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828BE174: 48000AC4  b 0x828bec38
	sub_828BEC38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE178 size=8
    let mut pc: u32 = 0x828BE178;
    'dispatch: loop {
        match pc {
            0x828BE178 => {
    //   block [0x828BE178..0x828BE180)
	// 828BE178: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828BE17C: 48000ABC  b 0x828bec38
	sub_828BEC38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE180 size=112
    let mut pc: u32 = 0x828BE180;
    'dispatch: loop {
        match pc {
            0x828BE180 => {
    //   block [0x828BE180..0x828BE1F0)
	// 828BE180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE188: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE18C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE194: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BE198: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BE19C: 396BCEF4  addi r11, r11, -0x310c
	ctx.r[11].s64 = ctx.r[11].s64 + -12556;
	// 828BE1A0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BE1A4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BE1A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE1AC: 394ACD4C  addi r10, r10, -0x32b4
	ctx.r[10].s64 = ctx.r[10].s64 + -12980;
	// 828BE1B0: 3929CD34  addi r9, r9, -0x32cc
	ctx.r[9].s64 = ctx.r[9].s64 + -13004;
	// 828BE1B4: 3968CD18  addi r11, r8, -0x32e8
	ctx.r[11].s64 = ctx.r[8].s64 + -13032;
	// 828BE1B8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BE1BC: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BE1C0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BE1C4: 807F03F4  lwz r3, 0x3f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 828BE1C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE1CC: 419A0008  beq cr6, 0x828be1d4
	if ctx.cr[6].eq {
	pc = 0x828BE1D4; continue 'dispatch;
	}
	// 828BE1D0: 4BA026C1  bl 0x822c0890
	ctx.lr = 0x828BE1D4;
	sub_822C0890(ctx, base);
	// 828BE1D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE1D8: 4BFFFC01  bl 0x828bddd8
	ctx.lr = 0x828BE1DC;
	sub_828BDDD8(ctx, base);
	// 828BE1DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BE1E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE1E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE1E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE1F0 size=8
    let mut pc: u32 = 0x828BE1F0;
    'dispatch: loop {
        match pc {
            0x828BE1F0 => {
    //   block [0x828BE1F0..0x828BE1F8)
	// 828BE1F0: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828BE1F4: 48000B4C  b 0x828bed40
	sub_828BED40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE1F8 size=8
    let mut pc: u32 = 0x828BE1F8;
    'dispatch: loop {
        match pc {
            0x828BE1F8 => {
    //   block [0x828BE1F8..0x828BE200)
	// 828BE1F8: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828BE1FC: 48000B44  b 0x828bed40
	sub_828BED40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE200 size=8
    let mut pc: u32 = 0x828BE200;
    'dispatch: loop {
        match pc {
            0x828BE200 => {
    //   block [0x828BE200..0x828BE208)
	// 828BE200: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828BE204: 48000B3C  b 0x828bed40
	sub_828BED40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE208 size=128
    let mut pc: u32 = 0x828BE208;
    'dispatch: loop {
        match pc {
            0x828BE208 => {
    //   block [0x828BE208..0x828BE288)
	// 828BE208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE218: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE21C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BE220: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828BE224: 396B0A80  addi r11, r11, 0xa80
	ctx.r[11].s64 = ctx.r[11].s64 + 2688;
	// 828BE228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE22C: 388A3420  addi r4, r10, 0x3420
	ctx.r[4].s64 = ctx.r[10].s64 + 13344;
	// 828BE230: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE234: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828BE238: C00B0118  lfs f0, 0x118(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE23C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828BE240: 485BF211  bl 0x82e7d450
	ctx.lr = 0x828BE244;
	sub_82E7D450(ctx, base);
	// 828BE244: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828BE248: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE24C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BE250: 485BDAF9  bl 0x82e7bd48
	ctx.lr = 0x828BE254;
	sub_82E7BD48(ctx, base);
	// 828BE254: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BE258: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BE25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE260: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE288 size=84
    let mut pc: u32 = 0x828BE288;
    'dispatch: loop {
        match pc {
            0x828BE288 => {
    //   block [0x828BE288..0x828BE2DC)
	// 828BE288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE28C: 488E9EE1  bl 0x831a816c
	ctx.lr = 0x828BE290;
	sub_831A8130(ctx, base);
	// 828BE290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE294: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BE298: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BE29C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE2A0: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828BE2A4: 409A0008  bne cr6, 0x828be2ac
	if !ctx.cr[6].eq {
	pc = 0x828BE2AC; continue 'dispatch;
	}
	// 828BE2A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BE2AC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE2B0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828BE2B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE2B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE2BC: 4BFFF5AD  bl 0x828bd868
	ctx.lr = 0x828BE2C0;
	sub_828BD868(ctx, base);
	// 828BE2C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE2C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE2C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE2CC: 4BA01D35  bl 0x822c0000
	ctx.lr = 0x828BE2D0;
	sub_822C0000(ctx, base);
	// 828BE2D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BE2D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE2D8: 488E9EE4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE2E0 size=84
    let mut pc: u32 = 0x828BE2E0;
    'dispatch: loop {
        match pc {
            0x828BE2E0 => {
    //   block [0x828BE2E0..0x828BE334)
	// 828BE2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE2E4: 488E9E89  bl 0x831a816c
	ctx.lr = 0x828BE2E8;
	sub_831A8130(ctx, base);
	// 828BE2E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE2EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BE2F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BE2F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE2F8: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828BE2FC: 409A0008  bne cr6, 0x828be304
	if !ctx.cr[6].eq {
	pc = 0x828BE304; continue 'dispatch;
	}
	// 828BE300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BE304: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE308: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828BE30C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE314: 4BFFF61D  bl 0x828bd930
	ctx.lr = 0x828BE318;
	sub_828BD930(ctx, base);
	// 828BE318: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE31C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE324: 4BA01CDD  bl 0x822c0000
	ctx.lr = 0x828BE328;
	sub_822C0000(ctx, base);
	// 828BE328: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BE32C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE330: 488E9E8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE338 size=84
    let mut pc: u32 = 0x828BE338;
    'dispatch: loop {
        match pc {
            0x828BE338 => {
    //   block [0x828BE338..0x828BE38C)
	// 828BE338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE33C: 488E9E31  bl 0x831a816c
	ctx.lr = 0x828BE340;
	sub_831A8130(ctx, base);
	// 828BE340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE344: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BE348: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BE34C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE350: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828BE354: 409A0008  bne cr6, 0x828be35c
	if !ctx.cr[6].eq {
	pc = 0x828BE35C; continue 'dispatch;
	}
	// 828BE358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BE35C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE360: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828BE364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE368: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE36C: 4BFFF68D  bl 0x828bd9f8
	ctx.lr = 0x828BE370;
	sub_828BD9F8(ctx, base);
	// 828BE370: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE37C: 4BA01C85  bl 0x822c0000
	ctx.lr = 0x828BE380;
	sub_822C0000(ctx, base);
	// 828BE380: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BE384: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE388: 488E9E34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE390 size=72
    let mut pc: u32 = 0x828BE390;
    'dispatch: loop {
        match pc {
            0x828BE390 => {
    //   block [0x828BE390..0x828BE3D8)
	// 828BE390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE398: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE39C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828BE3A0: 419A001C  beq cr6, 0x828be3bc
	if ctx.cr[6].eq {
	pc = 0x828BE3BC; continue 'dispatch;
	}
	// 828BE3A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BE3A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BE3AC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828BE3B0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE3B4: 4BFFF195  bl 0x828bd548
	ctx.lr = 0x828BE3B8;
	sub_828BD548(ctx, base);
	// 828BE3B8: 48000010  b 0x828be3c8
	pc = 0x828BE3C8; continue 'dispatch;
	// 828BE3BC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BE3C0: 396B3660  addi r11, r11, 0x3660
	ctx.r[11].s64 = ctx.r[11].s64 + 13920;
	// 828BE3C4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE3C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BE3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE3D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE3D8 size=212
    let mut pc: u32 = 0x828BE3D8;
    'dispatch: loop {
        match pc {
            0x828BE3D8 => {
    //   block [0x828BE3D8..0x828BE4AC)
	// 828BE3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE3DC: 488E9D8D  bl 0x831a8168
	ctx.lr = 0x828BE3E0;
	sub_831A8130(ctx, base);
	// 828BE3E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE3E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828BE3EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BE3F0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828BE3F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BE3F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE3FC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828BE400: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BE404: 38C0001C  li r6, 0x1c
	ctx.r[6].s64 = 28;
	// 828BE408: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 828BE40C: 480A0F0D  bl 0x8295f318
	ctx.lr = 0x828BE410;
	sub_8295F318(ctx, base);
	// 828BE410: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BE414: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BE418: 396BC834  addi r11, r11, -0x37cc
	ctx.r[11].s64 = ctx.r[11].s64 + -14284;
	// 828BE41C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BE420: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BE424: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BE428: 394AC674  addi r10, r10, -0x398c
	ctx.r[10].s64 = ctx.r[10].s64 + -14732;
	// 828BE42C: 3929C65C  addi r9, r9, -0x39a4
	ctx.r[9].s64 = ctx.r[9].s64 + -14756;
	// 828BE430: 3968C818  addi r11, r8, -0x37e8
	ctx.r[11].s64 = ctx.r[8].s64 + -14312;
	// 828BE434: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BE438: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BE43C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BE440: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BE444: 387F03C8  addi r3, r31, 0x3c8
	ctx.r[3].s64 = ctx.r[31].s64 + 968;
	// 828BE448: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 828BE44C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BE450: 93DF0394  stw r30, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u32 ) };
	// 828BE454: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828BE458: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 828BE45C: 93DF03A0  stw r30, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[30].u32 ) };
	// 828BE460: 93DF03A4  stw r30, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[30].u32 ) };
	// 828BE464: 93DF03A8  stw r30, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[30].u32 ) };
	// 828BE468: 93DF03AC  stw r30, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[30].u32 ) };
	// 828BE46C: 93DF03B0  stw r30, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[30].u32 ) };
	// 828BE470: 93DF03B4  stw r30, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[30].u32 ) };
	// 828BE474: 93DF03B8  stw r30, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[30].u32 ) };
	// 828BE478: 93DF03BC  stw r30, 0x3bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[30].u32 ) };
	// 828BE47C: 93DF03C0  stw r30, 0x3c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), ctx.r[30].u32 ) };
	// 828BE480: 93DF03C4  stw r30, 0x3c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[30].u32 ) };
	// 828BE484: 48535585  bl 0x82df3a08
	ctx.lr = 0x828BE488;
	sub_82DF3A08(ctx, base);
	// 828BE488: 387F03CC  addi r3, r31, 0x3cc
	ctx.r[3].s64 = ctx.r[31].s64 + 972;
	// 828BE48C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BE490: 48535579  bl 0x82df3a08
	ctx.lr = 0x828BE494;
	sub_82DF3A08(ctx, base);
	// 828BE494: 93DF03D0  stw r30, 0x3d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), ctx.r[30].u32 ) };
	// 828BE498: 387F03D4  addi r3, r31, 0x3d4
	ctx.r[3].s64 = ctx.r[31].s64 + 980;
	// 828BE49C: 48004555  bl 0x828c29f0
	ctx.lr = 0x828BE4A0;
	sub_828C29F0(ctx, base);
	// 828BE4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE4A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BE4A8: 488E9D10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE4B0 size=76
    let mut pc: u32 = 0x828BE4B0;
    'dispatch: loop {
        match pc {
            0x828BE4B0 => {
    //   block [0x828BE4B0..0x828BE4FC)
	// 828BE4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE4B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE4BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE4C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE4C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE4CC: 4BFFF90D  bl 0x828bddd8
	ctx.lr = 0x828BE4D0;
	sub_828BDDD8(ctx, base);
	// 828BE4D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE4D4: 4182000C  beq 0x828be4e0
	if ctx.cr[0].eq {
	pc = 0x828BE4E0; continue 'dispatch;
	}
	// 828BE4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE4DC: 48533EFD  bl 0x82df23d8
	ctx.lr = 0x828BE4E0;
	sub_82DF23D8(ctx, base);
	// 828BE4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE4E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE4E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE4EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE4F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BE4F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE500 size=644
    let mut pc: u32 = 0x828BE500;
    'dispatch: loop {
        match pc {
            0x828BE500 => {
    //   block [0x828BE500..0x828BE784)
	// 828BE500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE504: 488E9C5D  bl 0x831a8160
	ctx.lr = 0x828BE508;
	sub_831A8130(ctx, base);
	// 828BE508: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE50C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BE510: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE514: 48084E45  bl 0x82943358
	ctx.lr = 0x828BE518;
	sub_82943358(ctx, base);
	// 828BE518: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828BE51C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BE520: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BE524: 3B8BCF58  addi r28, r11, -0x30a8
	ctx.r[28].s64 = ctx.r[11].s64 + -12456;
	// 828BE528: 38A00289  li r5, 0x289
	ctx.r[5].s64 = 649;
	// 828BE52C: C00A4C5C  lfs f0, 0x4c5c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(19548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BE534: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828BE538: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828BE53C: 4BA01E9D  bl 0x822c03d8
	ctx.lr = 0x828BE540;
	sub_822C03D8(ctx, base);
	// 828BE540: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BE544: 41820018  beq 0x828be55c
	if ctx.cr[0].eq {
	pc = 0x828BE55C; continue 'dispatch;
	}
	// 828BE548: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828BE54C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE550: 48084E39  bl 0x82943388
	ctx.lr = 0x828BE554;
	sub_82943388(ctx, base);
	// 828BE554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE558: 48000008  b 0x828be560
	pc = 0x828BE560; continue 'dispatch;
	// 828BE55C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BE560: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BE564: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE568: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE56C: 4BFB394D  bl 0x82871eb8
	ctx.lr = 0x828BE570;
	sub_82871EB8(ctx, base);
	// 828BE570: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE578: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE57C: 4BA01A85  bl 0x822c0000
	ctx.lr = 0x828BE580;
	sub_822C0000(ctx, base);
	// 828BE580: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BE584: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE588: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BE58C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828BE590: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BE594: 419A0024  beq cr6, 0x828be5b8
	if ctx.cr[6].eq {
	pc = 0x828BE5B8; continue 'dispatch;
	}
	// 828BE598: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828BE59C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BE5A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE5A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BE5A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BE5AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BE5B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE5B4: 4082FFE8  bne 0x828be59c
	if !ctx.cr[0].eq {
	pc = 0x828BE59C; continue 'dispatch;
	}
	// 828BE5B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BE5BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE5C0: 48081EF1  bl 0x829404b0
	ctx.lr = 0x828BE5C4;
	sub_829404B0(ctx, base);
	// 828BE5C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828BE5C8: 48082E69  bl 0x82941430
	ctx.lr = 0x828BE5CC;
	sub_82941430(ctx, base);
	// 828BE5CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828BE5D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828BE5D4: 3FA08208  lis r29, -0x7df8
	ctx.r[29].s64 = -2113404928;
	// 828BE5D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BE5DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BE5E0: C1AB6154  lfs f13, 0x6154(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24916 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BE5E4: 38A00291  li r5, 0x291
	ctx.r[5].s64 = 657;
	// 828BE5E8: C18A6150  lfs f12, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828BE5EC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828BE5F0: C01D614C  lfs f0, 0x614c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE5F4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828BE5F8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828BE5FC: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828BE600: 4BA01DD9  bl 0x822c03d8
	ctx.lr = 0x828BE604;
	sub_822C03D8(ctx, base);
	// 828BE604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BE608: 41820018  beq 0x828be620
	if ctx.cr[0].eq {
	pc = 0x828BE620; continue 'dispatch;
	}
	// 828BE60C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828BE610: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE614: 480838F5  bl 0x82941f08
	ctx.lr = 0x828BE618;
	sub_82941F08(ctx, base);
	// 828BE618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE61C: 48000008  b 0x828be624
	pc = 0x828BE624; continue 'dispatch;
	// 828BE620: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BE624: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BE628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE62C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE630: 4BFB4779  bl 0x82872da8
	ctx.lr = 0x828BE634;
	sub_82872DA8(ctx, base);
	// 828BE634: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE63C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE640: 4BA019C1  bl 0x822c0000
	ctx.lr = 0x828BE644;
	sub_822C0000(ctx, base);
	// 828BE644: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BE648: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE64C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828BE650: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BE654: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BE658: 419A0024  beq cr6, 0x828be67c
	if ctx.cr[6].eq {
	pc = 0x828BE67C; continue 'dispatch;
	}
	// 828BE65C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828BE660: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BE664: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE668: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BE66C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BE670: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BE674: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE678: 4082FFE8  bne 0x828be660
	if !ctx.cr[0].eq {
	pc = 0x828BE660; continue 'dispatch;
	}
	// 828BE67C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BE680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE684: 48081E2D  bl 0x829404b0
	ctx.lr = 0x828BE688;
	sub_829404B0(ctx, base);
	// 828BE688: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE68C: 48084265  bl 0x829428f0
	ctx.lr = 0x828BE690;
	sub_829428F0(ctx, base);
	// 828BE690: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BE694: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BE698: C01D614C  lfs f0, 0x614c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE69C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828BE6A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BE6A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BE6A8: 38A0029A  li r5, 0x29a
	ctx.r[5].s64 = 666;
	// 828BE6AC: C1ABC664  lfs f13, -0x399c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BE6B0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828BE6B4: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE6B8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828BE6BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828BE6C0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828BE6C4: 4BA01D15  bl 0x822c03d8
	ctx.lr = 0x828BE6C8;
	sub_822C03D8(ctx, base);
	// 828BE6C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BE6CC: 41820018  beq 0x828be6e4
	if ctx.cr[0].eq {
	pc = 0x828BE6E4; continue 'dispatch;
	}
	// 828BE6D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BE6D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE6D8: 48084249  bl 0x82942920
	ctx.lr = 0x828BE6DC;
	sub_82942920(ctx, base);
	// 828BE6DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE6E0: 48000008  b 0x828be6e8
	pc = 0x828BE6E8; continue 'dispatch;
	// 828BE6E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BE6E8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BE6EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE6F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE6F4: 4BFB388D  bl 0x82871f80
	ctx.lr = 0x828BE6F8;
	sub_82871F80(ctx, base);
	// 828BE6F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE6FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE700: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE704: 4BA018FD  bl 0x822c0000
	ctx.lr = 0x828BE708;
	sub_822C0000(ctx, base);
	// 828BE708: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BE70C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE710: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE714: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BE718: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BE71C: 419A0024  beq cr6, 0x828be740
	if ctx.cr[6].eq {
	pc = 0x828BE740; continue 'dispatch;
	}
	// 828BE720: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828BE724: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BE728: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE72C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BE730: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BE734: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BE738: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE73C: 4082FFE8  bne 0x828be724
	if !ctx.cr[0].eq {
	pc = 0x828BE724; continue 'dispatch;
	}
	// 828BE740: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BE744: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE748: 48081D69  bl 0x829404b0
	ctx.lr = 0x828BE74C;
	sub_829404B0(ctx, base);
	// 828BE74C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE750: 419A000C  beq cr6, 0x828be75c
	if ctx.cr[6].eq {
	pc = 0x828BE75C; continue 'dispatch;
	}
	// 828BE754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE758: 4BA02139  bl 0x822c0890
	ctx.lr = 0x828BE75C;
	sub_822C0890(ctx, base);
	// 828BE75C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828BE760: 419A000C  beq cr6, 0x828be76c
	if ctx.cr[6].eq {
	pc = 0x828BE76C; continue 'dispatch;
	}
	// 828BE764: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BE768: 4BA02129  bl 0x822c0890
	ctx.lr = 0x828BE76C;
	sub_822C0890(ctx, base);
	// 828BE76C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BE770: 419A000C  beq cr6, 0x828be77c
	if ctx.cr[6].eq {
	pc = 0x828BE77C; continue 'dispatch;
	}
	// 828BE774: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BE778: 4BA02119  bl 0x822c0890
	ctx.lr = 0x828BE77C;
	sub_822C0890(ctx, base);
	// 828BE77C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828BE780: 488E9A30  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE788 size=272
    let mut pc: u32 = 0x828BE788;
    'dispatch: loop {
        match pc {
            0x828BE788 => {
    //   block [0x828BE788..0x828BE898)
	// 828BE788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE798: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE79C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE7A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE7A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE7A8: 48083B69  bl 0x82942310
	ctx.lr = 0x828BE7AC;
	sub_82942310(ctx, base);
	// 828BE7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE7B0: 4BF2D9B1  bl 0x827ec160
	ctx.lr = 0x828BE7B4;
	sub_827EC160(ctx, base);
	// 828BE7B4: 4BF30F85  bl 0x827ef738
	ctx.lr = 0x828BE7B8;
	sub_827EF738(ctx, base);
	// 828BE7B8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828BE7BC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828BE7C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828BE7C4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BE7C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BE7CC: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BE7D0: 3888CF58  addi r4, r8, -0x30a8
	ctx.r[4].s64 = ctx.r[8].s64 + -12456;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE898 size=224
    let mut pc: u32 = 0x828BE898;
    'dispatch: loop {
        match pc {
            0x828BE898 => {
    //   block [0x828BE898..0x828BE978)
	// 828BE898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE89C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE8A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE8A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE8A8: 816303C0  lwz r11, 0x3c0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BE8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE8B0: 419A00B4  beq cr6, 0x828be964
	if ctx.cr[6].eq {
	pc = 0x828BE964; continue 'dispatch;
	}
	// 828BE8B4: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828BE8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE8BC: 480A091D  bl 0x8295f1d8
	ctx.lr = 0x828BE8C0;
	sub_8295F1D8(ctx, base);
	// 828BE8C0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BE8C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE8C8: 808B3864  lwz r4, 0x3864(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14436 as u32) ) } as u64;
	// 828BE8CC: 4853513D  bl 0x82df3a08
	ctx.lr = 0x828BE8D0;
	sub_82DF3A08(ctx, base);
	// 828BE8D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BE8D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE8D8: 4BF37599  bl 0x827f5e70
	ctx.lr = 0x828BE8DC;
	sub_827F5E70(ctx, base);
	// 828BE8DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BE8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE8E4: 480A0AF5  bl 0x8295f3d8
	ctx.lr = 0x828BE8E8;
	sub_8295F3D8(ctx, base);
	// 828BE8E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BE8EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE8F0: 419A0008  beq cr6, 0x828be8f8
	if ctx.cr[6].eq {
	pc = 0x828BE8F8; continue 'dispatch;
	}
	// 828BE8F4: 4BA01F9D  bl 0x822c0890
	ctx.lr = 0x828BE8F8;
	sub_822C0890(ctx, base);
	// 828BE8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE8FC: 48534B2D  bl 0x82df3428
	ctx.lr = 0x828BE900;
	sub_82DF3428(ctx, base);
	// 828BE900: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BE904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE908: 808B39EC  lwz r4, 0x39ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14828 as u32) ) } as u64;
	// 828BE90C: 485350FD  bl 0x82df3a08
	ctx.lr = 0x828BE910;
	sub_82DF3A08(ctx, base);
	// 828BE910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BE914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE918: 480A0AC9  bl 0x8295f3e0
	ctx.lr = 0x828BE91C;
	sub_8295F3E0(ctx, base);
	// 828BE91C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE920: 48534B09  bl 0x82df3428
	ctx.lr = 0x828BE924;
	sub_82DF3428(ctx, base);
	// 828BE924: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BE928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE92C: 808B3868  lwz r4, 0x3868(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14440 as u32) ) } as u64;
	// 828BE930: 485350D9  bl 0x82df3a08
	ctx.lr = 0x828BE934;
	sub_82DF3A08(ctx, base);
	// 828BE934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BE938: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE93C: 4BF37535  bl 0x827f5e70
	ctx.lr = 0x828BE940;
	sub_827F5E70(ctx, base);
	// 828BE940: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BE944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE948: 480A0A91  bl 0x8295f3d8
	ctx.lr = 0x828BE94C;
	sub_8295F3D8(ctx, base);
	// 828BE94C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE954: 419A0008  beq cr6, 0x828be95c
	if ctx.cr[6].eq {
	pc = 0x828BE95C; continue 'dispatch;
	}
	// 828BE958: 4BA01F39  bl 0x822c0890
	ctx.lr = 0x828BE95C;
	sub_822C0890(ctx, base);
	// 828BE95C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE960: 48534AC9  bl 0x82df3428
	ctx.lr = 0x828BE964;
	sub_82DF3428(ctx, base);
	// 828BE964: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BE968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE96C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE978 size=184
    let mut pc: u32 = 0x828BE978;
    'dispatch: loop {
        match pc {
            0x828BE978 => {
    //   block [0x828BE978..0x828BEA30)
	// 828BE978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE984: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE98C: 817F03D0  lwz r11, 0x3d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 828BE990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE994: 409A0088  bne cr6, 0x828bea1c
	if !ctx.cr[6].eq {
	pc = 0x828BEA1C; continue 'dispatch;
	}
	// 828BE998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE99C: 4BF47F95  bl 0x82806930
	ctx.lr = 0x828BE9A0;
	sub_82806930(ctx, base);
	// 828BE9A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BE9A4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE9AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BE9B0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828BE9B4: 419A0024  beq cr6, 0x828be9d8
	if ctx.cr[6].eq {
	pc = 0x828BE9D8; continue 'dispatch;
	}
	// 828BE9B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BE9BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BE9C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE9C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BE9C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BE9CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BE9D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BE9D4: 4082FFE8  bne 0x828be9bc
	if !ctx.cr[0].eq {
	pc = 0x828BE9BC; continue 'dispatch;
	}
	// 828BE9D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828BE9DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BE9E0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BE9E4: 4BF2E68D  bl 0x827ed070
	ctx.lr = 0x828BE9E8;
	sub_827ED070(ctx, base);
	// 828BE9E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BE9EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE9F0: 419A0008  beq cr6, 0x828be9f8
	if ctx.cr[6].eq {
	pc = 0x828BE9F8; continue 'dispatch;
	}
	// 828BE9F4: 4BA01E9D  bl 0x822c0890
	ctx.lr = 0x828BE9F8;
	sub_822C0890(ctx, base);
	// 828BE9F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE9FC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 828BEA00: 4874A5B9  bl 0x83008fb8
	ctx.lr = 0x828BEA04;
	sub_83008FB8(ctx, base);
	// 828BEA04: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BEA08: 907F03D0  stw r3, 0x3d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), ctx.r[3].u32 ) };
	// 828BEA0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA10: 419A000C  beq cr6, 0x828bea1c
	if ctx.cr[6].eq {
	pc = 0x828BEA1C; continue 'dispatch;
	}
	// 828BEA14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BEA18: 4BA01E79  bl 0x822c0890
	ctx.lr = 0x828BEA1C;
	sub_822C0890(ctx, base);
	// 828BEA1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BEA20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEA24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEA28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEA2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEA30 size=152
    let mut pc: u32 = 0x828BEA30;
    'dispatch: loop {
        match pc {
            0x828BEA30 => {
    //   block [0x828BEA30..0x828BEAC8)
	// 828BEA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEA34: 488E9739  bl 0x831a816c
	ctx.lr = 0x828BEA38;
	sub_831A8130(ctx, base);
	// 828BEA38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEA3C: 83E3039C  lwz r31, 0x39c(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(924 as u32) ) } as u64;
	// 828BEA40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BEA44: 83C30398  lwz r30, 0x398(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 828BEA48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BEA4C: 419A0024  beq cr6, 0x828bea70
	if ctx.cr[6].eq {
	pc = 0x828BEA70; continue 'dispatch;
	}
	// 828BEA50: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828BEA54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BEA58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BEA5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BEA60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BEA64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BEA68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BEA6C: 4082FFE8  bne 0x828bea54
	if !ctx.cr[0].eq {
	pc = 0x828BEA54; continue 'dispatch;
	}
	// 828BEA70: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BEA74: 419A0038  beq cr6, 0x828beaac
	if ctx.cr[6].eq {
	pc = 0x828BEAAC; continue 'dispatch;
	}
	// 828BEA78: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828BEA7C: 4BF2E385  bl 0x827ece00
	ctx.lr = 0x828BEA80;
	sub_827ECE00(ctx, base);
	// 828BEA80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BEA84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BEA88: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEA8C: 48063605  bl 0x82922090
	ctx.lr = 0x828BEA90;
	sub_82922090(ctx, base);
	// 828BEA90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BEA94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BEA98: 419A000C  beq cr6, 0x828beaa4
	if ctx.cr[6].eq {
	pc = 0x828BEAA4; continue 'dispatch;
	}
	// 828BEA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEAA0: 4BA01DF1  bl 0x822c0890
	ctx.lr = 0x828BEAA4;
	sub_822C0890(ctx, base);
	// 828BEAA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BEAA8: 48000018  b 0x828beac0
	pc = 0x828BEAC0; continue 'dispatch;
	// 828BEAAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BEAB0: 419A000C  beq cr6, 0x828beabc
	if ctx.cr[6].eq {
	pc = 0x828BEABC; continue 'dispatch;
	}
	// 828BEAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEAB8: 4BA01DD9  bl 0x822c0890
	ctx.lr = 0x828BEABC;
	sub_822C0890(ctx, base);
	// 828BEABC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEAC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BEAC4: 488E96F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEAC8 size=120
    let mut pc: u32 = 0x828BEAC8;
    'dispatch: loop {
        match pc {
            0x828BEAC8 => {
    //   block [0x828BEAC8..0x828BEB40)
	// 828BEAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEAD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEAD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEAD8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BEADC: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828BEAE0: 394B33E0  addi r10, r11, 0x33e0
	ctx.r[10].s64 = ctx.r[11].s64 + 13280;
	// 828BEAE4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828BEAE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEAEC: 808B33E0  lwz r4, 0x33e0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13280 as u32) ) } as u64;
	// 828BEAF0: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEAF4: 4BFFF8E5  bl 0x828be3d8
	ctx.lr = 0x828BEAF8;
	sub_828BE3D8(ctx, base);
	// 828BEAF8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BEAFC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BEB00: 396BCA74  addi r11, r11, -0x358c
	ctx.r[11].s64 = ctx.r[11].s64 + -13708;
	// 828BEB04: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BEB08: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BEB0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BEB10: 394AC8CC  addi r10, r10, -0x3734
	ctx.r[10].s64 = ctx.r[10].s64 + -14132;
	// 828BEB14: 3929C8B4  addi r9, r9, -0x374c
	ctx.r[9].s64 = ctx.r[9].s64 + -14156;
	// 828BEB18: 3968C898  addi r11, r8, -0x3768
	ctx.r[11].s64 = ctx.r[8].s64 + -14184;
	// 828BEB1C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BEB20: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BEB24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEB28: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BEB2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BEB30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEB34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEB38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEB3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEB40 size=124
    let mut pc: u32 = 0x828BEB40;
    'dispatch: loop {
        match pc {
            0x828BEB40 => {
    //   block [0x828BEB40..0x828BEBBC)
	// 828BEB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEB48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BEB4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEB50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEB58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BEB5C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BEB60: 396BCA74  addi r11, r11, -0x358c
	ctx.r[11].s64 = ctx.r[11].s64 + -13708;
	// 828BEB64: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BEB68: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BEB6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BEB70: 394AC8CC  addi r10, r10, -0x3734
	ctx.r[10].s64 = ctx.r[10].s64 + -14132;
	// 828BEB74: 3929C8B4  addi r9, r9, -0x374c
	ctx.r[9].s64 = ctx.r[9].s64 + -14156;
	// 828BEB78: 3968C898  addi r11, r8, -0x3768
	ctx.r[11].s64 = ctx.r[8].s64 + -14184;
	// 828BEB7C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BEB80: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BEB84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BEB88: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BEB8C: 4BFFF24D  bl 0x828bddd8
	ctx.lr = 0x828BEB90;
	sub_828BDDD8(ctx, base);
	// 828BEB90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BEB94: 4182000C  beq 0x828beba0
	if ctx.cr[0].eq {
	pc = 0x828BEBA0; continue 'dispatch;
	}
	// 828BEB98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEB9C: 4853383D  bl 0x82df23d8
	ctx.lr = 0x828BEBA0;
	sub_82DF23D8(ctx, base);
	// 828BEBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEBA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BEBA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEBAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEBB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BEBB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEBC0 size=120
    let mut pc: u32 = 0x828BEBC0;
    'dispatch: loop {
        match pc {
            0x828BEBC0 => {
    //   block [0x828BEBC0..0x828BEC38)
	// 828BEBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEBD0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BEBD4: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828BEBD8: 396B33E0  addi r11, r11, 0x33e0
	ctx.r[11].s64 = ctx.r[11].s64 + 13280;
	// 828BEBDC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828BEBE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEBE4: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEBE8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEBEC: 4BFFF7ED  bl 0x828be3d8
	ctx.lr = 0x828BEBF0;
	sub_828BE3D8(ctx, base);
	// 828BEBF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BEBF4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BEBF8: 396BCCB4  addi r11, r11, -0x334c
	ctx.r[11].s64 = ctx.r[11].s64 + -13132;
	// 828BEBFC: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BEC00: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BEC04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BEC08: 394ACB0C  addi r10, r10, -0x34f4
	ctx.r[10].s64 = ctx.r[10].s64 + -13556;
	// 828BEC0C: 3929CAF4  addi r9, r9, -0x350c
	ctx.r[9].s64 = ctx.r[9].s64 + -13580;
	// 828BEC10: 3968CAD8  addi r11, r8, -0x3528
	ctx.r[11].s64 = ctx.r[8].s64 + -13608;
	// 828BEC14: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BEC18: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BEC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEC20: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BEC24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BEC28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEC2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEC30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEC34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEC38 size=124
    let mut pc: u32 = 0x828BEC38;
    'dispatch: loop {
        match pc {
            0x828BEC38 => {
    //   block [0x828BEC38..0x828BECB4)
	// 828BEC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEC3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEC40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BEC44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEC4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEC50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BEC54: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BEC58: 396BCCB4  addi r11, r11, -0x334c
	ctx.r[11].s64 = ctx.r[11].s64 + -13132;
	// 828BEC5C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BEC60: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BEC64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BEC68: 394ACB0C  addi r10, r10, -0x34f4
	ctx.r[10].s64 = ctx.r[10].s64 + -13556;
	// 828BEC6C: 3929CAF4  addi r9, r9, -0x350c
	ctx.r[9].s64 = ctx.r[9].s64 + -13580;
	// 828BEC70: 3968CAD8  addi r11, r8, -0x3528
	ctx.r[11].s64 = ctx.r[8].s64 + -13608;
	// 828BEC74: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BEC78: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BEC7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BEC80: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828BEC84: 4BFFF155  bl 0x828bddd8
	ctx.lr = 0x828BEC88;
	sub_828BDDD8(ctx, base);
	// 828BEC88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BEC8C: 4182000C  beq 0x828bec98
	if ctx.cr[0].eq {
	pc = 0x828BEC98; continue 'dispatch;
	}
	// 828BEC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEC94: 48533745  bl 0x82df23d8
	ctx.lr = 0x828BEC98;
	sub_82DF23D8(ctx, base);
	// 828BEC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEC9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BECA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BECA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BECA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BECAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BECB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BECB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BECB8 size=136
    let mut pc: u32 = 0x828BECB8;
    'dispatch: loop {
        match pc {
            0x828BECB8 => {
    //   block [0x828BECB8..0x828BED40)
	// 828BECB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BECBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BECC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BECC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BECC8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BECCC: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828BECD0: 396B33E0  addi r11, r11, 0x33e0
	ctx.r[11].s64 = ctx.r[11].s64 + 13280;
	// 828BECD4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828BECD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BECDC: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BECE0: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BECE4: 4BFFF6F5  bl 0x828be3d8
	ctx.lr = 0x828BECE8;
	sub_828BE3D8(ctx, base);
	// 828BECE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BECEC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BECF0: 396BCEF4  addi r11, r11, -0x310c
	ctx.r[11].s64 = ctx.r[11].s64 + -12556;
	// 828BECF4: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828BECF8: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828BECFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BED00: 394ACD4C  addi r10, r10, -0x32b4
	ctx.r[10].s64 = ctx.r[10].s64 + -12980;
	// 828BED04: 3929CD34  addi r9, r9, -0x32cc
	ctx.r[9].s64 = ctx.r[9].s64 + -13004;
	// 828BED08: 3908CD18  addi r8, r8, -0x32e8
	ctx.r[8].s64 = ctx.r[8].s64 + -13032;
	// 828BED0C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BED10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BED14: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828BED18: 911F0218  stw r8, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[8].u32 ) };
	// 828BED1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BED20: 917F03F0  stw r11, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[11].u32 ) };
	// 828BED24: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 828BED28: 997F03F8  stb r11, 0x3f8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u8 ) };
	// 828BED2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BED30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BED34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BED38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BED3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BED40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BED40 size=76
    let mut pc: u32 = 0x828BED40;
    'dispatch: loop {
        match pc {
            0x828BED40 => {
    //   block [0x828BED40..0x828BED8C)
	// 828BED40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BED44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BED48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BED4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BED50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BED54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BED58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BED5C: 4BFFF425  bl 0x828be180
	ctx.lr = 0x828BED60;
	sub_828BE180(ctx, base);
	// 828BED60: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BED64: 4182000C  beq 0x828bed70
	if ctx.cr[0].eq {
	pc = 0x828BED70; continue 'dispatch;
	}
	// 828BED68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BED6C: 4853366D  bl 0x82df23d8
	ctx.lr = 0x828BED70;
	sub_82DF23D8(ctx, base);
	// 828BED70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BED74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BED78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BED7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BED80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BED84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BED88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BED90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BED90 size=116
    let mut pc: u32 = 0x828BED90;
    'dispatch: loop {
        match pc {
            0x828BED90 => {
    //   block [0x828BED90..0x828BEE04)
	// 828BED90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BED94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BED98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BED9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEDA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEDA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEDA8: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828BEDAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEDB0: 419A003C  beq cr6, 0x828bedec
	if ctx.cr[6].eq {
	pc = 0x828BEDEC; continue 'dispatch;
	}
	// 828BEDB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEDB8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEDBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BEDC0: 4E800421  bctrl
	ctx.lr = 0x828BEDC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEDC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BEDC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BEDCC: 83FF03F0  lwz r31, 0x3f0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828BEDD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BEDD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEDD8: 4BFFF431  bl 0x828be208
	ctx.lr = 0x828BEDDC;
	sub_828BE208(ctx, base);
	// 828BEDDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828BEDE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEDE8: 480A0A39  bl 0x8295f820
	ctx.lr = 0x828BEDEC;
	sub_8295F820(ctx, base);
	// 828BEDEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BEDF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEDF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEDF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BEDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BEE08 size=88
    let mut pc: u32 = 0x828BEE08;
    'dispatch: loop {
        match pc {
            0x828BEE08 => {
    //   block [0x828BEE08..0x828BEE60)
	// 828BEE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEE10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BEE14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEE18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEE20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BEE24: 897F03E8  lbz r11, 0x3e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 828BEE28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BEE2C: 41820010  beq 0x828bee3c
	if ctx.cr[0].eq {
	pc = 0x828BEE3C; continue 'dispatch;
	}
	// 828BEE30: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 828BEE34: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BEE38: 4BFFFF59  bl 0x828bed90
	ctx.lr = 0x828BEE3C;
	sub_828BED90(ctx, base);
	// 828BEE3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEE44: 4BFFE78D  bl 0x828bd5d0
	ctx.lr = 0x828BEE48;
	sub_828BD5D0(ctx, base);
	// 828BEE48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BEE4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEE50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEE54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BEE58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEE60 size=112
    let mut pc: u32 = 0x828BEE60;
    'dispatch: loop {
        match pc {
            0x828BEE60 => {
    //   block [0x828BEE60..0x828BEED0)
	// 828BEE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEE64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEE68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BEE6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEE70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEE74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BEE78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEE7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BEE80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEE84: 4BFFEC3D  bl 0x828bdac0
	ctx.lr = 0x828BEE88;
	sub_828BDAC0(ctx, base);
	// 828BEE88: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BEE8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEE90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEE94: 4BA0116D  bl 0x822c0000
	ctx.lr = 0x828BEE98;
	sub_822C0000(ctx, base);
	// 828BEE98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BEE9C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BEEA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BEEA4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEEAC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BEEB0: 419A0008  beq cr6, 0x828beeb8
	if ctx.cr[6].eq {
	pc = 0x828BEEB8; continue 'dispatch;
	}
	// 828BEEB4: 4BA019DD  bl 0x822c0890
	ctx.lr = 0x828BEEB8;
	sub_822C0890(ctx, base);
	// 828BEEB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BEEBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BEEC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BEEC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BEEC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BEECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BEED0 size=304
    let mut pc: u32 = 0x828BEED0;
    'dispatch: loop {
        match pc {
            0x828BEED0 => {
    //   block [0x828BEED0..0x828BF000)
	// 828BEED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEED4: 488E9295  bl 0x831a8168
	ctx.lr = 0x828BEED8;
	sub_831A8130(ctx, base);
	// 828BEED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEEDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BEEE0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BEEE4: 3BFD03B0  addi r31, r29, 0x3b0
	ctx.r[31].s64 = ctx.r[29].s64 + 944;
	// 828BEEE8: 817D03B0  lwz r11, 0x3b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(944 as u32) ) } as u64;
	// 828BEEEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEEF0: 419A004C  beq cr6, 0x828bef3c
	if ctx.cr[6].eq {
	pc = 0x828BEF3C; continue 'dispatch;
	}
	// 828BEEF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEEF8: 4BC4BA59  bl 0x8250a950
	ctx.lr = 0x828BEEFC;
	sub_8250A950(ctx, base);
	// 828BEEFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEF00: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BEF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEF08: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 828BEF0C: 409A0008  bne cr6, 0x828bef14
	if !ctx.cr[6].eq {
	pc = 0x828BEF14; continue 'dispatch;
	}
	// 828BEF10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BEF14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BEF18: 4BF14AE9  bl 0x827d3a00
	ctx.lr = 0x828BEF1C;
	sub_827D3A00(ctx, base);
	// 828BEF1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEF20: 48532D71  bl 0x82df1c90
	ctx.lr = 0x828BEF24;
	sub_82DF1C90(ctx, base);
	// 828BEF24: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828BEF28: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEF2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEF30: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BEF34: 419A0008  beq cr6, 0x828bef3c
	if ctx.cr[6].eq {
	pc = 0x828BEF3C; continue 'dispatch;
	}
	// 828BEF38: 4BA01959  bl 0x822c0890
	ctx.lr = 0x828BEF3C;
	sub_822C0890(ctx, base);
	// 828BEF3C: 807D03A8  lwz r3, 0x3a8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(936 as u32) ) } as u64;
	// 828BEF40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEF44: 419A0018  beq cr6, 0x828bef5c
	if ctx.cr[6].eq {
	pc = 0x828BEF5C; continue 'dispatch;
	}
	// 828BEF48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEF4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BEF50: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BEF54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BEF58: 4E800421  bctrl
	ctx.lr = 0x828BEF5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEF5C: 817D03C0  lwz r11, 0x3c0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BEF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEF64: 419A0088  beq cr6, 0x828befec
	if ctx.cr[6].eq {
	pc = 0x828BEFEC; continue 'dispatch;
	}
	// 828BEF68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEF6C: 4BD190E5  bl 0x825d8050
	ctx.lr = 0x828BEF70;
	sub_825D8050(ctx, base);
	// 828BEF70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEF74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BEF78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEF80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BEF84: 419A0024  beq cr6, 0x828befa8
	if ctx.cr[6].eq {
	pc = 0x828BEFA8; continue 'dispatch;
	}
	// 828BEF88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BEF8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BEF90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BEF94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BEF98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BEF9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BEFA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BEFA4: 4082FFE8  bne 0x828bef8c
	if !ctx.cr[0].eq {
	pc = 0x828BEF8C; continue 'dispatch;
	}
	// 828BEFA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BEFAC: 80DD03C0  lwz r6, 0x3c0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BEFB0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BEFB4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828BEFB8: 388ACF58  addi r4, r10, -0x30a8
	ctx.r[4].s64 = ctx.r[10].s64 + -12456;
	// 828BEFBC: 38A00226  li r5, 0x226
	ctx.r[5].s64 = 550;
	// 828BEFC0: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 828BEFC4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BEFC8: 48599A79  bl 0x82e58a40
	ctx.lr = 0x828BEFCC;
	sub_82E58A40(ctx, base);
	// 828BEFCC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BEFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEFD4: 419A0008  beq cr6, 0x828befdc
	if ctx.cr[6].eq {
	pc = 0x828BEFDC; continue 'dispatch;
	}
	// 828BEFD8: 4BA018B9  bl 0x822c0890
	ctx.lr = 0x828BEFDC;
	sub_822C0890(ctx, base);
	// 828BEFDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BEFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEFE4: 419A0008  beq cr6, 0x828befec
	if ctx.cr[6].eq {
	pc = 0x828BEFEC; continue 'dispatch;
	}
	// 828BEFE8: 4BA018A9  bl 0x822c0890
	ctx.lr = 0x828BEFEC;
	sub_822C0890(ctx, base);
	// 828BEFEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BEFF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BEFF4: 480A0245  bl 0x8295f238
	ctx.lr = 0x828BEFF8;
	sub_8295F238(ctx, base);
	// 828BEFF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BEFFC: 488E91BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF000 size=588
    let mut pc: u32 = 0x828BF000;
    'dispatch: loop {
        match pc {
            0x828BF000 => {
    //   block [0x828BF000..0x828BF24C)
	// 828BF000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF004: 488E9159  bl 0x831a815c
	ctx.lr = 0x828BF008;
	sub_831A8130(ctx, base);
	// 828BF008: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 828BF00C: 488E9A6D  bl 0x831a8a78
	ctx.lr = 0x828BF010;
	sub_831A8A40(ctx, base);
	// 828BF010: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF018: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 828BF01C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BF020: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828BF024: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BF028: 815F03A0  lwz r10, 0x3a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828BF02C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828BF030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF034: 419A0158  beq cr6, 0x828bf18c
	if ctx.cr[6].eq {
	pc = 0x828BF18C; continue 'dispatch;
	}
	// 828BF038: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF03C: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 828BF040: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828BF044: C3EB010C  lfs f31, 0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BF048: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 828BF04C: C3CB0110  lfs f30, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828BF050: C3AB0114  lfs f29, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828BF054: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF058: 485E16D9  bl 0x82ea0730
	ctx.lr = 0x828BF05C;
	sub_82EA0730(ctx, base);
	// 828BF05C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828BF060: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828BF064: 396B2B30  addi r11, r11, 0x2b30
	ctx.r[11].s64 = ctx.r[11].s64 + 11056;
	// 828BF068: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 828BF06C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828BF070: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828BF074: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 828BF078: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BF07C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BF080: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828BF084: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF250 size=624
    let mut pc: u32 = 0x828BF250;
    'dispatch: loop {
        match pc {
            0x828BF250 => {
    //   block [0x828BF250..0x828BF4C0)
	// 828BF250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF254: 488E8F09  bl 0x831a815c
	ctx.lr = 0x828BF258;
	sub_831A8130(ctx, base);
	// 828BF258: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828BF25C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828BF260: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF264: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BF268: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BF26C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BF270: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BF274: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828BF278: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BF27C: 388BCF58  addi r4, r11, -0x30a8
	ctx.r[4].s64 = ctx.r[11].s64 + -12456;
	// 828BF280: 38A00249  li r5, 0x249
	ctx.r[5].s64 = 585;
	// 828BF284: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828BF288: 4BA01151  bl 0x822c03d8
	ctx.lr = 0x828BF28C;
	sub_822C03D8(ctx, base);
	// 828BF28C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828BF290: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BF294: 3B6B4A98  addi r27, r11, 0x4a98
	ctx.r[27].s64 = ctx.r[11].s64 + 19096;
	// 828BF298: 41820030  beq 0x828bf2c8
	if ctx.cr[0].eq {
	pc = 0x828BF2C8; continue 'dispatch;
	}
	// 828BF29C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BF2A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF2A4: 48534765  bl 0x82df3a08
	ctx.lr = 0x828BF2A8;
	sub_82DF3A08(ctx, base);
	// 828BF2A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BF2AC: 38BA03D4  addi r5, r26, 0x3d4
	ctx.r[5].s64 = ctx.r[26].s64 + 980;
	// 828BF2B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BF2B8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828BF2BC: 4BCED155  bl 0x825ac410
	ctx.lr = 0x828BF2C0;
	sub_825AC410(ctx, base);
	// 828BF2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF2C4: 48000008  b 0x828bf2cc
	pc = 0x828BF2CC; continue 'dispatch;
	// 828BF2C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BF2CC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828BF2D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BF2D4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BF2D8: 4BC340E1  bl 0x824f33b8
	ctx.lr = 0x828BF2DC;
	sub_824F33B8(ctx, base);
	// 828BF2DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BF2E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BF2E4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BF2E8: 4BA00D19  bl 0x822c0000
	ctx.lr = 0x828BF2EC;
	sub_822C0000(ctx, base);
	// 828BF2EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF2F0: 4182000C  beq 0x828bf2fc
	if ctx.cr[0].eq {
	pc = 0x828BF2FC; continue 'dispatch;
	}
	// 828BF2F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF2F8: 48534131  bl 0x82df3428
	ctx.lr = 0x828BF2FC;
	sub_82DF3428(ctx, base);
	// 828BF2FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BF300: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF304: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BF308: 3BABC550  addi r29, r11, -0x3ab0
	ctx.r[29].s64 = ctx.r[11].s64 + -15024;
	// 828BF30C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828BF310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF314: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF318: 485346F1  bl 0x82df3a08
	ctx.lr = 0x828BF31C;
	sub_82DF3A08(ctx, base);
	// 828BF31C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BF320: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BF324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BF328: 4BCECA99  bl 0x825abdc0
	ctx.lr = 0x828BF32C;
	sub_825ABDC0(ctx, base);
	// 828BF32C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF330: 485340F9  bl 0x82df3428
	ctx.lr = 0x828BF334;
	sub_82DF3428(ctx, base);
	// 828BF334: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828BF338: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 828BF33C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BF340: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828BF344: 4198FFCC  blt cr6, 0x828bf310
	if ctx.cr[6].lt {
	pc = 0x828BF310; continue 'dispatch;
	}
	// 828BF348: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BF34C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF350: 485346B9  bl 0x82df3a08
	ctx.lr = 0x828BF354;
	sub_82DF3A08(ctx, base);
	// 828BF354: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BF358: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828BF35C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF360: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828BF364: 419A0024  beq cr6, 0x828bf388
	if ctx.cr[6].eq {
	pc = 0x828BF388; continue 'dispatch;
	}
	// 828BF368: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828BF36C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BF370: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BF374: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BF378: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BF37C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BF380: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BF384: 4082FFE8  bne 0x828bf36c
	if !ctx.cr[0].eq {
	pc = 0x828BF36C; continue 'dispatch;
	}
	// 828BF388: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BF38C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF390: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF394: 4BCE2D7D  bl 0x825a2110
	ctx.lr = 0x828BF398;
	sub_825A2110(ctx, base);
	// 828BF398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF39C: 4853408D  bl 0x82df3428
	ctx.lr = 0x828BF3A0;
	sub_82DF3428(ctx, base);
	// 828BF3A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF3A4: 419A000C  beq cr6, 0x828bf3b0
	if ctx.cr[6].eq {
	pc = 0x828BF3B0; continue 'dispatch;
	}
	// 828BF3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BF3AC: 4BA014E5  bl 0x822c0890
	ctx.lr = 0x828BF3B0;
	sub_822C0890(ctx, base);
	// 828BF3B0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828BF3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF3B8: 388BEDA0  addi r4, r11, -0x1260
	ctx.r[4].s64 = ctx.r[11].s64 + -4704;
	// 828BF3BC: 4853464D  bl 0x82df3a08
	ctx.lr = 0x828BF3C0;
	sub_82DF3A08(ctx, base);
	// 828BF3C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BF3C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BF3C8: 389A03D8  addi r4, r26, 0x3d8
	ctx.r[4].s64 = ctx.r[26].s64 + 984;
	// 828BF3CC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828BF3D0: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BF3D4: C3CA08AC  lfs f30, 0x8ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2220 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828BF3D8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828BF3DC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828BF3E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BF3E4: 4BCE3DCD  bl 0x825a31b0
	ctx.lr = 0x828BF3E8;
	sub_825A31B0(ctx, base);
	// 828BF3E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828BF3EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF3F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF3F4: 4BCE237D  bl 0x825a1770
	ctx.lr = 0x828BF3F8;
	sub_825A1770(ctx, base);
	// 828BF3F8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828BF3FC: 4853402D  bl 0x82df3428
	ctx.lr = 0x828BF400;
	sub_82DF3428(ctx, base);
	// 828BF400: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828BF404: 4BA098B5  bl 0x822c8cb8
	ctx.lr = 0x828BF408;
	sub_822C8CB8(ctx, base);
	// 828BF408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF40C: 4853401D  bl 0x82df3428
	ctx.lr = 0x828BF410;
	sub_82DF3428(ctx, base);
	// 828BF410: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828BF414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF418: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 828BF41C: 485345ED  bl 0x82df3a08
	ctx.lr = 0x828BF420;
	sub_82DF3A08(ctx, base);
	// 828BF420: 389A03DC  addi r4, r26, 0x3dc
	ctx.r[4].s64 = ctx.r[26].s64 + 988;
	// 828BF424: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BF428: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828BF42C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828BF430: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BF434: 4BCE3D7D  bl 0x825a31b0
	ctx.lr = 0x828BF438;
	sub_825A31B0(ctx, base);
	// 828BF438: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828BF43C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF440: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF444: 4BCE232D  bl 0x825a1770
	ctx.lr = 0x828BF448;
	sub_825A1770(ctx, base);
	// 828BF448: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828BF44C: 48533FDD  bl 0x82df3428
	ctx.lr = 0x828BF450;
	sub_82DF3428(ctx, base);
	// 828BF450: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828BF454: 4BA09865  bl 0x822c8cb8
	ctx.lr = 0x828BF458;
	sub_822C8CB8(ctx, base);
	// 828BF458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF45C: 48533FCD  bl 0x82df3428
	ctx.lr = 0x828BF460;
	sub_82DF3428(ctx, base);
	// 828BF460: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828BF464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF468: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 828BF46C: 4853459D  bl 0x82df3a08
	ctx.lr = 0x828BF470;
	sub_82DF3A08(ctx, base);
	// 828BF470: 389A03E0  addi r4, r26, 0x3e0
	ctx.r[4].s64 = ctx.r[26].s64 + 992;
	// 828BF474: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828BF478: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828BF47C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828BF480: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828BF484: 4BCE3D2D  bl 0x825a31b0
	ctx.lr = 0x828BF488;
	sub_825A31B0(ctx, base);
	// 828BF488: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828BF48C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF490: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF494: 4BCE22DD  bl 0x825a1770
	ctx.lr = 0x828BF498;
	sub_825A1770(ctx, base);
	// 828BF498: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828BF49C: 48533F8D  bl 0x82df3428
	ctx.lr = 0x828BF4A0;
	sub_82DF3428(ctx, base);
	// 828BF4A0: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828BF4A4: 4BA09815  bl 0x822c8cb8
	ctx.lr = 0x828BF4A8;
	sub_822C8CB8(ctx, base);
	// 828BF4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF4AC: 48533F7D  bl 0x82df3428
	ctx.lr = 0x828BF4B0;
	sub_82DF3428(ctx, base);
	// 828BF4B0: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 828BF4B4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828BF4B8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828BF4BC: 488E8CF0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF4C0 size=460
    let mut pc: u32 = 0x828BF4C0;
    'dispatch: loop {
        match pc {
            0x828BF4C0 => {
    //   block [0x828BF4C0..0x828BF68C)
	// 828BF4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF4C4: 488E8C89  bl 0x831a814c
	ctx.lr = 0x828BF4C8;
	sub_831A8130(ctx, base);
	// 828BF4C8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF4CC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828BF4D0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828BF4D4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BF4D8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF4DC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828BF4E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF4E4: 409A01A0  bne cr6, 0x828bf684
	if !ctx.cr[6].eq {
	pc = 0x828BF684; continue 'dispatch;
	}
	// 828BF4E8: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828BF4EC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828BF4F0: 3BCB0800  addi r30, r11, 0x800
	ctx.r[30].s64 = ctx.r[11].s64 + 2048;
	// 828BF4F4: 816A0810  lwz r11, 0x810(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2064 as u32) ) } as u64;
	// 828BF4F8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828BF4FC: 4082001C  bne 0x828bf518
	if !ctx.cr[0].eq {
	pc = 0x828BF518; continue 'dispatch;
	}
	// 828BF500: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828BF504: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828BF508: 3929BC40  addi r9, r9, -0x43c0
	ctx.r[9].s64 = ctx.r[9].s64 + -17344;
	// 828BF50C: 916A0810  stw r11, 0x810(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2064 as u32), ctx.r[11].u32 ) };
	// 828BF510: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF690 size=256
    let mut pc: u32 = 0x828BF690;
    'dispatch: loop {
        match pc {
            0x828BF690 => {
    //   block [0x828BF690..0x828BF790)
	// 828BF690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF694: 488E8AD9  bl 0x831a816c
	ctx.lr = 0x828BF698;
	sub_831A8130(ctx, base);
	// 828BF698: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF69C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF6A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BF6A4: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828BF6A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF6AC: 480497AD  bl 0x82908e58
	ctx.lr = 0x828BF6B0;
	sub_82908E58(ctx, base);
	// 828BF6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BF6B4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BF6B8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828BF6BC: 409900CC  ble cr6, 0x828bf788
	if !ctx.cr[6].gt {
	pc = 0x828BF788; continue 'dispatch;
	}
	// 828BF6C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BF6C4: 4BFFF1D5  bl 0x828be898
	ctx.lr = 0x828BF6C8;
	sub_828BE898(ctx, base);
	// 828BF6C8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828BF6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF6D0: 808B39F0  lwz r4, 0x39f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14832 as u32) ) } as u64;
	// 828BF6D4: 48534335  bl 0x82df3a08
	ctx.lr = 0x828BF6D8;
	sub_82DF3A08(ctx, base);
	// 828BF6D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF6DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF6E0: 4809FD01  bl 0x8295f3e0
	ctx.lr = 0x828BF6E4;
	sub_8295F3E0(ctx, base);
	// 828BF6E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF6E8: 48533D41  bl 0x82df3428
	ctx.lr = 0x828BF6EC;
	sub_82DF3428(ctx, base);
	// 828BF6EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BF6F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF6F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BF6F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BF6FC: 4BFA8DBD  bl 0x828684b8
	ctx.lr = 0x828BF700;
	sub_828684B8(ctx, base);
	// 828BF700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF704: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828BF708: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF710: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BF714: 419A0024  beq cr6, 0x828bf738
	if ctx.cr[6].eq {
	pc = 0x828BF738; continue 'dispatch;
	}
	// 828BF718: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BF71C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BF720: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BF724: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BF728: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BF72C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BF730: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BF734: 4082FFE8  bne 0x828bf71c
	if !ctx.cr[0].eq {
	pc = 0x828BF71C; continue 'dispatch;
	}
	// 828BF738: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BF73C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828BF740: 487489E9  bl 0x83008128
	ctx.lr = 0x828BF744;
	sub_83008128(ctx, base);
	// 828BF744: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BF748: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BF74C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828BF750: 388ACF58  addi r4, r10, -0x30a8
	ctx.r[4].s64 = ctx.r[10].s64 + -12456;
	// 828BF754: 38A003A1  li r5, 0x3a1
	ctx.r[5].s64 = 929;
	// 828BF758: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828BF75C: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BF760: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828BF764: 485992DD  bl 0x82e58a40
	ctx.lr = 0x828BF768;
	sub_82E58A40(ctx, base);
	// 828BF768: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BF76C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BF770: 419A0008  beq cr6, 0x828bf778
	if ctx.cr[6].eq {
	pc = 0x828BF778; continue 'dispatch;
	}
	// 828BF774: 4BA0111D  bl 0x822c0890
	ctx.lr = 0x828BF778;
	sub_822C0890(ctx, base);
	// 828BF778: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BF77C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BF780: 419A0008  beq cr6, 0x828bf788
	if ctx.cr[6].eq {
	pc = 0x828BF788; continue 'dispatch;
	}
	// 828BF784: 4BA0110D  bl 0x822c0890
	ctx.lr = 0x828BF788;
	sub_822C0890(ctx, base);
	// 828BF788: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF78C: 488E8A30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF790 size=728
    let mut pc: u32 = 0x828BF790;
    'dispatch: loop {
        match pc {
            0x828BF790 => {
    //   block [0x828BF790..0x828BFA68)
	// 828BF790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF794: 488E89C5  bl 0x831a8158
	ctx.lr = 0x828BF798;
	sub_831A8130(ctx, base);
	// 828BF798: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828BF79C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF7A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BF7A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BF7A8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BF7AC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BF7B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF7B4: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 828BF7B8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828BF7BC: 4853424D  bl 0x82df3a08
	ctx.lr = 0x828BF7C0;
	sub_82DF3A08(ctx, base);
	// 828BF7C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BF7C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF7C8: 4BFFF269  bl 0x828bea30
	ctx.lr = 0x828BF7CC;
	sub_828BEA30(ctx, base);
	// 828BF7CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BF7D0: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828BF7D4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828BF7D8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BF7DC: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828BF7E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BF7E4: 418200E4  beq 0x828bf8c8
	if ctx.cr[0].eq {
	pc = 0x828BF8C8; continue 'dispatch;
	}
	// 828BF7E8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828BF7EC: 4BF2D615  bl 0x827ece00
	ctx.lr = 0x828BF7F0;
	sub_827ECE00(ctx, base);
	// 828BF7F0: 485339C1  bl 0x82df31b0
	ctx.lr = 0x828BF7F4;
	sub_82DF31B0(ctx, base);
	// 828BF7F4: 817A0B70  lwz r11, 0xb70(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828BF7F8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF7FC: 89230000  lbz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF800: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BF804: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828BF808: 41820014  beq 0x828bf81c
	if ctx.cr[0].eq {
	pc = 0x828BF81C; continue 'dispatch;
	}
	// 828BF80C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BF810: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828BF814: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BF818: 419AFFE0  beq cr6, 0x828bf7f8
	if ctx.cr[6].eq {
	pc = 0x828BF7F8; continue 'dispatch;
	}
	// 828BF81C: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BF820: 4082005C  bne 0x828bf87c
	if !ctx.cr[0].eq {
	pc = 0x828BF87C; continue 'dispatch;
	}
	// 828BF824: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BF828: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BF82C: 4BC4FC9D  bl 0x8250f4c8
	ctx.lr = 0x828BF830;
	sub_8250F4C8(ctx, base);
	// 828BF830: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF838: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828BF83C: 409A0008  bne cr6, 0x828bf844
	if !ctx.cr[6].eq {
	pc = 0x828BF844; continue 'dispatch;
	}
	// 828BF840: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BF844: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BF848: 4BC491D1  bl 0x82508a18
	ctx.lr = 0x828BF84C;
	sub_82508A18(ctx, base);
	// 828BF84C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828BF850: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF854: 487488D5  bl 0x83008128
	ctx.lr = 0x828BF858;
	sub_83008128(ctx, base);
	// 828BF858: 7D781850  subf r11, r24, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[24].s64;
	// 828BF85C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BF860: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828BF864: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828BF868: 69780001  xori r24, r11, 1
	ctx.r[24].u64 = ctx.r[11].u64 ^ 1;
	// 828BF86C: 48532425  bl 0x82df1c90
	ctx.lr = 0x828BF870;
	sub_82DF1C90(ctx, base);
	// 828BF870: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF874: 41820008  beq 0x828bf87c
	if ctx.cr[0].eq {
	pc = 0x828BF87C; continue 'dispatch;
	}
	// 828BF878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BF87C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828BF880: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828BF884: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828BF888: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF88C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF890: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BF894: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828BF898: 41820014  beq 0x828bf8ac
	if ctx.cr[0].eq {
	pc = 0x828BF8AC; continue 'dispatch;
	}
	// 828BF89C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BF8A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BF8A4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828BF8A8: 419AFFE0  beq cr6, 0x828bf888
	if ctx.cr[6].eq {
	pc = 0x828BF888; continue 'dispatch;
	}
	// 828BF8AC: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828BF8B0: 40820008  bne 0x828bf8b8
	if !ctx.cr[0].eq {
	pc = 0x828BF8B8; continue 'dispatch;
	}
	// 828BF8B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BF8B8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF8BC: 41820028  beq 0x828bf8e4
	if ctx.cr[0].eq {
	pc = 0x828BF8E4; continue 'dispatch;
	}
	// 828BF8C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF8C4: 48000018  b 0x828bf8dc
	pc = 0x828BF8DC; continue 'dispatch;
	// 828BF8C8: 48049591  bl 0x82908e58
	ctx.lr = 0x828BF8CC;
	sub_82908E58(ctx, base);
	// 828BF8CC: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828BF8D0: 40990014  ble cr6, 0x828bf8e4
	if !ctx.cr[6].gt {
	pc = 0x828BF8E4; continue 'dispatch;
	}
	// 828BF8D4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828BF8D8: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828BF8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF8E0: 48533F99  bl 0x82df3878
	ctx.lr = 0x828BF8E4;
	sub_82DF3878(ctx, base);
	// 828BF8E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF8E8: 485342C1  bl 0x82df3ba8
	ctx.lr = 0x828BF8EC;
	sub_82DF3BA8(ctx, base);
	// 828BF8EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF8F0: 40820164  bne 0x828bfa54
	if !ctx.cr[0].eq {
	pc = 0x828BFA54; continue 'dispatch;
	}
	// 828BF8F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BF8F8: 4BF2C869  bl 0x827ec160
	ctx.lr = 0x828BF8FC;
	sub_827EC160(ctx, base);
	// 828BF8FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BF900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BF904: 48057495  bl 0x82916d98
	ctx.lr = 0x828BF908;
	sub_82916D98(ctx, base);
	// 828BF908: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828BF90C: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF910: 394000E0  li r10, 0xe0
	ctx.r[10].s64 = 224;
	// 828BF914: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 828BF918: 390000D0  li r8, 0xd0
	ctx.r[8].s64 = 208;
	// 828BF91C: 13FB58C7  vcmpequd (lvx128) v31, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BFA68 size=272
    let mut pc: u32 = 0x828BFA68;
    'dispatch: loop {
        match pc {
            0x828BFA68 => {
    //   block [0x828BFA68..0x828BFB78)
	// 828BFA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BFA70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BFA74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BFA78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BFA80: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BFA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFA88: 419A00AC  beq cr6, 0x828bfb34
	if ctx.cr[6].eq {
	pc = 0x828BFB34; continue 'dispatch;
	}
	// 828BFA8C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828BFA90: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828BFA94: C00B6218  lfs f0, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BFA98: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828BFA9C: 48153BE5  bl 0x82a13680
	ctx.lr = 0x828BFAA0;
	sub_82A13680(ctx, base);
	// 828BFAA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFAA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BFAA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BFAAC: 4BF488D5  bl 0x82808380
	ctx.lr = 0x828BFAB0;
	sub_82808380(ctx, base);
	// 828BFAB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFAB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828BFAB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFAC0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BFAC4: 419A0024  beq cr6, 0x828bfae8
	if ctx.cr[6].eq {
	pc = 0x828BFAE8; continue 'dispatch;
	}
	// 828BFAC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BFACC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828BFAD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BFAD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828BFAD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828BFADC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BFAE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BFAE4: 4082FFE8  bne 0x828bfacc
	if !ctx.cr[0].eq {
	pc = 0x828BFACC; continue 'dispatch;
	}
	// 828BFAE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BFAEC: 80DF03C0  lwz r6, 0x3c0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828BFAF0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BFAF4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828BFAF8: 388ACF58  addi r4, r10, -0x30a8
	ctx.r[4].s64 = ctx.r[10].s64 + -12456;
	// 828BFAFC: 38A0042A  li r5, 0x42a
	ctx.r[5].s64 = 1066;
	// 828BFB00: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828BFB04: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BFB08: 48598F39  bl 0x82e58a40
	ctx.lr = 0x828BFB0C;
	sub_82E58A40(ctx, base);
	// 828BFB0C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BFB10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BFB14: 419A0008  beq cr6, 0x828bfb1c
	if ctx.cr[6].eq {
	pc = 0x828BFB1C; continue 'dispatch;
	}
	// 828BFB18: 4BA00D79  bl 0x822c0890
	ctx.lr = 0x828BFB1C;
	sub_822C0890(ctx, base);
	// 828BFB1C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BFB20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BFB24: 419A0008  beq cr6, 0x828bfb2c
	if ctx.cr[6].eq {
	pc = 0x828BFB2C; continue 'dispatch;
	}
	// 828BFB28: 4BA00D69  bl 0x822c0890
	ctx.lr = 0x828BFB2C;
	sub_822C0890(ctx, base);
	// 828BFB2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BFB30: 917F03C0  stw r11, 0x3c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), ctx.r[11].u32 ) };
	// 828BFB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFB38: 48153B49  bl 0x82a13680
	ctx.lr = 0x828BFB3C;
	sub_82A13680(ctx, base);
	// 828BFB3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BFB40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFB48: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BFB4C: 4804D14D  bl 0x8290cc98
	ctx.lr = 0x828BFB50;
	sub_8290CC98(ctx, base);
	// 828BFB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFB54: 480491D5  bl 0x82908d28
	ctx.lr = 0x828BFB58;
	sub_82908D28(ctx, base);
	// 828BFB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFB5C: 4BC50A75  bl 0x825105d0
	ctx.lr = 0x828BFB60;
	sub_825105D0(ctx, base);
	// 828BFB60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BFB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BFB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BFB6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BFB70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BFB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFB78 size=100
    let mut pc: u32 = 0x828BFB78;
    'dispatch: loop {
        match pc {
            0x828BFB78 => {
    //   block [0x828BFB78..0x828BFBDC)
	// 828BFB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFB7C: 488E85F1  bl 0x831a816c
	ctx.lr = 0x828BFB80;
	sub_831A8130(ctx, base);
	// 828BFB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFB84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BFB88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BFB8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BFB90: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828BFB94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BFB98: 388BCF58  addi r4, r11, -0x30a8
	ctx.r[4].s64 = ctx.r[11].s64 + -12456;
	// 828BFB9C: 38A00470  li r5, 0x470
	ctx.r[5].s64 = 1136;
	// 828BFBA0: 386003F0  li r3, 0x3f0
	ctx.r[3].s64 = 1008;
	// 828BFBA4: 48532845  bl 0x82df23e8
	ctx.lr = 0x828BFBA8;
	sub_82DF23E8(ctx, base);
	// 828BFBA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BFBAC: 41820018  beq 0x828bfbc4
	if ctx.cr[0].eq {
	pc = 0x828BFBC4; continue 'dispatch;
	}
	// 828BFBB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BFBB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFBB8: 4BFFEF11  bl 0x828beac8
	ctx.lr = 0x828BFBBC;
	sub_828BEAC8(ctx, base);
	// 828BFBBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFBC0: 48000008  b 0x828bfbc8
	pc = 0x828BFBC8; continue 'dispatch;
	// 828BFBC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BFBC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BFBCC: 4BFFE6BD  bl 0x828be288
	ctx.lr = 0x828BFBD0;
	sub_828BE288(ctx, base);
	// 828BFBD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BFBD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BFBD8: 488E85E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFBE0 size=100
    let mut pc: u32 = 0x828BFBE0;
    'dispatch: loop {
        match pc {
            0x828BFBE0 => {
    //   block [0x828BFBE0..0x828BFC44)
	// 828BFBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFBE4: 488E8589  bl 0x831a816c
	ctx.lr = 0x828BFBE8;
	sub_831A8130(ctx, base);
	// 828BFBE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFBEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BFBF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BFBF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BFBF8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828BFBFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BFC00: 388BCF58  addi r4, r11, -0x30a8
	ctx.r[4].s64 = ctx.r[11].s64 + -12456;
	// 828BFC04: 38A004C5  li r5, 0x4c5
	ctx.r[5].s64 = 1221;
	// 828BFC08: 386003F0  li r3, 0x3f0
	ctx.r[3].s64 = 1008;
	// 828BFC0C: 485327DD  bl 0x82df23e8
	ctx.lr = 0x828BFC10;
	sub_82DF23E8(ctx, base);
	// 828BFC10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BFC14: 41820018  beq 0x828bfc2c
	if ctx.cr[0].eq {
	pc = 0x828BFC2C; continue 'dispatch;
	}
	// 828BFC18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BFC1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFC20: 4BFFEFA1  bl 0x828bebc0
	ctx.lr = 0x828BFC24;
	sub_828BEBC0(ctx, base);
	// 828BFC24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFC28: 48000008  b 0x828bfc30
	pc = 0x828BFC30; continue 'dispatch;
	// 828BFC2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BFC30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BFC34: 4BFFE6AD  bl 0x828be2e0
	ctx.lr = 0x828BFC38;
	sub_828BE2E0(ctx, base);
	// 828BFC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BFC3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BFC40: 488E857C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFC48 size=100
    let mut pc: u32 = 0x828BFC48;
    'dispatch: loop {
        match pc {
            0x828BFC48 => {
    //   block [0x828BFC48..0x828BFCAC)
	// 828BFC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFC4C: 488E8521  bl 0x831a816c
	ctx.lr = 0x828BFC50;
	sub_831A8130(ctx, base);
	// 828BFC50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFC54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BFC58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BFC5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BFC60: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828BFC64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BFC68: 388BCF58  addi r4, r11, -0x30a8
	ctx.r[4].s64 = ctx.r[11].s64 + -12456;
	// 828BFC6C: 38A0051D  li r5, 0x51d
	ctx.r[5].s64 = 1309;
	// 828BFC70: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	// 828BFC74: 48532775  bl 0x82df23e8
	ctx.lr = 0x828BFC78;
	sub_82DF23E8(ctx, base);
	// 828BFC78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828BFC7C: 41820018  beq 0x828bfc94
	if ctx.cr[0].eq {
	pc = 0x828BFC94; continue 'dispatch;
	}
	// 828BFC80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BFC84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFC88: 4BFFF031  bl 0x828becb8
	ctx.lr = 0x828BFC8C;
	sub_828BECB8(ctx, base);
	// 828BFC8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFC90: 48000008  b 0x828bfc98
	pc = 0x828BFC98; continue 'dispatch;
	// 828BFC94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BFC98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BFC9C: 4BFFE69D  bl 0x828be338
	ctx.lr = 0x828BFCA0;
	sub_828BE338(ctx, base);
	// 828BFCA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BFCA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BFCA8: 488E8514  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFCB0 size=156
    let mut pc: u32 = 0x828BFCB0;
    'dispatch: loop {
        match pc {
            0x828BFCB0 => {
    //   block [0x828BFCB0..0x828BFD4C)
	// 828BFCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFCB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BFCB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BFCBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BFCC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFCC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BFCC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BFCCC: 4809F8CD  bl 0x8295f598
	ctx.lr = 0x828BFCD0;
	sub_8295F598(ctx, base);
	// 828BFCD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BFCD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BFCD8: 480570C1  bl 0x82916d98
	ctx.lr = 0x828BFCDC;
	sub_82916D98(ctx, base);
	// 828BFCDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BFCE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFCE4: 419A003C  beq cr6, 0x828bfd20
	if ctx.cr[6].eq {
	pc = 0x828BFD20; continue 'dispatch;
	}
	// 828BFCE8: 816B00F4  lwz r11, 0xf4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 828BFCEC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828BFCF0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFCF4: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 828BFCF8: 9169001C  stw r11, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828BFCFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BFD00: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 828BFD04: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFD08: 91690020  stw r11, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 828BFD0C: 816A85E4  lwz r11, -0x7a1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31260 as u32) ) } as u64;
	// 828BFD10: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFD14: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828BFD18: 81686818  lwz r11, 0x6818(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26648 as u32) ) } as u64;
	// 828BFD1C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BFD20: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BFD24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BFD28: 419A0008  beq cr6, 0x828bfd30
	if ctx.cr[6].eq {
	pc = 0x828BFD30; continue 'dispatch;
	}
	// 828BFD2C: 4BA00B65  bl 0x822c0890
	ctx.lr = 0x828BFD30;
	sub_822C0890(ctx, base);
	// 828BFD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFD34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BFD38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BFD3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BFD40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BFD44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BFD48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFD50 size=184
    let mut pc: u32 = 0x828BFD50;
    'dispatch: loop {
        match pc {
            0x828BFD50 => {
    //   block [0x828BFD50..0x828BFE08)
	// 828BFD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BFD58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BFD5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BFD60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFD64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BFD68: 817E03F0  lwz r11, 0x3f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828BFD6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFD70: 419A0070  beq cr6, 0x828bfde0
	if ctx.cr[6].eq {
	pc = 0x828BFDE0; continue 'dispatch;
	}
	// 828BFD74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828BFD78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BFD7C: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 828BFD80: 48533C89  bl 0x82df3a08
	ctx.lr = 0x828BFD84;
	sub_82DF3A08(ctx, base);
	// 828BFD84: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828BFD88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFD8C: 4BF2C3D5  bl 0x827ec160
	ctx.lr = 0x828BFD90;
	sub_827EC160(ctx, base);
	// 828BFD90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFD94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BFD98: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 828BFD9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BFDA0: 4E800421  bctrl
	ctx.lr = 0x828BFDA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BFDA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BFDA8: 48533681  bl 0x82df3428
	ctx.lr = 0x828BFDAC;
	sub_82DF3428(ctx, base);
	// 828BFDAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFDB0: 83FE03F0  lwz r31, 0x3f0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828BFDB4: 4BF2C3AD  bl 0x827ec160
	ctx.lr = 0x828BFDB8;
	sub_827EC160(ctx, base);
	// 828BFDB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFDBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BFDC0: 4BFFFEF1  bl 0x828bfcb0
	ctx.lr = 0x828BFDC4;
	sub_828BFCB0(ctx, base);
	// 828BFDC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFDC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFDCC: 4809F6DD  bl 0x8295f4a8
	ctx.lr = 0x828BFDD0;
	sub_8295F4A8(ctx, base);
	// 828BFDD0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BFDD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BFDD8: 419A0008  beq cr6, 0x828bfde0
	if ctx.cr[6].eq {
	pc = 0x828BFDE0; continue 'dispatch;
	}
	// 828BFDDC: 4BA00AB5  bl 0x822c0890
	ctx.lr = 0x828BFDE0;
	sub_822C0890(ctx, base);
	// 828BFDE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BFDE4: 4BFFD885  bl 0x828bd668
	ctx.lr = 0x828BFDE8;
	sub_828BD668(ctx, base);
	// 828BFDE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BFDEC: 997E03F8  stb r11, 0x3f8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1016 as u32), ctx.r[11].u8 ) };
	// 828BFDF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BFDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BFDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BFDFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BFE00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BFE04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFE08 size=612
    let mut pc: u32 = 0x828BFE08;
    'dispatch: loop {
        match pc {
            0x828BFE08 => {
    //   block [0x828BFE08..0x828C006C)
	// 828BFE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFE0C: 488E835D  bl 0x831a8168
	ctx.lr = 0x828BFE10;
	sub_831A8130(ctx, base);
	// 828BFE10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFE14: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BFE18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BFE1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BFE20: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828BFE24: 41820038  beq 0x828bfe5c
	if ctx.cr[0].eq {
	pc = 0x828BFE5C; continue 'dispatch;
	}
	// 828BFE28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFE2C: 488E9B5D  bl 0x831a9988
	ctx.lr = 0x828BFE30;
	sub_831A9988(ctx, base);
	// 828BFE30: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828BFE34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFE38: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 828BFE3C: 488E82BD  bl 0x831a80f8
	ctx.lr = 0x828BFE40;
	sub_831A80F8(ctx, base);
	// 828BFE40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFE44: 41820018  beq 0x828bfe5c
	if ctx.cr[0].eq {
	pc = 0x828BFE5C; continue 'dispatch;
	}
	// 828BFE48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFE4C: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFE50: 4BA001B1  bl 0x822c0000
	ctx.lr = 0x828BFE54;
	sub_822C0000(ctx, base);
	// 828BFE54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BFE58: 4800020C  b 0x828c0064
	pc = 0x828C0064; continue 'dispatch;
	// 828BFE5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFE60: 419A01F4  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFE68: 488E9B21  bl 0x831a9988
	ctx.lr = 0x828BFE6C;
	sub_831A9988(ctx, base);
	// 828BFE6C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828BFE70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFE74: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828BFE78: 488E8281  bl 0x831a80f8
	ctx.lr = 0x828BFE7C;
	sub_831A80F8(ctx, base);
	// 828BFE7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFE80: 41820014  beq 0x828bfe94
	if ctx.cr[0].eq {
	pc = 0x828BFE94; continue 'dispatch;
	}
	// 828BFE84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFE88: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFE8C: 4BA00175  bl 0x822c0000
	ctx.lr = 0x828BFE90;
	sub_822C0000(ctx, base);
	// 828BFE90: 4BFFFFC4  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFE94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFE98: 419A01BC  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFEA0: 488E9AE9  bl 0x831a9988
	ctx.lr = 0x828BFEA4;
	sub_831A9988(ctx, base);
	// 828BFEA4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828BFEA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFEAC: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828BFEB0: 488E8249  bl 0x831a80f8
	ctx.lr = 0x828BFEB4;
	sub_831A80F8(ctx, base);
	// 828BFEB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFEB8: 41820014  beq 0x828bfecc
	if ctx.cr[0].eq {
	pc = 0x828BFECC; continue 'dispatch;
	}
	// 828BFEBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFEC0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFEC4: 4BFFF7CD  bl 0x828bf690
	ctx.lr = 0x828BFEC8;
	sub_828BF690(ctx, base);
	// 828BFEC8: 4BFFFF8C  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFECC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFED0: 419A0184  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFED8: 488E9AB1  bl 0x831a9988
	ctx.lr = 0x828BFEDC;
	sub_831A9988(ctx, base);
	// 828BFEDC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828BFEE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFEE4: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828BFEE8: 488E8211  bl 0x831a80f8
	ctx.lr = 0x828BFEEC;
	sub_831A80F8(ctx, base);
	// 828BFEEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFEF0: 41820014  beq 0x828bff04
	if ctx.cr[0].eq {
	pc = 0x828BFF04; continue 'dispatch;
	}
	// 828BFEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFEF8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFEFC: 4BFFF895  bl 0x828bf790
	ctx.lr = 0x828BFF00;
	sub_828BF790(ctx, base);
	// 828BFF00: 4BFFFF54  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFF04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFF08: 419A014C  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFF10: 488E9A79  bl 0x831a9988
	ctx.lr = 0x828BFF14;
	sub_831A9988(ctx, base);
	// 828BFF14: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828BFF18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFF1C: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828BFF20: 488E81D9  bl 0x831a80f8
	ctx.lr = 0x828BFF24;
	sub_831A80F8(ctx, base);
	// 828BFF24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFF28: 41820014  beq 0x828bff3c
	if ctx.cr[0].eq {
	pc = 0x828BFF3C; continue 'dispatch;
	}
	// 828BFF2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFF30: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFF34: 4BFFD32D  bl 0x828bd260
	ctx.lr = 0x828BFF38;
	sub_828BD260(ctx, base);
	// 828BFF38: 4BFFFF1C  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFF3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFF40: 419A0114  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFF44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFF48: 488E9A41  bl 0x831a9988
	ctx.lr = 0x828BFF4C;
	sub_831A9988(ctx, base);
	// 828BFF4C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828BFF50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFF54: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828BFF58: 488E81A1  bl 0x831a80f8
	ctx.lr = 0x828BFF5C;
	sub_831A80F8(ctx, base);
	// 828BFF5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFF60: 41820014  beq 0x828bff74
	if ctx.cr[0].eq {
	pc = 0x828BFF74; continue 'dispatch;
	}
	// 828BFF64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFF68: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFF6C: 4BFFE04D  bl 0x828bdfb8
	ctx.lr = 0x828BFF70;
	sub_828BDFB8(ctx, base);
	// 828BFF70: 4BFFFEE4  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFF74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFF78: 419A00DC  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFF80: 488E9A09  bl 0x831a9988
	ctx.lr = 0x828BFF84;
	sub_831A9988(ctx, base);
	// 828BFF84: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828BFF88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFF8C: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828BFF90: 488E8169  bl 0x831a80f8
	ctx.lr = 0x828BFF94;
	sub_831A80F8(ctx, base);
	// 828BFF94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFF98: 41820014  beq 0x828bffac
	if ctx.cr[0].eq {
	pc = 0x828BFFAC; continue 'dispatch;
	}
	// 828BFF9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFFA0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFFA4: 4BFFE0DD  bl 0x828be080
	ctx.lr = 0x828BFFA8;
	sub_828BE080(ctx, base);
	// 828BFFA8: 4BFFFEAC  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFFAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFFB0: 419A00A4  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFFB8: 488E99D1  bl 0x831a9988
	ctx.lr = 0x828BFFBC;
	sub_831A9988(ctx, base);
	// 828BFFBC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828BFFC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFFC4: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828BFFC8: 488E8131  bl 0x831a80f8
	ctx.lr = 0x828BFFCC;
	sub_831A80F8(ctx, base);
	// 828BFFCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFFD0: 41820014  beq 0x828bffe4
	if ctx.cr[0].eq {
	pc = 0x828BFFE4; continue 'dispatch;
	}
	// 828BFFD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BFFD8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828BFFDC: 4BFFE135  bl 0x828be110
	ctx.lr = 0x828BFFE0;
	sub_828BE110(ctx, base);
	// 828BFFE0: 4BFFFE74  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828BFFE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BFFE8: 419A006C  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828BFFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BFFF0: 488E9999  bl 0x831a9988
	ctx.lr = 0x828BFFF4;
	sub_831A9988(ctx, base);
	// 828BFFF4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828BFFF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BFFFC: 386BFEC4  addi r3, r11, -0x13c
	ctx.r[3].s64 = ctx.r[11].s64 + -316;
	// 828C0000: 488E80F9  bl 0x831a80f8
	ctx.lr = 0x828C0004;
	sub_831A80F8(ctx, base);
	// 828C0004: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0008: 41820014  beq 0x828c001c
	if ctx.cr[0].eq {
	pc = 0x828C001C; continue 'dispatch;
	}
	// 828C000C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0010: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C0014: 4BFFD725  bl 0x828bd738
	ctx.lr = 0x828C0018;
	sub_828BD738(ctx, base);
	// 828C0018: 4BFFFE3C  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828C001C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C0020: 419A0034  beq cr6, 0x828c0054
	if ctx.cr[6].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828C0024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0028: 488E9961  bl 0x831a9988
	ctx.lr = 0x828C002C;
	sub_831A9988(ctx, base);
	// 828C002C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828C0030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C0034: 386BFEFC  addi r3, r11, -0x104
	ctx.r[3].s64 = ctx.r[11].s64 + -260;
	// 828C0038: 488E80C1  bl 0x831a80f8
	ctx.lr = 0x828C003C;
	sub_831A80F8(ctx, base);
	// 828C003C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0040: 41820014  beq 0x828c0054
	if ctx.cr[0].eq {
	pc = 0x828C0054; continue 'dispatch;
	}
	// 828C0044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0048: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C004C: 4BFFD76D  bl 0x828bd7b8
	ctx.lr = 0x828C0050;
	sub_828BD7B8(ctx, base);
	// 828C0050: 4BFFFE04  b 0x828bfe54
	pc = 0x828BFE54; continue 'dispatch;
	// 828C0054: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C0058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C005C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0060: 4809EEF9  bl 0x8295ef58
	ctx.lr = 0x828C0064;
	sub_8295EF58(ctx, base);
	// 828C0064: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C0068: 488E8150  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C0070 size=4
    let mut pc: u32 = 0x828C0070;
    'dispatch: loop {
        match pc {
            0x828C0070 => {
    //   block [0x828C0070..0x828C0074)
	// 828C0070: 4BFFFD98  b 0x828bfe08
	sub_828BFE08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0078 size=128
    let mut pc: u32 = 0x828C0078;
    'dispatch: loop {
        match pc {
            0x828C0078 => {
    //   block [0x828C0078..0x828C00F8)
	// 828C0078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C007C: 488E80F1  bl 0x831a816c
	ctx.lr = 0x828C0080;
	sub_831A8130(ctx, base);
	// 828C0080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0084: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C0088: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C008C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C0090: 3BEB0814  addi r31, r11, 0x814
	ctx.r[31].s64 = ctx.r[11].s64 + 2068;
	// 828C0094: 816A081C  lwz r11, 0x81c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2076 as u32) ) } as u64;
	// 828C0098: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C009C: 40820024  bne 0x828c00c0
	if !ctx.cr[0].eq {
	pc = 0x828C00C0; continue 'dispatch;
	}
	// 828C00A0: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828C00A4: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C00A8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C00AC: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828C00B0: 3908DB88  addi r8, r8, -0x2478
	ctx.r[8].s64 = ctx.r[8].s64 + -9336;
	// 828C00B4: 916A081C  stw r11, 0x81c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2076 as u32), ctx.r[11].u32 ) };
	// 828C00B8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C00BC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C00C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C00C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C00C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C00CC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828C00D0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C00D4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C00D8: 48007801  bl 0x828c78d8
	ctx.lr = 0x828C00DC;
	sub_828C78D8(ctx, base);
	// 828C00DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C00E0: 4182000C  beq 0x828c00ec
	if ctx.cr[0].eq {
	pc = 0x828C00EC; continue 'dispatch;
	}
	// 828C00E4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C00E8: 48000008  b 0x828c00f0
	pc = 0x828C00F0; continue 'dispatch;
	// 828C00EC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C00F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C00F4: 488E80C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C00F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C00F8 size=128
    let mut pc: u32 = 0x828C00F8;
    'dispatch: loop {
        match pc {
            0x828C00F8 => {
    //   block [0x828C00F8..0x828C0178)
	// 828C00F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C00FC: 488E8071  bl 0x831a816c
	ctx.lr = 0x828C0100;
	sub_831A8130(ctx, base);
	// 828C0100: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0104: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C0108: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C010C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C0110: 3BEB0820  addi r31, r11, 0x820
	ctx.r[31].s64 = ctx.r[11].s64 + 2080;
	// 828C0114: 816A0828  lwz r11, 0x828(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2088 as u32) ) } as u64;
	// 828C0118: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C011C: 40820024  bne 0x828c0140
	if !ctx.cr[0].eq {
	pc = 0x828C0140; continue 'dispatch;
	}
	// 828C0120: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828C0124: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C0128: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C012C: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828C0130: 3908DBD0  addi r8, r8, -0x2430
	ctx.r[8].s64 = ctx.r[8].s64 + -9264;
	// 828C0134: 916A0828  stw r11, 0x828(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2088 as u32), ctx.r[11].u32 ) };
	// 828C0138: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C013C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C0140: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C0144: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C0148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C014C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828C0150: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C0154: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0158: 48007781  bl 0x828c78d8
	ctx.lr = 0x828C015C;
	sub_828C78D8(ctx, base);
	// 828C015C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0160: 4182000C  beq 0x828c016c
	if ctx.cr[0].eq {
	pc = 0x828C016C; continue 'dispatch;
	}
	// 828C0164: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C0168: 48000008  b 0x828c0170
	pc = 0x828C0170; continue 'dispatch;
	// 828C016C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0170: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C0174: 488E8048  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0178 size=128
    let mut pc: u32 = 0x828C0178;
    'dispatch: loop {
        match pc {
            0x828C0178 => {
    //   block [0x828C0178..0x828C01F8)
	// 828C0178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C017C: 488E7FF1  bl 0x831a816c
	ctx.lr = 0x828C0180;
	sub_831A8130(ctx, base);
	// 828C0180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0184: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C0188: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C018C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C0190: 3BEB082C  addi r31, r11, 0x82c
	ctx.r[31].s64 = ctx.r[11].s64 + 2092;
	// 828C0194: 816A0834  lwz r11, 0x834(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2100 as u32) ) } as u64;
	// 828C0198: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C019C: 40820024  bne 0x828c01c0
	if !ctx.cr[0].eq {
	pc = 0x828C01C0; continue 'dispatch;
	}
	// 828C01A0: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828C01A4: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C01A8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C01AC: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828C01B0: 3908DC18  addi r8, r8, -0x23e8
	ctx.r[8].s64 = ctx.r[8].s64 + -9192;
	// 828C01B4: 916A0834  stw r11, 0x834(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2100 as u32), ctx.r[11].u32 ) };
	// 828C01B8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C01BC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C01C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C01C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C01C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C01CC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828C01D0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C01D4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C01D8: 48007701  bl 0x828c78d8
	ctx.lr = 0x828C01DC;
	sub_828C78D8(ctx, base);
	// 828C01DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C01E0: 4182000C  beq 0x828c01ec
	if ctx.cr[0].eq {
	pc = 0x828C01EC; continue 'dispatch;
	}
	// 828C01E4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C01E8: 48000008  b 0x828c01f0
	pc = 0x828C01F0; continue 'dispatch;
	// 828C01EC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C01F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C01F4: 488E7FC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C01F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C01F8 size=528
    let mut pc: u32 = 0x828C01F8;
    'dispatch: loop {
        match pc {
            0x828C01F8 => {
    //   block [0x828C01F8..0x828C0408)
	// 828C01F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C01FC: 488E7F69  bl 0x831a8164
	ctx.lr = 0x828C0200;
	sub_831A8130(ctx, base);
	// 828C0200: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828C0204: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0208: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C020C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0210: 3BABCF58  addi r29, r11, -0x30a8
	ctx.r[29].s64 = ctx.r[11].s64 + -12456;
	// 828C0214: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C0218: 38A00462  li r5, 0x462
	ctx.r[5].s64 = 1122;
	// 828C021C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C0220: 386003F0  li r3, 0x3f0
	ctx.r[3].s64 = 1008;
	// 828C0224: 485321C5  bl 0x82df23e8
	ctx.lr = 0x828C0228;
	sub_82DF23E8(ctx, base);
	// 828C0228: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C022C: 41820020  beq 0x828c024c
	if ctx.cr[0].eq {
	pc = 0x828C024C; continue 'dispatch;
	}
	// 828C0230: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C0234: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828C0238: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828C023C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828C0240: 4BFFE889  bl 0x828beac8
	ctx.lr = 0x828C0244;
	sub_828BEAC8(ctx, base);
	// 828C0244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0248: 48000008  b 0x828c0250
	pc = 0x828C0250; continue 'dispatch;
	// 828C024C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C0250: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C0254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0258: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C025C: 4BFFD60D  bl 0x828bd868
	ctx.lr = 0x828C0260;
	sub_828BD868(ctx, base);
	// 828C0260: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0268: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C026C: 4B9FFD95  bl 0x822c0000
	ctx.lr = 0x828C0270;
	sub_822C0000(ctx, base);
	// 828C0270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C0274: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C0278: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C027C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0280: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0284: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C0288: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C028C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C0290: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828C0294: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C0298: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828C029C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828C02A0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C02A4: 419A0024  beq cr6, 0x828c02c8
	if ctx.cr[6].eq {
	pc = 0x828C02C8; continue 'dispatch;
	}
	// 828C02A8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C02AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C02B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C02B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C02B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C02BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C02C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C02C4: 4082FFE8  bne 0x828c02ac
	if !ctx.cr[0].eq {
	pc = 0x828C02AC; continue 'dispatch;
	}
	// 828C02C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C02CC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828C02D0: 409A0008  bne cr6, 0x828c02d8
	if !ctx.cr[6].eq {
	pc = 0x828C02D8; continue 'dispatch;
	}
	// 828C02D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C02D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C02DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C02E0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C02E4: 419A0024  beq cr6, 0x828c0308
	if ctx.cr[6].eq {
	pc = 0x828C0308; continue 'dispatch;
	}
	// 828C02E8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C02EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C02F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C02F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C02F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C02FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0300: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0304: 4082FFE8  bne 0x828c02ec
	if !ctx.cr[0].eq {
	pc = 0x828C02EC; continue 'dispatch;
	}
	// 828C0308: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C030C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C0310: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C0314: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C0318: 485BC929  bl 0x82e7cc40
	ctx.lr = 0x828C031C;
	sub_82E7CC40(ctx, base);
	// 828C031C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C0320: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C0324: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0328: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C032C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0330: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C0334: 4BED8BFD  bl 0x82798f30
	ctx.lr = 0x828C0338;
	sub_82798F30(ctx, base);
	// 828C0338: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C033C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828C0340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0344: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828C0348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C034C: 4E800421  bctrl
	ctx.lr = 0x828C0350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C0350: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C0354: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828C0358: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C035C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0360: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828C0364: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C0368: 4E800421  bctrl
	ctx.lr = 0x828C036C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C036C: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C0370: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828C0374: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C0378: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C037C: 38A00468  li r5, 0x468
	ctx.r[5].s64 = 1128;
	// 828C0380: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C0384: 4BA00055  bl 0x822c03d8
	ctx.lr = 0x828C0388;
	sub_822C03D8(ctx, base);
	// 828C0388: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C038C: 41820014  beq 0x828c03a0
	if ctx.cr[0].eq {
	pc = 0x828C03A0; continue 'dispatch;
	}
	// 828C0390: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828C0394: 4BEDB2D5  bl 0x8279b668
	ctx.lr = 0x828C0398;
	sub_8279B668(ctx, base);
	// 828C0398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C039C: 48000008  b 0x828c03a4
	pc = 0x828C03A4; continue 'dispatch;
	// 828C03A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C03A4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C03A8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828C03AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C03B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C03B4: 4BCD789D  bl 0x82597c50
	ctx.lr = 0x828C03B8;
	sub_82597C50(ctx, base);
	// 828C03B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C03BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C03C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C03C4: 4B9FFC3D  bl 0x822c0000
	ctx.lr = 0x828C03C8;
	sub_822C0000(ctx, base);
	// 828C03C8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C03CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C03D0: 419A0008  beq cr6, 0x828c03d8
	if ctx.cr[6].eq {
	pc = 0x828C03D8; continue 'dispatch;
	}
	// 828C03D4: 4BA004BD  bl 0x822c0890
	ctx.lr = 0x828C03D8;
	sub_822C0890(ctx, base);
	// 828C03D8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C03DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C03E0: 419A0008  beq cr6, 0x828c03e8
	if ctx.cr[6].eq {
	pc = 0x828C03E8; continue 'dispatch;
	}
	// 828C03E4: 4BA004AD  bl 0x822c0890
	ctx.lr = 0x828C03E8;
	sub_822C0890(ctx, base);
	// 828C03E8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C03EC: 419A000C  beq cr6, 0x828c03f8
	if ctx.cr[6].eq {
	pc = 0x828C03F8; continue 'dispatch;
	}
	// 828C03F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C03F4: 4BA0049D  bl 0x822c0890
	ctx.lr = 0x828C03F8;
	sub_822C0890(ctx, base);
	// 828C03F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C03FC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828C0400: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C0404: 488E7DB0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C0408 size=528
    let mut pc: u32 = 0x828C0408;
    'dispatch: loop {
        match pc {
            0x828C0408 => {
    //   block [0x828C0408..0x828C0618)
	// 828C0408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C040C: 488E7D59  bl 0x831a8164
	ctx.lr = 0x828C0410;
	sub_831A8130(ctx, base);
	// 828C0410: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828C0414: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0418: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C041C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0420: 3BABCF58  addi r29, r11, -0x30a8
	ctx.r[29].s64 = ctx.r[11].s64 + -12456;
	// 828C0424: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C0428: 38A004B7  li r5, 0x4b7
	ctx.r[5].s64 = 1207;
	// 828C042C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C0430: 386003F0  li r3, 0x3f0
	ctx.r[3].s64 = 1008;
	// 828C0434: 48531FB5  bl 0x82df23e8
	ctx.lr = 0x828C0438;
	sub_82DF23E8(ctx, base);
	// 828C0438: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C043C: 41820020  beq 0x828c045c
	if ctx.cr[0].eq {
	pc = 0x828C045C; continue 'dispatch;
	}
	// 828C0440: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C0444: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828C0448: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828C044C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828C0450: 4BFFE771  bl 0x828bebc0
	ctx.lr = 0x828C0454;
	sub_828BEBC0(ctx, base);
	// 828C0454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0458: 48000008  b 0x828c0460
	pc = 0x828C0460; continue 'dispatch;
	// 828C045C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C0460: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C0464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0468: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C046C: 4BFFD4C5  bl 0x828bd930
	ctx.lr = 0x828C0470;
	sub_828BD930(ctx, base);
	// 828C0470: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0478: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C047C: 4B9FFB85  bl 0x822c0000
	ctx.lr = 0x828C0480;
	sub_822C0000(ctx, base);
	// 828C0480: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C0484: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C0488: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C048C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0490: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0494: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C0498: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C049C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C04A0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828C04A4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C04A8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828C04AC: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828C04B0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C04B4: 419A0024  beq cr6, 0x828c04d8
	if ctx.cr[6].eq {
	pc = 0x828C04D8; continue 'dispatch;
	}
	// 828C04B8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C04BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C04C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C04C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C04C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C04CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C04D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C04D4: 4082FFE8  bne 0x828c04bc
	if !ctx.cr[0].eq {
	pc = 0x828C04BC; continue 'dispatch;
	}
	// 828C04D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C04DC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828C04E0: 409A0008  bne cr6, 0x828c04e8
	if !ctx.cr[6].eq {
	pc = 0x828C04E8; continue 'dispatch;
	}
	// 828C04E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C04E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C04EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C04F0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C04F4: 419A0024  beq cr6, 0x828c0518
	if ctx.cr[6].eq {
	pc = 0x828C0518; continue 'dispatch;
	}
	// 828C04F8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C04FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C0500: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0504: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C0508: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C050C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0510: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0514: 4082FFE8  bne 0x828c04fc
	if !ctx.cr[0].eq {
	pc = 0x828C04FC; continue 'dispatch;
	}
	// 828C0518: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C051C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C0520: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C0524: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C0528: 485BC719  bl 0x82e7cc40
	ctx.lr = 0x828C052C;
	sub_82E7CC40(ctx, base);
	// 828C052C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C0530: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C0534: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0538: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C053C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0540: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C0544: 4BED89ED  bl 0x82798f30
	ctx.lr = 0x828C0548;
	sub_82798F30(ctx, base);
	// 828C0548: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C054C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828C0550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0554: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828C0558: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C055C: 4E800421  bctrl
	ctx.lr = 0x828C0560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C0560: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C0564: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828C0568: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C056C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0570: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828C0574: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C0578: 4E800421  bctrl
	ctx.lr = 0x828C057C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C057C: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C0580: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828C0584: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C0588: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C058C: 38A004BD  li r5, 0x4bd
	ctx.r[5].s64 = 1213;
	// 828C0590: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C0594: 4B9FFE45  bl 0x822c03d8
	ctx.lr = 0x828C0598;
	sub_822C03D8(ctx, base);
	// 828C0598: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C059C: 41820014  beq 0x828c05b0
	if ctx.cr[0].eq {
	pc = 0x828C05B0; continue 'dispatch;
	}
	// 828C05A0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828C05A4: 4BEDB0C5  bl 0x8279b668
	ctx.lr = 0x828C05A8;
	sub_8279B668(ctx, base);
	// 828C05A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C05AC: 48000008  b 0x828c05b4
	pc = 0x828C05B4; continue 'dispatch;
	// 828C05B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C05B4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C05B8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828C05BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C05C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C05C4: 4BCD768D  bl 0x82597c50
	ctx.lr = 0x828C05C8;
	sub_82597C50(ctx, base);
	// 828C05C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C05CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C05D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C05D4: 4B9FFA2D  bl 0x822c0000
	ctx.lr = 0x828C05D8;
	sub_822C0000(ctx, base);
	// 828C05D8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C05DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C05E0: 419A0008  beq cr6, 0x828c05e8
	if ctx.cr[6].eq {
	pc = 0x828C05E8; continue 'dispatch;
	}
	// 828C05E4: 4BA002AD  bl 0x822c0890
	ctx.lr = 0x828C05E8;
	sub_822C0890(ctx, base);
	// 828C05E8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C05EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C05F0: 419A0008  beq cr6, 0x828c05f8
	if ctx.cr[6].eq {
	pc = 0x828C05F8; continue 'dispatch;
	}
	// 828C05F4: 4BA0029D  bl 0x822c0890
	ctx.lr = 0x828C05F8;
	sub_822C0890(ctx, base);
	// 828C05F8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C05FC: 419A000C  beq cr6, 0x828c0608
	if ctx.cr[6].eq {
	pc = 0x828C0608; continue 'dispatch;
	}
	// 828C0600: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0604: 4BA0028D  bl 0x822c0890
	ctx.lr = 0x828C0608;
	sub_822C0890(ctx, base);
	// 828C0608: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C060C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828C0610: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C0614: 488E7BA0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C0618 size=528
    let mut pc: u32 = 0x828C0618;
    'dispatch: loop {
        match pc {
            0x828C0618 => {
    //   block [0x828C0618..0x828C0828)
	// 828C0618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C061C: 488E7B49  bl 0x831a8164
	ctx.lr = 0x828C0620;
	sub_831A8130(ctx, base);
	// 828C0620: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828C0624: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0628: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C062C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0630: 3BABCF58  addi r29, r11, -0x30a8
	ctx.r[29].s64 = ctx.r[11].s64 + -12456;
	// 828C0634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C0638: 38A0050F  li r5, 0x50f
	ctx.r[5].s64 = 1295;
	// 828C063C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C0640: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	// 828C0644: 48531DA5  bl 0x82df23e8
	ctx.lr = 0x828C0648;
	sub_82DF23E8(ctx, base);
	// 828C0648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C064C: 41820020  beq 0x828c066c
	if ctx.cr[0].eq {
	pc = 0x828C066C; continue 'dispatch;
	}
	// 828C0650: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C0654: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828C0658: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828C065C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828C0660: 4BFFE659  bl 0x828becb8
	ctx.lr = 0x828C0664;
	sub_828BECB8(ctx, base);
	// 828C0664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0668: 48000008  b 0x828c0670
	pc = 0x828C0670; continue 'dispatch;
	// 828C066C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C0670: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C0674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0678: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C067C: 4BFFD37D  bl 0x828bd9f8
	ctx.lr = 0x828C0680;
	sub_828BD9F8(ctx, base);
	// 828C0680: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C0688: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C068C: 4B9FF975  bl 0x822c0000
	ctx.lr = 0x828C0690;
	sub_822C0000(ctx, base);
	// 828C0690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C0694: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C0698: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C069C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C06A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C06A4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C06A8: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C06AC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C06B0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828C06B4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C06B8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828C06BC: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828C06C0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C06C4: 419A0024  beq cr6, 0x828c06e8
	if ctx.cr[6].eq {
	pc = 0x828C06E8; continue 'dispatch;
	}
	// 828C06C8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C06CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C06D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C06D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C06D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C06DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C06E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C06E4: 4082FFE8  bne 0x828c06cc
	if !ctx.cr[0].eq {
	pc = 0x828C06CC; continue 'dispatch;
	}
	// 828C06E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C06EC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828C06F0: 409A0008  bne cr6, 0x828c06f8
	if !ctx.cr[6].eq {
	pc = 0x828C06F8; continue 'dispatch;
	}
	// 828C06F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C06F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C06FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0700: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C0704: 419A0024  beq cr6, 0x828c0728
	if ctx.cr[6].eq {
	pc = 0x828C0728; continue 'dispatch;
	}
	// 828C0708: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C070C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C0710: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0714: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C0718: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C071C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0720: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0724: 4082FFE8  bne 0x828c070c
	if !ctx.cr[0].eq {
	pc = 0x828C070C; continue 'dispatch;
	}
	// 828C0728: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C072C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C0730: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C0734: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C0738: 485BC509  bl 0x82e7cc40
	ctx.lr = 0x828C073C;
	sub_82E7CC40(ctx, base);
	// 828C073C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C0740: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C0744: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0748: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C074C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0750: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C0754: 4BED87DD  bl 0x82798f30
	ctx.lr = 0x828C0758;
	sub_82798F30(ctx, base);
	// 828C0758: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C075C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828C0760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0764: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828C0768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C076C: 4E800421  bctrl
	ctx.lr = 0x828C0770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C0770: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C0774: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828C0778: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C077C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0780: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828C0784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C0788: 4E800421  bctrl
	ctx.lr = 0x828C078C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C078C: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C0790: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828C0794: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C0798: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C079C: 38A00515  li r5, 0x515
	ctx.r[5].s64 = 1301;
	// 828C07A0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C07A4: 4B9FFC35  bl 0x822c03d8
	ctx.lr = 0x828C07A8;
	sub_822C03D8(ctx, base);
	// 828C07A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C07AC: 41820014  beq 0x828c07c0
	if ctx.cr[0].eq {
	pc = 0x828C07C0; continue 'dispatch;
	}
	// 828C07B0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828C07B4: 4BEDAEB5  bl 0x8279b668
	ctx.lr = 0x828C07B8;
	sub_8279B668(ctx, base);
	// 828C07B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C07BC: 48000008  b 0x828c07c4
	pc = 0x828C07C4; continue 'dispatch;
	// 828C07C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C07C4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C07C8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828C07CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C07D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C07D4: 4BCD747D  bl 0x82597c50
	ctx.lr = 0x828C07D8;
	sub_82597C50(ctx, base);
	// 828C07D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C07DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C07E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C07E4: 4B9FF81D  bl 0x822c0000
	ctx.lr = 0x828C07E8;
	sub_822C0000(ctx, base);
	// 828C07E8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C07EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C07F0: 419A0008  beq cr6, 0x828c07f8
	if ctx.cr[6].eq {
	pc = 0x828C07F8; continue 'dispatch;
	}
	// 828C07F4: 4BA0009D  bl 0x822c0890
	ctx.lr = 0x828C07F8;
	sub_822C0890(ctx, base);
	// 828C07F8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C07FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0800: 419A0008  beq cr6, 0x828c0808
	if ctx.cr[6].eq {
	pc = 0x828C0808; continue 'dispatch;
	}
	// 828C0804: 4BA0008D  bl 0x822c0890
	ctx.lr = 0x828C0808;
	sub_822C0890(ctx, base);
	// 828C0808: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C080C: 419A000C  beq cr6, 0x828c0818
	if ctx.cr[6].eq {
	pc = 0x828C0818; continue 'dispatch;
	}
	// 828C0810: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0814: 4BA0007D  bl 0x822c0890
	ctx.lr = 0x828C0818;
	sub_822C0890(ctx, base);
	// 828C0818: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C081C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828C0820: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C0824: 488E7990  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0828 size=128
    let mut pc: u32 = 0x828C0828;
    'dispatch: loop {
        match pc {
            0x828C0828 => {
    //   block [0x828C0828..0x828C08A8)
	// 828C0828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C082C: 488E7941  bl 0x831a816c
	ctx.lr = 0x828C0830;
	sub_831A8130(ctx, base);
	// 828C0830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0834: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C0838: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C083C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C0840: 3BEB0838  addi r31, r11, 0x838
	ctx.r[31].s64 = ctx.r[11].s64 + 2104;
	// 828C0844: 816A0840  lwz r11, 0x840(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2112 as u32) ) } as u64;
	// 828C0848: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C084C: 40820024  bne 0x828c0870
	if !ctx.cr[0].eq {
	pc = 0x828C0870; continue 'dispatch;
	}
	// 828C0850: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828C0854: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C0858: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C085C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828C0860: 3908E390  addi r8, r8, -0x1c70
	ctx.r[8].s64 = ctx.r[8].s64 + -7280;
	// 828C0864: 916A0840  stw r11, 0x840(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2112 as u32), ctx.r[11].u32 ) };
	// 828C0868: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C086C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C0870: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C0874: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C0878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C087C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828C0880: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C0884: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0888: 4BD93D39  bl 0x826545c0
	ctx.lr = 0x828C088C;
	sub_826545C0(ctx, base);
	// 828C088C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0890: 4182000C  beq 0x828c089c
	if ctx.cr[0].eq {
	pc = 0x828C089C; continue 'dispatch;
	}
	// 828C0894: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C0898: 48000008  b 0x828c08a0
	pc = 0x828C08A0; continue 'dispatch;
	// 828C089C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C08A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C08A4: 488E7918  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C08A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C08A8 size=7008
    let mut pc: u32 = 0x828C08A8;
    'dispatch: loop {
        match pc {
            0x828C08A8 => {
    //   block [0x828C08A8..0x828C2408)
	// 828C08A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C08AC: 488E7885  bl 0x831a8130
	ctx.lr = 0x828C08B0;
	sub_831A8130(ctx, base);
	// 828C08B0: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 828C08B4: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 828C08B8: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C08BC: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 828C08C0: 908108CC  stw r4, 0x8cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2252 as u32), ctx.r[4].u32 ) };
	// 828C08C4: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 828C08C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C08CC: 928108D4  stw r20, 0x8d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2260 as u32), ctx.r[20].u32 ) };
	// 828C08D0: 92A108DC  stw r21, 0x8dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2268 as u32), ctx.r[21].u32 ) };
	// 828C08D4: 4809E57D  bl 0x8295ee50
	ctx.lr = 0x828C08D8;
	sub_8295EE50(ctx, base);
	// 828C08D8: 38BB03B8  addi r5, r27, 0x3b8
	ctx.r[5].s64 = ctx.r[27].s64 + 952;
	// 828C08DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C08E0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828C08E4: 4804FD1D  bl 0x82910600
	ctx.lr = 0x828C08E8;
	sub_82910600(ctx, base);
	// 828C08E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C08EC: 4804FFD5  bl 0x829108c0
	ctx.lr = 0x828C08F0;
	sub_829108C0(ctx, base);
	// 828C08F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C08F4: 41820010  beq 0x828c0904
	if ctx.cr[0].eq {
	pc = 0x828C0904; continue 'dispatch;
	}
	// 828C08F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C08FC: 4BC4FCD5  bl 0x825105d0
	ctx.lr = 0x828C0900;
	sub_825105D0(ctx, base);
	// 828C0900: 48001AF8  b 0x828c23f8
	pc = 0x828C23F8; continue 'dispatch;
	// 828C0904: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0908: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 828C090C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828C0910: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 828C0914: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C0918: 914100A8  stw r10, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 828C091C: 485DFE15  bl 0x82ea0730
	ctx.lr = 0x828C0920;
	sub_82EA0730(ctx, base);
	// 828C0920: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C0924: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 828C0928: 394BBC40  addi r10, r11, -0x43c0
	ctx.r[10].s64 = ctx.r[11].s64 + -17344;
	// 828C092C: 39692900  addi r11, r9, 0x2900
	ctx.r[11].s64 = ctx.r[9].s64 + 10496;
	// 828C0930: 39210720  addi r9, r1, 0x720
	ctx.r[9].s64 = ctx.r[1].s64 + 1824;
	// 828C0934: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828C0938: 39010710  addi r8, r1, 0x710
	ctx.r[8].s64 = ctx.r[1].s64 + 1808;
	// 828C093C: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 828C0940: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C0944: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828C0948: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C094C: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2408 size=96
    let mut pc: u32 = 0x828C2408;
    'dispatch: loop {
        match pc {
            0x828C2408 => {
    //   block [0x828C2408..0x828C2468)
	// 828C2408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C240C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2410: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2414: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2418: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C241C: 4BFFE48D  bl 0x828c08a8
	ctx.lr = 0x828C2420;
	sub_828C08A8(ctx, base);
	// 828C2420: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C2424: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C2428: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 828C242C: 388A0850  addi r4, r10, 0x850
	ctx.r[4].s64 = ctx.r[10].s64 + 2128;
	// 828C2430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2434: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C2438: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C243C: 4BFFCBC5  bl 0x828bf000
	ctx.lr = 0x828C2440;
	sub_828BF000(ctx, base);
	// 828C2440: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C2444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2448: 80AB3410  lwz r5, 0x3410(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13328 as u32) ) } as u64;
	// 828C244C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C2450: 4BFFC529  bl 0x828be978
	ctx.lr = 0x828C2454;
	sub_828BE978(ctx, base);
	// 828C2454: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C245C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2468 size=100
    let mut pc: u32 = 0x828C2468;
    'dispatch: loop {
        match pc {
            0x828C2468 => {
    //   block [0x828C2468..0x828C24CC)
	// 828C2468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C246C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2474: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C247C: 4BFFE42D  bl 0x828c08a8
	ctx.lr = 0x828C2480;
	sub_828C08A8(ctx, base);
	// 828C2480: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2484: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C2488: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 828C248C: 388A0968  addi r4, r10, 0x968
	ctx.r[4].s64 = ctx.r[10].s64 + 2408;
	// 828C2490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2494: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C2498: C02B959C  lfs f1, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C249C: 4BFFCB65  bl 0x828bf000
	ctx.lr = 0x828C24A0;
	sub_828BF000(ctx, base);
	// 828C24A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C24A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C24A8: 396B3410  addi r11, r11, 0x3410
	ctx.r[11].s64 = ctx.r[11].s64 + 13328;
	// 828C24AC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C24B0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C24B4: 4BFFC4C5  bl 0x828be978
	ctx.lr = 0x828C24B8;
	sub_828BE978(ctx, base);
	// 828C24B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C24BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C24C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C24C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C24C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C24D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C24D0 size=276
    let mut pc: u32 = 0x828C24D0;
    'dispatch: loop {
        match pc {
            0x828C24D0 => {
    //   block [0x828C24D0..0x828C25E4)
	// 828C24D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C24D4: 488E5C99  bl 0x831a816c
	ctx.lr = 0x828C24D8;
	sub_831A8130(ctx, base);
	// 828C24D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C24DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C24E0: 4BFFE3C9  bl 0x828c08a8
	ctx.lr = 0x828C24E4;
	sub_828C08A8(ctx, base);
	// 828C24E4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C24E8: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 828C24EC: 396B3410  addi r11, r11, 0x3410
	ctx.r[11].s64 = ctx.r[11].s64 + 13328;
	// 828C24F0: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C24F4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C24F8: 4BFFC481  bl 0x828be978
	ctx.lr = 0x828C24FC;
	sub_828BE978(ctx, base);
	// 828C24FC: 817F03E0  lwz r11, 0x3e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(992 as u32) ) } as u64;
	// 828C2500: 3BBF03E0  addi r29, r31, 0x3e0
	ctx.r[29].s64 = ctx.r[31].s64 + 992;
	// 828C2504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2508: 409A00B8  bne cr6, 0x828c25c0
	if !ctx.cr[6].eq {
	pc = 0x828C25C0; continue 'dispatch;
	}
	// 828C250C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2510: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828C2514: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828C2518: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 828C251C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C2520: 485DE211  bl 0x82ea0730
	ctx.lr = 0x828C2524;
	sub_82EA0730(ctx, base);
	// 828C2524: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828C2528: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828C252C: 396B2B30  addi r11, r11, 0x2b30
	ctx.r[11].s64 = ctx.r[11].s64 + 11056;
	// 828C2530: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 828C2534: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 828C2538: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 828C253C: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 828C2540: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C2544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2548: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C254C: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C25E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C25E8 size=60
    let mut pc: u32 = 0x828C25E8;
    'dispatch: loop {
        match pc {
            0x828C25E8 => {
    //   block [0x828C25E8..0x828C2624)
	// 828C25E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C25EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C25F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C25F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C25F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C25FC: 480548DD  bl 0x82916ed8
	ctx.lr = 0x828C2600;
	sub_82916ED8(ctx, base);
	// 828C2600: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2608: 396BD15C  addi r11, r11, -0x2ea4
	ctx.r[11].s64 = ctx.r[11].s64 + -11940;
	// 828C260C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C2610: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C261C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2628 size=72
    let mut pc: u32 = 0x828C2628;
    'dispatch: loop {
        match pc {
            0x828C2628 => {
    //   block [0x828C2628..0x828C2670)
	// 828C2628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C262C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2630: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2634: 4BF2B1E5  bl 0x827ed818
	ctx.lr = 0x828C2638;
	sub_827ED818(ctx, base);
	// 828C2638: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C263C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828C2640: 40820008  bne 0x828c2648
	if !ctx.cr[0].eq {
	pc = 0x828C2648; continue 'dispatch;
	}
	// 828C2644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C264C: 419A000C  beq cr6, 0x828c2658
	if ctx.cr[6].eq {
	pc = 0x828C2658; continue 'dispatch;
	}
	// 828C2650: 4BFFAB71  bl 0x828bd1c0
	ctx.lr = 0x828C2654;
	sub_828BD1C0(ctx, base);
	// 828C2654: 4800000C  b 0x828c2660
	pc = 0x828C2660; continue 'dispatch;
	// 828C2658: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C265C: 386B387C  addi r3, r11, 0x387c
	ctx.r[3].s64 = ctx.r[11].s64 + 14460;
	// 828C2660: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C266C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2670 size=84
    let mut pc: u32 = 0x828C2670;
    'dispatch: loop {
        match pc {
            0x828C2670 => {
    //   block [0x828C2670..0x828C26C4)
	// 828C2670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2678: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C267C: 4BF2B19D  bl 0x827ed818
	ctx.lr = 0x828C2680;
	sub_827ED818(ctx, base);
	// 828C2680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C2684: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828C2688: 40820008  bne 0x828c2690
	if !ctx.cr[0].eq {
	pc = 0x828C2690; continue 'dispatch;
	}
	// 828C268C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C2694: 419A0018  beq cr6, 0x828c26ac
	if ctx.cr[6].eq {
	pc = 0x828C26AC; continue 'dispatch;
	}
	// 828C2698: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C269C: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C26A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C26A4: 4E800421  bctrl
	ctx.lr = 0x828C26A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C26A8: 4800000C  b 0x828c26b4
	pc = 0x828C26B4; continue 'dispatch;
	// 828C26AC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C26B0: 386B0BB0  addi r3, r11, 0xbb0
	ctx.r[3].s64 = ctx.r[11].s64 + 2992;
	// 828C26B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C26B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C26BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C26C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C26C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C26C8 size=72
    let mut pc: u32 = 0x828C26C8;
    'dispatch: loop {
        match pc {
            0x828C26C8 => {
    //   block [0x828C26C8..0x828C2710)
	// 828C26C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C26CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C26D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C26D4: 4BF2B145  bl 0x827ed818
	ctx.lr = 0x828C26D8;
	sub_827ED818(ctx, base);
	// 828C26D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C26DC: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828C26E0: 40820008  bne 0x828c26e8
	if !ctx.cr[0].eq {
	pc = 0x828C26E8; continue 'dispatch;
	}
	// 828C26E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C26E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C26EC: 419A0014  beq cr6, 0x828c2700
	if ctx.cr[6].eq {
	pc = 0x828C2700; continue 'dispatch;
	}
	// 828C26F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C26F4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C26F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C26FC: 4E800421  bctrl
	ctx.lr = 0x828C2700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2700: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2704: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2708: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C270C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2710 size=72
    let mut pc: u32 = 0x828C2710;
    'dispatch: loop {
        match pc {
            0x828C2710 => {
    //   block [0x828C2710..0x828C2758)
	// 828C2710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2718: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C271C: 4BF2B0FD  bl 0x827ed818
	ctx.lr = 0x828C2720;
	sub_827ED818(ctx, base);
	// 828C2720: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C2724: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828C2728: 40820008  bne 0x828c2730
	if !ctx.cr[0].eq {
	pc = 0x828C2730; continue 'dispatch;
	}
	// 828C272C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C2734: 419A0014  beq cr6, 0x828c2748
	if ctx.cr[6].eq {
	pc = 0x828C2748; continue 'dispatch;
	}
	// 828C2738: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C273C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C2744: 4E800421  bctrl
	ctx.lr = 0x828C2748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C274C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2758 size=60
    let mut pc: u32 = 0x828C2758;
    'dispatch: loop {
        match pc {
            0x828C2758 => {
    //   block [0x828C2758..0x828C2794)
	// 828C2758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C275C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2760: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2764: 4BF2B0B5  bl 0x827ed818
	ctx.lr = 0x828C2768;
	sub_827ED818(ctx, base);
	// 828C2768: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C276C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828C2770: 40820008  bne 0x828c2778
	if !ctx.cr[0].eq {
	pc = 0x828C2778; continue 'dispatch;
	}
	// 828C2774: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2778: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C277C: 419A0008  beq cr6, 0x828c2784
	if ctx.cr[6].eq {
	pc = 0x828C2784; continue 'dispatch;
	}
	// 828C2780: 4BFFC119  bl 0x828be898
	ctx.lr = 0x828C2784;
	sub_828BE898(ctx, base);
	// 828C2784: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2788: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C278C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


