pub fn sub_830C0870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0870 size=452
    let mut pc: u32 = 0x830C0870;
    'dispatch: loop {
        match pc {
            0x830C0870 => {
    //   block [0x830C0870..0x830C0A34)
	// 830C0870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0874: 480E78E9  bl 0x831a815c
	ctx.lr = 0x830C0878;
	sub_831A8130(ctx, base);
	// 830C0878: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C087C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830C0880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0884: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830C0888: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830C088C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C0894: 409A0020  bne cr6, 0x830c08b4
	if !ctx.cr[6].eq {
	pc = 0x830C08B4; continue 'dispatch;
	}
	// 830C0898: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C089C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C08A0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C08A4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C08A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C08AC: 4BFFF78D  bl 0x830c0038
	ctx.lr = 0x830C08B0;
	sub_830C0038(ctx, base);
	// 830C08B0: 48000178  b 0x830c0a28
	pc = 0x830C0A28; continue 'dispatch;
	// 830C08B4: 833A0004  lwz r25, 4(r26)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C08B8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C08BC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C08C0: 409A002C  bne cr6, 0x830c08ec
	if !ctx.cr[6].eq {
	pc = 0x830C08EC; continue 'dispatch;
	}
	// 830C08C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C08C8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C08CC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C08D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C08D4: 41980008  blt cr6, 0x830c08dc
	if ctx.cr[6].lt {
	pc = 0x830C08DC; continue 'dispatch;
	}
	// 830C08D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C08DC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C08E0: 4182012C  beq 0x830c0a0c
	if ctx.cr[0].eq {
	pc = 0x830C0A0C; continue 'dispatch;
	}
	// 830C08E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C08E8: 4BFFFFB4  b 0x830c089c
	pc = 0x830C089C; continue 'dispatch;
	// 830C08EC: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830C08F0: 409A0030  bne cr6, 0x830c0920
	if !ctx.cr[6].eq {
	pc = 0x830C0920; continue 'dispatch;
	}
	// 830C08F4: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C08F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C08FC: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0900: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C0904: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C0908: 41980008  blt cr6, 0x830c0910
	if ctx.cr[6].lt {
	pc = 0x830C0910; continue 'dispatch;
	}
	// 830C090C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0910: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C0914: 418200F8  beq 0x830c0a0c
	if ctx.cr[0].eq {
	pc = 0x830C0A0C; continue 'dispatch;
	}
	// 830C0918: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C091C: 4BFFFF84  b 0x830c08a0
	pc = 0x830C08A0; continue 'dispatch;
	// 830C0920: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C0928: 837E0010  lwz r27, 0x10(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C092C: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830C0930: 41980008  blt cr6, 0x830c0938
	if ctx.cr[6].lt {
	pc = 0x830C0938; continue 'dispatch;
	}
	// 830C0934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0938: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C093C: 41820060  beq 0x830c099c
	if ctx.cr[0].eq {
	pc = 0x830C099C; continue 'dispatch;
	}
	// 830C0940: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C0944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0948: 4BFFF251  bl 0x830bfb98
	ctx.lr = 0x830C094C;
	sub_830BFB98(ctx, base);
	// 830C094C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C0950: 81660010  lwz r11, 0x10(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0954: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830C0958: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C095C: 41980008  blt cr6, 0x830c0964
	if ctx.cr[6].lt {
	pc = 0x830C0964; continue 'dispatch;
	}
	// 830C0960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0964: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C0968: 41820034  beq 0x830c099c
	if ctx.cr[0].eq {
	pc = 0x830C099C; continue 'dispatch;
	}
	// 830C096C: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0970: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C0974: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C0978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C097C: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C0980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C0984: 419A000C  beq cr6, 0x830c0990
	if ctx.cr[6].eq {
	pc = 0x830C0990; continue 'dispatch;
	}
	// 830C0988: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C098C: 4BFFFF20  b 0x830c08ac
	pc = 0x830C08AC; continue 'dispatch;
	// 830C0990: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C0994: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C0998: 4BFFFF14  b 0x830c08ac
	pc = 0x830C08AC; continue 'dispatch;
	// 830C099C: 7F1BE000  cmpw cr6, r27, r28
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830C09A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C09A4: 41980008  blt cr6, 0x830c09ac
	if ctx.cr[6].lt {
	pc = 0x830C09AC; continue 'dispatch;
	}
	// 830C09A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C09AC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C09B0: 4182005C  beq 0x830c0a0c
	if ctx.cr[0].eq {
	pc = 0x830C0A0C; continue 'dispatch;
	}
	// 830C09B4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C09B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C09BC: 4BD98E55  bl 0x82e59810
	ctx.lr = 0x830C09C0;
	sub_82E59810(ctx, base);
	// 830C09C0: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C09C4: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830C09C8: 419A0020  beq cr6, 0x830c09e8
	if ctx.cr[6].eq {
	pc = 0x830C09E8; continue 'dispatch;
	}
	// 830C09CC: 81660010  lwz r11, 0x10(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C09D0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C09D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C09D8: 41980008  blt cr6, 0x830c09e0
	if ctx.cr[6].lt {
	pc = 0x830C09E0; continue 'dispatch;
	}
	// 830C09DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C09E0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C09E4: 41820028  beq 0x830c0a0c
	if ctx.cr[0].eq {
	pc = 0x830C0A0C; continue 'dispatch;
	}
	// 830C09E8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C09EC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C09F0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C09F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C09F8: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C09FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C0A00: 419AFF94  beq cr6, 0x830c0994
	if ctx.cr[6].eq {
	pc = 0x830C0994; continue 'dispatch;
	}
	// 830C0A04: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C0A08: 4BFFFF80  b 0x830c0988
	pc = 0x830C0988; continue 'dispatch;
	// 830C0A0C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C0A10: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C0A14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0A18: 4BFFFBA9  bl 0x830c05c0
	ctx.lr = 0x830C0A1C;
	sub_830C05C0(ctx, base);
	// 830C0A1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C0A20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0A24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0A2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C0A30: 480E777C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0A38 size=372
    let mut pc: u32 = 0x830C0A38;
    'dispatch: loop {
        match pc {
            0x830C0A38 => {
    //   block [0x830C0A38..0x830C0BAC)
	// 830C0A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0A3C: 480E7729  bl 0x831a8164
	ctx.lr = 0x830C0A40;
	sub_831A8130(ctx, base);
	// 830C0A40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0A44: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C0A48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0A4C: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 830C0A50: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0A54: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0A58: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C0A5C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830C0A60: 419A0024  beq cr6, 0x830c0a84
	if ctx.cr[6].eq {
	pc = 0x830C0A84; continue 'dispatch;
	}
	// 830C0A64: 393E0004  addi r9, r30, 4
	ctx.r[9].s64 = ctx.r[30].s64 + 4;
	// 830C0A68: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 830C0A6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C0A70: 7D004828  lwarx r8, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 830C0A74: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 830C0A78: 7D00492D  stwcx. r8, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C0A7C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C0A80: 4082FFE8  bne 0x830c0a68
	if !ctx.cr[0].eq {
	pc = 0x830C0A68; continue 'dispatch;
	}
	// 830C0A84: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830C0A88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830C0A8C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830C0A90: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 830C0A94: 419A0024  beq cr6, 0x830c0ab8
	if ctx.cr[6].eq {
	pc = 0x830C0AB8; continue 'dispatch;
	}
	// 830C0A98: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830C0A9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C0AA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C0AA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C0AA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C0AAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C0AB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C0AB4: 4082FFE8  bne 0x830c0a9c
	if !ctx.cr[0].eq {
	pc = 0x830C0A9C; continue 'dispatch;
	}
	// 830C0AB8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830C0ABC: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 830C0AC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C0AC4: 4BFFF8A5  bl 0x830c0368
	ctx.lr = 0x830C0AC8;
	sub_830C0368(ctx, base);
	// 830C0AC8: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C0ACC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0AD0: 419A0008  beq cr6, 0x830c0ad8
	if ctx.cr[6].eq {
	pc = 0x830C0AD8; continue 'dispatch;
	}
	// 830C0AD4: 4B1FFDBD  bl 0x822c0890
	ctx.lr = 0x830C0AD8;
	sub_822C0890(ctx, base);
	// 830C0AD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830C0ADC: 419A000C  beq cr6, 0x830c0ae8
	if ctx.cr[6].eq {
	pc = 0x830C0AE8; continue 'dispatch;
	}
	// 830C0AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C0AE4: 4B1FFDAD  bl 0x822c0890
	ctx.lr = 0x830C0AE8;
	sub_822C0890(ctx, base);
	// 830C0AE8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C0AEC: 3BDF0054  addi r30, r31, 0x54
	ctx.r[30].s64 = ctx.r[31].s64 + 84;
	// 830C0AF0: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C0AF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830C0AF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0AFC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830C0B00: 419A0038  beq cr6, 0x830c0b38
	if ctx.cr[6].eq {
	pc = 0x830C0B38; continue 'dispatch;
	}
	// 830C0B04: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 830C0B08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C0B0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C0B10: 48002E01  bl 0x830c3910
	ctx.lr = 0x830C0B14;
	sub_830C3910(ctx, base);
	// 830C0B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0B18: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0B1C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0B24: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C0B28: 419A0008  beq cr6, 0x830c0b30
	if ctx.cr[6].eq {
	pc = 0x830C0B30; continue 'dispatch;
	}
	// 830C0B2C: 4B1FFD65  bl 0x822c0890
	ctx.lr = 0x830C0B30;
	sub_822C0890(ctx, base);
	// 830C0B30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C0B34: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 830C0B38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0B3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C0B40: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 830C0B44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0B48: 4B203919  bl 0x822c4460
	ctx.lr = 0x830C0B4C;
	sub_822C4460(ctx, base);
	// 830C0B4C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C0B50: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830C0B54: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 830C0B58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C0B5C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0B60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C0B64: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0B68: 4BFFF1A1  bl 0x830bfd08
	ctx.lr = 0x830C0B6C;
	sub_830BFD08(ctx, base);
	// 830C0B6C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C0B70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C0B74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C0B78: 4BDDD941  bl 0x82e9e4b8
	ctx.lr = 0x830C0B7C;
	sub_82E9E4B8(ctx, base);
	// 830C0B7C: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830C0B80: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0B84: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830C0B88: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0B8C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C0B90: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 830C0B94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0B98: 419A0008  beq cr6, 0x830c0ba0
	if ctx.cr[6].eq {
	pc = 0x830C0BA0; continue 'dispatch;
	}
	// 830C0B9C: 4B1FFCF5  bl 0x822c0890
	ctx.lr = 0x830C0BA0;
	sub_822C0890(ctx, base);
	// 830C0BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0BA4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C0BA8: 480E760C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0BB0 size=152
    let mut pc: u32 = 0x830C0BB0;
    'dispatch: loop {
        match pc {
            0x830C0BB0 => {
    //   block [0x830C0BB0..0x830C0C48)
	// 830C0BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C0BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C0BBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0BC0: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 830C0BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0BC8: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 830C0BCC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830C0BD0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C0BD4: 40980050  bge cr6, 0x830c0c24
	if !ctx.cr[6].lt {
	pc = 0x830C0C24; continue 'dispatch;
	}
	// 830C0BD8: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 830C0BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C0BE0: 386B001C  addi r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 + 28;
	// 830C0BE4: 4BFFFBC5  bl 0x830c07a8
	ctx.lr = 0x830C0BE8;
	sub_830C07A8(ctx, base);
	// 830C0BE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0BEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0BF0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C0BF8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C0BFC: 419A0034  beq cr6, 0x830c0c30
	if ctx.cr[6].eq {
	pc = 0x830C0C30; continue 'dispatch;
	}
	// 830C0C00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C0C04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C0C08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C0C0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C0C10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C0C14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C0C18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C0C1C: 4082FFE8  bne 0x830c0c04
	if !ctx.cr[0].eq {
	pc = 0x830C0C04; continue 'dispatch;
	}
	// 830C0C20: 48000010  b 0x830c0c30
	pc = 0x830C0C30; continue 'dispatch;
	// 830C0C24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0C28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0C2C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C0C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0C34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C0C38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0C3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C0C40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C0C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0C48 size=276
    let mut pc: u32 = 0x830C0C48;
    'dispatch: loop {
        match pc {
            0x830C0C48 => {
    //   block [0x830C0C48..0x830C0D5C)
	// 830C0C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0C4C: 480E7519  bl 0x831a8164
	ctx.lr = 0x830C0C50;
	sub_831A8130(ctx, base);
	// 830C0C50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0C54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C0C58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C0C5C: 3BBC0054  addi r29, r28, 0x54
	ctx.r[29].s64 = ctx.r[28].s64 + 84;
	// 830C0C60: 807C0054  lwz r3, 0x54(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C0C64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0C68: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C0C6C: 419A00D8  beq cr6, 0x830c0d44
	if ctx.cr[6].eq {
	pc = 0x830C0D44; continue 'dispatch;
	}
	// 830C0C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0C74: 419A0030  beq cr6, 0x830c0ca4
	if ctx.cr[6].eq {
	pc = 0x830C0CA4; continue 'dispatch;
	}
	// 830C0C78: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 830C0C7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C0C80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C0C84: 48002C8D  bl 0x830c3910
	ctx.lr = 0x830C0C88;
	sub_830C3910(ctx, base);
	// 830C0C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0C8C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0C90: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0C94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0C98: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C0C9C: 419A0008  beq cr6, 0x830c0ca4
	if ctx.cr[6].eq {
	pc = 0x830C0CA4; continue 'dispatch;
	}
	// 830C0CA0: 4B1FFBF1  bl 0x822c0890
	ctx.lr = 0x830C0CA4;
	sub_822C0890(ctx, base);
	// 830C0CA4: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C0CA8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0CAC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0CB0: 419A006C  beq cr6, 0x830c0d1c
	if ctx.cr[6].eq {
	pc = 0x830C0D1C; continue 'dispatch;
	}
	// 830C0CB4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0CB8: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0CBC: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C0CC0: 419A0014  beq cr6, 0x830c0cd4
	if ctx.cr[6].eq {
	pc = 0x830C0CD4; continue 'dispatch;
	}
	// 830C0CC4: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0CC8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0CCC: 409AFFEC  bne cr6, 0x830c0cb8
	if !ctx.cr[6].eq {
	pc = 0x830C0CB8; continue 'dispatch;
	}
	// 830C0CD0: 4800004C  b 0x830c0d1c
	pc = 0x830C0D1C; continue 'dispatch;
	// 830C0CD4: 3BFC002C  addi r31, r28, 0x2c
	ctx.r[31].s64 = ctx.r[28].s64 + 44;
	// 830C0CD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C0CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C0CE0: 4BFFF0B1  bl 0x830bfd90
	ctx.lr = 0x830C0CE4;
	sub_830BFD90(ctx, base);
	// 830C0CE4: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C0CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0CEC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C0CF0: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0CF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C0CF8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0CFC: 4BFFF00D  bl 0x830bfd08
	ctx.lr = 0x830C0D00;
	sub_830BFD08(ctx, base);
	// 830C0D00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C0D04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C0D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0D0C: 4BDDD7AD  bl 0x82e9e4b8
	ctx.lr = 0x830C0D10;
	sub_82E9E4B8(ctx, base);
	// 830C0D10: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830C0D14: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0D18: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830C0D1C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 830C0D20: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0D24: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830C0D28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C0D2C: 48002BE5  bl 0x830c3910
	ctx.lr = 0x830C0D30;
	sub_830C3910(ctx, base);
	// 830C0D30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0D34: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 830C0D38: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 830C0D3C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0D40: 4B203721  bl 0x822c4460
	ctx.lr = 0x830C0D44;
	sub_822C4460(ctx, base);
	// 830C0D44: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C0D4C: 419A0008  beq cr6, 0x830c0d54
	if ctx.cr[6].eq {
	pc = 0x830C0D54; continue 'dispatch;
	}
	// 830C0D50: 4B1FFB41  bl 0x822c0890
	ctx.lr = 0x830C0D54;
	sub_822C0890(ctx, base);
	// 830C0D54: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C0D58: 480E745C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0D60 size=156
    let mut pc: u32 = 0x830C0D60;
    'dispatch: loop {
        match pc {
            0x830C0D60 => {
    //   block [0x830C0D60..0x830C0DFC)
	// 830C0D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0D64: 480E7409  bl 0x831a816c
	ctx.lr = 0x830C0D68;
	sub_831A8130(ctx, base);
	// 830C0D68: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0D6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C0D70: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C0D74: 4BFFED65  bl 0x830bfad8
	ctx.lr = 0x830C0D78;
	sub_830BFAD8(ctx, base);
	// 830C0D78: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0D80: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0D84: 419A0024  beq cr6, 0x830c0da8
	if ctx.cr[6].eq {
	pc = 0x830C0DA8; continue 'dispatch;
	}
	// 830C0D88: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0D8C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0D90: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C0D94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C0D98: 41980008  blt cr6, 0x830c0da0
	if ctx.cr[6].lt {
	pc = 0x830C0DA0; continue 'dispatch;
	}
	// 830C0D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0DA0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C0DA4: 4182004C  beq 0x830c0df0
	if ctx.cr[0].eq {
	pc = 0x830C0DF0; continue 'dispatch;
	}
	// 830C0DA8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0DAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C0DB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830C0DB4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830C0DB8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830C0DBC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830C0DC0: 4B4CB151  bl 0x8258bf10
	ctx.lr = 0x830C0DC4;
	sub_8258BF10(ctx, base);
	// 830C0DC4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830C0DC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C0DCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C0DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0DD4: 4BFFFA9D  bl 0x830c0870
	ctx.lr = 0x830C0DD8;
	sub_830C0870(ctx, base);
	// 830C0DD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C0DDC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830C0DE0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0DE4: 4B207ED5  bl 0x822c8cb8
	ctx.lr = 0x830C0DE8;
	sub_822C8CB8(ctx, base);
	// 830C0DE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C0DEC: 4B207ECD  bl 0x822c8cb8
	ctx.lr = 0x830C0DF0;
	sub_822C8CB8(ctx, base);
	// 830C0DF0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 830C0DF4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830C0DF8: 480E73C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C0E00 size=132
    let mut pc: u32 = 0x830C0E00;
    'dispatch: loop {
        match pc {
            0x830C0E00 => {
    //   block [0x830C0E00..0x830C0E84)
	// 830C0E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C0E08: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830C0E0C: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830C0E10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0E14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0E18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C0E1C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830C0E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0E24: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830C0E28: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0E2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0E30: 4E800421  bctrl
	ctx.lr = 0x830C0E34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C0E34: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C0E38: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C0E3C: 4099002C  ble cr6, 0x830c0e68
	if !ctx.cr[6].gt {
	pc = 0x830C0E68; continue 'dispatch;
	}
	// 830C0E40: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C0E44: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C0E48: 40980020  bge cr6, 0x830c0e68
	if !ctx.cr[6].lt {
	pc = 0x830C0E68; continue 'dispatch;
	}
	// 830C0E4C: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C0E50: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C0E54: 40990014  ble cr6, 0x830c0e68
	if !ctx.cr[6].gt {
	pc = 0x830C0E68; continue 'dispatch;
	}
	// 830C0E58: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C0E5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C0E60: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C0E64: 41980008  blt cr6, 0x830c0e6c
	if ctx.cr[6].lt {
	pc = 0x830C0E6C; continue 'dispatch;
	}
	// 830C0E68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C0E6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C0E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C0E78: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C0E7C: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C0E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0E88 size=4
    let mut pc: u32 = 0x830C0E88;
    'dispatch: loop {
        match pc {
            0x830C0E88 => {
    //   block [0x830C0E88..0x830C0E8C)
	// 830C0E88: 48002190  b 0x830c3018
	sub_830C3018(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0E90 size=48
    let mut pc: u32 = 0x830C0E90;
    'dispatch: loop {
        match pc {
            0x830C0E90 => {
    //   block [0x830C0E90..0x830C0EC0)
	// 830C0E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C0E98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C0E9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0EA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0EA4: 48002265  bl 0x830c3108
	ctx.lr = 0x830C0EA8;
	sub_830C3108(ctx, base);
	// 830C0EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0EAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C0EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C0EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C0EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0EC0 size=28
    let mut pc: u32 = 0x830C0EC0;
    'dispatch: loop {
        match pc {
            0x830C0EC0 => {
    //   block [0x830C0EC0..0x830C0EDC)
	// 830C0EC0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830C0EC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0EC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C0ECC: 996A0095  stb r11, 0x95(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 830C0ED0: 996A0096  stb r11, 0x96(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 830C0ED4: 996A0097  stb r11, 0x97(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C0ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0EE0 size=136
    let mut pc: u32 = 0x830C0EE0;
    'dispatch: loop {
        match pc {
            0x830C0EE0 => {
    //   block [0x830C0EE0..0x830C0F68)
	// 830C0EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C0EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C0EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C0EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C0EF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C0EFC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830C0F00: 409A0020  bne cr6, 0x830c0f20
	if !ctx.cr[6].eq {
	pc = 0x830C0F20; continue 'dispatch;
	}
	// 830C0F04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C0F08: 419A0048  beq cr6, 0x830c0f50
	if ctx.cr[6].eq {
	pc = 0x830C0F50; continue 'dispatch;
	}
	// 830C0F0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0F10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0F14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0F18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C0F1C: 48000034  b 0x830c0f50
	pc = 0x830C0F50; continue 'dispatch;
	// 830C0F20: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830C0F24: 419A002C  beq cr6, 0x830c0f50
	if ctx.cr[6].eq {
	pc = 0x830C0F50; continue 'dispatch;
	}
	// 830C0F28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C0F2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0F30: 388B4468  addi r4, r11, 0x4468
	ctx.r[4].s64 = ctx.r[11].s64 + 17512;
	// 830C0F34: 480E71C5  bl 0x831a80f8
	ctx.lr = 0x830C0F38;
	sub_831A80F8(ctx, base);
	// 830C0F38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C0F3C: 4182000C  beq 0x830c0f48
	if ctx.cr[0].eq {
	pc = 0x830C0F48; continue 'dispatch;
	}
	// 830C0F40: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830C0F44: 4800000C  b 0x830c0f50
	pc = 0x830C0F50; continue 'dispatch;
	// 830C0F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0F4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0F50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C0F54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0F58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C0F5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C0F60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C0F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0F68 size=16
    let mut pc: u32 = 0x830C0F68;
    'dispatch: loop {
        match pc {
            0x830C0F68 => {
    //   block [0x830C0F68..0x830C0F78)
	// 830C0F68: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0F6C: 816C0048  lwz r11, 0x48(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(72 as u32) ) } as u64;
	// 830C0F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0F74: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0F78 size=16
    let mut pc: u32 = 0x830C0F78;
    'dispatch: loop {
        match pc {
            0x830C0F78 => {
    //   block [0x830C0F78..0x830C0F88)
	// 830C0F78: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0F7C: 816C003C  lwz r11, 0x3c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(60 as u32) ) } as u64;
	// 830C0F80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0F84: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0F88 size=16
    let mut pc: u32 = 0x830C0F88;
    'dispatch: loop {
        match pc {
            0x830C0F88 => {
    //   block [0x830C0F88..0x830C0F98)
	// 830C0F88: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0F8C: 816C0040  lwz r11, 0x40(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(64 as u32) ) } as u64;
	// 830C0F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0F94: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0F98 size=16
    let mut pc: u32 = 0x830C0F98;
    'dispatch: loop {
        match pc {
            0x830C0F98 => {
    //   block [0x830C0F98..0x830C0FA8)
	// 830C0F98: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0F9C: 816C0044  lwz r11, 0x44(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(68 as u32) ) } as u64;
	// 830C0FA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0FA4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C0FA8 size=16
    let mut pc: u32 = 0x830C0FA8;
    'dispatch: loop {
        match pc {
            0x830C0FA8 => {
    //   block [0x830C0FA8..0x830C0FB8)
	// 830C0FA8: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0FAC: 816C0038  lwz r11, 0x38(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C0FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0FB4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C0FB8 size=160
    let mut pc: u32 = 0x830C0FB8;
    'dispatch: loop {
        match pc {
            0x830C0FB8 => {
    //   block [0x830C0FB8..0x830C1058)
	// 830C0FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C0FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C0FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C0FC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0FD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0FD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C0FD8: 48002131  bl 0x830c3108
	ctx.lr = 0x830C0FDC;
	sub_830C3108(ctx, base);
	// 830C0FDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C0FE0: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C0FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0FE8: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C0FEC: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C0FF0: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830C0FF4: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C0FF8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C0FFC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830C1000: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830C1004: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1008: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C100C: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830C1010: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1014: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830C1018: 419A0008  beq cr6, 0x830c1020
	if ctx.cr[6].eq {
	pc = 0x830C1020; continue 'dispatch;
	}
	// 830C101C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C1020: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1024: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C1028: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C102C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C1030: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C1034: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C1038: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830C103C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830C1040: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C1044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C104C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C1050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C1054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1058 size=92
    let mut pc: u32 = 0x830C1058;
    'dispatch: loop {
        match pc {
            0x830C1058 => {
    //   block [0x830C1058..0x830C10B4)
	// 830C1058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C105C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C1064: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C1068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C106C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1070: 48002099  bl 0x830c3108
	ctx.lr = 0x830C1074;
	sub_830C3108(ctx, base);
	// 830C1074: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C1078: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C107C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C1080: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830C1084: C1AB959C  lfs f13, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1088: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C108C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C1090: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1094: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1098: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C109C: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C10A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C10A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C10A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C10AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C10B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C10B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C10B8 size=124
    let mut pc: u32 = 0x830C10B8;
    'dispatch: loop {
        match pc {
            0x830C10B8 => {
    //   block [0x830C10B8..0x830C1134)
	// 830C10B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C10BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C10C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C10C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C10C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C10CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C10D0: 48002039  bl 0x830c3108
	ctx.lr = 0x830C10D4;
	sub_830C3108(ctx, base);
	// 830C10D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C10D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C10DC: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C10E0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830C10E4: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C10E8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 830C10EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C10F0: C1AB959C  lfs f13, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C10F4: C16A0940  lfs f11, 0x940(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C10F8: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C10FC: C149E830  lfs f10, -0x17d0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C1100: ED6C5828  fsubs f11, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C1104: C1289524  lfs f9, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C1108: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 830C110C: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 830C1110: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C1114: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C1118: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C111C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830C1120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C1124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C112C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C1130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1138 size=124
    let mut pc: u32 = 0x830C1138;
    'dispatch: loop {
        match pc {
            0x830C1138 => {
    //   block [0x830C1138..0x830C11B4)
	// 830C1138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C113C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C1144: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C1148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C114C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1150: 48001FB9  bl 0x830c3108
	ctx.lr = 0x830C1154;
	sub_830C3108(ctx, base);
	// 830C1154: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C1158: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C115C: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1160: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C1164: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C1168: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 830C116C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C1170: C1ABD72C  lfs f13, -0x28d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1174: C16A0940  lfs f11, 0x940(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C1178: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C117C: C1499684  lfs f10, -0x697c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27004 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C1180: ED6C5828  fsubs f11, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C1184: C1289524  lfs f9, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C1188: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 830C118C: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 830C1190: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C1194: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C1198: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C119C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830C11A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C11A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C11A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C11AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C11B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C11B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C11B8 size=124
    let mut pc: u32 = 0x830C11B8;
    'dispatch: loop {
        match pc {
            0x830C11B8 => {
    //   block [0x830C11B8..0x830C1234)
	// 830C11B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C11BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C11C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C11C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C11C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C11CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C11D0: 48001F39  bl 0x830c3108
	ctx.lr = 0x830C11D4;
	sub_830C3108(ctx, base);
	// 830C11D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C11D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C11DC: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C11E0: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 830C11E4: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C11E8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 830C11EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C11F0: C1AB9584  lfs f13, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C11F4: C16A0940  lfs f11, 0x940(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C11F8: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C11FC: C1498DA0  lfs f10, -0x7260(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C1200: ED6C5828  fsubs f11, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C1204: C1289524  lfs f9, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C1208: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 830C120C: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 830C1210: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C1214: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C1218: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C121C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830C1220: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C1224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C122C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C1230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1238 size=120
    let mut pc: u32 = 0x830C1238;
    'dispatch: loop {
        match pc {
            0x830C1238 => {
    //   block [0x830C1238..0x830C12B0)
	// 830C1238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C123C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1240: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830C1244: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830C1248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C124C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C1250: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830C1254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1258: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830C125C: 4BFFFDFD  bl 0x830c1058
	ctx.lr = 0x830C1260;
	sub_830C1058(ctx, base);
	// 830C1260: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1264: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C1268: 4099002C  ble cr6, 0x830c1294
	if !ctx.cr[6].gt {
	pc = 0x830C1294; continue 'dispatch;
	}
	// 830C126C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1270: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C1274: 40980020  bge cr6, 0x830c1294
	if !ctx.cr[6].lt {
	pc = 0x830C1294; continue 'dispatch;
	}
	// 830C1278: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C127C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C1280: 40990014  ble cr6, 0x830c1294
	if !ctx.cr[6].gt {
	pc = 0x830C1294; continue 'dispatch;
	}
	// 830C1284: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1288: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C128C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C1290: 41980008  blt cr6, 0x830c1298
	if ctx.cr[6].lt {
	pc = 0x830C1298; continue 'dispatch;
	}
	// 830C1294: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1298: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C129C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C12A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C12A4: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C12A8: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C12AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C12B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C12B0 size=120
    let mut pc: u32 = 0x830C12B0;
    'dispatch: loop {
        match pc {
            0x830C12B0 => {
    //   block [0x830C12B0..0x830C1328)
	// 830C12B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C12B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C12B8: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830C12BC: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830C12C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C12C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C12C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830C12CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C12D0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830C12D4: 4BFFFDE5  bl 0x830c10b8
	ctx.lr = 0x830C12D8;
	sub_830C10B8(ctx, base);
	// 830C12D8: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C12DC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C12E0: 4099002C  ble cr6, 0x830c130c
	if !ctx.cr[6].gt {
	pc = 0x830C130C; continue 'dispatch;
	}
	// 830C12E4: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C12E8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C12EC: 40980020  bge cr6, 0x830c130c
	if !ctx.cr[6].lt {
	pc = 0x830C130C; continue 'dispatch;
	}
	// 830C12F0: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C12F4: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C12F8: 40990014  ble cr6, 0x830c130c
	if !ctx.cr[6].gt {
	pc = 0x830C130C; continue 'dispatch;
	}
	// 830C12FC: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1300: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C1304: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C1308: 41980008  blt cr6, 0x830c1310
	if ctx.cr[6].lt {
	pc = 0x830C1310; continue 'dispatch;
	}
	// 830C130C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1310: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C1314: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1318: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C131C: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C1320: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C1324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1328 size=120
    let mut pc: u32 = 0x830C1328;
    'dispatch: loop {
        match pc {
            0x830C1328 => {
    //   block [0x830C1328..0x830C13A0)
	// 830C1328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C132C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1330: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830C1334: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830C1338: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C133C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C1340: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830C1344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1348: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830C134C: 4BFFFDED  bl 0x830c1138
	ctx.lr = 0x830C1350;
	sub_830C1138(ctx, base);
	// 830C1350: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1354: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C1358: 4099002C  ble cr6, 0x830c1384
	if !ctx.cr[6].gt {
	pc = 0x830C1384; continue 'dispatch;
	}
	// 830C135C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1360: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C1364: 40980020  bge cr6, 0x830c1384
	if !ctx.cr[6].lt {
	pc = 0x830C1384; continue 'dispatch;
	}
	// 830C1368: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C136C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C1370: 40990014  ble cr6, 0x830c1384
	if !ctx.cr[6].gt {
	pc = 0x830C1384; continue 'dispatch;
	}
	// 830C1374: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1378: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C137C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C1380: 41980008  blt cr6, 0x830c1388
	if ctx.cr[6].lt {
	pc = 0x830C1388; continue 'dispatch;
	}
	// 830C1384: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1388: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C138C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C1394: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C1398: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C139C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C13A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C13A0 size=120
    let mut pc: u32 = 0x830C13A0;
    'dispatch: loop {
        match pc {
            0x830C13A0 => {
    //   block [0x830C13A0..0x830C1418)
	// 830C13A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C13A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C13A8: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830C13AC: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830C13B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C13B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C13B8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830C13BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C13C0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830C13C4: 4BFFFDF5  bl 0x830c11b8
	ctx.lr = 0x830C13C8;
	sub_830C11B8(ctx, base);
	// 830C13C8: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C13CC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C13D0: 4099002C  ble cr6, 0x830c13fc
	if !ctx.cr[6].gt {
	pc = 0x830C13FC; continue 'dispatch;
	}
	// 830C13D4: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C13D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C13DC: 40980020  bge cr6, 0x830c13fc
	if !ctx.cr[6].lt {
	pc = 0x830C13FC; continue 'dispatch;
	}
	// 830C13E0: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C13E4: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C13E8: 40990014  ble cr6, 0x830c13fc
	if !ctx.cr[6].gt {
	pc = 0x830C13FC; continue 'dispatch;
	}
	// 830C13EC: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C13F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C13F4: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 830C13F8: 41980008  blt cr6, 0x830c1400
	if ctx.cr[6].lt {
	pc = 0x830C1400; continue 'dispatch;
	}
	// 830C13FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1400: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C1404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C140C: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C1410: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C1414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C1418 size=72
    let mut pc: u32 = 0x830C1418;
    'dispatch: loop {
        match pc {
            0x830C1418 => {
    //   block [0x830C1418..0x830C1460)
	// 830C1418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C141C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1420: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C1424: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 830C1428: 419A001C  beq cr6, 0x830c1444
	if ctx.cr[6].eq {
	pc = 0x830C1444; continue 'dispatch;
	}
	// 830C142C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C1430: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C1434: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830C1438: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C143C: 4BFFFAA5  bl 0x830c0ee0
	ctx.lr = 0x830C1440;
	sub_830C0EE0(ctx, base);
	// 830C1440: 48000010  b 0x830c1450
	pc = 0x830C1450; continue 'dispatch;
	// 830C1444: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C1448: 396B4468  addi r11, r11, 0x4468
	ctx.r[11].s64 = ctx.r[11].s64 + 17512;
	// 830C144C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C1450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C1454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C145C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C1460 size=100
    let mut pc: u32 = 0x830C1460;
    'dispatch: loop {
        match pc {
            0x830C1460 => {
    //   block [0x830C1460..0x830C14C4)
	// 830C1460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C1464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C146C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C1470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C1474: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C1478: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C147C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1480: 48000028  b 0x830c14a8
	pc = 0x830C14A8; continue 'dispatch;
	// 830C1484: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1488: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C148C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C1490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C1494: 4E800421  bctrl
	ctx.lr = 0x830C1498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C149C: 4BFFE38D  bl 0x830bf828
	ctx.lr = 0x830C14A0;
	sub_830BF828(ctx, base);
	// 830C14A0: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C14A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C14A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C14AC: 409AFFD8  bne cr6, 0x830c1484
	if !ctx.cr[6].eq {
	pc = 0x830C1484; continue 'dispatch;
	}
	// 830C14B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C14B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C14B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C14BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C14C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C14C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C14C8 size=616
    let mut pc: u32 = 0x830C14C8;
    'dispatch: loop {
        match pc {
            0x830C14C8 => {
    //   block [0x830C14C8..0x830C1730)
	// 830C14C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C14CC: 480E6C9D  bl 0x831a8168
	ctx.lr = 0x830C14D0;
	sub_831A8130(ctx, base);
	// 830C14D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C14D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C14D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C14DC: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C14E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C14E4: 409A000C  bne cr6, 0x830c14f0
	if !ctx.cr[6].eq {
	pc = 0x830C14F0; continue 'dispatch;
	}
	// 830C14E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C14EC: 4800023C  b 0x830c1728
	pc = 0x830C1728; continue 'dispatch;
	// 830C14F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C14F4: C05C0008  lfs f2, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C14F8: C03C0004  lfs f1, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C14FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C1500: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C1504: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C1508: 4E800421  bctrl
	ctx.lr = 0x830C150C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C150C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1510: 40820014  bne 0x830c1524
	if !ctx.cr[0].eq {
	pc = 0x830C1524; continue 'dispatch;
	}
	// 830C1514: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C1518: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C151C: 997F0095  stb r11, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 830C1520: 48000208  b 0x830c1728
	pc = 0x830C1728; continue 'dispatch;
	// 830C1524: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C1528: 83DF0064  lwz r30, 0x64(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C152C: 4B2077ED  bl 0x822c8d18
	ctx.lr = 0x830C1530;
	sub_822C8D18(ctx, base);
	// 830C1530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1534: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C1538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C153C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1540: 409A0008  bne cr6, 0x830c1548
	if !ctx.cr[6].eq {
	pc = 0x830C1548; continue 'dispatch;
	}
	// 830C1544: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C1548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C154C: 4BFFE565  bl 0x830bfab0
	ctx.lr = 0x830C1550;
	sub_830BFAB0(ctx, base);
	// 830C1550: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C1554: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C1558: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C155C: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C1560: 4BD30731  bl 0x82df1c90
	ctx.lr = 0x830C1564;
	sub_82DF1C90(ctx, base);
	// 830C1564: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C1568: 4082FFAC  bne 0x830c1514
	if !ctx.cr[0].eq {
	pc = 0x830C1514; continue 'dispatch;
	}
	// 830C156C: 897F0095  lbz r11, 0x95(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(149 as u32) ) } as u64;
	// 830C1570: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C1574: 40820134  bne 0x830c16a8
	if !ctx.cr[0].eq {
	pc = 0x830C16A8; continue 'dispatch;
	}
	// 830C1578: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C157C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830C1580: 9BBF0097  stb r29, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[29].u8 ) };
	// 830C1584: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1588: 9BDF0095  stb r30, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[30].u8 ) };
	// 830C158C: 409A006C  bne cr6, 0x830c15f8
	if !ctx.cr[6].eq {
	pc = 0x830C15F8; continue 'dispatch;
	}
	// 830C1590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C1594: C05C0008  lfs f2, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C1598: C03C0004  lfs f1, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C159C: 4BFFFC9D  bl 0x830c1238
	ctx.lr = 0x830C15A0;
	sub_830C1238(ctx, base);
	// 830C15A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C15A4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C15A8: 409A0008  bne cr6, 0x830c15b0
	if !ctx.cr[6].eq {
	pc = 0x830C15B0; continue 'dispatch;
	}
	// 830C15AC: 9BDF0096  stb r30, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[30].u8 ) };
	// 830C15B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C15B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C15B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C15BC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C15C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C15C4: 4E800421  bctrl
	ctx.lr = 0x830C15C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C15C8: 897F0013  lbz r11, 0x13(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(19 as u32) ) } as u64;
	// 830C15CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C15D0: 409A00D8  bne cr6, 0x830c16a8
	if !ctx.cr[6].eq {
	pc = 0x830C16A8; continue 'dispatch;
	}
	// 830C15D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C15D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C15DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C15E0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C15E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C15E8: 4E800421  bctrl
	ctx.lr = 0x830C15EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C15EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C15F0: C00BA2EC  lfs f0, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C15F4: 48000034  b 0x830c1628
	pc = 0x830C1628; continue 'dispatch;
	// 830C15F8: 897F0013  lbz r11, 0x13(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(19 as u32) ) } as u64;
	// 830C15FC: 9BDF0096  stb r30, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[30].u8 ) };
	// 830C1600: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1604: 409A00A4  bne cr6, 0x830c16a8
	if !ctx.cr[6].eq {
	pc = 0x830C16A8; continue 'dispatch;
	}
	// 830C1608: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C160C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C1610: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C1614: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C161C: 4E800421  bctrl
	ctx.lr = 0x830C1620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1620: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830C1624: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1628: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C162C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C1630: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C1634: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830C1638: 40990010  ble cr6, 0x830c1648
	if !ctx.cr[6].gt {
	pc = 0x830C1648; continue 'dispatch;
	}
	// 830C163C: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1640: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830C1644: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C1648: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C164C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1650: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C1654: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830C1658: 40980010  bge cr6, 0x830c1668
	if !ctx.cr[6].lt {
	pc = 0x830C1668; continue 'dispatch;
	}
	// 830C165C: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1660: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C1664: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C1668: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C166C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C1670: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C1674: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830C1678: 40990010  ble cr6, 0x830c1688
	if !ctx.cr[6].gt {
	pc = 0x830C1688; continue 'dispatch;
	}
	// 830C167C: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1680: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830C1684: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C1688: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C168C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1690: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1694: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830C1698: 40980010  bge cr6, 0x830c16a8
	if !ctx.cr[6].lt {
	pc = 0x830C16A8; continue 'dispatch;
	}
	// 830C169C: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C16A0: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 830C16A4: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C16A8: 897F0096  lbz r11, 0x96(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 830C16AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C16B0: 419A0074  beq cr6, 0x830c1724
	if ctx.cr[6].eq {
	pc = 0x830C1724; continue 'dispatch;
	}
	// 830C16B4: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C16B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C16BC: 40820068  bne 0x830c1724
	if !ctx.cr[0].eq {
	pc = 0x830C1724; continue 'dispatch;
	}
	// 830C16C0: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C16C4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C16C8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C16CC: 48000050  b 0x830c171c
	pc = 0x830C171C; continue 'dispatch;
	// 830C16D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C16D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C16D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C16DC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C16E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C16E4: 4E800421  bctrl
	ctx.lr = 0x830C16E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C16E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C16EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C16F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C16F4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C16F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C16FC: 4E800421  bctrl
	ctx.lr = 0x830C1700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1700: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C1704: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1708: 48002209  bl 0x830c3910
	ctx.lr = 0x830C170C;
	sub_830C3910(ctx, base);
	// 830C170C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1710: 4BFFE119  bl 0x830bf828
	ctx.lr = 0x830C1714;
	sub_830BF828(ctx, base);
	// 830C1714: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C1718: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C171C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C1720: 409AFFB0  bne cr6, 0x830c16d0
	if !ctx.cr[6].eq {
	pc = 0x830C16D0; continue 'dispatch;
	}
	// 830C1724: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C1728: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830C172C: 480E6A8C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1730 size=512
    let mut pc: u32 = 0x830C1730;
    'dispatch: loop {
        match pc {
            0x830C1730 => {
    //   block [0x830C1730..0x830C1930)
	// 830C1730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C1734: 480E6A35  bl 0x831a8168
	ctx.lr = 0x830C1738;
	sub_831A8130(ctx, base);
	// 830C1738: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C173C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C1740: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830C1744: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C1748: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C174C: 9B9F0095  stb r28, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[28].u8 ) };
	// 830C1750: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1754: 409A000C  bne cr6, 0x830c1760
	if !ctx.cr[6].eq {
	pc = 0x830C1760; continue 'dispatch;
	}
	// 830C1758: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C175C: 480001CC  b 0x830c1928
	pc = 0x830C1928; continue 'dispatch;
	// 830C1760: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C1764: 83DF0064  lwz r30, 0x64(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C1768: 4B2075B1  bl 0x822c8d18
	ctx.lr = 0x830C176C;
	sub_822C8D18(ctx, base);
	// 830C176C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1774: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1778: 409A0008  bne cr6, 0x830c1780
	if !ctx.cr[6].eq {
	pc = 0x830C1780; continue 'dispatch;
	}
	// 830C177C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C1780: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C1784: 4BFFE32D  bl 0x830bfab0
	ctx.lr = 0x830C1788;
	sub_830BFAB0(ctx, base);
	// 830C1788: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C178C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C1790: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C1794: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C1798: 4BD304F9  bl 0x82df1c90
	ctx.lr = 0x830C179C;
	sub_82DF1C90(ctx, base);
	// 830C179C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C17A0: 4082FFB8  bne 0x830c1758
	if !ctx.cr[0].eq {
	pc = 0x830C1758; continue 'dispatch;
	}
	// 830C17A4: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830C17A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C17AC: 409A00EC  bne cr6, 0x830c1898
	if !ctx.cr[6].eq {
	pc = 0x830C1898; continue 'dispatch;
	}
	// 830C17B0: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C17B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C17B8: 408200E0  bne 0x830c1898
	if !ctx.cr[0].eq {
	pc = 0x830C1898; continue 'dispatch;
	}
	// 830C17BC: 897F0091  lbz r11, 0x91(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 830C17C0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C17C4: 409A0058  bne cr6, 0x830c181c
	if !ctx.cr[6].eq {
	pc = 0x830C181C; continue 'dispatch;
	}
	// 830C17C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C17CC: C05D0008  lfs f2, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C17D0: C03D0004  lfs f1, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C17D4: 4BFFFADD  bl 0x830c12b0
	ctx.lr = 0x830C17D8;
	sub_830C12B0(ctx, base);
	// 830C17D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C17DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C17E0: 409A003C  bne cr6, 0x830c181c
	if !ctx.cr[6].eq {
	pc = 0x830C181C; continue 'dispatch;
	}
	// 830C17E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C17E8: 4B207531  bl 0x822c8d18
	ctx.lr = 0x830C17EC;
	sub_822C8D18(ctx, base);
	// 830C17EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C17F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C17F4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C17F8: 409A0008  bne cr6, 0x830c1800
	if !ctx.cr[6].eq {
	pc = 0x830C1800; continue 'dispatch;
	}
	// 830C17FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C1800: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C1804: 4BFFEA6D  bl 0x830c0270
	ctx.lr = 0x830C1808;
	sub_830C0270(ctx, base);
	// 830C1808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C180C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C1810: 4BD30481  bl 0x82df1c90
	ctx.lr = 0x830C1814;
	sub_82DF1C90(ctx, base);
	// 830C1814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C1818: 48000110  b 0x830c1928
	pc = 0x830C1928; continue 'dispatch;
	// 830C181C: 897F0092  lbz r11, 0x92(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(146 as u32) ) } as u64;
	// 830C1820: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1824: 409A0034  bne cr6, 0x830c1858
	if !ctx.cr[6].eq {
	pc = 0x830C1858; continue 'dispatch;
	}
	// 830C1828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C182C: C05D0008  lfs f2, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C1830: C03D0004  lfs f1, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C1834: 4BFFFAF5  bl 0x830c1328
	ctx.lr = 0x830C1838;
	sub_830C1328(ctx, base);
	// 830C1838: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C183C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1840: 409A0018  bne cr6, 0x830c1858
	if !ctx.cr[6].eq {
	pc = 0x830C1858; continue 'dispatch;
	}
	// 830C1844: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C1848: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C184C: 4082000C  bne 0x830c1858
	if !ctx.cr[0].eq {
	pc = 0x830C1858; continue 'dispatch;
	}
	// 830C1850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C1854: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 830C1858: 897F0093  lbz r11, 0x93(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(147 as u32) ) } as u64;
	// 830C185C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1860: 409A0038  bne cr6, 0x830c1898
	if !ctx.cr[6].eq {
	pc = 0x830C1898; continue 'dispatch;
	}
	// 830C1864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C1868: C05D0008  lfs f2, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C186C: C03D0004  lfs f1, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C1870: 4BFFFB31  bl 0x830c13a0
	ctx.lr = 0x830C1874;
	sub_830C13A0(ctx, base);
	// 830C1874: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C1878: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C187C: 409A001C  bne cr6, 0x830c1898
	if !ctx.cr[6].eq {
	pc = 0x830C1898; continue 'dispatch;
	}
	// 830C1880: 897F0094  lbz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830C1884: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830C1888: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C188C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C1890: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830C1894: 997F0094  stb r11, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 830C1898: 897F0096  lbz r11, 0x96(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 830C189C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C18A0: 409A000C  bne cr6, 0x830c18ac
	if !ctx.cr[6].eq {
	pc = 0x830C18AC; continue 'dispatch;
	}
	// 830C18A4: 9B9F0096  stb r28, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[28].u8 ) };
	// 830C18A8: 4800007C  b 0x830c1924
	pc = 0x830C1924; continue 'dispatch;
	// 830C18AC: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C18B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C18B4: 4182000C  beq 0x830c18c0
	if ctx.cr[0].eq {
	pc = 0x830C18C0; continue 'dispatch;
	}
	// 830C18B8: 9B9F0097  stb r28, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[28].u8 ) };
	// 830C18BC: 48000068  b 0x830c1924
	pc = 0x830C1924; continue 'dispatch;
	// 830C18C0: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C18C4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C18C8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C18CC: 48000050  b 0x830c191c
	pc = 0x830C191C; continue 'dispatch;
	// 830C18D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C18D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C18D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C18DC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C18E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C18E4: 4E800421  bctrl
	ctx.lr = 0x830C18E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C18E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C18EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C18F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C18F4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C18F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C18FC: 4E800421  bctrl
	ctx.lr = 0x830C1900;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1900: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C1904: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1908: 48002009  bl 0x830c3910
	ctx.lr = 0x830C190C;
	sub_830C3910(ctx, base);
	// 830C190C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1910: 4BFFDF19  bl 0x830bf828
	ctx.lr = 0x830C1914;
	sub_830BF828(ctx, base);
	// 830C1914: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C1918: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C191C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C1920: 409AFFB0  bne cr6, 0x830c18d0
	if !ctx.cr[6].eq {
	pc = 0x830C18D0; continue 'dispatch;
	}
	// 830C1924: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C1928: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830C192C: 480E688C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1930 size=244
    let mut pc: u32 = 0x830C1930;
    'dispatch: loop {
        match pc {
            0x830C1930 => {
    //   block [0x830C1930..0x830C1A24)
	// 830C1930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C1934: 480E6839  bl 0x831a816c
	ctx.lr = 0x830C1938;
	sub_831A8130(ctx, base);
	// 830C1938: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C193C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C1940: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C1944: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1948: C05D0008  lfs f2, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C194C: C03D0004  lfs f1, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C1950: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C1954: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C1958: 4E800421  bctrl
	ctx.lr = 0x830C195C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C195C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1960: 418200B8  beq 0x830c1a18
	if ctx.cr[0].eq {
	pc = 0x830C1A18; continue 'dispatch;
	}
	// 830C1964: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C1968: 83DF0064  lwz r30, 0x64(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C196C: 4B2073AD  bl 0x822c8d18
	ctx.lr = 0x830C1970;
	sub_822C8D18(ctx, base);
	// 830C1970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1978: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C197C: 409A0008  bne cr6, 0x830c1984
	if !ctx.cr[6].eq {
	pc = 0x830C1984; continue 'dispatch;
	}
	// 830C1980: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1984: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C1988: 4BFFE129  bl 0x830bfab0
	ctx.lr = 0x830C198C;
	sub_830BFAB0(ctx, base);
	// 830C198C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C1990: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C1994: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C1998: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C199C: 4BD302F5  bl 0x82df1c90
	ctx.lr = 0x830C19A0;
	sub_82DF1C90(ctx, base);
	// 830C19A0: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C19A4: 40820074  bne 0x830c1a18
	if !ctx.cr[0].eq {
	pc = 0x830C1A18; continue 'dispatch;
	}
	// 830C19A8: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C19AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C19B0: 419A0068  beq cr6, 0x830c1a18
	if ctx.cr[6].eq {
	pc = 0x830C1A18; continue 'dispatch;
	}
	// 830C19B4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C19B8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C19BC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C19C0: 48000050  b 0x830c1a10
	pc = 0x830C1A10; continue 'dispatch;
	// 830C19C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C19C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C19CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C19D0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C19D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C19D8: 4E800421  bctrl
	ctx.lr = 0x830C19DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C19DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C19E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C19E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C19E8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C19EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C19F0: 4E800421  bctrl
	ctx.lr = 0x830C19F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C19F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C19F8: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C19FC: 48001F15  bl 0x830c3910
	ctx.lr = 0x830C1A00;
	sub_830C3910(ctx, base);
	// 830C1A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1A04: 4BFFDE25  bl 0x830bf828
	ctx.lr = 0x830C1A08;
	sub_830BF828(ctx, base);
	// 830C1A08: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C1A0C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C1A10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C1A14: 409AFFB0  bne cr6, 0x830c19c4
	if !ctx.cr[6].eq {
	pc = 0x830C19C4; continue 'dispatch;
	}
	// 830C1A18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1A1C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C1A20: 480E679C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C1A28 size=144
    let mut pc: u32 = 0x830C1A28;
    'dispatch: loop {
        match pc {
            0x830C1A28 => {
    //   block [0x830C1A28..0x830C1AB8)
	// 830C1A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C1A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C1A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C1A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C1A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C1A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C1A40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C1A44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C1A48: 895F0094  lbz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830C1A4C: 997F0095  stb r11, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 830C1A50: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C1A54: 997F0096  stb r11, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 830C1A58: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C1A5C: 4082000C  bne 0x830c1a68
	if !ctx.cr[0].eq {
	pc = 0x830C1A68; continue 'dispatch;
	}
	// 830C1A60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C1A64: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 830C1A68: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C1A6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1A70: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1A74: 48000020  b 0x830c1a94
	pc = 0x830C1A94; continue 'dispatch;
	// 830C1A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C1A7C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1A80: 48001E91  bl 0x830c3910
	ctx.lr = 0x830C1A84;
	sub_830C3910(ctx, base);
	// 830C1A84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C1A88: 4BFFDDA1  bl 0x830bf828
	ctx.lr = 0x830C1A8C;
	sub_830BF828(ctx, base);
	// 830C1A8C: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C1A90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C1A94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C1A98: 409AFFE0  bne cr6, 0x830c1a78
	if !ctx.cr[6].eq {
	pc = 0x830C1A78; continue 'dispatch;
	}
	// 830C1A9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C1AA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C1AA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C1AA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C1AAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C1AB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C1AB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C1AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C1AB8 size=2008
    let mut pc: u32 = 0x830C1AB8;
    'dispatch: loop {
        match pc {
            0x830C1AB8 => {
    //   block [0x830C1AB8..0x830C2290)
	// 830C1AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C1ABC: 480E66A1  bl 0x831a815c
	ctx.lr = 0x830C1AC0;
	sub_831A8130(ctx, base);
	// 830C1AC0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830C1AC4: 480E6FB1  bl 0x831a8a74
	ctx.lr = 0x830C1AC8;
	sub_831A8A40(ctx, base);
	// 830C1AC8: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C1ACC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C1AD0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830C1AD4: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C1AD8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1ADC: 409A000C  bne cr6, 0x830c1ae8
	if !ctx.cr[6].eq {
	pc = 0x830C1AE8; continue 'dispatch;
	}
	// 830C1AE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C1AE4: 4800079C  b 0x830c2280
	pc = 0x830C2280; continue 'dispatch;
	// 830C1AE8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830C1AEC: 83FC0064  lwz r31, 0x64(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C1AF0: 4B207229  bl 0x822c8d18
	ctx.lr = 0x830C1AF4;
	sub_822C8D18(ctx, base);
	// 830C1AF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1AF8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830C1AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1B00: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1B04: 409A0008  bne cr6, 0x830c1b0c
	if !ctx.cr[6].eq {
	pc = 0x830C1B0C; continue 'dispatch;
	}
	// 830C1B08: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1B0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C1B10: 4BFFDFA1  bl 0x830bfab0
	ctx.lr = 0x830C1B14;
	sub_830BFAB0(ctx, base);
	// 830C1B14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C1B18: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830C1B1C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C1B20: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C1B24: 4BD3016D  bl 0x82df1c90
	ctx.lr = 0x830C1B28;
	sub_82DF1C90(ctx, base);
	// 830C1B28: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C1B2C: 4082FFB4  bne 0x830c1ae0
	if !ctx.cr[0].eq {
	pc = 0x830C1AE0; continue 'dispatch;
	}
	// 830C1B30: 897C0095  lbz r11, 0x95(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(149 as u32) ) } as u64;
	// 830C1B34: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1B38: 409A0380  bne cr6, 0x830c1eb8
	if !ctx.cr[6].eq {
	pc = 0x830C1EB8; continue 'dispatch;
	}
	// 830C1B3C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1B40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C1B44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C1B48: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C1B4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C1B50: 4E800421  bctrl
	ctx.lr = 0x830C1B54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1B54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 830C1B58: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1B5C: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830C1B60: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1B64: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830C1B68: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C1B6C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830C1B70: C161006C  lfs f11, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C1B74: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 830C1B78: C3EB9FF4  lfs f31, -0x600c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24588 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C1B7C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 830C1B80: FF806890  fmr f28, f13
	ctx.f[28].f64 = ctx.f[13].f64;
	// 830C1B84: EFCC0028  fsubs f30, f12, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1B88: EFAB6828  fsubs f29, f11, f13
	ctx.f[29].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C1B8C: 897C0097  lbz r11, 0x97(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1B90: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1B94: 4182006C  beq 0x830c1c00
	if ctx.cr[0].eq {
	pc = 0x830C1C00; continue 'dispatch;
	}
	// 830C1B98: C1B90004  lfs f13, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1B9C: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C1BA0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C1BA4: 40980018  bge cr6, 0x830c1bbc
	if !ctx.cr[6].lt {
	pc = 0x830C1BBC; continue 'dispatch;
	}
	// 830C1BA8: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 830C1BAC: 4099001C  ble cr6, 0x830c1bc8
	if !ctx.cr[6].gt {
	pc = 0x830C1BC8; continue 'dispatch;
	}
	// 830C1BB0: EDBEF828  fsubs f13, f30, f31
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 830C1BB4: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 830C1BB8: 4800000C  b 0x830c1bc4
	pc = 0x830C1BC4; continue 'dispatch;
	// 830C1BBC: C1B90004  lfs f13, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1BC0: EFDE6828  fsubs f30, f30, f13
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C1BC4: EF6D002A  fadds f27, f13, f0
	ctx.f[27].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C1BC8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830C1BCC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 830C1BD0: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830C1BD4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830C1BD8: 4B207141  bl 0x822c8d18
	ctx.lr = 0x830C1BDC;
	sub_822C8D18(ctx, base);
	// 830C1BDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1BE4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1BE8: 409A0008  bne cr6, 0x830c1bf0
	if !ctx.cr[6].eq {
	pc = 0x830C1BF0; continue 'dispatch;
	}
	// 830C1BEC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1BF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1BF4: 4BFFDEA5  bl 0x830bfa98
	ctx.lr = 0x830C1BF8;
	sub_830BFA98(ctx, base);
	// 830C1BF8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 830C1BFC: 4BD30095  bl 0x82df1c90
	ctx.lr = 0x830C1C00;
	sub_82DF1C90(ctx, base);
	// 830C1C00: 897C0097  lbz r11, 0x97(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1C04: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1C08: 4182004C  beq 0x830c1c54
	if ctx.cr[0].eq {
	pc = 0x830C1C54; continue 'dispatch;
	}
	// 830C1C0C: C0190004  lfs f0, 4(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1C10: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 830C1C14: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 830C1C18: 40980008  bge cr6, 0x830c1c20
	if !ctx.cr[6].lt {
	pc = 0x830C1C20; continue 'dispatch;
	}
	// 830C1C1C: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 830C1C20: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830C1C24: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830C1C28: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830C1C2C: 4B2070ED  bl 0x822c8d18
	ctx.lr = 0x830C1C30;
	sub_822C8D18(ctx, base);
	// 830C1C30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1C34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1C38: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1C3C: 409A0008  bne cr6, 0x830c1c44
	if !ctx.cr[6].eq {
	pc = 0x830C1C44; continue 'dispatch;
	}
	// 830C1C40: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1C44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1C48: 4BFFDE51  bl 0x830bfa98
	ctx.lr = 0x830C1C4C;
	sub_830BFA98(ctx, base);
	// 830C1C4C: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830C1C50: 4BD30041  bl 0x82df1c90
	ctx.lr = 0x830C1C54;
	sub_82DF1C90(ctx, base);
	// 830C1C54: 897C0097  lbz r11, 0x97(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1C58: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C1C5C: 418200E4  beq 0x830c1d40
	if ctx.cr[0].eq {
	pc = 0x830C1D40; continue 'dispatch;
	}
	// 830C1C60: C0190008  lfs f0, 8(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1C64: EC1D0028  fsubs f0, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1C68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830C1C6C: 40980018  bge cr6, 0x830c1c84
	if !ctx.cr[6].lt {
	pc = 0x830C1C84; continue 'dispatch;
	}
	// 830C1C70: FF1DF800  fcmpu cr6, f29, f31
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[31].f64);
	// 830C1C74: 4099001C  ble cr6, 0x830c1c90
	if !ctx.cr[6].gt {
	pc = 0x830C1C90; continue 'dispatch;
	}
	// 830C1C78: EC1DF828  fsubs f0, f29, f31
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 830C1C7C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 830C1C80: 4800000C  b 0x830c1c8c
	pc = 0x830C1C8C; continue 'dispatch;
	// 830C1C84: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1C88: EFBD0028  fsubs f29, f29, f0
	ctx.f[29].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1C8C: EF80E02A  fadds f28, f0, f28
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 830C1C90: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C1C94: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830C1C98: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830C1C9C: 41820038  beq 0x830c1cd4
	if ctx.cr[0].eq {
	pc = 0x830C1CD4; continue 'dispatch;
	}
	// 830C1CA0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830C1CA4: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 830C1CA8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1CAC: 4B20706D  bl 0x822c8d18
	ctx.lr = 0x830C1CB0;
	sub_822C8D18(ctx, base);
	// 830C1CB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1CB8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1CBC: 409A0008  bne cr6, 0x830c1cc4
	if !ctx.cr[6].eq {
	pc = 0x830C1CC4; continue 'dispatch;
	}
	// 830C1CC0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1CC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1CC8: 4BFFDDD1  bl 0x830bfa98
	ctx.lr = 0x830C1CCC;
	sub_830BFA98(ctx, base);
	// 830C1CCC: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 830C1CD0: 4800006C  b 0x830c1d3c
	pc = 0x830C1D3C; continue 'dispatch;
	// 830C1CD4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1CD8: 41820038  beq 0x830c1d10
	if ctx.cr[0].eq {
	pc = 0x830C1D10; continue 'dispatch;
	}
	// 830C1CDC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830C1CE0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C1CE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1CE8: 4B207031  bl 0x822c8d18
	ctx.lr = 0x830C1CEC;
	sub_822C8D18(ctx, base);
	// 830C1CEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1CF4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1CF8: 409A0008  bne cr6, 0x830c1d00
	if !ctx.cr[6].eq {
	pc = 0x830C1D00; continue 'dispatch;
	}
	// 830C1CFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1D00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1D04: 4BFFDD95  bl 0x830bfa98
	ctx.lr = 0x830C1D08;
	sub_830BFA98(ctx, base);
	// 830C1D08: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C1D0C: 48000030  b 0x830c1d3c
	pc = 0x830C1D3C; continue 'dispatch;
	// 830C1D10: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 830C1D14: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C1D18: 4B207001  bl 0x822c8d18
	ctx.lr = 0x830C1D1C;
	sub_822C8D18(ctx, base);
	// 830C1D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1D24: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1D28: 409A0008  bne cr6, 0x830c1d30
	if !ctx.cr[6].eq {
	pc = 0x830C1D30; continue 'dispatch;
	}
	// 830C1D2C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1D30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1D34: 4BFFDD65  bl 0x830bfa98
	ctx.lr = 0x830C1D38;
	sub_830BFA98(ctx, base);
	// 830C1D38: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C1D3C: 4BD2FF55  bl 0x82df1c90
	ctx.lr = 0x830C1D40;
	sub_82DF1C90(ctx, base);
	// 830C1D40: 897C0097  lbz r11, 0x97(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1D44: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C1D48: 418200C4  beq 0x830c1e0c
	if ctx.cr[0].eq {
	pc = 0x830C1E0C; continue 'dispatch;
	}
	// 830C1D4C: C0190008  lfs f0, 8(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1D50: EFA0E82A  fadds f29, f0, f29
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 830C1D54: FF1DF800  fcmpu cr6, f29, f31
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[31].f64);
	// 830C1D58: 40980008  bge cr6, 0x830c1d60
	if !ctx.cr[6].lt {
	pc = 0x830C1D60; continue 'dispatch;
	}
	// 830C1D5C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 830C1D60: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C1D64: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830C1D68: 41820038  beq 0x830c1da0
	if ctx.cr[0].eq {
	pc = 0x830C1DA0; continue 'dispatch;
	}
	// 830C1D6C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 830C1D70: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 830C1D74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1D78: 4B206FA1  bl 0x822c8d18
	ctx.lr = 0x830C1D7C;
	sub_822C8D18(ctx, base);
	// 830C1D7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1D84: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1D88: 409A0008  bne cr6, 0x830c1d90
	if !ctx.cr[6].eq {
	pc = 0x830C1D90; continue 'dispatch;
	}
	// 830C1D8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1D90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1D94: 4BFFDD05  bl 0x830bfa98
	ctx.lr = 0x830C1D98;
	sub_830BFA98(ctx, base);
	// 830C1D98: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 830C1D9C: 4800006C  b 0x830c1e08
	pc = 0x830C1E08; continue 'dispatch;
	// 830C1DA0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1DA4: 41820038  beq 0x830c1ddc
	if ctx.cr[0].eq {
	pc = 0x830C1DDC; continue 'dispatch;
	}
	// 830C1DA8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 830C1DAC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830C1DB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1DB4: 4B206F65  bl 0x822c8d18
	ctx.lr = 0x830C1DB8;
	sub_822C8D18(ctx, base);
	// 830C1DB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1DC0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1DC4: 409A0008  bne cr6, 0x830c1dcc
	if !ctx.cr[6].eq {
	pc = 0x830C1DCC; continue 'dispatch;
	}
	// 830C1DC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1DCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1DD0: 4BFFDCC9  bl 0x830bfa98
	ctx.lr = 0x830C1DD4;
	sub_830BFA98(ctx, base);
	// 830C1DD4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830C1DD8: 48000030  b 0x830c1e08
	pc = 0x830C1E08; continue 'dispatch;
	// 830C1DDC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 830C1DE0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 830C1DE4: 4B206F35  bl 0x822c8d18
	ctx.lr = 0x830C1DE8;
	sub_822C8D18(ctx, base);
	// 830C1DE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1DF0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1DF4: 409A0008  bne cr6, 0x830c1dfc
	if !ctx.cr[6].eq {
	pc = 0x830C1DFC; continue 'dispatch;
	}
	// 830C1DF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1E00: 4BFFDC99  bl 0x830bfa98
	ctx.lr = 0x830C1E04;
	sub_830BFA98(ctx, base);
	// 830C1E04: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 830C1E08: 4BD2FE89  bl 0x82df1c90
	ctx.lr = 0x830C1E0C;
	sub_82DF1C90(ctx, base);
	// 830C1E0C: 897C0097  lbz r11, 0x97(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C1E10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C1E14: 40820030  bne 0x830c1e44
	if !ctx.cr[0].eq {
	pc = 0x830C1E44; continue 'dispatch;
	}
	// 830C1E18: 897C0012  lbz r11, 0x12(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(18 as u32) ) } as u64;
	// 830C1E1C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1E20: 409A0024  bne cr6, 0x830c1e44
	if !ctx.cr[6].eq {
	pc = 0x830C1E44; continue 'dispatch;
	}
	// 830C1E24: 897C0096  lbz r11, 0x96(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(150 as u32) ) } as u64;
	// 830C1E28: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1E2C: 409A0018  bne cr6, 0x830c1e44
	if !ctx.cr[6].eq {
	pc = 0x830C1E44; continue 'dispatch;
	}
	// 830C1E30: C0190004  lfs f0, 4(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1E34: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830C1E38: C1B90008  lfs f13, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1E3C: EF60D82A  fadds f27, f0, f27
	ctx.f[27].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 830C1E40: EF8DE02A  fadds f28, f13, f28
	ctx.f[28].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 830C1E44: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 830C1E48: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1E4C: 409A0028  bne cr6, 0x830c1e74
	if !ctx.cr[6].eq {
	pc = 0x830C1E74; continue 'dispatch;
	}
	// 830C1E50: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 830C1E54: D3610094  stfs f27, 0x94(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830C1E58: D3810098  stfs f28, 0x98(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830C1E5C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 830C1E60: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830C1E64: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 830C1E68: D3A100A0  stfs f29, 0xa0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830C1E6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C1E70: 48001AA1  bl 0x830c3910
	ctx.lr = 0x830C1E74;
	sub_830C3910(ctx, base);
	// 830C1E74: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 830C1E78: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1E7C: 409A0028  bne cr6, 0x830c1ea4
	if !ctx.cr[6].eq {
	pc = 0x830C1EA4; continue 'dispatch;
	}
	// 830C1E80: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 830C1E84: D3610074  stfs f27, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C1E88: D3810078  stfs f28, 0x78(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830C1E8C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C1E90: D3C1007C  stfs f30, 0x7c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830C1E94: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830C1E98: D3A10080  stfs f29, 0x80(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830C1E9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C1EA0: 48001A71  bl 0x830c3910
	ctx.lr = 0x830C1EA4;
	sub_830C3910(ctx, base);
	// 830C1EA4: D3DC0020  stfs f30, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830C1EA8: D3BC0024  stfs f29, 0x24(r28)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830C1EAC: D37C0030  stfs f27, 0x30(r28)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C1EB0: D39C0034  stfs f28, 0x34(r28)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C1EB4: 4800034C  b 0x830c2200
	pc = 0x830C2200; continue 'dispatch;
	// 830C1EB8: 897C0013  lbz r11, 0x13(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(19 as u32) ) } as u64;
	// 830C1EBC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C1EC0: 409A0340  bne cr6, 0x830c2200
	if !ctx.cr[6].eq {
	pc = 0x830C2200; continue 'dispatch;
	}
	// 830C1EC4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C1EC8: 4B206E51  bl 0x822c8d18
	ctx.lr = 0x830C1ECC;
	sub_822C8D18(ctx, base);
	// 830C1ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1ED4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1ED8: 409A0008  bne cr6, 0x830c1ee0
	if !ctx.cr[6].eq {
	pc = 0x830C1EE0; continue 'dispatch;
	}
	// 830C1EDC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1EE0: 4BFFDBA1  bl 0x830bfa80
	ctx.lr = 0x830C1EE4;
	sub_830BFA80(ctx, base);
	// 830C1EE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C1EE8: 39410150  addi r10, r1, 0x150
	ctx.r[10].s64 = ctx.r[1].s64 + 336;
	// 830C1EEC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 830C1EF0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830C1EF4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1EF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C1EFC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830C1F00: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830C1F04: 4200FFF0  bdnz 0x830c1ef4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830C1EF4; continue 'dispatch;
	}
	// 830C1F08: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C1F0C: 4BD2FD85  bl 0x82df1c90
	ctx.lr = 0x830C1F10;
	sub_82DF1C90(ctx, base);
	// 830C1F10: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1F14: C3C10154  lfs f30, 0x154(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830C1F18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C1F1C: C3E10150  lfs f31, 0x150(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C1F20: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830C1F24: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C1F28: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C1F2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C1F30: 4E800421  bctrl
	ctx.lr = 0x830C1F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1F34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C1F38: 41820298  beq 0x830c21d0
	if ctx.cr[0].eq {
	pc = 0x830C21D0; continue 'dispatch;
	}
	// 830C1F3C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1F40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C1F44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C1F48: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C1F4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C1F50: 4E800421  bctrl
	ctx.lr = 0x830C1F54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C1F54: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C1F58: C1A10060  lfs f13, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1F5C: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830C1F60: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830C1F64: C00AA2EC  lfs f0, -0x5d14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C1F68: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C1F6C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C1F70: 40990008  ble cr6, 0x830c1f78
	if !ctx.cr[6].gt {
	pc = 0x830C1F78; continue 'dispatch;
	}
	// 830C1F74: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830C1F78: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1F7C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1F80: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C1F84: 4098000C  bge cr6, 0x830c1f90
	if !ctx.cr[6].lt {
	pc = 0x830C1F90; continue 'dispatch;
	}
	// 830C1F88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C1F8C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C1F90: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1F94: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C1F98: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830C1F9C: 4099000C  ble cr6, 0x830c1fa8
	if !ctx.cr[6].gt {
	pc = 0x830C1FA8; continue 'dispatch;
	}
	// 830C1FA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C1FA4: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830C1FA8: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C1FAC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C1FB0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830C1FB4: 4098000C  bge cr6, 0x830c1fc0
	if !ctx.cr[6].lt {
	pc = 0x830C1FC0; continue 'dispatch;
	}
	// 830C1FB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C1FBC: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 830C1FC0: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C1FC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C1FC8: 418200B4  beq 0x830c207c
	if ctx.cr[0].eq {
	pc = 0x830C207C; continue 'dispatch;
	}
	// 830C1FCC: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C1FD0: 41820038  beq 0x830c2008
	if ctx.cr[0].eq {
	pc = 0x830C2008; continue 'dispatch;
	}
	// 830C1FD4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830C1FD8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 830C1FDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C1FE0: 4B206D39  bl 0x822c8d18
	ctx.lr = 0x830C1FE4;
	sub_822C8D18(ctx, base);
	// 830C1FE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C1FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C1FEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C1FF0: 409A0008  bne cr6, 0x830c1ff8
	if !ctx.cr[6].eq {
	pc = 0x830C1FF8; continue 'dispatch;
	}
	// 830C1FF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C1FF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C1FFC: 4BFFDA9D  bl 0x830bfa98
	ctx.lr = 0x830C2000;
	sub_830BFA98(ctx, base);
	// 830C2000: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 830C2004: 48000070  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C2008: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C200C: 41820038  beq 0x830c2044
	if ctx.cr[0].eq {
	pc = 0x830C2044; continue 'dispatch;
	}
	// 830C2010: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830C2014: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830C2018: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C201C: 4B206CFD  bl 0x822c8d18
	ctx.lr = 0x830C2020;
	sub_822C8D18(ctx, base);
	// 830C2020: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2028: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C202C: 409A0008  bne cr6, 0x830c2034
	if !ctx.cr[6].eq {
	pc = 0x830C2034; continue 'dispatch;
	}
	// 830C2030: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C2034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2038: 4BFFDA61  bl 0x830bfa98
	ctx.lr = 0x830C203C;
	sub_830BFA98(ctx, base);
	// 830C203C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830C2040: 48000034  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C2044: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C2048: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C204C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2050: 4B206CC9  bl 0x822c8d18
	ctx.lr = 0x830C2054;
	sub_822C8D18(ctx, base);
	// 830C2054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C205C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C2060: 409A0008  bne cr6, 0x830c2068
	if !ctx.cr[6].eq {
	pc = 0x830C2068; continue 'dispatch;
	}
	// 830C2064: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C2068: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C206C: 4BFFDA2D  bl 0x830bfa98
	ctx.lr = 0x830C2070;
	sub_830BFA98(ctx, base);
	// 830C2070: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C2074: 4BD2FC1D  bl 0x82df1c90
	ctx.lr = 0x830C2078;
	sub_82DF1C90(ctx, base);
	// 830C2078: 48000204  b 0x830c227c
	pc = 0x830C227C; continue 'dispatch;
	// 830C207C: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C2080: 418200B0  beq 0x830c2130
	if ctx.cr[0].eq {
	pc = 0x830C2130; continue 'dispatch;
	}
	// 830C2084: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C2088: 41820038  beq 0x830c20c0
	if ctx.cr[0].eq {
	pc = 0x830C20C0; continue 'dispatch;
	}
	// 830C208C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 830C2090: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830C2094: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2098: 4B206C81  bl 0x822c8d18
	ctx.lr = 0x830C209C;
	sub_822C8D18(ctx, base);
	// 830C209C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C20A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C20A4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C20A8: 409A0008  bne cr6, 0x830c20b0
	if !ctx.cr[6].eq {
	pc = 0x830C20B0; continue 'dispatch;
	}
	// 830C20AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C20B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C20B4: 4BFFD9E5  bl 0x830bfa98
	ctx.lr = 0x830C20B8;
	sub_830BFA98(ctx, base);
	// 830C20B8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830C20BC: 4BFFFFB8  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C20C0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C20C4: 41820038  beq 0x830c20fc
	if ctx.cr[0].eq {
	pc = 0x830C20FC; continue 'dispatch;
	}
	// 830C20C8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 830C20CC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830C20D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C20D4: 4B206C45  bl 0x822c8d18
	ctx.lr = 0x830C20D8;
	sub_822C8D18(ctx, base);
	// 830C20D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C20DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C20E0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C20E4: 409A0008  bne cr6, 0x830c20ec
	if !ctx.cr[6].eq {
	pc = 0x830C20EC; continue 'dispatch;
	}
	// 830C20E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C20EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C20F0: 4BFFD9A9  bl 0x830bfa98
	ctx.lr = 0x830C20F4;
	sub_830BFA98(ctx, base);
	// 830C20F4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830C20F8: 4BFFFF7C  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C20FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C2100: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 830C2104: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2108: 4B206C11  bl 0x822c8d18
	ctx.lr = 0x830C210C;
	sub_822C8D18(ctx, base);
	// 830C210C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2114: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C2118: 409A0008  bne cr6, 0x830c2120
	if !ctx.cr[6].eq {
	pc = 0x830C2120; continue 'dispatch;
	}
	// 830C211C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C2120: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2124: 4BFFD975  bl 0x830bfa98
	ctx.lr = 0x830C2128;
	sub_830BFA98(ctx, base);
	// 830C2128: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 830C212C: 4BFFFF48  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C2130: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C2134: 41820034  beq 0x830c2168
	if ctx.cr[0].eq {
	pc = 0x830C2168; continue 'dispatch;
	}
	// 830C2138: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830C213C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830C2140: 4B206BD9  bl 0x822c8d18
	ctx.lr = 0x830C2144;
	sub_822C8D18(ctx, base);
	// 830C2144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C214C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C2150: 409A0008  bne cr6, 0x830c2158
	if !ctx.cr[6].eq {
	pc = 0x830C2158; continue 'dispatch;
	}
	// 830C2154: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C2158: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C215C: 4BFFD93D  bl 0x830bfa98
	ctx.lr = 0x830C2160;
	sub_830BFA98(ctx, base);
	// 830C2160: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830C2164: 4BFFFF10  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C2168: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C216C: 41820034  beq 0x830c21a0
	if ctx.cr[0].eq {
	pc = 0x830C21A0; continue 'dispatch;
	}
	// 830C2170: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830C2174: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 830C2178: 4B206BA1  bl 0x822c8d18
	ctx.lr = 0x830C217C;
	sub_822C8D18(ctx, base);
	// 830C217C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2184: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C2188: 409A0008  bne cr6, 0x830c2190
	if !ctx.cr[6].eq {
	pc = 0x830C2190; continue 'dispatch;
	}
	// 830C218C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C2190: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2194: 4BFFD905  bl 0x830bfa98
	ctx.lr = 0x830C2198;
	sub_830BFA98(ctx, base);
	// 830C2198: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 830C219C: 4BFFFED8  b 0x830c2074
	pc = 0x830C2074; continue 'dispatch;
	// 830C21A0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830C21A4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 830C21A8: 4B206B71  bl 0x822c8d18
	ctx.lr = 0x830C21AC;
	sub_822C8D18(ctx, base);
	// 830C21AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C21B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C21B4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C21B8: 409A0008  bne cr6, 0x830c21c0
	if !ctx.cr[6].eq {
	pc = 0x830C21C0; continue 'dispatch;
	}
	// 830C21BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C21C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C21C4: 4BFFD8D5  bl 0x830bfa98
	ctx.lr = 0x830C21C8;
	sub_830BFA98(ctx, base);
	// 830C21C8: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 830C21CC: 48000030  b 0x830c21fc
	pc = 0x830C21FC; continue 'dispatch;
	// 830C21D0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830C21D4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 830C21D8: 4B206B41  bl 0x822c8d18
	ctx.lr = 0x830C21DC;
	sub_822C8D18(ctx, base);
	// 830C21DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C21E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C21E4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C21E8: 409A0008  bne cr6, 0x830c21f0
	if !ctx.cr[6].eq {
	pc = 0x830C21F0; continue 'dispatch;
	}
	// 830C21EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C21F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C21F4: 4BFFD8A5  bl 0x830bfa98
	ctx.lr = 0x830C21F8;
	sub_830BFA98(ctx, base);
	// 830C21F8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 830C21FC: 4BD2FA95  bl 0x82df1c90
	ctx.lr = 0x830C2200;
	sub_82DF1C90(ctx, base);
	// 830C2200: 897C0096  lbz r11, 0x96(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(150 as u32) ) } as u64;
	// 830C2204: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C2208: 419A0074  beq cr6, 0x830c227c
	if ctx.cr[6].eq {
	pc = 0x830C227C; continue 'dispatch;
	}
	// 830C220C: 897C0097  lbz r11, 0x97(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(151 as u32) ) } as u64;
	// 830C2210: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C2214: 40820068  bne 0x830c227c
	if !ctx.cr[0].eq {
	pc = 0x830C227C; continue 'dispatch;
	}
	// 830C2218: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C221C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2220: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830C2224: 48000050  b 0x830c2274
	pc = 0x830C2274; continue 'dispatch;
	// 830C2228: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C222C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C2230: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2234: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C2238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C223C: 4E800421  bctrl
	ctx.lr = 0x830C2240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2240: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2244: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C2248: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 830C224C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C2250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C2254: 4E800421  bctrl
	ctx.lr = 0x830C2258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2258: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830C225C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C2260: 480016B1  bl 0x830c3910
	ctx.lr = 0x830C2264;
	sub_830C3910(ctx, base);
	// 830C2264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C2268: 4BFFD5C1  bl 0x830bf828
	ctx.lr = 0x830C226C;
	sub_830BF828(ctx, base);
	// 830C226C: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C2270: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C2274: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C2278: 409AFFB0  bne cr6, 0x830c2228
	if !ctx.cr[6].eq {
	pc = 0x830C2228; continue 'dispatch;
	}
	// 830C227C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C2280: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 830C2284: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830C2288: 480E6839  bl 0x831a8ac0
	ctx.lr = 0x830C228C;
	sub_831A8A8C(ctx, base);
	// 830C228C: 480E5F20  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2290 size=108
    let mut pc: u32 = 0x830C2290;
    'dispatch: loop {
        match pc {
            0x830C2290 => {
    //   block [0x830C2290..0x830C22FC)
	// 830C2290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C2298: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C229C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C22A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C22A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C22A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C22AC: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C22B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C22B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C22B8: 48000020  b 0x830c22d8
	pc = 0x830C22D8; continue 'dispatch;
	// 830C22BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C22C0: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C22C4: 4800164D  bl 0x830c3910
	ctx.lr = 0x830C22C8;
	sub_830C3910(ctx, base);
	// 830C22C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C22CC: 4BFFD55D  bl 0x830bf828
	ctx.lr = 0x830C22D0;
	sub_830BF828(ctx, base);
	// 830C22D0: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C22D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C22D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C22DC: 409AFFE0  bne cr6, 0x830c22bc
	if !ctx.cr[6].eq {
	pc = 0x830C22BC; continue 'dispatch;
	}
	// 830C22E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C22E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C22E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C22EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C22F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C22F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C22F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2300 size=136
    let mut pc: u32 = 0x830C2300;
    'dispatch: loop {
        match pc {
            0x830C2300 => {
    //   block [0x830C2300..0x830C2388)
	// 830C2300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C2308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C230C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C2310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C2314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C2318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C231C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C2320: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C2324: 997F0095  stb r11, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 830C2328: 997F0096  stb r11, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 830C232C: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830C2330: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2334: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2338: 4800002C  b 0x830c2364
	pc = 0x830C2364; continue 'dispatch;
	// 830C233C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C2340: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C2344: 419A0010  beq cr6, 0x830c2354
	if ctx.cr[6].eq {
	pc = 0x830C2354; continue 'dispatch;
	}
	// 830C2348: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C234C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830C2350: 480015C1  bl 0x830c3910
	ctx.lr = 0x830C2354;
	sub_830C3910(ctx, base);
	// 830C2354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C2358: 4BFFD4D1  bl 0x830bf828
	ctx.lr = 0x830C235C;
	sub_830BF828(ctx, base);
	// 830C235C: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C2360: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C2364: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C2368: 409AFFD4  bne cr6, 0x830c233c
	if !ctx.cr[6].eq {
	pc = 0x830C233C; continue 'dispatch;
	}
	// 830C236C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C2370: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C2374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C2378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C237C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C2380: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C2384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2388 size=120
    let mut pc: u32 = 0x830C2388;
    'dispatch: loop {
        match pc {
            0x830C2388 => {
    //   block [0x830C2388..0x830C2400)
	// 830C2388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C238C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C2390: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C2394: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C2398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C239C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C23A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C23A4: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C23A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C23AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C23B0: 4800002C  b 0x830c23dc
	pc = 0x830C23DC; continue 'dispatch;
	// 830C23B4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C23B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C23BC: 419A0010  beq cr6, 0x830c23cc
	if ctx.cr[6].eq {
	pc = 0x830C23CC; continue 'dispatch;
	}
	// 830C23C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C23C4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830C23C8: 48001549  bl 0x830c3910
	ctx.lr = 0x830C23CC;
	sub_830C3910(ctx, base);
	// 830C23CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C23D0: 4BFFD459  bl 0x830bf828
	ctx.lr = 0x830C23D4;
	sub_830BF828(ctx, base);
	// 830C23D4: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C23D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C23DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C23E0: 409AFFD4  bne cr6, 0x830c23b4
	if !ctx.cr[6].eq {
	pc = 0x830C23B4; continue 'dispatch;
	}
	// 830C23E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C23E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C23EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C23F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C23F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C23F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C23FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C2400 size=1408
    let mut pc: u32 = 0x830C2400;
    'dispatch: loop {
        match pc {
            0x830C2400 => {
    //   block [0x830C2400..0x830C2980)
	// 830C2400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2404: 480E5D61  bl 0x831a8164
	ctx.lr = 0x830C2408;
	sub_831A8130(ctx, base);
	// 830C2408: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 830C240C: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 830C2410: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 830C2414: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C2418: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C241C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C2420: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830C2424: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C2428: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C242C: 409A04EC  bne cr6, 0x830c2918
	if !ctx.cr[6].eq {
	pc = 0x830C2918; continue 'dispatch;
	}
	// 830C2430: 48006EB1  bl 0x830c92e0
	ctx.lr = 0x830C2434;
	sub_830C92E0(ctx, base);
	// 830C2434: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C2438: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 830C243C: 40820110  bne 0x830c254c
	if !ctx.cr[0].eq {
	pc = 0x830C254C; continue 'dispatch;
	}
	// 830C2440: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 830C2444: 4B2068D5  bl 0x822c8d18
	ctx.lr = 0x830C2448;
	sub_822C8D18(ctx, base);
	// 830C2448: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C244C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2450: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 830C2454: 409A0008  bne cr6, 0x830c245c
	if !ctx.cr[6].eq {
	pc = 0x830C245C; continue 'dispatch;
	}
	// 830C2458: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C245C: 806B0058  lwz r3, 0x58(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C2460: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C2464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C2468: 419A0024  beq cr6, 0x830c248c
	if ctx.cr[6].eq {
	pc = 0x830C248C; continue 'dispatch;
	}
	// 830C246C: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 830C2470: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 830C2474: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C2478: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 830C247C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830C2480: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C2484: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C2488: 4082FFE8  bne 0x830c2470
	if !ctx.cr[0].eq {
	pc = 0x830C2470; continue 'dispatch;
	}
	// 830C248C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830C2490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C2494: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C2498: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C249C: 419A0008  beq cr6, 0x830c24a4
	if ctx.cr[6].eq {
	pc = 0x830C24A4; continue 'dispatch;
	}
	// 830C24A0: 4B1FE3F1  bl 0x822c0890
	ctx.lr = 0x830C24A4;
	sub_822C0890(ctx, base);
	// 830C24A4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 830C24A8: 4BD2F7E9  bl 0x82df1c90
	ctx.lr = 0x830C24AC;
	sub_82DF1C90(ctx, base);
	// 830C24AC: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C24B0: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 830C24B4: 41820010  beq 0x830c24c4
	if ctx.cr[0].eq {
	pc = 0x830C24C4; continue 'dispatch;
	}
	// 830C24B8: 396000E6  li r11, 0xe6
	ctx.r[11].s64 = 230;
	// 830C24BC: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 830C24C0: 4800000C  b 0x830c24cc
	pc = 0x830C24CC; continue 'dispatch;
	// 830C24C4: 396000BE  li r11, 0xbe
	ctx.r[11].s64 = 190;
	// 830C24C8: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 830C24CC: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 830C24D0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 830C24D4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 830C24D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C24DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C24E0: 4B206839  bl 0x822c8d18
	ctx.lr = 0x830C24E4;
	sub_822C8D18(ctx, base);
	// 830C24E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C24E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C24EC: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 830C24F0: 409A0008  bne cr6, 0x830c24f8
	if !ctx.cr[6].eq {
	pc = 0x830C24F8; continue 'dispatch;
	}
	// 830C24F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C24F8: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 830C24FC: 8BEB0018  lbz r31, 0x18(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C2500: 4BD2F791  bl 0x82df1c90
	ctx.lr = 0x830C2504;
	sub_82DF1C90(ctx, base);
	// 830C2504: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 830C2508: 409A0058  bne cr6, 0x830c2560
	if !ctx.cr[6].eq {
	pc = 0x830C2560; continue 'dispatch;
	}
	// 830C250C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 830C2510: 4B206809  bl 0x822c8d18
	ctx.lr = 0x830C2514;
	sub_822C8D18(ctx, base);
	// 830C2514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C251C: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 830C2520: 409A0008  bne cr6, 0x830c2528
	if !ctx.cr[6].eq {
	pc = 0x830C2528; continue 'dispatch;
	}
	// 830C2524: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C2528: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C252C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 830C2530: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 830C2534: 4BD2F75D  bl 0x82df1c90
	ctx.lr = 0x830C2538;
	sub_82DF1C90(ctx, base);
	// 830C2538: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C253C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C2540: 48000B61  bl 0x830c30a0
	ctx.lr = 0x830C2544;
	sub_830C30A0(ctx, base);
	// 830C2544: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830C2548: 48000018  b 0x830c2560
	pc = 0x830C2560; continue 'dispatch;
	// 830C254C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C2550: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C2554: 48000B7D  bl 0x830c30d0
	ctx.lr = 0x830C2558;
	sub_830C30D0(ctx, base);
	// 830C2558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C255C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2560: 897E0011  lbz r11, 0x11(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(17 as u32) ) } as u64;
	// 830C2564: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C2568: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C256C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C2570: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830C2574: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C2578: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C257C: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C2580: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830C2584: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 830C2588: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830C258C: 4E800421  bctrl
	ctx.lr = 0x830C2590;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2590: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 830C2594: 4B206785  bl 0x822c8d18
	ctx.lr = 0x830C2598;
	sub_822C8D18(ctx, base);
	// 830C2598: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C259C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C25A0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C25A4: 409A0008  bne cr6, 0x830c25ac
	if !ctx.cr[6].eq {
	pc = 0x830C25AC; continue 'dispatch;
	}
	// 830C25A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C25AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C25B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C25B4: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C25B8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830C25BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830C25C0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830C25C4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C25C8: C3EB9594  lfs f31, -0x6a6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C25CC: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C25D0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 830C25D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C25D8: 4E800421  bctrl
	ctx.lr = 0x830C25DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C25DC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 830C25E0: 4BD2F6B1  bl 0x82df1c90
	ctx.lr = 0x830C25E4;
	sub_82DF1C90(ctx, base);
	// 830C25E4: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 830C25E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C25EC: 409A032C  bne cr6, 0x830c2918
	if !ctx.cr[6].eq {
	pc = 0x830C2918; continue 'dispatch;
	}
	// 830C25F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C25F4: 48006CED  bl 0x830c92e0
	ctx.lr = 0x830C25F8;
	sub_830C92E0(ctx, base);
	// 830C25F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C25FC: 4082001C  bne 0x830c2618
	if !ctx.cr[0].eq {
	pc = 0x830C2618; continue 'dispatch;
	}
	// 830C2600: 9BA10054  stb r29, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u8 ) };
	// 830C2604: 9BA10056  stb r29, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[29].u8 ) };
	// 830C2608: 9BA10057  stb r29, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[29].u8 ) };
	// 830C260C: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 830C2610: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C2614: 48000014  b 0x830c2628
	pc = 0x830C2628; continue 'dispatch;
	// 830C2618: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C261C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C2620: 48000AB1  bl 0x830c30d0
	ctx.lr = 0x830C2624;
	sub_830C30D0(ctx, base);
	// 830C2624: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2628: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C262C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C2630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2634: 4BFFEA25  bl 0x830c1058
	ctx.lr = 0x830C2638;
	sub_830C1058(ctx, base);
	// 830C2638: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 830C263C: 4B2066DD  bl 0x822c8d18
	ctx.lr = 0x830C2640;
	sub_822C8D18(ctx, base);
	// 830C2640: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2648: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C264C: 409A0008  bne cr6, 0x830c2654
	if !ctx.cr[6].eq {
	pc = 0x830C2654; continue 'dispatch;
	}
	// 830C2650: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C2654: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C2658: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C265C: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C2660: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 830C2664: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830C2668: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830C266C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830C2670: C3AB0A98  lfs f29, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830C2674: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C2678: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 830C267C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C2680: 4E800421  bctrl
	ctx.lr = 0x830C2684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2684: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 830C2688: 4BD2F609  bl 0x82df1c90
	ctx.lr = 0x830C268C;
	sub_82DF1C90(ctx, base);
	// 830C268C: 389E0048  addi r4, r30, 0x48
	ctx.r[4].s64 = ctx.r[30].s64 + 72;
	// 830C2690: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 830C2694: 4B2077C5  bl 0x822c9e58
	ctx.lr = 0x830C2698;
	sub_822C9E58(ctx, base);
	// 830C2698: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 830C269C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 830C26A0: 83E10134  lwz r31, 0x134(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 830C26A4: 40980008  bge cr6, 0x830c26ac
	if !ctx.cr[6].lt {
	pc = 0x830C26AC; continue 'dispatch;
	}
	// 830C26A8: 3BE10134  addi r31, r1, 0x134
	ctx.r[31].s64 = ctx.r[1].s64 + 308;
	// 830C26AC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830C26B0: 4B206669  bl 0x822c8d18
	ctx.lr = 0x830C26B4;
	sub_822C8D18(ctx, base);
	// 830C26B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C26B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C26BC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C26C0: 409A0008  bne cr6, 0x830c26c8
	if !ctx.cr[6].eq {
	pc = 0x830C26C8; continue 'dispatch;
	}
	// 830C26C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C26C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C26CC: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C26D0: EC40F828  fsubs f2, f0, f31
	ctx.f[2].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 830C26D4: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C26D8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830C26DC: C07C0000  lfs f3, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830C26E0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830C26E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830C26E8: C00B093C  lfs f0, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C26EC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830C26F0: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C26F4: 4BFFD345  bl 0x830bfa38
	ctx.lr = 0x830C26F8;
	sub_830BFA38(ctx, base);
	// 830C26F8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830C26FC: 4BD2F595  bl 0x82df1c90
	ctx.lr = 0x830C2700;
	sub_82DF1C90(ctx, base);
	// 830C2700: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C2704: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C2708: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 830C270C: 4B206725  bl 0x822c8e30
	ctx.lr = 0x830C2710;
	sub_822C8E30(ctx, base);
	// 830C2710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C2714: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C2718: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C271C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C2720: ED80E82A  fadds f12, f0, f29
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 830C2724: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830C2728: D1810090  stfs f12, 0x90(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830C272C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 830C2730: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C2734: C18B0940  lfs f12, 0x940(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C2738: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C273C: C16A9684  lfs f11, -0x697c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27004 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C2740: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C2744: C1499524  lfs f10, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C2748: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 830C274C: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C2750: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 830C2754: C3C708A8  lfs f30, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830C2758: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830C275C: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830C2760: D3C100C8  stfs f30, 0xc8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830C2764: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830C2768: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830C276C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830C2770: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830C2774: 4B2065A5  bl 0x822c8d18
	ctx.lr = 0x830C2778;
	sub_822C8D18(ctx, base);
	// 830C2778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C277C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2780: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C2784: 409A0008  bne cr6, 0x830c278c
	if !ctx.cr[6].eq {
	pc = 0x830C278C; continue 'dispatch;
	}
	// 830C2788: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C278C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2790: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C2794: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 830C2798: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830C279C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830C27A0: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 830C27A4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C27A8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 830C27AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C27B0: 4E800421  bctrl
	ctx.lr = 0x830C27B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C27B4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C27B8: 4BD2F4D9  bl 0x82df1c90
	ctx.lr = 0x830C27BC;
	sub_82DF1C90(ctx, base);
	// 830C27BC: 897E0091  lbz r11, 0x91(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(145 as u32) ) } as u64;
	// 830C27C0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C27C4: 409A006C  bne cr6, 0x830c2830
	if !ctx.cr[6].eq {
	pc = 0x830C2830; continue 'dispatch;
	}
	// 830C27C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C27CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C27D0: 4BFFE8E9  bl 0x830c10b8
	ctx.lr = 0x830C27D4;
	sub_830C10B8(ctx, base);
	// 830C27D4: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830C27D8: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830C27DC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C27E0: D3C100A8  stfs f30, 0xa8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830C27E4: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830C27E8: 4B206531  bl 0x822c8d18
	ctx.lr = 0x830C27EC;
	sub_822C8D18(ctx, base);
	// 830C27EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C27F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C27F4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C27F8: 409A0008  bne cr6, 0x830c2800
	if !ctx.cr[6].eq {
	pc = 0x830C2800; continue 'dispatch;
	}
	// 830C27FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C2800: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2804: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C2808: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 830C280C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830C2810: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830C2814: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830C2818: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C281C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C2820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C2824: 4E800421  bctrl
	ctx.lr = 0x830C2828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2828: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C282C: 4BD2F465  bl 0x82df1c90
	ctx.lr = 0x830C2830;
	sub_82DF1C90(ctx, base);
	// 830C2830: 897E0092  lbz r11, 0x92(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(146 as u32) ) } as u64;
	// 830C2834: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C2838: 409A006C  bne cr6, 0x830c28a4
	if !ctx.cr[6].eq {
	pc = 0x830C28A4; continue 'dispatch;
	}
	// 830C283C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C2840: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C2844: 4BFFE8F5  bl 0x830c1138
	ctx.lr = 0x830C2848;
	sub_830C1138(ctx, base);
	// 830C2848: D3E100B0  stfs f31, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830C284C: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830C2850: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C2854: D3C100B8  stfs f30, 0xb8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830C2858: D3C100BC  stfs f30, 0xbc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830C285C: 4B2064BD  bl 0x822c8d18
	ctx.lr = 0x830C2860;
	sub_822C8D18(ctx, base);
	// 830C2860: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2868: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C286C: 409A0008  bne cr6, 0x830c2874
	if !ctx.cr[6].eq {
	pc = 0x830C2874; continue 'dispatch;
	}
	// 830C2870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C2874: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2878: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C287C: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 830C2880: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830C2884: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830C2888: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 830C288C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C2890: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C2894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C2898: 4E800421  bctrl
	ctx.lr = 0x830C289C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C289C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C28A0: 4BD2F3F1  bl 0x82df1c90
	ctx.lr = 0x830C28A4;
	sub_82DF1C90(ctx, base);
	// 830C28A4: 897E0093  lbz r11, 0x93(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(147 as u32) ) } as u64;
	// 830C28A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C28AC: 409A006C  bne cr6, 0x830c2918
	if !ctx.cr[6].eq {
	pc = 0x830C2918; continue 'dispatch;
	}
	// 830C28B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C28B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C28B8: 4BFFE901  bl 0x830c11b8
	ctx.lr = 0x830C28BC;
	sub_830C11B8(ctx, base);
	// 830C28BC: D3E100D0  stfs f31, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830C28C0: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830C28C4: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 830C28C8: D3C100D8  stfs f30, 0xd8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830C28CC: D3C100DC  stfs f30, 0xdc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 830C28D0: 4B206449  bl 0x822c8d18
	ctx.lr = 0x830C28D4;
	sub_822C8D18(ctx, base);
	// 830C28D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C28D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C28DC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C28E0: 409A0008  bne cr6, 0x830c28e8
	if !ctx.cr[6].eq {
	pc = 0x830C28E8; continue 'dispatch;
	}
	// 830C28E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C28E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C28EC: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C28F0: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 830C28F4: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830C28F8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830C28FC: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830C2900: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C2904: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C2908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C290C: 4E800421  bctrl
	ctx.lr = 0x830C2910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2910: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 830C2914: 4BD2F37D  bl 0x82df1c90
	ctx.lr = 0x830C2918;
	sub_82DF1C90(ctx, base);
	// 830C2918: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C291C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2920: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C2924: 4800002C  b 0x830c2950
	pc = 0x830C2950; continue 'dispatch;
	// 830C2928: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C292C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C2930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2934: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C2938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C293C: 4E800421  bctrl
	ctx.lr = 0x830C2940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C2940: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C2944: 4BFFCEE5  bl 0x830bf828
	ctx.lr = 0x830C2948;
	sub_830BF828(ctx, base);
	// 830C2948: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C294C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C2950: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C2954: 409AFFD4  bne cr6, 0x830c2928
	if !ctx.cr[6].eq {
	pc = 0x830C2928; continue 'dispatch;
	}
	// 830C2958: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 830C295C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C2960: 409A000C  bne cr6, 0x830c296c
	if !ctx.cr[6].eq {
	pc = 0x830C296C; continue 'dispatch;
	}
	// 830C2964: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C2968: 48000791  bl 0x830c30f8
	ctx.lr = 0x830C296C;
	sub_830C30F8(ctx, base);
	// 830C296C: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 830C2970: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 830C2974: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 830C2978: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830C297C: 480E5838  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2980 size=232
    let mut pc: u32 = 0x830C2980;
    'dispatch: loop {
        match pc {
            0x830C2980 => {
    //   block [0x830C2980..0x830C2A68)
	// 830C2980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2984: 480E57E5  bl 0x831a8168
	ctx.lr = 0x830C2988;
	sub_831A8130(ctx, base);
	// 830C2988: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C298C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830C2990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C2994: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C2998: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C299C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C29A0: 4B2074B9  bl 0x822c9e58
	ctx.lr = 0x830C29A4;
	sub_822C9E58(ctx, base);
	// 830C29A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C29A8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 830C29AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C29B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C29B4: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 830C29B8: 4B206779  bl 0x822c9130
	ctx.lr = 0x830C29BC;
	sub_822C9130(ctx, base);
	// 830C29BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C29C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C29C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C29C8: 4B206469  bl 0x822c8e30
	ctx.lr = 0x830C29CC;
	sub_822C8E30(ctx, base);
	// 830C29CC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C29D0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C29D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 830C29D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C29DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C29E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C29E4: 419A0024  beq cr6, 0x830c2a08
	if ctx.cr[6].eq {
	pc = 0x830C2A08; continue 'dispatch;
	}
	// 830C29E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C29EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C29F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C29F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C29F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C29FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C2A00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C2A04: 4082FFE8  bne 0x830c29ec
	if !ctx.cr[0].eq {
	pc = 0x830C29EC; continue 'dispatch;
	}
	// 830C2A08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C2A0C: 4B20630D  bl 0x822c8d18
	ctx.lr = 0x830C2A10;
	sub_822C8D18(ctx, base);
	// 830C2A10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C2A18: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C2A1C: 409A0008  bne cr6, 0x830c2a24
	if !ctx.cr[6].eq {
	pc = 0x830C2A24; continue 'dispatch;
	}
	// 830C2A20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C2A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2A28: 4BFFE011  bl 0x830c0a38
	ctx.lr = 0x830C2A2C;
	sub_830C0A38(ctx, base);
	// 830C2A2C: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 830C2A30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C2A34: 4BD2F25D  bl 0x82df1c90
	ctx.lr = 0x830C2A38;
	sub_82DF1C90(ctx, base);
	// 830C2A38: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C2A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C2A40: 83FF0064  lwz r31, 0x64(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C2A44: 419A0008  beq cr6, 0x830c2a4c
	if ctx.cr[6].eq {
	pc = 0x830C2A4C; continue 'dispatch;
	}
	// 830C2A48: 4B1FDE49  bl 0x822c0890
	ctx.lr = 0x830C2A4C;
	sub_822C0890(ctx, base);
	// 830C2A4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C2A50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C2A54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C2A58: 4B2063D9  bl 0x822c8e30
	ctx.lr = 0x830C2A5C;
	sub_822C8E30(ctx, base);
	// 830C2A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C2A60: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830C2A64: 480E5754  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2A68 size=128
    let mut pc: u32 = 0x830C2A68;
    'dispatch: loop {
        match pc {
            0x830C2A68 => {
    //   block [0x830C2A68..0x830C2AE8)
	// 830C2A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2A6C: 480E5701  bl 0x831a816c
	ctx.lr = 0x830C2A70;
	sub_831A8130(ctx, base);
	// 830C2A70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C2A74: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830C2A78: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830C2A7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C2A80: 3BEBBDC8  addi r31, r11, -0x4238
	ctx.r[31].s64 = ctx.r[11].s64 + -16952;
	// 830C2A84: 816ABDD0  lwz r11, -0x4230(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16944 as u32) ) } as u64;
	// 830C2A88: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C2A8C: 40820024  bne 0x830c2ab0
	if !ctx.cr[0].eq {
	pc = 0x830C2AB0; continue 'dispatch;
	}
	// 830C2A90: 3D2082E1  lis r9, -0x7d1f
	ctx.r[9].s64 = -2099183616;
	// 830C2A94: 3D00830C  lis r8, -0x7cf4
	ctx.r[8].s64 = -2096365568;
	// 830C2A98: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C2A9C: 3929BD78  addi r9, r9, -0x4288
	ctx.r[9].s64 = ctx.r[9].s64 + -17032;
	// 830C2AA0: 39081418  addi r8, r8, 0x1418
	ctx.r[8].s64 = ctx.r[8].s64 + 5144;
	// 830C2AA4: 916ABDD0  stw r11, -0x4230(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16944 as u32), ctx.r[11].u32 ) };
	// 830C2AA8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C2AAC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830C2AB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C2AB4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C2AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C2ABC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830C2AC0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830C2AC4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C2AC8: 4BD48C29  bl 0x82e0b6f0
	ctx.lr = 0x830C2ACC;
	sub_82E0B6F0(ctx, base);
	// 830C2ACC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C2AD0: 4182000C  beq 0x830c2adc
	if ctx.cr[0].eq {
	pc = 0x830C2ADC; continue 'dispatch;
	}
	// 830C2AD4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830C2AD8: 48000008  b 0x830c2ae0
	pc = 0x830C2AE0; continue 'dispatch;
	// 830C2ADC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830C2AE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C2AE4: 480E56D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2AE8 size=76
    let mut pc: u32 = 0x830C2AE8;
    'dispatch: loop {
        match pc {
            0x830C2AE8 => {
    //   block [0x830C2AE8..0x830C2B34)
	// 830C2AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C2AF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C2AF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C2AF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C2AFC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C2B00: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 830C2B04: 396B7788  addi r11, r11, 0x7788
	ctx.r[11].s64 = ctx.r[11].s64 + 30600;
	// 830C2B08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C2B0C: 4BD3CE7D  bl 0x82dff988
	ctx.lr = 0x830C2B10;
	sub_82DFF988(ctx, base);
	// 830C2B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C2B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C2B18: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830C2B1C: 48001015  bl 0x830c3b30
	ctx.lr = 0x830C2B20;
	sub_830C3B30(ctx, base);
	// 830C2B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C2B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C2B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C2B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C2B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2B38 size=76
    let mut pc: u32 = 0x830C2B38;
    'dispatch: loop {
        match pc {
            0x830C2B38 => {
    //   block [0x830C2B38..0x830C2B84)
	// 830C2B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C2B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C2B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C2B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C2B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C2B50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C2B54: 4BFFFF95  bl 0x830c2ae8
	ctx.lr = 0x830C2B58;
	sub_830C2AE8(ctx, base);
	// 830C2B58: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C2B5C: 4182000C  beq 0x830c2b68
	if ctx.cr[0].eq {
	pc = 0x830C2B68; continue 'dispatch;
	}
	// 830C2B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C2B64: 4B1FD705  bl 0x822c0268
	ctx.lr = 0x830C2B68;
	sub_822C0268(ctx, base);
	// 830C2B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C2B6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C2B70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C2B74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C2B78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C2B7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C2B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C2B88 size=1108
    let mut pc: u32 = 0x830C2B88;
    'dispatch: loop {
        match pc {
            0x830C2B88 => {
    //   block [0x830C2B88..0x830C2FDC)
	// 830C2B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C2B8C: 480E55D9  bl 0x831a8164
	ctx.lr = 0x830C2B90;
	sub_831A8130(ctx, base);
	// 830C2B90: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C2B94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C2B98: 48001001  bl 0x830c3b98
	ctx.lr = 0x830C2B9C;
	sub_830C3B98(ctx, base);
	// 830C2B9C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C2BA0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2BA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C2BA8: 396B7788  addi r11, r11, 0x7788
	ctx.r[11].s64 = ctx.r[11].s64 + 30600;
	// 830C2BAC: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 830C2BB0: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830C2BB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C2BB8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C2BBC: 396A6C98  addi r11, r10, 0x6c98
	ctx.r[11].s64 = ctx.r[10].s64 + 27800;
	// 830C2BC0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2BC4: 4B2060F5  bl 0x822c8cb8
	ctx.lr = 0x830C2BC8;
	sub_822C8CB8(ctx, base);
	// 830C2BC8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C2BCC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2BD0: 4BFFFE99  bl 0x830c2a68
	ctx.lr = 0x830C2BD4;
	sub_830C2A68(ctx, base);
	// 830C2BD4: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 830C2BD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2BDC: 4B4C9335  bl 0x8258bf10
	ctx.lr = 0x830C2BE0;
	sub_8258BF10(ctx, base);
	// 830C2BE0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C2BE4: 3BBF006C  addi r29, r31, 0x6c
	ctx.r[29].s64 = ctx.r[31].s64 + 108;
	// 830C2BE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C2BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2BF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2BF4: 4BFFE16D  bl 0x830c0d60
	ctx.lr = 0x830C2BF8;
	sub_830C0D60(ctx, base);
	// 830C2BF8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C2BFC: 4B3AE4CD  bl 0x824710c8
	ctx.lr = 0x830C2C00;
	sub_824710C8(ctx, base);
	// 830C2C00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C2C04: 4B2060B5  bl 0x822c8cb8
	ctx.lr = 0x830C2C08;
	sub_822C8CB8(ctx, base);
	// 830C2C08: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C2C0C: 4B2060AD  bl 0x822c8cb8
	ctx.lr = 0x830C2C10;
	sub_822C8CB8(ctx, base);
	// 830C2C10: 93C101A0  stw r30, 0x1a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 830C2C14: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2C18: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2C1C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 830C2C20: 396B7B70  addi r11, r11, 0x7b70
	ctx.r[11].s64 = ctx.r[11].s64 + 31600;
	// 830C2C24: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2C28: 4B206091  bl 0x822c8cb8
	ctx.lr = 0x830C2C2C;
	sub_822C8CB8(ctx, base);
	// 830C2C2C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 830C2C30: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2C34: 4BFFFE35  bl 0x830c2a68
	ctx.lr = 0x830C2C38;
	sub_830C2A68(ctx, base);
	// 830C2C38: 388101A0  addi r4, r1, 0x1a0
	ctx.r[4].s64 = ctx.r[1].s64 + 416;
	// 830C2C3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2C40: 4B4C92D1  bl 0x8258bf10
	ctx.lr = 0x830C2C44;
	sub_8258BF10(ctx, base);
	// 830C2C44: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830C2C48: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2C4C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830C2C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2C54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2C58: 4BFFE109  bl 0x830c0d60
	ctx.lr = 0x830C2C5C;
	sub_830C0D60(ctx, base);
	// 830C2C5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2C60: 4B3AE469  bl 0x824710c8
	ctx.lr = 0x830C2C64;
	sub_824710C8(ctx, base);
	// 830C2C64: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2C68: 4B206051  bl 0x822c8cb8
	ctx.lr = 0x830C2C6C;
	sub_822C8CB8(ctx, base);
	// 830C2C6C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 830C2C70: 4B206049  bl 0x822c8cb8
	ctx.lr = 0x830C2C74;
	sub_822C8CB8(ctx, base);
	// 830C2C74: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830C2C78: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2C7C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2C80: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C2C84: 396B7B80  addi r11, r11, 0x7b80
	ctx.r[11].s64 = ctx.r[11].s64 + 31616;
	// 830C2C88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2C8C: 4B20602D  bl 0x822c8cb8
	ctx.lr = 0x830C2C90;
	sub_822C8CB8(ctx, base);
	// 830C2C90: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C2C94: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2C98: 4BFFFDD1  bl 0x830c2a68
	ctx.lr = 0x830C2C9C;
	sub_830C2A68(ctx, base);
	// 830C2C9C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830C2CA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2CA4: 4B4C926D  bl 0x8258bf10
	ctx.lr = 0x830C2CA8;
	sub_8258BF10(ctx, base);
	// 830C2CA8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830C2CAC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2CB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2CB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2CB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2CBC: 4BFFE0A5  bl 0x830c0d60
	ctx.lr = 0x830C2CC0;
	sub_830C0D60(ctx, base);
	// 830C2CC0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2CC4: 4B3AE405  bl 0x824710c8
	ctx.lr = 0x830C2CC8;
	sub_824710C8(ctx, base);
	// 830C2CC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2CCC: 4B205FED  bl 0x822c8cb8
	ctx.lr = 0x830C2CD0;
	sub_822C8CB8(ctx, base);
	// 830C2CD0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C2CD4: 4B205FE5  bl 0x822c8cb8
	ctx.lr = 0x830C2CD8;
	sub_822C8CB8(ctx, base);
	// 830C2CD8: 93C10140  stw r30, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 830C2CDC: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2CE0: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830C2CE4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2CE8: 396B6C88  addi r11, r11, 0x6c88
	ctx.r[11].s64 = ctx.r[11].s64 + 27784;
	// 830C2CEC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2CF0: 4B205FC9  bl 0x822c8cb8
	ctx.lr = 0x830C2CF4;
	sub_822C8CB8(ctx, base);
	// 830C2CF4: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830C2CF8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2CFC: 4BFFFD6D  bl 0x830c2a68
	ctx.lr = 0x830C2D00;
	sub_830C2A68(ctx, base);
	// 830C2D00: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 830C2D04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2D08: 4B4C9209  bl 0x8258bf10
	ctx.lr = 0x830C2D0C;
	sub_8258BF10(ctx, base);
	// 830C2D0C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830C2D10: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2D14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2D18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2D1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2D20: 4BFFE041  bl 0x830c0d60
	ctx.lr = 0x830C2D24;
	sub_830C0D60(ctx, base);
	// 830C2D24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2D28: 4B3AE3A1  bl 0x824710c8
	ctx.lr = 0x830C2D2C;
	sub_824710C8(ctx, base);
	// 830C2D2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2D30: 4B205F89  bl 0x822c8cb8
	ctx.lr = 0x830C2D34;
	sub_822C8CB8(ctx, base);
	// 830C2D34: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830C2D38: 4B205F81  bl 0x822c8cb8
	ctx.lr = 0x830C2D3C;
	sub_822C8CB8(ctx, base);
	// 830C2D3C: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830C2D40: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2D44: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2D48: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C2D4C: 396B6CA8  addi r11, r11, 0x6ca8
	ctx.r[11].s64 = ctx.r[11].s64 + 27816;
	// 830C2D50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2D54: 4B205F65  bl 0x822c8cb8
	ctx.lr = 0x830C2D58;
	sub_822C8CB8(ctx, base);
	// 830C2D58: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C2D5C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2D60: 4BFFFD09  bl 0x830c2a68
	ctx.lr = 0x830C2D64;
	sub_830C2A68(ctx, base);
	// 830C2D64: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C2D68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2D6C: 4B4C91A5  bl 0x8258bf10
	ctx.lr = 0x830C2D70;
	sub_8258BF10(ctx, base);
	// 830C2D70: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830C2D74: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2D78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2D7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2D80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2D84: 4BFFDFDD  bl 0x830c0d60
	ctx.lr = 0x830C2D88;
	sub_830C0D60(ctx, base);
	// 830C2D88: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2D8C: 4B3AE33D  bl 0x824710c8
	ctx.lr = 0x830C2D90;
	sub_824710C8(ctx, base);
	// 830C2D90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2D94: 4B205F25  bl 0x822c8cb8
	ctx.lr = 0x830C2D98;
	sub_822C8CB8(ctx, base);
	// 830C2D98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C2D9C: 4B205F1D  bl 0x822c8cb8
	ctx.lr = 0x830C2DA0;
	sub_822C8CB8(ctx, base);
	// 830C2DA0: 93C10180  stw r30, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 830C2DA4: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2DA8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2DAC: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830C2DB0: 396B0FA8  addi r11, r11, 0xfa8
	ctx.r[11].s64 = ctx.r[11].s64 + 4008;
	// 830C2DB4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2DB8: 4B205F01  bl 0x822c8cb8
	ctx.lr = 0x830C2DBC;
	sub_822C8CB8(ctx, base);
	// 830C2DBC: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830C2DC0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2DC4: 4BFFFCA5  bl 0x830c2a68
	ctx.lr = 0x830C2DC8;
	sub_830C2A68(ctx, base);
	// 830C2DC8: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 830C2DCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2DD0: 4B4C9141  bl 0x8258bf10
	ctx.lr = 0x830C2DD4;
	sub_8258BF10(ctx, base);
	// 830C2DD4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 830C2DD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2DDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2DE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2DE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2DE8: 4BFFDF79  bl 0x830c0d60
	ctx.lr = 0x830C2DEC;
	sub_830C0D60(ctx, base);
	// 830C2DEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2DF0: 4B3AE2D9  bl 0x824710c8
	ctx.lr = 0x830C2DF4;
	sub_824710C8(ctx, base);
	// 830C2DF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2DF8: 4B205EC1  bl 0x822c8cb8
	ctx.lr = 0x830C2DFC;
	sub_822C8CB8(ctx, base);
	// 830C2DFC: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830C2E00: 4B205EB9  bl 0x822c8cb8
	ctx.lr = 0x830C2E04;
	sub_822C8CB8(ctx, base);
	// 830C2E04: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2E08: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 830C2E0C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C2E10: 396B0F78  addi r11, r11, 0xf78
	ctx.r[11].s64 = ctx.r[11].s64 + 3960;
	// 830C2E14: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2E18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2E1C: 4B205E9D  bl 0x822c8cb8
	ctx.lr = 0x830C2E20;
	sub_822C8CB8(ctx, base);
	// 830C2E20: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C2E24: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2E28: 4BFFFC41  bl 0x830c2a68
	ctx.lr = 0x830C2E2C;
	sub_830C2A68(ctx, base);
	// 830C2E2C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830C2E30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2E34: 4B4C90DD  bl 0x8258bf10
	ctx.lr = 0x830C2E38;
	sub_8258BF10(ctx, base);
	// 830C2E38: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 830C2E3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2E40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2E44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2E48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2E4C: 4BFFDF15  bl 0x830c0d60
	ctx.lr = 0x830C2E50;
	sub_830C0D60(ctx, base);
	// 830C2E50: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2E54: 4B3AE275  bl 0x824710c8
	ctx.lr = 0x830C2E58;
	sub_824710C8(ctx, base);
	// 830C2E58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2E5C: 4B205E5D  bl 0x822c8cb8
	ctx.lr = 0x830C2E60;
	sub_822C8CB8(ctx, base);
	// 830C2E60: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C2E64: 4B205E55  bl 0x822c8cb8
	ctx.lr = 0x830C2E68;
	sub_822C8CB8(ctx, base);
	// 830C2E68: 93C100E0  stw r30, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830C2E6C: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2E70: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2E74: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C2E78: 396B0F88  addi r11, r11, 0xf88
	ctx.r[11].s64 = ctx.r[11].s64 + 3976;
	// 830C2E7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2E80: 4B205E39  bl 0x822c8cb8
	ctx.lr = 0x830C2E84;
	sub_822C8CB8(ctx, base);
	// 830C2E84: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C2E88: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2E8C: 4BFFFBDD  bl 0x830c2a68
	ctx.lr = 0x830C2E90;
	sub_830C2A68(ctx, base);
	// 830C2E90: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830C2E94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2E98: 4B4C9079  bl 0x8258bf10
	ctx.lr = 0x830C2E9C;
	sub_8258BF10(ctx, base);
	// 830C2E9C: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 830C2EA0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2EA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2EA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2EAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2EB0: 4BFFDEB1  bl 0x830c0d60
	ctx.lr = 0x830C2EB4;
	sub_830C0D60(ctx, base);
	// 830C2EB4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2EB8: 4B3AE211  bl 0x824710c8
	ctx.lr = 0x830C2EBC;
	sub_824710C8(ctx, base);
	// 830C2EBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2EC0: 4B205DF9  bl 0x822c8cb8
	ctx.lr = 0x830C2EC4;
	sub_822C8CB8(ctx, base);
	// 830C2EC4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C2EC8: 4B205DF1  bl 0x822c8cb8
	ctx.lr = 0x830C2ECC;
	sub_822C8CB8(ctx, base);
	// 830C2ECC: 93C10120  stw r30, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 830C2ED0: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2ED4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2ED8: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C2EDC: 396B0F98  addi r11, r11, 0xf98
	ctx.r[11].s64 = ctx.r[11].s64 + 3992;
	// 830C2EE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2EE4: 4B205DD5  bl 0x822c8cb8
	ctx.lr = 0x830C2EE8;
	sub_822C8CB8(ctx, base);
	// 830C2EE8: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C2EEC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2EF0: 4BFFFB79  bl 0x830c2a68
	ctx.lr = 0x830C2EF4;
	sub_830C2A68(ctx, base);
	// 830C2EF4: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 830C2EF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2EFC: 4B4C9015  bl 0x8258bf10
	ctx.lr = 0x830C2F00;
	sub_8258BF10(ctx, base);
	// 830C2F00: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 830C2F04: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2F08: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2F0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2F10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2F14: 4BFFDE4D  bl 0x830c0d60
	ctx.lr = 0x830C2F18;
	sub_830C0D60(ctx, base);
	// 830C2F18: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2F1C: 4B3AE1AD  bl 0x824710c8
	ctx.lr = 0x830C2F20;
	sub_824710C8(ctx, base);
	// 830C2F20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2F24: 4B205D95  bl 0x822c8cb8
	ctx.lr = 0x830C2F28;
	sub_822C8CB8(ctx, base);
	// 830C2F28: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C2F2C: 4B205D8D  bl 0x822c8cb8
	ctx.lr = 0x830C2F30;
	sub_822C8CB8(ctx, base);
	// 830C2F30: 93C10160  stw r30, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[30].u32 ) };
	// 830C2F34: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C2F38: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C2F3C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830C2F40: 396B0F68  addi r11, r11, 0xf68
	ctx.r[11].s64 = ctx.r[11].s64 + 3944;
	// 830C2F44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2F48: 4B205D71  bl 0x822c8cb8
	ctx.lr = 0x830C2F4C;
	sub_822C8CB8(ctx, base);
	// 830C2F4C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830C2F50: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C2F54: 4BFFFB15  bl 0x830c2a68
	ctx.lr = 0x830C2F58;
	sub_830C2A68(ctx, base);
	// 830C2F58: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 830C2F5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C2F60: 4B4C8FB1  bl 0x8258bf10
	ctx.lr = 0x830C2F64;
	sub_8258BF10(ctx, base);
	// 830C2F64: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 830C2F68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C2F6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C2F70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C2F74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C2F78: 4BFFDDE9  bl 0x830c0d60
	ctx.lr = 0x830C2F7C;
	sub_830C0D60(ctx, base);
	// 830C2F7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C2F80: 4B3AE149  bl 0x824710c8
	ctx.lr = 0x830C2F84;
	sub_824710C8(ctx, base);
	// 830C2F84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C2F88: 4B205D31  bl 0x822c8cb8
	ctx.lr = 0x830C2F8C;
	sub_822C8CB8(ctx, base);
	// 830C2F8C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830C2F90: 4B205D29  bl 0x822c8cb8
	ctx.lr = 0x830C2F94;
	sub_822C8CB8(ctx, base);
	// 830C2F94: 9B9F0010  stb r28, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 830C2F98: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 830C2F9C: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 830C2FA0: 9B9F0090  stb r28, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[28].u8 ) };
	// 830C2FA4: 9B9F0091  stb r28, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[28].u8 ) };
	// 830C2FA8: 9B9F0092  stb r28, 0x92(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(146 as u32), ctx.r[28].u8 ) };
	// 830C2FAC: 9B9F0093  stb r28, 0x93(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(147 as u32), ctx.r[28].u8 ) };
	// 830C2FB0: 9B9F0012  stb r28, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[28].u8 ) };
	// 830C2FB4: 9B9F0013  stb r28, 0x13(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(19 as u32), ctx.r[28].u8 ) };
	// 830C2FB8: 9B9F0094  stb r28, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[28].u8 ) };
	// 830C2FBC: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830C2FC0: 9BDF0097  stb r30, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[30].u8 ) };
	// 830C2FC4: 9BDF0095  stb r30, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[30].u8 ) };
	// 830C2FC8: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 830C2FCC: 4BD3C9BD  bl 0x82dff988
	ctx.lr = 0x830C2FD0;
	sub_82DFF988(ctx, base);
	// 830C2FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C2FD4: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 830C2FD8: 480E51DC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C2FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C2FE0 size=52
    let mut pc: u32 = 0x830C2FE0;
    'dispatch: loop {
        match pc {
            0x830C2FE0 => {
    //   block [0x830C2FE0..0x830C3014)
	// 830C2FE0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C2FE4: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C2FE8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C2FEC: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C2FF0: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C2FF4: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C2FF8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C2FFC: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830C3000: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3004: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3008: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C300C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830C3010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C3018 size=60
    let mut pc: u32 = 0x830C3018;
    'dispatch: loop {
        match pc {
            0x830C3018 => {
    //   block [0x830C3018..0x830C3054)
	// 830C3018: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C301C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830C3020: 40990034  ble cr6, 0x830c3054
	if !ctx.cr[6].gt {
		sub_830C3054(ctx, base);
		return;
	}
	// 830C3024: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3028: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C302C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830C3030: 40980024  bge cr6, 0x830c3054
	if !ctx.cr[6].lt {
		sub_830C3054(ctx, base);
		return;
	}
	// 830C3034: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3038: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830C303C: 40990018  ble cr6, 0x830c3054
	if !ctx.cr[6].gt {
		sub_830C3054(ctx, base);
		return;
	}
	// 830C3040: C1A30024  lfs f13, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3044: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C3048: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C304C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830C3050: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3054(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C3054 size=8
    let mut pc: u32 = 0x830C3054;
    'dispatch: loop {
        match pc {
            0x830C3054 => {
    //   block [0x830C3054..0x830C305C)
	// 830C3054: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C3058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C3060 size=52
    let mut pc: u32 = 0x830C3060;
    'dispatch: loop {
        match pc {
            0x830C3060 => {
    //   block [0x830C3060..0x830C3094)
	// 830C3060: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3064: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830C3068: 4099002C  ble cr6, 0x830c3094
	if !ctx.cr[6].gt {
		sub_830C3094(ctx, base);
		return;
	}
	// 830C306C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3070: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830C3074: 40980020  bge cr6, 0x830c3094
	if !ctx.cr[6].lt {
		sub_830C3094(ctx, base);
		return;
	}
	// 830C3078: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C307C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830C3080: 40990014  ble cr6, 0x830c3094
	if !ctx.cr[6].gt {
		sub_830C3094(ctx, base);
		return;
	}
	// 830C3084: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3088: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C308C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830C3090: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3094(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C3094 size=8
    let mut pc: u32 = 0x830C3094;
    'dispatch: loop {
        match pc {
            0x830C3094 => {
    //   block [0x830C3094..0x830C309C)
	// 830C3094: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C3098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C30A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C30A0 size=48
    let mut pc: u32 = 0x830C30A0;
    'dispatch: loop {
        match pc {
            0x830C30A0 => {
    //   block [0x830C30A0..0x830C30D0)
	// 830C30A0: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C30A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C30A8: 39230040  addi r9, r3, 0x40
	ctx.r[9].s64 = ctx.r[3].s64 + 64;
	// 830C30AC: 99630040  stb r11, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 830C30B0: 89640001  lbz r11, 1(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 830C30B4: 99630041  stb r11, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 830C30B8: 89640002  lbz r11, 2(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 830C30BC: 99630042  stb r11, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[11].u8 ) };
	// 830C30C0: 89640003  lbz r11, 3(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(3 as u32) ) } as u64;
	// 830C30C4: 99630043  stb r11, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[11].u8 ) };
	// 830C30C8: 99430044  stb r10, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 830C30CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C30D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C30D0 size=40
    let mut pc: u32 = 0x830C30D0;
    'dispatch: loop {
        match pc {
            0x830C30D0 => {
    //   block [0x830C30D0..0x830C30F8)
	// 830C30D0: 39640040  addi r11, r4, 0x40
	ctx.r[11].s64 = ctx.r[4].s64 + 64;
	// 830C30D4: 89440040  lbz r10, 0x40(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 830C30D8: 89640041  lbz r11, 0x41(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(65 as u32) ) } as u64;
	// 830C30DC: 89240042  lbz r9, 0x42(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(66 as u32) ) } as u64;
	// 830C30E0: 89040043  lbz r8, 0x43(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(67 as u32) ) } as u64;
	// 830C30E4: 99430000  stb r10, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830C30E8: 99630001  stb r11, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 830C30EC: 99230002  stb r9, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 830C30F0: 99030003  stb r8, 3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 830C30F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C30F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C30F8 size=12
    let mut pc: u32 = 0x830C30F8;
    'dispatch: loop {
        match pc {
            0x830C30F8 => {
    //   block [0x830C30F8..0x830C3104)
	// 830C30F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C30FC: 99630044  stb r11, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 830C3100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C3108 size=44
    let mut pc: u32 = 0x830C3108;
    'dispatch: loop {
        match pc {
            0x830C3108 => {
    //   block [0x830C3108..0x830C3134)
	// 830C3108: C0040034  lfs f0, 0x34(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C310C: C1A40030  lfs f13, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3110: C1840024  lfs f12, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C3114: C1640020  lfs f11, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C3118: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C311C: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C3120: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C3124: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C3128: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830C312C: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C3130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3138 size=172
    let mut pc: u32 = 0x830C3138;
    'dispatch: loop {
        match pc {
            0x830C3138 => {
    //   block [0x830C3138..0x830C31E4)
	// 830C3138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C313C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C3144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C314C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C3150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C3154: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 830C3158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C315C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3160: 4B1FD7D9  bl 0x822c0938
	ctx.lr = 0x830C3164;
	sub_822C0938(ctx, base);
	// 830C3164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C3168: 41820028  beq 0x830c3190
	if ctx.cr[0].eq {
	pc = 0x830C3190; continue 'dispatch;
	}
	// 830C316C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 830C3170: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 830C3174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C3178: 392BC73C  addi r9, r11, -0x38c4
	ctx.r[9].s64 = ctx.r[11].s64 + -14532;
	// 830C317C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830C3180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C3184: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830C3188: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C318C: 48000008  b 0x830c3194
	pc = 0x830C3194; continue 'dispatch;
	// 830C3190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C3194: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C319C: 409A002C  bne cr6, 0x830c31c8
	if !ctx.cr[6].eq {
	pc = 0x830C31C8; continue 'dispatch;
	}
	// 830C31A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C31A4: 4B1FD0C5  bl 0x822c0268
	ctx.lr = 0x830C31A8;
	sub_822C0268(ctx, base);
	// 830C31A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C31AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C31B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C31B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 830C31B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C31BC: 816B4528  lwz r11, 0x4528(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17704 as u32) ) } as u64;
	// 830C31C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C31C4: 4B1FCE3D  bl 0x822c0000
	ctx.lr = 0x830C31C8;
	sub_822C0000(ctx, base);
	// 830C31C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C31CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C31D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C31D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C31D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C31DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C31E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C31E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C31E8 size=8
    let mut pc: u32 = 0x830C31E8;
    'dispatch: loop {
        match pc {
            0x830C31E8 => {
    //   block [0x830C31E8..0x830C31F0)
	// 830C31E8: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C31EC: 4B1FD07C  b 0x822c0268
	sub_822C0268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C31F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C31F0 size=92
    let mut pc: u32 = 0x830C31F0;
    'dispatch: loop {
        match pc {
            0x830C31F0 => {
    //   block [0x830C31F0..0x830C324C)
	// 830C31F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C31F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C31F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C31FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C3200: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C3204: 4BFFC78D  bl 0x830bf990
	ctx.lr = 0x830C3208;
	sub_830BF990(ctx, base);
	// 830C3208: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C320C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C3210: 41820008  beq 0x830c3218
	if ctx.cr[0].eq {
	pc = 0x830C3218; continue 'dispatch;
	}
	// 830C3214: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C3218: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C321C: 41820008  beq 0x830c3224
	if ctx.cr[0].eq {
	pc = 0x830C3224; continue 'dispatch;
	}
	// 830C3220: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C3224: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C3228: 41820008  beq 0x830c3230
	if ctx.cr[0].eq {
	pc = 0x830C3230; continue 'dispatch;
	}
	// 830C322C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C3230: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C3234: 99430039  stb r10, 0x39(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(57 as u32), ctx.r[10].u8 ) };
	// 830C3238: 99630038  stb r11, 0x38(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 830C323C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C3240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3250 size=108
    let mut pc: u32 = 0x830C3250;
    'dispatch: loop {
        match pc {
            0x830C3250 => {
    //   block [0x830C3250..0x830C32BC)
	// 830C3250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3258: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C325C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830C3260: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C3264: 38C0001C  li r6, 0x1c
	ctx.r[6].s64 = 28;
	// 830C3268: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 830C326C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 830C3270: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C3274: 4BD2EE55  bl 0x82df20c8
	ctx.lr = 0x830C3278;
	sub_82DF20C8(ctx, base);
	// 830C3278: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C327C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C3280: 41820008  beq 0x830c3288
	if ctx.cr[0].eq {
	pc = 0x830C3288; continue 'dispatch;
	}
	// 830C3284: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C3288: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C328C: 41820008  beq 0x830c3294
	if ctx.cr[0].eq {
	pc = 0x830C3294; continue 'dispatch;
	}
	// 830C3290: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C3294: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C3298: 41820008  beq 0x830c32a0
	if ctx.cr[0].eq {
	pc = 0x830C32A0; continue 'dispatch;
	}
	// 830C329C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C32A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C32A4: 99430019  stb r10, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 830C32A8: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 830C32AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C32B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C32B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C32B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C32C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C32C0 size=88
    let mut pc: u32 = 0x830C32C0;
    'dispatch: loop {
        match pc {
            0x830C32C0 => {
    //   block [0x830C32C0..0x830C3318)
	// 830C32C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C32C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C32C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C32CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C32D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C32D4: 4BFFFF1D  bl 0x830c31f0
	ctx.lr = 0x830C32D8;
	sub_830C31F0(ctx, base);
	// 830C32D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C32DC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830C32E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C32E4: 99630039  stb r11, 0x39(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 830C32E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C32EC: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C32F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C32F4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C32F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C32FC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3300: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C3304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C3308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C330C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3318 size=88
    let mut pc: u32 = 0x830C3318;
    'dispatch: loop {
        match pc {
            0x830C3318 => {
    //   block [0x830C3318..0x830C3370)
	// 830C3318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C331C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3320: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3324: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C332C: 4BFFFF25  bl 0x830c3250
	ctx.lr = 0x830C3330;
	sub_830C3250(ctx, base);
	// 830C3330: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C3334: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830C3338: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C333C: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 830C3340: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3344: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C3348: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C334C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3350: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3354: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3358: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C335C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C3360: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3364: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3368: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C336C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3370 size=112
    let mut pc: u32 = 0x830C3370;
    'dispatch: loop {
        match pc {
            0x830C3370 => {
    //   block [0x830C3370..0x830C33E0)
	// 830C3370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C337C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3384: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C3388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C338C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C3390: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C3394: 4BFFFDA5  bl 0x830c3138
	ctx.lr = 0x830C3398;
	sub_830C3138(ctx, base);
	// 830C3398: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830C339C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C33A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C33A4: 4B1FCC5D  bl 0x822c0000
	ctx.lr = 0x830C33A8;
	sub_822C0000(ctx, base);
	// 830C33A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C33AC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C33B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C33B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C33B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C33BC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830C33C0: 419A0008  beq cr6, 0x830c33c8
	if ctx.cr[6].eq {
	pc = 0x830C33C8; continue 'dispatch;
	}
	// 830C33C4: 4B1FD4CD  bl 0x822c0890
	ctx.lr = 0x830C33C8;
	sub_822C0890(ctx, base);
	// 830C33C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C33CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C33D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C33D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C33D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C33DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C33E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C33E0 size=88
    let mut pc: u32 = 0x830C33E0;
    'dispatch: loop {
        match pc {
            0x830C33E0 => {
    //   block [0x830C33E0..0x830C3438)
	// 830C33E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C33E4: 480E4D89  bl 0x831a816c
	ctx.lr = 0x830C33E8;
	sub_831A8130(ctx, base);
	// 830C33E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C33EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C33F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C33F4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830C33F8: 897E0039  lbz r11, 0x39(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C33FC: 4800002C  b 0x830c3428
	pc = 0x830C3428; continue 'dispatch;
	// 830C3400: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C3404: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3408: 4BFFFFD9  bl 0x830c33e0
	ctx.lr = 0x830C340C;
	sub_830C33E0(ctx, base);
	// 830C340C: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 830C3410: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3414: 4B2058A5  bl 0x822c8cb8
	ctx.lr = 0x830C3418;
	sub_822C8CB8(ctx, base);
	// 830C3418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C341C: 4B1FCE4D  bl 0x822c0268
	ctx.lr = 0x830C3420;
	sub_822C0268(ctx, base);
	// 830C3420: 897F0039  lbz r11, 0x39(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C3424: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830C3428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C342C: 419AFFD4  beq cr6, 0x830c3400
	if ctx.cr[6].eq {
	pc = 0x830C3400; continue 'dispatch;
	}
	// 830C3430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C3434: 480E4D88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3438 size=1016
    let mut pc: u32 = 0x830C3438;
    'dispatch: loop {
        match pc {
            0x830C3438 => {
    //   block [0x830C3438..0x830C3830)
	// 830C3438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C343C: 480E4D1D  bl 0x831a8158
	ctx.lr = 0x830C3440;
	sub_831A8130(ctx, base);
	// 830C3440: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3444: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830C3448: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830C344C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830C3450: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 830C3454: 897F0039  lbz r11, 0x39(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C3458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C345C: 419A0048  beq cr6, 0x830c34a4
	if ctx.cr[6].eq {
	pc = 0x830C34A4; continue 'dispatch;
	}
	// 830C3460: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C3464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C3468: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 830C346C: 4B20245D  bl 0x822c58c8
	ctx.lr = 0x830C3470;
	sub_822C58C8(ctx, base);
	// 830C3470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C3474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C3478: 4B206A39  bl 0x822c9eb0
	ctx.lr = 0x830C347C;
	sub_822C9EB0(ctx, base);
	// 830C347C: 4B200E35  bl 0x822c42b0
	ctx.lr = 0x830C3480;
	sub_822C42B0(ctx, base);
	// 830C3480: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C3484: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C3488: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 830C348C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830C3490: 4B201FE1  bl 0x822c5470
	ctx.lr = 0x830C3494;
	sub_822C5470(ctx, base);
	// 830C3494: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C3498: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C349C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C34A0: 4B201841  bl 0x822c4ce0
	ctx.lr = 0x830C34A4;
	sub_822C4CE0(ctx, base);
	// 830C34A4: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 830C34A8: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 830C34AC: 4BD96365  bl 0x82e59810
	ctx.lr = 0x830C34B0;
	sub_82E59810(ctx, base);
	// 830C34B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C34B4: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C34B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C34BC: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 830C34C0: 419A000C  beq cr6, 0x830c34cc
	if ctx.cr[6].eq {
	pc = 0x830C34CC; continue 'dispatch;
	}
	// 830C34C4: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C34C8: 48000028  b 0x830c34f0
	pc = 0x830C34F0; continue 'dispatch;
	// 830C34CC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C34D0: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C34D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C34D8: 419A000C  beq cr6, 0x830c34e4
	if ctx.cr[6].eq {
	pc = 0x830C34E4; continue 'dispatch;
	}
	// 830C34DC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 830C34E0: 48000010  b 0x830c34f0
	pc = 0x830C34F0; continue 'dispatch;
	// 830C34E4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C34E8: 7F19D040  cmplw cr6, r25, r26
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C34EC: 409A00DC  bne cr6, 0x830c35c8
	if !ctx.cr[6].eq {
	pc = 0x830C35C8; continue 'dispatch;
	}
	// 830C34F0: 897C0039  lbz r11, 0x39(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C34F4: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C34F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C34FC: 409A0008  bne cr6, 0x830c3504
	if !ctx.cr[6].eq {
	pc = 0x830C3504; continue 'dispatch;
	}
	// 830C3500: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830C3504: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3508: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C350C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C3510: 409A000C  bne cr6, 0x830c351c
	if !ctx.cr[6].eq {
	pc = 0x830C351C; continue 'dispatch;
	}
	// 830C3514: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830C3518: 4800001C  b 0x830c3534
	pc = 0x830C3534; continue 'dispatch;
	// 830C351C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3520: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C3524: 409A000C  bne cr6, 0x830c3530
	if !ctx.cr[6].eq {
	pc = 0x830C3530; continue 'dispatch;
	}
	// 830C3528: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C352C: 48000008  b 0x830c3534
	pc = 0x830C3534; continue 'dispatch;
	// 830C3530: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C3534: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3538: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C353C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C3540: 409A003C  bne cr6, 0x830c357c
	if !ctx.cr[6].eq {
	pc = 0x830C357C; continue 'dispatch;
	}
	// 830C3544: 897C0039  lbz r11, 0x39(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C3548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C354C: 419A000C  beq cr6, 0x830c3558
	if ctx.cr[6].eq {
	pc = 0x830C3558; continue 'dispatch;
	}
	// 830C3550: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830C3554: 48000024  b 0x830c3578
	pc = 0x830C3578; continue 'dispatch;
	// 830C3558: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C355C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830C3560: 4800000C  b 0x830c356c
	pc = 0x830C356C; continue 'dispatch;
	// 830C3564: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830C3568: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C356C: 890B0039  lbz r8, 0x39(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C3570: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830C3574: 419AFFF0  beq cr6, 0x830c3564
	if ctx.cr[6].eq {
	pc = 0x830C3564; continue 'dispatch;
	}
	// 830C3578: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C357C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3580: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3584: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C3588: 409A00D4  bne cr6, 0x830c365c
	if !ctx.cr[6].eq {
	pc = 0x830C365C; continue 'dispatch;
	}
	// 830C358C: 897C0039  lbz r11, 0x39(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C3590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C3594: 419A000C  beq cr6, 0x830c35a0
	if ctx.cr[6].eq {
	pc = 0x830C35A0; continue 'dispatch;
	}
	// 830C3598: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830C359C: 48000024  b 0x830c35c0
	pc = 0x830C35C0; continue 'dispatch;
	// 830C35A0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C35A4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830C35A8: 4800000C  b 0x830c35b4
	pc = 0x830C35B4; continue 'dispatch;
	// 830C35AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830C35B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C35B4: 890B0039  lbz r8, 0x39(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C35B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830C35BC: 419AFFF0  beq cr6, 0x830c35ac
	if ctx.cr[6].eq {
	pc = 0x830C35AC; continue 'dispatch;
	}
	// 830C35C0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C35C4: 48000098  b 0x830c365c
	pc = 0x830C365C; continue 'dispatch;
	// 830C35C8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830C35CC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C35D0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C35D4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C35D8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C35DC: 409A000C  bne cr6, 0x830c35e8
	if !ctx.cr[6].eq {
	pc = 0x830C35E8; continue 'dispatch;
	}
	// 830C35E0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830C35E4: 4800002C  b 0x830c3610
	pc = 0x830C3610; continue 'dispatch;
	// 830C35E8: 897C0039  lbz r11, 0x39(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C35EC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C35F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C35F4: 409A0008  bne cr6, 0x830c35fc
	if !ctx.cr[6].eq {
	pc = 0x830C35FC; continue 'dispatch;
	}
	// 830C35F8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830C35FC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C3600: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3604: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3608: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C360C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830C3610: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3614: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3618: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C361C: 409A000C  bne cr6, 0x830c3628
	if !ctx.cr[6].eq {
	pc = 0x830C3628; continue 'dispatch;
	}
	// 830C3620: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830C3624: 48000020  b 0x830c3644
	pc = 0x830C3644; continue 'dispatch;
	// 830C3628: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C362C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3630: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C3634: 409A000C  bne cr6, 0x830c3640
	if !ctx.cr[6].eq {
	pc = 0x830C3640; continue 'dispatch;
	}
	// 830C3638: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830C363C: 48000008  b 0x830c3644
	pc = 0x830C3644; continue 'dispatch;
	// 830C3640: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 830C3644: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3648: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C364C: 897A0038  lbz r11, 0x38(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3650: 89590038  lbz r10, 0x38(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3654: 99790038  stb r11, 0x38(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 830C3658: 995A0038  stb r10, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 830C365C: 897A0038  lbz r11, 0x38(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3660: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C3664: 409A0198  bne cr6, 0x830c37fc
	if !ctx.cr[6].eq {
	pc = 0x830C37FC; continue 'dispatch;
	}
	// 830C3668: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C366C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830C3670: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3674: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C3678: 419A0180  beq cr6, 0x830c37f8
	if ctx.cr[6].eq {
	pc = 0x830C37F8; continue 'dispatch;
	}
	// 830C367C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C3680: 897C0038  lbz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3684: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C3688: 409A0170  bne cr6, 0x830c37f8
	if !ctx.cr[6].eq {
	pc = 0x830C37F8; continue 'dispatch;
	}
	// 830C368C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3690: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C3694: 409A00A8  bne cr6, 0x830c373c
	if !ctx.cr[6].eq {
	pc = 0x830C373C; continue 'dispatch;
	}
	// 830C3698: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C369C: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C36A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C36A4: 409A001C  bne cr6, 0x830c36c0
	if !ctx.cr[6].eq {
	pc = 0x830C36C0; continue 'dispatch;
	}
	// 830C36A8: 9BCB0038  stb r30, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C36AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C36B0: 9BBF0038  stb r29, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C36B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C36B8: 4BFFC479  bl 0x830bfb30
	ctx.lr = 0x830C36BC;
	sub_830BFB30(ctx, base);
	// 830C36BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C36C0: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C36C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C36C8: 409A00C8  bne cr6, 0x830c3790
	if !ctx.cr[6].eq {
	pc = 0x830C3790; continue 'dispatch;
	}
	// 830C36CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C36D0: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C36D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C36D8: 409A0014  bne cr6, 0x830c36ec
	if !ctx.cr[6].eq {
	pc = 0x830C36EC; continue 'dispatch;
	}
	// 830C36DC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C36E0: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C36E4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C36E8: 419A00A4  beq cr6, 0x830c378c
	if ctx.cr[6].eq {
	pc = 0x830C378C; continue 'dispatch;
	}
	// 830C36EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C36F0: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C36F4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C36F8: 409A0020  bne cr6, 0x830c3718
	if !ctx.cr[6].eq {
	pc = 0x830C3718; continue 'dispatch;
	}
	// 830C36FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3700: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830C3704: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C3708: 9BCA0038  stb r30, 0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C370C: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C3710: 4BFFC0B1  bl 0x830bf7c0
	ctx.lr = 0x830C3714;
	sub_830BF7C0(ctx, base);
	// 830C3714: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3718: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C371C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C3720: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C3724: 994B0038  stb r10, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 830C3728: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C372C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3730: 9BCB0038  stb r30, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C3734: 4BFFC3FD  bl 0x830bfb30
	ctx.lr = 0x830C3738;
	sub_830BFB30(ctx, base);
	// 830C3738: 480000C0  b 0x830c37f8
	pc = 0x830C37F8; continue 'dispatch;
	// 830C373C: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C3744: 409A001C  bne cr6, 0x830c3760
	if !ctx.cr[6].eq {
	pc = 0x830C3760; continue 'dispatch;
	}
	// 830C3748: 9BCB0038  stb r30, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C374C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C3750: 9BBF0038  stb r29, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C3754: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C3758: 4BFFC069  bl 0x830bf7c0
	ctx.lr = 0x830C375C;
	sub_830BF7C0(ctx, base);
	// 830C375C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3760: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C3764: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C3768: 409A0028  bne cr6, 0x830c3790
	if !ctx.cr[6].eq {
	pc = 0x830C3790; continue 'dispatch;
	}
	// 830C376C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3770: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3774: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C3778: 409A0034  bne cr6, 0x830c37ac
	if !ctx.cr[6].eq {
	pc = 0x830C37AC; continue 'dispatch;
	}
	// 830C377C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3780: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C3784: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C3788: 409A0024  bne cr6, 0x830c37ac
	if !ctx.cr[6].eq {
	pc = 0x830C37AC; continue 'dispatch;
	}
	// 830C378C: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C3790: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3794: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 830C3798: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C379C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C37A0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C37A4: 409AFEDC  bne cr6, 0x830c3680
	if !ctx.cr[6].eq {
	pc = 0x830C3680; continue 'dispatch;
	}
	// 830C37A8: 48000050  b 0x830c37f8
	pc = 0x830C37F8; continue 'dispatch;
	// 830C37AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C37B0: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C37B4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C37B8: 409A0020  bne cr6, 0x830c37d8
	if !ctx.cr[6].eq {
	pc = 0x830C37D8; continue 'dispatch;
	}
	// 830C37BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C37C0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830C37C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C37C8: 9BCA0038  stb r30, 0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C37CC: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C37D0: 4BFFC361  bl 0x830bfb30
	ctx.lr = 0x830C37D4;
	sub_830BFB30(ctx, base);
	// 830C37D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C37D8: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C37DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C37E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C37E4: 994B0038  stb r10, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 830C37E8: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C37EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C37F0: 9BCB0038  stb r30, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C37F4: 4BFFBFCD  bl 0x830bf7c0
	ctx.lr = 0x830C37F8;
	sub_830BF7C0(ctx, base);
	// 830C37F8: 9BDC0038  stb r30, 0x38(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830C37FC: 387A0018  addi r3, r26, 0x18
	ctx.r[3].s64 = ctx.r[26].s64 + 24;
	// 830C3800: 4B2054B9  bl 0x822c8cb8
	ctx.lr = 0x830C3804;
	sub_822C8CB8(ctx, base);
	// 830C3804: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C3808: 4B1FCA61  bl 0x822c0268
	ctx.lr = 0x830C380C;
	sub_822C0268(ctx, base);
	// 830C380C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C3810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C3814: 419A000C  beq cr6, 0x830c3820
	if ctx.cr[6].eq {
	pc = 0x830C3820; continue 'dispatch;
	}
	// 830C3818: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830C381C: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3820: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830C3824: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830C3828: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830C382C: 480E497C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3830 size=84
    let mut pc: u32 = 0x830C3830;
    'dispatch: loop {
        match pc {
            0x830C3830 => {
    //   block [0x830C3830..0x830C3884)
	// 830C3830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C383C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3844: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3848: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C384C: 4BFFFB95  bl 0x830c33e0
	ctx.lr = 0x830C3850;
	sub_830C33E0(ctx, base);
	// 830C3850: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3854: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C3858: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830C385C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3860: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3864: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C3868: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C386C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3870: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C3874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C387C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3888 size=132
    let mut pc: u32 = 0x830C3888;
    'dispatch: loop {
        match pc {
            0x830C3888 => {
    //   block [0x830C3888..0x830C390C)
	// 830C3888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C388C: 480E48DD  bl 0x831a8168
	ctx.lr = 0x830C3890;
	sub_831A8130(ctx, base);
	// 830C3890: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3894: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C3898: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 830C389C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C38A0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830C38A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C38A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C38AC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C38B0: 409A0044  bne cr6, 0x830c38f4
	if !ctx.cr[6].eq {
	pc = 0x830C38F4; continue 'dispatch;
	}
	// 830C38B4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C38B8: 409A003C  bne cr6, 0x830c38f4
	if !ctx.cr[6].eq {
	pc = 0x830C38F4; continue 'dispatch;
	}
	// 830C38BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C38C0: 4BFFFF71  bl 0x830c3830
	ctx.lr = 0x830C38C4;
	sub_830C3830(ctx, base);
	// 830C38C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C38C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C38CC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C38D0: 48000030  b 0x830c3900
	pc = 0x830C3900; continue 'dispatch;
	// 830C38D4: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 830C38D8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830C38DC: 4BD95F35  bl 0x82e59810
	ctx.lr = 0x830C38E0;
	sub_82E59810(ctx, base);
	// 830C38E0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830C38E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C38E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C38EC: 4BFFFB4D  bl 0x830c3438
	ctx.lr = 0x830C38F0;
	sub_830C3438(ctx, base);
	// 830C38F0: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830C38F4: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830C38F8: 409AFFDC  bne cr6, 0x830c38d4
	if !ctx.cr[6].eq {
	pc = 0x830C38D4; continue 'dispatch;
	}
	// 830C38FC: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 830C3900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C3904: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C3908: 480E48B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C3910 size=8
    let mut pc: u32 = 0x830C3910;
    'dispatch: loop {
        match pc {
            0x830C3910 => {
    //   block [0x830C3910..0x830C3918)
	// 830C3910: 3863006C  addi r3, r3, 0x6c
	ctx.r[3].s64 = ctx.r[3].s64 + 108;
	// 830C3914: 4BFFCE24  b 0x830c0738
	sub_830C0738(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3918 size=216
    let mut pc: u32 = 0x830C3918;
    'dispatch: loop {
        match pc {
            0x830C3918 => {
    //   block [0x830C3918..0x830C39F0)
	// 830C3918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C391C: 480E4851  bl 0x831a816c
	ctx.lr = 0x830C3920;
	sub_831A8130(ctx, base);
	// 830C3920: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C3928: 83E40004  lwz r31, 4(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C392C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3930: 3BA40004  addi r29, r4, 4
	ctx.r[29].s64 = ctx.r[4].s64 + 4;
	// 830C3934: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C3938: 815E008C  lwz r10, 0x8c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 830C393C: 419A0024  beq cr6, 0x830c3960
	if ctx.cr[6].eq {
	pc = 0x830C3960; continue 'dispatch;
	}
	// 830C3940: 393F0004  addi r9, r31, 4
	ctx.r[9].s64 = ctx.r[31].s64 + 4;
	// 830C3944: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 830C3948: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C394C: 7D004828  lwarx r8, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 830C3950: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 830C3954: 7D00492D  stwcx. r8, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C3958: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C395C: 4082FFE8  bne 0x830c3944
	if !ctx.cr[0].eq {
	pc = 0x830C3944; continue 'dispatch;
	}
	// 830C3960: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830C3964: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C3968: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830C396C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 830C3970: 419A0024  beq cr6, 0x830c3994
	if ctx.cr[6].eq {
	pc = 0x830C3994; continue 'dispatch;
	}
	// 830C3974: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 830C3978: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C397C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C3980: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C3984: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C3988: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C398C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C3990: 4082FFE8  bne 0x830c3978
	if !ctx.cr[0].eq {
	pc = 0x830C3978; continue 'dispatch;
	}
	// 830C3994: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830C3998: 389E0080  addi r4, r30, 0x80
	ctx.r[4].s64 = ctx.r[30].s64 + 128;
	// 830C399C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C39A0: 4BD502E9  bl 0x82e13c88
	ctx.lr = 0x830C39A4;
	sub_82E13C88(ctx, base);
	// 830C39A4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830C39A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C39AC: 419A0008  beq cr6, 0x830c39b4
	if ctx.cr[6].eq {
	pc = 0x830C39B4; continue 'dispatch;
	}
	// 830C39B0: 4B1FCEE1  bl 0x822c0890
	ctx.lr = 0x830C39B4;
	sub_822C0890(ctx, base);
	// 830C39B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C39B8: 419A000C  beq cr6, 0x830c39c4
	if ctx.cr[6].eq {
	pc = 0x830C39C4; continue 'dispatch;
	}
	// 830C39BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C39C0: 4B1FCED1  bl 0x822c0890
	ctx.lr = 0x830C39C4;
	sub_822C0890(ctx, base);
	// 830C39C4: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 830C39C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830C39CC: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830C39D0: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 830C39D4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C39D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C39DC: 419A0008  beq cr6, 0x830c39e4
	if ctx.cr[6].eq {
	pc = 0x830C39E4; continue 'dispatch;
	}
	// 830C39E0: 4B1FCEB1  bl 0x822c0890
	ctx.lr = 0x830C39E4;
	sub_822C0890(ctx, base);
	// 830C39E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C39E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C39EC: 480E47D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C39F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C39F0 size=80
    let mut pc: u32 = 0x830C39F0;
    'dispatch: loop {
        match pc {
            0x830C39F0 => {
    //   block [0x830C39F0..0x830C3A40)
	// 830C39F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C39F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C39F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C39FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3A00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C3A08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C3A0C: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3A10: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3A14: 4BFFFE75  bl 0x830c3888
	ctx.lr = 0x830C3A18;
	sub_830C3888(ctx, base);
	// 830C3A18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3A1C: 4B1FC84D  bl 0x822c0268
	ctx.lr = 0x830C3A20;
	sub_822C0268(ctx, base);
	// 830C3A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C3A24: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C3A28: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C3A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3A38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3A40 size=88
    let mut pc: u32 = 0x830C3A40;
    'dispatch: loop {
        match pc {
            0x830C3A40 => {
    //   block [0x830C3A40..0x830C3A98)
	// 830C3A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3A48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3A4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3A50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C3A58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C3A5C: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3A60: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3A64: 4BDA5195  bl 0x82e68bf8
	ctx.lr = 0x830C3A68;
	sub_82E68BF8(ctx, base);
	// 830C3A68: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830C3A6C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3A70: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C3A74: 4BD2E715  bl 0x82df2188
	ctx.lr = 0x830C3A78;
	sub_82DF2188(ctx, base);
	// 830C3A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C3A7C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C3A80: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C3A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C3A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C3A98 size=148
    let mut pc: u32 = 0x830C3A98;
    'dispatch: loop {
        match pc {
            0x830C3A98 => {
    //   block [0x830C3A98..0x830C3B2C)
	// 830C3A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3A9C: 480E46C9  bl 0x831a8164
	ctx.lr = 0x830C3AA0;
	sub_831A8130(ctx, base);
	// 830C3AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3AA8: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C3AAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C3AB0: 396B77D4  addi r11, r11, 0x77d4
	ctx.r[11].s64 = ctx.r[11].s64 + 30676;
	// 830C3AB4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830C3AB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3ABC: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 830C3AC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C3AC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C3AC8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830C3ACC: 4B205365  bl 0x822c8e30
	ctx.lr = 0x830C3AD0;
	sub_822C8E30(ctx, base);
	// 830C3AD0: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 830C3AD4: 4BFFF7ED  bl 0x830c32c0
	ctx.lr = 0x830C3AD8;
	sub_830C32C0(ctx, base);
	// 830C3AD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C3ADC: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 830C3AE0: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 830C3AE4: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 830C3AE8: 4BFFF831  bl 0x830c3318
	ctx.lr = 0x830C3AEC;
	sub_830C3318(ctx, base);
	// 830C3AEC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830C3AF0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 830C3AF4: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 830C3AF8: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 830C3AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3B30 size=100
    let mut pc: u32 = 0x830C3B30;
    'dispatch: loop {
        match pc {
            0x830C3B30 => {
    //   block [0x830C3B30..0x830C3B94)
	// 830C3B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3B38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3B3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3B44: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C3B48: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 830C3B4C: 396B77D4  addi r11, r11, 0x77d4
	ctx.r[11].s64 = ctx.r[11].s64 + 30676;
	// 830C3B50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3B54: 4BFFFEED  bl 0x830c3a40
	ctx.lr = 0x830C3B58;
	sub_830C3A40(ctx, base);
	// 830C3B58: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830C3B5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C3B60: 419A0008  beq cr6, 0x830c3b68
	if ctx.cr[6].eq {
	pc = 0x830C3B68; continue 'dispatch;
	}
	// 830C3B64: 4B1FCD2D  bl 0x822c0890
	ctx.lr = 0x830C3B68;
	sub_822C0890(ctx, base);
	// 830C3B68: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 830C3B6C: 4BFFFE85  bl 0x830c39f0
	ctx.lr = 0x830C3B70;
	sub_830C39F0(ctx, base);
	// 830C3B70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C3B74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C3B78: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 830C3B7C: 4B2052B5  bl 0x822c8e30
	ctx.lr = 0x830C3B80;
	sub_822C8E30(ctx, base);
	// 830C3B80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C3B84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3B88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3B8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C3B98 size=172
    let mut pc: u32 = 0x830C3B98;
    'dispatch: loop {
        match pc {
            0x830C3B98 => {
    //   block [0x830C3B98..0x830C3C44)
	// 830C3B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3B9C: 480E45CD  bl 0x831a8168
	ctx.lr = 0x830C3BA0;
	sub_831A8130(ctx, base);
	// 830C3BA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3BA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3BA8: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C3BAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C3BB0: 396B77D4  addi r11, r11, 0x77d4
	ctx.r[11].s64 = ctx.r[11].s64 + 30676;
	// 830C3BB4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830C3BB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3BBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C3BC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C3BC4: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 830C3BC8: 4B205269  bl 0x822c8e30
	ctx.lr = 0x830C3BCC;
	sub_822C8E30(ctx, base);
	// 830C3BCC: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 830C3BD0: 4BFFF6F1  bl 0x830c32c0
	ctx.lr = 0x830C3BD4;
	sub_830C32C0(ctx, base);
	// 830C3BD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C3BD8: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 830C3BDC: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 830C3BE0: 397F0078  addi r11, r31, 0x78
	ctx.r[11].s64 = ctx.r[31].s64 + 120;
	// 830C3BE4: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 830C3BE8: 4BFFF731  bl 0x830c3318
	ctx.lr = 0x830C3BEC;
	sub_830C3318(ctx, base);
	// 830C3BEC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830C3BF0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 830C3BF4: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3C48 size=76
    let mut pc: u32 = 0x830C3C48;
    'dispatch: loop {
        match pc {
            0x830C3C48 => {
    //   block [0x830C3C48..0x830C3C94)
	// 830C3C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3C50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C3C54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3C58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3C5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3C60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C3C64: 4BFFFECD  bl 0x830c3b30
	ctx.lr = 0x830C3C68;
	sub_830C3B30(ctx, base);
	// 830C3C68: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C3C6C: 4182000C  beq 0x830c3c78
	if ctx.cr[0].eq {
	pc = 0x830C3C78; continue 'dispatch;
	}
	// 830C3C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C3C74: 4B1FC5F5  bl 0x822c0268
	ctx.lr = 0x830C3C78;
	sub_822C0268(ctx, base);
	// 830C3C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C3C7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C3C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3C88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C3C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C3C98 size=244
    let mut pc: u32 = 0x830C3C98;
    'dispatch: loop {
        match pc {
            0x830C3C98 => {
    //   block [0x830C3C98..0x830C3D8C)
	// 830C3C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3C9C: 480E44D1  bl 0x831a816c
	ctx.lr = 0x830C3CA0;
	sub_831A8130(ctx, base);
	// 830C3CA0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830C3CA4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3CA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3CAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C3CB0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C3CB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C3CB8: 408200C4  bne 0x830c3d7c
	if !ctx.cr[0].eq {
	pc = 0x830C3D7C; continue 'dispatch;
	}
	// 830C3CBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3CC0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830C3CC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C3CC8: 9BBF00C0  stb r29, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[29].u8 ) };
	// 830C3CCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C3CD0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C3CD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3CD8: 4E800421  bctrl
	ctx.lr = 0x830C3CDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3CDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C3CE0: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C3CE4: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3CE8: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C3CEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C3CF0: C00B9594  lfs f0, -0x6a6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3CF4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C3CF8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830C3CFC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C3D00: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830C3D04: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3D08: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C3D0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3D10: 4E800421  bctrl
	ctx.lr = 0x830C3D14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3D14: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C3D18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C3D1C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3D20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C3D24: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3D28: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3D2C: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C3D30: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C3D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3D38: 4E800421  bctrl
	ctx.lr = 0x830C3D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3D3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3D40: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C3D48: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3D4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C3D50: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C3D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C3D58: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C3D5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3D60: 4E800421  bctrl
	ctx.lr = 0x830C3D64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3D64: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C3D68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C3D6C: 409A0010  bne cr6, 0x830c3d7c
	if !ctx.cr[6].eq {
	pc = 0x830C3D7C; continue 'dispatch;
	}
	// 830C3D70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C3D74: 9BBF00C1  stb r29, 0xc1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(193 as u32), ctx.r[29].u8 ) };
	// 830C3D78: 48000008  b 0x830c3d80
	pc = 0x830C3D80; continue 'dispatch;
	// 830C3D7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C3D80: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830C3D84: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830C3D88: 480E4434  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3D90 size=136
    let mut pc: u32 = 0x830C3D90;
    'dispatch: loop {
        match pc {
            0x830C3D90 => {
    //   block [0x830C3D90..0x830C3E18)
	// 830C3D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C3D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3DA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C3DA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C3DAC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830C3DB0: 409A0020  bne cr6, 0x830c3dd0
	if !ctx.cr[6].eq {
	pc = 0x830C3DD0; continue 'dispatch;
	}
	// 830C3DB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C3DB8: 419A0048  beq cr6, 0x830c3e00
	if ctx.cr[6].eq {
	pc = 0x830C3E00; continue 'dispatch;
	}
	// 830C3DBC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3DC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3DC4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C3DC8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C3DCC: 48000034  b 0x830c3e00
	pc = 0x830C3E00; continue 'dispatch;
	// 830C3DD0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830C3DD4: 419A002C  beq cr6, 0x830c3e00
	if ctx.cr[6].eq {
	pc = 0x830C3E00; continue 'dispatch;
	}
	// 830C3DD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C3DDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3DE0: 388B4530  addi r4, r11, 0x4530
	ctx.r[4].s64 = ctx.r[11].s64 + 17712;
	// 830C3DE4: 480E4315  bl 0x831a80f8
	ctx.lr = 0x830C3DE8;
	sub_831A80F8(ctx, base);
	// 830C3DE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C3DEC: 4182000C  beq 0x830c3df8
	if ctx.cr[0].eq {
	pc = 0x830C3DF8; continue 'dispatch;
	}
	// 830C3DF0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830C3DF4: 4800000C  b 0x830c3e00
	pc = 0x830C3E00; continue 'dispatch;
	// 830C3DF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C3DFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3E00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C3E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3E0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C3E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C3E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C3E18 size=72
    let mut pc: u32 = 0x830C3E18;
    'dispatch: loop {
        match pc {
            0x830C3E18 => {
    //   block [0x830C3E18..0x830C3E60)
	// 830C3E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3E20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3E24: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 830C3E28: 419A001C  beq cr6, 0x830c3e44
	if ctx.cr[6].eq {
	pc = 0x830C3E44; continue 'dispatch;
	}
	// 830C3E2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C3E30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C3E34: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830C3E38: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C3E3C: 4BFFFF55  bl 0x830c3d90
	ctx.lr = 0x830C3E40;
	sub_830C3D90(ctx, base);
	// 830C3E40: 48000010  b 0x830c3e50
	pc = 0x830C3E50; continue 'dispatch;
	// 830C3E44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C3E48: 396B4530  addi r11, r11, 0x4530
	ctx.r[11].s64 = ctx.r[11].s64 + 17712;
	// 830C3E4C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C3E50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C3E54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C3E58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C3E5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C3E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C3E60 size=432
    let mut pc: u32 = 0x830C3E60;
    'dispatch: loop {
        match pc {
            0x830C3E60 => {
    //   block [0x830C3E60..0x830C4010)
	// 830C3E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C3E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C3E68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C3E6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C3E70: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C3E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C3E78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C3E7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C3E80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C3E84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3E88: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C3E8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3E90: 4E800421  bctrl
	ctx.lr = 0x830C3E94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3E94: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C3E98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830C3E9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3EA0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C3EA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3EA8: 4E800421  bctrl
	ctx.lr = 0x830C3EAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3EAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C3EB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C3EB4: C1610090  lfs f11, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C3EB8: C1410094  lfs f10, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C3EBC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C3EC0: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C3EC4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3EC8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830C3ECC: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830C3ED0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3ED4: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830C3ED8: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830C3EDC: C1899594  lfs f12, -0x6a6c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C3EE0: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C3EE4: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C3EE8: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 830C3EEC: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 830C3EF0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830C3EF4: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C3EF8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C3EFC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830C3F00: EC0D602A  fadds f0, f13, f12
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C3F04: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830C3F08: 480053D9  bl 0x830c92e0
	ctx.lr = 0x830C3F0C;
	sub_830C92E0(ctx, base);
	// 830C3F0C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C3F10: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C3F14: 409A0018  bne cr6, 0x830c3f2c
	if !ctx.cr[6].eq {
	pc = 0x830C3F2C; continue 'dispatch;
	}
	// 830C3F18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C3F1C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C3F20: 4BFFF1B1  bl 0x830c30d0
	ctx.lr = 0x830C3F24;
	sub_830C30D0(ctx, base);
	// 830C3F24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3F28: 4800001C  b 0x830c3f44
	pc = 0x830C3F44; continue 'dispatch;
	// 830C3F2C: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 830C3F30: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 830C3F34: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 830C3F38: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 830C3F3C: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 830C3F40: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C3F44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C3F48: 897F00E8  lbz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830C3F4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C3F50: 409A0050  bne cr6, 0x830c3fa0
	if !ctx.cr[6].eq {
	pc = 0x830C3FA0; continue 'dispatch;
	}
	// 830C3F54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C3F58: 4B204DC1  bl 0x822c8d18
	ctx.lr = 0x830C3F5C;
	sub_822C8D18(ctx, base);
	// 830C3F5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C3F64: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C3F68: 409A0008  bne cr6, 0x830c3f70
	if !ctx.cr[6].eq {
	pc = 0x830C3F70; continue 'dispatch;
	}
	// 830C3F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C3F70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3F74: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C3F78: 3900001A  li r8, 0x1a
	ctx.r[8].s64 = 26;
	// 830C3F7C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830C3F80: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C3F84: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830C3F88: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C3F8C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C3F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3F94: 4E800421  bctrl
	ctx.lr = 0x830C3F98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3F98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C3F9C: 4800004C  b 0x830c3fe8
	pc = 0x830C3FE8; continue 'dispatch;
	// 830C3FA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C3FA4: 4B204D75  bl 0x822c8d18
	ctx.lr = 0x830C3FA8;
	sub_822C8D18(ctx, base);
	// 830C3FA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C3FB0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C3FB4: 409A0008  bne cr6, 0x830c3fbc
	if !ctx.cr[6].eq {
	pc = 0x830C3FBC; continue 'dispatch;
	}
	// 830C3FB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C3FBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C3FC0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C3FC4: 39000019  li r8, 0x19
	ctx.r[8].s64 = 25;
	// 830C3FC8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830C3FCC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C3FD0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830C3FD4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C3FD8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C3FDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C3FE0: 4E800421  bctrl
	ctx.lr = 0x830C3FE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C3FE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C3FE8: 4BD2DCA9  bl 0x82df1c90
	ctx.lr = 0x830C3FEC;
	sub_82DF1C90(ctx, base);
	// 830C3FEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C3FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C3FF4: 4800407D  bl 0x830c8070
	ctx.lr = 0x830C3FF8;
	sub_830C8070(ctx, base);
	// 830C3FF8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830C3FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4004: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C4008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C400C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4010 size=128
    let mut pc: u32 = 0x830C4010;
    'dispatch: loop {
        match pc {
            0x830C4010 => {
    //   block [0x830C4010..0x830C4090)
	// 830C4010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4014: 480E4159  bl 0x831a816c
	ctx.lr = 0x830C4018;
	sub_831A8130(ctx, base);
	// 830C4018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C401C: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830C4020: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830C4024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C4028: 3BEBBDD4  addi r31, r11, -0x422c
	ctx.r[31].s64 = ctx.r[11].s64 + -16940;
	// 830C402C: 816ABDDC  lwz r11, -0x4224(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16932 as u32) ) } as u64;
	// 830C4030: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C4034: 40820024  bne 0x830c4058
	if !ctx.cr[0].eq {
	pc = 0x830C4058; continue 'dispatch;
	}
	// 830C4038: 3D2082E1  lis r9, -0x7d1f
	ctx.r[9].s64 = -2099183616;
	// 830C403C: 3D00830C  lis r8, -0x7cf4
	ctx.r[8].s64 = -2096365568;
	// 830C4040: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C4044: 3929BD78  addi r9, r9, -0x4288
	ctx.r[9].s64 = ctx.r[9].s64 + -17032;
	// 830C4048: 39083E18  addi r8, r8, 0x3e18
	ctx.r[8].s64 = ctx.r[8].s64 + 15896;
	// 830C404C: 916ABDDC  stw r11, -0x4224(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16932 as u32), ctx.r[11].u32 ) };
	// 830C4050: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C4054: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830C4058: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C405C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C4060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4064: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830C4068: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830C406C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C4070: 4BD47681  bl 0x82e0b6f0
	ctx.lr = 0x830C4074;
	sub_82E0B6F0(ctx, base);
	// 830C4074: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4078: 4182000C  beq 0x830c4084
	if ctx.cr[0].eq {
	pc = 0x830C4084; continue 'dispatch;
	}
	// 830C407C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830C4080: 48000008  b 0x830c4088
	pc = 0x830C4088; continue 'dispatch;
	// 830C4084: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830C4088: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C408C: 480E4130  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C4090 size=292
    let mut pc: u32 = 0x830C4090;
    'dispatch: loop {
        match pc {
            0x830C4090 => {
    //   block [0x830C4090..0x830C41B4)
	// 830C4090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4094: 480E40D9  bl 0x831a816c
	ctx.lr = 0x830C4098;
	sub_831A8130(ctx, base);
	// 830C4098: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830C409C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C40A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C40A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C40A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C40AC: 897F00C1  lbz r11, 0xc1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(193 as u32) ) } as u64;
	// 830C40B0: 9BBF00C0  stb r29, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[29].u8 ) };
	// 830C40B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C40B8: 418200EC  beq 0x830c41a4
	if ctx.cr[0].eq {
	pc = 0x830C41A4; continue 'dispatch;
	}
	// 830C40BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C40C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C40C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C40C8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C40CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C40D0: 4E800421  bctrl
	ctx.lr = 0x830C40D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C40D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C40D8: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C40DC: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C40E0: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C40E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C40E8: C00B9594  lfs f0, -0x6a6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C40EC: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C40F0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830C40F4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C40F8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830C40FC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4100: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C4104: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4108: 4E800421  bctrl
	ctx.lr = 0x830C410C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C410C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C4110: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C4114: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4118: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C411C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4120: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4124: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C4128: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C412C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4130: 4E800421  bctrl
	ctx.lr = 0x830C4134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4134: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4138: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C413C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C4140: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4144: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C4148: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C414C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4150: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C4154: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4158: 4E800421  bctrl
	ctx.lr = 0x830C415C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C415C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C4160: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C4164: 409A0040  bne cr6, 0x830c41a4
	if !ctx.cr[6].eq {
	pc = 0x830C41A4; continue 'dispatch;
	}
	// 830C4168: 897F00E8  lbz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830C416C: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 830C4170: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830C4174: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830C4178: 9BBF00C1  stb r29, 0xc1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(193 as u32), ctx.r[29].u8 ) };
	// 830C417C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C4180: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830C4184: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830C4188: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830C418C: 997F00E8  stb r11, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 830C4190: 419A000C  beq cr6, 0x830c419c
	if ctx.cr[6].eq {
	pc = 0x830C419C; continue 'dispatch;
	}
	// 830C4194: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C4198: 4B4ED731  bl 0x825b18c8
	ctx.lr = 0x830C419C;
	sub_825B18C8(ctx, base);
	// 830C419C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C41A0: 48000008  b 0x830c41a8
	pc = 0x830C41A8; continue 'dispatch;
	// 830C41A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C41A8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830C41AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830C41B0: 480E400C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C41B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C41B8 size=356
    let mut pc: u32 = 0x830C41B8;
    'dispatch: loop {
        match pc {
            0x830C41B8 => {
    //   block [0x830C41B8..0x830C431C)
	// 830C41B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C41BC: 480E3FA9  bl 0x831a8164
	ctx.lr = 0x830C41C0;
	sub_831A8130(ctx, base);
	// 830C41C0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C41C4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830C41C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C41CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C41D0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C41D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C41D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C41DC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830C41E0: 4B205C79  bl 0x822c9e58
	ctx.lr = 0x830C41E4;
	sub_822C9E58(ctx, base);
	// 830C41E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830C41E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C41EC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830C41F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C41F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C41F8: 48003F71  bl 0x830c8168
	ctx.lr = 0x830C41FC;
	sub_830C8168(ctx, base);
	// 830C41FC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C4200: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C4204: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C4208: 396B77F8  addi r11, r11, 0x77f8
	ctx.r[11].s64 = ctx.r[11].s64 + 30712;
	// 830C420C: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830C4210: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830C4214: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C4218: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C421C: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 830C4220: 396A7B70  addi r11, r10, 0x7b70
	ctx.r[11].s64 = ctx.r[10].s64 + 31600;
	// 830C4224: 9BDF00E8  stb r30, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u8 ) };
	// 830C4228: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C422C: 4B204A8D  bl 0x822c8cb8
	ctx.lr = 0x830C4230;
	sub_822C8CB8(ctx, base);
	// 830C4230: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C4234: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C4238: 4BFFFDD9  bl 0x830c4010
	ctx.lr = 0x830C423C;
	sub_830C4010(ctx, base);
	// 830C423C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C4240: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C4244: 4B4C7CCD  bl 0x8258bf10
	ctx.lr = 0x830C4248;
	sub_8258BF10(ctx, base);
	// 830C4248: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830C424C: 3BBF006C  addi r29, r31, 0x6c
	ctx.r[29].s64 = ctx.r[31].s64 + 108;
	// 830C4250: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C4254: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C4258: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C425C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C4260: 4BFFCB01  bl 0x830c0d60
	ctx.lr = 0x830C4264;
	sub_830C0D60(ctx, base);
	// 830C4264: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C4268: 4B3ACE61  bl 0x824710c8
	ctx.lr = 0x830C426C;
	sub_824710C8(ctx, base);
	// 830C426C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C4270: 4B204A49  bl 0x822c8cb8
	ctx.lr = 0x830C4274;
	sub_822C8CB8(ctx, base);
	// 830C4274: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C4278: 4B204A41  bl 0x822c8cb8
	ctx.lr = 0x830C427C;
	sub_822C8CB8(ctx, base);
	// 830C427C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 830C4280: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C4284: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C4288: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C428C: 396B7B80  addi r11, r11, 0x7b80
	ctx.r[11].s64 = ctx.r[11].s64 + 31616;
	// 830C4290: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C4294: 4B204A25  bl 0x822c8cb8
	ctx.lr = 0x830C4298;
	sub_822C8CB8(ctx, base);
	// 830C4298: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C429C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C42A0: 4BFFFD71  bl 0x830c4010
	ctx.lr = 0x830C42A4;
	sub_830C4010(ctx, base);
	// 830C42A4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830C42A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C42AC: 4B4C7C65  bl 0x8258bf10
	ctx.lr = 0x830C42B0;
	sub_8258BF10(ctx, base);
	// 830C42B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C42B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C42B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C42BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C42C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C42C4: 4BFFCA9D  bl 0x830c0d60
	ctx.lr = 0x830C42C8;
	sub_830C0D60(ctx, base);
	// 830C42C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C42CC: 4B3ACDFD  bl 0x824710c8
	ctx.lr = 0x830C42D0;
	sub_824710C8(ctx, base);
	// 830C42D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C42D4: 4B2049E5  bl 0x822c8cb8
	ctx.lr = 0x830C42D8;
	sub_822C8CB8(ctx, base);
	// 830C42D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C42DC: 4B2049DD  bl 0x822c8cb8
	ctx.lr = 0x830C42E0;
	sub_822C8CB8(ctx, base);
	// 830C42E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C42E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C42E8: 9BDF00C0  stb r30, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u8 ) };
	// 830C42EC: 9BDF00C1  stb r30, 0xc1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(193 as u32), ctx.r[30].u8 ) };
	// 830C42F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C42F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C42F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C42FC: C00B959C  lfs f0, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4300: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4304: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830C4308: D1BF00B0  stfs f13, 0xb0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830C430C: 4B204B25  bl 0x822c8e30
	ctx.lr = 0x830C4310;
	sub_822C8E30(ctx, base);
	// 830C4310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4314: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830C4318: 480E3E9C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4320 size=104
    let mut pc: u32 = 0x830C4320;
    'dispatch: loop {
        match pc {
            0x830C4320 => {
    //   block [0x830C4320..0x830C4388)
	// 830C4320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C432C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4338: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C433C: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 830C4340: 4B204979  bl 0x822c8cb8
	ctx.lr = 0x830C4344;
	sub_822C8CB8(ctx, base);
	// 830C4344: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830C4348: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C434C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C4350: 4B204AE1  bl 0x822c8e30
	ctx.lr = 0x830C4354;
	sub_822C8E30(ctx, base);
	// 830C4354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4358: 4BFFF7D9  bl 0x830c3b30
	ctx.lr = 0x830C435C;
	sub_830C3B30(ctx, base);
	// 830C435C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4360: 4182000C  beq 0x830c436c
	if ctx.cr[0].eq {
	pc = 0x830C436C; continue 'dispatch;
	}
	// 830C4364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4368: 4B1FBF01  bl 0x822c0268
	ctx.lr = 0x830C436C;
	sub_822C0268(ctx, base);
	// 830C436C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4370: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C437C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C4380: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C4384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C4388 size=24
    let mut pc: u32 = 0x830C4388;
    'dispatch: loop {
        match pc {
            0x830C4388 => {
    //   block [0x830C4388..0x830C43A0)
	// 830C4388: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C438C: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C4390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C4394: 419A000C  beq cr6, 0x830c43a0
	if ctx.cr[6].eq {
		sub_830C43A0(ctx, base);
		return;
	}
	// 830C4398: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C439C: 48000070  b 0x830c440c
	sub_830C440C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C43A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C43A0 size=24
    let mut pc: u32 = 0x830C43A0;
    'dispatch: loop {
        match pc {
            0x830C43A0 => {
    //   block [0x830C43A0..0x830C43B8)
	// 830C43A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C43A4: 892A0031  lbz r9, 0x31(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C43A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C43AC: 409A0040  bne cr6, 0x830c43ec
	if !ctx.cr[6].eq {
		sub_830C43D4(ctx, base);
		return;
	}
	// 830C43B0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C43B4: 4800000C  b 0x830c43c0
	sub_830C43B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C43B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C43B8 size=28
    let mut pc: u32 = 0x830C43B8;
    'dispatch: loop {
        match pc {
            0x830C43B8 => {
    //   block [0x830C43B8..0x830C43D4)
	// 830C43B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830C43BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C43C0: 892B0031  lbz r9, 0x31(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C43C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C43C8: 419AFFF0  beq cr6, 0x830c43b8
	if ctx.cr[6].eq {
	pc = 0x830C43B8; continue 'dispatch;
	}
	// 830C43CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C43D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C43D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C43D4 size=56
    let mut pc: u32 = 0x830C43D4;
    'dispatch: loop {
        match pc {
            0x830C43D4 => {
    //   block [0x830C43D4..0x830C440C)
	// 830C43D4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C43D8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C43DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830C43E0: 409A001C  bne cr6, 0x830c43fc
	if !ctx.cr[6].eq {
	pc = 0x830C43FC; continue 'dispatch;
	}
	// 830C43E4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C43E8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830C43EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C43F0: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C43F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C43F8: 419AFFDC  beq cr6, 0x830c43d4
	if ctx.cr[6].eq {
	pc = 0x830C43D4; continue 'dispatch;
	}
	// 830C43FC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4400: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C4404: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C4408: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C440C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C440C size=8
    let mut pc: u32 = 0x830C440C;
    'dispatch: loop {
        match pc {
            0x830C440C => {
    //   block [0x830C440C..0x830C4414)
	// 830C440C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C4410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4418 size=136
    let mut pc: u32 = 0x830C4418;
    'dispatch: loop {
        match pc {
            0x830C4418 => {
    //   block [0x830C4418..0x830C44A0)
	// 830C4418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C441C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C4424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C442C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C4430: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C4434: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830C4438: 409A0020  bne cr6, 0x830c4458
	if !ctx.cr[6].eq {
	pc = 0x830C4458; continue 'dispatch;
	}
	// 830C443C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C4440: 419A0048  beq cr6, 0x830c4488
	if ctx.cr[6].eq {
	pc = 0x830C4488; continue 'dispatch;
	}
	// 830C4444: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4448: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C444C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4450: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C4454: 48000034  b 0x830c4488
	pc = 0x830C4488; continue 'dispatch;
	// 830C4458: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830C445C: 419A002C  beq cr6, 0x830c4488
	if ctx.cr[6].eq {
	pc = 0x830C4488; continue 'dispatch;
	}
	// 830C4460: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C4464: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4468: 388B45F8  addi r4, r11, 0x45f8
	ctx.r[4].s64 = ctx.r[11].s64 + 17912;
	// 830C446C: 480E3C8D  bl 0x831a80f8
	ctx.lr = 0x830C4470;
	sub_831A80F8(ctx, base);
	// 830C4470: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4474: 4182000C  beq 0x830c4480
	if ctx.cr[0].eq {
	pc = 0x830C4480; continue 'dispatch;
	}
	// 830C4478: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830C447C: 4800000C  b 0x830c4488
	pc = 0x830C4488; continue 'dispatch;
	// 830C4480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C4484: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C4488: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C448C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4494: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C4498: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C449C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C44A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C44A0 size=300
    let mut pc: u32 = 0x830C44A0;
    'dispatch: loop {
        match pc {
            0x830C44A0 => {
    //   block [0x830C44A0..0x830C45CC)
	// 830C44A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C44A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C44A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C44AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C44B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C44B4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C44B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C44BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C44C0: 897F00E8  lbz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830C44C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C44C8: 408200E4  bne 0x830c45ac
	if !ctx.cr[0].eq {
	pc = 0x830C45AC; continue 'dispatch;
	}
	// 830C44CC: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C44D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C44D4: 997F00E8  stb r11, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 830C44D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C44DC: 419A0020  beq cr6, 0x830c44fc
	if ctx.cr[6].eq {
	pc = 0x830C44FC; continue 'dispatch;
	}
	// 830C44E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C44E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C44E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C44EC: 4E800421  bctrl
	ctx.lr = 0x830C44F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C44F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C44F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C44F8: 419A00B4  beq cr6, 0x830c45ac
	if ctx.cr[6].eq {
	pc = 0x830C45AC; continue 'dispatch;
	}
	// 830C44FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4500: C3FE0008  lfs f31, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C4504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C4508: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C450C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C4510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4514: 4E800421  bctrl
	ctx.lr = 0x830C4518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4518: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C451C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C4520: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4524: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C4528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C452C: 4E800421  bctrl
	ctx.lr = 0x830C4530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4534: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C453C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4540: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C4544: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C4548: EC206028  fsubs f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C454C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C4550: EC4D5828  fsubs f2, f13, f11
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C4554: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4558: 4E800421  bctrl
	ctx.lr = 0x830C455C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C455C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4560: 4082000C  bne 0x830c456c
	if !ctx.cr[0].eq {
	pc = 0x830C456C; continue 'dispatch;
	}
	// 830C4564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C4568: 48000048  b 0x830c45b0
	pc = 0x830C45B0; continue 'dispatch;
	// 830C456C: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4570: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C4574: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C4578: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C457C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C4580: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C4584: 419A0014  beq cr6, 0x830c4598
	if ctx.cr[6].eq {
	pc = 0x830C4598; continue 'dispatch;
	}
	// 830C4588: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C458C: 4800433D  bl 0x830c88c8
	ctx.lr = 0x830C4590;
	sub_830C88C8(ctx, base);
	// 830C4590: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4594: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830C4598: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C459C: 396000F8  li r11, 0xf8
	ctx.r[11].s64 = 248;
	// 830C45A0: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C45A4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C45A8: 7C1F5FAE  stfiwx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 830C45AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C45B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C45B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C45B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C45BC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C45C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C45C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C45C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C45D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C45D0 size=260
    let mut pc: u32 = 0x830C45D0;
    'dispatch: loop {
        match pc {
            0x830C45D0 => {
    //   block [0x830C45D0..0x830C46D4)
	// 830C45D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C45D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C45D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C45DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C45E0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C45E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C45E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C45EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C45F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C45F4: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C45F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C45FC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C4600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4604: 4E800421  bctrl
	ctx.lr = 0x830C4608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4608: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C460C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C4610: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4614: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C4618: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C461C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4620: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C4624: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C4628: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C462C: 4E800421  bctrl
	ctx.lr = 0x830C4630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4630: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4634: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C463C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4640: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C4644: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C4648: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C464C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4650: 4E800421  bctrl
	ctx.lr = 0x830C4654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4654: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C4658: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C465C: 409A0058  bne cr6, 0x830c46b4
	if !ctx.cr[6].eq {
	pc = 0x830C46B4; continue 'dispatch;
	}
	// 830C4660: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830C4664: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 830C4668: 4099004C  ble cr6, 0x830c46b4
	if !ctx.cr[6].gt {
	pc = 0x830C46B4; continue 'dispatch;
	}
	// 830C466C: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C4670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4674: 419A0014  beq cr6, 0x830c4688
	if ctx.cr[6].eq {
	pc = 0x830C4688; continue 'dispatch;
	}
	// 830C4678: 813F010C  lwz r9, 0x10c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 830C467C: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 830C4680: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830C4684: 7D6B43D6  divw r11, r11, r8
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[8].s32;
	// 830C4688: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C468C: 40980028  bge cr6, 0x830c46b4
	if !ctx.cr[6].lt {
	pc = 0x830C46B4; continue 'dispatch;
	}
	// 830C4690: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C4694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C4698: 419A001C  beq cr6, 0x830c46b4
	if ctx.cr[6].eq {
	pc = 0x830C46B4; continue 'dispatch;
	}
	// 830C469C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C46A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C46A4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C46A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C46AC: 4E800421  bctrl
	ctx.lr = 0x830C46B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C46B0: 48000008  b 0x830c46b8
	pc = 0x830C46B8; continue 'dispatch;
	// 830C46B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C46B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C46BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C46C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C46C4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C46C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C46CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C46D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C46D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C46D8 size=108
    let mut pc: u32 = 0x830C46D8;
    'dispatch: loop {
        match pc {
            0x830C46D8 => {
    //   block [0x830C46D8..0x830C4744)
	// 830C46D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C46DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C46E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C46E4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830C46E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C46EC: 38C00034  li r6, 0x34
	ctx.r[6].s64 = 52;
	// 830C46F0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 830C46F4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 830C46F8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C46FC: 4BD2D9CD  bl 0x82df20c8
	ctx.lr = 0x830C4700;
	sub_82DF20C8(ctx, base);
	// 830C4700: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C4704: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C4708: 41820008  beq 0x830c4710
	if ctx.cr[0].eq {
	pc = 0x830C4710; continue 'dispatch;
	}
	// 830C470C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C4710: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4714: 41820008  beq 0x830c471c
	if ctx.cr[0].eq {
	pc = 0x830C471C; continue 'dispatch;
	}
	// 830C4718: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C471C: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4720: 41820008  beq 0x830c4728
	if ctx.cr[0].eq {
	pc = 0x830C4728; continue 'dispatch;
	}
	// 830C4724: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C4728: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C472C: 99430031  stb r10, 0x31(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(49 as u32), ctx.r[10].u8 ) };
	// 830C4730: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 830C4734: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C4738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C473C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4748 size=96
    let mut pc: u32 = 0x830C4748;
    'dispatch: loop {
        match pc {
            0x830C4748 => {
    //   block [0x830C4748..0x830C47A8)
	// 830C4748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C474C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C4754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C475C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C4760: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 830C4764: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830C4768: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C476C: 419A0024  beq cr6, 0x830c4790
	if ctx.cr[6].eq {
	pc = 0x830C4790; continue 'dispatch;
	}
	// 830C4770: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4774: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 830C4778: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830C477C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C4780: 4B424A01  bl 0x824e9180
	ctx.lr = 0x830C4784;
	sub_824E9180(ctx, base);
	// 830C4784: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C4788: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C478C: 409AFFE4  bne cr6, 0x830c4770
	if !ctx.cr[6].eq {
	pc = 0x830C4770; continue 'dispatch;
	}
	// 830C4790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C479C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C47A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C47A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C47A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C47A8 size=84
    let mut pc: u32 = 0x830C47A8;
    'dispatch: loop {
        match pc {
            0x830C47A8 => {
    //   block [0x830C47A8..0x830C47FC)
	// 830C47A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C47AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C47B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C47B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C47B8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830C47BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C47C0: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 830C47C4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 830C47C8: 38890004  addi r4, r9, 4
	ctx.r[4].s64 = ctx.r[9].s64 + 4;
	// 830C47CC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C47D0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 830C47D4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830C47D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C47DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C47E0: 4B1FFC81  bl 0x822c4460
	ctx.lr = 0x830C47E4;
	sub_822C4460(ctx, base);
	// 830C47E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C47E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C47EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C47F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C47F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C47F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C4800 size=8
    let mut pc: u32 = 0x830C4800;
    'dispatch: loop {
        match pc {
            0x830C4800 => {
    //   block [0x830C4800..0x830C4808)
	// 830C4800: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C4804: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C4808 size=36
    let mut pc: u32 = 0x830C4808;
    'dispatch: loop {
        match pc {
            0x830C4808 => {
    //   block [0x830C4808..0x830C482C)
	// 830C4808: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C480C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 830C4810: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C4814: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4818: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C481C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C4820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4824: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C4828: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C482C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C482C size=36
    let mut pc: u32 = 0x830C482C;
    'dispatch: loop {
        match pc {
            0x830C482C => {
    //   block [0x830C482C..0x830C4850)
	// 830C482C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C4830: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C4834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C4838: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C483C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C4840: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C4844: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C4848: 4082FFE8  bne 0x830c4830
	if !ctx.cr[0].eq {
	pc = 0x830C4830; continue 'dispatch;
	}
	// 830C484C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4850 size=88
    let mut pc: u32 = 0x830C4850;
    'dispatch: loop {
        match pc {
            0x830C4850 => {
    //   block [0x830C4850..0x830C48A8)
	// 830C4850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C485C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C486C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C4870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C4874: 419A0008  beq cr6, 0x830c487c
	if ctx.cr[6].eq {
	pc = 0x830C487C; continue 'dispatch;
	}
	// 830C4878: 4B1FC019  bl 0x822c0890
	ctx.lr = 0x830C487C;
	sub_822C0890(ctx, base);
	// 830C487C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4880: 4182000C  beq 0x830c488c
	if ctx.cr[0].eq {
	pc = 0x830C488C; continue 'dispatch;
	}
	// 830C4884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4888: 4B1FB9E1  bl 0x822c0268
	ctx.lr = 0x830C488C;
	sub_822C0268(ctx, base);
	// 830C488C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4890: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C489C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C48A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C48A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C48A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C48A8 size=72
    let mut pc: u32 = 0x830C48A8;
    'dispatch: loop {
        match pc {
            0x830C48A8 => {
    //   block [0x830C48A8..0x830C48F0)
	// 830C48A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C48AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C48B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C48B4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 830C48B8: 419A001C  beq cr6, 0x830c48d4
	if ctx.cr[6].eq {
	pc = 0x830C48D4; continue 'dispatch;
	}
	// 830C48BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C48C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C48C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830C48C8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C48CC: 4BFFFB4D  bl 0x830c4418
	ctx.lr = 0x830C48D0;
	sub_830C4418(ctx, base);
	// 830C48D0: 48000010  b 0x830c48e0
	pc = 0x830C48E0; continue 'dispatch;
	// 830C48D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C48D8: 396B45F8  addi r11, r11, 0x45f8
	ctx.r[11].s64 = ctx.r[11].s64 + 17912;
	// 830C48DC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C48E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C48E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C48E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C48EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C48F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C48F0 size=100
    let mut pc: u32 = 0x830C48F0;
    'dispatch: loop {
        match pc {
            0x830C48F0 => {
    //   block [0x830C48F0..0x830C4954)
	// 830C48F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C48F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C48F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C48FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4904: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C4908: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C490C: 93C30038  stw r30, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 830C4910: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4914: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C4918: 4800001C  b 0x830c4934
	pc = 0x830C4934; continue 'dispatch;
	// 830C491C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C4920: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C4924: 4BFFFFCD  bl 0x830c48f0
	ctx.lr = 0x830C4928;
	sub_830C48F0(ctx, base);
	// 830C4928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C492C: 4B424855  bl 0x824e9180
	ctx.lr = 0x830C4930;
	sub_824E9180(ctx, base);
	// 830C4930: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C4934: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C4938: 409AFFE4  bne cr6, 0x830c491c
	if !ctx.cr[6].eq {
	pc = 0x830C491C; continue 'dispatch;
	}
	// 830C493C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4948: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C494C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C4950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C4958 size=180
    let mut pc: u32 = 0x830C4958;
    'dispatch: loop {
        match pc {
            0x830C4958 => {
    //   block [0x830C4958..0x830C4A0C)
	// 830C4958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C495C: 480E380D  bl 0x831a8168
	ctx.lr = 0x830C4960;
	sub_831A8130(ctx, base);
	// 830C4960: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4964: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C496C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830C4970: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830C4974: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830C4978: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C497C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4980: 4E800421  bctrl
	ctx.lr = 0x830C4984;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4984: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C4988: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C498C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C4990: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4994: C1AAC664  lfs f13, -0x399c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4998: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830C499C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830C49A0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830C49A4: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830C49A8: 4B204371  bl 0x822c8d18
	ctx.lr = 0x830C49AC;
	sub_822C8D18(ctx, base);
	// 830C49AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C49B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C49B4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C49B8: 409A0008  bne cr6, 0x830c49c0
	if !ctx.cr[6].eq {
	pc = 0x830C49C0; continue 'dispatch;
	}
	// 830C49BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C49C0: 396000B4  li r11, 0xb4
	ctx.r[11].s64 = 180;
	// 830C49C4: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 830C49C8: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C49CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830C49D0: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 830C49D4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830C49D8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 830C49DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C49E0: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 830C49E4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830C49E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C49EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C49F0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C49F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C49F8: 4E800421  bctrl
	ctx.lr = 0x830C49FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C49FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C4A00: 4BD2D291  bl 0x82df1c90
	ctx.lr = 0x830C4A04;
	sub_82DF1C90(ctx, base);
	// 830C4A04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C4A08: 480E37B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C4A10 size=812
    let mut pc: u32 = 0x830C4A10;
    'dispatch: loop {
        match pc {
            0x830C4A10 => {
    //   block [0x830C4A10..0x830C4D3C)
	// 830C4A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4A14: 480E3751  bl 0x831a8164
	ctx.lr = 0x830C4A18;
	sub_831A8130(ctx, base);
	// 830C4A18: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4A20: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C4A24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C4A28: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C4A2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4A30: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C4A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4A38: 4E800421  bctrl
	ctx.lr = 0x830C4A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4A3C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C4A40: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C4A44: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4A48: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C4A4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4A50: 4E800421  bctrl
	ctx.lr = 0x830C4A54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4A54: C00100A4  lfs f0, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4A58: C1A100A0  lfs f13, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4A5C: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 830C4A60: C1810084  lfs f12, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C4A64: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C4A68: C1610080  lfs f11, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C4A6C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C4A70: C141008C  lfs f10, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C4A74: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C4A78: C1210088  lfs f9, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C4A7C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C4A80: EDA9682A  fadds f13, f9, f13
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C4A84: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830C4A88: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830C4A8C: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 830C4A90: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830C4A94: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830C4A98: 48004849  bl 0x830c92e0
	ctx.lr = 0x830C4A9C;
	sub_830C92E0(ctx, base);
	// 830C4A9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C4AA0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C4AA4: 409A0010  bne cr6, 0x830c4ab4
	if !ctx.cr[6].eq {
	pc = 0x830C4AB4; continue 'dispatch;
	}
	// 830C4AA8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C4AAC: 4BDB3AD5  bl 0x82e78580
	ctx.lr = 0x830C4AB0;
	sub_82E78580(ctx, base);
	// 830C4AB0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C4AB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C4AB8: 4B204261  bl 0x822c8d18
	ctx.lr = 0x830C4ABC;
	sub_822C8D18(ctx, base);
	// 830C4ABC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4AC4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C4AC8: 409A0008  bne cr6, 0x830c4ad0
	if !ctx.cr[6].eq {
	pc = 0x830C4AD0; continue 'dispatch;
	}
	// 830C4ACC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C4AD0: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 830C4AD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830C4AD8: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 830C4ADC: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C4AE0: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 830C4AE4: 3900000B  li r8, 0xb
	ctx.r[8].s64 = 11;
	// 830C4AE8: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 830C4AEC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830C4AF0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4AF4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830C4AF8: C04BE830  lfs f2, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C4AFC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C4B00: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C4B04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4B08: 4E800421  bctrl
	ctx.lr = 0x830C4B0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4B0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C4B10: 4BD2D181  bl 0x82df1c90
	ctx.lr = 0x830C4B14;
	sub_82DF1C90(ctx, base);
	// 830C4B14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C4B18: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 830C4B1C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C4B20: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 830C4B24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C4B28: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4B2C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4B30: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830C4B34: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C4B38: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830C4B3C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830C4B40: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 830C4B44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4B48: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C4B4C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C4B50: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830C4B54: 419A0078  beq cr6, 0x830c4bcc
	if ctx.cr[6].eq {
	pc = 0x830C4BCC; continue 'dispatch;
	}
	// 830C4B58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4B5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C4B60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4B64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C4B68: 4E800421  bctrl
	ctx.lr = 0x830C4B6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C4B6C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830C4B70: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C4B74: 48003D55  bl 0x830c88c8
	ctx.lr = 0x830C4B78;
	sub_830C88C8(ctx, base);
	// 830C4B78: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C4B7C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 830C4B80: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 830C4B84: 892B0088  lbz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4D40 size=88
    let mut pc: u32 = 0x830C4D40;
    'dispatch: loop {
        match pc {
            0x830C4D40 => {
    //   block [0x830C4D40..0x830C4D98)
	// 830C4D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4D4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4D54: 4BFFF985  bl 0x830c46d8
	ctx.lr = 0x830C4D58;
	sub_830C46D8(ctx, base);
	// 830C4D58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C4D5C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830C4D60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C4D64: 99630031  stb r11, 0x31(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(49 as u32), ctx.r[11].u8 ) };
	// 830C4D68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4D6C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C4D70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4D74: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C4D78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4D7C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C4D80: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C4D84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C4D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4D90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C4D94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4D98 size=88
    let mut pc: u32 = 0x830C4D98;
    'dispatch: loop {
        match pc {
            0x830C4D98 => {
    //   block [0x830C4D98..0x830C4DF0)
	// 830C4D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4D9C: 480E33D1  bl 0x831a816c
	ctx.lr = 0x830C4DA0;
	sub_831A8130(ctx, base);
	// 830C4DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4DA4: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4DA8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C4DAC: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4DB0: 48000028  b 0x830c4dd8
	pc = 0x830C4DD8; continue 'dispatch;
	// 830C4DB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C4DB8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830C4DBC: 4BD30E55  bl 0x82df5c10
	ctx.lr = 0x830C4DC0;
	sub_82DF5C10(ctx, base);
	// 830C4DC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4DC4: 4182000C  beq 0x830c4dd0
	if ctx.cr[0].eq {
	pc = 0x830C4DD0; continue 'dispatch;
	}
	// 830C4DC8: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C4DCC: 4800000C  b 0x830c4dd8
	pc = 0x830C4DD8; continue 'dispatch;
	// 830C4DD0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830C4DD4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4DD8: 897F0031  lbz r11, 0x31(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C4DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4DE0: 419AFFD4  beq cr6, 0x830c4db4
	if ctx.cr[6].eq {
	pc = 0x830C4DB4; continue 'dispatch;
	}
	// 830C4DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C4DE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4DEC: 480E33D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4DF0 size=88
    let mut pc: u32 = 0x830C4DF0;
    'dispatch: loop {
        match pc {
            0x830C4DF0 => {
    //   block [0x830C4DF0..0x830C4E48)
	// 830C4DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4DF4: 480E3379  bl 0x831a816c
	ctx.lr = 0x830C4DF8;
	sub_831A8130(ctx, base);
	// 830C4DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4DFC: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4E00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C4E04: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4E08: 48000028  b 0x830c4e30
	pc = 0x830C4E30; continue 'dispatch;
	// 830C4E0C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 830C4E10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C4E14: 4BD30DFD  bl 0x82df5c10
	ctx.lr = 0x830C4E18;
	sub_82DF5C10(ctx, base);
	// 830C4E18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C4E1C: 41820010  beq 0x830c4e2c
	if ctx.cr[0].eq {
	pc = 0x830C4E2C; continue 'dispatch;
	}
	// 830C4E20: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830C4E24: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4E28: 48000008  b 0x830c4e30
	pc = 0x830C4E30; continue 'dispatch;
	// 830C4E2C: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C4E30: 897F0031  lbz r11, 0x31(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C4E34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4E38: 419AFFD4  beq cr6, 0x830c4e0c
	if ctx.cr[6].eq {
	pc = 0x830C4E0C; continue 'dispatch;
	}
	// 830C4E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C4E40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4E44: 480E3378  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4E48 size=120
    let mut pc: u32 = 0x830C4E48;
    'dispatch: loop {
        match pc {
            0x830C4E48 => {
    //   block [0x830C4E48..0x830C4EC0)
	// 830C4E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C4E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4E60: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830C4E64: 4B204FF5  bl 0x822c9e58
	ctx.lr = 0x830C4E68;
	sub_822C9E58(ctx, base);
	// 830C4E68: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 830C4E6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C4E70: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830C4E74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C4E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4E7C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830C4E80: 419A0024  beq cr6, 0x830c4ea4
	if ctx.cr[6].eq {
	pc = 0x830C4EA4; continue 'dispatch;
	}
	// 830C4E84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C4E88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C4E8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C4E90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C4E94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C4E98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C4E9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C4EA0: 4082FFE8  bne 0x830c4e88
	if !ctx.cr[0].eq {
	pc = 0x830C4E88; continue 'dispatch;
	}
	// 830C4EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4EA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4EB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C4EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C4EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4EC0 size=120
    let mut pc: u32 = 0x830C4EC0;
    'dispatch: loop {
        match pc {
            0x830C4EC0 => {
    //   block [0x830C4EC0..0x830C4F38)
	// 830C4EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C4ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4ED8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C4EDC: 4B204F7D  bl 0x822c9e58
	ctx.lr = 0x830C4EE0;
	sub_822C9E58(ctx, base);
	// 830C4EE0: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 830C4EE4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C4EE8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830C4EEC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C4EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4EF4: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830C4EF8: 419A0024  beq cr6, 0x830c4f1c
	if ctx.cr[6].eq {
	pc = 0x830C4F1C; continue 'dispatch;
	}
	// 830C4EFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C4F00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C4F04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C4F08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C4F0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C4F10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C4F14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C4F18: 4082FFE8  bne 0x830c4f00
	if !ctx.cr[0].eq {
	pc = 0x830C4F00; continue 'dispatch;
	}
	// 830C4F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4F20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4F24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4F28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4F2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C4F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C4F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C4F38 size=84
    let mut pc: u32 = 0x830C4F38;
    'dispatch: loop {
        match pc {
            0x830C4F38 => {
    //   block [0x830C4F38..0x830C4F8C)
	// 830C4F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C4F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C4F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C4F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4F4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C4F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C4F54: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830C4F58: 419A001C  beq cr6, 0x830c4f74
	if ctx.cr[6].eq {
	pc = 0x830C4F74; continue 'dispatch;
	}
	// 830C4F5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C4F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C4F64: 4BFFF8ED  bl 0x830c4850
	ctx.lr = 0x830C4F68;
	sub_830C4850(ctx, base);
	// 830C4F68: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830C4F6C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830C4F70: 409AFFEC  bne cr6, 0x830c4f5c
	if !ctx.cr[6].eq {
	pc = 0x830C4F5C; continue 'dispatch;
	}
	// 830C4F74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C4F78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C4F7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C4F80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C4F84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C4F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C4F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C4F90 size=304
    let mut pc: u32 = 0x830C4F90;
    'dispatch: loop {
        match pc {
            0x830C4F90 => {
    //   block [0x830C4F90..0x830C50C0)
	// 830C4F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C4F94: 480E31CD  bl 0x831a8160
	ctx.lr = 0x830C4F98;
	sub_831A8130(ctx, base);
	// 830C4F98: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C4F9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C4FA0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C4FA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C4FA8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830C4FAC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830C4FB0: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4FB4: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4FB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830C4FBC: 419800FC  blt cr6, 0x830c50b8
	if ctx.cr[6].lt {
	pc = 0x830C50B8; continue 'dispatch;
	}
	// 830C4FC0: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C4FC4: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C4FC8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C4FCC: 419900EC  bgt cr6, 0x830c50b8
	if ctx.cr[6].gt {
	pc = 0x830C50B8; continue 'dispatch;
	}
	// 830C4FD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C4FD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C4FD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C4FDC: 4B203E55  bl 0x822c8e30
	ctx.lr = 0x830C4FE0;
	sub_822C8E30(ctx, base);
	// 830C4FE0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C4FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C4FE8: 40990028  ble cr6, 0x830c5010
	if !ctx.cr[6].gt {
	pc = 0x830C5010; continue 'dispatch;
	}
	// 830C4FEC: 897E0034  lbz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C4FF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C4FF4: 409A0010  bne cr6, 0x830c5004
	if !ctx.cr[6].eq {
	pc = 0x830C5004; continue 'dispatch;
	}
	// 830C4FF8: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C4FFC: 3B4B0484  addi r26, r11, 0x484
	ctx.r[26].s64 = ctx.r[11].s64 + 1156;
	// 830C5000: 48000018  b 0x830c5018
	pc = 0x830C5018; continue 'dispatch;
	// 830C5004: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C5008: 3B4B7834  addi r26, r11, 0x7834
	ctx.r[26].s64 = ctx.r[11].s64 + 30772;
	// 830C500C: 4800000C  b 0x830c5018
	pc = 0x830C5018; continue 'dispatch;
	// 830C5010: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C5014: 3B4B96A0  addi r26, r11, -0x6960
	ctx.r[26].s64 = ctx.r[11].s64 + -26976;
	// 830C5018: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C501C: 480E40AD  bl 0x831a90c8
	ctx.lr = 0x830C5020;
	sub_831A90C8(ctx, base);
	// 830C5020: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830C5024: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C5028: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C502C: 4B2041FD  bl 0x822c9228
	ctx.lr = 0x830C5030;
	sub_822C9228(ctx, base);
	// 830C5030: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 830C5034: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C5038: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 830C503C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C5040: 4B204A41  bl 0x822c9a80
	ctx.lr = 0x830C5044;
	sub_822C9A80(ctx, base);
	// 830C5044: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C5048: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C504C: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 830C5050: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C5054: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 830C5058: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C505C: 40980008  bge cr6, 0x830c5064
	if !ctx.cr[6].lt {
	pc = 0x830C5064; continue 'dispatch;
	}
	// 830C5060: 3BC10064  addi r30, r1, 0x64
	ctx.r[30].s64 = ctx.r[1].s64 + 100;
	// 830C5064: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C5068: 4B203CB1  bl 0x822c8d18
	ctx.lr = 0x830C506C;
	sub_822C8D18(ctx, base);
	// 830C506C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C5074: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C5078: 409A0008  bne cr6, 0x830c5080
	if !ctx.cr[6].eq {
	pc = 0x830C5080; continue 'dispatch;
	}
	// 830C507C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C5080: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830C5084: C07B0000  lfs f3, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830C5088: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830C508C: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C5090: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830C5094: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C5098: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830C509C: 4BFFA99D  bl 0x830bfa38
	ctx.lr = 0x830C50A0;
	sub_830BFA38(ctx, base);
	// 830C50A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C50A4: 4BD2CBED  bl 0x82df1c90
	ctx.lr = 0x830C50A8;
	sub_82DF1C90(ctx, base);
	// 830C50A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C50AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C50B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C50B4: 4B203D7D  bl 0x822c8e30
	ctx.lr = 0x830C50B8;
	sub_822C8E30(ctx, base);
	// 830C50B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830C50BC: 480E30F4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C50C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C50C0 size=116
    let mut pc: u32 = 0x830C50C0;
    'dispatch: loop {
        match pc {
            0x830C50C0 => {
    //   block [0x830C50C0..0x830C5134)
	// 830C50C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C50C4: 480E309D  bl 0x831a8160
	ctx.lr = 0x830C50C8;
	sub_831A8130(ctx, base);
	// 830C50C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C50CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830C50D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C50D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C50D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C50DC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830C50E0: 38C00034  li r6, 0x34
	ctx.r[6].s64 = 52;
	// 830C50E4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C50E8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 830C50EC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 830C50F0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830C50F4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830C50F8: 4BD2CFD1  bl 0x82df20c8
	ctx.lr = 0x830C50FC;
	sub_82DF20C8(ctx, base);
	// 830C50FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C5100: 41820028  beq 0x830c5128
	if ctx.cr[0].eq {
	pc = 0x830C5128; continue 'dispatch;
	}
	// 830C5104: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830C5108: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C510C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830C5110: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830C5114: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C5118: 4BFFFDA9  bl 0x830c4ec0
	ctx.lr = 0x830C511C;
	sub_830C4EC0(ctx, base);
	// 830C511C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5120: 9B5F0030  stb r26, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[26].u8 ) };
	// 830C5124: 997F0031  stb r11, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[11].u8 ) };
	// 830C5128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C512C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C5130: 480E3080  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5138 size=96
    let mut pc: u32 = 0x830C5138;
    'dispatch: loop {
        match pc {
            0x830C5138 => {
    //   block [0x830C5138..0x830C5198)
	// 830C5138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C513C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C5140: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5144: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C5148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C514C: 388B94BC  addi r4, r11, -0x6b44
	ctx.r[4].s64 = ctx.r[11].s64 + -27460;
	// 830C5150: 4B200779  bl 0x822c58c8
	ctx.lr = 0x830C5154;
	sub_822C58C8(ctx, base);
	// 830C5154: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5158: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C515C: 4B2006BD  bl 0x822c5818
	ctx.lr = 0x830C5160;
	sub_822C5818(ctx, base);
	// 830C5160: 4B1FF151  bl 0x822c42b0
	ctx.lr = 0x830C5164;
	sub_822C42B0(ctx, base);
	// 830C5164: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C5168: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C516C: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 830C5170: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830C5174: 4B2002FD  bl 0x822c5470
	ctx.lr = 0x830C5178;
	sub_822C5470(ctx, base);
	// 830C5178: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C517C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C5180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C5184: 4B1FFB5D  bl 0x822c4ce0
	ctx.lr = 0x830C5188;
	sub_822C4CE0(ctx, base);
	// 830C5188: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C518C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C5190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C5194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5198 size=192
    let mut pc: u32 = 0x830C5198;
    'dispatch: loop {
        match pc {
            0x830C5198 => {
    //   block [0x830C5198..0x830C5258)
	// 830C5198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C519C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C51A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C51A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C51A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C51AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C51B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C51B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C51B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C51BC: 409A0018  bne cr6, 0x830c51d4
	if !ctx.cr[6].eq {
	pc = 0x830C51D4; continue 'dispatch;
	}
	// 830C51C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C51C4: 4B20E415  bl 0x822d35d8
	ctx.lr = 0x830C51C8;
	sub_822D35D8(ctx, base);
	// 830C51C8: 4B1FAE39  bl 0x822c0000
	ctx.lr = 0x830C51CC;
	sub_822C0000(ctx, base);
	// 830C51CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C51D0: 4B20D641  bl 0x822d2810
	ctx.lr = 0x830C51D4;
	sub_822D2810(ctx, base);
	// 830C51D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C51D8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C51DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C51E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C51E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C51E8: 419A0024  beq cr6, 0x830c520c
	if ctx.cr[6].eq {
	pc = 0x830C520C; continue 'dispatch;
	}
	// 830C51EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C51F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C51F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C51F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C51FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C5200: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C5204: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C5208: 4082FFE8  bne 0x830c51f0
	if !ctx.cr[0].eq {
	pc = 0x830C51F0; continue 'dispatch;
	}
	// 830C520C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5210: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5214: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 830C5218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C521C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C5220: 4E800421  bctrl
	ctx.lr = 0x830C5224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C5224: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C522C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C5230: 419A000C  beq cr6, 0x830c523c
	if ctx.cr[6].eq {
	pc = 0x830C523C; continue 'dispatch;
	}
	// 830C5234: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830C5238: 4B1FB659  bl 0x822c0890
	ctx.lr = 0x830C523C;
	sub_822C0890(ctx, base);
	// 830C523C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C5240: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C5244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C5248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C524C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C5250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C5254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C5258 size=472
    let mut pc: u32 = 0x830C5258;
    'dispatch: loop {
        match pc {
            0x830C5258 => {
    //   block [0x830C5258..0x830C5430)
	// 830C5258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C525C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C5260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C5264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C5268: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C526C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C5274: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5278: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C527C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C5280: 997F00E8  stb r11, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 830C5284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5288: 419A0028  beq cr6, 0x830c52b0
	if ctx.cr[6].eq {
	pc = 0x830C52B0; continue 'dispatch;
	}
	// 830C528C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5290: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5294: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C5298: 4E800421  bctrl
	ctx.lr = 0x830C529C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C529C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C52A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C52A4: 409A000C  bne cr6, 0x830c52b0
	if !ctx.cr[6].eq {
	pc = 0x830C52B0; continue 'dispatch;
	}
	// 830C52A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C52AC: 48000168  b 0x830c5414
	pc = 0x830C5414; continue 'dispatch;
	// 830C52B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C52B4: C3FE0008  lfs f31, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C52B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C52BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C52C0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C52C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C52C8: 4E800421  bctrl
	ctx.lr = 0x830C52CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C52CC: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C52D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C52D4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C52D8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C52DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C52E0: 4E800421  bctrl
	ctx.lr = 0x830C52E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C52E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C52E8: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C52EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C52F0: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C52F4: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C52F8: C1610064  lfs f11, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C52FC: EC206028  fsubs f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C5300: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C5304: EC4D5828  fsubs f2, f13, f11
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C5308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C530C: 4E800421  bctrl
	ctx.lr = 0x830C5310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C5310: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C5314: 418200FC  beq 0x830c5410
	if ctx.cr[0].eq {
	pc = 0x830C5410; continue 'dispatch;
	}
	// 830C5318: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C531C: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C5320: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C5324: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C5328: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C532C: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C5330: 419A0014  beq cr6, 0x830c5344
	if ctx.cr[6].eq {
	pc = 0x830C5344; continue 'dispatch;
	}
	// 830C5334: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C5338: 48003591  bl 0x830c88c8
	ctx.lr = 0x830C533C;
	sub_830C88C8(ctx, base);
	// 830C533C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C5340: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830C5344: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C5348: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830C534C: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C5350: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C5354: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830C5358: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C535C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C5360: 409A00B0  bne cr6, 0x830c5410
	if !ctx.cr[6].eq {
	pc = 0x830C5410; continue 'dispatch;
	}
	// 830C5364: 897F0100  lbz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 830C5368: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C536C: 4182FF3C  beq 0x830c52a8
	if ctx.cr[0].eq {
	pc = 0x830C52A8; continue 'dispatch;
	}
	// 830C5370: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C5374: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C5378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C537C: 419AFF2C  beq cr6, 0x830c52a8
	if ctx.cr[6].eq {
	pc = 0x830C52A8; continue 'dispatch;
	}
	// 830C5380: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C5384: 396B7AE0  addi r11, r11, 0x7ae0
	ctx.r[11].s64 = ctx.r[11].s64 + 31456;
	// 830C5388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C538C: 419AFF1C  beq cr6, 0x830c52a8
	if ctx.cr[6].eq {
	pc = 0x830C52A8; continue 'dispatch;
	}
	// 830C5390: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 830C5394: 4099FF14  ble cr6, 0x830c52a8
	if !ctx.cr[6].gt {
	pc = 0x830C52A8; continue 'dispatch;
	}
	// 830C5398: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C539C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C53A0: 419A0014  beq cr6, 0x830c53b4
	if ctx.cr[6].eq {
	pc = 0x830C53B4; continue 'dispatch;
	}
	// 830C53A4: 813F010C  lwz r9, 0x10c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 830C53A8: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 830C53AC: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830C53B0: 7D6B43D6  divw r11, r11, r8
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[8].s32;
	// 830C53B4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C53B8: 4098FEF0  bge cr6, 0x830c52a8
	if !ctx.cr[6].lt {
	pc = 0x830C52A8; continue 'dispatch;
	}
	// 830C53BC: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C53C0: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 830C53C4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830C53C8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 830C53CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C53D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C53D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C53D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830C53DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C53E0: 419A0024  beq cr6, 0x830c5404
	if ctx.cr[6].eq {
	pc = 0x830C5404; continue 'dispatch;
	}
	// 830C53E4: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 830C53E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C53EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C53F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C53F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C53F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C53FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C5400: 4082FFE8  bne 0x830c53e8
	if !ctx.cr[0].eq {
	pc = 0x830C53E8; continue 'dispatch;
	}
	// 830C5404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5408: 4BFFFD91  bl 0x830c5198
	ctx.lr = 0x830C540C;
	sub_830C5198(ctx, base);
	// 830C540C: 4BFFFE9C  b 0x830c52a8
	pc = 0x830C52A8; continue 'dispatch;
	// 830C5410: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C5414: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C5418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C541C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C5420: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C5424: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C5428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C542C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C5430 size=416
    let mut pc: u32 = 0x830C5430;
    'dispatch: loop {
        match pc {
            0x830C5430 => {
    //   block [0x830C5430..0x830C55D0)
	// 830C5430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C5438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C543C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830C5440: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C5448: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830C544C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 830C5450: 40990164  ble cr6, 0x830c55b4
	if !ctx.cr[6].gt {
	pc = 0x830C55B4; continue 'dispatch;
	}
	// 830C5454: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C5458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C545C: 419A0014  beq cr6, 0x830c5470
	if ctx.cr[6].eq {
	pc = 0x830C5470; continue 'dispatch;
	}
	// 830C5460: 813F010C  lwz r9, 0x10c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 830C5464: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 830C5468: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830C546C: 7D6B43D6  divw r11, r11, r8
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[8].s32;
	// 830C5470: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C5474: 40980140  bge cr6, 0x830c55b4
	if !ctx.cr[6].lt {
	pc = 0x830C55B4; continue 'dispatch;
	}
	// 830C5478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C547C: C3E40008  lfs f31, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C5480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C5484: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C5488: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C548C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C5490: 4E800421  bctrl
	ctx.lr = 0x830C5494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C5494: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C5498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C549C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C54A0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C54A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C54A8: 4E800421  bctrl
	ctx.lr = 0x830C54AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C54AC: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C54B0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C54B4: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C54B8: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C54BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C54C0: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C54C4: 419A0014  beq cr6, 0x830c54d8
	if ctx.cr[6].eq {
	pc = 0x830C54D8; continue 'dispatch;
	}
	// 830C54C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C54CC: 480033FD  bl 0x830c88c8
	ctx.lr = 0x830C54D0;
	sub_830C88C8(ctx, base);
	// 830C54D0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C54D4: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830C54D8: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C54DC: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830C54E0: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C54E4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C54E8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830C54EC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C54F0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C54F4: 409A00C0  bne cr6, 0x830c55b4
	if !ctx.cr[6].eq {
	pc = 0x830C55B4; continue 'dispatch;
	}
	// 830C54F8: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C54FC: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C5500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C5504: 419A0078  beq cr6, 0x830c557c
	if ctx.cr[6].eq {
	pc = 0x830C557C; continue 'dispatch;
	}
	// 830C5508: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830C550C: 394A7AE0  addi r10, r10, 0x7ae0
	ctx.r[10].s64 = ctx.r[10].s64 + 31456;
	// 830C5510: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C5514: 419A0068  beq cr6, 0x830c557c
	if ctx.cr[6].eq {
	pc = 0x830C557C; continue 'dispatch;
	}
	// 830C5518: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C551C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 830C5520: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830C5524: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 830C5528: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C552C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5530: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C5534: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830C5538: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C553C: 419A0024  beq cr6, 0x830c5560
	if ctx.cr[6].eq {
	pc = 0x830C5560; continue 'dispatch;
	}
	// 830C5540: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 830C5544: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C5548: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C554C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C5550: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C5554: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C5558: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C555C: 4082FFE8  bne 0x830c5544
	if !ctx.cr[0].eq {
	pc = 0x830C5544; continue 'dispatch;
	}
	// 830C5560: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5564: 4BFFFC35  bl 0x830c5198
	ctx.lr = 0x830C5568;
	sub_830C5198(ctx, base);
	// 830C5568: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C556C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C5570: 409A000C  bne cr6, 0x830c557c
	if !ctx.cr[6].eq {
	pc = 0x830C557C; continue 'dispatch;
	}
	// 830C5574: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C5578: 48000040  b 0x830c55b8
	pc = 0x830C55B8; continue 'dispatch;
	// 830C557C: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830C5580: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C5584: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 830C5588: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830C558C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5590: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5594: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C5598: 419A001C  beq cr6, 0x830c55b4
	if ctx.cr[6].eq {
	pc = 0x830C55B4; continue 'dispatch;
	}
	// 830C559C: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C55A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830C55A4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830C55A8: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 830C55AC: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 830C55B0: 994B0034  stb r10, 0x34(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u8 ) };
	// 830C55B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C55B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C55BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C55C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C55C4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C55C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C55CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C55D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C55D0 size=548
    let mut pc: u32 = 0x830C55D0;
    'dispatch: loop {
        match pc {
            0x830C55D0 => {
    //   block [0x830C55D0..0x830C57F4)
	// 830C55D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C55D4: 480E2B8D  bl 0x831a8160
	ctx.lr = 0x830C55D8;
	sub_831A8130(ctx, base);
	// 830C55D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C55DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C55E0: 3D60071C  lis r11, 0x71c
	ctx.r[11].s64 = 119275520;
	// 830C55E4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C55E8: 616B71C6  ori r11, r11, 0x71c6
	ctx.r[11].u64 = ctx.r[11].u64 | 29126;
	// 830C55EC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830C55F0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C55F4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830C55F8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830C55FC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C5600: 41980048  blt cr6, 0x830c5648
	if ctx.cr[6].lt {
	pc = 0x830C5648; continue 'dispatch;
	}
	// 830C5604: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C5608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C560C: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 830C5610: 4B2002B9  bl 0x822c58c8
	ctx.lr = 0x830C5614;
	sub_822C58C8(ctx, base);
	// 830C5614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5618: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C561C: 4B2001FD  bl 0x822c5818
	ctx.lr = 0x830C5620;
	sub_822C5818(ctx, base);
	// 830C5620: 4B1FEC91  bl 0x822c42b0
	ctx.lr = 0x830C5624;
	sub_822C42B0(ctx, base);
	// 830C5624: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C5628: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C562C: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 830C5630: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830C5634: 4B1FFE3D  bl 0x822c5470
	ctx.lr = 0x830C5638;
	sub_822C5470(ctx, base);
	// 830C5638: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C563C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C5640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C5644: 4B1FF69D  bl 0x822c4ce0
	ctx.lr = 0x830C5648;
	sub_822C4CE0(ctx, base);
	// 830C5648: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C564C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830C5650: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C5654: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830C5658: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C565C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5660: 4BFFFA61  bl 0x830c50c0
	ctx.lr = 0x830C5664;
	sub_830C50C0(ctx, base);
	// 830C5664: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5668: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C566C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C5670: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C5674: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C5678: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C567C: 409A0018  bne cr6, 0x830c5694
	if !ctx.cr[6].eq {
	pc = 0x830C5694; continue 'dispatch;
	}
	// 830C5680: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830C5684: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5688: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C568C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5690: 4800003C  b 0x830c56cc
	pc = 0x830C56CC; continue 'dispatch;
	// 830C5694: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C5698: 41820020  beq 0x830c56b8
	if ctx.cr[0].eq {
	pc = 0x830C56B8; continue 'dispatch;
	}
	// 830C569C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C56A0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C56A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C56A8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C56AC: 409A0024  bne cr6, 0x830c56d0
	if !ctx.cr[6].eq {
	pc = 0x830C56D0; continue 'dispatch;
	}
	// 830C56B0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C56B4: 4800001C  b 0x830c56d0
	pc = 0x830C56D0; continue 'dispatch;
	// 830C56B8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C56BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C56C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C56C4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C56C8: 409A0008  bne cr6, 0x830c56d0
	if !ctx.cr[6].eq {
	pc = 0x830C56D0; continue 'dispatch;
	}
	// 830C56CC: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C56D0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C56D4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 830C56D8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830C56DC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830C56E0: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C56E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C56E8: 409A00F0  bne cr6, 0x830c57d8
	if !ctx.cr[6].eq {
	pc = 0x830C57D8; continue 'dispatch;
	}
	// 830C56EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830C56F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C56F4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C56F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C56FC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830C5700: 409A0054  bne cr6, 0x830c5754
	if !ctx.cr[6].eq {
	pc = 0x830C5754; continue 'dispatch;
	}
	// 830C5704: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5708: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C570C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5710: 419A0054  beq cr6, 0x830c5764
	if ctx.cr[6].eq {
	pc = 0x830C5764; continue 'dispatch;
	}
	// 830C5714: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5718: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C571C: 409A0010  bne cr6, 0x830c572c
	if !ctx.cr[6].eq {
	pc = 0x830C572C; continue 'dispatch;
	}
	// 830C5720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5724: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C5728: 4B203CE9  bl 0x822c9410
	ctx.lr = 0x830C572C;
	sub_822C9410(ctx, base);
	// 830C572C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5734: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 830C5738: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C573C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5740: 9B6B0030  stb r27, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 830C5744: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5748: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C574C: 4B203D2D  bl 0x822c9478
	ctx.lr = 0x830C5750;
	sub_822C9478(ctx, base);
	// 830C5750: 48000074  b 0x830c57c4
	pc = 0x830C57C4; continue 'dispatch;
	// 830C5754: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5758: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C575C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5760: 409A0028  bne cr6, 0x830c5788
	if !ctx.cr[6].eq {
	pc = 0x830C5788; continue 'dispatch;
	}
	// 830C5764: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5768: 9BA90030  stb r29, 0x30(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 830C576C: 9BAA0030  stb r29, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 830C5770: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5774: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5778: 9B6A0030  stb r27, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 830C577C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5780: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5784: 48000040  b 0x830c57c4
	pc = 0x830C57C4; continue 'dispatch;
	// 830C5788: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C578C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C5790: 409A0010  bne cr6, 0x830c57a0
	if !ctx.cr[6].eq {
	pc = 0x830C57A0; continue 'dispatch;
	}
	// 830C5794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5798: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C579C: 4B203CDD  bl 0x822c9478
	ctx.lr = 0x830C57A0;
	sub_822C9478(ctx, base);
	// 830C57A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C57A8: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 830C57AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57B4: 9B6B0030  stb r27, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 830C57B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57BC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57C0: 4B203C51  bl 0x822c9410
	ctx.lr = 0x830C57C4;
	sub_822C9410(ctx, base);
	// 830C57C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57C8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 830C57CC: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C57D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C57D4: 419AFF1C  beq cr6, 0x830c56f0
	if ctx.cr[6].eq {
	pc = 0x830C56F0; continue 'dispatch;
	}
	// 830C57D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C57E0: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C57E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C57E8: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 830C57EC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830C57F0: 480E29C0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C57F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C57F8 size=116
    let mut pc: u32 = 0x830C57F8;
    'dispatch: loop {
        match pc {
            0x830C57F8 => {
    //   block [0x830C57F8..0x830C586C)
	// 830C57F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C57FC: 480E2965  bl 0x831a8160
	ctx.lr = 0x830C5800;
	sub_831A8130(ctx, base);
	// 830C5800: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5804: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830C5808: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C580C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C5810: 7F1B3040  cmplw cr6, r27, r6
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[6].u32, &mut ctx.xer);
	// 830C5814: 419A0048  beq cr6, 0x830c585c
	if ctx.cr[6].eq {
	pc = 0x830C585C; continue 'dispatch;
	}
	// 830C5818: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C581C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830C5820: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830C5824: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830C5828: 419A0020  beq cr6, 0x830c5848
	if ctx.cr[6].eq {
	pc = 0x830C5848; continue 'dispatch;
	}
	// 830C582C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C5830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C5834: 4BFFEF75  bl 0x830c47a8
	ctx.lr = 0x830C5838;
	sub_830C47A8(ctx, base);
	// 830C5838: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830C583C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830C5840: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830C5844: 409AFFE8  bne cr6, 0x830c582c
	if !ctx.cr[6].eq {
	pc = 0x830C582C; continue 'dispatch;
	}
	// 830C5848: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830C584C: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C5854: 4BFFF6E5  bl 0x830c4f38
	ctx.lr = 0x830C5858;
	sub_830C4F38(ctx, base);
	// 830C5858: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 830C585C: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830C5860: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C5864: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C5868: 480E2948  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5870 size=96
    let mut pc: u32 = 0x830C5870;
    'dispatch: loop {
        match pc {
            0x830C5870 => {
    //   block [0x830C5870..0x830C58D0)
	// 830C5870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C5878: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C587C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C5884: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C588C: 419A0020  beq cr6, 0x830c58ac
	if ctx.cr[6].eq {
	pc = 0x830C58AC; continue 'dispatch;
	}
	// 830C5890: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C5894: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5898: 4BFFF6A1  bl 0x830c4f38
	ctx.lr = 0x830C589C;
	sub_830C4F38(ctx, base);
	// 830C589C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830C58A0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C58A4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C58A8: 4BD2C8E1  bl 0x82df2188
	ctx.lr = 0x830C58AC;
	sub_82DF2188(ctx, base);
	// 830C58AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C58B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C58B4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C58B8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830C58BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C58C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C58C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C58C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C58CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C58D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C58D0 size=128
    let mut pc: u32 = 0x830C58D0;
    'dispatch: loop {
        match pc {
            0x830C58D0 => {
    //   block [0x830C58D0..0x830C5950)
	// 830C58D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C58D4: 480E2895  bl 0x831a8168
	ctx.lr = 0x830C58D8;
	sub_831A8130(ctx, base);
	// 830C58D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C58DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C58E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C58E4: 897E0031  lbz r11, 0x31(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C58E8: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C58EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C58F0: 409A0054  bne cr6, 0x830c5944
	if !ctx.cr[6].eq {
	pc = 0x830C5944; continue 'dispatch;
	}
	// 830C58F4: 5784003E  slwi r4, r28, 0
	ctx.r[4].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830C58F8: 891E0030  lbz r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C58FC: 38FE000C  addi r7, r30, 0xc
	ctx.r[7].s64 = ctx.r[30].s64 + 12;
	// 830C5900: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830C5904: 4BFFF7BD  bl 0x830c50c0
	ctx.lr = 0x830C5908;
	sub_830C50C0(ctx, base);
	// 830C5908: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C590C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C5910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C5914: 419A0008  beq cr6, 0x830c591c
	if ctx.cr[6].eq {
	pc = 0x830C591C; continue 'dispatch;
	}
	// 830C5918: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 830C591C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C5920: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C5928: 4BFFFFA9  bl 0x830c58d0
	ctx.lr = 0x830C592C;
	sub_830C58D0(ctx, base);
	// 830C592C: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830C5930: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C5934: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C593C: 4BFFFF95  bl 0x830c58d0
	ctx.lr = 0x830C5940;
	sub_830C58D0(ctx, base);
	// 830C5940: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830C5944: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C5948: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C594C: 480E286C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5950 size=128
    let mut pc: u32 = 0x830C5950;
    'dispatch: loop {
        match pc {
            0x830C5950 => {
    //   block [0x830C5950..0x830C59D0)
	// 830C5950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5954: 480E2819  bl 0x831a816c
	ctx.lr = 0x830C5958;
	sub_831A8130(ctx, base);
	// 830C5958: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C595C: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830C5960: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830C5964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C5968: 3BEBBDE0  addi r31, r11, -0x4220
	ctx.r[31].s64 = ctx.r[11].s64 + -16928;
	// 830C596C: 816ABDE8  lwz r11, -0x4218(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16920 as u32) ) } as u64;
	// 830C5970: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C5974: 40820024  bne 0x830c5998
	if !ctx.cr[0].eq {
	pc = 0x830C5998; continue 'dispatch;
	}
	// 830C5978: 3D2082E1  lis r9, -0x7d1f
	ctx.r[9].s64 = -2099183616;
	// 830C597C: 3D00830C  lis r8, -0x7cf4
	ctx.r[8].s64 = -2096365568;
	// 830C5980: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C5984: 3929BD78  addi r9, r9, -0x4288
	ctx.r[9].s64 = ctx.r[9].s64 + -17032;
	// 830C5988: 390848A8  addi r8, r8, 0x48a8
	ctx.r[8].s64 = ctx.r[8].s64 + 18600;
	// 830C598C: 916ABDE8  stw r11, -0x4218(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16920 as u32), ctx.r[11].u32 ) };
	// 830C5990: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C5994: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830C5998: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C599C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C59A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C59A4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830C59A8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830C59AC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C59B0: 4BD45D41  bl 0x82e0b6f0
	ctx.lr = 0x830C59B4;
	sub_82E0B6F0(ctx, base);
	// 830C59B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C59B8: 4182000C  beq 0x830c59c4
	if ctx.cr[0].eq {
	pc = 0x830C59C4; continue 'dispatch;
	}
	// 830C59BC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830C59C0: 48000008  b 0x830c59c8
	pc = 0x830C59C8; continue 'dispatch;
	// 830C59C4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830C59C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C59CC: 480E27F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C59D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C59D0 size=236
    let mut pc: u32 = 0x830C59D0;
    'dispatch: loop {
        match pc {
            0x830C59D0 => {
    //   block [0x830C59D0..0x830C5ABC)
	// 830C59D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C59D4: 480E2789  bl 0x831a815c
	ctx.lr = 0x830C59D8;
	sub_831A8130(ctx, base);
	// 830C59D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C59DC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830C59E0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 830C59E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C59E8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830C59EC: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 830C59F0: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C59F4: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C59F8: 4800002C  b 0x830c5a24
	pc = 0x830C5A24; continue 'dispatch;
	// 830C59FC: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 830C5A00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C5A04: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830C5A08: 4BD30209  bl 0x82df5c10
	ctx.lr = 0x830C5A0C;
	sub_82DF5C10(ctx, base);
	// 830C5A0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C5A10: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C5A14: 4182000C  beq 0x830c5a20
	if ctx.cr[0].eq {
	pc = 0x830C5A20; continue 'dispatch;
	}
	// 830C5A18: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5A1C: 48000008  b 0x830c5a24
	pc = 0x830C5A24; continue 'dispatch;
	// 830C5A20: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5A24: 897D0031  lbz r11, 0x31(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C5A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C5A2C: 419AFFD0  beq cr6, 0x830c59fc
	if ctx.cr[6].eq {
	pc = 0x830C59FC; continue 'dispatch;
	}
	// 830C5A30: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830C5A34: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C5A38: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830C5A3C: 41820048  beq 0x830c5a84
	if ctx.cr[0].eq {
	pc = 0x830C5A84; continue 'dispatch;
	}
	// 830C5A40: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C5A48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5A4C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C5A50: 409A002C  bne cr6, 0x830c5a7c
	if !ctx.cr[6].eq {
	pc = 0x830C5A7C; continue 'dispatch;
	}
	// 830C5A54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C5A58: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C5A5C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C5A60: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830C5A64: 4BFFFB6D  bl 0x830c55d0
	ctx.lr = 0x830C5A68;
	sub_830C55D0(ctx, base);
	// 830C5A68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C5A6C: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 830C5A70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5A74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C5A78: 48000038  b 0x830c5ab0
	pc = 0x830C5AB0; continue 'dispatch;
	// 830C5A7C: 4BFFE90D  bl 0x830c4388
	ctx.lr = 0x830C5A80;
	sub_830C4388(ctx, base);
	// 830C5A80: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C5A84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C5A88: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 830C5A8C: 4BD30185  bl 0x82df5c10
	ctx.lr = 0x830C5A90;
	sub_82DF5C10(ctx, base);
	// 830C5A90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C5A94: 41820010  beq 0x830c5aa4
	if ctx.cr[0].eq {
	pc = 0x830C5AA4; continue 'dispatch;
	}
	// 830C5A98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830C5A9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C5AA0: 4BFFFFB8  b 0x830c5a58
	pc = 0x830C5A58; continue 'dispatch;
	// 830C5AA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5AA8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830C5AAC: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 830C5AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C5AB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C5AB8: 480E26F4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5AC0 size=168
    let mut pc: u32 = 0x830C5AC0;
    'dispatch: loop {
        match pc {
            0x830C5AC0 => {
    //   block [0x830C5AC0..0x830C5B68)
	// 830C5AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5AC4: 480E26A9  bl 0x831a816c
	ctx.lr = 0x830C5AC8;
	sub_831A8130(ctx, base);
	// 830C5AC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5ACC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C5AD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C5AD4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5AD8: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5ADC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C5AE0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5AE4: 4BFFFDED  bl 0x830c58d0
	ctx.lr = 0x830C5AE8;
	sub_830C58D0(ctx, base);
	// 830C5AE8: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830C5AEC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5AF0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5AF4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C5AF8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5AFC: 896A0031  lbz r11, 0x31(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C5B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C5B04: 409A0050  bne cr6, 0x830c5b54
	if !ctx.cr[6].eq {
	pc = 0x830C5B54; continue 'dispatch;
	}
	// 830C5B08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5B0C: 4800000C  b 0x830c5b18
	pc = 0x830C5B18; continue 'dispatch;
	// 830C5B10: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830C5B14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5B18: 890B0031  lbz r8, 0x31(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C5B1C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830C5B20: 419AFFF0  beq cr6, 0x830c5b10
	if ctx.cr[6].eq {
	pc = 0x830C5B10; continue 'dispatch;
	}
	// 830C5B24: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C5B28: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5B2C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5B30: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5B34: 4800000C  b 0x830c5b40
	pc = 0x830C5B40; continue 'dispatch;
	// 830C5B38: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830C5B3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5B40: 890B0031  lbz r8, 0x31(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 830C5B44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830C5B48: 419AFFF0  beq cr6, 0x830c5b38
	if ctx.cr[6].eq {
	pc = 0x830C5B38; continue 'dispatch;
	}
	// 830C5B4C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C5B50: 48000010  b 0x830c5b60
	pc = 0x830C5B60; continue 'dispatch;
	// 830C5B54: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830C5B58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5B5C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C5B60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C5B64: 480E2658  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5B68 size=920
    let mut pc: u32 = 0x830C5B68;
    'dispatch: loop {
        match pc {
            0x830C5B68 => {
    //   block [0x830C5B68..0x830C5F00)
	// 830C5B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5B6C: 480E25E5  bl 0x831a8150
	ctx.lr = 0x830C5B70;
	sub_831A8130(ctx, base);
	// 830C5B70: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5B74: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5B78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C5B7C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5B80: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830C5B84: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5B88: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830C5B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C5B90: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C5B94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C5B98: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 830C5B9C: 419A0024  beq cr6, 0x830c5bc0
	if ctx.cr[6].eq {
	pc = 0x830C5BC0; continue 'dispatch;
	}
	// 830C5BA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C5BA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C5BA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C5BAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C5BB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C5BB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C5BB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C5BBC: 4082FFE8  bne 0x830c5ba4
	if !ctx.cr[0].eq {
	pc = 0x830C5BA4; continue 'dispatch;
	}
	// 830C5BC0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5BC4: 3AC0000C  li r22, 0xc
	ctx.r[22].s64 = 12;
	// 830C5BC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5BCC: 409A000C  bne cr6, 0x830c5bd8
	if !ctx.cr[6].eq {
	pc = 0x830C5BD8; continue 'dispatch;
	}
	// 830C5BD0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830C5BD4: 48000010  b 0x830c5be4
	pc = 0x830C5BE4; continue 'dispatch;
	// 830C5BD8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C5BDC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830C5BE0: 7D0BB3D6  divw r8, r11, r22
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830C5BE4: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830C5BE8: 419A0300  beq cr6, 0x830c5ee8
	if ctx.cr[6].eq {
	pc = 0x830C5EE8; continue 'dispatch;
	}
	// 830C5BEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5BF0: 409A000C  bne cr6, 0x830c5bfc
	if !ctx.cr[6].eq {
	pc = 0x830C5BFC; continue 'dispatch;
	}
	// 830C5BF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5BF8: 48000010  b 0x830c5c08
	pc = 0x830C5C08; continue 'dispatch;
	// 830C5BFC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5C00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830C5C04: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830C5C08: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 830C5C0C: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 830C5C10: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830C5C14: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 830C5C18: 4098000C  bge cr6, 0x830c5c24
	if !ctx.cr[6].lt {
	pc = 0x830C5C24; continue 'dispatch;
	}
	// 830C5C1C: 4BFFF51D  bl 0x830c5138
	ctx.lr = 0x830C5C20;
	sub_830C5138(ctx, base);
	// 830C5C20: 480002C8  b 0x830c5ee8
	pc = 0x830C5EE8; continue 'dispatch;
	// 830C5C24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5C28: 409A000C  bne cr6, 0x830c5c34
	if !ctx.cr[6].eq {
	pc = 0x830C5C34; continue 'dispatch;
	}
	// 830C5C2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5C30: 48000010  b 0x830c5c40
	pc = 0x830C5C40; continue 'dispatch;
	// 830C5C34: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5C38: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830C5C3C: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830C5C40: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830C5C44: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C5C48: 40980170  bge cr6, 0x830c5db8
	if !ctx.cr[6].lt {
	pc = 0x830C5DB8; continue 'dispatch;
	}
	// 830C5C4C: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830C5C50: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830C5C54: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830C5C58: 4098000C  bge cr6, 0x830c5c64
	if !ctx.cr[6].lt {
	pc = 0x830C5C64; continue 'dispatch;
	}
	// 830C5C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5C60: 48000008  b 0x830c5c68
	pc = 0x830C5C68; continue 'dispatch;
	// 830C5C64: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830C5C68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5C6C: 409A000C  bne cr6, 0x830c5c78
	if !ctx.cr[6].eq {
	pc = 0x830C5C78; continue 'dispatch;
	}
	// 830C5C70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C5C74: 48000010  b 0x830c5c84
	pc = 0x830C5C84; continue 'dispatch;
	// 830C5C78: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5C7C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 830C5C80: 7D4AB3D6  divw r10, r10, r22
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[22].s32;
	// 830C5C84: 7D4ABA14  add r10, r10, r23
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 830C5C88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C5C8C: 40980024  bge cr6, 0x830c5cb0
	if !ctx.cr[6].lt {
	pc = 0x830C5CB0; continue 'dispatch;
	}
	// 830C5C90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C5C94: 409A000C  bne cr6, 0x830c5ca0
	if !ctx.cr[6].eq {
	pc = 0x830C5CA0; continue 'dispatch;
	}
	// 830C5C98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5C9C: 48000010  b 0x830c5cac
	pc = 0x830C5CAC; continue 'dispatch;
	// 830C5CA0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5CA4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830C5CA8: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830C5CAC: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830C5CB0: 1F0B000C  mulli r24, r11, 0xc
	ctx.r[24].s64 = ctx.r[11].s64 * 12;
	// 830C5CB4: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 830C5CB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C5CBC: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830C5CC0: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 830C5CC4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 830C5CC8: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C5CCC: 4BD2C3FD  bl 0x82df20c8
	ctx.lr = 0x830C5CD0;
	sub_82DF20C8(ctx, base);
	// 830C5CD0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C5CD4: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5CD8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830C5CDC: 48000018  b 0x830c5cf4
	pc = 0x830C5CF4; continue 'dispatch;
	// 830C5CE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C5CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5CE8: 4BFFEB19  bl 0x830c4800
	ctx.lr = 0x830C5CEC;
	sub_830C4800(ctx, base);
	// 830C5CEC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830C5CF0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830C5CF4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C5CF8: 409AFFE8  bne cr6, 0x830c5ce0
	if !ctx.cr[6].eq {
	pc = 0x830C5CE0; continue 'dispatch;
	}
	// 830C5CFC: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 830C5D00: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830C5D04: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830C5D08: 419A001C  beq cr6, 0x830c5d24
	if ctx.cr[6].eq {
	pc = 0x830C5D24; continue 'dispatch;
	}
	// 830C5D0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5D10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C5D14: 4BFFEAED  bl 0x830c4800
	ctx.lr = 0x830C5D18;
	sub_830C4800(ctx, base);
	// 830C5D18: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C5D1C: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 830C5D20: 4082FFEC  bne 0x830c5d0c
	if !ctx.cr[0].eq {
	pc = 0x830C5D0C; continue 'dispatch;
	}
	// 830C5D24: 839D0008  lwz r28, 8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5D28: 1D77000C  mulli r11, r23, 0xc
	ctx.r[11].s64 = ctx.r[23].s64 * 12;
	// 830C5D2C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830C5D30: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830C5D34: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830C5D38: 419A0020  beq cr6, 0x830c5d58
	if ctx.cr[6].eq {
	pc = 0x830C5D58; continue 'dispatch;
	}
	// 830C5D3C: 7FDA5850  subf r30, r26, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 830C5D40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C5D44: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 830C5D48: 4BFFEAB9  bl 0x830c4800
	ctx.lr = 0x830C5D4C;
	sub_830C4800(ctx, base);
	// 830C5D4C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830C5D50: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830C5D54: 409AFFEC  bne cr6, 0x830c5d40
	if !ctx.cr[6].eq {
	pc = 0x830C5D40; continue 'dispatch;
	}
	// 830C5D58: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5D5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5D60: 409A000C  bne cr6, 0x830c5d6c
	if !ctx.cr[6].eq {
	pc = 0x830C5D6C; continue 'dispatch;
	}
	// 830C5D64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C5D68: 48000010  b 0x830c5d78
	pc = 0x830C5D78; continue 'dispatch;
	// 830C5D6C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5D70: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 830C5D74: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830C5D78: 7FEBBA14  add r31, r11, r23
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830C5D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5D80: 419A001C  beq cr6, 0x830c5d9c
	if ctx.cr[6].eq {
	pc = 0x830C5D9C; continue 'dispatch;
	}
	// 830C5D84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C5D88: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5D8C: 4BFFF1AD  bl 0x830c4f38
	ctx.lr = 0x830C5D90;
	sub_830C4F38(ctx, base);
	// 830C5D90: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C5D94: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5D98: 4BD2C3F1  bl 0x82df2188
	ctx.lr = 0x830C5D9C;
	sub_82DF2188(ctx, base);
	// 830C5D9C: 1D7F000C  mulli r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 * 12;
	// 830C5DA0: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830C5DA4: 7D58DA14  add r10, r24, r27
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 830C5DA8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830C5DAC: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830C5DB0: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C5DB4: 48000134  b 0x830c5ee8
	pc = 0x830C5EE8; continue 'dispatch;
	// 830C5DB8: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5DBC: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 830C5DC0: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830C5DC4: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 830C5DC8: 4098009C  bge cr6, 0x830c5e64
	if !ctx.cr[6].lt {
	pc = 0x830C5E64; continue 'dispatch;
	}
	// 830C5DCC: 1F97000C  mulli r28, r23, 0xc
	ctx.r[28].s64 = ctx.r[23].s64 * 12;
	// 830C5DD0: 7D7CD214  add r11, r28, r26
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[26].u64;
	// 830C5DD4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 830C5DD8: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C5DDC: 419A0020  beq cr6, 0x830c5dfc
	if ctx.cr[6].eq {
	pc = 0x830C5DFC; continue 'dispatch;
	}
	// 830C5DE0: 7F7A5850  subf r27, r26, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 830C5DE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C5DE8: 7C7BF214  add r3, r27, r30
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 830C5DEC: 4BFFEA15  bl 0x830c4800
	ctx.lr = 0x830C5DF0;
	sub_830C4800(ctx, base);
	// 830C5DF0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830C5DF4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C5DF8: 409AFFEC  bne cr6, 0x830c5de4
	if !ctx.cr[6].eq {
	pc = 0x830C5DE4; continue 'dispatch;
	}
	// 830C5DFC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5E00: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 830C5E04: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830C5E08: 7D6AB3D6  divw r11, r10, r22
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[22].s32;
	// 830C5E0C: 7FEBB851  subf. r31, r11, r23
	ctx.r[31].s64 = ctx.r[23].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C5E10: 4182001C  beq 0x830c5e2c
	if ctx.cr[0].eq {
	pc = 0x830C5E2C; continue 'dispatch;
	}
	// 830C5E14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5E1C: 4BFFE9E5  bl 0x830c4800
	ctx.lr = 0x830C5E20;
	sub_830C4800(ctx, base);
	// 830C5E20: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C5E24: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830C5E28: 4082FFEC  bne 0x830c5e14
	if !ctx.cr[0].eq {
	pc = 0x830C5E14; continue 'dispatch;
	}
	// 830C5E2C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C5E30: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 830C5E34: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830C5E38: 7FFC5850  subf r31, r28, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 830C5E3C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C5E40: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C5E44: 419A00A4  beq cr6, 0x830c5ee8
	if ctx.cr[6].eq {
	pc = 0x830C5EE8; continue 'dispatch;
	}
	// 830C5E48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C5E50: 4BFFE959  bl 0x830c47a8
	ctx.lr = 0x830C5E54;
	sub_830C47A8(ctx, base);
	// 830C5E54: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830C5E58: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C5E5C: 409AFFEC  bne cr6, 0x830c5e48
	if !ctx.cr[6].eq {
	pc = 0x830C5E48; continue 'dispatch;
	}
	// 830C5E60: 48000088  b 0x830c5ee8
	pc = 0x830C5EE8; continue 'dispatch;
	// 830C5E64: 1F37000C  mulli r25, r23, 0xc
	ctx.r[25].s64 = ctx.r[23].s64 * 12;
	// 830C5E68: 7FD9F850  subf r30, r25, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[25].s64;
	// 830C5E6C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 830C5E70: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 830C5E74: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C5E78: 419A0020  beq cr6, 0x830c5e98
	if ctx.cr[6].eq {
	pc = 0x830C5E98; continue 'dispatch;
	}
	// 830C5E7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C5E80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C5E84: 4BFFE97D  bl 0x830c4800
	ctx.lr = 0x830C5E88;
	sub_830C4800(ctx, base);
	// 830C5E88: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 830C5E8C: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 830C5E90: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830C5E94: 409AFFE8  bne cr6, 0x830c5e7c
	if !ctx.cr[6].eq {
	pc = 0x830C5E7C; continue 'dispatch;
	}
	// 830C5E98: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C5E9C: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830C5EA0: 419A0020  beq cr6, 0x830c5ec0
	if ctx.cr[6].eq {
	pc = 0x830C5EC0; continue 'dispatch;
	}
	// 830C5EA4: 7FFEF850  subf r31, r30, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830C5EA8: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 830C5EAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C5EB0: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 830C5EB4: 4BFFE8F5  bl 0x830c47a8
	ctx.lr = 0x830C5EB8;
	sub_830C47A8(ctx, base);
	// 830C5EB8: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830C5EBC: 409AFFEC  bne cr6, 0x830c5ea8
	if !ctx.cr[6].eq {
	pc = 0x830C5EA8; continue 'dispatch;
	}
	// 830C5EC0: 7FD9D214  add r30, r25, r26
	ctx.r[30].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 830C5EC4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830C5EC8: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830C5ECC: 419A001C  beq cr6, 0x830c5ee8
	if ctx.cr[6].eq {
	pc = 0x830C5EE8; continue 'dispatch;
	}
	// 830C5ED0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C5ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C5ED8: 4BFFE8D1  bl 0x830c47a8
	ctx.lr = 0x830C5EDC;
	sub_830C47A8(ctx, base);
	// 830C5EDC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830C5EE0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830C5EE4: 409AFFEC  bne cr6, 0x830c5ed0
	if !ctx.cr[6].eq {
	pc = 0x830C5ED0; continue 'dispatch;
	}
	// 830C5EE8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C5EEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5EF0: 419A0008  beq cr6, 0x830c5ef8
	if ctx.cr[6].eq {
	pc = 0x830C5EF8; continue 'dispatch;
	}
	// 830C5EF4: 4B1FA99D  bl 0x822c0890
	ctx.lr = 0x830C5EF8;
	sub_822C0890(ctx, base);
	// 830C5EF8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830C5EFC: 480E22A4  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5F00 size=228
    let mut pc: u32 = 0x830C5F00;
    'dispatch: loop {
        match pc {
            0x830C5F00 => {
    //   block [0x830C5F00..0x830C5FE4)
	// 830C5F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C5F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C5F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C5F10: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5F14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C5F18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C5F1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5F20: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830C5F24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5F28: 809E0038  lwz r4, 0x38(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C5F2C: 4BFFE9C5  bl 0x830c48f0
	ctx.lr = 0x830C5F30;
	sub_830C48F0(ctx, base);
	// 830C5F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C5F34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C5F38: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 830C5F3C: 4B203F1D  bl 0x822c9e58
	ctx.lr = 0x830C5F40;
	sub_822C9E58(ctx, base);
	// 830C5F40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C5F44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830C5F48: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830C5F4C: 4BFFEEFD  bl 0x830c4e48
	ctx.lr = 0x830C5F50;
	sub_830C4E48(ctx, base);
	// 830C5F50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C5F54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C5F58: 4BFFEF69  bl 0x830c4ec0
	ctx.lr = 0x830C5F5C;
	sub_830C4EC0(ctx, base);
	// 830C5F5C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830C5F60: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 830C5F64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C5F68: 4BFFFA69  bl 0x830c59d0
	ctx.lr = 0x830C5F6C;
	sub_830C59D0(ctx, base);
	// 830C5F6C: 806100A0  lwz r3, 0xa0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830C5F70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5F74: 419A0008  beq cr6, 0x830c5f7c
	if ctx.cr[6].eq {
	pc = 0x830C5F7C; continue 'dispatch;
	}
	// 830C5F78: 4B1FA919  bl 0x822c0890
	ctx.lr = 0x830C5F7C;
	sub_822C0890(ctx, base);
	// 830C5F7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C5F80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C5F84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C5F88: 4B202EA9  bl 0x822c8e30
	ctx.lr = 0x830C5F8C;
	sub_822C8E30(ctx, base);
	// 830C5F8C: 806100D0  lwz r3, 0xd0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 830C5F90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5F94: 419A0008  beq cr6, 0x830c5f9c
	if ctx.cr[6].eq {
	pc = 0x830C5F9C; continue 'dispatch;
	}
	// 830C5F98: 4B1FA8F9  bl 0x822c0890
	ctx.lr = 0x830C5F9C;
	sub_822C0890(ctx, base);
	// 830C5F9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C5FA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C5FA4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830C5FA8: 4B202E89  bl 0x822c8e30
	ctx.lr = 0x830C5FAC;
	sub_822C8E30(ctx, base);
	// 830C5FAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C5FB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C5FB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C5FB8: 4B202E79  bl 0x822c8e30
	ctx.lr = 0x830C5FBC;
	sub_822C8E30(ctx, base);
	// 830C5FBC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5FC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C5FC4: 419A0008  beq cr6, 0x830c5fcc
	if ctx.cr[6].eq {
	pc = 0x830C5FCC; continue 'dispatch;
	}
	// 830C5FC8: 4B1FA8C9  bl 0x822c0890
	ctx.lr = 0x830C5FCC;
	sub_822C0890(ctx, base);
	// 830C5FCC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830C5FD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C5FD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C5FD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C5FDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C5FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C5FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C5FE8 size=124
    let mut pc: u32 = 0x830C5FE8;
    'dispatch: loop {
        match pc {
            0x830C5FE8 => {
    //   block [0x830C5FE8..0x830C6064)
	// 830C5FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C5FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C5FF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C5FF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C5FF8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C5FFC: 3BE40004  addi r31, r4, 4
	ctx.r[31].s64 = ctx.r[4].s64 + 4;
	// 830C6000: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6008: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C600C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C6010: 419A0024  beq cr6, 0x830c6034
	if ctx.cr[6].eq {
	pc = 0x830C6034; continue 'dispatch;
	}
	// 830C6014: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C6018: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C601C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C6020: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C6024: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C6028: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C602C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C6030: 4082FFE8  bne 0x830c6018
	if !ctx.cr[0].eq {
	pc = 0x830C6018; continue 'dispatch;
	}
	// 830C6034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C6038: 806300E0  lwz r3, 0xe0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 830C603C: 4BFFFEC5  bl 0x830c5f00
	ctx.lr = 0x830C6040;
	sub_830C5F00(ctx, base);
	// 830C6040: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6048: 419A0008  beq cr6, 0x830c6050
	if ctx.cr[6].eq {
	pc = 0x830C6050; continue 'dispatch;
	}
	// 830C604C: 4B1FA845  bl 0x822c0890
	ctx.lr = 0x830C6050;
	sub_822C0890(ctx, base);
	// 830C6050: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C605C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6068 size=100
    let mut pc: u32 = 0x830C6068;
    'dispatch: loop {
        match pc {
            0x830C6068 => {
    //   block [0x830C6068..0x830C60CC)
	// 830C6068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C606C: 480E2101  bl 0x831a816c
	ctx.lr = 0x830C6070;
	sub_831A8130(ctx, base);
	// 830C6070: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6078: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C607C: 4BFFED75  bl 0x830c4df0
	ctx.lr = 0x830C6080;
	sub_830C4DF0(ctx, base);
	// 830C6080: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C6084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C608C: 4BFFED0D  bl 0x830c4d98
	ctx.lr = 0x830C6090;
	sub_830C4D98(ctx, base);
	// 830C6090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C6094: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C6098: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C609C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C60A0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830C60A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C60A8: 4BFFE6A1  bl 0x830c4748
	ctx.lr = 0x830C60AC;
	sub_830C4748(ctx, base);
	// 830C60AC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830C60B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830C60B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C60B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C60BC: 4B2044AD  bl 0x822ca568
	ctx.lr = 0x830C60C0;
	sub_822CA568(ctx, base);
	// 830C60C0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C60C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C60C8: 480E20F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C60D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C60D0 size=112
    let mut pc: u32 = 0x830C60D0;
    'dispatch: loop {
        match pc {
            0x830C60D0 => {
    //   block [0x830C60D0..0x830C6140)
	// 830C60D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C60D4: 480E2099  bl 0x831a816c
	ctx.lr = 0x830C60D8;
	sub_831A8130(ctx, base);
	// 830C60D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C60DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C60E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C60E4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830C60E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C60EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C60F0: 419A0018  beq cr6, 0x830c6108
	if ctx.cr[6].eq {
	pc = 0x830C6108; continue 'dispatch;
	}
	// 830C60F4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C60F8: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 830C60FC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830C6100: 7D2953D7  divw. r9, r9, r10
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C6104: 4082000C  bne 0x830c6110
	if !ctx.cr[0].eq {
	pc = 0x830C6110; continue 'dispatch;
	}
	// 830C6108: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C610C: 4800000C  b 0x830c6118
	pc = 0x830C6118; continue 'dispatch;
	// 830C6110: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830C6114: 7FCB53D6  divw r30, r11, r10
	ctx.r[30].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 830C6118: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C611C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6120: 4BFFFA49  bl 0x830c5b68
	ctx.lr = 0x830C6124;
	sub_830C5B68(ctx, base);
	// 830C6124: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C6128: 1D7E000C  mulli r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 * 12;
	// 830C612C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830C6130: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C6134: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C6138: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C613C: 480E2080  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6140 size=120
    let mut pc: u32 = 0x830C6140;
    'dispatch: loop {
        match pc {
            0x830C6140 => {
    //   block [0x830C6140..0x830C61B8)
	// 830C6140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C614C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6150: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6154: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C6158: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C615C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C6160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6164: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6168: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830C616C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6170: 4BFFE781  bl 0x830c48f0
	ctx.lr = 0x830C6174;
	sub_830C48F0(ctx, base);
	// 830C6174: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C617C: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 830C6180: 4B203CD9  bl 0x822c9e58
	ctx.lr = 0x830C6184;
	sub_822C9E58(ctx, base);
	// 830C6184: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C6188: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 830C618C: 4BFFFEDD  bl 0x830c6068
	ctx.lr = 0x830C6190;
	sub_830C6068(ctx, base);
	// 830C6190: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C6194: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C6198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C619C: 4B202C95  bl 0x822c8e30
	ctx.lr = 0x830C61A0;
	sub_822C8E30(ctx, base);
	// 830C61A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C61A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C61A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C61AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C61B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C61B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C61B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C61B8 size=64
    let mut pc: u32 = 0x830C61B8;
    'dispatch: loop {
        match pc {
            0x830C61B8 => {
    //   block [0x830C61B8..0x830C61F8)
	// 830C61B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C61BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C61C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C61C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C61C8: 806300E0  lwz r3, 0xe0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 830C61CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C61D0: 4BFFFF71  bl 0x830c6140
	ctx.lr = 0x830C61D4;
	sub_830C6140(ctx, base);
	// 830C61D4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C61D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C61DC: 419A0008  beq cr6, 0x830c61e4
	if ctx.cr[6].eq {
	pc = 0x830C61E4; continue 'dispatch;
	}
	// 830C61E0: 4B1FA6B1  bl 0x822c0890
	ctx.lr = 0x830C61E4;
	sub_822C0890(ctx, base);
	// 830C61E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C61E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C61EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C61F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C61F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C61F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C61F8 size=156
    let mut pc: u32 = 0x830C61F8;
    'dispatch: loop {
        match pc {
            0x830C61F8 => {
    //   block [0x830C61F8..0x830C6294)
	// 830C61F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C61FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C620C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6210: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 830C6214: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C6218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C621C: 409A000C  bne cr6, 0x830c6228
	if !ctx.cr[6].eq {
	pc = 0x830C6228; continue 'dispatch;
	}
	// 830C6220: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C6224: 48000010  b 0x830c6234
	pc = 0x830C6234; continue 'dispatch;
	// 830C6228: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C622C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830C6230: 7D4A4BD6  divw r10, r10, r9
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830C6234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6238: 419A0030  beq cr6, 0x830c6268
	if ctx.cr[6].eq {
	pc = 0x830C6268; continue 'dispatch;
	}
	// 830C623C: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C6240: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 830C6244: 7D6B4BD6  divw r11, r11, r9
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 830C6248: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C624C: 4098001C  bge cr6, 0x830c6268
	if !ctx.cr[6].lt {
	pc = 0x830C6268; continue 'dispatch;
	}
	// 830C6250: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C6254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C6258: 4BFFE5A9  bl 0x830c4800
	ctx.lr = 0x830C625C;
	sub_830C4800(ctx, base);
	// 830C625C: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830C6260: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C6264: 48000018  b 0x830c627c
	pc = 0x830C627C; continue 'dispatch;
	// 830C6268: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830C626C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C6270: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C6274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C6278: 4BFFFE59  bl 0x830c60d0
	ctx.lr = 0x830C627C;
	sub_830C60D0(ctx, base);
	// 830C627C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6288: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C628C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6298 size=136
    let mut pc: u32 = 0x830C6298;
    'dispatch: loop {
        match pc {
            0x830C6298 => {
    //   block [0x830C6298..0x830C6320)
	// 830C6298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C629C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C62A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C62A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C62A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C62AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C62B0: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C62B4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 830C62B8: 396B7838  addi r11, r11, 0x7838
	ctx.r[11].s64 = ctx.r[11].s64 + 30776;
	// 830C62BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C62C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C62C4: 4BFFEA7D  bl 0x830c4d40
	ctx.lr = 0x830C62C8;
	sub_830C4D40(ctx, base);
	// 830C62C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C62CC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830C62D0: 4B203B89  bl 0x822c9e58
	ctx.lr = 0x830C62D4;
	sub_822C9E58(ctx, base);
	// 830C62D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C62D8: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 830C62DC: 997F0031  stb r11, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[11].u8 ) };
	// 830C62E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C62E4: 995F0030  stb r10, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 830C62E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C62EC: 997F0032  stb r11, 0x32(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(50 as u32), ctx.r[11].u8 ) };
	// 830C62F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C62F4: 997F0033  stb r11, 0x33(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(51 as u32), ctx.r[11].u8 ) };
	// 830C62F8: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 830C62FC: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830C6300: 4B202B31  bl 0x822c8e30
	ctx.lr = 0x830C6304;
	sub_822C8E30(ctx, base);
	// 830C6304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C630C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6314: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C631C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6320 size=72
    let mut pc: u32 = 0x830C6320;
    'dispatch: loop {
        match pc {
            0x830C6320 => {
    //   block [0x830C6320..0x830C6368)
	// 830C6320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C632C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C6338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C633C: 4BFFEA05  bl 0x830c4d40
	ctx.lr = 0x830C6340;
	sub_830C4D40(ctx, base);
	// 830C6340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C6344: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 830C6348: 4BFFF779  bl 0x830c5ac0
	ctx.lr = 0x830C634C;
	sub_830C5AC0(ctx, base);
	// 830C634C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C6350: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6354: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6358: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C635C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C6368 size=428
    let mut pc: u32 = 0x830C6368;
    'dispatch: loop {
        match pc {
            0x830C6368 => {
    //   block [0x830C6368..0x830C6514)
	// 830C6368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C636C: 480E1DF9  bl 0x831a8164
	ctx.lr = 0x830C6370;
	sub_831A8130(ctx, base);
	// 830C6370: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 830C6374: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6378: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C637C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C6380: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C6384: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 830C6388: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 830C638C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830C6390: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C6394: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6398: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830C639C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C63A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830C63A4: 4B1FE0BD  bl 0x822c4460
	ctx.lr = 0x830C63A8;
	sub_822C4460(ctx, base);
	// 830C63A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830C63AC: 387E0104  addi r3, r30, 0x104
	ctx.r[3].s64 = ctx.r[30].s64 + 260;
	// 830C63B0: 4BFFFE49  bl 0x830c61f8
	ctx.lr = 0x830C63B4;
	sub_830C61F8(ctx, base);
	// 830C63B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C63B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830C63BC: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 830C63C0: 4B203A99  bl 0x822c9e58
	ctx.lr = 0x830C63C4;
	sub_822C9E58(ctx, base);
	// 830C63C4: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 830C63C8: C1BE00F4  lfs f13, 0xf4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C63CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C63D0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830C63D4: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830C63D8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830C63DC: C19E00F0  lfs f12, 0xf0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C63E0: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830C63E4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830C63E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C63EC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830C63F0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830C63F4: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830C63F8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830C63FC: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830C6400: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830C6404: EFEC02FA  fmadds f31, f12, f11, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 830C6408: 4B202A29  bl 0x822c8e30
	ctx.lr = 0x830C640C;
	sub_822C8E30(ctx, base);
	// 830C640C: C01E00FC  lfs f0, 0xfc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6410: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830C6414: 40990008  ble cr6, 0x830c641c
	if !ctx.cr[6].gt {
	pc = 0x830C641C; continue 'dispatch;
	}
	// 830C6418: D3FE00FC  stfs f31, 0xfc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830C641C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C6420: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6424: 4BFFFEFD  bl 0x830c6320
	ctx.lr = 0x830C6428;
	sub_830C6320(ctx, base);
	// 830C6428: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C642C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6430: 40990018  ble cr6, 0x830c6448
	if !ctx.cr[6].gt {
	pc = 0x830C6448; continue 'dispatch;
	}
	// 830C6434: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6438: 896B0034  lbz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C643C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C6440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C6444: 419A0008  beq cr6, 0x830c644c
	if ctx.cr[6].eq {
	pc = 0x830C644C; continue 'dispatch;
	}
	// 830C6448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C644C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C6450: 557B063E  clrlwi r27, r11, 0x18
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C6454: 4B20419D  bl 0x822ca5f0
	ctx.lr = 0x830C6458;
	sub_822CA5F0(ctx, base);
	// 830C6458: 281B0000  cmplwi r27, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C645C: 4182008C  beq 0x830c64e8
	if ctx.cr[0].eq {
	pc = 0x830C64E8; continue 'dispatch;
	}
	// 830C6460: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C6464: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6468: 3BFD0001  addi r31, r29, 1
	ctx.r[31].s64 = ctx.r[29].s64 + 1;
	// 830C646C: 4BFFFEB5  bl 0x830c6320
	ctx.lr = 0x830C6470;
	sub_830C6320(ctx, base);
	// 830C6470: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830C6474: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6478: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C647C: 4800005C  b 0x830c64d8
	pc = 0x830C64D8; continue 'dispatch;
	// 830C6480: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C6484: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830C6488: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830C648C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6490: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830C6494: 419A0024  beq cr6, 0x830c64b8
	if ctx.cr[6].eq {
	pc = 0x830C64B8; continue 'dispatch;
	}
	// 830C6498: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C649C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C64A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C64A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C64A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C64AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C64B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C64B4: 4082FFE8  bne 0x830c649c
	if !ctx.cr[0].eq {
	pc = 0x830C649C; continue 'dispatch;
	}
	// 830C64B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C64BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830C64C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C64C4: 4BFFFEA5  bl 0x830c6368
	ctx.lr = 0x830C64C8;
	sub_830C6368(ctx, base);
	// 830C64C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C64CC: 4B422CB5  bl 0x824e9180
	ctx.lr = 0x830C64D0;
	sub_824E9180(ctx, base);
	// 830C64D0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830C64D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C64D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C64DC: 409AFFA4  bne cr6, 0x830c6480
	if !ctx.cr[6].eq {
	pc = 0x830C6480; continue 'dispatch;
	}
	// 830C64E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C64E4: 4B20410D  bl 0x822ca5f0
	ctx.lr = 0x830C64E8;
	sub_822CA5F0(ctx, base);
	// 830C64E8: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C64EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C64F0: 419A0008  beq cr6, 0x830c64f8
	if ctx.cr[6].eq {
	pc = 0x830C64F8; continue 'dispatch;
	}
	// 830C64F4: 4B1FA39D  bl 0x822c0890
	ctx.lr = 0x830C64F8;
	sub_822C0890(ctx, base);
	// 830C64F8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C64FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6500: 419A0008  beq cr6, 0x830c6508
	if ctx.cr[6].eq {
	pc = 0x830C6508; continue 'dispatch;
	}
	// 830C6504: 4B1FA38D  bl 0x822c0890
	ctx.lr = 0x830C6508;
	sub_822C0890(ctx, base);
	// 830C6508: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830C650C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830C6510: 480E1CA4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6518 size=96
    let mut pc: u32 = 0x830C6518;
    'dispatch: loop {
        match pc {
            0x830C6518 => {
    //   block [0x830C6518..0x830C6578)
	// 830C6518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C651C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C652C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6530: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C6534: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C6538: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C653C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830C6540: 4B2028F1  bl 0x822c8e30
	ctx.lr = 0x830C6544;
	sub_822C8E30(ctx, base);
	// 830C6544: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 830C6548: 4B2040A9  bl 0x822ca5f0
	ctx.lr = 0x830C654C;
	sub_822CA5F0(ctx, base);
	// 830C654C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C6550: 4182000C  beq 0x830c655c
	if ctx.cr[0].eq {
	pc = 0x830C655C; continue 'dispatch;
	}
	// 830C6554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6558: 4B1F9D11  bl 0x822c0268
	ctx.lr = 0x830C655C;
	sub_822C0268(ctx, base);
	// 830C655C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C656C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6570: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6574: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C6578 size=292
    let mut pc: u32 = 0x830C6578;
    'dispatch: loop {
        match pc {
            0x830C6578 => {
    //   block [0x830C6578..0x830C669C)
	// 830C6578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C657C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6588: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C658C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C6590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C6594: 3BFE0104  addi r31, r30, 0x104
	ctx.r[31].s64 = ctx.r[30].s64 + 260;
	// 830C6598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C659C: 80DE010C  lwz r6, 0x10c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(268 as u32) ) } as u64;
	// 830C65A0: 80BE0108  lwz r5, 0x108(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C65A4: 4BFFF255  bl 0x830c57f8
	ctx.lr = 0x830C65A8;
	sub_830C57F8(ctx, base);
	// 830C65A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C65AC: 809E00E0  lwz r4, 0xe0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) } as u64;
	// 830C65B0: 4BFFFD71  bl 0x830c6320
	ctx.lr = 0x830C65B4;
	sub_830C6320(ctx, base);
	// 830C65B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C65B8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C65BC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C65C0: D01E00FC  stfs f0, 0xfc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830C65C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C65C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C65CC: 4800005C  b 0x830c6628
	pc = 0x830C6628; continue 'dispatch;
	// 830C65D0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830C65D4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C65D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C65DC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830C65E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C65E4: 419A0024  beq cr6, 0x830c6608
	if ctx.cr[6].eq {
	pc = 0x830C6608; continue 'dispatch;
	}
	// 830C65E8: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 830C65EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C65F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C65F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C65F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C65FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C6600: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C6604: 4082FFE8  bne 0x830c65ec
	if !ctx.cr[0].eq {
	pc = 0x830C65EC; continue 'dispatch;
	}
	// 830C6608: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C660C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830C6610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C6614: 4BFFFD55  bl 0x830c6368
	ctx.lr = 0x830C6618;
	sub_830C6368(ctx, base);
	// 830C6618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C661C: 4B422B65  bl 0x824e9180
	ctx.lr = 0x830C6620;
	sub_824E9180(ctx, base);
	// 830C6620: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C6624: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C6628: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C662C: 409AFFA4  bne cr6, 0x830c65d0
	if !ctx.cr[6].eq {
	pc = 0x830C65D0; continue 'dispatch;
	}
	// 830C6630: 807E0078  lwz r3, 0x78(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C6634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6638: 419A0044  beq cr6, 0x830c667c
	if ctx.cr[6].eq {
	pc = 0x830C667C; continue 'dispatch;
	}
	// 830C663C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C6640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6644: 419A0014  beq cr6, 0x830c6658
	if ctx.cr[6].eq {
	pc = 0x830C6658; continue 'dispatch;
	}
	// 830C6648: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C664C: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 830C6650: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830C6654: 7D6B4BD6  divw r11, r11, r9
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 830C6658: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830C665C: C01E00EC  lfs f0, 0xec(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6660: C03E00FC  lfs f1, 0xfc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C6664: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830C6668: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830C666C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830C6670: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830C6674: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830C6678: 48001C29  bl 0x830c82a0
	ctx.lr = 0x830C667C;
	sub_830C82A0(ctx, base);
	// 830C667C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6680: 4B203F71  bl 0x822ca5f0
	ctx.lr = 0x830C6684;
	sub_822CA5F0(ctx, base);
	// 830C6684: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C6688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C668C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6690: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C66A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C66A0 size=184
    let mut pc: u32 = 0x830C66A0;
    'dispatch: loop {
        match pc {
            0x830C66A0 => {
    //   block [0x830C66A0..0x830C6758)
	// 830C66A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C66A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C66A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C66AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C66B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C66B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C66B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C66BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 830C66C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C66C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C66C8: 4B1FA271  bl 0x822c0938
	ctx.lr = 0x830C66CC;
	sub_822C0938(ctx, base);
	// 830C66CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C66D0: 41820028  beq 0x830c66f8
	if ctx.cr[0].eq {
	pc = 0x830C66F8; continue 'dispatch;
	}
	// 830C66D4: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C66D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 830C66DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C66E0: 392B7824  addi r9, r11, 0x7824
	ctx.r[9].s64 = ctx.r[11].s64 + 30756;
	// 830C66E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830C66E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C66EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830C66F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C66F4: 48000008  b 0x830c66fc
	pc = 0x830C66FC; continue 'dispatch;
	// 830C66F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C66FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C6700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6704: 409A0038  bne cr6, 0x830c673c
	if !ctx.cr[6].eq {
	pc = 0x830C673C; continue 'dispatch;
	}
	// 830C6708: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C670C: 419A0010  beq cr6, 0x830c671c
	if ctx.cr[6].eq {
	pc = 0x830C671C; continue 'dispatch;
	}
	// 830C6710: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C6714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6718: 4BFFFE01  bl 0x830c6518
	ctx.lr = 0x830C671C;
	sub_830C6518(ctx, base);
	// 830C671C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C6720: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C6724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C6728: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 830C672C: 816B45F0  lwz r11, 0x45f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17904 as u32) ) } as u64;
	// 830C6730: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C6734: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C6738: 4B1F98C9  bl 0x822c0000
	ctx.lr = 0x830C673C;
	sub_822C0000(ctx, base);
	// 830C673C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C6740: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C674C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6758 size=12
    let mut pc: u32 = 0x830C6758;
    'dispatch: loop {
        match pc {
            0x830C6758 => {
    //   block [0x830C6758..0x830C6764)
	// 830C6758: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C675C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6760: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6764 size=8
    let mut pc: u32 = 0x830C6764;
    'dispatch: loop {
        match pc {
            0x830C6764 => {
    //   block [0x830C6764..0x830C676C)
	// 830C6764: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C6768: 4BFFFDB0  b 0x830c6518
	sub_830C6518(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C676C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C676C size=4
    let mut pc: u32 = 0x830C676C;
    'dispatch: loop {
        match pc {
            0x830C676C => {
    //   block [0x830C676C..0x830C6770)
	// 830C676C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6770 size=112
    let mut pc: u32 = 0x830C6770;
    'dispatch: loop {
        match pc {
            0x830C6770 => {
    //   block [0x830C6770..0x830C67E0)
	// 830C6770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C677C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6784: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C6788: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C678C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C6790: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C6794: 4BFFFF0D  bl 0x830c66a0
	ctx.lr = 0x830C6798;
	sub_830C66A0(ctx, base);
	// 830C6798: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830C679C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C67A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C67A4: 4B1F985D  bl 0x822c0000
	ctx.lr = 0x830C67A8;
	sub_822C0000(ctx, base);
	// 830C67A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C67AC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C67B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C67B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C67B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C67BC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830C67C0: 419A0008  beq cr6, 0x830c67c8
	if ctx.cr[6].eq {
	pc = 0x830C67C8; continue 'dispatch;
	}
	// 830C67C4: 4B1FA0CD  bl 0x822c0890
	ctx.lr = 0x830C67C8;
	sub_822C0890(ctx, base);
	// 830C67C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C67CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C67D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C67D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C67D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C67DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C67E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C67E0 size=860
    let mut pc: u32 = 0x830C67E0;
    'dispatch: loop {
        match pc {
            0x830C67E0 => {
    //   block [0x830C67E0..0x830C6B3C)
	// 830C67E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C67E4: 480E197D  bl 0x831a8160
	ctx.lr = 0x830C67E8;
	sub_831A8130(ctx, base);
	// 830C67E8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C67EC: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 830C67F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C67F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C67F8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C67FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6800: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C6804: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830C6808: 4B203651  bl 0x822c9e58
	ctx.lr = 0x830C680C;
	sub_822C9E58(ctx, base);
	// 830C680C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830C6810: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830C6814: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C6818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C681C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6820: 48001949  bl 0x830c8168
	ctx.lr = 0x830C6824;
	sub_830C8168(ctx, base);
	// 830C6824: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C6828: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C682C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C6830: 396B784C  addi r11, r11, 0x784c
	ctx.r[11].s64 = ctx.r[11].s64 + 30796;
	// 830C6834: 93C100E0  stw r30, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830C6838: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830C683C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C6840: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C6844: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830C6848: 396A7B70  addi r11, r10, 0x7b70
	ctx.r[11].s64 = ctx.r[10].s64 + 31600;
	// 830C684C: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830C6850: 3B9F00E0  addi r28, r31, 0xe0
	ctx.r[28].s64 = ctx.r[31].s64 + 224;
	// 830C6854: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 830C6858: 9BDF0100  stb r30, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u8 ) };
	// 830C685C: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 830C6860: 93DF010C  stw r30, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 830C6864: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 830C6868: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C686C: 4B20244D  bl 0x822c8cb8
	ctx.lr = 0x830C6870;
	sub_822C8CB8(ctx, base);
	// 830C6870: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C6874: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C6878: 4BFFF0D9  bl 0x830c5950
	ctx.lr = 0x830C687C;
	sub_830C5950(ctx, base);
	// 830C687C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830C6880: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6884: 4B4C568D  bl 0x8258bf10
	ctx.lr = 0x830C6888;
	sub_8258BF10(ctx, base);
	// 830C6888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C688C: 3BBF006C  addi r29, r31, 0x6c
	ctx.r[29].s64 = ctx.r[31].s64 + 108;
	// 830C6890: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C6894: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C6898: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C689C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C68A0: 4BFFA4C1  bl 0x830c0d60
	ctx.lr = 0x830C68A4;
	sub_830C0D60(ctx, base);
	// 830C68A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C68A8: 4B3AA821  bl 0x824710c8
	ctx.lr = 0x830C68AC;
	sub_824710C8(ctx, base);
	// 830C68AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C68B0: 4B202409  bl 0x822c8cb8
	ctx.lr = 0x830C68B4;
	sub_822C8CB8(ctx, base);
	// 830C68B4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C68B8: 4B202401  bl 0x822c8cb8
	ctx.lr = 0x830C68BC;
	sub_822C8CB8(ctx, base);
	// 830C68BC: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830C68C0: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C68C4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C68C8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C68CC: 396B7B80  addi r11, r11, 0x7b80
	ctx.r[11].s64 = ctx.r[11].s64 + 31616;
	// 830C68D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C68D4: 4B2023E5  bl 0x822c8cb8
	ctx.lr = 0x830C68D8;
	sub_822C8CB8(ctx, base);
	// 830C68D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C68DC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C68E0: 4BFFF071  bl 0x830c5950
	ctx.lr = 0x830C68E4;
	sub_830C5950(ctx, base);
	// 830C68E4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C68E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C68EC: 4B4C5625  bl 0x8258bf10
	ctx.lr = 0x830C68F0;
	sub_8258BF10(ctx, base);
	// 830C68F0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830C68F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C68F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C68FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C6900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C6904: 4BFFA45D  bl 0x830c0d60
	ctx.lr = 0x830C6908;
	sub_830C0D60(ctx, base);
	// 830C6908: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C690C: 4B3AA7BD  bl 0x824710c8
	ctx.lr = 0x830C6910;
	sub_824710C8(ctx, base);
	// 830C6910: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C6914: 4B2023A5  bl 0x822c8cb8
	ctx.lr = 0x830C6918;
	sub_822C8CB8(ctx, base);
	// 830C6918: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C691C: 4B20239D  bl 0x822c8cb8
	ctx.lr = 0x830C6920;
	sub_822C8CB8(ctx, base);
	// 830C6920: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 830C6924: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C6928: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C692C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C6930: 396B6C88  addi r11, r11, 0x6c88
	ctx.r[11].s64 = ctx.r[11].s64 + 27784;
	// 830C6934: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C6938: 4B202381  bl 0x822c8cb8
	ctx.lr = 0x830C693C;
	sub_822C8CB8(ctx, base);
	// 830C693C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C6940: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C6944: 4BFFF00D  bl 0x830c5950
	ctx.lr = 0x830C6948;
	sub_830C5950(ctx, base);
	// 830C6948: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830C694C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6950: 4B4C55C1  bl 0x8258bf10
	ctx.lr = 0x830C6954;
	sub_8258BF10(ctx, base);
	// 830C6954: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830C6958: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C695C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C6960: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C6964: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C6968: 4BFFA3F9  bl 0x830c0d60
	ctx.lr = 0x830C696C;
	sub_830C0D60(ctx, base);
	// 830C696C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C6970: 4B3AA759  bl 0x824710c8
	ctx.lr = 0x830C6974;
	sub_824710C8(ctx, base);
	// 830C6974: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C6978: 4B202341  bl 0x822c8cb8
	ctx.lr = 0x830C697C;
	sub_822C8CB8(ctx, base);
	// 830C697C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C6980: 4B202339  bl 0x822c8cb8
	ctx.lr = 0x830C6984;
	sub_822C8CB8(ctx, base);
	// 830C6984: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830C6988: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C698C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C6990: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C6994: 396B6C98  addi r11, r11, 0x6c98
	ctx.r[11].s64 = ctx.r[11].s64 + 27800;
	// 830C6998: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C699C: 4B20231D  bl 0x822c8cb8
	ctx.lr = 0x830C69A0;
	sub_822C8CB8(ctx, base);
	// 830C69A0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C69A4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C69A8: 4BFFEFA9  bl 0x830c5950
	ctx.lr = 0x830C69AC;
	sub_830C5950(ctx, base);
	// 830C69AC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830C69B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C69B4: 4B4C555D  bl 0x8258bf10
	ctx.lr = 0x830C69B8;
	sub_8258BF10(ctx, base);
	// 830C69B8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C69BC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C69C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C69C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C69C8: 4BFFA399  bl 0x830c0d60
	ctx.lr = 0x830C69CC;
	sub_830C0D60(ctx, base);
	// 830C69CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C69D0: 4B3AA6F9  bl 0x824710c8
	ctx.lr = 0x830C69D4;
	sub_824710C8(ctx, base);
	// 830C69D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C69D8: 4B2022E1  bl 0x822c8cb8
	ctx.lr = 0x830C69DC;
	sub_822C8CB8(ctx, base);
	// 830C69DC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C69E0: 4B2022D9  bl 0x822c8cb8
	ctx.lr = 0x830C69E4;
	sub_822C8CB8(ctx, base);
	// 830C69E4: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 830C69E8: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C69EC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C69F0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C69F4: 396B6CA8  addi r11, r11, 0x6ca8
	ctx.r[11].s64 = ctx.r[11].s64 + 27816;
	// 830C69F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C69FC: 4B2022BD  bl 0x822c8cb8
	ctx.lr = 0x830C6A00;
	sub_822C8CB8(ctx, base);
	// 830C6A00: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C6A04: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C6A08: 4BFFEF49  bl 0x830c5950
	ctx.lr = 0x830C6A0C;
	sub_830C5950(ctx, base);
	// 830C6A0C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 830C6A10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6A14: 4B4C54FD  bl 0x8258bf10
	ctx.lr = 0x830C6A18;
	sub_8258BF10(ctx, base);
	// 830C6A18: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830C6A1C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830C6A20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C6A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C6A28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C6A2C: 4BFFA335  bl 0x830c0d60
	ctx.lr = 0x830C6A30;
	sub_830C0D60(ctx, base);
	// 830C6A30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C6A34: 4B3AA695  bl 0x824710c8
	ctx.lr = 0x830C6A38;
	sub_824710C8(ctx, base);
	// 830C6A38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C6A3C: 4B20227D  bl 0x822c8cb8
	ctx.lr = 0x830C6A40;
	sub_822C8CB8(ctx, base);
	// 830C6A40: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C6A44: 4B202275  bl 0x822c8cb8
	ctx.lr = 0x830C6A48;
	sub_822C8CB8(ctx, base);
	// 830C6A48: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 830C6A4C: 4B1F9EED  bl 0x822c0938
	ctx.lr = 0x830C6A50;
	sub_822C0938(ctx, base);
	// 830C6A50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C6A54: 4182001C  beq 0x830c6a70
	if ctx.cr[0].eq {
	pc = 0x830C6A70; continue 'dispatch;
	}
	// 830C6A58: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830C6A5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C6A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C6A64: 48001AC5  bl 0x830c8528
	ctx.lr = 0x830C6A68;
	sub_830C8528(ctx, base);
	// 830C6A68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C6A6C: 48000008  b 0x830c6a74
	pc = 0x830C6A74; continue 'dispatch;
	// 830C6A70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C6A74: 3BBF0078  addi r29, r31, 0x78
	ctx.r[29].s64 = ctx.r[31].s64 + 120;
	// 830C6A78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C6A7C: 4BFFC8F5  bl 0x830c3370
	ctx.lr = 0x830C6A80;
	sub_830C3370(ctx, base);
	// 830C6A80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C6A84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C6A88: 9BDF00E8  stb r30, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u8 ) };
	// 830C6A8C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C6A90: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 830C6A94: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830C6A98: C00B9590  lfs f0, -0x6a70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6A9C: 911F00F8  stw r8, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[8].u32 ) };
	// 830C6AA0: C1AA9594  lfs f13, -0x6a6c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C6AA4: C189959C  lfs f12, -0x6a64(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C6AA8: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 830C6AAC: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 830C6AB0: D19F00EC  stfs f12, 0xec(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 830C6AB4: 4B1F9E85  bl 0x822c0938
	ctx.lr = 0x830C6AB8;
	sub_822C0938(ctx, base);
	// 830C6AB8: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830C6ABC: 41820028  beq 0x830c6ae4
	if ctx.cr[0].eq {
	pc = 0x830C6AE4; continue 'dispatch;
	}
	// 830C6AC0: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C6AC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6AC8: 388B7840  addi r4, r11, 0x7840
	ctx.r[4].s64 = ctx.r[11].s64 + 30784;
	// 830C6ACC: 4B202825  bl 0x822c92f0
	ctx.lr = 0x830C6AD0;
	sub_822C92F0(ctx, base);
	// 830C6AD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C6AD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C6AD8: 4BFFF7C1  bl 0x830c6298
	ctx.lr = 0x830C6ADC;
	sub_830C6298(ctx, base);
	// 830C6ADC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C6AE0: 48000008  b 0x830c6ae8
	pc = 0x830C6AE8; continue 'dispatch;
	// 830C6AE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C6AE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C6AEC: 4BFFFC85  bl 0x830c6770
	ctx.lr = 0x830C6AF0;
	sub_830C6770(ctx, base);
	// 830C6AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C6AF4: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6AF8: 4BFFDDF9  bl 0x830c48f0
	ctx.lr = 0x830C6AFC;
	sub_830C48F0(ctx, base);
	// 830C6AFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C6B04: 419A001C  beq cr6, 0x830c6b20
	if ctx.cr[6].eq {
	pc = 0x830C6B20; continue 'dispatch;
	}
	// 830C6B08: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830C6B0C: C01F00EC  lfs f0, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6B10: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830C6B14: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6B18: C00A89AC  lfs f0, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6B1C: D00B0074  stfs f0, 0x74(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C6B20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C6B24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C6B28: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C6B2C: 4B202305  bl 0x822c8e30
	ctx.lr = 0x830C6B30;
	sub_822C8E30(ctx, base);
	// 830C6B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6B34: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 830C6B38: 480E1678  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6B40 size=96
    let mut pc: u32 = 0x830C6B40;
    'dispatch: loop {
        match pc {
            0x830C6B40 => {
    //   block [0x830C6B40..0x830C6BA0)
	// 830C6B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6B48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6B4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6B54: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 830C6B58: 4BFFED19  bl 0x830c5870
	ctx.lr = 0x830C6B5C;
	sub_830C5870(ctx, base);
	// 830C6B5C: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830C6B60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6B64: 419A0008  beq cr6, 0x830c6b6c
	if ctx.cr[6].eq {
	pc = 0x830C6B6C; continue 'dispatch;
	}
	// 830C6B68: 4B1F9D29  bl 0x822c0890
	ctx.lr = 0x830C6B6C;
	sub_822C0890(ctx, base);
	// 830C6B6C: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C6B70: 4B202149  bl 0x822c8cb8
	ctx.lr = 0x830C6B74;
	sub_822C8CB8(ctx, base);
	// 830C6B74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C6B78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C6B7C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830C6B80: 4B2022B1  bl 0x822c8e30
	ctx.lr = 0x830C6B84;
	sub_822C8E30(ctx, base);
	// 830C6B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6B88: 4BFFCFA9  bl 0x830c3b30
	ctx.lr = 0x830C6B8C;
	sub_830C3B30(ctx, base);
	// 830C6B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C6B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6BA0 size=76
    let mut pc: u32 = 0x830C6BA0;
    'dispatch: loop {
        match pc {
            0x830C6BA0 => {
    //   block [0x830C6BA0..0x830C6BEC)
	// 830C6BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6BB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C6BBC: 4BFFFF85  bl 0x830c6b40
	ctx.lr = 0x830C6BC0;
	sub_830C6B40(ctx, base);
	// 830C6BC0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C6BC4: 4182000C  beq 0x830c6bd0
	if ctx.cr[0].eq {
	pc = 0x830C6BD0; continue 'dispatch;
	}
	// 830C6BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6BCC: 4B1F969D  bl 0x822c0268
	ctx.lr = 0x830C6BD0;
	sub_822C0268(ctx, base);
	// 830C6BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6BD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6BD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6BDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6BE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6BF0 size=8
    let mut pc: u32 = 0x830C6BF0;
    'dispatch: loop {
        match pc {
            0x830C6BF0 => {
    //   block [0x830C6BF0..0x830C6BF8)
	// 830C6BF0: 908300F4  stw r4, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[4].u32 ) };
	// 830C6BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6BF8 size=8
    let mut pc: u32 = 0x830C6BF8;
    'dispatch: loop {
        match pc {
            0x830C6BF8 => {
    //   block [0x830C6BF8..0x830C6C00)
	// 830C6BF8: 806300F4  lwz r3, 0xf4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 830C6BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6C00 size=136
    let mut pc: u32 = 0x830C6C00;
    'dispatch: loop {
        match pc {
            0x830C6C00 => {
    //   block [0x830C6C00..0x830C6C88)
	// 830C6C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6C10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6C14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C6C18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C6C1C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830C6C20: 409A0020  bne cr6, 0x830c6c40
	if !ctx.cr[6].eq {
	pc = 0x830C6C40; continue 'dispatch;
	}
	// 830C6C24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C6C28: 419A0048  beq cr6, 0x830c6c70
	if ctx.cr[6].eq {
	pc = 0x830C6C70; continue 'dispatch;
	}
	// 830C6C2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6C30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C6C34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C6C38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C6C3C: 48000034  b 0x830c6c70
	pc = 0x830C6C70; continue 'dispatch;
	// 830C6C40: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830C6C44: 419A002C  beq cr6, 0x830c6c70
	if ctx.cr[6].eq {
	pc = 0x830C6C70; continue 'dispatch;
	}
	// 830C6C48: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C6C4C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6C50: 388B46B8  addi r4, r11, 0x46b8
	ctx.r[4].s64 = ctx.r[11].s64 + 18104;
	// 830C6C54: 480E14A5  bl 0x831a80f8
	ctx.lr = 0x830C6C58;
	sub_831A80F8(ctx, base);
	// 830C6C58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C6C5C: 4182000C  beq 0x830c6c68
	if ctx.cr[0].eq {
	pc = 0x830C6C68; continue 'dispatch;
	}
	// 830C6C60: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830C6C64: 4800000C  b 0x830c6c70
	pc = 0x830C6C70; continue 'dispatch;
	// 830C6C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C6C6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C6C70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C6C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6C7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6C80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6C88 size=16
    let mut pc: u32 = 0x830C6C88;
    'dispatch: loop {
        match pc {
            0x830C6C88 => {
    //   block [0x830C6C88..0x830C6C98)
	// 830C6C88: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6C8C: 816C002C  lwz r11, 0x2c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(44 as u32) ) } as u64;
	// 830C6C90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6C94: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6C98 size=16
    let mut pc: u32 = 0x830C6C98;
    'dispatch: loop {
        match pc {
            0x830C6C98 => {
    //   block [0x830C6C98..0x830C6CA8)
	// 830C6C98: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6C9C: 816C0030  lwz r11, 0x30(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C6CA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6CA4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6CA8 size=16
    let mut pc: u32 = 0x830C6CA8;
    'dispatch: loop {
        match pc {
            0x830C6CA8 => {
    //   block [0x830C6CA8..0x830C6CB8)
	// 830C6CA8: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6CAC: 816C0034  lwz r11, 0x34(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C6CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6CB4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C6CB8 size=88
    let mut pc: u32 = 0x830C6CB8;
    'dispatch: loop {
        match pc {
            0x830C6CB8 => {
    //   block [0x830C6CB8..0x830C6D10)
	// 830C6CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6CC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6CC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C6CC8: 806B0078  lwz r3, 0x78(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C6CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6CD0: 419A0030  beq cr6, 0x830c6d00
	if ctx.cr[6].eq {
	pc = 0x830C6D00; continue 'dispatch;
	}
	// 830C6CD4: 814B00EC  lwz r10, 0xec(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(236 as u32) ) } as u64;
	// 830C6CD8: C00B00F0  lfs f0, 0xf0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6CDC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830C6CE0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830C6CE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830C6CE8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C6CEC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830C6CF0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830C6CF4: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C6CF8: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830C6CFC: 480015A5  bl 0x830c82a0
	ctx.lr = 0x830C6D00;
	sub_830C82A0(ctx, base);
	// 830C6D00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C6D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C6D10 size=300
    let mut pc: u32 = 0x830C6D10;
    'dispatch: loop {
        match pc {
            0x830C6D10 => {
    //   block [0x830C6D10..0x830C6E3C)
	// 830C6D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6D20: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C6D24: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6D28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6D2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C6D30: 897F00E0  lbz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830C6D34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C6D38: 408200E4  bne 0x830c6e1c
	if !ctx.cr[0].eq {
	pc = 0x830C6E1C; continue 'dispatch;
	}
	// 830C6D3C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C6D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C6D44: 997F00E0  stb r11, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 830C6D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6D4C: 419A0020  beq cr6, 0x830c6d6c
	if ctx.cr[6].eq {
	pc = 0x830C6D6C; continue 'dispatch;
	}
	// 830C6D50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6D54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C6D58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6D5C: 4E800421  bctrl
	ctx.lr = 0x830C6D60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6D60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C6D64: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C6D68: 419A00B4  beq cr6, 0x830c6e1c
	if ctx.cr[6].eq {
	pc = 0x830C6E1C; continue 'dispatch;
	}
	// 830C6D6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6D70: C3FE0008  lfs f31, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C6D74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C6D78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6D7C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C6D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6D84: 4E800421  bctrl
	ctx.lr = 0x830C6D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6D88: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C6D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C6D90: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6D94: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C6D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6D9C: 4E800421  bctrl
	ctx.lr = 0x830C6DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6DA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6DA4: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6DAC: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C6DB0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C6DB4: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C6DB8: EC206028  fsubs f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C6DBC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C6DC0: EC4D5828  fsubs f2, f13, f11
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C6DC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6DC8: 4E800421  bctrl
	ctx.lr = 0x830C6DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6DCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C6DD0: 4082000C  bne 0x830c6ddc
	if !ctx.cr[0].eq {
	pc = 0x830C6DDC; continue 'dispatch;
	}
	// 830C6DD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C6DD8: 48000048  b 0x830c6e20
	pc = 0x830C6E20; continue 'dispatch;
	// 830C6DDC: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6DE0: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C6DE4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C6DE8: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C6DEC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C6DF0: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C6DF4: 419A0014  beq cr6, 0x830c6e08
	if ctx.cr[6].eq {
	pc = 0x830C6E08; continue 'dispatch;
	}
	// 830C6DF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C6DFC: 48001ACD  bl 0x830c88c8
	ctx.lr = 0x830C6E00;
	sub_830C88C8(ctx, base);
	// 830C6E00: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6E04: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830C6E08: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6E0C: 396000F4  li r11, 0xf4
	ctx.r[11].s64 = 244;
	// 830C6E10: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C6E14: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C6E18: 7C1F5FAE  stfiwx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 830C6E1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C6E20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C6E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6E2C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C6E30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6E34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6E40 size=28
    let mut pc: u32 = 0x830C6E40;
    'dispatch: loop {
        match pc {
            0x830C6E40 => {
    //   block [0x830C6E40..0x830C6E5C)
	// 830C6E40: 80630078  lwz r3, 0x78(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C6E44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6E48: 419A0014  beq cr6, 0x830c6e5c
	if ctx.cr[6].eq {
		sub_830C6E5C(ctx, base);
		return;
	}
	// 830C6E4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6E50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C6E54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6E58: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6E5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C6E5C size=8
    let mut pc: u32 = 0x830C6E5C;
    'dispatch: loop {
        match pc {
            0x830C6E5C => {
    //   block [0x830C6E5C..0x830C6E64)
	// 830C6E5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C6E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C6E68 size=236
    let mut pc: u32 = 0x830C6E68;
    'dispatch: loop {
        match pc {
            0x830C6E68 => {
    //   block [0x830C6E68..0x830C6F54)
	// 830C6E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C6E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C6E78: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C6E7C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6E84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C6E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C6E8C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C6E90: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6E94: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C6E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6E9C: 4E800421  bctrl
	ctx.lr = 0x830C6EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6EA0: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C6EA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C6EA8: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6EAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C6EB0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6EB4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C6EB8: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C6EBC: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C6EC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6EC4: 4E800421  bctrl
	ctx.lr = 0x830C6EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6EC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6ECC: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C6ED4: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C6ED8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C6EDC: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C6EE0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C6EE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6EE8: 4E800421  bctrl
	ctx.lr = 0x830C6EEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6EEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C6EF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C6EF4: 409A0040  bne cr6, 0x830c6f34
	if !ctx.cr[6].eq {
	pc = 0x830C6F34; continue 'dispatch;
	}
	// 830C6EF8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830C6EFC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830C6F00: 40990034  ble cr6, 0x830c6f34
	if !ctx.cr[6].gt {
	pc = 0x830C6F34; continue 'dispatch;
	}
	// 830C6F04: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830C6F08: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C6F0C: 40980028  bge cr6, 0x830c6f34
	if !ctx.cr[6].lt {
	pc = 0x830C6F34; continue 'dispatch;
	}
	// 830C6F10: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C6F14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C6F18: 419A001C  beq cr6, 0x830c6f34
	if ctx.cr[6].eq {
	pc = 0x830C6F34; continue 'dispatch;
	}
	// 830C6F1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6F20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C6F24: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C6F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6F2C: 4E800421  bctrl
	ctx.lr = 0x830C6F30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6F30: 48000008  b 0x830c6f38
	pc = 0x830C6F38; continue 'dispatch;
	// 830C6F34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C6F38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C6F3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6F40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6F44: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C6F48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C6F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C6F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C6F58 size=72
    let mut pc: u32 = 0x830C6F58;
    'dispatch: loop {
        match pc {
            0x830C6F58 => {
    //   block [0x830C6F58..0x830C6FA0)
	// 830C6F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C6F60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6F64: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 830C6F68: 419A001C  beq cr6, 0x830c6f84
	if ctx.cr[6].eq {
	pc = 0x830C6F84; continue 'dispatch;
	}
	// 830C6F6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C6F70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C6F74: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830C6F78: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C6F7C: 4BFFFC85  bl 0x830c6c00
	ctx.lr = 0x830C6F80;
	sub_830C6C00(ctx, base);
	// 830C6F80: 48000010  b 0x830c6f90
	pc = 0x830C6F90; continue 'dispatch;
	// 830C6F84: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C6F88: 396B46B8  addi r11, r11, 0x46b8
	ctx.r[11].s64 = ctx.r[11].s64 + 18104;
	// 830C6F8C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C6F90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C6F94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C6F98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C6F9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C6FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C6FA0 size=992
    let mut pc: u32 = 0x830C6FA0;
    'dispatch: loop {
        match pc {
            0x830C6FA0 => {
    //   block [0x830C6FA0..0x830C7380)
	// 830C6FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C6FA4: 480E11B9  bl 0x831a815c
	ctx.lr = 0x830C6FA8;
	sub_831A8130(ctx, base);
	// 830C6FA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 830C6FAC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C6FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C6FB4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830C6FB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C6FBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C6FC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6FC4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C6FC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6FCC: 4E800421  bctrl
	ctx.lr = 0x830C6FD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6FD0: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C6FD4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830C6FD8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C6FDC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C6FE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C6FE4: 4E800421  bctrl
	ctx.lr = 0x830C6FE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C6FE8: C0010094  lfs f0, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C6FEC: C1A10090  lfs f13, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C6FF0: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 830C6FF4: C1810074  lfs f12, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C6FF8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C6FFC: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C7000: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C7004: C141007C  lfs f10, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C7008: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C700C: C1210078  lfs f9, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C7010: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C7014: EDA9682A  fadds f13, f9, f13
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C7018: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C701C: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830C7020: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 830C7024: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830C7028: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830C702C: 480022B5  bl 0x830c92e0
	ctx.lr = 0x830C7030;
	sub_830C92E0(ctx, base);
	// 830C7030: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C7034: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C7038: 409A0010  bne cr6, 0x830c7048
	if !ctx.cr[6].eq {
	pc = 0x830C7048; continue 'dispatch;
	}
	// 830C703C: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7040: 4BDB1541  bl 0x82e78580
	ctx.lr = 0x830C7044;
	sub_82E78580(ctx, base);
	// 830C7044: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830C7048: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C704C: 4B201CCD  bl 0x822c8d18
	ctx.lr = 0x830C7050;
	sub_822C8D18(ctx, base);
	// 830C7050: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7058: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C705C: 409A0008  bne cr6, 0x830c7064
	if !ctx.cr[6].eq {
	pc = 0x830C7064; continue 'dispatch;
	}
	// 830C7060: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C7064: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 830C7068: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830C706C: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 830C7070: C03A0000  lfs f1, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C7074: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 830C7078: 3900000B  li r8, 0xb
	ctx.r[8].s64 = 11;
	// 830C707C: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 830C7080: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830C7084: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7088: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830C708C: C04BE830  lfs f2, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C7090: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C7094: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C7098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C709C: 4E800421  bctrl
	ctx.lr = 0x830C70A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C70A0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C70A4: 4BD2ABED  bl 0x82df1c90
	ctx.lr = 0x830C70A8;
	sub_82DF1C90(ctx, base);
	// 830C70A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C70AC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 830C70B0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C70B4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 830C70B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C70BC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C70C0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C70C4: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 830C70C8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C70CC: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830C70D0: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 830C70D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C70D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C70DC: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C70E0: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830C70E4: 419A0078  beq cr6, 0x830c715c
	if ctx.cr[6].eq {
	pc = 0x830C715C; continue 'dispatch;
	}
	// 830C70E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C70EC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C70F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C70F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C70F8: 4E800421  bctrl
	ctx.lr = 0x830C70FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C70FC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830C7100: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C7104: 480017C5  bl 0x830c88c8
	ctx.lr = 0x830C7108;
	sub_830C88C8(ctx, base);
	// 830C7108: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C710C: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 830C7110: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 830C7114: 892B0088  lbz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C7380 size=128
    let mut pc: u32 = 0x830C7380;
    'dispatch: loop {
        match pc {
            0x830C7380 => {
    //   block [0x830C7380..0x830C7400)
	// 830C7380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7384: 480E0DE9  bl 0x831a816c
	ctx.lr = 0x830C7388;
	sub_831A8130(ctx, base);
	// 830C7388: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C738C: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830C7390: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830C7394: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C7398: 3BEBBDEC  addi r31, r11, -0x4214
	ctx.r[31].s64 = ctx.r[11].s64 + -16916;
	// 830C739C: 816ABDF4  lwz r11, -0x420c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16908 as u32) ) } as u64;
	// 830C73A0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C73A4: 40820024  bne 0x830c73c8
	if !ctx.cr[0].eq {
	pc = 0x830C73C8; continue 'dispatch;
	}
	// 830C73A8: 3D2082E1  lis r9, -0x7d1f
	ctx.r[9].s64 = -2099183616;
	// 830C73AC: 3D00830C  lis r8, -0x7cf4
	ctx.r[8].s64 = -2096365568;
	// 830C73B0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C73B4: 3929BD78  addi r9, r9, -0x4288
	ctx.r[9].s64 = ctx.r[9].s64 + -17032;
	// 830C73B8: 39086F58  addi r8, r8, 0x6f58
	ctx.r[8].s64 = ctx.r[8].s64 + 28504;
	// 830C73BC: 916ABDF4  stw r11, -0x420c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16908 as u32), ctx.r[11].u32 ) };
	// 830C73C0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C73C4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830C73C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C73CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C73D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C73D4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830C73D8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830C73DC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C73E0: 4BD44311  bl 0x82e0b6f0
	ctx.lr = 0x830C73E4;
	sub_82E0B6F0(ctx, base);
	// 830C73E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C73E8: 4182000C  beq 0x830c73f4
	if ctx.cr[0].eq {
	pc = 0x830C73F4; continue 'dispatch;
	}
	// 830C73EC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830C73F0: 48000008  b 0x830c73f8
	pc = 0x830C73F8; continue 'dispatch;
	// 830C73F4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830C73F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C73FC: 480E0DC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7400 size=364
    let mut pc: u32 = 0x830C7400;
    'dispatch: loop {
        match pc {
            0x830C7400 => {
    //   block [0x830C7400..0x830C756C)
	// 830C7400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7404: 480E0D69  bl 0x831a816c
	ctx.lr = 0x830C7408;
	sub_831A8130(ctx, base);
	// 830C7408: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830C740C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C7414: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C7418: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C741C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C7420: 9BBF00E0  stb r29, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u8 ) };
	// 830C7424: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C7428: 419A002C  beq cr6, 0x830c7454
	if ctx.cr[6].eq {
	pc = 0x830C7454; continue 'dispatch;
	}
	// 830C742C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7430: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C7434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7438: 4E800421  bctrl
	ctx.lr = 0x830C743C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C743C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C7440: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C7444: 409A0010  bne cr6, 0x830c7454
	if !ctx.cr[6].eq {
	pc = 0x830C7454; continue 'dispatch;
	}
	// 830C7448: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C744C: 9BBF00F8  stb r29, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[29].u8 ) };
	// 830C7450: 48000110  b 0x830c7560
	pc = 0x830C7560; continue 'dispatch;
	// 830C7454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7458: C3FE0008  lfs f31, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C745C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C7460: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C7464: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C7468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C746C: 4E800421  bctrl
	ctx.lr = 0x830C7470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7470: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7474: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7478: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C747C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C7480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7484: 4E800421  bctrl
	ctx.lr = 0x830C7488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7488: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C748C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7494: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7498: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C749C: C1610064  lfs f11, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C74A0: EC206028  fsubs f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C74A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C74A8: EC4D5828  fsubs f2, f13, f11
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C74AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C74B0: 4E800421  bctrl
	ctx.lr = 0x830C74B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C74B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C74B8: 418200A4  beq 0x830c755c
	if ctx.cr[0].eq {
	pc = 0x830C755C; continue 'dispatch;
	}
	// 830C74BC: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C74C0: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C74C4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C74C8: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C74CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C74D0: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C74D4: 419A0014  beq cr6, 0x830c74e8
	if ctx.cr[6].eq {
	pc = 0x830C74E8; continue 'dispatch;
	}
	// 830C74D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C74DC: 480013ED  bl 0x830c88c8
	ctx.lr = 0x830C74E0;
	sub_830C88C8(ctx, base);
	// 830C74E0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C74E4: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830C74E8: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C74EC: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830C74F0: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C74F4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C74F8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830C74FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C7500: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C7504: 409A0058  bne cr6, 0x830c755c
	if !ctx.cr[6].eq {
	pc = 0x830C755C; continue 'dispatch;
	}
	// 830C7508: 897F00F9  lbz r11, 0xf9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(249 as u32) ) } as u64;
	// 830C750C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C7510: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C7514: 995F00F8  stb r10, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u8 ) };
	// 830C7518: 4182003C  beq 0x830c7554
	if ctx.cr[0].eq {
	pc = 0x830C7554; continue 'dispatch;
	}
	// 830C751C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C7520: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C7524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7528: 419A002C  beq cr6, 0x830c7554
	if ctx.cr[6].eq {
	pc = 0x830C7554; continue 'dispatch;
	}
	// 830C752C: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 830C7530: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 830C7534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7538: 419A001C  beq cr6, 0x830c7554
	if ctx.cr[6].eq {
	pc = 0x830C7554; continue 'dispatch;
	}
	// 830C753C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 830C7540: 40990014  ble cr6, 0x830c7554
	if !ctx.cr[6].gt {
	pc = 0x830C7554; continue 'dispatch;
	}
	// 830C7544: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830C7548: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C754C: 40980008  bge cr6, 0x830c7554
	if !ctx.cr[6].lt {
	pc = 0x830C7554; continue 'dispatch;
	}
	// 830C7550: 4B4EA379  bl 0x825b18c8
	ctx.lr = 0x830C7554;
	sub_825B18C8(ctx, base);
	// 830C7554: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C7558: 48000008  b 0x830c7560
	pc = 0x830C7560; continue 'dispatch;
	// 830C755C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C7560: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830C7564: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830C7568: 480E0C54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7570 size=260
    let mut pc: u32 = 0x830C7570;
    'dispatch: loop {
        match pc {
            0x830C7570 => {
    //   block [0x830C7570..0x830C7674)
	// 830C7570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C7578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C757C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830C7580: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C7588: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830C758C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830C7590: 409900C8  ble cr6, 0x830c7658
	if !ctx.cr[6].gt {
	pc = 0x830C7658; continue 'dispatch;
	}
	// 830C7594: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830C7598: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C759C: 409800BC  bge cr6, 0x830c7658
	if !ctx.cr[6].lt {
	pc = 0x830C7658; continue 'dispatch;
	}
	// 830C75A0: 897F00F8  lbz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830C75A4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C75A8: 409A00B0  bne cr6, 0x830c7658
	if !ctx.cr[6].eq {
	pc = 0x830C7658; continue 'dispatch;
	}
	// 830C75AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C75B0: C3E40008  lfs f31, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C75B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C75B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C75BC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C75C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C75C4: 4E800421  bctrl
	ctx.lr = 0x830C75C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C75C8: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C75CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C75D0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C75D4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C75D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C75DC: 4E800421  bctrl
	ctx.lr = 0x830C75E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C75E0: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C75E4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C75E8: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C75EC: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C75F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C75F4: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C75F8: 419A0014  beq cr6, 0x830c760c
	if ctx.cr[6].eq {
	pc = 0x830C760C; continue 'dispatch;
	}
	// 830C75FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C7600: 480012C9  bl 0x830c88c8
	ctx.lr = 0x830C7604;
	sub_830C88C8(ctx, base);
	// 830C7604: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7608: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830C760C: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7610: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830C7614: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C7618: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C761C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830C7620: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C7624: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830C7628: 409A0030  bne cr6, 0x830c7658
	if !ctx.cr[6].eq {
	pc = 0x830C7658; continue 'dispatch;
	}
	// 830C762C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C7630: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C7634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7638: 419A0020  beq cr6, 0x830c7658
	if ctx.cr[6].eq {
	pc = 0x830C7658; continue 'dispatch;
	}
	// 830C763C: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 830C7640: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 830C7644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7648: 419A0010  beq cr6, 0x830c7658
	if ctx.cr[6].eq {
	pc = 0x830C7658; continue 'dispatch;
	}
	// 830C764C: 4B4EA27D  bl 0x825b18c8
	ctx.lr = 0x830C7650;
	sub_825B18C8(ctx, base);
	// 830C7650: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C7654: 48000008  b 0x830c765c
	pc = 0x830C765C; continue 'dispatch;
	// 830C7658: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C765C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C7660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C7664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C7668: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C766C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C7670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7678 size=760
    let mut pc: u32 = 0x830C7678;
    'dispatch: loop {
        match pc {
            0x830C7678 => {
    //   block [0x830C7678..0x830C7970)
	// 830C7678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C767C: 480E0AE5  bl 0x831a8160
	ctx.lr = 0x830C7680;
	sub_831A8130(ctx, base);
	// 830C7680: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7684: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830C7688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C768C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C7690: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C7694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7698: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C769C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830C76A0: 4B2027B9  bl 0x822c9e58
	ctx.lr = 0x830C76A4;
	sub_822C9E58(ctx, base);
	// 830C76A4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830C76A8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830C76AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C76B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C76B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C76B8: 48000AB1  bl 0x830c8168
	ctx.lr = 0x830C76BC;
	sub_830C8168(ctx, base);
	// 830C76BC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C76C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C76C4: 396B7884  addi r11, r11, 0x7884
	ctx.r[11].s64 = ctx.r[11].s64 + 30852;
	// 830C76C8: 3B9F00E4  addi r28, r31, 0xe4
	ctx.r[28].s64 = ctx.r[31].s64 + 228;
	// 830C76CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C76D0: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830C76D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C76D8: 4B482DE9  bl 0x8254a4c0
	ctx.lr = 0x830C76DC;
	sub_8254A4C0(ctx, base);
	// 830C76DC: 907F00E8  stw r3, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[3].u32 ) };
	// 830C76E0: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 830C76E4: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C76E8: 9BDF00F9  stb r30, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[30].u8 ) };
	// 830C76EC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C76F0: 93C100E0  stw r30, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830C76F4: 396B7B70  addi r11, r11, 0x7b70
	ctx.r[11].s64 = ctx.r[11].s64 + 31600;
	// 830C76F8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C76FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7700: 4B2015B9  bl 0x822c8cb8
	ctx.lr = 0x830C7704;
	sub_822C8CB8(ctx, base);
	// 830C7704: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C7708: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C770C: 4BFFFC75  bl 0x830c7380
	ctx.lr = 0x830C7710;
	sub_830C7380(ctx, base);
	// 830C7710: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830C7714: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7718: 4B4C47F9  bl 0x8258bf10
	ctx.lr = 0x830C771C;
	sub_8258BF10(ctx, base);
	// 830C771C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C7720: 3BBF006C  addi r29, r31, 0x6c
	ctx.r[29].s64 = ctx.r[31].s64 + 108;
	// 830C7724: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7728: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C772C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7730: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C7734: 4BFF962D  bl 0x830c0d60
	ctx.lr = 0x830C7738;
	sub_830C0D60(ctx, base);
	// 830C7738: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C773C: 4B3A998D  bl 0x824710c8
	ctx.lr = 0x830C7740;
	sub_824710C8(ctx, base);
	// 830C7740: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C7744: 4B201575  bl 0x822c8cb8
	ctx.lr = 0x830C7748;
	sub_822C8CB8(ctx, base);
	// 830C7748: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 830C774C: 4B20156D  bl 0x822c8cb8
	ctx.lr = 0x830C7750;
	sub_822C8CB8(ctx, base);
	// 830C7750: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830C7754: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C7758: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C775C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C7760: 396B7B80  addi r11, r11, 0x7b80
	ctx.r[11].s64 = ctx.r[11].s64 + 31616;
	// 830C7764: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7768: 4B201551  bl 0x822c8cb8
	ctx.lr = 0x830C776C;
	sub_822C8CB8(ctx, base);
	// 830C776C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C7770: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C7774: 4BFFFC0D  bl 0x830c7380
	ctx.lr = 0x830C7778;
	sub_830C7380(ctx, base);
	// 830C7778: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C777C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7780: 4B4C4791  bl 0x8258bf10
	ctx.lr = 0x830C7784;
	sub_8258BF10(ctx, base);
	// 830C7784: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830C7788: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C778C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C7794: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7798: 4BFF95C9  bl 0x830c0d60
	ctx.lr = 0x830C779C;
	sub_830C0D60(ctx, base);
	// 830C779C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C77A0: 4B3A9929  bl 0x824710c8
	ctx.lr = 0x830C77A4;
	sub_824710C8(ctx, base);
	// 830C77A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C77A8: 4B201511  bl 0x822c8cb8
	ctx.lr = 0x830C77AC;
	sub_822C8CB8(ctx, base);
	// 830C77AC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C77B0: 4B201509  bl 0x822c8cb8
	ctx.lr = 0x830C77B4;
	sub_822C8CB8(ctx, base);
	// 830C77B4: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C77B8: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 830C77BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C77C0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C77C4: 396B6C88  addi r11, r11, 0x6c88
	ctx.r[11].s64 = ctx.r[11].s64 + 27784;
	// 830C77C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C77CC: 4B2014ED  bl 0x822c8cb8
	ctx.lr = 0x830C77D0;
	sub_822C8CB8(ctx, base);
	// 830C77D0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C77D4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C77D8: 4BFFFBA9  bl 0x830c7380
	ctx.lr = 0x830C77DC;
	sub_830C7380(ctx, base);
	// 830C77DC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830C77E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C77E4: 4B4C472D  bl 0x8258bf10
	ctx.lr = 0x830C77E8;
	sub_8258BF10(ctx, base);
	// 830C77E8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830C77EC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C77F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C77F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C77F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C77FC: 4BFF9565  bl 0x830c0d60
	ctx.lr = 0x830C7800;
	sub_830C0D60(ctx, base);
	// 830C7800: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C7804: 4B3A98C5  bl 0x824710c8
	ctx.lr = 0x830C7808;
	sub_824710C8(ctx, base);
	// 830C7808: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C780C: 4B2014AD  bl 0x822c8cb8
	ctx.lr = 0x830C7810;
	sub_822C8CB8(ctx, base);
	// 830C7810: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C7814: 4B2014A5  bl 0x822c8cb8
	ctx.lr = 0x830C7818;
	sub_822C8CB8(ctx, base);
	// 830C7818: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830C781C: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C7820: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C7824: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C7828: 396B6C98  addi r11, r11, 0x6c98
	ctx.r[11].s64 = ctx.r[11].s64 + 27800;
	// 830C782C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7830: 4B201489  bl 0x822c8cb8
	ctx.lr = 0x830C7834;
	sub_822C8CB8(ctx, base);
	// 830C7834: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C7838: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C783C: 4BFFFB45  bl 0x830c7380
	ctx.lr = 0x830C7840;
	sub_830C7380(ctx, base);
	// 830C7840: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830C7844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7848: 4B4C46C9  bl 0x8258bf10
	ctx.lr = 0x830C784C;
	sub_8258BF10(ctx, base);
	// 830C784C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C7850: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C7854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7858: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C785C: 4BFF9505  bl 0x830c0d60
	ctx.lr = 0x830C7860;
	sub_830C0D60(ctx, base);
	// 830C7860: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C7864: 4B3A9865  bl 0x824710c8
	ctx.lr = 0x830C7868;
	sub_824710C8(ctx, base);
	// 830C7868: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C786C: 4B20144D  bl 0x822c8cb8
	ctx.lr = 0x830C7870;
	sub_822C8CB8(ctx, base);
	// 830C7870: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 830C7874: 4B201445  bl 0x822c8cb8
	ctx.lr = 0x830C7878;
	sub_822C8CB8(ctx, base);
	// 830C7878: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 830C787C: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C7880: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C7884: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C7888: 396B6CA8  addi r11, r11, 0x6ca8
	ctx.r[11].s64 = ctx.r[11].s64 + 27816;
	// 830C788C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7890: 4B201429  bl 0x822c8cb8
	ctx.lr = 0x830C7894;
	sub_822C8CB8(ctx, base);
	// 830C7894: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C7898: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C789C: 4BFFFAE5  bl 0x830c7380
	ctx.lr = 0x830C78A0;
	sub_830C7380(ctx, base);
	// 830C78A0: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 830C78A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C78A8: 4B4C4669  bl 0x8258bf10
	ctx.lr = 0x830C78AC;
	sub_8258BF10(ctx, base);
	// 830C78AC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830C78B0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830C78B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C78B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C78BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C78C0: 4BFF94A1  bl 0x830c0d60
	ctx.lr = 0x830C78C4;
	sub_830C0D60(ctx, base);
	// 830C78C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830C78C8: 4B3A9801  bl 0x824710c8
	ctx.lr = 0x830C78CC;
	sub_824710C8(ctx, base);
	// 830C78CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830C78D0: 4B2013E9  bl 0x822c8cb8
	ctx.lr = 0x830C78D4;
	sub_822C8CB8(ctx, base);
	// 830C78D4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C78D8: 4B2013E1  bl 0x822c8cb8
	ctx.lr = 0x830C78DC;
	sub_822C8CB8(ctx, base);
	// 830C78DC: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 830C78E0: 4B1F9059  bl 0x822c0938
	ctx.lr = 0x830C78E4;
	sub_822C0938(ctx, base);
	// 830C78E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C78E8: 4182001C  beq 0x830c7904
	if ctx.cr[0].eq {
	pc = 0x830C7904; continue 'dispatch;
	}
	// 830C78EC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830C78F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C78F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C78F8: 48000C31  bl 0x830c8528
	ctx.lr = 0x830C78FC;
	sub_830C8528(ctx, base);
	// 830C78FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C7900: 48000008  b 0x830c7908
	pc = 0x830C7908; continue 'dispatch;
	// 830C7904: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C7908: 3BBF0078  addi r29, r31, 0x78
	ctx.r[29].s64 = ctx.r[31].s64 + 120;
	// 830C790C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7910: 4BFFBA61  bl 0x830c3370
	ctx.lr = 0x830C7914;
	sub_830C3370(ctx, base);
	// 830C7914: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C7918: 4B205709  bl 0x822cd020
	ctx.lr = 0x830C791C;
	sub_822CD020(ctx, base);
	// 830C791C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C7920: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830C7924: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 830C7928: 9BDF00E0  stb r30, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u8 ) };
	// 830C792C: 913F00F4  stw r9, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 830C7930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7934: C00A959C  lfs f0, -0x6a64(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7938: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 830C793C: 419A0018  beq cr6, 0x830c7954
	if ctx.cr[6].eq {
	pc = 0x830C7954; continue 'dispatch;
	}
	// 830C7940: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830C7944: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830C7948: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C794C: C00A89AC  lfs f0, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7950: D00B0074  stfs f0, 0x74(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C7954: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C7958: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C795C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C7960: 4B2014D1  bl 0x822c8e30
	ctx.lr = 0x830C7964;
	sub_822C8E30(ctx, base);
	// 830C7964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7968: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 830C796C: 480E0844  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C7970 size=104
    let mut pc: u32 = 0x830C7970;
    'dispatch: loop {
        match pc {
            0x830C7970 => {
    //   block [0x830C7970..0x830C79D8)
	// 830C7970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C7978: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C797C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C7984: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 830C7988: 4B205699  bl 0x822cd020
	ctx.lr = 0x830C798C;
	sub_822CD020(ctx, base);
	// 830C798C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830C7990: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830C7994: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830C7998: 4BD2A7F1  bl 0x82df2188
	ctx.lr = 0x830C799C;
	sub_82DF2188(ctx, base);
	// 830C799C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C79A0: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C79A4: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 830C79A8: 4B201311  bl 0x822c8cb8
	ctx.lr = 0x830C79AC;
	sub_822C8CB8(ctx, base);
	// 830C79AC: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830C79B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C79B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C79B8: 4B201479  bl 0x822c8e30
	ctx.lr = 0x830C79BC;
	sub_822C8E30(ctx, base);
	// 830C79BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C79C0: 4BFFC171  bl 0x830c3b30
	ctx.lr = 0x830C79C4;
	sub_830C3B30(ctx, base);
	// 830C79C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C79C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C79CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C79D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C79D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C79D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C79D8 size=76
    let mut pc: u32 = 0x830C79D8;
    'dispatch: loop {
        match pc {
            0x830C79D8 => {
    //   block [0x830C79D8..0x830C7A24)
	// 830C79D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C79DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C79E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C79E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C79E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C79EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C79F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C79F4: 4BFFFF7D  bl 0x830c7970
	ctx.lr = 0x830C79F8;
	sub_830C7970(ctx, base);
	// 830C79F8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C79FC: 4182000C  beq 0x830c7a08
	if ctx.cr[0].eq {
	pc = 0x830C7A08; continue 'dispatch;
	}
	// 830C7A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7A04: 4B1F8865  bl 0x822c0268
	ctx.lr = 0x830C7A08;
	sub_822C0268(ctx, base);
	// 830C7A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7A0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C7A10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C7A14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C7A18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C7A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C7A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7A28 size=184
    let mut pc: u32 = 0x830C7A28;
    'dispatch: loop {
        match pc {
            0x830C7A28 => {
    //   block [0x830C7A28..0x830C7AE0)
	// 830C7A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7A2C: 480E0741  bl 0x831a816c
	ctx.lr = 0x830C7A30;
	sub_831A8130(ctx, base);
	// 830C7A30: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830C7A34: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C7A3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C7A40: 897F00E0  lbz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830C7A44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C7A48: 40820088  bne 0x830c7ad0
	if !ctx.cr[0].eq {
	pc = 0x830C7AD0; continue 'dispatch;
	}
	// 830C7A4C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7A50: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830C7A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C7A58: 9BBF00E0  stb r29, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u8 ) };
	// 830C7A5C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7A60: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C7A64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7A68: 4E800421  bctrl
	ctx.lr = 0x830C7A6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7A6C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7A70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C7A74: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7A78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7A7C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7A80: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7A84: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C7A88: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C7A8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7A90: 4E800421  bctrl
	ctx.lr = 0x830C7A94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7A94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7A98: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7AA0: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7AA4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C7AA8: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C7AAC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C7AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7AB4: 4E800421  bctrl
	ctx.lr = 0x830C7AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7AB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C7ABC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C7AC0: 409A0010  bne cr6, 0x830c7ad0
	if !ctx.cr[6].eq {
	pc = 0x830C7AD0; continue 'dispatch;
	}
	// 830C7AC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C7AC8: 9BBF00E1  stb r29, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[29].u8 ) };
	// 830C7ACC: 48000008  b 0x830c7ad4
	pc = 0x830C7AD4; continue 'dispatch;
	// 830C7AD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C7AD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C7AD8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830C7ADC: 480E06E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C7AE0 size=4
    let mut pc: u32 = 0x830C7AE0;
    'dispatch: loop {
        match pc {
            0x830C7AE0 => {
    //   block [0x830C7AE0..0x830C7AE4)
	// 830C7AE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C7AE8 size=136
    let mut pc: u32 = 0x830C7AE8;
    'dispatch: loop {
        match pc {
            0x830C7AE8 => {
    //   block [0x830C7AE8..0x830C7B70)
	// 830C7AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C7AF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C7AF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C7AF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7AFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C7B00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C7B04: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830C7B08: 409A0020  bne cr6, 0x830c7b28
	if !ctx.cr[6].eq {
	pc = 0x830C7B28; continue 'dispatch;
	}
	// 830C7B0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830C7B10: 419A0048  beq cr6, 0x830c7b58
	if ctx.cr[6].eq {
	pc = 0x830C7B58; continue 'dispatch;
	}
	// 830C7B14: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7B18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C7B1C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C7B20: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C7B24: 48000034  b 0x830c7b58
	pc = 0x830C7B58; continue 'dispatch;
	// 830C7B28: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830C7B2C: 419A002C  beq cr6, 0x830c7b58
	if ctx.cr[6].eq {
	pc = 0x830C7B58; continue 'dispatch;
	}
	// 830C7B30: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C7B34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7B38: 388B4778  addi r4, r11, 0x4778
	ctx.r[4].s64 = ctx.r[11].s64 + 18296;
	// 830C7B3C: 480E05BD  bl 0x831a80f8
	ctx.lr = 0x830C7B40;
	sub_831A80F8(ctx, base);
	// 830C7B40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C7B44: 4182000C  beq 0x830c7b50
	if ctx.cr[0].eq {
	pc = 0x830C7B50; continue 'dispatch;
	}
	// 830C7B48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830C7B4C: 4800000C  b 0x830c7b58
	pc = 0x830C7B58; continue 'dispatch;
	// 830C7B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C7B54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C7B58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C7B5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C7B60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C7B64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C7B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C7B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C7B70 size=16
    let mut pc: u32 = 0x830C7B70;
    'dispatch: loop {
        match pc {
            0x830C7B70 => {
    //   block [0x830C7B70..0x830C7B80)
	// 830C7B70: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7B74: 816C0024  lwz r11, 0x24(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(36 as u32) ) } as u64;
	// 830C7B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7B7C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C7B80 size=16
    let mut pc: u32 = 0x830C7B80;
    'dispatch: loop {
        match pc {
            0x830C7B80 => {
    //   block [0x830C7B80..0x830C7B90)
	// 830C7B80: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7B84: 816C0028  lwz r11, 0x28(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C7B88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7B8C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C7B90 size=72
    let mut pc: u32 = 0x830C7B90;
    'dispatch: loop {
        match pc {
            0x830C7B90 => {
    //   block [0x830C7B90..0x830C7BD8)
	// 830C7B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C7B98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7B9C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 830C7BA0: 419A001C  beq cr6, 0x830c7bbc
	if ctx.cr[6].eq {
	pc = 0x830C7BBC; continue 'dispatch;
	}
	// 830C7BA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C7BA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C7BAC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830C7BB0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C7BB4: 4BFFFF35  bl 0x830c7ae8
	ctx.lr = 0x830C7BB8;
	sub_830C7AE8(ctx, base);
	// 830C7BB8: 48000010  b 0x830c7bc8
	pc = 0x830C7BC8; continue 'dispatch;
	// 830C7BBC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C7BC0: 396B4778  addi r11, r11, 0x4778
	ctx.r[11].s64 = ctx.r[11].s64 + 18296;
	// 830C7BC4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C7BC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C7BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C7BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C7BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7BD8 size=348
    let mut pc: u32 = 0x830C7BD8;
    'dispatch: loop {
        match pc {
            0x830C7BD8 => {
    //   block [0x830C7BD8..0x830C7D34)
	// 830C7BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7BDC: 480E058D  bl 0x831a8168
	ctx.lr = 0x830C7BE0;
	sub_831A8130(ctx, base);
	// 830C7BE0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830C7BE4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7BE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C7BEC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C7BF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C7BF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C7BF8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7BFC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C7C00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7C04: 4E800421  bctrl
	ctx.lr = 0x830C7C08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7C08: 809D0068  lwz r4, 0x68(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7C0C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C7C10: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7C14: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C7C18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7C1C: 4E800421  bctrl
	ctx.lr = 0x830C7C20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7C20: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7C24: C1A10080  lfs f13, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7C28: 807D0068  lwz r3, 0x68(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7C2C: C1810074  lfs f12, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C7C30: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C7C34: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C7C38: C141007C  lfs f10, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C7C3C: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C7C40: C1210078  lfs f9, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C7C44: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C7C48: EDA9682A  fadds f13, f9, f13
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C7C4C: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C7C50: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830C7C54: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830C7C58: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830C7C5C: 48001685  bl 0x830c92e0
	ctx.lr = 0x830C7C60;
	sub_830C92E0(ctx, base);
	// 830C7C60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C7C64: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C7C68: 409A0068  bne cr6, 0x830c7cd0
	if !ctx.cr[6].eq {
	pc = 0x830C7CD0; continue 'dispatch;
	}
	// 830C7C6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C7C70: 4B2010A9  bl 0x822c8d18
	ctx.lr = 0x830C7C74;
	sub_822C8D18(ctx, base);
	// 830C7C74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7C7C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 830C7C80: 409A0008  bne cr6, 0x830c7c88
	if !ctx.cr[6].eq {
	pc = 0x830C7C88; continue 'dispatch;
	}
	// 830C7C84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830C7C88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C7C8C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7C90: C3FC0000  lfs f31, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C7C94: 809D0068  lwz r4, 0x68(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7C98: 4BFFB439  bl 0x830c30d0
	ctx.lr = 0x830C7C9C;
	sub_830C30D0(ctx, base);
	// 830C7C9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830C7CA0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830C7CA4: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C7CA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C7CAC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830C7CB0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C7CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7CB8: C04BE830  lfs f2, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C7CBC: 39000011  li r8, 0x11
	ctx.r[8].s64 = 17;
	// 830C7CC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830C7CC4: 4E800421  bctrl
	ctx.lr = 0x830C7CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7CC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C7CCC: 4800004C  b 0x830c7d18
	pc = 0x830C7D18; continue 'dispatch;
	// 830C7CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7CD4: 4B201045  bl 0x822c8d18
	ctx.lr = 0x830C7CD8;
	sub_822C8D18(ctx, base);
	// 830C7CD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7CE0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C7CE4: 409A0008  bne cr6, 0x830c7cec
	if !ctx.cr[6].eq {
	pc = 0x830C7CEC; continue 'dispatch;
	}
	// 830C7CE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C7CEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830C7CF0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7CF4: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C7CF8: 38E00011  li r7, 0x11
	ctx.r[7].s64 = 17;
	// 830C7CFC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830C7D00: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C7D04: C04BE830  lfs f2, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C7D08: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 830C7D0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7D10: 4E800421  bctrl
	ctx.lr = 0x830C7D14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7D14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7D18: 4BD29F79  bl 0x82df1c90
	ctx.lr = 0x830C7D1C;
	sub_82DF1C90(ctx, base);
	// 830C7D1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C7D20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7D24: 4800034D  bl 0x830c8070
	ctx.lr = 0x830C7D28;
	sub_830C8070(ctx, base);
	// 830C7D28: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830C7D2C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830C7D30: 480E0488  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C7D38 size=128
    let mut pc: u32 = 0x830C7D38;
    'dispatch: loop {
        match pc {
            0x830C7D38 => {
    //   block [0x830C7D38..0x830C7DB8)
	// 830C7D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7D3C: 480E0431  bl 0x831a816c
	ctx.lr = 0x830C7D40;
	sub_831A8130(ctx, base);
	// 830C7D40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7D44: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830C7D48: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830C7D4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C7D50: 3BEBBDF8  addi r31, r11, -0x4208
	ctx.r[31].s64 = ctx.r[11].s64 + -16904;
	// 830C7D54: 816ABE00  lwz r11, -0x4200(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16896 as u32) ) } as u64;
	// 830C7D58: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C7D5C: 40820024  bne 0x830c7d80
	if !ctx.cr[0].eq {
	pc = 0x830C7D80; continue 'dispatch;
	}
	// 830C7D60: 3D2082E1  lis r9, -0x7d1f
	ctx.r[9].s64 = -2099183616;
	// 830C7D64: 3D00830C  lis r8, -0x7cf4
	ctx.r[8].s64 = -2096365568;
	// 830C7D68: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830C7D6C: 3929BD78  addi r9, r9, -0x4288
	ctx.r[9].s64 = ctx.r[9].s64 + -17032;
	// 830C7D70: 39087B90  addi r8, r8, 0x7b90
	ctx.r[8].s64 = ctx.r[8].s64 + 31632;
	// 830C7D74: 916ABE00  stw r11, -0x4200(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16896 as u32), ctx.r[11].u32 ) };
	// 830C7D78: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C7D7C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830C7D80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C7D84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830C7D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7D8C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830C7D90: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830C7D94: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C7D98: 4BD43959  bl 0x82e0b6f0
	ctx.lr = 0x830C7D9C;
	sub_82E0B6F0(ctx, base);
	// 830C7D9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C7DA0: 4182000C  beq 0x830c7dac
	if ctx.cr[0].eq {
	pc = 0x830C7DAC; continue 'dispatch;
	}
	// 830C7DA4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830C7DA8: 48000008  b 0x830c7db0
	pc = 0x830C7DB0; continue 'dispatch;
	// 830C7DAC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830C7DB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C7DB4: 480E0408  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7DB8 size=240
    let mut pc: u32 = 0x830C7DB8;
    'dispatch: loop {
        match pc {
            0x830C7DB8 => {
    //   block [0x830C7DB8..0x830C7EA8)
	// 830C7DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C7DC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C7DC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C7DC8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C7DCC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7DD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C7DD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C7DD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C7DDC: 897F00E1  lbz r11, 0xe1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(225 as u32) ) } as u64;
	// 830C7DE0: 995F00E0  stb r10, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[10].u8 ) };
	// 830C7DE4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C7DE8: 418200A0  beq 0x830c7e88
	if ctx.cr[0].eq {
	pc = 0x830C7E88; continue 'dispatch;
	}
	// 830C7DEC: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C7DF4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7DF8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C7DFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7E00: 4E800421  bctrl
	ctx.lr = 0x830C7E04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7E04: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C7E08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C7E0C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7E10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7E14: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7E18: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7E1C: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C7E20: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C7E24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7E28: 4E800421  bctrl
	ctx.lr = 0x830C7E2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7E2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C7E30: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7E38: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7E3C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830C7E40: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C7E44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C7E48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C7E4C: 4E800421  bctrl
	ctx.lr = 0x830C7E50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C7E50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C7E54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C7E58: 409A0030  bne cr6, 0x830c7e88
	if !ctx.cr[6].eq {
	pc = 0x830C7E88; continue 'dispatch;
	}
	// 830C7E5C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C7E60: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C7E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7E68: 419A0020  beq cr6, 0x830c7e88
	if ctx.cr[6].eq {
	pc = 0x830C7E88; continue 'dispatch;
	}
	// 830C7E6C: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C7E70: 396B7AE0  addi r11, r11, 0x7ae0
	ctx.r[11].s64 = ctx.r[11].s64 + 31456;
	// 830C7E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C7E78: 419A0010  beq cr6, 0x830c7e88
	if ctx.cr[6].eq {
	pc = 0x830C7E88; continue 'dispatch;
	}
	// 830C7E7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C7E80: 4BFF8849  bl 0x830c06c8
	ctx.lr = 0x830C7E84;
	sub_830C06C8(ctx, base);
	// 830C7E84: 48000008  b 0x830c7e8c
	pc = 0x830C7E8C; continue 'dispatch;
	// 830C7E88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C7E8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C7E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C7E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C7E98: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C7E9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C7EA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C7EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C7EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C7EA8 size=352
    let mut pc: u32 = 0x830C7EA8;
    'dispatch: loop {
        match pc {
            0x830C7EA8 => {
    //   block [0x830C7EA8..0x830C8008)
	// 830C7EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C7EAC: 480E02B9  bl 0x831a8164
	ctx.lr = 0x830C7EB0;
	sub_831A8130(ctx, base);
	// 830C7EB0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C7EB4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830C7EB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C7EBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C7EC0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830C7EC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7EC8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830C7ECC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830C7ED0: 4B201F89  bl 0x822c9e58
	ctx.lr = 0x830C7ED4;
	sub_822C9E58(ctx, base);
	// 830C7ED4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830C7ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C7EDC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830C7EE0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C7EE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C7EE8: 48000281  bl 0x830c8168
	ctx.lr = 0x830C7EEC;
	sub_830C8168(ctx, base);
	// 830C7EEC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C7EF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C7EF4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C7EF8: 396B78BC  addi r11, r11, 0x78bc
	ctx.r[11].s64 = ctx.r[11].s64 + 30908;
	// 830C7EFC: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830C7F00: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830C7F04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C7F08: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C7F0C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830C7F10: 396A7B80  addi r11, r10, 0x7b80
	ctx.r[11].s64 = ctx.r[10].s64 + 31616;
	// 830C7F14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7F18: 4B200DA1  bl 0x822c8cb8
	ctx.lr = 0x830C7F1C;
	sub_822C8CB8(ctx, base);
	// 830C7F1C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C7F20: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C7F24: 4BFFFE15  bl 0x830c7d38
	ctx.lr = 0x830C7F28;
	sub_830C7D38(ctx, base);
	// 830C7F28: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830C7F2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7F30: 4B4C3FE1  bl 0x8258bf10
	ctx.lr = 0x830C7F34;
	sub_8258BF10(ctx, base);
	// 830C7F34: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830C7F38: 3BBF006C  addi r29, r31, 0x6c
	ctx.r[29].s64 = ctx.r[31].s64 + 108;
	// 830C7F3C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7F40: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C7F44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7F48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C7F4C: 4BFF8E15  bl 0x830c0d60
	ctx.lr = 0x830C7F50;
	sub_830C0D60(ctx, base);
	// 830C7F50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C7F54: 4B3A9175  bl 0x824710c8
	ctx.lr = 0x830C7F58;
	sub_824710C8(ctx, base);
	// 830C7F58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C7F5C: 4B200D5D  bl 0x822c8cb8
	ctx.lr = 0x830C7F60;
	sub_822C8CB8(ctx, base);
	// 830C7F60: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830C7F64: 4B200D55  bl 0x822c8cb8
	ctx.lr = 0x830C7F68;
	sub_822C8CB8(ctx, base);
	// 830C7F68: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 830C7F6C: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830C7F70: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830C7F74: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C7F78: 396B7B70  addi r11, r11, 0x7b70
	ctx.r[11].s64 = ctx.r[11].s64 + 31600;
	// 830C7F7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7F80: 4B200D39  bl 0x822c8cb8
	ctx.lr = 0x830C7F84;
	sub_822C8CB8(ctx, base);
	// 830C7F84: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C7F88: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C7F8C: 4BFFFDAD  bl 0x830c7d38
	ctx.lr = 0x830C7F90;
	sub_830C7D38(ctx, base);
	// 830C7F90: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830C7F94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C7F98: 4B4C3F79  bl 0x8258bf10
	ctx.lr = 0x830C7F9C;
	sub_8258BF10(ctx, base);
	// 830C7F9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C7FA0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830C7FA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C7FA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C7FAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C7FB0: 4BFF8DB1  bl 0x830c0d60
	ctx.lr = 0x830C7FB4;
	sub_830C0D60(ctx, base);
	// 830C7FB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C7FB8: 4B3A9111  bl 0x824710c8
	ctx.lr = 0x830C7FBC;
	sub_824710C8(ctx, base);
	// 830C7FBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C7FC0: 4B200CF9  bl 0x822c8cb8
	ctx.lr = 0x830C7FC4;
	sub_822C8CB8(ctx, base);
	// 830C7FC4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830C7FC8: 4B200CF1  bl 0x822c8cb8
	ctx.lr = 0x830C7FCC;
	sub_822C8CB8(ctx, base);
	// 830C7FCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830C7FD0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C7FD4: 9BDF00E0  stb r30, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u8 ) };
	// 830C7FD8: 9BDF00E1  stb r30, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[30].u8 ) };
	// 830C7FDC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C7FE0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C7FE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C7FE8: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C7FEC: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C7FF0: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830C7FF4: D1BF00B0  stfs f13, 0xb0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830C7FF8: 4B200E39  bl 0x822c8e30
	ctx.lr = 0x830C7FFC;
	sub_822C8E30(ctx, base);
	// 830C7FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8000: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830C8004: 480E01B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C8008 size=104
    let mut pc: u32 = 0x830C8008;
    'dispatch: loop {
        match pc {
            0x830C8008 => {
    //   block [0x830C8008..0x830C8070)
	// 830C8008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C800C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C8010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C8014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C8018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C801C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C8020: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C8024: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 830C8028: 4B200C91  bl 0x822c8cb8
	ctx.lr = 0x830C802C;
	sub_822C8CB8(ctx, base);
	// 830C802C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830C8030: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C8034: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C8038: 4B200DF9  bl 0x822c8e30
	ctx.lr = 0x830C803C;
	sub_822C8E30(ctx, base);
	// 830C803C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8040: 4BFFBAF1  bl 0x830c3b30
	ctx.lr = 0x830C8044;
	sub_830C3B30(ctx, base);
	// 830C8044: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C8048: 4182000C  beq 0x830c8054
	if ctx.cr[0].eq {
	pc = 0x830C8054; continue 'dispatch;
	}
	// 830C804C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8050: 4B1F8219  bl 0x822c0268
	ctx.lr = 0x830C8054;
	sub_822C0268(ctx, base);
	// 830C8054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8058: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C805C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C8060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C8064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C8068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C806C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C8070 size=244
    let mut pc: u32 = 0x830C8070;
    'dispatch: loop {
        match pc {
            0x830C8070 => {
    //   block [0x830C8070..0x830C8164)
	// 830C8070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C8074: 480E00F9  bl 0x831a816c
	ctx.lr = 0x830C8078;
	sub_831A8130(ctx, base);
	// 830C8078: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C807C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C8080: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830C8084: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C8088: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C808C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8090: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8094: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8098: 4E800421  bctrl
	ctx.lr = 0x830C809C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C809C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C80A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C80A4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C80A8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C80AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C80B0: 4E800421  bctrl
	ctx.lr = 0x830C80B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C80B4: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830C80B8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C80BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C80C0: 48001221  bl 0x830c92e0
	ctx.lr = 0x830C80C4;
	sub_830C92E0(ctx, base);
	// 830C80C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C80C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C80CC: 409A0010  bne cr6, 0x830c80dc
	if !ctx.cr[6].eq {
	pc = 0x830C80DC; continue 'dispatch;
	}
	// 830C80D0: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C80D4: 4BDB04AD  bl 0x82e78580
	ctx.lr = 0x830C80D8;
	sub_82E78580(ctx, base);
	// 830C80D8: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 830C80DC: 815F00A8  lwz r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830C80E0: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	// 830C80E4: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 830C80E8: 4198000C  blt cr6, 0x830c80f4
	if ctx.cr[6].lt {
	pc = 0x830C80F4; continue 'dispatch;
	}
	// 830C80EC: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C80F0: 48000008  b 0x830c80f8
	pc = 0x830C80F8; continue 'dispatch;
	// 830C80F4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 830C80F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C80FC: 4B200C1D  bl 0x822c8d18
	ctx.lr = 0x830C8100;
	sub_822C8D18(ctx, base);
	// 830C8100: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8108: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C810C: 409A0008  bne cr6, 0x830c8114
	if !ctx.cr[6].eq {
	pc = 0x830C8114; continue 'dispatch;
	}
	// 830C8110: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8114: C1810074  lfs f12, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8118: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830C811C: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C8120: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830C8124: C01F00B0  lfs f0, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8128: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830C812C: C1BF00AC  lfs f13, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8130: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8134: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 830C8138: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C813C: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C8140: 80FF00B4  lwz r7, 0xb4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 830C8144: C07D0000  lfs f3, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830C8148: EC40602A  fadds f2, f0, f12
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C814C: EC2D582A  fadds f1, f13, f11
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 830C8150: 4BFF78E9  bl 0x830bfa38
	ctx.lr = 0x830C8154;
	sub_830BFA38(ctx, base);
	// 830C8154: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830C8158: 4BD29B39  bl 0x82df1c90
	ctx.lr = 0x830C815C;
	sub_82DF1C90(ctx, base);
	// 830C815C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C8160: 480E005C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C8168 size=156
    let mut pc: u32 = 0x830C8168;
    'dispatch: loop {
        match pc {
            0x830C8168 => {
    //   block [0x830C8168..0x830C8204)
	// 830C8168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C816C: 480E0001  bl 0x831a816c
	ctx.lr = 0x830C8170;
	sub_831A8130(ctx, base);
	// 830C8170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C8174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C8178: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830C817C: 4BFFB91D  bl 0x830c3a98
	ctx.lr = 0x830C8180;
	sub_830C3A98(ctx, base);
	// 830C8180: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C8184: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 830C8188: 396B78E8  addi r11, r11, 0x78e8
	ctx.r[11].s64 = ctx.r[11].s64 + 30952;
	// 830C818C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C8190: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C8194: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C8198: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C819C: 4B200C95  bl 0x822c8e30
	ctx.lr = 0x830C81A0;
	sub_822C8E30(ctx, base);
	// 830C81A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C81A4: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 830C81A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C81AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C81B0: 4B200F81  bl 0x822c9130
	ctx.lr = 0x830C81B4;
	sub_822C9130(ctx, base);
	// 830C81B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C81B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C81BC: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 830C81C0: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 830C81C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C81C8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 830C81CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C81D0: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C81D4: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 830C81D8: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 830C81DC: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830C81E0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C81E4: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830C81E8: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 830C81EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C81F0: 915F00B8  stw r10, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 830C81F4: 4B200C3D  bl 0x822c8e30
	ctx.lr = 0x830C81F8;
	sub_822C8E30(ctx, base);
	// 830C81F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C81FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C8200: 480DFFBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C8208 size=96
    let mut pc: u32 = 0x830C8208;
    'dispatch: loop {
        match pc {
            0x830C8208 => {
    //   block [0x830C8208..0x830C8268)
	// 830C8208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C820C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C8210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C8214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C8218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C821C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C8220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C8224: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830C8228: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C822C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C8230: 4B200C01  bl 0x822c8e30
	ctx.lr = 0x830C8234;
	sub_822C8E30(ctx, base);
	// 830C8234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8238: 4BFFB8F9  bl 0x830c3b30
	ctx.lr = 0x830C823C;
	sub_830C3B30(ctx, base);
	// 830C823C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C8240: 4182000C  beq 0x830c824c
	if ctx.cr[0].eq {
	pc = 0x830C824C; continue 'dispatch;
	}
	// 830C8244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8248: 4B1F8021  bl 0x822c0268
	ctx.lr = 0x830C824C;
	sub_822C0268(ctx, base);
	// 830C824C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C8250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C8254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C8258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C825C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C8260: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C8264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C8268 size=56
    let mut pc: u32 = 0x830C8268;
    'dispatch: loop {
        match pc {
            0x830C8268 => {
    //   block [0x830C8268..0x830C82A0)
	// 830C8268: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C826C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830C8270: 396B4830  addi r11, r11, 0x4830
	ctx.r[11].s64 = ctx.r[11].s64 + 18480;
	// 830C8274: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 830C8278: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830C827C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8280: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830C8284: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8288: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830C828C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8290: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830C8294: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8298: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830C829C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C82A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C82A0 size=364
    let mut pc: u32 = 0x830C82A0;
    'dispatch: loop {
        match pc {
            0x830C82A0 => {
    //   block [0x830C82A0..0x830C840C)
	// 830C82A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C82A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C82A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C82AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C82B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C82B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C82B8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C82BC: D03F0020  stfs f1, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830C82C0: D05F0024  stfs f2, 0x24(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830C82C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C82C8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C82CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C82D0: 4E800421  bctrl
	ctx.lr = 0x830C82D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C82D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C82D8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C82DC: 895F0088  lbz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830C82E0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 830C82E4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C82E8: C12B08A8  lfs f9, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C82EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C82F0: C1499524  lfs f10, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C82F4: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 830C82F8: C168A1C4  lfs f11, -0x5e3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C82FC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8300: 409A0070  bne cr6, 0x830c8370
	if !ctx.cr[6].eq {
	pc = 0x830C8370; continue 'dispatch;
	}
	// 830C8304: 893F0089  lbz r9, 0x89(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C8308: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C830C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 830C8310: 409A000C  bne cr6, 0x830c831c
	if !ctx.cr[6].eq {
	pc = 0x830C831C; continue 'dispatch;
	}
	// 830C8314: EDA002F2  fmuls f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 830C8318: 4800000C  b 0x830c8324
	pc = 0x830C8324; continue 'dispatch;
	// 830C831C: EDA002B2  fmuls f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 830C8320: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C8324: C0E10054  lfs f7, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830C8328: C101005C  lfs f8, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830C832C: ED083828  fsubs f8, f8, f7
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 830C8330: C0FF0024  lfs f7, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830C8334: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C8338: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C833C: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 830C8340: 40980008  bge cr6, 0x830c8348
	if !ctx.cr[6].lt {
	pc = 0x830C8348; continue 'dispatch;
	}
	// 830C8344: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830C8348: C11F0024  lfs f8, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830C834C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830C8350: ED094024  fdivs f8, f9, f8
	ctx.f[8].f64 = ((ctx.f[9].f64 / ctx.f[8].f64) as f32) as f64;
	// 830C8354: EC000232  fmuls f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 830C8358: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830C835C: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 830C8360: D11F0064  stfs f8, 0x64(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830C8364: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C8368: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830C836C: 48000010  b 0x830c837c
	pc = 0x830C837C; continue 'dispatch;
	// 830C8370: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830C8374: D19F0054  stfs f12, 0x54(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830C8378: D19F0064  stfs f12, 0x64(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830C837C: 897F0089  lbz r11, 0x89(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C8380: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8384: 409A0068  bne cr6, 0x830c83ec
	if !ctx.cr[6].eq {
	pc = 0x830C83EC; continue 'dispatch;
	}
	// 830C8388: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C838C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C8390: 409A000C  bne cr6, 0x830c839c
	if !ctx.cr[6].eq {
	pc = 0x830C839C; continue 'dispatch;
	}
	// 830C8394: EDA002F2  fmuls f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 830C8398: 4800000C  b 0x830c83a4
	pc = 0x830C83A4; continue 'dispatch;
	// 830C839C: EDA002B2  fmuls f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 830C83A0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C83A4: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C83A8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C83AC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C83B0: C17F0020  lfs f11, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C83B4: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C83B8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C83BC: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 830C83C0: 40980008  bge cr6, 0x830c83c8
	if !ctx.cr[6].lt {
	pc = 0x830C83C8; continue 'dispatch;
	}
	// 830C83C4: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830C83C8: C19F0020  lfs f12, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C83CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830C83D0: ED896024  fdivs f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 / ctx.f[12].f64) as f32) as f64;
	// 830C83D4: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C83D8: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830C83DC: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 830C83E0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C83E4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830C83E8: 4800000C  b 0x830c83f4
	pc = 0x830C83F4; continue 'dispatch;
	// 830C83EC: D19F0040  stfs f12, 0x40(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830C83F0: D19F0050  stfs f12, 0x50(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830C83F4: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830C83F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C83FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C8400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C8404: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C8408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C8410 size=88
    let mut pc: u32 = 0x830C8410;
    'dispatch: loop {
        match pc {
            0x830C8410 => {
    //   block [0x830C8410..0x830C8468)
	// 830C8410: 8963007C  lbz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 830C8414: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8418: 409A0094  bne cr6, 0x830c84ac
	if !ctx.cr[6].eq {
		sub_830C84AC(ctx, base);
		return;
	}
	// 830C841C: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8420: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8424: 41820044  beq 0x830c8468
	if ctx.cr[0].eq {
		sub_830C8468(ctx, base);
		return;
	}
	// 830C8428: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C842C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C8430: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8434: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8438: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C843C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8440: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8444: 40980008  bge cr6, 0x830c844c
	if !ctx.cr[6].lt {
	pc = 0x830C844C; continue 'dispatch;
	}
	// 830C8448: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C844C: C0030054  lfs f0, 0x54(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8450: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8454: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8458: 40990008  ble cr6, 0x830c8460
	if !ctx.cr[6].gt {
	pc = 0x830C8460; continue 'dispatch;
	}
	// 830C845C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C8460: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C8464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C8468 size=68
    let mut pc: u32 = 0x830C8468;
    'dispatch: loop {
        match pc {
            0x830C8468 => {
    //   block [0x830C8468..0x830C84AC)
	// 830C8468: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C846C: 41820040  beq 0x830c84ac
	if ctx.cr[0].eq {
		sub_830C84AC(ctx, base);
		return;
	}
	// 830C8470: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8474: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C8478: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C847C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8480: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C8484: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8488: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C848C: 40980008  bge cr6, 0x830c8494
	if !ctx.cr[6].lt {
	pc = 0x830C8494; continue 'dispatch;
	}
	// 830C8490: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C8494: C0030050  lfs f0, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8498: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C849C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C84A0: 4099FFC0  ble cr6, 0x830c8460
	if !ctx.cr[6].gt {
		sub_830C8410(ctx, base);
		return;
	}
	// 830C84A4: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C84A8: 4BFFFFB8  b 0x830c8460
	sub_830C8410(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C84AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C84AC size=8
    let mut pc: u32 = 0x830C84AC;
    'dispatch: loop {
        match pc {
            0x830C84AC => {
    //   block [0x830C84AC..0x830C84B4)
	// 830C84AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C84B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C84B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C84B8 size=60
    let mut pc: u32 = 0x830C84B8;
    'dispatch: loop {
        match pc {
            0x830C84B8 => {
    //   block [0x830C84B8..0x830C84F4)
	// 830C84B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C84BC: C1A4000C  lfs f13, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C84C0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C84C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C84C8: 4099002C  ble cr6, 0x830c84f4
	if !ctx.cr[6].gt {
		sub_830C84F4(ctx, base);
		return;
	}
	// 830C84CC: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C84D0: C1830070  lfs f12, 0x70(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C84D4: C1630064  lfs f11, 0x64(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C84D8: EDAC6AFC  fnmsubs f13, f12, f11, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C84DC: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C84E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C84E4: 40980008  bge cr6, 0x830c84ec
	if !ctx.cr[6].lt {
	pc = 0x830C84EC; continue 'dispatch;
	}
	// 830C84E8: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C84EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C84F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C84F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C84F4 size=44
    let mut pc: u32 = 0x830C84F4;
    'dispatch: loop {
        match pc {
            0x830C84F4 => {
    //   block [0x830C84F4..0x830C8520)
	// 830C84F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C84F8: 40980028  bge cr6, 0x830c8520
	if !ctx.cr[6].lt {
		sub_830C8520(ctx, base);
		return;
	}
	// 830C84FC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8500: C1A30070  lfs f13, 0x70(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8504: C1830064  lfs f12, 0x64(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8508: EDAD033A  fmadds f13, f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830C850C: C0030054  lfs f0, 0x54(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8510: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C8514: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8518: 4099FFD4  ble cr6, 0x830c84ec
	if !ctx.cr[6].gt {
		sub_830C84B8(ctx, base);
		return;
	}
	// 830C851C: 4BFFFFCC  b 0x830c84e8
	sub_830C84B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C8520 size=8
    let mut pc: u32 = 0x830C8520;
    'dispatch: loop {
        match pc {
            0x830C8520 => {
    //   block [0x830C8520..0x830C8528)
	// 830C8520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C8528 size=184
    let mut pc: u32 = 0x830C8528;
    'dispatch: loop {
        match pc {
            0x830C8528 => {
    //   block [0x830C8528..0x830C85E0)
	// 830C8528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C852C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C8530: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C8534: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C8538: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C853C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830C8540: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830C8544: 3D008218  lis r8, -0x7de8
	ctx.r[8].s64 = -2112356352;
	// 830C8548: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 830C854C: 98DF0088  stb r6, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[6].u8 ) };
	// 830C8550: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 830C8554: C1AA9590  lfs f13, -0x6a70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8558: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C855C: 3948790C  addi r10, r8, 0x790c
	ctx.r[10].s64 = ctx.r[8].s64 + 30988;
	// 830C8560: C00989AC  lfs f0, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8564: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830C8568: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 830C856C: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830C8570: 98BF0089  stb r5, 0x89(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(137 as u32), ctx.r[5].u8 ) };
	// 830C8574: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830C8578: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 830C857C: C00708A4  lfs f0, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8580: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C8584: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830C8588: C1A608A8  lfs f13, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C858C: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830C8590: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830C8594: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830C8598: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 830C859C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830C85A0: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830C85A4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830C85A8: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830C85AC: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830C85B0: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830C85B4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830C85B8: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830C85BC: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830C85C0: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830C85C4: 4BDB4DAD  bl 0x82e7d370
	ctx.lr = 0x830C85C8;
	sub_82E7D370(ctx, base);
	// 830C85C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C85CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830C85D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C85D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C85D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C85DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C85E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C85E0 size=744
    let mut pc: u32 = 0x830C85E0;
    'dispatch: loop {
        match pc {
            0x830C85E0 => {
    //   block [0x830C85E0..0x830C88C8)
	// 830C85E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C85E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C85E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C85EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C85F0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 830C85F4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830C85F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C85FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C8600: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830C8604: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C8608: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 830C860C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C8610: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8614: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8618: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C861C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8620: 4E800421  bctrl
	ctx.lr = 0x830C8624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8624: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8628: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830C862C: 808B0068  lwz r4, 0x68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C8630: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8634: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C8638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C863C: 4E800421  bctrl
	ctx.lr = 0x830C8640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8640: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C8644: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C8648: C0A1005C  lfs f5, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 830C864C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C8650: C0810058  lfs f4, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830C8654: C0E10064  lfs f7, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830C8658: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C865C: C0C10060  lfs f6, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 830C8660: C06A08A8  lfs f3, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830C8664: C1499524  lfs f10, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C8668: 897F0088  lbz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830C866C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8670: 409A0128  bne cr6, 0x830c8798
	if !ctx.cr[6].eq {
	pc = 0x830C8798; continue 'dispatch;
	}
	// 830C8674: EDA4302A  fadds f13, f4, f6
	ctx.f[13].f64 = ((ctx.f[4].f64 + ctx.f[6].f64) as f32) as f64;
	// 830C8678: 895F0089  lbz r10, 0x89(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C867C: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8680: ED05382A  fadds f8, f5, f7
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[7].f64) as f32) as f64;
	// 830C8684: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8688: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C868C: ED8C382A  fadds f12, f12, f7
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 830C8690: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C8694: 409A000C  bne cr6, 0x830c86a0
	if !ctx.cr[6].eq {
	pc = 0x830C86A0; continue 'dispatch;
	}
	// 830C8698: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 830C869C: 48000008  b 0x830c86a4
	pc = 0x830C86A4; continue 'dispatch;
	// 830C86A0: FD201890  fmr f9, f3
	ctx.f[9].f64 = ctx.f[3].f64;
	// 830C86A4: FF1E5800  fcmpu cr6, f30, f11
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[11].f64);
	// 830C86A8: 409900F0  ble cr6, 0x830c8798
	if !ctx.cr[6].gt {
	pc = 0x830C8798; continue 'dispatch;
	}
	// 830C86AC: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 830C86B0: 409800E8  bge cr6, 0x830c8798
	if !ctx.cr[6].lt {
	pc = 0x830C8798; continue 'dispatch;
	}
	// 830C86B4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 830C86B8: 40980020  bge cr6, 0x830c86d8
	if !ctx.cr[6].lt {
	pc = 0x830C86D8; continue 'dispatch;
	}
	// 830C86BC: EDA0602A  fadds f13, f0, f12
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C86C0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C86C4: 40990014  ble cr6, 0x830c86d8
	if !ctx.cr[6].gt {
	pc = 0x830C86D8; continue 'dispatch;
	}
	// 830C86C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C86CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C86D0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C86D4: 480001D4  b 0x830c88a8
	pc = 0x830C88A8; continue 'dispatch;
	// 830C86D8: ED600272  fmuls f11, f0, f9
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 830C86DC: EDA85828  fsubs f13, f8, f11
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C86E0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C86E4: 4098001C  bge cr6, 0x830c8700
	if !ctx.cr[6].lt {
	pc = 0x830C8700; continue 'dispatch;
	}
	// 830C86E8: EDA91828  fsubs f13, f9, f3
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[3].f64) as f32) as f64);
	// 830C86EC: EDAD403C  fnmsubs f13, f13, f0, f8
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 830C86F0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C86F4: 4099000C  ble cr6, 0x830c8700
	if !ctx.cr[6].gt {
	pc = 0x830C8700; continue 'dispatch;
	}
	// 830C86F8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830C86FC: 4BFFFFD0  b 0x830c86cc
	pc = 0x830C86CC; continue 'dispatch;
	// 830C8700: EDA0602A  fadds f13, f0, f12
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8704: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C8708: 40980030  bge cr6, 0x830c8738
	if !ctx.cr[6].lt {
	pc = 0x830C8738; continue 'dispatch;
	}
	// 830C870C: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8710: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8714: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8718: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830C871C: 4099001C  ble cr6, 0x830c8738
	if !ctx.cr[6].gt {
	pc = 0x830C8738; continue 'dispatch;
	}
	// 830C8720: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 830C8724: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 830C8728: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C872C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C8730: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 830C8734: 48000174  b 0x830c88a8
	pc = 0x830C88A8; continue 'dispatch;
	// 830C8738: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C873C: ED2D002A  fadds f9, f13, f0
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8740: ED29602A  fadds f9, f9, f12
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8744: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 830C8748: 40980024  bge cr6, 0x830c876c
	if !ctx.cr[6].lt {
	pc = 0x830C876C; continue 'dispatch;
	}
	// 830C874C: C13F0044  lfs f9, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C8750: ED29682A  fadds f9, f9, f13
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8754: ED29002A  fadds f9, f9, f0
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8758: ED29602A  fadds f9, f9, f12
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C875C: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 830C8760: 4099000C  ble cr6, 0x830c876c
	if !ctx.cr[6].gt {
	pc = 0x830C876C; continue 'dispatch;
	}
	// 830C8764: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 830C8768: 4BFFFF64  b 0x830c86cc
	pc = 0x830C86CC; continue 'dispatch;
	// 830C876C: C13F0044  lfs f9, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C8770: EDA9682A  fadds f13, f9, f13
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8774: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8778: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C877C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830C8780: 40980018  bge cr6, 0x830c8798
	if !ctx.cr[6].lt {
	pc = 0x830C8798; continue 'dispatch;
	}
	// 830C8784: EC085828  fsubs f0, f8, f11
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C8788: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830C878C: 4099000C  ble cr6, 0x830c8798
	if !ctx.cr[6].gt {
	pc = 0x830C8798; continue 'dispatch;
	}
	// 830C8790: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 830C8794: 4BFFFF90  b 0x830c8724
	pc = 0x830C8724; continue 'dispatch;
	// 830C8798: 895F0089  lbz r10, 0x89(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C879C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C87A0: 409A0104  bne cr6, 0x830c88a4
	if !ctx.cr[6].eq {
	pc = 0x830C88A4; continue 'dispatch;
	}
	// 830C87A4: EDA5382A  fadds f13, f5, f7
	ctx.f[13].f64 = ((ctx.f[5].f64 + ctx.f[7].f64) as f32) as f64;
	// 830C87A8: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C87AC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C87B0: ED24302A  fadds f9, f4, f6
	ctx.f[9].f64 = ((ctx.f[4].f64 + ctx.f[6].f64) as f32) as f64;
	// 830C87B4: ED8C302A  fadds f12, f12, f6
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 830C87B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C87BC: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C87C0: 419A0008  beq cr6, 0x830c87c8
	if ctx.cr[6].eq {
	pc = 0x830C87C8; continue 'dispatch;
	}
	// 830C87C4: FD401890  fmr f10, f3
	ctx.f[10].f64 = ctx.f[3].f64;
	// 830C87C8: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 830C87CC: 409900D8  ble cr6, 0x830c88a4
	if !ctx.cr[6].gt {
	pc = 0x830C88A4; continue 'dispatch;
	}
	// 830C87D0: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 830C87D4: 409800D0  bge cr6, 0x830c88a4
	if !ctx.cr[6].lt {
	pc = 0x830C88A4; continue 'dispatch;
	}
	// 830C87D8: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 830C87DC: 40980018  bge cr6, 0x830c87f4
	if !ctx.cr[6].lt {
	pc = 0x830C87F4; continue 'dispatch;
	}
	// 830C87E0: EDA0602A  fadds f13, f0, f12
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C87E4: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830C87E8: 4099000C  ble cr6, 0x830c87f4
	if !ctx.cr[6].gt {
	pc = 0x830C87F4; continue 'dispatch;
	}
	// 830C87EC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830C87F0: 4BFFFEDC  b 0x830c86cc
	pc = 0x830C86CC; continue 'dispatch;
	// 830C87F4: ED6002B2  fmuls f11, f0, f10
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 830C87F8: EDA95828  fsubs f13, f9, f11
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C87FC: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830C8800: 4098001C  bge cr6, 0x830c881c
	if !ctx.cr[6].lt {
	pc = 0x830C881C; continue 'dispatch;
	}
	// 830C8804: EDAA1828  fsubs f13, f10, f3
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[3].f64) as f32) as f64);
	// 830C8808: EDAD483C  fnmsubs f13, f13, f0, f9
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 830C880C: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830C8810: 4099000C  ble cr6, 0x830c881c
	if !ctx.cr[6].gt {
	pc = 0x830C881C; continue 'dispatch;
	}
	// 830C8814: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 830C8818: 4BFFFEB4  b 0x830c86cc
	pc = 0x830C86CC; continue 'dispatch;
	// 830C881C: EDA0602A  fadds f13, f0, f12
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8820: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830C8824: 40980020  bge cr6, 0x830c8844
	if !ctx.cr[6].lt {
	pc = 0x830C8844; continue 'dispatch;
	}
	// 830C8828: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C882C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8830: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8834: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830C8838: 4099000C  ble cr6, 0x830c8844
	if !ctx.cr[6].gt {
	pc = 0x830C8844; continue 'dispatch;
	}
	// 830C883C: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 830C8840: 4BFFFEE4  b 0x830c8724
	pc = 0x830C8724; continue 'dispatch;
	// 830C8844: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8848: ED4D002A  fadds f10, f13, f0
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C884C: ED4A602A  fadds f10, f10, f12
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8850: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 830C8854: 40980024  bge cr6, 0x830c8878
	if !ctx.cr[6].lt {
	pc = 0x830C8878; continue 'dispatch;
	}
	// 830C8858: C15F0040  lfs f10, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C885C: ED4A682A  fadds f10, f10, f13
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8860: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8864: ED4A602A  fadds f10, f10, f12
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8868: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 830C886C: 4099000C  ble cr6, 0x830c8878
	if !ctx.cr[6].gt {
	pc = 0x830C8878; continue 'dispatch;
	}
	// 830C8870: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830C8874: 4BFFFE58  b 0x830c86cc
	pc = 0x830C86CC; continue 'dispatch;
	// 830C8878: C15F0040  lfs f10, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C887C: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8880: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8884: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8888: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830C888C: 40980018  bge cr6, 0x830c88a4
	if !ctx.cr[6].lt {
	pc = 0x830C88A4; continue 'dispatch;
	}
	// 830C8890: EC095828  fsubs f0, f9, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C8894: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830C8898: 4099000C  ble cr6, 0x830c88a4
	if !ctx.cr[6].gt {
	pc = 0x830C88A4; continue 'dispatch;
	}
	// 830C889C: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 830C88A0: 4BFFFE84  b 0x830c8724
	pc = 0x830C8724; continue 'dispatch;
	// 830C88A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C88A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C88AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C88B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C88B4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830C88B8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830C88BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C88C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C88C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C88C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C88C8 size=72
    let mut pc: u32 = 0x830C88C8;
    'dispatch: loop {
        match pc {
            0x830C88C8 => {
    //   block [0x830C88C8..0x830C8910)
	// 830C88C8: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C88CC: 89440089  lbz r10, 0x89(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C88D0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830C88D4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830C88D8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C88DC: C9AB7920  lfd f13, 0x7920(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31008 as u32) ) };
	// 830C88E0: C18908A8  lfs f12, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C88E4: C16808A4  lfs f11, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C88E8: 41820028  beq 0x830c8910
	if ctx.cr[0].eq {
		sub_830C8910(ctx, base);
		return;
	}
	// 830C88EC: C0040060  lfs f0, 0x60(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C88F0: FD400210  fabs f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830C88F4: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 830C88F8: 41980018  blt cr6, 0x830c8910
	if ctx.cr[6].lt {
		sub_830C8910(ctx, base);
		return;
	}
	// 830C88FC: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C8900: C1440030  lfs f10, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C8904: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 830C8908: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C890C: 48000008  b 0x830c8914
	sub_830C8910(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C8910 size=52
    let mut pc: u32 = 0x830C8910;
    'dispatch: loop {
        match pc {
            0x830C8910 => {
    //   block [0x830C8910..0x830C8944)
	// 830C8910: D1630000  stfs f11, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C8914: 89640088  lbz r11, 0x88(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) } as u64;
	// 830C8918: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C891C: 41820028  beq 0x830c8944
	if ctx.cr[0].eq {
		sub_830C8944(ctx, base);
		return;
	}
	// 830C8920: C0040064  lfs f0, 0x64(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8924: FD400210  fabs f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830C8928: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 830C892C: 41980018  blt cr6, 0x830c8944
	if ctx.cr[6].lt {
		sub_830C8944(ctx, base);
		return;
	}
	// 830C8930: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 830C8934: C1A40034  lfs f13, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8938: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830C893C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C8940: 48000008  b 0x830c8948
	sub_830C8944(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8944(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C8944 size=12
    let mut pc: u32 = 0x830C8944;
    'dispatch: loop {
        match pc {
            0x830C8944 => {
    //   block [0x830C8944..0x830C8950)
	// 830C8944: D1630004  stfs f11, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C8948: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C894C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C8950 size=40
    let mut pc: u32 = 0x830C8950;
    'dispatch: loop {
        match pc {
            0x830C8950 => {
    //   block [0x830C8950..0x830C8978)
	// 830C8950: 8943007C  lbz r10, 0x7c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 830C8954: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830C8958: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C895C: 4082001C  bne 0x830c8978
	if !ctx.cr[0].eq {
		sub_830C8978(ctx, base);
		return;
	}
	// 830C8960: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C8964: 38830080  addi r4, r3, 0x80
	ctx.r[4].s64 = ctx.r[3].s64 + 128;
	// 830C8968: 9943007C  stb r10, 0x7c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[10].u8 ) };
	// 830C896C: C04B0008  lfs f2, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C8970: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8974: 4BFFFC6C  b 0x830c85e0
	sub_830C85E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C8978 size=8
    let mut pc: u32 = 0x830C8978;
    'dispatch: loop {
        match pc {
            0x830C8978 => {
    //   block [0x830C8978..0x830C8980)
	// 830C8978: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C897C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C8980 size=488
    let mut pc: u32 = 0x830C8980;
    'dispatch: loop {
        match pc {
            0x830C8980 => {
    //   block [0x830C8980..0x830C8B68)
	// 830C8980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C8984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C8988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C898C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C8990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C8994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C8998: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830C899C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830C89A0: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C89A4: 9BDF007C  stb r30, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u8 ) };
	// 830C89A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C89AC: 419A01A0  beq cr6, 0x830c8b4c
	if ctx.cr[6].eq {
	pc = 0x830C8B4C; continue 'dispatch;
	}
	// 830C89B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C89B4: C04B0008  lfs f2, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830C89B8: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C89BC: 4BFFFC25  bl 0x830c85e0
	ctx.lr = 0x830C89C0;
	sub_830C85E0(ctx, base);
	// 830C89C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C89C4: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C89C8: 41820040  beq 0x830c8a08
	if ctx.cr[0].eq {
	pc = 0x830C8A08; continue 'dispatch;
	}
	// 830C89CC: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C89D0: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C89D4: 41820034  beq 0x830c8a08
	if ctx.cr[0].eq {
	pc = 0x830C8A08; continue 'dispatch;
	}
	// 830C89D8: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C89DC: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C89E0: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C89E4: EDAD033C  fnmsubs f13, f13, f12, f0
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C89E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C89EC: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C89F0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C89F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C89F8: 40980008  bge cr6, 0x830c8a00
	if !ctx.cr[6].lt {
	pc = 0x830C8A00; continue 'dispatch;
	}
	// 830C89FC: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C8A00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C8A04: 4800014C  b 0x830c8b50
	pc = 0x830C8B50; continue 'dispatch;
	// 830C8A08: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8A0C: 41820034  beq 0x830c8a40
	if ctx.cr[0].eq {
	pc = 0x830C8A40; continue 'dispatch;
	}
	// 830C8A10: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8A14: 554A07BD  rlwinm. r10, r10, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8A18: 41820028  beq 0x830c8a40
	if ctx.cr[0].eq {
	pc = 0x830C8A40; continue 'dispatch;
	}
	// 830C8A1C: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8A20: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8A24: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8A28: EDAD033A  fmadds f13, f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830C8A2C: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8A30: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C8A34: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8A38: 4099FFC8  ble cr6, 0x830c8a00
	if !ctx.cr[6].gt {
	pc = 0x830C8A00; continue 'dispatch;
	}
	// 830C8A3C: 4BFFFFC0  b 0x830c89fc
	pc = 0x830C89FC; continue 'dispatch;
	// 830C8A40: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8A44: 4182003C  beq 0x830c8a80
	if ctx.cr[0].eq {
	pc = 0x830C8A80; continue 'dispatch;
	}
	// 830C8A48: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8A4C: 554A077B  rlwinm. r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8A50: 41820030  beq 0x830c8a80
	if ctx.cr[0].eq {
	pc = 0x830C8A80; continue 'dispatch;
	}
	// 830C8A54: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8A58: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8A5C: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8A60: EDAD033C  fnmsubs f13, f13, f12, f0
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C8A64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C8A68: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C8A6C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8A70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8A74: 4098FF8C  bge cr6, 0x830c8a00
	if !ctx.cr[6].lt {
	pc = 0x830C8A00; continue 'dispatch;
	}
	// 830C8A78: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C8A7C: 4BFFFF84  b 0x830c8a00
	pc = 0x830C8A00; continue 'dispatch;
	// 830C8A80: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8A84: 41820034  beq 0x830c8ab8
	if ctx.cr[0].eq {
	pc = 0x830C8AB8; continue 'dispatch;
	}
	// 830C8A88: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8A8C: 554A0739  rlwinm. r10, r10, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8A90: 41820028  beq 0x830c8ab8
	if ctx.cr[0].eq {
	pc = 0x830C8AB8; continue 'dispatch;
	}
	// 830C8A94: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8A98: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8A9C: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8AA0: EDAD033A  fmadds f13, f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830C8AA4: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8AA8: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C8AAC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8AB0: 4099FF50  ble cr6, 0x830c8a00
	if !ctx.cr[6].gt {
	pc = 0x830C8A00; continue 'dispatch;
	}
	// 830C8AB4: 4BFFFFC4  b 0x830c8a78
	pc = 0x830C8A78; continue 'dispatch;
	// 830C8AB8: 556A0673  rlwinm. r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8ABC: 41820020  beq 0x830c8adc
	if ctx.cr[0].eq {
	pc = 0x830C8ADC; continue 'dispatch;
	}
	// 830C8AC0: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8AC4: 554A0673  rlwinm. r10, r10, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8AC8: 41820014  beq 0x830c8adc
	if ctx.cr[0].eq {
	pc = 0x830C8ADC; continue 'dispatch;
	}
	// 830C8ACC: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8AD0: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8AD4: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C8AD8: 4BFFFF10  b 0x830c89e8
	pc = 0x830C89E8; continue 'dispatch;
	// 830C8ADC: 556A0631  rlwinm. r10, r11, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8AE0: 41820020  beq 0x830c8b00
	if ctx.cr[0].eq {
	pc = 0x830C8B00; continue 'dispatch;
	}
	// 830C8AE4: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8AE8: 554A0631  rlwinm. r10, r10, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8AEC: 41820014  beq 0x830c8b00
	if ctx.cr[0].eq {
	pc = 0x830C8B00; continue 'dispatch;
	}
	// 830C8AF0: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8AF4: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8AF8: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8AFC: 4BFFFF30  b 0x830c8a2c
	pc = 0x830C8A2C; continue 'dispatch;
	// 830C8B00: 556A05EF  rlwinm. r10, r11, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8B04: 41820020  beq 0x830c8b24
	if ctx.cr[0].eq {
	pc = 0x830C8B24; continue 'dispatch;
	}
	// 830C8B08: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8B0C: 554A05EF  rlwinm. r10, r10, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C8B10: 41820014  beq 0x830c8b24
	if ctx.cr[0].eq {
	pc = 0x830C8B24; continue 'dispatch;
	}
	// 830C8B14: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8B18: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8B1C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C8B20: 4BFFFF44  b 0x830c8a64
	pc = 0x830C8A64; continue 'dispatch;
	// 830C8B24: 556B05AD  rlwinm. r11, r11, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C8B28: 41820020  beq 0x830c8b48
	if ctx.cr[0].eq {
	pc = 0x830C8B48; continue 'dispatch;
	}
	// 830C8B2C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830C8B30: 556B05AD  rlwinm. r11, r11, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C8B34: 41820014  beq 0x830c8b48
	if ctx.cr[0].eq {
	pc = 0x830C8B48; continue 'dispatch;
	}
	// 830C8B38: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8B3C: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8B40: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8B44: 4BFFFF60  b 0x830c8aa4
	pc = 0x830C8AA4; continue 'dispatch;
	// 830C8B48: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830C8B4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8B50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C8B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C8B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C8B5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C8B60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C8B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C8B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C8B68 size=1684
    let mut pc: u32 = 0x830C8B68;
    'dispatch: loop {
        match pc {
            0x830C8B68 => {
    //   block [0x830C8B68..0x830C91FC)
	// 830C8B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C8B6C: 480DF5FD  bl 0x831a8168
	ctx.lr = 0x830C8B70;
	sub_831A8130(ctx, base);
	// 830C8B70: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 830C8B74: 480DFF01  bl 0x831a8a74
	ctx.lr = 0x830C8B78;
	sub_831A8A40(ctx, base);
	// 830C8B78: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C8B7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C8B80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C8B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C8B88: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8B8C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8B90: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8B94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8B98: 4E800421  bctrl
	ctx.lr = 0x830C8B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8B9C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8BA0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830C8BA4: 808B0068  lwz r4, 0x68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C8BA8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8BAC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C8BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8BB4: 4E800421  bctrl
	ctx.lr = 0x830C8BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8BB8: C0010104  lfs f0, 0x104(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8BBC: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8BC0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830C8BC4: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C8BC8: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8BCC: C1810100  lfs f12, 0x100(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8BD0: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8BD4: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C8BD8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 830C8BDC: ED4A602A  fadds f10, f10, f12
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8BE0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830C8BE4: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830C8BE8: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830C8BEC: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C8BF0: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8BF4: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830C8BF8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C8BFC: C001010C  lfs f0, 0x10c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8C00: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C8C04: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8C08: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8C0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C8C10: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830C8C14: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830C8C18: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830C8C1C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C8C20: 40990008  ble cr6, 0x830c8c28
	if !ctx.cr[6].gt {
	pc = 0x830C8C28; continue 'dispatch;
	}
	// 830C8C24: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830C8C28: C1A10098  lfs f13, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8C2C: C0010108  lfs f0, 0x108(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8C30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C8C34: 40990008  ble cr6, 0x830c8c3c
	if !ctx.cr[6].gt {
	pc = 0x830C8C3C; continue 'dispatch;
	}
	// 830C8C38: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830C8C3C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8C40: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 830C8C44: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 830C8C48: 806B0068  lwz r3, 0x68(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C8C4C: 48000695  bl 0x830c92e0
	ctx.lr = 0x830C8C50;
	sub_830C92E0(ctx, base);
	// 830C8C50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830C8C54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8C58: 409A0014  bne cr6, 0x830c8c6c
	if !ctx.cr[6].eq {
	pc = 0x830C8C6C; continue 'dispatch;
	}
	// 830C8C5C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C8C60: 806B0068  lwz r3, 0x68(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 830C8C64: 4BDAF91D  bl 0x82e78580
	ctx.lr = 0x830C8C68;
	sub_82E78580(ctx, base);
	// 830C8C68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C8C6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C8C70: 895E0088  lbz r10, 0x88(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830C8C74: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C8C78: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830C8C7C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 830C8C80: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830C8C84: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830C8C88: C369A1C4  lfs f27, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830C8C8C: C3E808A8  lfs f31, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830C8C90: C3A79524  lfs f29, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830C8C94: 409A0258  bne cr6, 0x830c8eec
	if !ctx.cr[6].eq {
	pc = 0x830C8EEC; continue 'dispatch;
	}
	// 830C8C98: 897E0089  lbz r11, 0x89(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C8C9C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8CA0: 409A000C  bne cr6, 0x830c8cac
	if !ctx.cr[6].eq {
	pc = 0x830C8CAC; continue 'dispatch;
	}
	// 830C8CA4: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	// 830C8CA8: 48000008  b 0x830c8cb0
	pc = 0x830C8CB0; continue 'dispatch;
	// 830C8CAC: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 830C8CB0: C1BE0078  lfs f13, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8CB4: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 830C8CB8: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8CBC: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8CC0: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C8CC4: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C8CC8: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8CCC: EDAD573C  fnmsubs f13, f13, f28, f10
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[28].f64 - ctx.f[10].f64) as f32) as f64);
	// 830C8CD0: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830C8CD4: D16100B0  stfs f11, 0xb0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830C8CD8: D18100B4  stfs f12, 0xb4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830C8CDC: D1A100BC  stfs f13, 0xbc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830C8CE0: 4B200039  bl 0x822c8d18
	ctx.lr = 0x830C8CE4;
	sub_822C8D18(ctx, base);
	// 830C8CE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8CEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C8CF0: 409A0008  bne cr6, 0x830c8cf8
	if !ctx.cr[6].eq {
	pc = 0x830C8CF8; continue 'dispatch;
	}
	// 830C8CF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8CF8: 9BA10080  stb r29, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u8 ) };
	// 830C8CFC: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8D00: 9BE10081  stb r31, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[31].u8 ) };
	// 830C8D04: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 830C8D08: 9BE10082  stb r31, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[31].u8 ) };
	// 830C8D0C: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 830C8D10: 9BE10083  stb r31, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[31].u8 ) };
	// 830C8D14: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830C8D18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8D1C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830C8D20: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 830C8D24: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C8D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8D2C: 4E800421  bctrl
	ctx.lr = 0x830C8D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8D30: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 830C8D34: 4BD28F5D  bl 0x82df1c90
	ctx.lr = 0x830C8D38;
	sub_82DF1C90(ctx, base);
	// 830C8D38: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8D3C: C1BE0078  lfs f13, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8D40: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 830C8D44: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 830C8D48: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8D4C: C18100B0  lfs f12, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8D50: D3C100F0  stfs f30, 0xf0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 830C8D54: D3C100F4  stfs f30, 0xf4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 830C8D58: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 830C8D5C: D3E100FC  stfs f31, 0xfc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830C8D60: D18100E0  stfs f12, 0xe0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 830C8D64: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 830C8D68: C1A100B8  lfs f13, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8D6C: D1A100E8  stfs f13, 0xe8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 830C8D70: 4B1FFFA9  bl 0x822c8d18
	ctx.lr = 0x830C8D74;
	sub_822C8D18(ctx, base);
	// 830C8D74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8D7C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C8D80: 409A0008  bne cr6, 0x830c8d88
	if !ctx.cr[6].eq {
	pc = 0x830C8D88; continue 'dispatch;
	}
	// 830C8D84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8D88: 9BA10064  stb r29, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u8 ) };
	// 830C8D8C: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8D90: 9BE10065  stb r31, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[31].u8 ) };
	// 830C8D94: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 830C8D98: 9BE10066  stb r31, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[31].u8 ) };
	// 830C8D9C: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 830C8DA0: 9BE10067  stb r31, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[31].u8 ) };
	// 830C8DA4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C8DA8: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 830C8DAC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830C8DB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8DB4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C8DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8DBC: 4E800421  bctrl
	ctx.lr = 0x830C8DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8DC0: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 830C8DC4: 4BD28ECD  bl 0x82df1c90
	ctx.lr = 0x830C8DC8;
	sub_82DF1C90(ctx, base);
	// 830C8DC8: EDBCF828  fsubs f13, f28, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[28].f64 - ctx.f[31].f64) as f32) as f64);
	// 830C8DCC: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8DD0: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830C8DD4: C19E0078  lfs f12, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8DD8: ED4C073C  fnmsubs f10, f12, f28, f0
	ctx.f[10].f64 = -(((ctx.f[12].f64 * ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C8DDC: C16100B0  lfs f11, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C8DE0: C12100B8  lfs f9, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C8DE4: D3E100F0  stfs f31, 0xf0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 830C8DE8: D3E100F4  stfs f31, 0xf4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 830C8DEC: D3C100F8  stfs f30, 0xf8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 830C8DF0: D3C100FC  stfs f30, 0xfc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830C8DF4: D16100E0  stfs f11, 0xe0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 830C8DF8: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C8DFC: D14100E4  stfs f10, 0xe4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 830C8E00: D12100E8  stfs f9, 0xe8(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 830C8E04: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 830C8E08: 4B1FFF11  bl 0x822c8d18
	ctx.lr = 0x830C8E0C;
	sub_822C8D18(ctx, base);
	// 830C8E0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8E14: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C8E18: 409A0008  bne cr6, 0x830c8e20
	if !ctx.cr[6].eq {
	pc = 0x830C8E20; continue 'dispatch;
	}
	// 830C8E1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8E20: 9BE10076  stb r31, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[31].u8 ) };
	// 830C8E24: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8E28: 9BE10077  stb r31, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[31].u8 ) };
	// 830C8E2C: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 830C8E30: 9BA10074  stb r29, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u8 ) };
	// 830C8E34: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 830C8E38: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 830C8E3C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C8E40: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 830C8E44: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830C8E48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8E4C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C8E50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8E54: 4E800421  bctrl
	ctx.lr = 0x830C8E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8E58: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830C8E5C: 4BD28E35  bl 0x82df1c90
	ctx.lr = 0x830C8E60;
	sub_82DF1C90(ctx, base);
	// 830C8E60: C00100B4  lfs f0, 0xb4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8E64: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8E68: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 830C8E6C: C19E0044  lfs f12, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8E70: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8E74: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8E78: C14100B8  lfs f10, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C8E7C: D1610114  stfs f11, 0x114(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 830C8E80: D1410118  stfs f10, 0x118(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 830C8E84: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C8E88: D001011C  stfs f0, 0x11c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 830C8E8C: C18100B0  lfs f12, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8E90: D1810110  stfs f12, 0x110(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 830C8E94: 4B1FFE85  bl 0x822c8d18
	ctx.lr = 0x830C8E98;
	sub_822C8D18(ctx, base);
	// 830C8E98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8EA0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C8EA4: 409A0008  bne cr6, 0x830c8eac
	if !ctx.cr[6].eq {
	pc = 0x830C8EAC; continue 'dispatch;
	}
	// 830C8EA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8EAC: 9BA1006C  stb r29, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u8 ) };
	// 830C8EB0: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8EB4: 9BE1006D  stb r31, 0x6d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(109 as u32), ctx.r[31].u8 ) };
	// 830C8EB8: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 830C8EBC: 9BE1006E  stb r31, 0x6e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(110 as u32), ctx.r[31].u8 ) };
	// 830C8EC0: 39000016  li r8, 0x16
	ctx.r[8].s64 = 22;
	// 830C8EC4: 9BE1006F  stb r31, 0x6f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(111 as u32), ctx.r[31].u8 ) };
	// 830C8EC8: 38C1006C  addi r6, r1, 0x6c
	ctx.r[6].s64 = ctx.r[1].s64 + 108;
	// 830C8ECC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830C8ED0: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 830C8ED4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8ED8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C8EDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8EE0: 4E800421  bctrl
	ctx.lr = 0x830C8EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8EE4: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 830C8EE8: 4BD28DA9  bl 0x82df1c90
	ctx.lr = 0x830C8EEC;
	sub_82DF1C90(ctx, base);
	// 830C8EEC: 897E0089  lbz r11, 0x89(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C8EF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8EF4: 409A0250  bne cr6, 0x830c9144
	if !ctx.cr[6].eq {
	pc = 0x830C9144; continue 'dispatch;
	}
	// 830C8EF8: 897E0088  lbz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830C8EFC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C8F00: 419A0008  beq cr6, 0x830c8f08
	if ctx.cr[6].eq {
	pc = 0x830C8F08; continue 'dispatch;
	}
	// 830C8F04: FFA0F890  fmr f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[31].f64;
	// 830C8F08: C1BE0078  lfs f13, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8F0C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830C8F10: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8F14: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8F18: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C8F1C: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C8F20: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830C8F24: EDAD577C  fnmsubs f13, f13, f29, f10
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[29].f64 - ctx.f[10].f64) as f32) as f64);
	// 830C8F28: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830C8F2C: D16100A4  stfs f11, 0xa4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830C8F30: D18100A0  stfs f12, 0xa0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830C8F34: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830C8F38: 4B1FFDE1  bl 0x822c8d18
	ctx.lr = 0x830C8F3C;
	sub_822C8D18(ctx, base);
	// 830C8F3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8F44: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C8F48: 409A0008  bne cr6, 0x830c8f50
	if !ctx.cr[6].eq {
	pc = 0x830C8F50; continue 'dispatch;
	}
	// 830C8F4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8F50: 9BA1007C  stb r29, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u8 ) };
	// 830C8F54: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8F58: 9BE1007E  stb r31, 0x7e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(126 as u32), ctx.r[31].u8 ) };
	// 830C8F5C: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 830C8F60: 9BE1007D  stb r31, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[31].u8 ) };
	// 830C8F64: 39000013  li r8, 0x13
	ctx.r[8].s64 = 19;
	// 830C8F68: 9BE1007F  stb r31, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[31].u8 ) };
	// 830C8F6C: 38C1007C  addi r6, r1, 0x7c
	ctx.r[6].s64 = ctx.r[1].s64 + 124;
	// 830C8F70: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830C8F74: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830C8F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8F7C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C8F80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C8F84: 4E800421  bctrl
	ctx.lr = 0x830C8F88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C8F88: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830C8F8C: 4BD28D05  bl 0x82df1c90
	ctx.lr = 0x830C8F90;
	sub_82DF1C90(ctx, base);
	// 830C8F90: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C8F94: C1BE0078  lfs f13, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8F98: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 830C8F9C: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830C8FA0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C8FA4: C18100A4  lfs f12, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C8FA8: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830C8FAC: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830C8FB0: D3C100C8  stfs f30, 0xc8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830C8FB4: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830C8FB8: D18100D4  stfs f12, 0xd4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830C8FBC: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830C8FC0: C1A100AC  lfs f13, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C8FC4: D1A100DC  stfs f13, 0xdc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 830C8FC8: 4B1FFD51  bl 0x822c8d18
	ctx.lr = 0x830C8FCC;
	sub_822C8D18(ctx, base);
	// 830C8FCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C8FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C8FD4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C8FD8: 409A0008  bne cr6, 0x830c8fe0
	if !ctx.cr[6].eq {
	pc = 0x830C8FE0; continue 'dispatch;
	}
	// 830C8FDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C8FE0: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 830C8FE4: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C8FE8: 9BE10061  stb r31, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[31].u8 ) };
	// 830C8FEC: 39000017  li r8, 0x17
	ctx.r[8].s64 = 23;
	// 830C8FF0: 9BE10062  stb r31, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[31].u8 ) };
	// 830C8FF4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830C8FF8: 9BE10063  stb r31, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[31].u8 ) };
	// 830C8FFC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C9000: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 830C9004: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 830C9008: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C900C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C9010: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C9014: 4E800421  bctrl
	ctx.lr = 0x830C9018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C9018: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 830C901C: 4BD28C75  bl 0x82df1c90
	ctx.lr = 0x830C9020;
	sub_82DF1C90(ctx, base);
	// 830C9020: EDBDF828  fsubs f13, f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 830C9024: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9028: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 830C902C: C19E0078  lfs f12, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9030: ED4C077C  fnmsubs f10, f12, f29, f0
	ctx.f[10].f64 = -(((ctx.f[12].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C9034: C16100A4  lfs f11, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C9038: C12100AC  lfs f9, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C903C: D3C100C0  stfs f30, 0xc0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830C9040: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830C9044: D3E100C8  stfs f31, 0xc8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830C9048: D3E100CC  stfs f31, 0xcc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830C904C: D16100D4  stfs f11, 0xd4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830C9050: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C9054: D14100D0  stfs f10, 0xd0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830C9058: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830C905C: D12100DC  stfs f9, 0xdc(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 830C9060: 4B1FFCB9  bl 0x822c8d18
	ctx.lr = 0x830C9064;
	sub_822C8D18(ctx, base);
	// 830C9064: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C906C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C9070: 409A0008  bne cr6, 0x830c9078
	if !ctx.cr[6].eq {
	pc = 0x830C9078; continue 'dispatch;
	}
	// 830C9074: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C9078: 9BA10068  stb r29, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 830C907C: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C9080: 9BE10069  stb r31, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[31].u8 ) };
	// 830C9084: 39000017  li r8, 0x17
	ctx.r[8].s64 = 23;
	// 830C9088: 9BE1006A  stb r31, 0x6a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[31].u8 ) };
	// 830C908C: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 830C9090: 9BE1006B  stb r31, 0x6b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(107 as u32), ctx.r[31].u8 ) };
	// 830C9094: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C9098: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 830C909C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 830C90A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C90A4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C90A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C90AC: 4E800421  bctrl
	ctx.lr = 0x830C90B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C90B0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 830C90B4: 4BD28BDD  bl 0x82df1c90
	ctx.lr = 0x830C90B8;
	sub_82DF1C90(ctx, base);
	// 830C90B8: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C90BC: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C90C0: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 830C90C4: C19E0040  lfs f12, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C90C8: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C90CC: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 830C90D0: C14100AC  lfs f10, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C90D4: D1610120  stfs f11, 0x120(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 830C90D8: D141012C  stfs f10, 0x12c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 830C90DC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830C90E0: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 830C90E4: C18100A4  lfs f12, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C90E8: D1810124  stfs f12, 0x124(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 830C90EC: 4B1FFC2D  bl 0x822c8d18
	ctx.lr = 0x830C90F0;
	sub_822C8D18(ctx, base);
	// 830C90F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C90F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C90F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C90FC: 409A0008  bne cr6, 0x830c9104
	if !ctx.cr[6].eq {
	pc = 0x830C9104; continue 'dispatch;
	}
	// 830C9100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C9104: 9BA10070  stb r29, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u8 ) };
	// 830C9108: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C910C: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 830C9110: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 830C9114: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 830C9118: 39000015  li r8, 0x15
	ctx.r[8].s64 = 21;
	// 830C911C: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 830C9120: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830C9124: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830C9128: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 830C912C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9130: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C9134: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C9138: 4E800421  bctrl
	ctx.lr = 0x830C913C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C913C: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 830C9140: 4BD28B51  bl 0x82df1c90
	ctx.lr = 0x830C9144;
	sub_82DF1C90(ctx, base);
	// 830C9144: 897E0088  lbz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830C9148: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C914C: 409A00A0  bne cr6, 0x830c91ec
	if !ctx.cr[6].eq {
	pc = 0x830C91EC; continue 'dispatch;
	}
	// 830C9150: 897E0089  lbz r11, 0x89(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(137 as u32) ) } as u64;
	// 830C9154: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830C9158: 409A0094  bne cr6, 0x830c91ec
	if !ctx.cr[6].eq {
	pc = 0x830C91EC; continue 'dispatch;
	}
	// 830C915C: C19E0078  lfs f12, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9160: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 830C9164: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9168: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C916C: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C9170: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830C9174: D1610130  stfs f11, 0x130(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 830C9178: D1810134  stfs f12, 0x134(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 830C917C: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 830C9180: D1A1013C  stfs f13, 0x13c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 830C9184: D3C10140  stfs f30, 0x140(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 830C9188: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 830C918C: D3E10148  stfs f31, 0x148(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 830C9190: D3E1014C  stfs f31, 0x14c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 830C9194: 4B1FFB85  bl 0x822c8d18
	ctx.lr = 0x830C9198;
	sub_822C8D18(ctx, base);
	// 830C9198: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C919C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C91A0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 830C91A4: 409A0008  bne cr6, 0x830c91ac
	if !ctx.cr[6].eq {
	pc = 0x830C91AC; continue 'dispatch;
	}
	// 830C91A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C91AC: 9BA10078  stb r29, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u8 ) };
	// 830C91B0: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C91B4: 9BE10079  stb r31, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[31].u8 ) };
	// 830C91B8: 39000011  li r8, 0x11
	ctx.r[8].s64 = 17;
	// 830C91BC: 9BE1007A  stb r31, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[31].u8 ) };
	// 830C91C0: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 830C91C4: 9BE1007B  stb r31, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[31].u8 ) };
	// 830C91C8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C91CC: 38A10140  addi r5, r1, 0x140
	ctx.r[5].s64 = ctx.r[1].s64 + 320;
	// 830C91D0: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 830C91D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C91D8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C91DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C91E0: 4E800421  bctrl
	ctx.lr = 0x830C91E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C91E4: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 830C91E8: 4BD28AA9  bl 0x82df1c90
	ctx.lr = 0x830C91EC;
	sub_82DF1C90(ctx, base);
	// 830C91EC: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 830C91F0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 830C91F4: 480DF8CD  bl 0x831a8ac0
	ctx.lr = 0x830C91F8;
	sub_831A8A8C(ctx, base);
	// 830C91F8: 480DEFC0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9200 size=8
    let mut pc: u32 = 0x830C9200;
    'dispatch: loop {
        match pc {
            0x830C9200 => {
    //   block [0x830C9200..0x830C9208)
	// 830C9200: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C9204: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9208 size=40
    let mut pc: u32 = 0x830C9208;
    'dispatch: loop {
        match pc {
            0x830C9208 => {
    //   block [0x830C9208..0x830C9230)
	// 830C9208: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C920C: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 830C9210: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C9214: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C9218: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C921C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C9220: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830C9224: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C9228: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830C922C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9230 size=8
    let mut pc: u32 = 0x830C9230;
    'dispatch: loop {
        match pc {
            0x830C9230 => {
    //   block [0x830C9230..0x830C9238)
	// 830C9230: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C9234: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9238 size=40
    let mut pc: u32 = 0x830C9238;
    'dispatch: loop {
        match pc {
            0x830C9238 => {
    //   block [0x830C9238..0x830C9260)
	// 830C9238: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C923C: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 830C9240: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830C9244: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C9248: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830C924C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C9250: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830C9254: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C9258: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830C925C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9260 size=8
    let mut pc: u32 = 0x830C9260;
    'dispatch: loop {
        match pc {
            0x830C9260 => {
    //   block [0x830C9260..0x830C9268)
	// 830C9260: 90830024  stw r4, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[4].u32 ) };
	// 830C9264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9268 size=8
    let mut pc: u32 = 0x830C9268;
    'dispatch: loop {
        match pc {
            0x830C9268 => {
    //   block [0x830C9268..0x830C9270)
	// 830C9268: 98830028  stb r4, 0x28(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[4].u8 ) };
	// 830C926C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9270 size=8
    let mut pc: u32 = 0x830C9270;
    'dispatch: loop {
        match pc {
            0x830C9270 => {
    //   block [0x830C9270..0x830C9278)
	// 830C9270: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830C9274: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9278 size=20
    let mut pc: u32 = 0x830C9278;
    'dispatch: loop {
        match pc {
            0x830C9278 => {
    //   block [0x830C9278..0x830C928C)
	// 830C9278: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C927C: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830C9280: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C9284: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830C9288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9290 size=8
    let mut pc: u32 = 0x830C9290;
    'dispatch: loop {
        match pc {
            0x830C9290 => {
    //   block [0x830C9290..0x830C9298)
	// 830C9290: 98830044  stb r4, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[4].u8 ) };
	// 830C9294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C9298 size=8
    let mut pc: u32 = 0x830C9298;
    'dispatch: loop {
        match pc {
            0x830C9298 => {
    //   block [0x830C9298..0x830C92A0)
	// 830C9298: D0230048  stfs f1, 0x48(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830C929C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C92A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C92A0 size=48
    let mut pc: u32 = 0x830C92A0;
    'dispatch: loop {
        match pc {
            0x830C92A0 => {
    //   block [0x830C92A0..0x830C92D0)
	// 830C92A0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C92A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C92A8: 39230058  addi r9, r3, 0x58
	ctx.r[9].s64 = ctx.r[3].s64 + 88;
	// 830C92AC: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C92B0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C92B4: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830C92B8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C92BC: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830C92C0: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C92C4: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830C92C8: 99430054  stb r10, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 830C92CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C92D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C92D0 size=8
    let mut pc: u32 = 0x830C92D0;
    'dispatch: loop {
        match pc {
            0x830C92D0 => {
    //   block [0x830C92D0..0x830C92D8)
	// 830C92D0: D0230068  stfs f1, 0x68(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830C92D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C92D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C92D8 size=8
    let mut pc: u32 = 0x830C92D8;
    'dispatch: loop {
        match pc {
            0x830C92D8 => {
    //   block [0x830C92D8..0x830C92E0)
	// 830C92D8: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 830C92DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C92E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C92E0 size=8
    let mut pc: u32 = 0x830C92E0;
    'dispatch: loop {
        match pc {
            0x830C92E0 => {
    //   block [0x830C92E0..0x830C92E8)
	// 830C92E0: 88630044  lbz r3, 0x44(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 830C92E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C92E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830C92E8 size=8
    let mut pc: u32 = 0x830C92E8;
    'dispatch: loop {
        match pc {
            0x830C92E8 => {
    //   block [0x830C92E8..0x830C92F0)
	// 830C92E8: C0230048  lfs f1, 0x48(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C92EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C92F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C92F0 size=80
    let mut pc: u32 = 0x830C92F0;
    'dispatch: loop {
        match pc {
            0x830C92F0 => {
    //   block [0x830C92F0..0x830C9340)
	// 830C92F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830C92F4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830C92F8: 99430070  stb r10, 0x70(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[10].u8 ) };
	// 830C92FC: 39430094  addi r10, r3, 0x94
	ctx.r[10].s64 = ctx.r[3].s64 + 148;
	// 830C9300: 7D0B2050  subf r8, r11, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830C9304: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830C9308: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830C930C: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830C9310: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C9314: 90EAFFE0  stw r7, -0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32 as u32), ctx.r[7].u32 ) };
	// 830C9318: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C931C: 90EAFFE4  stw r7, -0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28 as u32), ctx.r[7].u32 ) };
	// 830C9320: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9324: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830C9328: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C932C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830C9330: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 830C9334: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830C9338: 4082FFD0  bne 0x830c9308
	if !ctx.cr[0].eq {
	pc = 0x830C9308; continue 'dispatch;
	}
	// 830C933C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C9340 size=844
    let mut pc: u32 = 0x830C9340;
    'dispatch: loop {
        match pc {
            0x830C9340 => {
    //   block [0x830C9340..0x830C968C)
	// 830C9340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9344: 480DEE1D  bl 0x831a8160
	ctx.lr = 0x830C9348;
	sub_831A8130(ctx, base);
	// 830C9348: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 830C934C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 830C9350: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C9358: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830C935C: 897F0070  lbz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 830C9360: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C9364: 418200D0  beq 0x830c9434
	if ctx.cr[0].eq {
	pc = 0x830C9434; continue 'dispatch;
	}
	// 830C9368: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 830C936C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 830C9370: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 830C9374: 391F0034  addi r8, r31, 0x34
	ctx.r[8].s64 = ctx.r[31].s64 + 52;
	// 830C9378: 3964000C  addi r11, r4, 0xc
	ctx.r[11].s64 = ctx.r[4].s64 + 12;
	// 830C937C: C1879524  lfs f12, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9380: 395F0078  addi r10, r31, 0x78
	ctx.r[10].s64 = ctx.r[31].s64 + 120;
	// 830C9384: C00608A8  lfs f0, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9388: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830C938C: C1A59450  lfs f13, -0x6bb0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C9390: C16AFFFC  lfs f11, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C9394: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830C9398: D16BFFF4  stfs f11, -0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 830C939C: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C93A0: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C93A4: D14BFFF8  stfs f10, -8(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 830C93A8: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C93AC: D16BFFF4  stfs f11, -0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 830C93B0: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C93B4: D14BFFF8  stfs f10, -8(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 830C93B8: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C93BC: C13F004C  lfs f9, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C93C0: D12BFFFC  stfs f9, -4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830C93C4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C93C8: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C93CC: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 830C93D0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 830C93D4: C12A001C  lfs f9, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C93D8: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C93DC: C12A0020  lfs f9, 0x20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C93E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830C93E4: D12B000C  stfs f9, 0xc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830C93E8: E8FA0002  lwa r7, 0(r26)
	ctx.r[7].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 830C93EC: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 830C93F0: C9210050  lfd f9, 0x50(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C93F4: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 830C93F8: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 830C93FC: ED6B4824  fdivs f11, f11, f9
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[9].f64) as f32) as f64;
	// 830C9400: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C9404: D16BFFF4  stfs f11, -0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 830C9408: E8FA0006  lwa r7, 4(r26)
	ctx.r[7].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 830C940C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 830C9410: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830C9414: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830C9418: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830C941C: ED6A5824  fdivs f11, f10, f11
	ctx.f[11].f64 = ((ctx.f[10].f64 / ctx.f[11].f64) as f32) as f64;
	// 830C9420: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C9424: D16BFFF8  stfs f11, -8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 830C9428: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 830C942C: 4082FF64  bne 0x830c9390
	if !ctx.cr[0].eq {
	pc = 0x830C9390; continue 'dispatch;
	}
	// 830C9430: 4800024C  b 0x830c967c
	pc = 0x830C967C; continue 'dispatch;
	// 830C9434: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9438: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830C943C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C9440: 3964001C  addi r11, r4, 0x1c
	ctx.r[11].s64 = ctx.r[4].s64 + 28;
	// 830C9444: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9448: 3B640004  addi r27, r4, 4
	ctx.r[27].s64 = ctx.r[4].s64 + 4;
	// 830C944C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C9450: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 830C9454: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9458: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C945C: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830C9460: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9464: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830C9468: 813F0034  lwz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C946C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9470: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830C9474: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C9478: D1A4001C  stfs f13, 0x1c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830C947C: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C9480: D1A40020  stfs f13, 0x20(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830C9484: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C9488: D1A40030  stfs f13, 0x30(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C948C: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C9490: D1A40034  stfs f13, 0x34(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C9494: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C9498: 9144002C  stw r10, 0x2c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 830C949C: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94A0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C94A4: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94A8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C94AC: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94B0: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830C94B4: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94B8: D1AB0018  stfs f13, 0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830C94BC: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830C94C0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830C94C4: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94C8: D1AB001C  stfs f13, 0x1c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830C94CC: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94D0: D1AB0020  stfs f13, 0x20(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830C94D4: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94D8: D1AB0030  stfs f13, 0x30(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830C94DC: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94E0: D1AB0034  stfs f13, 0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830C94E4: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 830C94E8: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 830C94EC: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C94F0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830C94F4: 419A0078  beq cr6, 0x830c956c
	if ctx.cr[6].eq {
	pc = 0x830C956C; continue 'dispatch;
	}
	// 830C94F8: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 830C94FC: C03F0068  lfs f1, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C9500: 480DF9A9  bl 0x831a8ea8
	ctx.lr = 0x830C9504;
	sub_831A8EA8(ctx, base);
	// 830C9504: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9508: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830C950C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 830C9510: 480DF8B9  bl 0x831a8dc8
	ctx.lr = 0x830C9514;
	sub_831A8DC8(ctx, base);
	// 830C9514: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830C9518: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C951C: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9520: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 830C9524: C03F0068  lfs f1, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830C9528: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830C952C: EFEC07F8  fmsubs f31, f12, f31, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C9530: 480DF899  bl 0x831a8dc8
	ctx.lr = 0x830C9534;
	sub_831A8DC8(ctx, base);
	// 830C9534: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9538: FFC00818  frsp f30, f1
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830C953C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 830C9540: 480DF969  bl 0x831a8ea8
	ctx.lr = 0x830C9544;
	sub_831A8EA8(ctx, base);
	// 830C9544: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9548: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830C954C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 830C9550: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9554: D3FE0000  stfs f31, 0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C9558: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830C955C: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 830C9560: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830C9564: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C9568: 4082FF94  bne 0x830c94fc
	if !ctx.cr[0].eq {
	pc = 0x830C94FC; continue 'dispatch;
	}
	// 830C956C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830C9570: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830C9574: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 830C9578: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830C957C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830C9580: C1899524  lfs f12, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9584: C00808A8  lfs f0, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9588: C1A79450  lfs f13, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C958C: 893F0028  lbz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C9590: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C9594: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C9598: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C959C: 41820044  beq 0x830c95e0
	if ctx.cr[0].eq {
	pc = 0x830C95E0; continue 'dispatch;
	}
	// 830C95A0: E93A0002  lwa r9, 0(r26)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 830C95A4: C12B0000  lfs f9, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830C95A8: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 830C95AC: C9010058  lfd f8, 0x58(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830C95B0: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 830C95B4: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 830C95B8: ED685ABA  fmadds f11, f8, f10, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 830C95BC: D16BFFFC  stfs f11, -4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830C95C0: E93A0006  lwa r9, 4(r26)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 830C95C4: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C95C8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 830C95CC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830C95D0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830C95D4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830C95D8: ED6B527A  fmadds f11, f11, f9, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 830C95DC: 48000018  b 0x830c95f4
	pc = 0x830C95F4; continue 'dispatch;
	// 830C95E0: ED6B502A  fadds f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 830C95E4: D16BFFFC  stfs f11, -4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830C95E8: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C95EC: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C95F0: ED6B502A  fadds f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 830C95F4: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C95F8: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C95FC: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830C9600: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C9604: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 830C9608: D14BFFFC  stfs f10, -4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830C960C: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C9610: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C9614: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 830C9618: E93A0002  lwa r9, 0(r26)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 830C961C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 830C9620: C9210060  lfd f9, 0x60(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830C9624: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 830C9628: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 830C962C: ED4A4824  fdivs f10, f10, f9
	ctx.f[10].f64 = ((ctx.f[10].f64 / ctx.f[9].f64) as f32) as f64;
	// 830C9630: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 830C9634: D14BFFFC  stfs f10, -4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830C9638: E93A0006  lwa r9, 4(r26)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 830C963C: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 830C9640: C9410068  lfd f10, 0x68(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830C9644: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830C9648: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830C964C: ED6B5024  fdivs f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[10].f64) as f32) as f64;
	// 830C9650: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 830C9654: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830C9658: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C965C: D16B0010  stfs f11, 0x10(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830C9660: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C9664: D16B0014  stfs f11, 0x14(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830C9668: C17F004C  lfs f11, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830C966C: D16B0004  stfs f11, 4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830C9670: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830C9674: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 830C9678: 4082FF14  bne 0x830c958c
	if !ctx.cr[0].eq {
	pc = 0x830C958C; continue 'dispatch;
	}
	// 830C967C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830C9680: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 830C9684: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 830C9688: 480DEB28  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9690 size=60
    let mut pc: u32 = 0x830C9690;
    'dispatch: loop {
        match pc {
            0x830C9690 => {
    //   block [0x830C9690..0x830C96CC)
	// 830C9690: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 830C9694: 9081FFF0  stw r4, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u32 ) };
	// 830C9698: 9081FFF4  stw r4, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[4].u32 ) };
	// 830C969C: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 830C96A0: 9081FFF8  stw r4, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[4].u32 ) };
	// 830C96A4: 9081FFFC  stw r4, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 830C96A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C96AC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C96B0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C96B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C96B8: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830C96BC: 91230040  stw r9, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 830C96C0: 91030034  stw r8, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 830C96C4: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830C96C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C96D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C96D0 size=168
    let mut pc: u32 = 0x830C96D0;
    'dispatch: loop {
        match pc {
            0x830C96D0 => {
    //   block [0x830C96D0..0x830C9778)
	// 830C96D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C96D4: 480DEA99  bl 0x831a816c
	ctx.lr = 0x830C96D8;
	sub_831A8130(ctx, base);
	// 830C96D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C96DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C96E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C96E4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C96E8: 4199000C  bgt cr6, 0x830c96f4
	if ctx.cr[6].gt {
	pc = 0x830C96F4; continue 'dispatch;
	}
	// 830C96EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830C96F0: 48000040  b 0x830c9730
	pc = 0x830C9730; continue 'dispatch;
	// 830C96F4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830C96F8: 0CDF0000  twi 6, r31, 0
	// 830C96FC: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 830C9700: 2B0B00C4  cmplwi cr6, r11, 0xc4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 196 as u32, &mut ctx.xer);
	// 830C9704: 4098002C  bge cr6, 0x830c9730
	if !ctx.cr[6].lt {
	pc = 0x830C9730; continue 'dispatch;
	}
	// 830C9708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C970C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C9710: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 830C9714: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830C9718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C971C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C9720: 4B1FAB91  bl 0x822c42b0
	ctx.lr = 0x830C9724;
	sub_822C42B0(ctx, base);
	// 830C9724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830C9728: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 830C972C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C9730: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C9734: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C9738: 4099002C  ble cr6, 0x830c9764
	if !ctx.cr[6].gt {
	pc = 0x830C9764; continue 'dispatch;
	}
	// 830C973C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 830C9740: 3BCB5686  addi r30, r11, 0x5686
	ctx.r[30].s64 = ctx.r[11].s64 + 22150;
	// 830C9744: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C9748: 1C7F00C4  mulli r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 * 196;
	// 830C974C: 480E371D  bl 0x831ace68
	ctx.lr = 0x830C9750;
	sub_831ACE68(ctx, base);
	// 830C9750: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C9754: 40820010  bne 0x830c9764
	if !ctx.cr[0].eq {
	pc = 0x830C9764; continue 'dispatch;
	}
	// 830C9758: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 830C975C: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830C9760: 4181FFE4  bgt 0x830c9744
	if ctx.cr[0].gt {
	pc = 0x830C9744; continue 'dispatch;
	}
	// 830C9764: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830C9768: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C976C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830C9770: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C9774: 480DEA48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C9778 size=448
    let mut pc: u32 = 0x830C9778;
    'dispatch: loop {
        match pc {
            0x830C9778 => {
    //   block [0x830C9778..0x830C9938)
	// 830C9778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C977C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C9780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C9784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C9788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C978C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C9790: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C9794: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C9798: 396B9CF8  addi r11, r11, -0x6308
	ctx.r[11].s64 = ctx.r[11].s64 + -25352;
	// 830C979C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 830C97A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C97A4: 389E0074  addi r4, r30, 0x74
	ctx.r[4].s64 = ctx.r[30].s64 + 116;
	// 830C97A8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830C97AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C97B0: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 830C97B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C97B8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C97BC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C97C0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C97C4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830C97C8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C97CC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830C97D0: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C97D4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830C97D8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C97DC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830C97E0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C97E4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830C97E8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C97EC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830C97F0: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 830C97F4: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830C97F8: 897E0028  lbz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C97FC: 997F0028  stb r11, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u8 ) };
	// 830C9800: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 830C9804: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830C9808: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C980C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830C9810: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C9814: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 830C9818: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C981C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830C9820: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 830C9824: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830C9828: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 830C982C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 830C9830: 897E0044  lbz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 830C9834: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 830C9838: C01E0048  lfs f0, 0x48(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C983C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830C9840: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9844: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830C9848: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C984C: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C9850: 897E0054  lbz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9854: 997F0054  stb r11, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 830C9858: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C985C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C9860: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 830C9864: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830C9868: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 830C986C: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830C9870: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C9874: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830C9878: C01E0068  lfs f0, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C987C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830C9880: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 830C9884: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830C9888: 897E0070  lbz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 830C988C: 997F0070  stb r11, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 830C9890: 480DEC81  bl 0x831a8510
	ctx.lr = 0x830C9894;
	sub_831A8510(ctx, base);
	// 830C9894: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 830C9898: 389E0094  addi r4, r30, 0x94
	ctx.r[4].s64 = ctx.r[30].s64 + 148;
	// 830C989C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830C98A0: 480DEC71  bl 0x831a8510
	ctx.lr = 0x830C98A4;
	sub_831A8510(ctx, base);
	// 830C98A4: 397F00B4  addi r11, r31, 0xb4
	ctx.r[11].s64 = ctx.r[31].s64 + 180;
	// 830C98A8: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 830C98AC: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 830C98B0: 817E00B8  lwz r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 830C98B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C98B8: 917F00B8  stw r11, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 830C98BC: 419A0024  beq cr6, 0x830c98e0
	if ctx.cr[6].eq {
	pc = 0x830C98E0; continue 'dispatch;
	}
	// 830C98C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C98C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C98C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C98CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C98D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C98D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C98D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C98DC: 4082FFE8  bne 0x830c98c4
	if !ctx.cr[0].eq {
	pc = 0x830C98C4; continue 'dispatch;
	}
	// 830C98E0: 815E00BC  lwz r10, 0xbc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) } as u64;
	// 830C98E4: 397F00BC  addi r11, r31, 0xbc
	ctx.r[11].s64 = ctx.r[31].s64 + 188;
	// 830C98E8: 915F00BC  stw r10, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 830C98EC: 817E00C0  lwz r11, 0xc0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C98F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C98F4: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 830C98F8: 419A0024  beq cr6, 0x830c991c
	if ctx.cr[6].eq {
	pc = 0x830C991C; continue 'dispatch;
	}
	// 830C98FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830C9900: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830C9904: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C9908: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830C990C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C9910: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830C9914: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830C9918: 4082FFE8  bne 0x830c9900
	if !ctx.cr[0].eq {
	pc = 0x830C9900; continue 'dispatch;
	}
	// 830C991C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9920: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C9924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C9928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C992C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C9930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C9934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C9938 size=240
    let mut pc: u32 = 0x830C9938;
    'dispatch: loop {
        match pc {
            0x830C9938 => {
    //   block [0x830C9938..0x830C9A28)
	// 830C9938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C993C: 480DE82D  bl 0x831a8168
	ctx.lr = 0x830C9940;
	sub_831A8130(ctx, base);
	// 830C9940: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C9948: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C994C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C9950: 3BCB7928  addi r30, r11, 0x7928
	ctx.r[30].s64 = ctx.r[11].s64 + 31016;
	// 830C9954: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 830C9958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C995C: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 830C9960: 4BB10711  bl 0x82bda070
	ctx.lr = 0x830C9964;
	sub_82BDA070(ctx, base);
	// 830C9964: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C9968: 807F0208  lwz r3, 0x208(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 830C996C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9970: 419A0008  beq cr6, 0x830c9978
	if ctx.cr[6].eq {
	pc = 0x830C9978; continue 'dispatch;
	}
	// 830C9974: 4BB15665  bl 0x82bdefd8
	ctx.lr = 0x830C9978;
	sub_82BDEFD8(ctx, base);
	// 830C9978: 93BF0208  stw r29, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[29].u32 ) };
	// 830C997C: 387E0114  addi r3, r30, 0x114
	ctx.r[3].s64 = ctx.r[30].s64 + 276;
	// 830C9980: 4BB10601  bl 0x82bd9f80
	ctx.lr = 0x830C9984;
	sub_82BD9F80(ctx, base);
	// 830C9984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C9988: 807F020C  lwz r3, 0x20c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 830C998C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9990: 419A0008  beq cr6, 0x830c9998
	if ctx.cr[6].eq {
	pc = 0x830C9998; continue 'dispatch;
	}
	// 830C9994: 4BB15645  bl 0x82bdefd8
	ctx.lr = 0x830C9998;
	sub_82BDEFD8(ctx, base);
	// 830C9998: 93DF020C  stw r30, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[30].u32 ) };
	// 830C999C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830C99A0: 38BF0214  addi r5, r31, 0x214
	ctx.r[5].s64 = ctx.r[31].s64 + 532;
	// 830C99A4: 388B7B20  addi r4, r11, 0x7b20
	ctx.r[4].s64 = ctx.r[11].s64 + 31520;
	// 830C99A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C99AC: 4BD457BD  bl 0x82e0f168
	ctx.lr = 0x830C99B0;
	sub_82E0F168(ctx, base);
	// 830C99B0: 3D002800  lis r8, 0x2800
	ctx.r[8].s64 = 671088640;
	// 830C99B4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 830C99B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830C99BC: 61080102  ori r8, r8, 0x102
	ctx.r[8].u64 = ctx.r[8].u64 | 258;
	// 830C99C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830C99C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830C99C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C99CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C99D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C99D4: 4BB180B5  bl 0x82be1a88
	ctx.lr = 0x830C99D8;
	sub_82BE1A88(ctx, base);
	// 830C99D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C99DC: 807F0210  lwz r3, 0x210(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 830C99E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C99E4: 419A0008  beq cr6, 0x830c99ec
	if ctx.cr[6].eq {
	pc = 0x830C99EC; continue 'dispatch;
	}
	// 830C99E8: 4BB155F1  bl 0x82bdefd8
	ctx.lr = 0x830C99EC;
	sub_82BDEFD8(ctx, base);
	// 830C99EC: 93DF0210  stw r30, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[30].u32 ) };
	// 830C99F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830C99F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830C99F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830C99FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C9A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9A04: 4BB17EED  bl 0x82be18f0
	ctx.lr = 0x830C9A08;
	sub_82BE18F0(ctx, base);
	// 830C9A08: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9A0C: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 830C9A10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C9A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9A18: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830C9A1C: 4BB16355  bl 0x82bdfd70
	ctx.lr = 0x830C9A20;
	sub_82BDFD70(ctx, base);
	// 830C9A20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C9A24: 480DE794  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C9A28 size=216
    let mut pc: u32 = 0x830C9A28;
    'dispatch: loop {
        match pc {
            0x830C9A28 => {
    //   block [0x830C9A28..0x830C9B00)
	// 830C9A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C9A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C9A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C9A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9A3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C9A40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C9A44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C9A48: 809E0214  lwz r4, 0x214(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(532 as u32) ) } as u64;
	// 830C9A4C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830C9A50: 419A0010  beq cr6, 0x830c9a60
	if ctx.cr[6].eq {
	pc = 0x830C9A60; continue 'dispatch;
	}
	// 830C9A54: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830C9A58: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9A5C: 4BB0EE75  bl 0x82bd88d0
	ctx.lr = 0x830C9A60;
	sub_82BD88D0(ctx, base);
	// 830C9A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9A64: 4BD4515D  bl 0x82e0ebc0
	ctx.lr = 0x830C9A68;
	sub_82E0EBC0(ctx, base);
	// 830C9A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9A6C: 4BD45245  bl 0x82e0ecb0
	ctx.lr = 0x830C9A70;
	sub_82E0ECB0(ctx, base);
	// 830C9A70: 809E0208  lwz r4, 0x208(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(520 as u32) ) } as u64;
	// 830C9A74: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9A78: 4BB0EC89  bl 0x82bd8700
	ctx.lr = 0x830C9A7C;
	sub_82BD8700(ctx, base);
	// 830C9A7C: 809E020C  lwz r4, 0x20c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 830C9A80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9A84: 4BB0E9C5  bl 0x82bd8448
	ctx.lr = 0x830C9A88;
	sub_82BD8448(ctx, base);
	// 830C9A88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C9A8C: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 830C9A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9A94: 4B21B855  bl 0x822e52e8
	ctx.lr = 0x830C9A98;
	sub_822E52E8(ctx, base);
	// 830C9A98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C9A9C: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 830C9AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9AA4: 4B21B845  bl 0x822e52e8
	ctx.lr = 0x830C9AA8;
	sub_822E52E8(ctx, base);
	// 830C9AA8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 830C9AAC: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 830C9AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9AB4: 4B21B835  bl 0x822e52e8
	ctx.lr = 0x830C9AB8;
	sub_822E52E8(ctx, base);
	// 830C9AB8: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 830C9ABC: 3880004C  li r4, 0x4c
	ctx.r[4].s64 = 76;
	// 830C9AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9AC4: 4B21B825  bl 0x822e52e8
	ctx.lr = 0x830C9AC8;
	sub_822E52E8(ctx, base);
	// 830C9AC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C9ACC: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 830C9AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9AD4: 4B21B815  bl 0x822e52e8
	ctx.lr = 0x830C9AD8;
	sub_822E52E8(ctx, base);
	// 830C9AD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C9ADC: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 830C9AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9AE4: 4B21B805  bl 0x822e52e8
	ctx.lr = 0x830C9AE8;
	sub_822E52E8(ctx, base);
	// 830C9AE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C9AEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C9AF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C9AF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C9AF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C9AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C9B00 size=104
    let mut pc: u32 = 0x830C9B00;
    'dispatch: loop {
        match pc {
            0x830C9B00 => {
    //   block [0x830C9B00..0x830C9B68)
	// 830C9B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C9B08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C9B0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C9B10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C9B18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C9B1C: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830C9B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9B24: 419A0008  beq cr6, 0x830c9b2c
	if ctx.cr[6].eq {
	pc = 0x830C9B2C; continue 'dispatch;
	}
	// 830C9B28: 4B1F6D69  bl 0x822c0890
	ctx.lr = 0x830C9B2C;
	sub_822C0890(ctx, base);
	// 830C9B2C: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830C9B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9B34: 419A0008  beq cr6, 0x830c9b3c
	if ctx.cr[6].eq {
	pc = 0x830C9B3C; continue 'dispatch;
	}
	// 830C9B38: 4B1F6D59  bl 0x822c0890
	ctx.lr = 0x830C9B3C;
	sub_822C0890(ctx, base);
	// 830C9B3C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C9B40: 4182000C  beq 0x830c9b4c
	if ctx.cr[0].eq {
	pc = 0x830C9B4C; continue 'dispatch;
	}
	// 830C9B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9B48: 4B1F6721  bl 0x822c0268
	ctx.lr = 0x830C9B4C;
	sub_822C0268(ctx, base);
	// 830C9B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9B50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C9B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C9B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C9B5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C9B60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C9B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C9B68 size=124
    let mut pc: u32 = 0x830C9B68;
    'dispatch: loop {
        match pc {
            0x830C9B68 => {
    //   block [0x830C9B68..0x830C9BE4)
	// 830C9B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C9B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C9B74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9B78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C9B7C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9B80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9B84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C9B88: 409A0040  bne cr6, 0x830c9bc8
	if !ctx.cr[6].eq {
	pc = 0x830C9BC8; continue 'dispatch;
	}
	// 830C9B8C: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C9B90: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830C9B94: 40990034  ble cr6, 0x830c9bc8
	if !ctx.cr[6].gt {
	pc = 0x830C9BC8; continue 'dispatch;
	}
	// 830C9B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C9B9C: 4BFFFB35  bl 0x830c96d0
	ctx.lr = 0x830C9BA0;
	sub_830C96D0(ctx, base);
	// 830C9BA0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9BA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C9BA8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9BAC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C9BB0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9BB4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830C9BB8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9BBC: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830C9BC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9BC4: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830C9BC8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9BCC: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C9BD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C9BD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C9BD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C9BDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C9BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C9BE8 size=168
    let mut pc: u32 = 0x830C9BE8;
    'dispatch: loop {
        match pc {
            0x830C9BE8 => {
    //   block [0x830C9BE8..0x830C9C90)
	// 830C9BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C9BF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C9BF4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830C9BF8: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9BFC: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 830C9C00: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830C9C04: 4BFFFB75  bl 0x830c9778
	ctx.lr = 0x830C9C08;
	sub_830C9778(ctx, base);
	// 830C9C08: 4BFFF6E1  bl 0x830c92e8
	ctx.lr = 0x830C9C0C;
	sub_830C92E8(ctx, base);
	// 830C9C0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C9C10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C9C14: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830C9C18: 4BFFFB61  bl 0x830c9778
	ctx.lr = 0x830C9C1C;
	sub_830C9778(ctx, base);
	// 830C9C1C: 4BFFF6CD  bl 0x830c92e8
	ctx.lr = 0x830C9C20;
	sub_830C92E8(ctx, base);
	// 830C9C20: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 830C9C24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830C9C28: 41990008  bgt cr6, 0x830c9c30
	if ctx.cr[6].gt {
	pc = 0x830C9C30; continue 'dispatch;
	}
	// 830C9C2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C9C30: 80610110  lwz r3, 0x110(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 830C9C34: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830C9C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9C3C: 419A0008  beq cr6, 0x830c9c44
	if ctx.cr[6].eq {
	pc = 0x830C9C44; continue 'dispatch;
	}
	// 830C9C40: 4B1F6C51  bl 0x822c0890
	ctx.lr = 0x830C9C44;
	sub_822C0890(ctx, base);
	// 830C9C44: 80610108  lwz r3, 0x108(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 830C9C48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9C4C: 419A0008  beq cr6, 0x830c9c54
	if ctx.cr[6].eq {
	pc = 0x830C9C54; continue 'dispatch;
	}
	// 830C9C50: 4B1F6C41  bl 0x822c0890
	ctx.lr = 0x830C9C54;
	sub_822C0890(ctx, base);
	// 830C9C54: 806101E0  lwz r3, 0x1e0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(480 as u32) ) } as u64;
	// 830C9C58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9C5C: 419A0008  beq cr6, 0x830c9c64
	if ctx.cr[6].eq {
	pc = 0x830C9C64; continue 'dispatch;
	}
	// 830C9C60: 4B1F6C31  bl 0x822c0890
	ctx.lr = 0x830C9C64;
	sub_822C0890(ctx, base);
	// 830C9C64: 806101D8  lwz r3, 0x1d8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(472 as u32) ) } as u64;
	// 830C9C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C9C6C: 419A0008  beq cr6, 0x830c9c74
	if ctx.cr[6].eq {
	pc = 0x830C9C74; continue 'dispatch;
	}
	// 830C9C70: 4B1F6C21  bl 0x822c0890
	ctx.lr = 0x830C9C74;
	sub_822C0890(ctx, base);
	// 830C9C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9C78: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 830C9C7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C9C80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C9C84: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C9C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C9C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830C9C90 size=28
    let mut pc: u32 = 0x830C9C90;
    'dispatch: loop {
        match pc {
            0x830C9C90 => {
    //   block [0x830C9C90..0x830C9CAC)
	// 830C9C90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C9C94: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830C9C98: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830C9C9C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830C9CA0: 386ABE08  addi r3, r10, -0x41f8
	ctx.r[3].s64 = ctx.r[10].s64 + -16888;
	// 830C9CA4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830C9CA8: 4BFFFC90  b 0x830c9938
	sub_830C9938(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C9CB0 size=560
    let mut pc: u32 = 0x830C9CB0;
    'dispatch: loop {
        match pc {
            0x830C9CB0 => {
    //   block [0x830C9CB0..0x830C9EE0)
	// 830C9CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9CB4: 480DE4B1  bl 0x831a8164
	ctx.lr = 0x830C9CB8;
	sub_831A8130(ctx, base);
	// 830C9CB8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9CBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830C9CC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C9CC4: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 830C9CC8: 409A0028  bne cr6, 0x830c9cf0
	if !ctx.cr[6].eq {
	pc = 0x830C9CF0; continue 'dispatch;
	}
	// 830C9CCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830C9CD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C9CD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C9CD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830C9CDC: 4BFFFFD5  bl 0x830c9cb0
	ctx.lr = 0x830C9CE0;
	sub_830C9CB0(ctx, base);
	// 830C9CE0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830C9CE4: 2B1F0020  cmplwi cr6, r31, 0x20
	ctx.cr[6].compare_u32(ctx.r[31].u32, 32 as u32, &mut ctx.xer);
	// 830C9CE8: 409AFFE8  bne cr6, 0x830c9cd0
	if !ctx.cr[6].eq {
	pc = 0x830C9CD0; continue 'dispatch;
	}
	// 830C9CEC: 480001EC  b 0x830c9ed8
	pc = 0x830C9ED8; continue 'dispatch;
	// 830C9CF0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830C9CF4: 4098000C  bge cr6, 0x830c9d00
	if !ctx.cr[6].lt {
	pc = 0x830C9D00; continue 'dispatch;
	}
	// 830C9CF8: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 830C9CFC: 48000010  b 0x830c9d0c
	pc = 0x830C9D0C; continue 'dispatch;
	// 830C9D00: 2F05001F  cmpwi cr6, r5, 0x1f
	ctx.cr[6].compare_i32(ctx.r[5].s32, 31, &mut ctx.xer);
	// 830C9D04: 40990008  ble cr6, 0x830c9d0c
	if !ctx.cr[6].gt {
	pc = 0x830C9D0C; continue 'dispatch;
	}
	// 830C9D08: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 830C9D0C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830C9D10: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830C9D14: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C9D18: 838B0010  lwz r28, 0x10(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9D1C: 480001A4  b 0x830c9ec0
	pc = 0x830C9EC0; continue 'dispatch;
	// 830C9D20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9D24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C9D28: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 830C9D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9D30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C9D38: 4E800421  bctrl
	ctx.lr = 0x830C9D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C9D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9D40: 4BF8A2F9  bl 0x83054038
	ctx.lr = 0x830C9D44;
	sub_83054038(ctx, base);
	// 830C9D44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C9D48: 4182001C  beq 0x830c9d64
	if ctx.cr[0].eq {
	pc = 0x830C9D64; continue 'dispatch;
	}
	// 830C9D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9D50: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9D54: 4BF8A2E5  bl 0x83054038
	ctx.lr = 0x830C9D58;
	sub_83054038(ctx, base);
	// 830C9D58: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830C9D5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830C9D60: 4800000C  b 0x830c9d6c
	pc = 0x830C9D6C; continue 'dispatch;
	// 830C9D64: 80BD0210  lwz r5, 0x210(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(528 as u32) ) } as u64;
	// 830C9D68: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9D6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830C9D70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C9D74: 64C68000  oris r6, r6, 0x8000
	ctx.r[6].u64 = ctx.r[6].u64 | 2147483648;
	// 830C9D78: 4BB18091  bl 0x82be1e08
	ctx.lr = 0x830C9D7C;
	sub_82BE1E08(ctx, base);
	// 830C9D7C: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 830C9D80: 389F00B4  addi r4, r31, 0xb4
	ctx.r[4].s64 = ctx.r[31].s64 + 180;
	// 830C9D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C9D88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9D8C: 419A000C  beq cr6, 0x830c9d98
	if ctx.cr[6].eq {
	pc = 0x830C9D98; continue 'dispatch;
	}
	// 830C9D90: 4BD44D99  bl 0x82e0eb28
	ctx.lr = 0x830C9D94;
	sub_82E0EB28(ctx, base);
	// 830C9D94: 48000014  b 0x830c9da8
	pc = 0x830C9DA8; continue 'dispatch;
	// 830C9D98: 4BD44E29  bl 0x82e0ebc0
	ctx.lr = 0x830C9D9C;
	sub_82E0EBC0(ctx, base);
	// 830C9D9C: 809D0208  lwz r4, 0x208(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(520 as u32) ) } as u64;
	// 830C9DA0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9DA4: 4BB0E95D  bl 0x82bd8700
	ctx.lr = 0x830C9DA8;
	sub_82BD8700(ctx, base);
	// 830C9DA8: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 830C9DAC: 389F00BC  addi r4, r31, 0xbc
	ctx.r[4].s64 = ctx.r[31].s64 + 188;
	// 830C9DB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C9DB8: 419A000C  beq cr6, 0x830c9dc4
	if ctx.cr[6].eq {
	pc = 0x830C9DC4; continue 'dispatch;
	}
	// 830C9DBC: 4BD44E65  bl 0x82e0ec20
	ctx.lr = 0x830C9DC0;
	sub_82E0EC20(ctx, base);
	// 830C9DC0: 48000014  b 0x830c9dd4
	pc = 0x830C9DD4; continue 'dispatch;
	// 830C9DC4: 4BD44EED  bl 0x82e0ecb0
	ctx.lr = 0x830C9DC8;
	sub_82E0ECB0(ctx, base);
	// 830C9DC8: 809D020C  lwz r4, 0x20c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(524 as u32) ) } as u64;
	// 830C9DCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9DD0: 4BB0E679  bl 0x82bd8448
	ctx.lr = 0x830C9DD4;
	sub_82BD8448(ctx, base);
	// 830C9DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C9DD8: 4BFFF509  bl 0x830c92e0
	ctx.lr = 0x830C9DDC;
	sub_830C92E0(ctx, base);
	// 830C9DDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C9DE0: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 830C9DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9DE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C9DEC: 40820008  bne 0x830c9df4
	if !ctx.cr[0].eq {
	pc = 0x830C9DF4; continue 'dispatch;
	}
	// 830C9DF0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C9DF4: 4B21B4F5  bl 0x822e52e8
	ctx.lr = 0x830C9DF8;
	sub_822E52E8(ctx, base);
	// 830C9DF8: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9DFC: 388000C8  li r4, 0xc8
	ctx.r[4].s64 = 200;
	// 830C9E00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830C9E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9E08: 41820094  beq 0x830c9e9c
	if ctx.cr[0].eq {
	pc = 0x830C9E9C; continue 'dispatch;
	}
	// 830C9E0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C9E10: 4B21B4D9  bl 0x822e52e8
	ctx.lr = 0x830C9E14;
	sub_822E52E8(ctx, base);
	// 830C9E14: 395F0058  addi r10, r31, 0x58
	ctx.r[10].s64 = ctx.r[31].s64 + 88;
	// 830C9E18: 813F005C  lwz r9, 0x5c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830C9E1C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830C9E20: 811F0060  lwz r8, 0x60(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830C9E24: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830C9E28: 80FF0064  lwz r7, 0x64(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C9E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9E30: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830C9E34: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830C9E38: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 830C9E3C: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C9E40: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C9E44: C1A10064  lfs f13, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830C9E48: C181006C  lfs f12, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830C9E4C: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9E50: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C9E54: D8010080  stfd f0, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[0].u64 ) };
	// 830C9E58: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 830C9E5C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9E60: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 830C9E64: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 830C9E68: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9E6C: D9810088  stfd f12, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[12].u64 ) };
	// 830C9E70: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 830C9E74: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830C9E78: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 830C9E7C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830C9E80: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830C9E84: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9E88: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 830C9E8C: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 830C9E90: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830C9E94: 4BD4491D  bl 0x82e0e7b0
	ctx.lr = 0x830C9E98;
	sub_82E0E7B0(ctx, base);
	// 830C9E98: 4800000C  b 0x830c9ea4
	pc = 0x830C9EA4; continue 'dispatch;
	// 830C9E9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C9EA0: 4B21B449  bl 0x822e52e8
	ctx.lr = 0x830C9EA4;
	sub_822E52E8(ctx, base);
	// 830C9EA4: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 830C9EA8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C9EAC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830C9EB0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830C9EB4: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 830C9EB8: 4BB13A31  bl 0x82bdd8e8
	ctx.lr = 0x830C9EBC;
	sub_82BDD8E8(ctx, base);
	// 830C9EBC: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830C9EC0: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830C9EC4: 409AFE5C  bne cr6, 0x830c9d20
	if !ctx.cr[6].eq {
	pc = 0x830C9D20; continue 'dispatch;
	}
	// 830C9EC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C9ECC: 388000C8  li r4, 0xc8
	ctx.r[4].s64 = 200;
	// 830C9ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C9ED4: 4B21B415  bl 0x822e52e8
	ctx.lr = 0x830C9ED8;
	sub_822E52E8(ctx, base);
	// 830C9ED8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 830C9EDC: 480DE2D8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C9EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C9EE0 size=428
    let mut pc: u32 = 0x830C9EE0;
    'dispatch: loop {
        match pc {
            0x830C9EE0 => {
    //   block [0x830C9EE0..0x830CA08C)
	// 830C9EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C9EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C9EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C9EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C9EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C9EF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C9EF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C9EFC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830C9F00: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 830C9F04: 397F0074  addi r11, r31, 0x74
	ctx.r[11].s64 = ctx.r[31].s64 + 116;
	// 830C9F08: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C9F0C: 7D3FF050  subf r9, r31, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 830C9F10: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830C9F14: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830C9F18: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C9F1C: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830C9F20: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C9F24: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830C9F28: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C9F2C: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 830C9F30: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830C9F34: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 830C9F38: 811E0018  lwz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C9F3C: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 830C9F40: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830C9F44: 911F001C  stw r8, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 830C9F48: 811E0020  lwz r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C9F4C: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 830C9F50: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 830C9F54: 911F0024  stw r8, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 830C9F58: 891E0028  lbz r8, 0x28(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830C9F5C: 991F0028  stb r8, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u8 ) };
	// 830C9F60: 811E002C  lwz r8, 0x2c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 830C9F64: 911F002C  stw r8, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 830C9F68: 811E0030  lwz r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C9F6C: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 830C9F70: 811E0034  lwz r8, 0x34(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830C9F74: 911F0034  stw r8, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 830C9F78: 811E0038  lwz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C9F7C: 911F0038  stw r8, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u32 ) };
	// 830C9F80: 811E003C  lwz r8, 0x3c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 830C9F84: 911F003C  stw r8, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 830C9F88: 811E0040  lwz r8, 0x40(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 830C9F8C: 911F0040  stw r8, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 830C9F90: 891E0044  lbz r8, 0x44(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 830C9F94: 991F0044  stb r8, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[8].u8 ) };
	// 830C9F98: C01E0048  lfs f0, 0x48(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9F9C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830C9FA0: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9FA4: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830C9FA8: 811E0050  lwz r8, 0x50(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C9FAC: 911F0050  stw r8, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 830C9FB0: 891E0054  lbz r8, 0x54(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C9FB4: 991F0054  stb r8, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u8 ) };
	// 830C9FB8: 811E0058  lwz r8, 0x58(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C9FBC: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 830C9FC0: 811E005C  lwz r8, 0x5c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 830C9FC4: 911F005C  stw r8, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 830C9FC8: 811E0060  lwz r8, 0x60(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 830C9FCC: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 830C9FD0: 811E0064  lwz r8, 0x64(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 830C9FD4: 911F0064  stw r8, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 830C9FD8: C01E0068  lfs f0, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830C9FDC: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830C9FE0: 811E006C  lwz r8, 0x6c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 830C9FE4: 911F006C  stw r8, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 830C9FE8: 891E0070  lbz r8, 0x70(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 830C9FEC: 991F0070  stb r8, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[8].u8 ) };
	// 830C9FF0: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830C9FF4: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830C9FF8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C9FFC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830CA000: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA004: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830CA008: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830CA00C: 4082FFE4  bne 0x830c9ff0
	if !ctx.cr[0].eq {
	pc = 0x830C9FF0; continue 'dispatch;
	}
	// 830CA010: 397F0094  addi r11, r31, 0x94
	ctx.r[11].s64 = ctx.r[31].s64 + 148;
	// 830CA014: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830CA018: 7D0B482E  lwzx r8, r11, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830CA01C: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830CA020: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830CA024: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830CA028: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA02C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830CA030: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830CA034: 4082FFE4  bne 0x830ca018
	if !ctx.cr[0].eq {
	pc = 0x830CA018; continue 'dispatch;
	}
	// 830CA038: 813E00B4  lwz r9, 0xb4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 830CA03C: 397E00B4  addi r11, r30, 0xb4
	ctx.r[11].s64 = ctx.r[30].s64 + 180;
	// 830CA040: 395F00B4  addi r10, r31, 0xb4
	ctx.r[10].s64 = ctx.r[31].s64 + 180;
	// 830CA044: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 830CA048: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 830CA04C: 913F00B4  stw r9, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[9].u32 ) };
	// 830CA050: 4B1FA411  bl 0x822c4460
	ctx.lr = 0x830CA054;
	sub_822C4460(ctx, base);
	// 830CA054: 397E00BC  addi r11, r30, 0xbc
	ctx.r[11].s64 = ctx.r[30].s64 + 188;
	// 830CA058: 395F00BC  addi r10, r31, 0xbc
	ctx.r[10].s64 = ctx.r[31].s64 + 188;
	// 830CA05C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 830CA060: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 830CA064: 817E00BC  lwz r11, 0xbc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) } as u64;
	// 830CA068: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 830CA06C: 4B1FA3F5  bl 0x822c4460
	ctx.lr = 0x830CA070;
	sub_822C4460(ctx, base);
	// 830CA070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CA074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CA078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CA07C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CA080: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CA084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CA088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA090 size=120
    let mut pc: u32 = 0x830CA090;
    'dispatch: loop {
        match pc {
            0x830CA090 => {
    //   block [0x830CA090..0x830CA108)
	// 830CA090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CA098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CA09C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CA0A0: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA0A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CA0A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830CA0AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA0B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CA0B4: 4BFFF6C5  bl 0x830c9778
	ctx.lr = 0x830CA0B8;
	sub_830C9778(ctx, base);
	// 830CA0B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CA0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CA0C0: 4BFFFE21  bl 0x830c9ee0
	ctx.lr = 0x830CA0C4;
	sub_830C9EE0(ctx, base);
	// 830CA0C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830CA0C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA0CC: 4BFFFE15  bl 0x830c9ee0
	ctx.lr = 0x830CA0D0;
	sub_830C9EE0(ctx, base);
	// 830CA0D0: 80610110  lwz r3, 0x110(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 830CA0D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CA0D8: 419A0008  beq cr6, 0x830ca0e0
	if ctx.cr[6].eq {
	pc = 0x830CA0E0; continue 'dispatch;
	}
	// 830CA0DC: 4B1F67B5  bl 0x822c0890
	ctx.lr = 0x830CA0E0;
	sub_822C0890(ctx, base);
	// 830CA0E0: 80610108  lwz r3, 0x108(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 830CA0E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CA0E8: 419A0008  beq cr6, 0x830ca0f0
	if ctx.cr[6].eq {
	pc = 0x830CA0F0; continue 'dispatch;
	}
	// 830CA0EC: 4B1F67A5  bl 0x822c0890
	ctx.lr = 0x830CA0F0;
	sub_822C0890(ctx, base);
	// 830CA0F0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 830CA0F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CA0F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CA0FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CA100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CA104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830CA108 size=128
    let mut pc: u32 = 0x830CA108;
    'dispatch: loop {
        match pc {
            0x830CA108 => {
    //   block [0x830CA108..0x830CA188)
	// 830CA108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA10C: 480DE055  bl 0x831a8160
	ctx.lr = 0x830CA110;
	sub_831A8130(ctx, base);
	// 830CA110: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA114: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830CA118: 98E100C7  stb r7, 0xc7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(199 as u32), ctx.r[7].u8 ) };
	// 830CA11C: 394000C4  li r10, 0xc4
	ctx.r[10].s64 = 196;
	// 830CA120: 7D7D2850  subf r11, r29, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 830CA124: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CA128: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830CA12C: 7FEB53D7  divw. r31, r11, r10
	ctx.r[31].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830CA130: 40810048  ble 0x830ca178
	if !ctx.cr[0].gt {
	pc = 0x830CA178; continue 'dispatch;
	}
	// 830CA134: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 830CA138: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830CA13C: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 830CA140: 386100C7  addi r3, r1, 0xc7
	ctx.r[3].s64 = ctx.r[1].s64 + 199;
	// 830CA144: 1D7E00C4  mulli r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 * 196;
	// 830CA148: 7F8BEA14  add r28, r11, r29
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830CA14C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CA150: 4BFFFA99  bl 0x830c9be8
	ctx.lr = 0x830CA154;
	sub_830C9BE8(ctx, base);
	// 830CA154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CA158: 41820014  beq 0x830ca16c
	if ctx.cr[0].eq {
	pc = 0x830CA16C; continue 'dispatch;
	}
	// 830CA15C: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830CA160: 3BBC00C4  addi r29, r28, 0xc4
	ctx.r[29].s64 = ctx.r[28].s64 + 196;
	// 830CA164: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 830CA168: 48000008  b 0x830ca170
	pc = 0x830CA170; continue 'dispatch;
	// 830CA16C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830CA170: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830CA174: 4199FFC0  bgt cr6, 0x830ca134
	if ctx.cr[6].gt {
	pc = 0x830CA134; continue 'dispatch;
	}
	// 830CA178: 93BA0000  stw r29, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830CA17C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CA180: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CA184: 480DE02C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830CA188 size=128
    let mut pc: u32 = 0x830CA188;
    'dispatch: loop {
        match pc {
            0x830CA188 => {
    //   block [0x830CA188..0x830CA208)
	// 830CA188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA18C: 480DDFD5  bl 0x831a8160
	ctx.lr = 0x830CA190;
	sub_831A8130(ctx, base);
	// 830CA190: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA194: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830CA198: 98E100C7  stb r7, 0xc7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(199 as u32), ctx.r[7].u8 ) };
	// 830CA19C: 394000C4  li r10, 0xc4
	ctx.r[10].s64 = 196;
	// 830CA1A0: 7D7D2850  subf r11, r29, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 830CA1A4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CA1A8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830CA1AC: 7FEB53D7  divw. r31, r11, r10
	ctx.r[31].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830CA1B0: 40810048  ble 0x830ca1f8
	if !ctx.cr[0].gt {
	pc = 0x830CA1F8; continue 'dispatch;
	}
	// 830CA1B4: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 830CA1B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830CA1BC: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 830CA1C0: 386100C7  addi r3, r1, 0xc7
	ctx.r[3].s64 = ctx.r[1].s64 + 199;
	// 830CA1C4: 1D7E00C4  mulli r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 * 196;
	// 830CA1C8: 7F8BEA14  add r28, r11, r29
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830CA1CC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CA1D0: 4BFFFA19  bl 0x830c9be8
	ctx.lr = 0x830CA1D4;
	sub_830C9BE8(ctx, base);
	// 830CA1D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CA1D8: 40820014  bne 0x830ca1ec
	if !ctx.cr[0].eq {
	pc = 0x830CA1EC; continue 'dispatch;
	}
	// 830CA1DC: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830CA1E0: 3BBC00C4  addi r29, r28, 0xc4
	ctx.r[29].s64 = ctx.r[28].s64 + 196;
	// 830CA1E4: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 830CA1E8: 48000008  b 0x830ca1f0
	pc = 0x830CA1F0; continue 'dispatch;
	// 830CA1EC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830CA1F0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830CA1F4: 4199FFC0  bgt cr6, 0x830ca1b4
	if ctx.cr[6].gt {
	pc = 0x830CA1B4; continue 'dispatch;
	}
	// 830CA1F8: 93BA0000  stw r29, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830CA1FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CA200: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CA204: 480DDFAC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA208 size=128
    let mut pc: u32 = 0x830CA208;
    'dispatch: loop {
        match pc {
            0x830CA208 => {
    //   block [0x830CA208..0x830CA288)
	// 830CA208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CA210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CA214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CA21C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA220: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA224: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CA228: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830CA22C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA230: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA234: 40980014  bge cr6, 0x830ca248
	if !ctx.cr[6].lt {
	pc = 0x830CA248; continue 'dispatch;
	}
	// 830CA238: 394300C4  addi r10, r3, 0xc4
	ctx.r[10].s64 = ctx.r[3].s64 + 196;
	// 830CA23C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830CA240: 4BFFFCA1  bl 0x830c9ee0
	ctx.lr = 0x830CA244;
	sub_830C9EE0(ctx, base);
	// 830CA244: 4800002C  b 0x830ca270
	pc = 0x830CA270; continue 'dispatch;
	// 830CA248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CA24C: 419A0008  beq cr6, 0x830ca254
	if ctx.cr[6].eq {
	pc = 0x830CA254; continue 'dispatch;
	}
	// 830CA250: 4BFFF529  bl 0x830c9778
	ctx.lr = 0x830CA254;
	sub_830C9778(ctx, base);
	// 830CA254: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA258: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA25C: 394A00C4  addi r10, r10, 0xc4
	ctx.r[10].s64 = ctx.r[10].s64 + 196;
	// 830CA260: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830CA264: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA268: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA26C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830CA270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CA274: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830CA278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CA27C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CA280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CA284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA288 size=316
    let mut pc: u32 = 0x830CA288;
    'dispatch: loop {
        match pc {
            0x830CA288 => {
    //   block [0x830CA288..0x830CA3C4)
	// 830CA288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA28C: 480DDEC9  bl 0x831a8154
	ctx.lr = 0x830CA290;
	sub_831A8130(ctx, base);
	// 830CA290: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA294: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CA298: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830CA29C: 3AE000C4  li r23, 0xc4
	ctx.r[23].s64 = 196;
	// 830CA2A0: 93410194  stw r26, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[26].u32 ) };
	// 830CA2A4: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 830CA2A8: 7D5AC850  subf r10, r26, r25
	ctx.r[10].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 830CA2AC: 7FABBBD7  divw. r29, r11, r23
	ctx.r[29].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830CA2B0: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 830CA2B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830CA2B8: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 830CA2BC: 41820030  beq 0x830ca2ec
	if ctx.cr[0].eq {
	pc = 0x830CA2EC; continue 'dispatch;
	}
	// 830CA2C0: 7D1C5BD6  divw r8, r28, r11
	ctx.r[8].s32 = ctx.r[28].s32 / ctx.r[11].s32;
	// 830CA2C4: 578A083E  rotlwi r10, r28, 1
	ctx.r[10].u64 = ((ctx.r[28].u32).rotate_left(1)) as u64;
	// 830CA2C8: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830CA2CC: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 830CA2D0: 7D48E051  subf. r10, r8, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830CA2D4: 7D683878  andc r8, r11, r7
	ctx.r[8].u64 = ctx.r[11].u64 & !ctx.r[7].u64;
	// 830CA2D8: 0CCB0000  twi 6, r11, 0
	// 830CA2DC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 830CA2E0: 0CA8FFFF  twi 5, r8, -1
	// 830CA2E4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830CA2E8: 4082FFD8  bne 0x830ca2c0
	if !ctx.cr[0].eq {
	pc = 0x830CA2C0; continue 'dispatch;
	}
	// 830CA2EC: 7F1C4800  cmpw cr6, r28, r9
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830CA2F0: 409800CC  bge cr6, 0x830ca3bc
	if !ctx.cr[6].lt {
	pc = 0x830CA3BC; continue 'dispatch;
	}
	// 830CA2F4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830CA2F8: 409900C4  ble cr6, 0x830ca3bc
	if !ctx.cr[6].gt {
	pc = 0x830CA3BC; continue 'dispatch;
	}
	// 830CA2FC: 1D7C00C4  mulli r11, r28, 0xc4
	ctx.r[11].s64 = ctx.r[28].s64 * 196;
	// 830CA300: 1F1D00C4  mulli r24, r29, 0xc4
	ctx.r[24].s64 = ctx.r[29].s64 * 196;
	// 830CA304: 7FCBD214  add r30, r11, r26
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830CA308: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CA30C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830CA310: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 830CA314: 4BFFF465  bl 0x830c9778
	ctx.lr = 0x830CA318;
	sub_830C9778(ctx, base);
	// 830CA318: 7D7EC214  add r11, r30, r24
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[24].u64;
	// 830CA31C: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830CA320: 409A000C  bne cr6, 0x830ca32c
	if !ctx.cr[6].eq {
	pc = 0x830CA32C; continue 'dispatch;
	}
	// 830CA324: 39610194  addi r11, r1, 0x194
	ctx.r[11].s64 = ctx.r[1].s64 + 404;
	// 830CA328: 48000050  b 0x830ca378
	pc = 0x830CA378; continue 'dispatch;
	// 830CA32C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830CA330: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 830CA334: 48000044  b 0x830ca378
	pc = 0x830CA378; continue 'dispatch;
	// 830CA338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA33C: 4BFFFBA5  bl 0x830c9ee0
	ctx.lr = 0x830CA340;
	sub_830C9EE0(ctx, base);
	// 830CA340: 7D7FC850  subf r11, r31, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 830CA344: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 830CA348: 7D6BBBD6  divw r11, r11, r23
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 830CA34C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830CA350: 40980014  bge cr6, 0x830ca364
	if !ctx.cr[6].lt {
	pc = 0x830CA364; continue 'dispatch;
	}
	// 830CA354: 7D58FA14  add r10, r24, r31
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[31].u64;
	// 830CA358: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830CA35C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830CA360: 48000018  b 0x830ca378
	pc = 0x830CA378; continue 'dispatch;
	// 830CA364: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 830CA368: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 830CA36C: 1D4A00C4  mulli r10, r10, 0xc4
	ctx.r[10].s64 = ctx.r[10].s64 * 196;
	// 830CA370: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 830CA374: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830CA378: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA37C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830CA380: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA384: 409AFFB4  bne cr6, 0x830ca338
	if !ctx.cr[6].eq {
	pc = 0x830CA338; continue 'dispatch;
	}
	// 830CA388: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830CA38C: 4BFFFB55  bl 0x830c9ee0
	ctx.lr = 0x830CA390;
	sub_830C9EE0(ctx, base);
	// 830CA390: 80610120  lwz r3, 0x120(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) } as u64;
	// 830CA394: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CA398: 419A0008  beq cr6, 0x830ca3a0
	if ctx.cr[6].eq {
	pc = 0x830CA3A0; continue 'dispatch;
	}
	// 830CA39C: 4B1F64F5  bl 0x822c0890
	ctx.lr = 0x830CA3A0;
	sub_822C0890(ctx, base);
	// 830CA3A0: 80610118  lwz r3, 0x118(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) } as u64;
	// 830CA3A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CA3A8: 419A0008  beq cr6, 0x830ca3b0
	if ctx.cr[6].eq {
	pc = 0x830CA3B0; continue 'dispatch;
	}
	// 830CA3AC: 4B1F64E5  bl 0x822c0890
	ctx.lr = 0x830CA3B0;
	sub_822C0890(ctx, base);
	// 830CA3B0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830CA3B4: 3BDEFF3C  addi r30, r30, -0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + -196;
	// 830CA3B8: 4181FF50  bgt 0x830ca308
	if ctx.cr[0].gt {
	pc = 0x830CA308; continue 'dispatch;
	}
	// 830CA3BC: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 830CA3C0: 480DDDE4  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA3C8 size=100
    let mut pc: u32 = 0x830CA3C8;
    'dispatch: loop {
        match pc {
            0x830CA3C8 => {
    //   block [0x830CA3C8..0x830CA42C)
	// 830CA3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CA3D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CA3D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CA3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA3DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830CA3E0: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA3E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830CA3E8: 419A002C  beq cr6, 0x830ca414
	if ctx.cr[6].eq {
	pc = 0x830CA414; continue 'dispatch;
	}
	// 830CA3EC: 48000014  b 0x830ca400
	pc = 0x830CA400; continue 'dispatch;
	// 830CA3F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830CA3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CA3F8: 4BFFF709  bl 0x830c9b00
	ctx.lr = 0x830CA3FC;
	sub_830C9B00(ctx, base);
	// 830CA3FC: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA400: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CA404: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830CA408: 409AFFE8  bne cr6, 0x830ca3f0
	if !ctx.cr[6].eq {
	pc = 0x830CA3F0; continue 'dispatch;
	}
	// 830CA40C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA410: 4B1F5E59  bl 0x822c0268
	ctx.lr = 0x830CA414;
	sub_822C0268(ctx, base);
	// 830CA414: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CA418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CA41C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CA420: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CA424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CA428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA430 size=104
    let mut pc: u32 = 0x830CA430;
    'dispatch: loop {
        match pc {
            0x830CA430 => {
    //   block [0x830CA430..0x830CA498)
	// 830CA430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA434: 480DDD35  bl 0x831a8168
	ctx.lr = 0x830CA438;
	sub_831A8130(ctx, base);
	// 830CA438: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA43C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830CA440: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830CA444: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830CA448: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830CA44C: 48000014  b 0x830ca460
	pc = 0x830CA460; continue 'dispatch;
	// 830CA450: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA454: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA458: 4BFFFDB1  bl 0x830ca208
	ctx.lr = 0x830CA45C;
	sub_830CA208(ctx, base);
	// 830CA45C: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA460: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830CA464: 409AFFEC  bne cr6, 0x830ca450
	if !ctx.cr[6].eq {
	pc = 0x830CA450; continue 'dispatch;
	}
	// 830CA468: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA46C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CA470: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA474: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830CA478: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830CA47C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830CA480: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830CA484: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830CA488: 4BFFFF41  bl 0x830ca3c8
	ctx.lr = 0x830CA48C;
	sub_830CA3C8(ctx, base);
	// 830CA48C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA490: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830CA494: 480DDD24  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA498 size=120
    let mut pc: u32 = 0x830CA498;
    'dispatch: loop {
        match pc {
            0x830CA498 => {
    //   block [0x830CA498..0x830CA510)
	// 830CA498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CA4A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CA4A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CA4A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA4AC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830CA4B0: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830CA4B4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830CA4B8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830CA4BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CA4C0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830CA4C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830CA4C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CA4CC: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA4D0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830CA4D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830CA4D8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830CA4DC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830CA4E0: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 830CA4E4: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830CA4E8: 4BFFFF49  bl 0x830ca430
	ctx.lr = 0x830CA4EC;
	sub_830CA430(ctx, base);
	// 830CA4EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA4F0: 4BFFFED9  bl 0x830ca3c8
	ctx.lr = 0x830CA4F4;
	sub_830CA3C8(ctx, base);
	// 830CA4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CA4F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CA4FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CA500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CA504: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CA508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CA50C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA510 size=460
    let mut pc: u32 = 0x830CA510;
    'dispatch: loop {
        match pc {
            0x830CA510 => {
    //   block [0x830CA510..0x830CA6DC)
	// 830CA510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA514: 480DDC49  bl 0x831a815c
	ctx.lr = 0x830CA518;
	sub_831A8130(ctx, base);
	// 830CA518: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA51C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830CA520: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830CA524: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830CA528: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830CA52C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830CA530: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830CA534: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 830CA538: 7F1BD000  cmpw cr6, r27, r26
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830CA53C: 419900B4  bgt cr6, 0x830ca5f0
	if ctx.cr[6].gt {
	pc = 0x830CA5F0; continue 'dispatch;
	}
	// 830CA540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA544: 4BFFF625  bl 0x830c9b68
	ctx.lr = 0x830CA548;
	sub_830C9B68(ctx, base);
	// 830CA548: 7F1B1800  cmpw cr6, r27, r3
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830CA54C: 419900A4  bgt cr6, 0x830ca5f0
	if ctx.cr[6].gt {
	pc = 0x830CA5F0; continue 'dispatch;
	}
	// 830CA550: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CA558: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CA55C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830CA560: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CA564: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830CA568: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CA56C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830CA570: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CA574: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA578: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830CA57C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830CA580: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA584: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830CA588: 4BFFFF11  bl 0x830ca498
	ctx.lr = 0x830CA58C;
	sub_830CA498(ctx, base);
	// 830CA58C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CA590: 4BFFFE39  bl 0x830ca3c8
	ctx.lr = 0x830CA594;
	sub_830CA3C8(ctx, base);
	// 830CA594: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830CA598: 419A0020  beq cr6, 0x830ca5b8
	if ctx.cr[6].eq {
	pc = 0x830CA5B8; continue 'dispatch;
	}
	// 830CA59C: 7FBFE850  subf r29, r31, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 830CA5A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA5A4: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 830CA5A8: 4BFFF939  bl 0x830c9ee0
	ctx.lr = 0x830CA5AC;
	sub_830C9EE0(ctx, base);
	// 830CA5AC: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA5B0: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830CA5B4: 409AFFEC  bne cr6, 0x830ca5a0
	if !ctx.cr[6].eq {
	pc = 0x830CA5A0; continue 'dispatch;
	}
	// 830CA5B8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA5BC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA5C0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA5C4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CA5C8: 419A0020  beq cr6, 0x830ca5e8
	if ctx.cr[6].eq {
	pc = 0x830CA5E8; continue 'dispatch;
	}
	// 830CA5CC: 3BFFFF3C  addi r31, r31, -0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + -196;
	// 830CA5D0: 3B9CFF3C  addi r28, r28, -0xc4
	ctx.r[28].s64 = ctx.r[28].s64 + -196;
	// 830CA5D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA5D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CA5DC: 4BFFF905  bl 0x830c9ee0
	ctx.lr = 0x830CA5E0;
	sub_830C9EE0(ctx, base);
	// 830CA5E0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA5E4: 409AFFE8  bne cr6, 0x830ca5cc
	if !ctx.cr[6].eq {
	pc = 0x830CA5CC; continue 'dispatch;
	}
	// 830CA5E8: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830CA5EC: 480000E4  b 0x830ca6d0
	pc = 0x830CA6D0; continue 'dispatch;
	// 830CA5F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA5F4: 4BFFF575  bl 0x830c9b68
	ctx.lr = 0x830CA5F8;
	sub_830C9B68(ctx, base);
	// 830CA5F8: 7F1A1800  cmpw cr6, r26, r3
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830CA5FC: 419900A0  bgt cr6, 0x830ca69c
	if ctx.cr[6].gt {
	pc = 0x830CA69C; continue 'dispatch;
	}
	// 830CA600: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CA608: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CA60C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830CA610: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CA614: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830CA618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA61C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830CA620: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CA624: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA628: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830CA62C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830CA630: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA634: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830CA638: 4BFFFE61  bl 0x830ca498
	ctx.lr = 0x830CA63C;
	sub_830CA498(ctx, base);
	// 830CA63C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CA640: 4BFFFD89  bl 0x830ca3c8
	ctx.lr = 0x830CA644;
	sub_830CA3C8(ctx, base);
	// 830CA644: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CA648: 419A0020  beq cr6, 0x830ca668
	if ctx.cr[6].eq {
	pc = 0x830CA668; continue 'dispatch;
	}
	// 830CA64C: 7F9FE050  subf r28, r31, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 830CA650: 3BFFFF3C  addi r31, r31, -0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + -196;
	// 830CA654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA658: 7C7CFA14  add r3, r28, r31
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 830CA65C: 4BFFF885  bl 0x830c9ee0
	ctx.lr = 0x830CA660;
	sub_830C9EE0(ctx, base);
	// 830CA660: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CA664: 409AFFEC  bne cr6, 0x830ca650
	if !ctx.cr[6].eq {
	pc = 0x830CA650; continue 'dispatch;
	}
	// 830CA668: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA66C: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CA670: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CA674: 48000018  b 0x830ca68c
	pc = 0x830CA68C; continue 'dispatch;
	// 830CA678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA67C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA680: 4BFFF861  bl 0x830c9ee0
	ctx.lr = 0x830CA684;
	sub_830C9EE0(ctx, base);
	// 830CA684: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA688: 3BBD00C4  addi r29, r29, 0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + 196;
	// 830CA68C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA690: 409AFFE8  bne cr6, 0x830ca678
	if !ctx.cr[6].eq {
	pc = 0x830CA678; continue 'dispatch;
	}
	// 830CA694: 93B90000  stw r29, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830CA698: 48000038  b 0x830ca6d0
	pc = 0x830CA6D0; continue 'dispatch;
	// 830CA69C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CA6A0: 419A0024  beq cr6, 0x830ca6c4
	if ctx.cr[6].eq {
	pc = 0x830CA6C4; continue 'dispatch;
	}
	// 830CA6A4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830CA6A8: 419A001C  beq cr6, 0x830ca6c4
	if ctx.cr[6].eq {
	pc = 0x830CA6C4; continue 'dispatch;
	}
	// 830CA6AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830CA6B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830CA6B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CA6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA6BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA6C0: 4BFFFBC9  bl 0x830ca288
	ctx.lr = 0x830CA6C4;
	sub_830CA288(ctx, base);
	// 830CA6C4: 1D7A00C4  mulli r11, r26, 0xc4
	ctx.r[11].s64 = ctx.r[26].s64 * 196;
	// 830CA6C8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830CA6CC: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830CA6D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830CA6D4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830CA6D8: 480DDAD4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA6E0 size=208
    let mut pc: u32 = 0x830CA6E0;
    'dispatch: loop {
        match pc {
            0x830CA6E0 => {
    //   block [0x830CA6E0..0x830CA7B0)
	// 830CA6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA6E4: 480DDA7D  bl 0x831a8160
	ctx.lr = 0x830CA6E8;
	sub_831A8130(ctx, base);
	// 830CA6E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA6EC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CA6F0: 992100D7  stb r9, 0xd7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(215 as u32), ctx.r[9].u8 ) };
	// 830CA6F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830CA6F8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830CA6FC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830CA700: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830CA704: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830CA708: 48000048  b 0x830ca750
	pc = 0x830CA750; continue 'dispatch;
	// 830CA70C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830CA710: 419A0060  beq cr6, 0x830ca770
	if ctx.cr[6].eq {
	pc = 0x830CA770; continue 'dispatch;
	}
	// 830CA714: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CA718: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CA71C: 386100D7  addi r3, r1, 0xd7
	ctx.r[3].s64 = ctx.r[1].s64 + 215;
	// 830CA720: 4BFFF4C9  bl 0x830c9be8
	ctx.lr = 0x830CA724;
	sub_830C9BE8(ctx, base);
	// 830CA724: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CA728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA72C: 41820014  beq 0x830ca740
	if ctx.cr[0].eq {
	pc = 0x830CA740; continue 'dispatch;
	}
	// 830CA730: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CA734: 4BFFF7AD  bl 0x830c9ee0
	ctx.lr = 0x830CA738;
	sub_830C9EE0(ctx, base);
	// 830CA738: 3B9C00C4  addi r28, r28, 0xc4
	ctx.r[28].s64 = ctx.r[28].s64 + 196;
	// 830CA73C: 48000010  b 0x830ca74c
	pc = 0x830CA74C; continue 'dispatch;
	// 830CA740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA744: 4BFFF79D  bl 0x830c9ee0
	ctx.lr = 0x830CA748;
	sub_830C9EE0(ctx, base);
	// 830CA748: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA74C: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CA750: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CA754: 409AFFB8  bne cr6, 0x830ca70c
	if !ctx.cr[6].eq {
	pc = 0x830CA70C; continue 'dispatch;
	}
	// 830CA758: 48000018  b 0x830ca770
	pc = 0x830CA770; continue 'dispatch;
	// 830CA75C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA764: 4BFFF77D  bl 0x830c9ee0
	ctx.lr = 0x830CA768;
	sub_830C9EE0(ctx, base);
	// 830CA768: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA76C: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CA770: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CA774: 409AFFE8  bne cr6, 0x830ca75c
	if !ctx.cr[6].eq {
	pc = 0x830CA75C; continue 'dispatch;
	}
	// 830CA778: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830CA77C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830CA780: 419A0020  beq cr6, 0x830ca7a0
	if ctx.cr[6].eq {
	pc = 0x830CA7A0; continue 'dispatch;
	}
	// 830CA784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA78C: 4BFFF755  bl 0x830c9ee0
	ctx.lr = 0x830CA790;
	sub_830C9EE0(ctx, base);
	// 830CA790: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA794: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CA798: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830CA79C: 409AFFE8  bne cr6, 0x830ca784
	if !ctx.cr[6].eq {
	pc = 0x830CA784; continue 'dispatch;
	}
	// 830CA7A0: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830CA7A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CA7A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CA7AC: 480DDA04  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA7B0 size=224
    let mut pc: u32 = 0x830CA7B0;
    'dispatch: loop {
        match pc {
            0x830CA7B0 => {
    //   block [0x830CA7B0..0x830CA890)
	// 830CA7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA7B4: 480DD9AD  bl 0x831a8160
	ctx.lr = 0x830CA7B8;
	sub_831A8130(ctx, base);
	// 830CA7B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA7BC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CA7C0: 992100D7  stb r9, 0xd7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(215 as u32), ctx.r[9].u8 ) };
	// 830CA7C4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830CA7C8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830CA7CC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830CA7D0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830CA7D4: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 830CA7D8: 48000050  b 0x830ca828
	pc = 0x830CA828; continue 'dispatch;
	// 830CA7DC: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA7E0: 419A007C  beq cr6, 0x830ca85c
	if ctx.cr[6].eq {
	pc = 0x830CA85C; continue 'dispatch;
	}
	// 830CA7E4: 3BDEFF3C  addi r30, r30, -0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + -196;
	// 830CA7E8: 3BFFFF3C  addi r31, r31, -0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + -196;
	// 830CA7EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CA7F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CA7F4: 386100D7  addi r3, r1, 0xd7
	ctx.r[3].s64 = ctx.r[1].s64 + 215;
	// 830CA7F8: 4BFFF3F1  bl 0x830c9be8
	ctx.lr = 0x830CA7FC;
	sub_830C9BE8(ctx, base);
	// 830CA7FC: 3BBDFF3C  addi r29, r29, -0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + -196;
	// 830CA800: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CA804: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA808: 41820014  beq 0x830ca81c
	if ctx.cr[0].eq {
	pc = 0x830CA81C; continue 'dispatch;
	}
	// 830CA80C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA810: 4BFFF6D1  bl 0x830c9ee0
	ctx.lr = 0x830CA814;
	sub_830C9EE0(ctx, base);
	// 830CA814: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CA818: 48000010  b 0x830ca828
	pc = 0x830CA828; continue 'dispatch;
	// 830CA81C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CA820: 4BFFF6C1  bl 0x830c9ee0
	ctx.lr = 0x830CA824;
	sub_830C9EE0(ctx, base);
	// 830CA824: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA828: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CA82C: 409AFFB0  bne cr6, 0x830ca7dc
	if !ctx.cr[6].eq {
	pc = 0x830CA7DC; continue 'dispatch;
	}
	// 830CA830: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830CA834: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA838: 419A0048  beq cr6, 0x830ca880
	if ctx.cr[6].eq {
	pc = 0x830CA880; continue 'dispatch;
	}
	// 830CA83C: 3BFFFF3C  addi r31, r31, -0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + -196;
	// 830CA840: 3BBDFF3C  addi r29, r29, -0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + -196;
	// 830CA844: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA848: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA84C: 4BFFF695  bl 0x830c9ee0
	ctx.lr = 0x830CA850;
	sub_830C9EE0(ctx, base);
	// 830CA850: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830CA854: 409AFFE8  bne cr6, 0x830ca83c
	if !ctx.cr[6].eq {
	pc = 0x830CA83C; continue 'dispatch;
	}
	// 830CA858: 48000028  b 0x830ca880
	pc = 0x830CA880; continue 'dispatch;
	// 830CA85C: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CA860: 419A0020  beq cr6, 0x830ca880
	if ctx.cr[6].eq {
	pc = 0x830CA880; continue 'dispatch;
	}
	// 830CA864: 3BFFFF3C  addi r31, r31, -0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + -196;
	// 830CA868: 3BBDFF3C  addi r29, r29, -0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + -196;
	// 830CA86C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CA870: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CA874: 4BFFF66D  bl 0x830c9ee0
	ctx.lr = 0x830CA878;
	sub_830C9EE0(ctx, base);
	// 830CA878: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830CA87C: 409AFFE8  bne cr6, 0x830ca864
	if !ctx.cr[6].eq {
	pc = 0x830CA864; continue 'dispatch;
	}
	// 830CA880: 93BA0000  stw r29, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830CA884: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CA888: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CA88C: 480DD924  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA890 size=248
    let mut pc: u32 = 0x830CA890;
    'dispatch: loop {
        match pc {
            0x830CA890 => {
    //   block [0x830CA890..0x830CA988)
	// 830CA890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA894: 480DD8C9  bl 0x831a815c
	ctx.lr = 0x830CA898;
	sub_831A8130(ctx, base);
	// 830CA898: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA89C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CA8A0: 99210117  stb r9, 0x117(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(279 as u32), ctx.r[9].u8 ) };
	// 830CA8A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830CA8A8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830CA8AC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830CA8B0: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830CA8B4: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830CA8B8: 48000044  b 0x830ca8fc
	pc = 0x830CA8FC; continue 'dispatch;
	// 830CA8BC: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830CA8C0: 419A0044  beq cr6, 0x830ca904
	if ctx.cr[6].eq {
	pc = 0x830CA904; continue 'dispatch;
	}
	// 830CA8C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830CA8C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CA8CC: 38610117  addi r3, r1, 0x117
	ctx.r[3].s64 = ctx.r[1].s64 + 279;
	// 830CA8D0: 4BFFF319  bl 0x830c9be8
	ctx.lr = 0x830CA8D4;
	sub_830C9BE8(ctx, base);
	// 830CA8D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CA8D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA8DC: 41820014  beq 0x830ca8f0
	if ctx.cr[0].eq {
	pc = 0x830CA8F0; continue 'dispatch;
	}
	// 830CA8E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CA8E4: 4BFFF925  bl 0x830ca208
	ctx.lr = 0x830CA8E8;
	sub_830CA208(ctx, base);
	// 830CA8E8: 3B9C00C4  addi r28, r28, 0xc4
	ctx.r[28].s64 = ctx.r[28].s64 + 196;
	// 830CA8EC: 48000010  b 0x830ca8fc
	pc = 0x830CA8FC; continue 'dispatch;
	// 830CA8F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CA8F4: 4BFFF915  bl 0x830ca208
	ctx.lr = 0x830CA8F8;
	sub_830CA208(ctx, base);
	// 830CA8F8: 3BBD00C4  addi r29, r29, 0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + 196;
	// 830CA8FC: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830CA900: 409AFFBC  bne cr6, 0x830ca8bc
	if !ctx.cr[6].eq {
	pc = 0x830CA8BC; continue 'dispatch;
	}
	// 830CA904: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA908: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830CA90C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CA910: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830CA914: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830CA918: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830CA91C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CA920: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830CA924: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CA928: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830CA92C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 830CA930: 4BFFFB69  bl 0x830ca498
	ctx.lr = 0x830CA934;
	sub_830CA498(ctx, base);
	// 830CA934: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830CA938: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CA93C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA940: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830CA944: 4BFFFA85  bl 0x830ca3c8
	ctx.lr = 0x830CA948;
	sub_830CA3C8(ctx, base);
	// 830CA948: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CA94C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830CA950: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CA954: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830CA958: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830CA95C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830CA960: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CA964: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 830CA968: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CA96C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830CA970: 4BFFFB29  bl 0x830ca498
	ctx.lr = 0x830CA974;
	sub_830CA498(ctx, base);
	// 830CA974: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CA978: 4BFFFA51  bl 0x830ca3c8
	ctx.lr = 0x830CA97C;
	sub_830CA3C8(ctx, base);
	// 830CA97C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CA980: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830CA984: 480DD828  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA988 size=84
    let mut pc: u32 = 0x830CA988;
    'dispatch: loop {
        match pc {
            0x830CA988 => {
    //   block [0x830CA988..0x830CA9DC)
	// 830CA988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CA990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CA994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CA998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA99C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830CA9A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CA9A4: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA9A8: 419A001C  beq cr6, 0x830ca9c4
	if ctx.cr[6].eq {
	pc = 0x830CA9C4; continue 'dispatch;
	}
	// 830CA9AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830CA9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CA9B4: 4BFFF14D  bl 0x830c9b00
	ctx.lr = 0x830CA9B8;
	sub_830C9B00(ctx, base);
	// 830CA9B8: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CA9BC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CA9C0: 409AFFEC  bne cr6, 0x830ca9ac
	if !ctx.cr[6].eq {
	pc = 0x830CA9AC; continue 'dispatch;
	}
	// 830CA9C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CA9C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CA9CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CA9D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CA9D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CA9D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CA9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CA9E0 size=220
    let mut pc: u32 = 0x830CA9E0;
    'dispatch: loop {
        match pc {
            0x830CA9E0 => {
    //   block [0x830CA9E0..0x830CAABC)
	// 830CA9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CA9E4: 480DD77D  bl 0x831a8160
	ctx.lr = 0x830CA9E8;
	sub_831A8130(ctx, base);
	// 830CA9E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CA9EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830CA9F0: 98A100B7  stb r5, 0xb7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(183 as u32), ctx.r[5].u8 ) };
	// 830CA9F4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830CA9F8: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830CA9FC: 419A00B8  beq cr6, 0x830caab4
	if ctx.cr[6].eq {
	pc = 0x830CAAB4; continue 'dispatch;
	}
	// 830CAA00: 3BFB00C4  addi r31, r27, 0xc4
	ctx.r[31].s64 = ctx.r[27].s64 + 196;
	// 830CAA04: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830CAA08: 419A00AC  beq cr6, 0x830caab4
	if ctx.cr[6].eq {
	pc = 0x830CAAB4; continue 'dispatch;
	}
	// 830CAA0C: 3BBF00C4  addi r29, r31, 0xc4
	ctx.r[29].s64 = ctx.r[31].s64 + 196;
	// 830CAA10: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830CAA14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAA18: 386100B7  addi r3, r1, 0xb7
	ctx.r[3].s64 = ctx.r[1].s64 + 183;
	// 830CAA1C: 4BFFF1CD  bl 0x830c9be8
	ctx.lr = 0x830CAA20;
	sub_830C9BE8(ctx, base);
	// 830CAA20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CAA24: 4182001C  beq 0x830caa40
	if ctx.cr[0].eq {
	pc = 0x830CAA40; continue 'dispatch;
	}
	// 830CAA28: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CAA2C: 419A0078  beq cr6, 0x830caaa4
	if ctx.cr[6].eq {
	pc = 0x830CAAA4; continue 'dispatch;
	}
	// 830CAA30: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CAA34: 419A0070  beq cr6, 0x830caaa4
	if ctx.cr[6].eq {
	pc = 0x830CAAA4; continue 'dispatch;
	}
	// 830CAA38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830CAA3C: 48000054  b 0x830caa90
	pc = 0x830CAA90; continue 'dispatch;
	// 830CAA40: 38BDFE78  addi r5, r29, -0x188
	ctx.r[5].s64 = ctx.r[29].s64 + -392;
	// 830CAA44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAA48: 386100B7  addi r3, r1, 0xb7
	ctx.r[3].s64 = ctx.r[1].s64 + 183;
	// 830CAA4C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830CAA50: 4BFFF199  bl 0x830c9be8
	ctx.lr = 0x830CAA54;
	sub_830C9BE8(ctx, base);
	// 830CAA54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CAA58: 4182004C  beq 0x830caaa4
	if ctx.cr[0].eq {
	pc = 0x830CAAA4; continue 'dispatch;
	}
	// 830CAA5C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830CAA60: 3BDEFF3C  addi r30, r30, -0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + -196;
	// 830CAA64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAA68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830CAA6C: 386100B7  addi r3, r1, 0xb7
	ctx.r[3].s64 = ctx.r[1].s64 + 183;
	// 830CAA70: 4BFFF179  bl 0x830c9be8
	ctx.lr = 0x830CAA74;
	sub_830C9BE8(ctx, base);
	// 830CAA74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CAA78: 4082FFE4  bne 0x830caa5c
	if !ctx.cr[0].eq {
	pc = 0x830CAA5C; continue 'dispatch;
	}
	// 830CAA7C: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830CAA80: 419A0024  beq cr6, 0x830caaa4
	if ctx.cr[6].eq {
	pc = 0x830CAAA4; continue 'dispatch;
	}
	// 830CAA84: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CAA88: 419A001C  beq cr6, 0x830caaa4
	if ctx.cr[6].eq {
	pc = 0x830CAAA4; continue 'dispatch;
	}
	// 830CAA8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CAA90: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830CAA94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830CAA98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830CAA9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAAA0: 4BFFF7E9  bl 0x830ca288
	ctx.lr = 0x830CAAA4;
	sub_830CA288(ctx, base);
	// 830CAAA4: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CAAA8: 3BBD00C4  addi r29, r29, 0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + 196;
	// 830CAAAC: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830CAAB0: 409AFF60  bne cr6, 0x830caa10
	if !ctx.cr[6].eq {
	pc = 0x830CAA10; continue 'dispatch;
	}
	// 830CAAB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CAAB8: 480DD6F8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CAAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CAAC0 size=244
    let mut pc: u32 = 0x830CAAC0;
    'dispatch: loop {
        match pc {
            0x830CAAC0 => {
    //   block [0x830CAAC0..0x830CABB4)
	// 830CAAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CAAC4: 480DD695  bl 0x831a8158
	ctx.lr = 0x830CAAC8;
	sub_831A8130(ctx, base);
	// 830CAAC8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CAACC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830CAAD0: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830CAAD4: 575E083C  slwi r30, r26, 1
	ctx.r[30].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830CAAD8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 830CAADC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830CAAE0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830CAAE4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830CAAE8: 7F1EF800  cmpw cr6, r30, r31
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830CAAEC: 41990054  bgt cr6, 0x830cab40
	if ctx.cr[6].gt {
	pc = 0x830CAB40; continue 'dispatch;
	}
	// 830CAAF0: 1F9A00C4  mulli r28, r26, 0xc4
	ctx.r[28].s64 = ctx.r[26].s64 * 196;
	// 830CAAF4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 830CAAF8: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAAFC: 7CDC1A14  add r6, r28, r3
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 830CAB00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830CAB04: 7FBC3214  add r29, r28, r6
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[6].u64;
	// 830CAB08: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830CAB0C: 9B290000  stb r25, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 830CAB10: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830CAB14: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830CAB18: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830CAB1C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 830CAB20: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAB24: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 830CAB28: 4BFFFBB9  bl 0x830ca6e0
	ctx.lr = 0x830CAB2C;
	sub_830CA6E0(ctx, base);
	// 830CAB2C: 7FFEF850  subf r31, r30, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830CAB30: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830CAB34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CAB38: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830CAB3C: 4098FFB8  bge cr6, 0x830caaf4
	if !ctx.cr[6].lt {
	pc = 0x830CAAF4; continue 'dispatch;
	}
	// 830CAB40: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830CAB44: 41990030  bgt cr6, 0x830cab74
	if ctx.cr[6].gt {
	pc = 0x830CAB74; continue 'dispatch;
	}
	// 830CAB48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CAB4C: 7F03C040  cmplw cr6, r3, r24
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[24].u32, &mut ctx.xer);
	// 830CAB50: 419A005C  beq cr6, 0x830cabac
	if ctx.cr[6].eq {
	pc = 0x830CABAC; continue 'dispatch;
	}
	// 830CAB54: 7FC35850  subf r30, r3, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 830CAB58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAB5C: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 830CAB60: 4BFFF381  bl 0x830c9ee0
	ctx.lr = 0x830CAB64;
	sub_830C9EE0(ctx, base);
	// 830CAB64: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CAB68: 7F1FC040  cmplw cr6, r31, r24
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[24].u32, &mut ctx.xer);
	// 830CAB6C: 409AFFEC  bne cr6, 0x830cab58
	if !ctx.cr[6].eq {
	pc = 0x830CAB58; continue 'dispatch;
	}
	// 830CAB70: 4800003C  b 0x830cabac
	pc = 0x830CABAC; continue 'dispatch;
	// 830CAB74: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 830CAB78: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAB7C: 1D3A00C4  mulli r9, r26, 0xc4
	ctx.r[9].s64 = ctx.r[26].s64 * 196;
	// 830CAB80: 9B280000  stb r25, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 830CAB84: 7CC91A14  add r6, r9, r3
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 830CAB88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830CAB8C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830CAB90: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830CAB94: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 830CAB98: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830CAB9C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 830CABA0: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CABA4: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 830CABA8: 4BFFFB39  bl 0x830ca6e0
	ctx.lr = 0x830CABAC;
	sub_830CA6E0(ctx, base);
	// 830CABAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830CABB0: 480DD5F8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CABB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CABB8 size=88
    let mut pc: u32 = 0x830CABB8;
    'dispatch: loop {
        match pc {
            0x830CABB8 => {
    //   block [0x830CABB8..0x830CAC10)
	// 830CABB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CABBC: 480DD5A9  bl 0x831a8164
	ctx.lr = 0x830CABC0;
	sub_831A8130(ctx, base);
	// 830CABC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CABC4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830CABC8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830CABCC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830CABD0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 830CABD4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830CABD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830CABDC: 419A0024  beq cr6, 0x830cac00
	if ctx.cr[6].eq {
	pc = 0x830CAC00; continue 'dispatch;
	}
	// 830CABE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830CABE4: 419A0010  beq cr6, 0x830cabf4
	if ctx.cr[6].eq {
	pc = 0x830CABF4; continue 'dispatch;
	}
	// 830CABE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830CABEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CABF0: 4BFFEB89  bl 0x830c9778
	ctx.lr = 0x830CABF4;
	sub_830C9778(ctx, base);
	// 830CABF4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830CABF8: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CABFC: 4082FFE4  bne 0x830cabe0
	if !ctx.cr[0].eq {
	pc = 0x830CABE0; continue 'dispatch;
	}
	// 830CAC00: 1D7F00C4  mulli r11, r31, 0xc4
	ctx.r[11].s64 = ctx.r[31].s64 * 196;
	// 830CAC04: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830CAC08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830CAC0C: 480DD5A8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CAC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830CAC10 size=596
    let mut pc: u32 = 0x830CAC10;
    'dispatch: loop {
        match pc {
            0x830CAC10 => {
    //   block [0x830CAC10..0x830CAE64)
	// 830CAC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CAC14: 480DD535  bl 0x831a8148
	ctx.lr = 0x830CAC18;
	sub_831A8130(ctx, base);
	// 830CAC18: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CAC1C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830CAC20: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830CAC24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830CAC28: 7D78CA14  add r11, r24, r25
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[25].u64;
	// 830CAC2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830CAC30: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 830CAC34: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 830CAC38: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 830CAC3C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830CAC40: 419A0100  beq cr6, 0x830cad40
	if ctx.cr[6].eq {
	pc = 0x830CAD40; continue 'dispatch;
	}
	// 830CAC44: 3A8000C4  li r20, 0xc4
	ctx.r[20].s64 = 196;
	// 830CAC48: 7F18C800  cmpw cr6, r24, r25
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830CAC4C: 41990014  bgt cr6, 0x830cac60
	if ctx.cr[6].gt {
	pc = 0x830CAC60; continue 'dispatch;
	}
	// 830CAC50: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830CAC54: 4BFFEF15  bl 0x830c9b68
	ctx.lr = 0x830CAC58;
	sub_830C9B68(ctx, base);
	// 830CAC58: 7F181800  cmpw cr6, r24, r3
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830CAC5C: 4099010C  ble cr6, 0x830cad68
	if !ctx.cr[6].gt {
	pc = 0x830CAD68; continue 'dispatch;
	}
	// 830CAC60: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830CAC64: 4BFFEF05  bl 0x830c9b68
	ctx.lr = 0x830CAC68;
	sub_830C9B68(ctx, base);
	// 830CAC68: 7F191800  cmpw cr6, r25, r3
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830CAC6C: 4099017C  ble cr6, 0x830cade8
	if !ctx.cr[6].gt {
	pc = 0x830CADE8; continue 'dispatch;
	}
	// 830CAC70: 7F19C000  cmpw cr6, r25, r24
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830CAC74: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830CAC78: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 830CAC7C: 40980038  bge cr6, 0x830cacb4
	if !ctx.cr[6].lt {
	pc = 0x830CACB4; continue 'dispatch;
	}
	// 830CAC80: 7F0B0E70  srawi r11, r24, 1
	ctx.xer.ca = (ctx.r[24].s32 < 0) && ((ctx.r[24].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[24].s32 >> 1) as i64;
	// 830CAC84: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 830CAC88: 7F6B0194  addze r27, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[27].s64 = tmp.s64;
	// 830CAC8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAC90: 1D7B00C4  mulli r11, r27, 0xc4
	ctx.r[11].s64 = ctx.r[27].s64 * 196;
	// 830CAC94: 7F8BF214  add r28, r11, r30
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830CAC98: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830CAC9C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830CACA0: 4BFFF469  bl 0x830ca108
	ctx.lr = 0x830CACA4;
	sub_830CA108(ctx, base);
	// 830CACA4: 83430000  lwz r26, 0(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CACA8: 7D7FD050  subf r11, r31, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[31].s64;
	// 830CACAC: 7FABA3D6  divw r29, r11, r20
	ctx.r[29].s32 = ctx.r[11].s32 / ctx.r[20].s32;
	// 830CACB0: 48000034  b 0x830cace4
	pc = 0x830CACE4; continue 'dispatch;
	// 830CACB4: 7F2B0E70  srawi r11, r25, 1
	ctx.xer.ca = (ctx.r[25].s32 < 0) && ((ctx.r[25].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[25].s32 >> 1) as i64;
	// 830CACB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CACBC: 7FAB0194  addze r29, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[29].s64 = tmp.s64;
	// 830CACC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CACC4: 1D7D00C4  mulli r11, r29, 0xc4
	ctx.r[11].s64 = ctx.r[29].s64 * 196;
	// 830CACC8: 7F4BFA14  add r26, r11, r31
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830CACCC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 830CACD0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830CACD4: 4BFFF4B5  bl 0x830ca188
	ctx.lr = 0x830CACD8;
	sub_830CA188(ctx, base);
	// 830CACD8: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CACDC: 7D7EE050  subf r11, r30, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 830CACE0: 7F6BA3D6  divw r27, r11, r20
	ctx.r[27].s32 = ctx.r[11].s32 / ctx.r[20].s32;
	// 830CACE4: 7F1BC050  subf r24, r27, r24
	ctx.r[24].s64 = ctx.r[24].s64 - ctx.r[27].s64;
	// 830CACE8: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 830CACEC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 830CACF0: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 830CACF4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830CACF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CACFC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CAD00: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 830CAD04: 4BFFF80D  bl 0x830ca510
	ctx.lr = 0x830CAD08;
	sub_830CA510(ctx, base);
	// 830CAD08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CAD0C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 830CAD10: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 830CAD14: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830CAD18: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830CAD1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830CAD20: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830CAD24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830CAD28: 4BFFFEE9  bl 0x830cac10
	ctx.lr = 0x830CAD2C;
	sub_830CAC10(ctx, base);
	// 830CAD2C: 7F3DC850  subf r25, r29, r25
	ctx.r[25].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 830CAD30: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830CAD34: 7D78CA14  add r11, r24, r25
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[25].u64;
	// 830CAD38: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830CAD3C: 409AFF0C  bne cr6, 0x830cac48
	if !ctx.cr[6].eq {
	pc = 0x830CAC48; continue 'dispatch;
	}
	// 830CAD40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830CAD44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAD48: 38610157  addi r3, r1, 0x157
	ctx.r[3].s64 = ctx.r[1].s64 + 343;
	// 830CAD4C: 4BFFEE9D  bl 0x830c9be8
	ctx.lr = 0x830CAD50;
	sub_830C9BE8(ctx, base);
	// 830CAD50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CAD54: 41820108  beq 0x830cae5c
	if ctx.cr[0].eq {
	pc = 0x830CAE5C; continue 'dispatch;
	}
	// 830CAD58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAD5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CAD60: 4BFFF331  bl 0x830ca090
	ctx.lr = 0x830CAD64;
	sub_830CA090(ctx, base);
	// 830CAD64: 480000F8  b 0x830cae5c
	pc = 0x830CAE5C; continue 'dispatch;
	// 830CAD68: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CAD6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830CAD70: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830CAD74: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 830CAD78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CAD7C: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 830CAD80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CAD84: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 830CAD88: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830CAD8C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CAD90: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 830CAD94: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830CAD98: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CAD9C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830CADA0: 4BFFF6F9  bl 0x830ca498
	ctx.lr = 0x830CADA4;
	sub_830CA498(ctx, base);
	// 830CADA4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830CADA8: 4BFFF621  bl 0x830ca3c8
	ctx.lr = 0x830CADAC;
	sub_830CA3C8(ctx, base);
	// 830CADAC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830CADB0: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CADB4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830CADB8: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 830CADBC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 830CADC0: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830CADC4: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830CADC8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 830CADCC: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CADD0: 8BE10060  lbz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CADD4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CADD8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CADDC: 9BE10057  stb r31, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[31].u8 ) };
	// 830CADE0: 4BFFF901  bl 0x830ca6e0
	ctx.lr = 0x830CADE4;
	sub_830CA6E0(ctx, base);
	// 830CADE4: 48000078  b 0x830cae5c
	pc = 0x830CAE5C; continue 'dispatch;
	// 830CADE8: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CADEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830CADF0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830CADF4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 830CADF8: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 830CADFC: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 830CAE00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CAE04: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 830CAE08: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830CAE0C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CAE10: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 830CAE14: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830CAE18: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CAE1C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830CAE20: 4BFFF679  bl 0x830ca498
	ctx.lr = 0x830CAE24;
	sub_830CA498(ctx, base);
	// 830CAE24: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830CAE28: 4BFFF5A1  bl 0x830ca3c8
	ctx.lr = 0x830CAE2C;
	sub_830CA3C8(ctx, base);
	// 830CAE2C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830CAE30: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 830CAE34: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 830CAE38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CAE3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CAE40: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830CAE44: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 830CAE48: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CAE4C: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAE50: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CAE54: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CAE58: 4BFFF959  bl 0x830ca7b0
	ctx.lr = 0x830CAE5C;
	sub_830CA7B0(ctx, base);
	// 830CAE5C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 830CAE60: 480DD338  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CAE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CAE68 size=356
    let mut pc: u32 = 0x830CAE68;
    'dispatch: loop {
        match pc {
            0x830CAE68 => {
    //   block [0x830CAE68..0x830CAFCC)
	// 830CAE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CAE6C: 480DD2E9  bl 0x831a8154
	ctx.lr = 0x830CAE70;
	sub_831A8130(ctx, base);
	// 830CAE70: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CAE74: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830CAE78: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830CAE7C: 571B083C  slwi r27, r24, 1
	ctx.r[27].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 830CAE80: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 830CAE84: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830CAE88: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 830CAE8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830CAE90: 7F1BF000  cmpw cr6, r27, r30
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830CAE94: 41990094  bgt cr6, 0x830caf28
	if ctx.cr[6].gt {
	pc = 0x830CAF28; continue 'dispatch;
	}
	// 830CAE98: 1F5800C4  mulli r26, r24, 0xc4
	ctx.r[26].s64 = ctx.r[24].s64 * 196;
	// 830CAE9C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 830CAEA0: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAEA4: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CAEA8: 7CDA1A14  add r6, r26, r3
	ctx.r[6].u64 = ctx.r[26].u64 + ctx.r[3].u64;
	// 830CAEAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830CAEB0: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 830CAEB4: 7FBA3214  add r29, r26, r6
	ctx.r[29].u64 = ctx.r[26].u64 + ctx.r[6].u64;
	// 830CAEB8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830CAEBC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 830CAEC0: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830CAEC4: 9BE90000  stb r31, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 830CAEC8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 830CAECC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830CAED0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830CAED4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 830CAED8: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830CAEDC: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 830CAEE0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830CAEE4: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 830CAEE8: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 830CAEEC: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 830CAEF0: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 830CAEF4: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAEF8: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 830CAEFC: 4BFFF995  bl 0x830ca890
	ctx.lr = 0x830CAF00;
	sub_830CA890(ctx, base);
	// 830CAF00: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830CAF04: 4BFFF4C5  bl 0x830ca3c8
	ctx.lr = 0x830CAF08;
	sub_830CA3C8(ctx, base);
	// 830CAF08: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 830CAF0C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830CAF10: 917C0010  stw r11, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830CAF14: 4BFFF4B5  bl 0x830ca3c8
	ctx.lr = 0x830CAF18;
	sub_830CA3C8(ctx, base);
	// 830CAF18: 7FDBF050  subf r30, r27, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 830CAF1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CAF20: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830CAF24: 4098FF78  bge cr6, 0x830cae9c
	if !ctx.cr[6].lt {
	pc = 0x830CAE9C; continue 'dispatch;
	}
	// 830CAF28: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CAF2C: 7F1EC000  cmpw cr6, r30, r24
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830CAF30: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 830CAF34: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 830CAF38: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 830CAF3C: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 830CAF40: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 830CAF44: 4199001C  bgt cr6, 0x830caf60
	if ctx.cr[6].gt {
	pc = 0x830CAF60; continue 'dispatch;
	}
	// 830CAF48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830CAF4C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830CAF50: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830CAF54: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830CAF58: 4BFFF541  bl 0x830ca498
	ctx.lr = 0x830CAF5C;
	sub_830CA498(ctx, base);
	// 830CAF5C: 48000058  b 0x830cafb4
	pc = 0x830CAFB4; continue 'dispatch;
	// 830CAF60: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 830CAF64: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAF68: 1D3800C4  mulli r9, r24, 0xc4
	ctx.r[9].s64 = ctx.r[24].s64 * 196;
	// 830CAF6C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830CAF70: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 830CAF74: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830CAF78: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830CAF7C: 9BE80000  stb r31, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 830CAF80: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 830CAF84: 7CC91A14  add r6, r9, r3
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 830CAF88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830CAF8C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 830CAF90: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 830CAF94: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 830CAF98: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830CAF9C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830CAFA0: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830CAFA4: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 830CAFA8: 4BFFF8E9  bl 0x830ca890
	ctx.lr = 0x830CAFAC;
	sub_830CA890(ctx, base);
	// 830CAFAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830CAFB0: 4BFFF419  bl 0x830ca3c8
	ctx.lr = 0x830CAFB4;
	sub_830CA3C8(ctx, base);
	// 830CAFB4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830CAFB8: 4BFFF411  bl 0x830ca3c8
	ctx.lr = 0x830CAFBC;
	sub_830CA3C8(ctx, base);
	// 830CAFBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CAFC0: 4BFFF409  bl 0x830ca3c8
	ctx.lr = 0x830CAFC4;
	sub_830CA3C8(ctx, base);
	// 830CAFC4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 830CAFC8: 480DD1DC  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CAFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CAFD0 size=116
    let mut pc: u32 = 0x830CAFD0;
    'dispatch: loop {
        match pc {
            0x830CAFD0 => {
    //   block [0x830CAFD0..0x830CB044)
	// 830CAFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CAFD4: 480DD18D  bl 0x831a8160
	ctx.lr = 0x830CAFD8;
	sub_831A8130(ctx, base);
	// 830CAFD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CAFDC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830CAFE0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CAFE4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830CAFE8: 7F1B3040  cmplw cr6, r27, r6
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[6].u32, &mut ctx.xer);
	// 830CAFEC: 419A0048  beq cr6, 0x830cb034
	if ctx.cr[6].eq {
	pc = 0x830CB034; continue 'dispatch;
	}
	// 830CAFF0: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CAFF4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830CAFF8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830CAFFC: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CB000: 419A0020  beq cr6, 0x830cb020
	if ctx.cr[6].eq {
	pc = 0x830CB020; continue 'dispatch;
	}
	// 830CB004: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CB008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB00C: 4BFFEED5  bl 0x830c9ee0
	ctx.lr = 0x830CB010;
	sub_830C9EE0(ctx, base);
	// 830CB010: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CB014: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CB018: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CB01C: 409AFFE8  bne cr6, 0x830cb004
	if !ctx.cr[6].eq {
	pc = 0x830CB004; continue 'dispatch;
	}
	// 830CB020: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CB024: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB02C: 4BFFF95D  bl 0x830ca988
	ctx.lr = 0x830CB030;
	sub_830CA988(ctx, base);
	// 830CB030: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 830CB034: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830CB038: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CB03C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CB040: 480DD170  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB048 size=96
    let mut pc: u32 = 0x830CB048;
    'dispatch: loop {
        match pc {
            0x830CB048 => {
    //   block [0x830CB048..0x830CB0A8)
	// 830CB048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB054: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB058: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CB05C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB064: 419A0020  beq cr6, 0x830cb084
	if ctx.cr[6].eq {
	pc = 0x830CB084; continue 'dispatch;
	}
	// 830CB068: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CB06C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB070: 4BFFF919  bl 0x830ca988
	ctx.lr = 0x830CB074;
	sub_830CA988(ctx, base);
	// 830CB074: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830CB078: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB07C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830CB080: 4BD27109  bl 0x82df2188
	ctx.lr = 0x830CB084;
	sub_82DF2188(ctx, base);
	// 830CB084: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB088: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830CB08C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830CB090: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830CB094: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830CB098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB0A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB0A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB0A8 size=96
    let mut pc: u32 = 0x830CB0A8;
    'dispatch: loop {
        match pc {
            0x830CB0A8 => {
    //   block [0x830CB0A8..0x830CB108)
	// 830CB0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB0B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB0B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB0B8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830CB0BC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830CB0C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB0C4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830CB0C8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830CB0CC: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CB0D0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830CB0D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830CB0D8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830CB0DC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830CB0E0: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 830CB0E4: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830CB0E8: 4BFFFD81  bl 0x830cae68
	ctx.lr = 0x830CB0EC;
	sub_830CAE68(ctx, base);
	// 830CB0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB0F0: 4BFFF2D9  bl 0x830ca3c8
	ctx.lr = 0x830CB0F4;
	sub_830CA3C8(ctx, base);
	// 830CB0F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CB0F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB0FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB108 size=876
    let mut pc: u32 = 0x830CB108;
    'dispatch: loop {
        match pc {
            0x830CB108 => {
    //   block [0x830CB108..0x830CB474)
	// 830CB108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB10C: 480DD045  bl 0x831a8150
	ctx.lr = 0x830CB110;
	sub_831A8130(ctx, base);
	// 830CB110: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CB118: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830CB11C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830CB120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CB124: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830CB128: 4BFFE651  bl 0x830c9778
	ctx.lr = 0x830CB12C;
	sub_830C9778(ctx, base);
	// 830CB12C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB130: 3AC000C4  li r22, 0xc4
	ctx.r[22].s64 = 196;
	// 830CB134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830CB138: 409A000C  bne cr6, 0x830cb144
	if !ctx.cr[6].eq {
	pc = 0x830CB144; continue 'dispatch;
	}
	// 830CB13C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830CB140: 48000010  b 0x830cb150
	pc = 0x830CB150; continue 'dispatch;
	// 830CB144: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830CB148: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830CB14C: 7D0BB3D6  divw r8, r11, r22
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB150: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830CB154: 419A02F8  beq cr6, 0x830cb44c
	if ctx.cr[6].eq {
	pc = 0x830CB44C; continue 'dispatch;
	}
	// 830CB158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830CB15C: 409A000C  bne cr6, 0x830cb168
	if !ctx.cr[6].eq {
	pc = 0x830CB168; continue 'dispatch;
	}
	// 830CB160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB164: 48000010  b 0x830cb174
	pc = 0x830CB174; continue 'dispatch;
	// 830CB168: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB16C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830CB170: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB174: 3D20014E  lis r9, 0x14e
	ctx.r[9].s64 = 21889024;
	// 830CB178: 61295E0A  ori r9, r9, 0x5e0a
	ctx.r[9].u64 = ctx.r[9].u64 | 24074;
	// 830CB17C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830CB180: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 830CB184: 4098000C  bge cr6, 0x830cb190
	if !ctx.cr[6].lt {
	pc = 0x830CB190; continue 'dispatch;
	}
	// 830CB188: 4BFF9FB1  bl 0x830c5138
	ctx.lr = 0x830CB18C;
	sub_830C5138(ctx, base);
	// 830CB18C: 480002C0  b 0x830cb44c
	pc = 0x830CB44C; continue 'dispatch;
	// 830CB190: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830CB194: 409A000C  bne cr6, 0x830cb1a0
	if !ctx.cr[6].eq {
	pc = 0x830CB1A0; continue 'dispatch;
	}
	// 830CB198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB19C: 48000010  b 0x830cb1ac
	pc = 0x830CB1AC; continue 'dispatch;
	// 830CB1A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB1A4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830CB1A8: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB1AC: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830CB1B0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830CB1B4: 40980168  bge cr6, 0x830cb31c
	if !ctx.cr[6].lt {
	pc = 0x830CB31C; continue 'dispatch;
	}
	// 830CB1B8: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830CB1BC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830CB1C0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830CB1C4: 4098000C  bge cr6, 0x830cb1d0
	if !ctx.cr[6].lt {
	pc = 0x830CB1D0; continue 'dispatch;
	}
	// 830CB1C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB1CC: 48000008  b 0x830cb1d4
	pc = 0x830CB1D4; continue 'dispatch;
	// 830CB1D0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830CB1D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830CB1D8: 409A000C  bne cr6, 0x830cb1e4
	if !ctx.cr[6].eq {
	pc = 0x830CB1E4; continue 'dispatch;
	}
	// 830CB1DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830CB1E0: 48000010  b 0x830cb1f0
	pc = 0x830CB1F0; continue 'dispatch;
	// 830CB1E4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB1E8: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 830CB1EC: 7D29B3D6  divw r9, r9, r22
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[22].s32;
	// 830CB1F0: 7D29BA14  add r9, r9, r23
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[23].u64;
	// 830CB1F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830CB1F8: 40980024  bge cr6, 0x830cb21c
	if !ctx.cr[6].lt {
	pc = 0x830CB21C; continue 'dispatch;
	}
	// 830CB1FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830CB200: 409A000C  bne cr6, 0x830cb20c
	if !ctx.cr[6].eq {
	pc = 0x830CB20C; continue 'dispatch;
	}
	// 830CB204: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB208: 48000010  b 0x830cb218
	pc = 0x830CB218; continue 'dispatch;
	// 830CB20C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB210: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830CB214: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB218: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830CB21C: 1F0B00C4  mulli r24, r11, 0xc4
	ctx.r[24].s64 = ctx.r[11].s64 * 196;
	// 830CB220: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 830CB224: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830CB228: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830CB22C: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 830CB230: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 830CB234: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830CB238: 4BD26E91  bl 0x82df20c8
	ctx.lr = 0x830CB23C;
	sub_82DF20C8(ctx, base);
	// 830CB23C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830CB240: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB244: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830CB248: 48000020  b 0x830cb268
	pc = 0x830CB268; continue 'dispatch;
	// 830CB24C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830CB250: 419A0010  beq cr6, 0x830cb260
	if ctx.cr[6].eq {
	pc = 0x830CB260; continue 'dispatch;
	}
	// 830CB254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830CB258: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CB25C: 4BFFE51D  bl 0x830c9778
	ctx.lr = 0x830CB260;
	sub_830C9778(ctx, base);
	// 830CB260: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CB264: 3BBD00C4  addi r29, r29, 0xc4
	ctx.r[29].s64 = ctx.r[29].s64 + 196;
	// 830CB268: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830CB26C: 409AFFE0  bne cr6, 0x830cb24c
	if !ctx.cr[6].eq {
	pc = 0x830CB24C; continue 'dispatch;
	}
	// 830CB270: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CB274: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830CB278: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CB27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB280: 4BFFF939  bl 0x830cabb8
	ctx.lr = 0x830CB284;
	sub_830CABB8(ctx, base);
	// 830CB284: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB288: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830CB28C: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CB290: 419A002C  beq cr6, 0x830cb2bc
	if ctx.cr[6].eq {
	pc = 0x830CB2BC; continue 'dispatch;
	}
	// 830CB294: 7F9ED050  subf r28, r30, r26
	ctx.r[28].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 830CB298: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830CB29C: 419A0010  beq cr6, 0x830cb2ac
	if ctx.cr[6].eq {
	pc = 0x830CB2AC; continue 'dispatch;
	}
	// 830CB2A0: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 830CB2A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CB2A8: 4BFFE4D1  bl 0x830c9778
	ctx.lr = 0x830CB2AC;
	sub_830C9778(ctx, base);
	// 830CB2AC: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 830CB2B0: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 830CB2B4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CB2B8: 409AFFE0  bne cr6, 0x830cb298
	if !ctx.cr[6].eq {
	pc = 0x830CB298; continue 'dispatch;
	}
	// 830CB2BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB2C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB2C4: 409A000C  bne cr6, 0x830cb2d0
	if !ctx.cr[6].eq {
	pc = 0x830CB2D0; continue 'dispatch;
	}
	// 830CB2C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB2CC: 48000010  b 0x830cb2dc
	pc = 0x830CB2DC; continue 'dispatch;
	// 830CB2D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB2D4: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 830CB2D8: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB2DC: 7FCBBA14  add r30, r11, r23
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830CB2E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB2E4: 419A001C  beq cr6, 0x830cb300
	if ctx.cr[6].eq {
	pc = 0x830CB300; continue 'dispatch;
	}
	// 830CB2E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CB2EC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB2F0: 4BFFF699  bl 0x830ca988
	ctx.lr = 0x830CB2F4;
	sub_830CA988(ctx, base);
	// 830CB2F4: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 830CB2F8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB2FC: 4BD26E8D  bl 0x82df2188
	ctx.lr = 0x830CB300;
	sub_82DF2188(ctx, base);
	// 830CB300: 1D7E00C4  mulli r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 * 196;
	// 830CB304: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830CB308: 7D58DA14  add r10, r24, r27
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 830CB30C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830CB310: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830CB314: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830CB318: 48000134  b 0x830cb44c
	pc = 0x830CB44C; continue 'dispatch;
	// 830CB31C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB320: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 830CB324: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB328: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 830CB32C: 40980090  bge cr6, 0x830cb3bc
	if !ctx.cr[6].lt {
	pc = 0x830CB3BC; continue 'dispatch;
	}
	// 830CB330: 1FB700C4  mulli r29, r23, 0xc4
	ctx.r[29].s64 = ctx.r[23].s64 * 196;
	// 830CB334: 7F9DD214  add r28, r29, r26
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[26].u64;
	// 830CB338: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB33C: 419A002C  beq cr6, 0x830cb368
	if ctx.cr[6].eq {
	pc = 0x830CB368; continue 'dispatch;
	}
	// 830CB340: 7F7DE050  subf r27, r29, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 830CB344: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830CB348: 419A0010  beq cr6, 0x830cb358
	if ctx.cr[6].eq {
	pc = 0x830CB358; continue 'dispatch;
	}
	// 830CB34C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830CB350: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CB354: 4BFFE425  bl 0x830c9778
	ctx.lr = 0x830CB358;
	sub_830C9778(ctx, base);
	// 830CB358: 3B7B00C4  addi r27, r27, 0xc4
	ctx.r[27].s64 = ctx.r[27].s64 + 196;
	// 830CB35C: 3B9C00C4  addi r28, r28, 0xc4
	ctx.r[28].s64 = ctx.r[28].s64 + 196;
	// 830CB360: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB364: 409AFFE0  bne cr6, 0x830cb344
	if !ctx.cr[6].eq {
	pc = 0x830CB344; continue 'dispatch;
	}
	// 830CB368: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB36C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CB370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB374: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 830CB378: 7D6BB3D6  divw r11, r11, r22
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[22].s32;
	// 830CB37C: 7CABB850  subf r5, r11, r23
	ctx.r[5].s64 = ctx.r[23].s64 - ctx.r[11].s64;
	// 830CB380: 4BFFF839  bl 0x830cabb8
	ctx.lr = 0x830CB384;
	sub_830CABB8(ctx, base);
	// 830CB384: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB388: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830CB38C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830CB390: 7FDD5850  subf r30, r29, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 830CB394: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830CB398: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB39C: 419A00B0  beq cr6, 0x830cb44c
	if ctx.cr[6].eq {
	pc = 0x830CB44C; continue 'dispatch;
	}
	// 830CB3A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830CB3A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CB3A8: 4BFFEB39  bl 0x830c9ee0
	ctx.lr = 0x830CB3AC;
	sub_830C9EE0(ctx, base);
	// 830CB3AC: 3B9C00C4  addi r28, r28, 0xc4
	ctx.r[28].s64 = ctx.r[28].s64 + 196;
	// 830CB3B0: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB3B4: 409AFFEC  bne cr6, 0x830cb3a0
	if !ctx.cr[6].eq {
	pc = 0x830CB3A0; continue 'dispatch;
	}
	// 830CB3B8: 48000094  b 0x830cb44c
	pc = 0x830CB44C; continue 'dispatch;
	// 830CB3BC: 1F3700C4  mulli r25, r23, 0xc4
	ctx.r[25].s64 = ctx.r[23].s64 * 196;
	// 830CB3C0: 7FB9F050  subf r29, r25, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 830CB3C4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830CB3C8: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 830CB3CC: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB3D0: 419A0028  beq cr6, 0x830cb3f8
	if ctx.cr[6].eq {
	pc = 0x830CB3F8; continue 'dispatch;
	}
	// 830CB3D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830CB3D8: 419A0010  beq cr6, 0x830cb3e8
	if ctx.cr[6].eq {
	pc = 0x830CB3E8; continue 'dispatch;
	}
	// 830CB3DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830CB3E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CB3E4: 4BFFE395  bl 0x830c9778
	ctx.lr = 0x830CB3E8;
	sub_830C9778(ctx, base);
	// 830CB3E8: 3B7B00C4  addi r27, r27, 0xc4
	ctx.r[27].s64 = ctx.r[27].s64 + 196;
	// 830CB3EC: 3B9C00C4  addi r28, r28, 0xc4
	ctx.r[28].s64 = ctx.r[28].s64 + 196;
	// 830CB3F0: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB3F4: 409AFFE0  bne cr6, 0x830cb3d4
	if !ctx.cr[6].eq {
	pc = 0x830CB3D4; continue 'dispatch;
	}
	// 830CB3F8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830CB3FC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 830CB400: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830CB404: 419A0020  beq cr6, 0x830cb424
	if ctx.cr[6].eq {
	pc = 0x830CB424; continue 'dispatch;
	}
	// 830CB408: 7FDDF050  subf r30, r29, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 830CB40C: 3BFFFF3C  addi r31, r31, -0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + -196;
	// 830CB410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CB414: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 830CB418: 4BFFEAC9  bl 0x830c9ee0
	ctx.lr = 0x830CB41C;
	sub_830C9EE0(ctx, base);
	// 830CB41C: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830CB420: 409AFFEC  bne cr6, 0x830cb40c
	if !ctx.cr[6].eq {
	pc = 0x830CB40C; continue 'dispatch;
	}
	// 830CB424: 7FD9D214  add r30, r25, r26
	ctx.r[30].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 830CB428: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830CB42C: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB430: 419A001C  beq cr6, 0x830cb44c
	if ctx.cr[6].eq {
	pc = 0x830CB44C; continue 'dispatch;
	}
	// 830CB434: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830CB438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB43C: 4BFFEAA5  bl 0x830c9ee0
	ctx.lr = 0x830CB440;
	sub_830C9EE0(ctx, base);
	// 830CB440: 3BFF00C4  addi r31, r31, 0xc4
	ctx.r[31].s64 = ctx.r[31].s64 + 196;
	// 830CB444: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830CB448: 409AFFEC  bne cr6, 0x830cb434
	if !ctx.cr[6].eq {
	pc = 0x830CB434; continue 'dispatch;
	}
	// 830CB44C: 80610110  lwz r3, 0x110(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 830CB450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB454: 419A0008  beq cr6, 0x830cb45c
	if ctx.cr[6].eq {
	pc = 0x830CB45C; continue 'dispatch;
	}
	// 830CB458: 4B1F5439  bl 0x822c0890
	ctx.lr = 0x830CB45C;
	sub_822C0890(ctx, base);
	// 830CB45C: 80610108  lwz r3, 0x108(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 830CB460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB464: 419A0008  beq cr6, 0x830cb46c
	if ctx.cr[6].eq {
	pc = 0x830CB46C; continue 'dispatch;
	}
	// 830CB468: 4B1F5429  bl 0x822c0890
	ctx.lr = 0x830CB46C;
	sub_822C0890(ctx, base);
	// 830CB46C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830CB470: 480DCD30  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB478 size=232
    let mut pc: u32 = 0x830CB478;
    'dispatch: loop {
        match pc {
            0x830CB478 => {
    //   block [0x830CB478..0x830CB560)
	// 830CB478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB47C: 480DCCE1  bl 0x831a815c
	ctx.lr = 0x830CB480;
	sub_831A8130(ctx, base);
	// 830CB480: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB484: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830CB488: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CB48C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830CB490: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830CB494: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830CB498: 2F1F0020  cmpwi cr6, r31, 0x20
	ctx.cr[6].compare_i32(ctx.r[31].s32, 32, &mut ctx.xer);
	// 830CB49C: 41980024  blt cr6, 0x830cb4c0
	if ctx.cr[6].lt {
	pc = 0x830CB4C0; continue 'dispatch;
	}
	// 830CB4A0: 57FED97E  srwi r30, r31, 5
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shr(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830CB4A4: 3BA31880  addi r29, r3, 0x1880
	ctx.r[29].s64 = ctx.r[3].s64 + 6272;
	// 830CB4A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CB4AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CB4B0: 4BFFF531  bl 0x830ca9e0
	ctx.lr = 0x830CB4B4;
	sub_830CA9E0(ctx, base);
	// 830CB4B4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830CB4B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CB4BC: 4082FFE8  bne 0x830cb4a4
	if !ctx.cr[0].eq {
	pc = 0x830CB4A4; continue 'dispatch;
	}
	// 830CB4C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CB4C4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830CB4C8: 4BFFF519  bl 0x830ca9e0
	ctx.lr = 0x830CB4CC;
	sub_830CA9E0(ctx, base);
	// 830CB4CC: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 830CB4D0: 2F1F0020  cmpwi cr6, r31, 0x20
	ctx.cr[6].compare_i32(ctx.r[31].s32, 32, &mut ctx.xer);
	// 830CB4D4: 40990084  ble cr6, 0x830cb558
	if !ctx.cr[6].gt {
	pc = 0x830CB558; continue 'dispatch;
	}
	// 830CB4D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830CB4DC: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CB4E0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830CB4E4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 830CB4E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830CB4EC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830CB4F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830CB4F4: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 830CB4F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830CB4FC: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 830CB500: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830CB504: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CB508: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CB50C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830CB510: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CB514: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830CB518: 4BFFFB91  bl 0x830cb0a8
	ctx.lr = 0x830CB51C;
	sub_830CB0A8(ctx, base);
	// 830CB51C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830CB520: 57BD083C  slwi r29, r29, 1
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830CB524: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830CB528: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830CB52C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830CB530: 9BCB0000  stb r30, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 830CB534: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830CB538: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CB53C: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830CB540: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB544: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CB548: 4BFFF579  bl 0x830caac0
	ctx.lr = 0x830CB54C;
	sub_830CAAC0(ctx, base);
	// 830CB54C: 57BD083C  slwi r29, r29, 1
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830CB550: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830CB554: 4198FF88  blt cr6, 0x830cb4dc
	if ctx.cr[6].lt {
	pc = 0x830CB4DC; continue 'dispatch;
	}
	// 830CB558: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830CB55C: 480DCC50  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB560 size=156
    let mut pc: u32 = 0x830CB560;
    'dispatch: loop {
        match pc {
            0x830CB560 => {
    //   block [0x830CB560..0x830CB5FC)
	// 830CB560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CB56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB574: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830CB578: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 830CB57C: 419A0040  beq cr6, 0x830cb5bc
	if ctx.cr[6].eq {
	pc = 0x830CB5BC; continue 'dispatch;
	}
	// 830CB580: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830CB584: 4098000C  bge cr6, 0x830cb590
	if !ctx.cr[6].lt {
	pc = 0x830CB590; continue 'dispatch;
	}
	// 830CB588: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 830CB58C: 48000010  b 0x830cb59c
	pc = 0x830CB59C; continue 'dispatch;
	// 830CB590: 2F05001F  cmpwi cr6, r5, 0x1f
	ctx.cr[6].compare_i32(ctx.r[5].s32, 31, &mut ctx.xer);
	// 830CB594: 40990008  ble cr6, 0x830cb59c
	if !ctx.cr[6].gt {
	pc = 0x830CB59C; continue 'dispatch;
	}
	// 830CB598: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 830CB59C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830CB5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CB5A4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830CB5A8: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 830CB5AC: 80CB0010  lwz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CB5B0: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830CB5B4: 4BFFFA1D  bl 0x830cafd0
	ctx.lr = 0x830CB5B8;
	sub_830CAFD0(ctx, base);
	// 830CB5B8: 4800002C  b 0x830cb5e4
	pc = 0x830CB5E4; continue 'dispatch;
	// 830CB5BC: 3BEA000C  addi r31, r10, 0xc
	ctx.r[31].s64 = ctx.r[10].s64 + 12;
	// 830CB5C0: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 830CB5C4: 389FFFFC  addi r4, r31, -4
	ctx.r[4].s64 = ctx.r[31].s64 + -4;
	// 830CB5C8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CB5D0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CB5D4: 4BFFF9FD  bl 0x830cafd0
	ctx.lr = 0x830CB5D8;
	sub_830CAFD0(ctx, base);
	// 830CB5D8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830CB5DC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 830CB5E0: 4082FFE4  bne 0x830cb5c4
	if !ctx.cr[0].eq {
	pc = 0x830CB5C4; continue 'dispatch;
	}
	// 830CB5E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB5F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CB5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB600 size=112
    let mut pc: u32 = 0x830CB600;
    'dispatch: loop {
        match pc {
            0x830CB600 => {
    //   block [0x830CB600..0x830CB670)
	// 830CB600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB604: 480DCB69  bl 0x831a816c
	ctx.lr = 0x830CB608;
	sub_831A8130(ctx, base);
	// 830CB608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB60C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830CB610: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830CB614: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830CB618: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830CB620: 419A0018  beq cr6, 0x830cb638
	if ctx.cr[6].eq {
	pc = 0x830CB638; continue 'dispatch;
	}
	// 830CB624: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB628: 394000C4  li r10, 0xc4
	ctx.r[10].s64 = 196;
	// 830CB62C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830CB630: 7D2953D7  divw. r9, r9, r10
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830CB634: 4082000C  bne 0x830cb640
	if !ctx.cr[0].eq {
	pc = 0x830CB640; continue 'dispatch;
	}
	// 830CB638: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830CB63C: 4800000C  b 0x830cb648
	pc = 0x830CB648; continue 'dispatch;
	// 830CB640: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830CB644: 7FCB53D6  divw r30, r11, r10
	ctx.r[30].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 830CB648: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830CB64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB650: 4BFFFAB9  bl 0x830cb108
	ctx.lr = 0x830CB654;
	sub_830CB108(ctx, base);
	// 830CB654: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB658: 1D7E00C4  mulli r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 * 196;
	// 830CB65C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830CB660: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CB664: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830CB668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB66C: 480DCB50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830CB670 size=216
    let mut pc: u32 = 0x830CB670;
    'dispatch: loop {
        match pc {
            0x830CB670 => {
    //   block [0x830CB670..0x830CB748)
	// 830CB670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB674: 480DCAE9  bl 0x831a815c
	ctx.lr = 0x830CB678;
	sub_831A8130(ctx, base);
	// 830CB678: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB67C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830CB680: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830CB684: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830CB688: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830CB68C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830CB690: 2F1B0020  cmpwi cr6, r27, 0x20
	ctx.cr[6].compare_i32(ctx.r[27].s32, 32, &mut ctx.xer);
	// 830CB694: 41990010  bgt cr6, 0x830cb6a4
	if ctx.cr[6].gt {
	pc = 0x830CB6A4; continue 'dispatch;
	}
	// 830CB698: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830CB69C: 4BFFF345  bl 0x830ca9e0
	ctx.lr = 0x830CB6A0;
	sub_830CA9E0(ctx, base);
	// 830CB6A0: 480000A0  b 0x830cb740
	pc = 0x830CB740; continue 'dispatch;
	// 830CB6A4: 397B0001  addi r11, r27, 1
	ctx.r[11].s64 = ctx.r[27].s64 + 1;
	// 830CB6A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CB6AC: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830CB6B0: 7FEB0194  addze r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	// 830CB6B4: 1D7F00C4  mulli r11, r31, 0xc4
	ctx.r[11].s64 = ctx.r[31].s64 * 196;
	// 830CB6B8: 7FABD214  add r29, r11, r26
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830CB6BC: 4BFFE4AD  bl 0x830c9b68
	ctx.lr = 0x830CB6C0;
	sub_830C9B68(ctx, base);
	// 830CB6C0: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830CB6C4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830CB6C8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830CB6CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830CB6D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CB6D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CB6D8: 41990028  bgt cr6, 0x830cb700
	if ctx.cr[6].gt {
	pc = 0x830CB700; continue 'dispatch;
	}
	// 830CB6DC: 4BFFFD9D  bl 0x830cb478
	ctx.lr = 0x830CB6E0;
	sub_830CB478(ctx, base);
	// 830CB6E0: 7F7FD850  subf r27, r31, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 830CB6E4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830CB6E8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830CB6EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830CB6F0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830CB6F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CB6F8: 4BFFFD81  bl 0x830cb478
	ctx.lr = 0x830CB6FC;
	sub_830CB478(ctx, base);
	// 830CB6FC: 48000024  b 0x830cb720
	pc = 0x830CB720; continue 'dispatch;
	// 830CB700: 4BFFFF71  bl 0x830cb670
	ctx.lr = 0x830CB704;
	sub_830CB670(ctx, base);
	// 830CB704: 7F7FD850  subf r27, r31, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 830CB708: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830CB70C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830CB710: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830CB714: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830CB718: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CB71C: 4BFFFF55  bl 0x830cb670
	ctx.lr = 0x830CB720;
	sub_830CB670(ctx, base);
	// 830CB720: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 830CB724: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 830CB728: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830CB72C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830CB730: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830CB734: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830CB738: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830CB73C: 4BFFF4D5  bl 0x830cac10
	ctx.lr = 0x830CB740;
	sub_830CAC10(ctx, base);
	// 830CB740: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830CB744: 480DCA68  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB748 size=164
    let mut pc: u32 = 0x830CB748;
    'dispatch: loop {
        match pc {
            0x830CB748 => {
    //   block [0x830CB748..0x830CB7EC)
	// 830CB748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CB754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB75C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CB760: 392000C4  li r9, 0xc4
	ctx.r[9].s64 = 196;
	// 830CB764: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830CB76C: 409A000C  bne cr6, 0x830cb778
	if !ctx.cr[6].eq {
	pc = 0x830CB778; continue 'dispatch;
	}
	// 830CB770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830CB774: 48000010  b 0x830cb784
	pc = 0x830CB784; continue 'dispatch;
	// 830CB778: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB77C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830CB780: 7D4A4BD6  divw r10, r10, r9
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830CB784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830CB788: 419A0038  beq cr6, 0x830cb7c0
	if ctx.cr[6].eq {
	pc = 0x830CB7C0; continue 'dispatch;
	}
	// 830CB78C: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830CB790: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 830CB794: 7D6B4BD6  divw r11, r11, r9
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 830CB798: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830CB79C: 40980024  bge cr6, 0x830cb7c0
	if !ctx.cr[6].lt {
	pc = 0x830CB7C0; continue 'dispatch;
	}
	// 830CB7A0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB7A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830CB7A8: 419A000C  beq cr6, 0x830cb7b4
	if ctx.cr[6].eq {
	pc = 0x830CB7B4; continue 'dispatch;
	}
	// 830CB7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830CB7B0: 4BFFDFC9  bl 0x830c9778
	ctx.lr = 0x830CB7B4;
	sub_830C9778(ctx, base);
	// 830CB7B4: 397E00C4  addi r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 + 196;
	// 830CB7B8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830CB7BC: 48000018  b 0x830cb7d4
	pc = 0x830CB7D4; continue 'dispatch;
	// 830CB7C0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830CB7C4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CB7C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CB7CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CB7D0: 4BFFFE31  bl 0x830cb600
	ctx.lr = 0x830CB7D4;
	sub_830CB600(ctx, base);
	// 830CB7D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB7E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CB7E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830CB7F0 size=96
    let mut pc: u32 = 0x830CB7F0;
    'dispatch: loop {
        match pc {
            0x830CB7F0 => {
    //   block [0x830CB7F0..0x830CB850)
	// 830CB7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB7F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB7FC: 7D432050  subf r10, r3, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 830CB800: 392000C4  li r9, 0xc4
	ctx.r[9].s64 = 196;
	// 830CB804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830CB808: 7CAA4BD6  divw r5, r10, r9
	ctx.r[5].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830CB80C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830CB810: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830CB814: 39250001  addi r9, r5, 1
	ctx.r[9].s64 = ctx.r[5].s64 + 1;
	// 830CB818: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830CB81C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830CB820: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CB824: 7D2B0E70  srawi r11, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 830CB828: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830CB82C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 830CB830: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830CB834: 4BFFFE3D  bl 0x830cb670
	ctx.lr = 0x830CB838;
	sub_830CB670(ctx, base);
	// 830CB838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CB83C: 4BFFEB8D  bl 0x830ca3c8
	ctx.lr = 0x830CB840;
	sub_830CA3C8(ctx, base);
	// 830CB840: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB84C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB850 size=132
    let mut pc: u32 = 0x830CB850;
    'dispatch: loop {
        match pc {
            0x830CB850 => {
    //   block [0x830CB850..0x830CB8D4)
	// 830CB850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CB85C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CB868: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 830CB86C: 4BD47A2D  bl 0x82e13298
	ctx.lr = 0x830CB870;
	sub_82E13298(ctx, base);
	// 830CB870: 807F0210  lwz r3, 0x210(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 830CB874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB878: 419A0008  beq cr6, 0x830cb880
	if ctx.cr[6].eq {
	pc = 0x830CB880; continue 'dispatch;
	}
	// 830CB87C: 4BB1375D  bl 0x82bdefd8
	ctx.lr = 0x830CB880;
	sub_82BDEFD8(ctx, base);
	// 830CB880: 807F020C  lwz r3, 0x20c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 830CB884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB888: 419A0008  beq cr6, 0x830cb890
	if ctx.cr[6].eq {
	pc = 0x830CB890; continue 'dispatch;
	}
	// 830CB88C: 4BB1374D  bl 0x82bdefd8
	ctx.lr = 0x830CB890;
	sub_82BDEFD8(ctx, base);
	// 830CB890: 807F0208  lwz r3, 0x208(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 830CB894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830CB898: 419A0008  beq cr6, 0x830cb8a0
	if ctx.cr[6].eq {
	pc = 0x830CB8A0; continue 'dispatch;
	}
	// 830CB89C: 4BB1373D  bl 0x82bdefd8
	ctx.lr = 0x830CB8A0;
	sub_82BDEFD8(ctx, base);
	// 830CB8A0: 3BFF0208  addi r31, r31, 0x208
	ctx.r[31].s64 = ctx.r[31].s64 + 520;
	// 830CB8A4: 3BC0001F  li r30, 0x1f
	ctx.r[30].s64 = 31;
	// 830CB8A8: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 830CB8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB8B0: 4BFFF799  bl 0x830cb048
	ctx.lr = 0x830CB8B4;
	sub_830CB048(ctx, base);
	// 830CB8B4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830CB8B8: 4080FFF0  bge 0x830cb8a8
	if !ctx.cr[0].lt {
	pc = 0x830CB8A8; continue 'dispatch;
	}
	// 830CB8BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB8C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB8C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB8C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CB8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB8D8 size=116
    let mut pc: u32 = 0x830CB8D8;
    'dispatch: loop {
        match pc {
            0x830CB8D8 => {
    //   block [0x830CB8D8..0x830CB94C)
	// 830CB8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB8E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CB8E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB8E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB8EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830CB8F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830CB8F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830CB8F8: 419A003C  beq cr6, 0x830cb934
	if ctx.cr[6].eq {
	pc = 0x830CB934; continue 'dispatch;
	}
	// 830CB8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CB900: 4BFFD9D9  bl 0x830c92d8
	ctx.lr = 0x830CB904;
	sub_830C92D8(ctx, base);
	// 830CB904: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830CB908: 4080000C  bge 0x830cb914
	if !ctx.cr[0].lt {
	pc = 0x830CB914; continue 'dispatch;
	}
	// 830CB90C: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 830CB910: 48000010  b 0x830cb920
	pc = 0x830CB920; continue 'dispatch;
	// 830CB914: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 830CB918: 40990008  ble cr6, 0x830cb920
	if !ctx.cr[6].gt {
	pc = 0x830CB920; continue 'dispatch;
	}
	// 830CB91C: 3960001E  li r11, 0x1e
	ctx.r[11].s64 = 30;
	// 830CB920: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830CB924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CB928: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830CB92C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 830CB930: 4BFFFE19  bl 0x830cb748
	ctx.lr = 0x830CB934;
	sub_830CB748(ctx, base);
	// 830CB934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB93C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB940: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CB944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830CB950 size=16
    let mut pc: u32 = 0x830CB950;
    'dispatch: loop {
        match pc {
            0x830CB950 => {
    //   block [0x830CB950..0x830CB960)
	// 830CB950: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830CB954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830CB958: 386BBE08  addi r3, r11, -0x41f8
	ctx.r[3].s64 = ctx.r[11].s64 + -16888;
	// 830CB95C: 4BFFFF7C  b 0x830cb8d8
	sub_830CB8D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB960 size=108
    let mut pc: u32 = 0x830CB960;
    'dispatch: loop {
        match pc {
            0x830CB960 => {
    //   block [0x830CB960..0x830CB9CC)
	// 830CB960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CB968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830CB96C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CB970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB974: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 830CB978: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 830CB97C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830CB980: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CB984: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830CB988: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CB98C: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830CB990: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830CB994: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830CB998: 419A0010  beq cr6, 0x830cb9a8
	if ctx.cr[6].eq {
	pc = 0x830CB9A8; continue 'dispatch;
	}
	// 830CB99C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830CB9A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830CB9A4: 4BFFFE4D  bl 0x830cb7f0
	ctx.lr = 0x830CB9A8;
	sub_830CB7F0(ctx, base);
	// 830CB9A8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830CB9AC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 830CB9B0: 4082FFCC  bne 0x830cb97c
	if !ctx.cr[0].eq {
	pc = 0x830CB97C; continue 'dispatch;
	}
	// 830CB9B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CB9B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CB9BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CB9C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830CB9C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CB9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CB9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CB9D0 size=96
    let mut pc: u32 = 0x830CB9D0;
    'dispatch: loop {
        match pc {
            0x830CB9D0 => {
    //   block [0x830CB9D0..0x830CBA30)
	// 830CB9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CB9D4: 480DC795  bl 0x831a8168
	ctx.lr = 0x830CB9D8;
	sub_831A8130(ctx, base);
	// 830CB9D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CB9DC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830CB9E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CB9E4: 3B8BBE08  addi r28, r11, -0x41f8
	ctx.r[28].s64 = ctx.r[11].s64 + -16888;
	// 830CB9E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830CB9EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CB9F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830CB9F4: 4BFFFF6D  bl 0x830cb960
	ctx.lr = 0x830CB9F8;
	sub_830CB960(ctx, base);
	// 830CB9F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CB9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CBA00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830CBA04: 4BFFE025  bl 0x830c9a28
	ctx.lr = 0x830CBA08;
	sub_830C9A28(ctx, base);
	// 830CBA08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CBA0C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830CBA10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CBA14: 4BFFE29D  bl 0x830c9cb0
	ctx.lr = 0x830CBA18;
	sub_830C9CB0(ctx, base);
	// 830CBA18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830CBA1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830CBA20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830CBA24: 4BFFFB3D  bl 0x830cb560
	ctx.lr = 0x830CBA28;
	sub_830CB560(ctx, base);
	// 830CBA28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830CBA2C: 480DC78C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CBA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CBA30 size=116
    let mut pc: u32 = 0x830CBA30;
    'dispatch: loop {
        match pc {
            0x830CBA30 => {
    //   block [0x830CBA30..0x830CBAA4)
	// 830CBA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CBA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830CBA38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830CBA3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CBA40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830CBA44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830CBA48: 419A0040  beq cr6, 0x830cba88
	if ctx.cr[6].eq {
	pc = 0x830CBA88; continue 'dispatch;
	}
	// 830CBA4C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830CBA50: 0CDF0000  twi 6, r31, 0
	// 830CBA54: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 830CBA58: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 830CBA5C: 4098002C  bge cr6, 0x830cba88
	if !ctx.cr[6].lt {
	pc = 0x830CBA88; continue 'dispatch;
	}
	// 830CBA60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830CBA64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830CBA68: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 830CBA6C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830CBA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830CBA74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830CBA78: 4B1F8839  bl 0x822c42b0
	ctx.lr = 0x830CBA7C;
	sub_822C42B0(ctx, base);
	// 830CBA7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830CBA80: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 830CBA84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830CBA88: 1C7F0014  mulli r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 * 20;
	// 830CBA8C: 4B1F4EAD  bl 0x822c0938
	ctx.lr = 0x830CBA90;
	sub_822C0938(ctx, base);
	// 830CBA90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830CBA94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830CBA98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830CBA9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830CBAA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CBAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830CBAA8 size=152
    let mut pc: u32 = 0x830CBAA8;
    'dispatch: loop {
        match pc {
            0x830CBAA8 => {
    //   block [0x830CBAA8..0x830CBB40)
	// 830CBAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830CBAAC: 480DC6BD  bl 0x831a8168
	ctx.lr = 0x830CBAB0;
	sub_831A8130(ctx, base);
	// 830CBAB0: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 830CBAB4: 9421E380  stwu r1, -0x1c80(r1)
	ea = ctx.r[1].u32.wrapping_add(-7296 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830CBAB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830CBABC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830CBAC0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CBAC4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CBAC8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830CBACC: 419A006C  beq cr6, 0x830cbb38
	if ctx.cr[6].eq {
	pc = 0x830CBB38; continue 'dispatch;
	}
	// 830CBAD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830CBAD4: 3BCB09A8  addi r30, r11, 0x9a8
	ctx.r[30].s64 = ctx.r[11].s64 + 2472;
	// 830CBAD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830CBADC: 388000C8  li r4, 0xc8
	ctx.r[4].s64 = 200;
	// 830CBAE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830CBAE4: 4B219805  bl 0x822e52e8
	ctx.lr = 0x830CBAE8;
	sub_822E52E8(ctx, base);
	// 830CBAE8: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 830CBAEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830CBAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830CBAF4: 48000B25  bl 0x830cc618
	ctx.lr = 0x830CBAF8;
	sub_830CC618(ctx, base);
	// 830CBAF8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830CBAFC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830CBB00: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830CBB04: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830CBB08: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CBB0C: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 830CBB10: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830CBB14: 7D0AF02E  lwzx r8, r10, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830CBB18: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830CBB1C: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830CBB20: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830CBB24: 4BB11DC5  bl 0x82bdd8e8
	ctx.lr = 0x830CBB28;
	sub_82BDD8E8(ctx, base);
	// 830CBB28: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CBB2C: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 830CBB30: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830CBB34: 409AFFA4  bne cr6, 0x830cbad8
	if !ctx.cr[6].eq {
	pc = 0x830CBAD8; continue 'dispatch;
	}
	// 830CBB38: 38211C80  addi r1, r1, 0x1c80
	ctx.r[1].s64 = ctx.r[1].s64 + 7296;
	// 830CBB3C: 480DC67C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CBB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830CBB40 size=16
    let mut pc: u32 = 0x830CBB40;
    'dispatch: loop {
        match pc {
            0x830CBB40 => {
    //   block [0x830CBB40..0x830CBB50)
	// 830CBB40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CBB44: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CBB48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830CBB4C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830CBB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830CBB50 size=68
    let mut pc: u32 = 0x830CBB50;
    'dispatch: loop {
        match pc {
            0x830CBB50 => {
    //   block [0x830CBB50..0x830CBB94)
	// 830CBB50: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830CBB54: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830CBB58: 419A0034  beq cr6, 0x830cbb8c
	if ctx.cr[6].eq {
	pc = 0x830CBB8C; continue 'dispatch;
	}
	// 830CBB5C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830CBB60: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830CBB64: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830CBB68: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830CBB6C: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830CBB70: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830CBB74: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830CBB78: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830CBB7C: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830CBB80: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830CBB84: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830CBB88: 409AFFD4  bne cr6, 0x830cbb5c
	if !ctx.cr[6].eq {
	pc = 0x830CBB5C; continue 'dispatch;
	}
	// 830CBB8C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830CBB90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


