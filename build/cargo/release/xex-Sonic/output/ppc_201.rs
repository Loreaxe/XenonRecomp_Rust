pub fn sub_82E859E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E859E0 size=564
    let mut pc: u32 = 0x82E859E0;
    'dispatch: loop {
        match pc {
            0x82E859E0 => {
    //   block [0x82E859E0..0x82E85C14)
	// 82E859E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E859E4: 48322785  bl 0x831a8168
	ctx.lr = 0x82E859E8;
	sub_831A8130(ctx, base);
	// 82E859E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E859EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E859F0: 38600230  li r3, 0x230
	ctx.r[3].s64 = 560;
	// 82E859F4: 4BF6C9CD  bl 0x82df23c0
	ctx.lr = 0x82E859F8;
	sub_82DF23C0(ctx, base);
	// 82E859F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E859FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85A00: 419A000C  beq cr6, 0x82e85a0c
	if ctx.cr[6].eq {
	pc = 0x82E85A0C; continue 'dispatch;
	}
	// 82E85A04: 48007005  bl 0x82e8ca08
	ctx.lr = 0x82E85A08;
	sub_82E8CA08(ctx, base);
	// 82E85A08: 48000008  b 0x82e85a10
	pc = 0x82E85A10; continue 'dispatch;
	// 82E85A0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E85A10: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E85A14: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82E85A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85A1C: 419A001C  beq cr6, 0x82e85a38
	if ctx.cr[6].eq {
	pc = 0x82E85A38; continue 'dispatch;
	}
	// 82E85A20: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85A24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E85A28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E85A2C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85A30: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E85A34: 4E800421  bctrl
	ctx.lr = 0x82E85A38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85A38: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E85A3C: 4BF6C985  bl 0x82df23c0
	ctx.lr = 0x82E85A40;
	sub_82DF23C0(ctx, base);
	// 82E85A40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85A44: 419A000C  beq cr6, 0x82e85a50
	if ctx.cr[6].eq {
	pc = 0x82E85A50; continue 'dispatch;
	}
	// 82E85A48: 48006581  bl 0x82e8bfc8
	ctx.lr = 0x82E85A4C;
	sub_82E8BFC8(ctx, base);
	// 82E85A4C: 48000008  b 0x82e85a54
	pc = 0x82E85A54; continue 'dispatch;
	// 82E85A50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E85A54: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E85A58: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82E85A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85A60: 419A001C  beq cr6, 0x82e85a7c
	if ctx.cr[6].eq {
	pc = 0x82E85A7C; continue 'dispatch;
	}
	// 82E85A64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85A68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E85A6C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E85A70: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85A74: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E85A78: 4E800421  bctrl
	ctx.lr = 0x82E85A7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85A7C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82E85A80: 4BF6C941  bl 0x82df23c0
	ctx.lr = 0x82E85A84;
	sub_82DF23C0(ctx, base);
	// 82E85A84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85A88: 419A000C  beq cr6, 0x82e85a94
	if ctx.cr[6].eq {
	pc = 0x82E85A94; continue 'dispatch;
	}
	// 82E85A8C: 4800D2DD  bl 0x82e92d68
	ctx.lr = 0x82E85A90;
	sub_82E92D68(ctx, base);
	// 82E85A90: 48000008  b 0x82e85a98
	pc = 0x82E85A98; continue 'dispatch;
	// 82E85A94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E85A98: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E85A9C: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82E85AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85AA4: 419A001C  beq cr6, 0x82e85ac0
	if ctx.cr[6].eq {
	pc = 0x82E85AC0; continue 'dispatch;
	}
	// 82E85AA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85AAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E85AB0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E85AB4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85AB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E85ABC: 4E800421  bctrl
	ctx.lr = 0x82E85AC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85AC0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82E85AC4: 4BF6C8FD  bl 0x82df23c0
	ctx.lr = 0x82E85AC8;
	sub_82DF23C0(ctx, base);
	// 82E85AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85ACC: 419A0010  beq cr6, 0x82e85adc
	if ctx.cr[6].eq {
	pc = 0x82E85ADC; continue 'dispatch;
	}
	// 82E85AD0: 480058B9  bl 0x82e8b388
	ctx.lr = 0x82E85AD4;
	sub_82E8B388(ctx, base);
	// 82E85AD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85AD8: 48000008  b 0x82e85ae0
	pc = 0x82E85AE0; continue 'dispatch;
	// 82E85ADC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82E85AE0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E85AE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85AE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85AEC: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 82E85AF0: 4BFFF2E9  bl 0x82e84dd8
	ctx.lr = 0x82E85AF4;
	sub_82E84DD8(ctx, base);
	// 82E85AF4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E85AF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85AFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85B00: 4B43A501  bl 0x822c0000
	ctx.lr = 0x82E85B04;
	sub_822C0000(ctx, base);
	// 82E85B04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E85B08: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E85B0C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E85B10: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E85B14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85B18: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82E85B1C: 419A0008  beq cr6, 0x82e85b24
	if ctx.cr[6].eq {
	pc = 0x82E85B24; continue 'dispatch;
	}
	// 82E85B20: 4B43AD71  bl 0x822c0890
	ctx.lr = 0x82E85B24;
	sub_822C0890(ctx, base);
	// 82E85B24: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82E85B28: 4BF6C899  bl 0x82df23c0
	ctx.lr = 0x82E85B2C;
	sub_82DF23C0(ctx, base);
	// 82E85B2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85B30: 419A0010  beq cr6, 0x82e85b40
	if ctx.cr[6].eq {
	pc = 0x82E85B40; continue 'dispatch;
	}
	// 82E85B34: 48004E05  bl 0x82e8a938
	ctx.lr = 0x82E85B38;
	sub_82E8A938(ctx, base);
	// 82E85B38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85B3C: 48000008  b 0x82e85b44
	pc = 0x82E85B44; continue 'dispatch;
	// 82E85B40: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82E85B44: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E85B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85B4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85B50: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 82E85B54: 4BFFF285  bl 0x82e84dd8
	ctx.lr = 0x82E85B58;
	sub_82E84DD8(ctx, base);
	// 82E85B58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E85B5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85B60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85B64: 4B43A49D  bl 0x822c0000
	ctx.lr = 0x82E85B68;
	sub_822C0000(ctx, base);
	// 82E85B68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E85B6C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E85B70: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E85B74: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E85B78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85B7C: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82E85B80: 419A0008  beq cr6, 0x82e85b88
	if ctx.cr[6].eq {
	pc = 0x82E85B88; continue 'dispatch;
	}
	// 82E85B84: 4B43AD0D  bl 0x822c0890
	ctx.lr = 0x82E85B88;
	sub_822C0890(ctx, base);
	// 82E85B88: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82E85B8C: 4BF6C835  bl 0x82df23c0
	ctx.lr = 0x82E85B90;
	sub_82DF23C0(ctx, base);
	// 82E85B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85B94: 419A0010  beq cr6, 0x82e85ba4
	if ctx.cr[6].eq {
	pc = 0x82E85BA4; continue 'dispatch;
	}
	// 82E85B98: 48004C59  bl 0x82e8a7f0
	ctx.lr = 0x82E85B9C;
	sub_82E8A7F0(ctx, base);
	// 82E85B9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85BA0: 48000008  b 0x82e85ba8
	pc = 0x82E85BA8; continue 'dispatch;
	// 82E85BA4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82E85BA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E85BAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85BB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85BB4: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 82E85BB8: 4BFFF221  bl 0x82e84dd8
	ctx.lr = 0x82E85BBC;
	sub_82E84DD8(ctx, base);
	// 82E85BBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E85BC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85BC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85BC8: 4B43A439  bl 0x822c0000
	ctx.lr = 0x82E85BCC;
	sub_822C0000(ctx, base);
	// 82E85BCC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E85BD0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E85BD4: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E85BD8: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E85BDC: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82E85BE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85BE4: 419A0008  beq cr6, 0x82e85bec
	if ctx.cr[6].eq {
	pc = 0x82E85BEC; continue 'dispatch;
	}
	// 82E85BE8: 4B43ACA9  bl 0x822c0890
	ctx.lr = 0x82E85BEC;
	sub_822C0890(ctx, base);
	// 82E85BEC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82E85BF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82E85BF4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82E85BF8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82E85BFC: 4BF8D6FD  bl 0x82e132f8
	ctx.lr = 0x82E85C00;
	sub_82E132F8(ctx, base);
	// 82E85C00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E85C04: 4BF8D695  bl 0x82e13298
	ctx.lr = 0x82E85C08;
	sub_82E13298(ctx, base);
	// 82E85C08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E85C0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E85C10: 483225A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85C18 size=36
    let mut pc: u32 = 0x82E85C18;
    'dispatch: loop {
        match pc {
            0x82E85C18 => {
    //   block [0x82E85C18..0x82E85C3C)
	// 82E85C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85C20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85C24: 4BFFFDBD  bl 0x82e859e0
	ctx.lr = 0x82E85C28;
	sub_82E859E0(ctx, base);
	// 82E85C28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E85C2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85C40 size=276
    let mut pc: u32 = 0x82E85C40;
    'dispatch: loop {
        match pc {
            0x82E85C40 => {
    //   block [0x82E85C40..0x82E85D54)
	// 82E85C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85C44: 48322519  bl 0x831a815c
	ctx.lr = 0x82E85C48;
	sub_831A8130(ctx, base);
	// 82E85C48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85C4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E85C50: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 82E85C54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E85C58: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E85C5C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E85C60: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E85C64: 4BF6C75D  bl 0x82df23c0
	ctx.lr = 0x82E85C68;
	sub_82DF23C0(ctx, base);
	// 82E85C68: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82E85C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85C70: 419A0010  beq cr6, 0x82e85c80
	if ctx.cr[6].eq {
	pc = 0x82E85C80; continue 'dispatch;
	}
	// 82E85C74: 4BFF876D  bl 0x82e7e3e0
	ctx.lr = 0x82E85C78;
	sub_82E7E3E0(ctx, base);
	// 82E85C78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85C7C: 48000008  b 0x82e85c84
	pc = 0x82E85C84; continue 'dispatch;
	// 82E85C80: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82E85C84: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E85C88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85C8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85C90: 4BFFF481  bl 0x82e85110
	ctx.lr = 0x82E85C94;
	sub_82E85110(ctx, base);
	// 82E85C94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E85C98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E85C9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E85CA0: 4B43A361  bl 0x822c0000
	ctx.lr = 0x82E85CA4;
	sub_822C0000(ctx, base);
	// 82E85CA4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E85CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85CAC: 419A0058  beq cr6, 0x82e85d04
	if ctx.cr[6].eq {
	pc = 0x82E85D04; continue 'dispatch;
	}
	// 82E85CB0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82E85CB4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E85CB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E85CBC: 4BFF8965  bl 0x82e7e620
	ctx.lr = 0x82E85CC0;
	sub_82E7E620(ctx, base);
	// 82E85CC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E85CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85CC8: 409A0010  bne cr6, 0x82e85cd8
	if !ctx.cr[6].eq {
	pc = 0x82E85CD8; continue 'dispatch;
	}
	// 82E85CCC: 933B0000  stw r25, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82E85CD0: 933B0004  stw r25, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82E85CD4: 48000064  b 0x82e85d38
	pc = 0x82E85D38; continue 'dispatch;
	// 82E85CD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85CDC: 38BD0140  addi r5, r29, 0x140
	ctx.r[5].s64 = ctx.r[29].s64 + 320;
	// 82E85CE0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E85CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85CE8: 814B009C  lwz r10, 0x9c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 82E85CEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E85CF0: 4E800421  bctrl
	ctx.lr = 0x82E85CF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85CF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E85CF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E85CFC: 480046A5  bl 0x82e8a3a0
	ctx.lr = 0x82E85D00;
	sub_82E8A3A0(ctx, base);
	// 82E85D00: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E85D04: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E85D08: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E85D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85D10: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E85D14: 419A0034  beq cr6, 0x82e85d48
	if ctx.cr[6].eq {
	pc = 0x82E85D48; continue 'dispatch;
	}
	// 82E85D18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E85D1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E85D20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E85D24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E85D28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E85D2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E85D30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E85D34: 4082FFE8  bne 0x82e85d1c
	if !ctx.cr[0].eq {
	pc = 0x82E85D1C; continue 'dispatch;
	}
	// 82E85D38: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E85D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85D40: 419A0008  beq cr6, 0x82e85d48
	if ctx.cr[6].eq {
	pc = 0x82E85D48; continue 'dispatch;
	}
	// 82E85D44: 4B43AB4D  bl 0x822c0890
	ctx.lr = 0x82E85D48;
	sub_822C0890(ctx, base);
	// 82E85D48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E85D4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E85D50: 4832245C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85D58 size=220
    let mut pc: u32 = 0x82E85D58;
    'dispatch: loop {
        match pc {
            0x82E85D58 => {
    //   block [0x82E85D58..0x82E85E34)
	// 82E85D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85D5C: 483223FD  bl 0x831a8158
	ctx.lr = 0x82E85D60;
	sub_831A8130(ctx, base);
	// 82E85D60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85D64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85D68: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E85D6C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E85D70: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E85D74: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E85D78: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E85D7C: 3B3E0068  addi r25, r30, 0x68
	ctx.r[25].s64 = ctx.r[30].s64 + 104;
	// 82E85D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85D84: 419A00A8  beq cr6, 0x82e85e2c
	if ctx.cr[6].eq {
	pc = 0x82E85E2C; continue 'dispatch;
	}
	// 82E85D88: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E85D8C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E85D90: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E85D94: 41820098  beq 0x82e85e2c
	if ctx.cr[0].eq {
	pc = 0x82E85E2C; continue 'dispatch;
	}
	// 82E85D98: 83FE006C  lwz r31, 0x6c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E85D9C: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E85DA0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E85DA4: 419A0054  beq cr6, 0x82e85df8
	if ctx.cr[6].eq {
	pc = 0x82E85DF8; continue 'dispatch;
	}
	// 82E85DA8: 831F0000  lwz r24, 0(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85DAC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E85DB0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E85DB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E85DB8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E85DBC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85DC0: 93D80018  stw r30, 0x18(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82E85DC4: 9B580060  stb r26, 0x60(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(96 as u32), ctx.r[26].u8 ) };
	// 82E85DC8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E85DD0: 4E800421  bctrl
	ctx.lr = 0x82E85DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85DD4: 81380000  lwz r9, 0(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85DD8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E85DDC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85DE0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82E85DE4: 4E800421  bctrl
	ctx.lr = 0x82E85DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85DE8: 80FE0070  lwz r7, 0x70(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E85DEC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82E85DF0: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82E85DF4: 409AFFB4  bne cr6, 0x82e85da8
	if !ctx.cr[6].eq {
	pc = 0x82E85DA8; continue 'dispatch;
	}
	// 82E85DF8: 480072A9  bl 0x82e8d0a0
	ctx.lr = 0x82E85DFC;
	sub_82E8D0A0(ctx, base);
	// 82E85DFC: 80B90008  lwz r5, 8(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E85E00: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85E04: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82E85E08: 419A0024  beq cr6, 0x82e85e2c
	if ctx.cr[6].eq {
	pc = 0x82E85E2C; continue 'dispatch;
	}
	// 82E85E0C: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82E85E10: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E85E14: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E85E18: 7FE61A14  add r31, r6, r3
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82E85E1C: 4081000C  ble 0x82e85e28
	if !ctx.cr[0].gt {
	pc = 0x82E85E28; continue 'dispatch;
	}
	// 82E85E20: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E85E24: 48322EE5  bl 0x831a8d08
	ctx.lr = 0x82E85E28;
	sub_831A8D08(ctx, base);
	// 82E85E28: 93F90008  stw r31, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82E85E2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E85E30: 48322378  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85E38 size=88
    let mut pc: u32 = 0x82E85E38;
    'dispatch: loop {
        match pc {
            0x82E85E38 => {
    //   block [0x82E85E38..0x82E85E90)
	// 82E85E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E85E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85E4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85E50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E85E54: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E85E58: 419A0020  beq cr6, 0x82e85e78
	if ctx.cr[6].eq {
	pc = 0x82E85E78; continue 'dispatch;
	}
	// 82E85E5C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85E60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85E64: 419A0008  beq cr6, 0x82e85e6c
	if ctx.cr[6].eq {
	pc = 0x82E85E6C; continue 'dispatch;
	}
	// 82E85E68: 4B43AA29  bl 0x822c0890
	ctx.lr = 0x82E85E6C;
	sub_822C0890(ctx, base);
	// 82E85E6C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82E85E70: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E85E74: 409AFFE8  bne cr6, 0x82e85e5c
	if !ctx.cr[6].eq {
	pc = 0x82E85E5C; continue 'dispatch;
	}
	// 82E85E78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E85E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85E84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E85E88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85E90 size=212
    let mut pc: u32 = 0x82E85E90;
    'dispatch: loop {
        match pc {
            0x82E85E90 => {
    //   block [0x82E85E90..0x82E85F64)
	// 82E85E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85E98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E85E9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85EA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85EA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85EAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E85EB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E85EB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E85EB8: 4B43AA81  bl 0x822c0938
	ctx.lr = 0x82E85EBC;
	sub_822C0938(ctx, base);
	// 82E85EBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85EC0: 419A0028  beq cr6, 0x82e85ee8
	if ctx.cr[6].eq {
	pc = 0x82E85EE8; continue 'dispatch;
	}
	// 82E85EC4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E85EC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82E85ECC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E85ED0: 392BE0A8  addi r9, r11, -0x1f58
	ctx.r[9].s64 = ctx.r[11].s64 + -8024;
	// 82E85ED4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E85ED8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E85EDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E85EE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E85EE4: 48000008  b 0x82e85eec
	pc = 0x82E85EEC; continue 'dispatch;
	// 82E85EE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85EEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E85EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85EF4: 409A0054  bne cr6, 0x82e85f48
	if !ctx.cr[6].eq {
	pc = 0x82E85F48; continue 'dispatch;
	}
	// 82E85EF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E85EFC: 419A002C  beq cr6, 0x82e85f28
	if ctx.cr[6].eq {
	pc = 0x82E85F28; continue 'dispatch;
	}
	// 82E85F00: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E85F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85F08: 419A0008  beq cr6, 0x82e85f10
	if ctx.cr[6].eq {
	pc = 0x82E85F10; continue 'dispatch;
	}
	// 82E85F0C: 4B43A985  bl 0x822c0890
	ctx.lr = 0x82E85F10;
	sub_822C0890(ctx, base);
	// 82E85F10: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85F14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85F18: 419A0008  beq cr6, 0x82e85f20
	if ctx.cr[6].eq {
	pc = 0x82E85F20; continue 'dispatch;
	}
	// 82E85F1C: 4B43A975  bl 0x822c0890
	ctx.lr = 0x82E85F20;
	sub_822C0890(ctx, base);
	// 82E85F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85F24: 4B43A345  bl 0x822c0268
	ctx.lr = 0x82E85F28;
	sub_822C0268(ctx, base);
	// 82E85F28: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E85F2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E85F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E85F34: 392A0828  addi r9, r10, 0x828
	ctx.r[9].s64 = ctx.r[10].s64 + 2088;
	// 82E85F38: 816BBAF4  lwz r11, -0x450c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17676 as u32) ) } as u64;
	// 82E85F3C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82E85F40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E85F44: 4B43A0BD  bl 0x822c0000
	ctx.lr = 0x82E85F48;
	sub_822C0000(ctx, base);
	// 82E85F48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E85F4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E85F50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85F54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85F58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E85F5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85F68 size=88
    let mut pc: u32 = 0x82E85F68;
    'dispatch: loop {
        match pc {
            0x82E85F68 => {
    //   block [0x82E85F68..0x82E85FC0)
	// 82E85F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85F74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85F78: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E85F7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E85F80: 419A002C  beq cr6, 0x82e85fac
	if ctx.cr[6].eq {
	pc = 0x82E85FAC; continue 'dispatch;
	}
	// 82E85F84: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E85F88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85F8C: 419A0008  beq cr6, 0x82e85f94
	if ctx.cr[6].eq {
	pc = 0x82E85F94; continue 'dispatch;
	}
	// 82E85F90: 4B43A901  bl 0x822c0890
	ctx.lr = 0x82E85F94;
	sub_822C0890(ctx, base);
	// 82E85F94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85F98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E85F9C: 419A0008  beq cr6, 0x82e85fa4
	if ctx.cr[6].eq {
	pc = 0x82E85FA4; continue 'dispatch;
	}
	// 82E85FA0: 4B43A8F1  bl 0x822c0890
	ctx.lr = 0x82E85FA4;
	sub_822C0890(ctx, base);
	// 82E85FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85FA8: 4B43A2C1  bl 0x822c0268
	ctx.lr = 0x82E85FAC;
	sub_822C0268(ctx, base);
	// 82E85FAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85FC0 size=216
    let mut pc: u32 = 0x82E85FC0;
    'dispatch: loop {
        match pc {
            0x82E85FC0 => {
    //   block [0x82E85FC0..0x82E86098)
	// 82E85FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85FC4: 48322199  bl 0x831a815c
	ctx.lr = 0x82E85FC8;
	sub_831A8130(ctx, base);
	// 82E85FC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85FCC: 83240004  lwz r25, 4(r4)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85FD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85FD4: 83440000  lwz r26, 0(r4)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85FD8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E85FDC: 419A0024  beq cr6, 0x82e86000
	if ctx.cr[6].eq {
	pc = 0x82E86000; continue 'dispatch;
	}
	// 82E85FE0: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 82E85FE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E85FE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E85FEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E85FF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E85FF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E85FF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E85FFC: 4082FFE8  bne 0x82e85fe4
	if !ctx.cr[0].eq {
	pc = 0x82E85FE4; continue 'dispatch;
	}
	// 82E86000: 837E0004  lwz r27, 4(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86004: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86008: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E8600C: 419A0074  beq cr6, 0x82e86080
	if ctx.cr[6].eq {
	pc = 0x82E86080; continue 'dispatch;
	}
	// 82E86010: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82E86014: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86018: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E8601C: 409A0058  bne cr6, 0x82e86074
	if !ctx.cr[6].eq {
	pc = 0x82E86074; continue 'dispatch;
	}
	// 82E86020: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86024: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86028: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8602C: 419A0040  beq cr6, 0x82e8606c
	if ctx.cr[6].eq {
	pc = 0x82E8606C; continue 'dispatch;
	}
	// 82E86030: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86034: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E86038: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8603C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86040: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E86044: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86048: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8604C: 419A0008  beq cr6, 0x82e86054
	if ctx.cr[6].eq {
	pc = 0x82E86054; continue 'dispatch;
	}
	// 82E86050: 4B43A841  bl 0x822c0890
	ctx.lr = 0x82E86054;
	sub_822C0890(ctx, base);
	// 82E86054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E86058: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8605C: 4BF6C12D  bl 0x82df2188
	ctx.lr = 0x82E86060;
	sub_82DF2188(ctx, base);
	// 82E86060: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86064: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E86068: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8606C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82E86070: 48000008  b 0x82e86078
	pc = 0x82E86078; continue 'dispatch;
	// 82E86074: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86078: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E8607C: 409AFF98  bne cr6, 0x82e86014
	if !ctx.cr[6].eq {
	pc = 0x82E86014; continue 'dispatch;
	}
	// 82E86080: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E86084: 419A000C  beq cr6, 0x82e86090
	if ctx.cr[6].eq {
	pc = 0x82E86090; continue 'dispatch;
	}
	// 82E86088: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E8608C: 4B43A805  bl 0x822c0890
	ctx.lr = 0x82E86090;
	sub_822C0890(ctx, base);
	// 82E86090: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E86094: 48322118  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86098 size=124
    let mut pc: u32 = 0x82E86098;
    'dispatch: loop {
        match pc {
            0x82E86098 => {
    //   block [0x82E86098..0x82E86114)
	// 82E86098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8609C: 483220CD  bl 0x831a8168
	ctx.lr = 0x82E860A0;
	sub_831A8130(ctx, base);
	// 82E860A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E860A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E860A8: 83850000  lwz r28, 0(r5)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E860AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E860B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E860B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E860B8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E860BC: 419A0048  beq cr6, 0x82e86104
	if ctx.cr[6].eq {
	pc = 0x82E86104; continue 'dispatch;
	}
	// 82E860C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E860C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E860C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E860CC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E860D0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E860D4: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82E860D8: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E860DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E860E0: 419A0008  beq cr6, 0x82e860e8
	if ctx.cr[6].eq {
	pc = 0x82E860E8; continue 'dispatch;
	}
	// 82E860E4: 4B43A7AD  bl 0x822c0890
	ctx.lr = 0x82E860E8;
	sub_822C0890(ctx, base);
	// 82E860E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E860EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E860F0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E860F4: 4BF6C095  bl 0x82df2188
	ctx.lr = 0x82E860F8;
	sub_82DF2188(ctx, base);
	// 82E860F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E860FC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82E86100: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E86104: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82E86108: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8610C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86110: 483220A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86118 size=188
    let mut pc: u32 = 0x82E86118;
    'dispatch: loop {
        match pc {
            0x82E86118 => {
    //   block [0x82E86118..0x82E861D4)
	// 82E86118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8611C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86124: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86128: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8612C: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 82E86130: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E86134: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82E86138: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82E8613C: 38A00012  li r5, 0x12
	ctx.r[5].s64 = 18;
	// 82E86140: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82E86144: 388994BC  addi r4, r9, -0x6b44
	ctx.r[4].s64 = ctx.r[9].s64 + -27460;
	// 82E86148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8614C: 4B43F51D  bl 0x822c5668
	ctx.lr = 0x82E86150;
	sub_822C5668(ctx, base);
	// 82E86150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E86154: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E86158: 4B43F6C1  bl 0x822c5818
	ctx.lr = 0x82E8615C;
	sub_822C5818(ctx, base);
	// 82E8615C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E86160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86164: 814B55A0  lwz r10, 0x55a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21920 as u32) ) } as u64;
	// 82E86168: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8616C: 419A0010  beq cr6, 0x82e8617c
	if ctx.cr[6].eq {
	pc = 0x82E8617C; continue 'dispatch;
	}
	// 82E86170: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86178: 4E800421  bctrl
	ctx.lr = 0x82E8617C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8617C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86184: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86188: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8618C: 4E800421  bctrl
	ctx.lr = 0x82E86190;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E86190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86194: 4BF6A3AD  bl 0x82df0540
	ctx.lr = 0x82E86198;
	sub_82DF0540(ctx, base);
	// 82E86198: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82E8619C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E861A0: 390994A0  addi r8, r9, -0x6b60
	ctx.r[8].s64 = ctx.r[9].s64 + -27488;
	// 82E861A4: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 82E861A8: 4B43F2C9  bl 0x822c5470
	ctx.lr = 0x82E861AC;
	sub_822C5470(ctx, base);
	// 82E861AC: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E861B0: 2B070010  cmplwi cr6, r7, 0x10
	ctx.cr[6].compare_u32(ctx.r[7].u32, 16 as u32, &mut ctx.xer);
	// 82E861B4: 4198000C  blt cr6, 0x82e861c0
	if ctx.cr[6].lt {
	pc = 0x82E861C0; continue 'dispatch;
	}
	// 82E861B8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E861BC: 4B43A0AD  bl 0x822c0268
	ctx.lr = 0x82E861C0;
	sub_822C0268(ctx, base);
	// 82E861C0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E861C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E861C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E861CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E861D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E861D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E861D8 size=152
    let mut pc: u32 = 0x82E861D8;
    'dispatch: loop {
        match pc {
            0x82E861D8 => {
    //   block [0x82E861D8..0x82E86270)
	// 82E861D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E861DC: 48321F89  bl 0x831a8164
	ctx.lr = 0x82E861E0;
	sub_831A8130(ctx, base);
	// 82E861E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E861E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E861E8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E861EC: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E861F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E861F4: 419A0074  beq cr6, 0x82e86268
	if ctx.cr[6].eq {
	pc = 0x82E86268; continue 'dispatch;
	}
	// 82E861F8: 839E0060  lwz r28, 0x60(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E861FC: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86200: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E86204: 419A0064  beq cr6, 0x82e86268
	if ctx.cr[6].eq {
	pc = 0x82E86268; continue 'dispatch;
	}
	// 82E86208: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8620C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E86210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E86214: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86218: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8621C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86220: 4BFFED81  bl 0x82e84fa0
	ctx.lr = 0x82E86224;
	sub_82E84FA0(ctx, base);
	// 82E86224: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E86228: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8622C: 419A0030  beq cr6, 0x82e8625c
	if ctx.cr[6].eq {
	pc = 0x82E8625C; continue 'dispatch;
	}
	// 82E86230: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E86238: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8623C: 80A40010  lwz r5, 0x10(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E86240: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E86244: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E86248: 4E800421  bctrl
	ctx.lr = 0x82E8624C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8624C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E86250: 389E005C  addi r4, r30, 0x5c
	ctx.r[4].s64 = ctx.r[30].s64 + 92;
	// 82E86254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E86258: 4BFFFE41  bl 0x82e86098
	ctx.lr = 0x82E8625C;
	sub_82E86098(ctx, base);
	// 82E8625C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82E86260: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E86264: 409AFFA4  bne cr6, 0x82e86208
	if !ctx.cr[6].eq {
	pc = 0x82E86208; continue 'dispatch;
	}
	// 82E86268: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8626C: 48321F48  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E86270 size=12
    let mut pc: u32 = 0x82E86270;
    'dispatch: loop {
        match pc {
            0x82E86270 => {
    //   block [0x82E86270..0x82E8627C)
	// 82E86270: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86278: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8627C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8627C size=8
    let mut pc: u32 = 0x82E8627C;
    'dispatch: loop {
        match pc {
            0x82E8627C => {
    //   block [0x82E8627C..0x82E86284)
	// 82E8627C: 38630038  addi r3, r3, 0x38
	ctx.r[3].s64 = ctx.r[3].s64 + 56;
	// 82E86280: 4BFFFD40  b 0x82e85fc0
	sub_82E85FC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86284(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E86284 size=4
    let mut pc: u32 = 0x82E86284;
    'dispatch: loop {
        match pc {
            0x82E86284 => {
    //   block [0x82E86284..0x82E86288)
	// 82E86284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86288 size=48
    let mut pc: u32 = 0x82E86288;
    'dispatch: loop {
        match pc {
            0x82E86288 => {
    //   block [0x82E86288..0x82E862B8)
	// 82E86288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8628C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86290: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86294: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E86298: 38830038  addi r4, r3, 0x38
	ctx.r[4].s64 = ctx.r[3].s64 + 56;
	// 82E8629C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E862A0: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E862A4: 4B83EEC5  bl 0x826c5168
	ctx.lr = 0x82E862A8;
	sub_826C5168(ctx, base);
	// 82E862A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E862AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E862B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E862B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E862B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E862B8 size=56
    let mut pc: u32 = 0x82E862B8;
    'dispatch: loop {
        match pc {
            0x82E862B8 => {
    //   block [0x82E862B8..0x82E862F0)
	// 82E862B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E862BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E862C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E862C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E862C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E862CC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82E862D0: 4B9801E9  bl 0x828064b8
	ctx.lr = 0x82E862D4;
	sub_828064B8(ctx, base);
	// 82E862D4: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E862D8: 4B9801E1  bl 0x828064b8
	ctx.lr = 0x82E862DC;
	sub_828064B8(ctx, base);
	// 82E862DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E862E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E862E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E862E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E862EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E862F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E862F0 size=12
    let mut pc: u32 = 0x82E862F0;
    'dispatch: loop {
        match pc {
            0x82E862F0 => {
    //   block [0x82E862F0..0x82E862FC)
	// 82E862F0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E862F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E862F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E862FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E862FC size=8
    let mut pc: u32 = 0x82E862FC;
    'dispatch: loop {
        match pc {
            0x82E862FC => {
    //   block [0x82E862FC..0x82E86304)
	// 82E862FC: 38630044  addi r3, r3, 0x44
	ctx.r[3].s64 = ctx.r[3].s64 + 68;
	// 82E86300: 4BFFFCC0  b 0x82e85fc0
	sub_82E85FC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86304(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E86304 size=4
    let mut pc: u32 = 0x82E86304;
    'dispatch: loop {
        match pc {
            0x82E86304 => {
    //   block [0x82E86304..0x82E86308)
	// 82E86304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86308 size=48
    let mut pc: u32 = 0x82E86308;
    'dispatch: loop {
        match pc {
            0x82E86308 => {
    //   block [0x82E86308..0x82E86338)
	// 82E86308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8630C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86314: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E86318: 38830044  addi r4, r3, 0x44
	ctx.r[4].s64 = ctx.r[3].s64 + 68;
	// 82E8631C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E86320: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86324: 4B83EE45  bl 0x826c5168
	ctx.lr = 0x82E86328;
	sub_826C5168(ctx, base);
	// 82E86328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8632C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86338 size=764
    let mut pc: u32 = 0x82E86338;
    'dispatch: loop {
        match pc {
            0x82E86338 => {
    //   block [0x82E86338..0x82E86634)
	// 82E86338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8633C: 48321E1D  bl 0x831a8158
	ctx.lr = 0x82E86340;
	sub_831A8130(ctx, base);
	// 82E86340: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86344: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E86348: 83060000  lwz r24, 0(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8634C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E86350: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82E86354: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86358: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8635C: 409A000C  bne cr6, 0x82e86368
	if !ctx.cr[6].eq {
	pc = 0x82E86368; continue 'dispatch;
	}
	// 82E86360: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E86364: 48000010  b 0x82e86374
	pc = 0x82E86374; continue 'dispatch;
	// 82E86368: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8636C: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E86370: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82E86374: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E86378: 419A02B4  beq cr6, 0x82e8662c
	if ctx.cr[6].eq {
	pc = 0x82E8662C; continue 'dispatch;
	}
	// 82E8637C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E86380: 409A000C  bne cr6, 0x82e8638c
	if !ctx.cr[6].eq {
	pc = 0x82E8638C; continue 'dispatch;
	}
	// 82E86384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86388: 48000010  b 0x82e86398
	pc = 0x82E86398; continue 'dispatch;
	// 82E8638C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86390: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E86394: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82E86398: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82E8639C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E863A0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E863A4: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E863A8: 40980010  bge cr6, 0x82e863b8
	if !ctx.cr[6].lt {
	pc = 0x82E863B8; continue 'dispatch;
	}
	// 82E863AC: 4BFFFD6D  bl 0x82e86118
	ctx.lr = 0x82E863B0;
	sub_82E86118(ctx, base);
	// 82E863B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E863B4: 48321DF4  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
	// 82E863B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E863BC: 409A000C  bne cr6, 0x82e863c8
	if !ctx.cr[6].eq {
	pc = 0x82E863C8; continue 'dispatch;
	}
	// 82E863C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E863C4: 48000010  b 0x82e863d4
	pc = 0x82E863D4; continue 'dispatch;
	// 82E863C8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E863CC: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E863D0: 7CEB1670  srawi r11, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 82E863D4: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82E863D8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E863DC: 40980144  bge cr6, 0x82e86520
	if !ctx.cr[6].lt {
	pc = 0x82E86520; continue 'dispatch;
	}
	// 82E863E0: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E863E4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E863E8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E863EC: 4098000C  bge cr6, 0x82e863f8
	if !ctx.cr[6].lt {
	pc = 0x82E863F8; continue 'dispatch;
	}
	// 82E863F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E863F4: 48000008  b 0x82e863fc
	pc = 0x82E863FC; continue 'dispatch;
	// 82E863F8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82E863FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E86400: 409A000C  bne cr6, 0x82e8640c
	if !ctx.cr[6].eq {
	pc = 0x82E8640C; continue 'dispatch;
	}
	// 82E86404: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E86408: 48000010  b 0x82e86418
	pc = 0x82E86418; continue 'dispatch;
	// 82E8640C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86410: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82E86414: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82E86418: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 82E8641C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E86420: 40980024  bge cr6, 0x82e86444
	if !ctx.cr[6].lt {
	pc = 0x82E86444; continue 'dispatch;
	}
	// 82E86424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E86428: 409A000C  bne cr6, 0x82e86434
	if !ctx.cr[6].eq {
	pc = 0x82E86434; continue 'dispatch;
	}
	// 82E8642C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86430: 48000010  b 0x82e86440
	pc = 0x82E86440; continue 'dispatch;
	// 82E86434: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86438: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E8643C: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82E86440: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82E86444: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82E86448: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82E8644C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86450: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E86454: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 82E86458: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E8645C: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E86460: 4BF6BC69  bl 0x82df20c8
	ctx.lr = 0x82E86464;
	sub_82DF20C8(ctx, base);
	// 82E86464: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8646C: 7D45D050  subf r10, r5, r26
	ctx.r[10].s64 = ctx.r[26].s64 - ctx.r[5].s64;
	// 82E86470: 7D4B1671  srawi. r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86474: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E86478: 7FC6FA14  add r30, r6, r31
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82E8647C: 4182000C  beq 0x82e86488
	if ctx.cr[0].eq {
	pc = 0x82E86488; continue 'dispatch;
	}
	// 82E86480: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E86484: 48322885  bl 0x831a8d08
	ctx.lr = 0x82E86488;
	sub_831A8D08(ctx, base);
	// 82E86488: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E8648C: 419A0018  beq cr6, 0x82e864a4
	if ctx.cr[6].eq {
	pc = 0x82E864A4; continue 'dispatch;
	}
	// 82E86490: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E86494: 7F2903A6  mtctr r25
	ctx.ctr.u64 = ctx.r[25].u64;
	// 82E86498: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82E8649C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E864A0: 4200FFF8  bdnz 0x82e86498
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E86498; continue 'dispatch;
	}
	// 82E864A4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E864A8: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 82E864AC: 7D4B1671  srawi. r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E864B0: 4182001C  beq 0x82e864cc
	if ctx.cr[0].eq {
	pc = 0x82E864CC; continue 'dispatch;
	}
	// 82E864B4: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82E864B8: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E864BC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E864C0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E864C4: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E864C8: 48322841  bl 0x831a8d08
	ctx.lr = 0x82E864CC;
	sub_831A8D08(ctx, base);
	// 82E864CC: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E864D0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E864D4: 409A000C  bne cr6, 0x82e864e0
	if !ctx.cr[6].eq {
	pc = 0x82E864E0; continue 'dispatch;
	}
	// 82E864D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E864DC: 48000010  b 0x82e864ec
	pc = 0x82E864EC; continue 'dispatch;
	// 82E864E0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E864E4: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82E864E8: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82E864EC: 7FCBCA14  add r30, r11, r25
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82E864F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E864F4: 419A000C  beq cr6, 0x82e86500
	if ctx.cr[6].eq {
	pc = 0x82E86500; continue 'dispatch;
	}
	// 82E864F8: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E864FC: 4BF6BC8D  bl 0x82df2188
	ctx.lr = 0x82E86500;
	sub_82DF2188(ctx, base);
	// 82E86500: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86504: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82E86508: 7D5BFA14  add r10, r27, r31
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 82E8650C: 7D2BFA14  add r9, r11, r31
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82E86510: 915C000C  stw r10, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E86514: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E86518: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8651C: 48321C8C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
	// 82E86520: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86524: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82E86528: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82E8652C: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E86530: 40980088  bge cr6, 0x82e865b8
	if !ctx.cr[6].lt {
	pc = 0x82E865B8; continue 'dispatch;
	}
	// 82E86534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86538: 419A001C  beq cr6, 0x82e86554
	if ctx.cr[6].eq {
	pc = 0x82E86554; continue 'dispatch;
	}
	// 82E8653C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82E86540: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86544: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E86548: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E8654C: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82E86550: 483227B9  bl 0x831a8d08
	ctx.lr = 0x82E86554;
	sub_831A8D08(ctx, base);
	// 82E86554: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86558: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 82E8655C: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82E86560: 7D49C851  subf. r10, r9, r25
	ctx.r[10].s64 = ctx.r[25].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E86564: 4182001C  beq 0x82e86580
	if ctx.cr[0].eq {
	pc = 0x82E86580; continue 'dispatch;
	}
	// 82E86568: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8656C: 419A0014  beq cr6, 0x82e86580
	if ctx.cr[6].eq {
	pc = 0x82E86580; continue 'dispatch;
	}
	// 82E86570: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E86574: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82E86578: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E8657C: 4200FFF8  bdnz 0x82e86574
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E86574; continue 'dispatch;
	}
	// 82E86580: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86584: 5729103A  slwi r9, r25, 2
	ctx.r[9].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E86588: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82E8658C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82E86590: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82E86594: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E86598: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8659C: 419A0090  beq cr6, 0x82e8662c
	if ctx.cr[6].eq {
	pc = 0x82E8662C; continue 'dispatch;
	}
	// 82E865A0: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82E865A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E865A8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E865AC: 409AFFF4  bne cr6, 0x82e865a0
	if !ctx.cr[6].eq {
	pc = 0x82E865A0; continue 'dispatch;
	}
	// 82E865B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E865B4: 48321BF4  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
	// 82E865B8: 573B103A  slwi r27, r25, 2
	ctx.r[27].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82E865BC: 7FDBF850  subf r30, r27, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82E865C0: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82E865C4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E865C8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E865CC: 7FA6FA14  add r29, r6, r31
	ctx.r[29].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82E865D0: 41820014  beq 0x82e865e4
	if ctx.cr[0].eq {
	pc = 0x82E865E4; continue 'dispatch;
	}
	// 82E865D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E865D8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E865DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E865E0: 48322729  bl 0x831a8d08
	ctx.lr = 0x82E865E4;
	sub_831A8D08(ctx, base);
	// 82E865E4: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 82E865E8: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E865EC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E865F0: 4081001C  ble 0x82e8660c
	if !ctx.cr[0].gt {
	pc = 0x82E8660C; continue 'dispatch;
	}
	// 82E865F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E865F8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E865FC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82E86600: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E86604: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E86608: 48322701  bl 0x831a8d08
	ctx.lr = 0x82E8660C;
	sub_831A8D08(ctx, base);
	// 82E8660C: 7D5BD214  add r10, r27, r26
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[26].u64;
	// 82E86610: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82E86614: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E86618: 419A0014  beq cr6, 0x82e8662c
	if ctx.cr[6].eq {
	pc = 0x82E8662C; continue 'dispatch;
	}
	// 82E8661C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82E86620: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E86624: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E86628: 409AFFF4  bne cr6, 0x82e8661c
	if !ctx.cr[6].eq {
	pc = 0x82E8661C; continue 'dispatch;
	}
	// 82E8662C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E86630: 48321B78  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86638 size=120
    let mut pc: u32 = 0x82E86638;
    'dispatch: loop {
        match pc {
            0x82E86638 => {
    //   block [0x82E86638..0x82E866B0)
	// 82E86638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8663C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E86644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8664C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86650: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86654: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86658: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E8665C: 419A003C  beq cr6, 0x82e86698
	if ctx.cr[6].eq {
	pc = 0x82E86698; continue 'dispatch;
	}
	// 82E86660: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E86664: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86668: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8666C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86670: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82E86674: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E86678: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8667C: 4BFFEA05  bl 0x82e85080
	ctx.lr = 0x82E86680;
	sub_82E85080(ctx, base);
	// 82E86680: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E86684: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86688: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8668C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E86690: 4BFFF7A9  bl 0x82e85e38
	ctx.lr = 0x82E86694;
	sub_82E85E38(ctx, base);
	// 82E86694: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E86698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8669C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E866A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E866A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E866A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E866AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E866B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E866B0 size=156
    let mut pc: u32 = 0x82E866B0;
    'dispatch: loop {
        match pc {
            0x82E866B0 => {
    //   block [0x82E866B0..0x82E8674C)
	// 82E866B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E866B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E866B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E866BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E866C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E866C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E866C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E866CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E866D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E866D4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E866D8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E866DC: 409A000C  bne cr6, 0x82e866e8
	if !ctx.cr[6].eq {
	pc = 0x82E866E8; continue 'dispatch;
	}
	// 82E866E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E866E4: 48000050  b 0x82e86734
	pc = 0x82E86734; continue 'dispatch;
	// 82E866E8: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82E866EC: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82E866F0: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E866F4: 4099000C  ble cr6, 0x82e86700
	if !ctx.cr[6].gt {
	pc = 0x82E86700; continue 'dispatch;
	}
	// 82E866F8: 4BFFFA21  bl 0x82e86118
	ctx.lr = 0x82E866FC;
	sub_82E86118(ctx, base);
	// 82E866FC: 48000034  b 0x82e86730
	pc = 0x82E86730; continue 'dispatch;
	// 82E86700: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E86704: 549E1838  slwi r30, r4, 3
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82E86708: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8670C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E86710: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82E86714: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E86718: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8671C: 4BF6B9AD  bl 0x82df20c8
	ctx.lr = 0x82E86720;
	sub_82DF20C8(ctx, base);
	// 82E86720: 7D3E1A14  add r9, r30, r3
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 82E86724: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82E86728: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82E8672C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E86730: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E86734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E86738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8673C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E86744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86750 size=420
    let mut pc: u32 = 0x82E86750;
    'dispatch: loop {
        match pc {
            0x82E86750 => {
    //   block [0x82E86750..0x82E868F4)
	// 82E86750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86754: 48321A11  bl 0x831a8164
	ctx.lr = 0x82E86758;
	sub_831A8130(ctx, base);
	// 82E86758: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8675C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86760: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E86764: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E86768: 390BE0D8  addi r8, r11, -0x1f28
	ctx.r[8].s64 = ctx.r[11].s64 + -7976;
	// 82E8676C: 38EAE0CC  addi r7, r10, -0x1f34
	ctx.r[7].s64 = ctx.r[10].s64 + -7988;
	// 82E86770: 83DF006C  lwz r30, 0x6c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E86774: 3B7F0004  addi r27, r31, 4
	ctx.r[27].s64 = ctx.r[31].s64 + 4;
	// 82E86778: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E8677C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E86780: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82E86784: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E86788: 419A0028  beq cr6, 0x82e867b0
	if ctx.cr[6].eq {
	pc = 0x82E867B0; continue 'dispatch;
	}
	// 82E8678C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86790: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86794: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8679C: 4E800421  bctrl
	ctx.lr = 0x82E867A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E867A0: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E867A4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E867A8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E867AC: 409AFFE0  bne cr6, 0x82e8678c
	if !ctx.cr[6].eq {
	pc = 0x82E8678C; continue 'dispatch;
	}
	// 82E867B0: 480069B1  bl 0x82e8d160
	ctx.lr = 0x82E867B4;
	sub_82E8D160(ctx, base);
	// 82E867B4: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E867B8: 3B9F0068  addi r28, r31, 0x68
	ctx.r[28].s64 = ctx.r[31].s64 + 104;
	// 82E867BC: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82E867C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E867C4: 419A000C  beq cr6, 0x82e867d0
	if ctx.cr[6].eq {
	pc = 0x82E867D0; continue 'dispatch;
	}
	// 82E867C8: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E867CC: 4BF6B9BD  bl 0x82df2188
	ctx.lr = 0x82E867D0;
	sub_82DF2188(ctx, base);
	// 82E867D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E867D4: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 82E867D8: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E867DC: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E867E0: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E867E4: 4BFF759D  bl 0x82e7dd80
	ctx.lr = 0x82E867E8;
	sub_82E7DD80(ctx, base);
	// 82E867E8: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E867EC: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E867F0: 4BF6B999  bl 0x82df2188
	ctx.lr = 0x82E867F4;
	sub_82DF2188(ctx, base);
	// 82E867F4: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82E867F8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82E867FC: 4B97FCBD  bl 0x828064b8
	ctx.lr = 0x82E86800;
	sub_828064B8(ctx, base);
	// 82E86800: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E86804: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E86808: 4BF6B981  bl 0x82df2188
	ctx.lr = 0x82E8680C;
	sub_82DF2188(ctx, base);
	// 82E8680C: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E86810: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E86814: 4B97FCA5  bl 0x828064b8
	ctx.lr = 0x82E86818;
	sub_828064B8(ctx, base);
	// 82E86818: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8681C: 809F0048  lwz r4, 0x48(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E86820: 4BF6B969  bl 0x82df2188
	ctx.lr = 0x82E86824;
	sub_82DF2188(ctx, base);
	// 82E86824: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82E86828: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82E8682C: 4B97FC8D  bl 0x828064b8
	ctx.lr = 0x82E86830;
	sub_828064B8(ctx, base);
	// 82E86830: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E86834: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E86838: 4BF6B951  bl 0x82df2188
	ctx.lr = 0x82E8683C;
	sub_82DF2188(ctx, base);
	// 82E8683C: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82E86840: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E86844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86848: 419A0008  beq cr6, 0x82e86850
	if ctx.cr[6].eq {
	pc = 0x82E86850; continue 'dispatch;
	}
	// 82E8684C: 4B43A045  bl 0x822c0890
	ctx.lr = 0x82E86850;
	sub_822C0890(ctx, base);
	// 82E86850: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E86854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86858: 419A0008  beq cr6, 0x82e86860
	if ctx.cr[6].eq {
	pc = 0x82E86860; continue 'dispatch;
	}
	// 82E8685C: 4B43A035  bl 0x822c0890
	ctx.lr = 0x82E86860;
	sub_822C0890(ctx, base);
	// 82E86860: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E86864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86868: 419A0008  beq cr6, 0x82e86870
	if ctx.cr[6].eq {
	pc = 0x82E86870; continue 'dispatch;
	}
	// 82E8686C: 4B43A025  bl 0x822c0890
	ctx.lr = 0x82E86870;
	sub_822C0890(ctx, base);
	// 82E86870: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E86874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86878: 419A0018  beq cr6, 0x82e86890
	if ctx.cr[6].eq {
	pc = 0x82E86890; continue 'dispatch;
	}
	// 82E8687C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86880: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E86884: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86888: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8688C: 4E800421  bctrl
	ctx.lr = 0x82E86890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E86890: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E86894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86898: 419A0018  beq cr6, 0x82e868b0
	if ctx.cr[6].eq {
	pc = 0x82E868B0; continue 'dispatch;
	}
	// 82E8689C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E868A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E868AC: 4E800421  bctrl
	ctx.lr = 0x82E868B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E868B0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E868B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E868B8: 419A0018  beq cr6, 0x82e868d0
	if ctx.cr[6].eq {
	pc = 0x82E868D0; continue 'dispatch;
	}
	// 82E868BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E868C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E868CC: 4E800421  bctrl
	ctx.lr = 0x82E868D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E868D0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82E868D4: 4BF8C9C5  bl 0x82e13298
	ctx.lr = 0x82E868D8;
	sub_82E13298(ctx, base);
	// 82E868D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E868DC: 4BF8B615  bl 0x82e11ef0
	ctx.lr = 0x82E868E0;
	sub_82E11EF0(ctx, base);
	// 82E868E0: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 82E868E4: 394B3114  addi r10, r11, 0x3114
	ctx.r[10].s64 = ctx.r[11].s64 + 12564;
	// 82E868E8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E868EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E868F0: 483218C4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E868F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E868F8 size=8
    let mut pc: u32 = 0x82E868F8;
    'dispatch: loop {
        match pc {
            0x82E868F8 => {
    //   block [0x82E868F8..0x82E86900)
	// 82E868F8: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82E868FC: 48000584  b 0x82e86e80
	sub_82E86E80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86900 size=756
    let mut pc: u32 = 0x82E86900;
    'dispatch: loop {
        match pc {
            0x82E86900 => {
    //   block [0x82E86900..0x82E86BF4)
	// 82E86900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86904: 48321851  bl 0x831a8154
	ctx.lr = 0x82E86908;
	sub_831A8130(ctx, base);
	// 82E86908: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8690C: 82E60004  lwz r23, 4(r6)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86914: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86918: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8691C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E86920: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82E86924: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 82E86928: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E8692C: 419A0024  beq cr6, 0x82e86950
	if ctx.cr[6].eq {
	pc = 0x82E86950; continue 'dispatch;
	}
	// 82E86930: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 82E86934: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E86938: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8693C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E86940: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E86944: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E86948: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8694C: 4082FFE8  bne 0x82e86934
	if !ctx.cr[0].eq {
	pc = 0x82E86934; continue 'dispatch;
	}
	// 82E86950: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86954: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82E86958: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E8695C: 409A000C  bne cr6, 0x82e86968
	if !ctx.cr[6].eq {
	pc = 0x82E86968; continue 'dispatch;
	}
	// 82E86960: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 82E86964: 48000010  b 0x82e86974
	pc = 0x82E86974; continue 'dispatch;
	// 82E86968: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8696C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82E86970: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82E86974: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E86978: 419A0264  beq cr6, 0x82e86bdc
	if ctx.cr[6].eq {
	pc = 0x82E86BDC; continue 'dispatch;
	}
	// 82E8697C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E86980: 409A000C  bne cr6, 0x82e8698c
	if !ctx.cr[6].eq {
	pc = 0x82E8698C; continue 'dispatch;
	}
	// 82E86984: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82E86988: 48000010  b 0x82e86998
	pc = 0x82E86998; continue 'dispatch;
	// 82E8698C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86990: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82E86994: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82E86998: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 82E8699C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E869A0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E869A4: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E869A8: 4098000C  bge cr6, 0x82e869b4
	if !ctx.cr[6].lt {
	pc = 0x82E869B4; continue 'dispatch;
	}
	// 82E869AC: 4BFFF76D  bl 0x82e86118
	ctx.lr = 0x82E869B0;
	sub_82E86118(ctx, base);
	// 82E869B0: 4800022C  b 0x82e86bdc
	pc = 0x82E86BDC; continue 'dispatch;
	// 82E869B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E869B8: 409A000C  bne cr6, 0x82e869c4
	if !ctx.cr[6].eq {
	pc = 0x82E869C4; continue 'dispatch;
	}
	// 82E869BC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82E869C0: 48000010  b 0x82e869d0
	pc = 0x82E869D0; continue 'dispatch;
	// 82E869C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E869C8: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82E869CC: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82E869D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82E869D4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E869D8: 4098014C  bge cr6, 0x82e86b24
	if !ctx.cr[6].lt {
	pc = 0x82E86B24; continue 'dispatch;
	}
	// 82E869DC: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E869E0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E869E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E869E8: 4098000C  bge cr6, 0x82e869f4
	if !ctx.cr[6].lt {
	pc = 0x82E869F4; continue 'dispatch;
	}
	// 82E869EC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82E869F0: 48000008  b 0x82e869f8
	pc = 0x82E869F8; continue 'dispatch;
	// 82E869F4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E869F8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E869FC: 409A000C  bne cr6, 0x82e86a08
	if !ctx.cr[6].eq {
	pc = 0x82E86A08; continue 'dispatch;
	}
	// 82E86A00: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82E86A04: 48000010  b 0x82e86a14
	pc = 0x82E86A14; continue 'dispatch;
	// 82E86A08: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86A0C: 7D285050  subf r9, r8, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82E86A10: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E86A14: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82E86A18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E86A1C: 40980024  bge cr6, 0x82e86a40
	if !ctx.cr[6].lt {
	pc = 0x82E86A40; continue 'dispatch;
	}
	// 82E86A20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E86A24: 409A000C  bne cr6, 0x82e86a30
	if !ctx.cr[6].eq {
	pc = 0x82E86A30; continue 'dispatch;
	}
	// 82E86A28: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82E86A2C: 48000010  b 0x82e86a3c
	pc = 0x82E86A3C; continue 'dispatch;
	// 82E86A30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86A34: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82E86A38: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82E86A3C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82E86A40: 55791838  slwi r25, r11, 3
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82E86A44: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82E86A48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86A4C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82E86A50: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 82E86A54: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E86A58: 807A110C  lwz r3, 0x110c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E86A5C: 4BF6B66D  bl 0x82df20c8
	ctx.lr = 0x82E86A60;
	sub_82DF20C8(ctx, base);
	// 82E86A60: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E86A64: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86A68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E86A6C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86A70: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E86A74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E86A78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E86A7C: 9B0A0000  stb r24, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82E86A80: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82E86A84: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86A88: 4BFF9779  bl 0x82e80200
	ctx.lr = 0x82E86A8C;
	sub_82E80200(ctx, base);
	// 82E86A8C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E86A90: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E86A94: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E86A98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E86A9C: 4BFF9985  bl 0x82e80420
	ctx.lr = 0x82E86AA0;
	sub_82E80420(ctx, base);
	// 82E86AA0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82E86AA4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86AA8: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86AAC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E86AB0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86AB4: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E86AB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86ABC: 9B080000  stb r24, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82E86AC0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86AC4: 4BFF973D  bl 0x82e80200
	ctx.lr = 0x82E86AC8;
	sub_82E80200(ctx, base);
	// 82E86AC8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86ACC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86AD0: 419A0010  beq cr6, 0x82e86ae0
	if ctx.cr[6].eq {
	pc = 0x82E86AE0; continue 'dispatch;
	}
	// 82E86AD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86AD8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82E86ADC: 7D581E70  srawi r24, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82E86AE0: 7FD8DA14  add r30, r24, r27
	ctx.r[30].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 82E86AE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86AE8: 419A0020  beq cr6, 0x82e86b08
	if ctx.cr[6].eq {
	pc = 0x82E86B08; continue 'dispatch;
	}
	// 82E86AEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E86AF0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86AF4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86AF8: 4BFFF341  bl 0x82e85e38
	ctx.lr = 0x82E86AFC;
	sub_82E85E38(ctx, base);
	// 82E86AFC: 807A110C  lwz r3, 0x110c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E86B00: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86B04: 4BF6B685  bl 0x82df2188
	ctx.lr = 0x82E86B08;
	sub_82DF2188(ctx, base);
	// 82E86B08: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86B0C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82E86B10: 7D59E214  add r10, r25, r28
	ctx.r[10].u64 = ctx.r[25].u64 + ctx.r[28].u64;
	// 82E86B14: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82E86B18: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E86B1C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E86B20: 480000BC  b 0x82e86bdc
	pc = 0x82E86BDC; continue 'dispatch;
	// 82E86B24: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86B28: 577C1838  slwi r28, r27, 3
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82E86B2C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86B30: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E86B34: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 82E86B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86B3C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E86B40: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E86B44: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E86B48: 9B0B0000  stb r24, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82E86B4C: 40980044  bge cr6, 0x82e86b90
	if !ctx.cr[6].lt {
	pc = 0x82E86B90; continue 'dispatch;
	}
	// 82E86B50: 7CBCEA14  add r5, r28, r29
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 82E86B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86B58: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86B5C: 4BFF96A5  bl 0x82e80200
	ctx.lr = 0x82E86B60;
	sub_82E80200(ctx, base);
	// 82E86B60: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86B64: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E86B68: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E86B6C: 7D5D1850  subf r10, r29, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[29].s64;
	// 82E86B70: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82E86B74: 7C89D850  subf r4, r9, r27
	ctx.r[4].s64 = ctx.r[27].s64 - ctx.r[9].s64;
	// 82E86B78: 4BFF98A9  bl 0x82e80420
	ctx.lr = 0x82E86B7C;
	sub_82E80420(ctx, base);
	// 82E86B7C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86B80: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82E86B84: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E86B88: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82E86B8C: 48000044  b 0x82e86bd0
	pc = 0x82E86BD0; continue 'dispatch;
	// 82E86B90: 7F7CF050  subf r27, r28, r30
	ctx.r[27].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 82E86B94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E86B98: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E86B9C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86BA0: 4BFF9661  bl 0x82e80200
	ctx.lr = 0x82E86BA4;
	sub_82E80200(ctx, base);
	// 82E86BA4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E86BA8: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86BAC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86BB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E86BB4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82E86BB8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E86BBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86BC0: 9B0A0000  stb r24, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82E86BC4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86BC8: 4BFFE2D9  bl 0x82e84ea0
	ctx.lr = 0x82E86BCC;
	sub_82E84EA0(ctx, base);
	// 82E86BCC: 7C9CEA14  add r4, r28, r29
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 82E86BD0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E86BD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86BD8: 4BFF8CC1  bl 0x82e7f898
	ctx.lr = 0x82E86BDC;
	sub_82E7F898(ctx, base);
	// 82E86BDC: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82E86BE0: 419A000C  beq cr6, 0x82e86bec
	if ctx.cr[6].eq {
	pc = 0x82E86BEC; continue 'dispatch;
	}
	// 82E86BE4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E86BE8: 4B439CA9  bl 0x822c0890
	ctx.lr = 0x82E86BEC;
	sub_822C0890(ctx, base);
	// 82E86BEC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E86BF0: 483215B4  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86BF8 size=108
    let mut pc: u32 = 0x82E86BF8;
    'dispatch: loop {
        match pc {
            0x82E86BF8 => {
    //   block [0x82E86BF8..0x82E86C64)
	// 82E86BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86BFC: 48321571  bl 0x831a816c
	ctx.lr = 0x82E86C00;
	sub_831A8130(ctx, base);
	// 82E86C00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86C04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E86C08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E86C0C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82E86C10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86C18: 419A0014  beq cr6, 0x82e86c2c
	if ctx.cr[6].eq {
	pc = 0x82E86C2C; continue 'dispatch;
	}
	// 82E86C1C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86C20: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86C24: 7D2A1671  srawi. r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E86C28: 4082000C  bne 0x82e86c34
	if !ctx.cr[0].eq {
	pc = 0x82E86C34; continue 'dispatch;
	}
	// 82E86C2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E86C30: 4800000C  b 0x82e86c3c
	pc = 0x82E86C3C; continue 'dispatch;
	// 82E86C34: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82E86C38: 7D7D1670  srawi r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82E86C3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E86C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86C44: 4BFFF6F5  bl 0x82e86338
	ctx.lr = 0x82E86C48;
	sub_82E86338(ctx, base);
	// 82E86C48: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86C4C: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86C50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E86C54: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E86C58: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E86C60: 4832155C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86C68 size=532
    let mut pc: u32 = 0x82E86C68;
    'dispatch: loop {
        match pc {
            0x82E86C68 => {
    //   block [0x82E86C68..0x82E86E7C)
	// 82E86C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86C6C: 483214FD  bl 0x831a8168
	ctx.lr = 0x82E86C70;
	sub_831A8130(ctx, base);
	// 82E86C70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86C74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86C78: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E86C7C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E86C80: 419A01F0  beq cr6, 0x82e86e70
	if ctx.cr[6].eq {
	pc = 0x82E86E70; continue 'dispatch;
	}
	// 82E86C84: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86C8C: 419A0018  beq cr6, 0x82e86ca4
	if ctx.cr[6].eq {
	pc = 0x82E86CA4; continue 'dispatch;
	}
	// 82E86C90: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86C94: 7D632050  subf r11, r3, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82E86C98: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E86C9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E86CA0: 409A0018  bne cr6, 0x82e86cb8
	if !ctx.cr[6].eq {
	pc = 0x82E86CB8; continue 'dispatch;
	}
	// 82E86CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86CA8: 4BFFF991  bl 0x82e86638
	ctx.lr = 0x82E86CAC;
	sub_82E86638(ctx, base);
	// 82E86CAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86CB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86CB4: 48321504  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 82E86CB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86CBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E86CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86CC4: 409A000C  bne cr6, 0x82e86cd0
	if !ctx.cr[6].eq {
	pc = 0x82E86CD0; continue 'dispatch;
	}
	// 82E86CC8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82E86CCC: 48000010  b 0x82e86cdc
	pc = 0x82E86CDC; continue 'dispatch;
	// 82E86CD0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86CD4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86CD8: 7D0A1E70  srawi r10, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82E86CDC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E86CE0: 41990084  bgt cr6, 0x82e86d64
	if ctx.cr[6].gt {
	pc = 0x82E86D64; continue 'dispatch;
	}
	// 82E86CE4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E86CE8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86CEC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86CF0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82E86CF4: 9B8A0000  stb r28, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E86CF8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86CFC: 4BFFE385  bl 0x82e85080
	ctx.lr = 0x82E86D00;
	sub_82E85080(ctx, base);
	// 82E86D00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E86D04: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86D08: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86D0C: 4BFFF12D  bl 0x82e85e38
	ctx.lr = 0x82E86D10;
	sub_82E85E38(ctx, base);
	// 82E86D10: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86D18: 409A0024  bne cr6, 0x82e86d3c
	if !ctx.cr[6].eq {
	pc = 0x82E86D3C; continue 'dispatch;
	}
	// 82E86D1C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82E86D20: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86D28: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86D2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E86D30: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E86D34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86D38: 48321480  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 82E86D3C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86D44: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86D48: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86D4C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E86D50: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86D54: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E86D58: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E86D5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86D60: 48321458  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 82E86D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86D68: 409A000C  bne cr6, 0x82e86d74
	if !ctx.cr[6].eq {
	pc = 0x82E86D74; continue 'dispatch;
	}
	// 82E86D6C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82E86D70: 48000010  b 0x82e86d80
	pc = 0x82E86D80; continue 'dispatch;
	// 82E86D74: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86D78: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86D7C: 7D0A1E70  srawi r10, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82E86D80: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E86D84: 41990064  bgt cr6, 0x82e86de8
	if ctx.cr[6].gt {
	pc = 0x82E86DE8; continue 'dispatch;
	}
	// 82E86D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86D8C: 409A000C  bne cr6, 0x82e86d98
	if !ctx.cr[6].eq {
	pc = 0x82E86D98; continue 'dispatch;
	}
	// 82E86D90: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82E86D94: 48000010  b 0x82e86da4
	pc = 0x82E86DA4; continue 'dispatch;
	// 82E86D98: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86D9C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86DA0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E86DA4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82E86DA8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86DAC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86DB0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E86DB4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86DB8: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82E86DBC: 7FCA1A14  add r30, r10, r3
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82E86DC0: 9B890000  stb r28, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E86DC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86DC8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86DCC: 4BFFE2B5  bl 0x82e85080
	ctx.lr = 0x82E86DD0;
	sub_82E85080(ctx, base);
	// 82E86DD0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82E86DD4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86DD8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E86DE0: 9B880000  stb r28, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E86DE4: 48000078  b 0x82e86e5c
	pc = 0x82E86E5C; continue 'dispatch;
	// 82E86DE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86DEC: 419A0028  beq cr6, 0x82e86e14
	if ctx.cr[6].eq {
	pc = 0x82E86E14; continue 'dispatch;
	}
	// 82E86DF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E86DF4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86DF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E86DFC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86E00: 4BFFF039  bl 0x82e85e38
	ctx.lr = 0x82E86E04;
	sub_82E85E38(ctx, base);
	// 82E86E04: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E86E08: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86E0C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E86E10: 4BF6B379  bl 0x82df2188
	ctx.lr = 0x82E86E14;
	sub_82DF2188(ctx, base);
	// 82E86E14: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86E1C: 409A000C  bne cr6, 0x82e86e28
	if !ctx.cr[6].eq {
	pc = 0x82E86E28; continue 'dispatch;
	}
	// 82E86E20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E86E24: 48000010  b 0x82e86e34
	pc = 0x82E86E34; continue 'dispatch;
	// 82E86E28: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86E2C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86E30: 7D241E70  srawi r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E86E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86E38: 4BFFF879  bl 0x82e866b0
	ctx.lr = 0x82E86E3C;
	sub_82E866B0(ctx, base);
	// 82E86E3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E86E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86E44: 419A002C  beq cr6, 0x82e86e70
	if ctx.cr[6].eq {
	pc = 0x82E86E70; continue 'dispatch;
	}
	// 82E86E48: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E86E4C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86E50: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86E54: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86E58: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E86E5C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E86E60: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86E64: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86E68: 4BFF9399  bl 0x82e80200
	ctx.lr = 0x82E86E6C;
	sub_82E80200(ctx, base);
	// 82E86E6C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82E86E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86E74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86E78: 48321340  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86E80 size=80
    let mut pc: u32 = 0x82E86E80;
    'dispatch: loop {
        match pc {
            0x82E86E80 => {
    //   block [0x82E86E80..0x82E86ED0)
	// 82E86E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86E88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E86E8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86E90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86E94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86E98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E86E9C: 4BFFF8B5  bl 0x82e86750
	ctx.lr = 0x82E86EA0;
	sub_82E86750(ctx, base);
	// 82E86EA0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E86EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86EA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86EAC: 419A000C  beq cr6, 0x82e86eb8
	if ctx.cr[6].eq {
	pc = 0x82E86EB8; continue 'dispatch;
	}
	// 82E86EB0: 4BF6B529  bl 0x82df23d8
	ctx.lr = 0x82E86EB4;
	sub_82DF23D8(ctx, base);
	// 82E86EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86EB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E86EBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86EC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86EC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E86EC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86ED0 size=108
    let mut pc: u32 = 0x82E86ED0;
    'dispatch: loop {
        match pc {
            0x82E86ED0 => {
    //   block [0x82E86ED0..0x82E86F3C)
	// 82E86ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86ED4: 48321299  bl 0x831a816c
	ctx.lr = 0x82E86ED8;
	sub_831A8130(ctx, base);
	// 82E86ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86EDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E86EE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E86EE4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82E86EE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86EF0: 419A0014  beq cr6, 0x82e86f04
	if ctx.cr[6].eq {
	pc = 0x82E86F04; continue 'dispatch;
	}
	// 82E86EF4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86EF8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86EFC: 7D2A1E71  srawi. r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E86F00: 4082000C  bne 0x82e86f0c
	if !ctx.cr[0].eq {
	pc = 0x82E86F0C; continue 'dispatch;
	}
	// 82E86F04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E86F08: 4800000C  b 0x82e86f14
	pc = 0x82E86F14; continue 'dispatch;
	// 82E86F0C: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82E86F10: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E86F14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E86F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86F1C: 4BFFF9E5  bl 0x82e86900
	ctx.lr = 0x82E86F20;
	sub_82E86900(ctx, base);
	// 82E86F20: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86F24: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E86F2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E86F30: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E86F38: 48321284  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86F40 size=144
    let mut pc: u32 = 0x82E86F40;
    'dispatch: loop {
        match pc {
            0x82E86F40 => {
    //   block [0x82E86F40..0x82E86FD0)
	// 82E86F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86F48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86F4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86F50: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E86F54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86F58: 409A000C  bne cr6, 0x82e86f64
	if !ctx.cr[6].eq {
	pc = 0x82E86F64; continue 'dispatch;
	}
	// 82E86F5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E86F60: 48000010  b 0x82e86f70
	pc = 0x82E86F70; continue 'dispatch;
	// 82E86F64: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86F68: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E86F6C: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82E86F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86F74: 419A003C  beq cr6, 0x82e86fb0
	if ctx.cr[6].eq {
	pc = 0x82E86FB0; continue 'dispatch;
	}
	// 82E86F78: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86F7C: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82E86F80: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82E86F84: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E86F88: 40980028  bge cr6, 0x82e86fb0
	if !ctx.cr[6].lt {
	pc = 0x82E86FB0; continue 'dispatch;
	}
	// 82E86F8C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86F90: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86F94: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82E86F98: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E86F9C: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E86FA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86FA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86FA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86FAC: 4E800020  blr
	return;
	// 82E86FB0: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86FB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E86FBC: 4BFFFC3D  bl 0x82e86bf8
	ctx.lr = 0x82E86FC0;
	sub_82E86BF8(ctx, base);
	// 82E86FC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86FC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86FC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86FD0 size=240
    let mut pc: u32 = 0x82E86FD0;
    'dispatch: loop {
        match pc {
            0x82E86FD0 => {
    //   block [0x82E86FD0..0x82E870C0)
	// 82E86FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86FD4: 48321191  bl 0x831a8164
	ctx.lr = 0x82E86FD8;
	sub_831A8130(ctx, base);
	// 82E86FD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E86FE0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82E86FE4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E86FE8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E86FEC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E86FF0: 4B439949  bl 0x822c0938
	ctx.lr = 0x82E86FF4;
	sub_822C0938(ctx, base);
	// 82E86FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E86FF8: 419A0020  beq cr6, 0x82e87018
	if ctx.cr[6].eq {
	pc = 0x82E87018; continue 'dispatch;
	}
	// 82E86FFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E87000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87004: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E87008: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8700C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E87010: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E87014: 48000008  b 0x82e8701c
	pc = 0x82E8701C; continue 'dispatch;
	// 82E87018: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8701C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E87020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E87024: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87028: 4BFFEE69  bl 0x82e85e90
	ctx.lr = 0x82E8702C;
	sub_82E85E90(ctx, base);
	// 82E8702C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E87030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E87034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87038: 4B438FC9  bl 0x822c0000
	ctx.lr = 0x82E8703C;
	sub_822C0000(ctx, base);
	// 82E8703C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87040: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87044: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82E87048: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E8704C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E87050: 4B43D411  bl 0x822c4460
	ctx.lr = 0x82E87054;
	sub_822C4460(ctx, base);
	// 82E87054: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87058: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82E8705C: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82E87060: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E87064: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E87068: 4B43D3F9  bl 0x822c4460
	ctx.lr = 0x82E8706C;
	sub_822C4460(ctx, base);
	// 82E8706C: 937F0010  stw r27, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 82E87070: 3BFE005C  addi r31, r30, 0x5c
	ctx.r[31].s64 = ctx.r[30].s64 + 92;
	// 82E87074: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E87078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8707C: 83DE0060  lwz r30, 0x60(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E87080: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87084: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87088: 480029B9  bl 0x82e89a40
	ctx.lr = 0x82E8708C;
	sub_82E89A40(ctx, base);
	// 82E8708C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E87090: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E87094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87098: 48002F61  bl 0x82e89ff8
	ctx.lr = 0x82E8709C;
	sub_82E89FF8(ctx, base);
	// 82E8709C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E870A0: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E870A4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E870A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E870AC: 93A90000  stw r29, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E870B0: 419A0008  beq cr6, 0x82e870b8
	if ctx.cr[6].eq {
	pc = 0x82E870B8; continue 'dispatch;
	}
	// 82E870B4: 4B4397DD  bl 0x822c0890
	ctx.lr = 0x82E870B8;
	sub_822C0890(ctx, base);
	// 82E870B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E870BC: 483210F8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E870C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E870C0 size=76
    let mut pc: u32 = 0x82E870C0;
    'dispatch: loop {
        match pc {
            0x82E870C0 => {
    //   block [0x82E870C0..0x82E8710C)
	// 82E870C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E870C4: 483210A9  bl 0x831a816c
	ctx.lr = 0x82E870C8;
	sub_831A8130(ctx, base);
	// 82E870C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E870CC: 83C3003C  lwz r30, 0x3c(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E870D0: 3BE30038  addi r31, r3, 0x38
	ctx.r[31].s64 = ctx.r[3].s64 + 56;
	// 82E870D4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E870D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E870DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E870E0: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E870E4: 4B8427ED  bl 0x826c98d0
	ctx.lr = 0x82E870E8;
	sub_826C98D0(ctx, base);
	// 82E870E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E870EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E870F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E870F4: 4BC8122D  bl 0x82b08320
	ctx.lr = 0x82E870F8;
	sub_82B08320(ctx, base);
	// 82E870F8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E870FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87100: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E87104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E87108: 483210B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87110 size=144
    let mut pc: u32 = 0x82E87110;
    'dispatch: loop {
        match pc {
            0x82E87110 => {
    //   block [0x82E87110..0x82E871A0)
	// 82E87110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87114: 48321051  bl 0x831a8164
	ctx.lr = 0x82E87118;
	sub_831A8130(ctx, base);
	// 82E87118: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8711C: 83840048  lwz r28, 0x48(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E87120: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E87124: 3BC40044  addi r30, r4, 0x44
	ctx.r[30].s64 = ctx.r[4].s64 + 68;
	// 82E87128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8712C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E87130: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82E87134: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E87138: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8713C: 4B842795  bl 0x826c98d0
	ctx.lr = 0x82E87140;
	sub_826C98D0(ctx, base);
	// 82E87140: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E87144: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E87148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8714C: 4BC811D5  bl 0x82b08320
	ctx.lr = 0x82E87150;
	sub_82B08320(ctx, base);
	// 82E87150: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82E87154: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87158: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82E8715C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87160: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E87164: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8716C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E87170: 419A0024  beq cr6, 0x82e87194
	if ctx.cr[6].eq {
	pc = 0x82E87194; continue 'dispatch;
	}
	// 82E87174: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E87178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E8717C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E87180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E87184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E87188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E8718C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E87190: 4082FFE8  bne 0x82e87178
	if !ctx.cr[0].eq {
	pc = 0x82E87178; continue 'dispatch;
	}
	// 82E87194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87198: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8719C: 48321018  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E871A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E871A0 size=200
    let mut pc: u32 = 0x82E871A0;
    'dispatch: loop {
        match pc {
            0x82E871A0 => {
    //   block [0x82E871A0..0x82E87268)
	// 82E871A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E871A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E871A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E871AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E871B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E871B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E871B8: 409A000C  bne cr6, 0x82e871c4
	if !ctx.cr[6].eq {
	pc = 0x82E871C4; continue 'dispatch;
	}
	// 82E871BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E871C0: 48000010  b 0x82e871d0
	pc = 0x82E871D0; continue 'dispatch;
	// 82E871C4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E871C8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E871CC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E871D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E871D4: 419A0074  beq cr6, 0x82e87248
	if ctx.cr[6].eq {
	pc = 0x82E87248; continue 'dispatch;
	}
	// 82E871D8: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E871DC: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82E871E0: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82E871E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E871E8: 40980060  bge cr6, 0x82e87248
	if !ctx.cr[6].lt {
	pc = 0x82E87248; continue 'dispatch;
	}
	// 82E871EC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E871F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E871F4: 419A003C  beq cr6, 0x82e87230
	if ctx.cr[6].eq {
	pc = 0x82E87230; continue 'dispatch;
	}
	// 82E871F8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E871FC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E87200: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87204: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E87208: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8720C: 419A0024  beq cr6, 0x82e87230
	if ctx.cr[6].eq {
	pc = 0x82E87230; continue 'dispatch;
	}
	// 82E87210: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E87214: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82E87218: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8721C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82E87220: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E87224: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E87228: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8722C: 4082FFE8  bne 0x82e87214
	if !ctx.cr[0].eq {
	pc = 0x82E87214; continue 'dispatch;
	}
	// 82E87230: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82E87234: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E87238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8723C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E87240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E87244: 4E800020  blr
	return;
	// 82E87248: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8724C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E87250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E87254: 4BFFFC7D  bl 0x82e86ed0
	ctx.lr = 0x82E87258;
	sub_82E86ED0(ctx, base);
	// 82E87258: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8725C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E87260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E87264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87268 size=348
    let mut pc: u32 = 0x82E87268;
    'dispatch: loop {
        match pc {
            0x82E87268 => {
    //   block [0x82E87268..0x82E873C4)
	// 82E87268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8726C: 48320EE5  bl 0x831a8150
	ctx.lr = 0x82E87270;
	sub_831A8130(ctx, base);
	// 82E87270: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87274: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E87278: 98A100E7  stb r5, 0xe7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(231 as u32), ctx.r[5].u8 ) };
	// 82E8727C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87280: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E87284: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E87288: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E8728C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87290: 4BFF84A9  bl 0x82e7f738
	ctx.lr = 0x82E87294;
	sub_82E7F738(ctx, base);
	// 82E87294: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E87298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8729C: 419A0120  beq cr6, 0x82e873bc
	if ctx.cr[6].eq {
	pc = 0x82E873BC; continue 'dispatch;
	}
	// 82E872A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E872A4: 4BFF814D  bl 0x82e7f3f0
	ctx.lr = 0x82E872A8;
	sub_82E7F3F0(ctx, base);
	// 82E872A8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E872AC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82E872B0: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82E872B4: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E872B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E872BC: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E872C0: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E872C4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82E872C8: 419A00F4  beq cr6, 0x82e873bc
	if ctx.cr[6].eq {
	pc = 0x82E873BC; continue 'dispatch;
	}
	// 82E872CC: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E872D0: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E872D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E872D8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E872DC: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E872E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E872E4: 419A00CC  beq cr6, 0x82e873b0
	if ctx.cr[6].eq {
	pc = 0x82E873B0; continue 'dispatch;
	}
	// 82E872E8: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E872EC: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82E872F0: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E872F4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E872F8: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E872FC: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87300: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E87304: 419A00AC  beq cr6, 0x82e873b0
	if ctx.cr[6].eq {
	pc = 0x82E873B0; continue 'dispatch;
	}
	// 82E87308: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8730C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87310: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82E87314: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87318: 814B00C8  lwz r10, 0xc8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8731C: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E87320: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E87324: 419A0080  beq cr6, 0x82e873a4
	if ctx.cr[6].eq {
	pc = 0x82E873A4; continue 'dispatch;
	}
	// 82E87328: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E8732C: 812B0198  lwz r9, 0x198(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87330: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E87334: 409A0070  bne cr6, 0x82e873a4
	if !ctx.cr[6].eq {
	pc = 0x82E873A4; continue 'dispatch;
	}
	// 82E87338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8733C: 386100E7  addi r3, r1, 0xe7
	ctx.r[3].s64 = ctx.r[1].s64 + 231;
	// 82E87340: 4BFFD841  bl 0x82e84b80
	ctx.lr = 0x82E87344;
	sub_82E84B80(ctx, base);
	// 82E87344: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E87348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8734C: 419A0058  beq cr6, 0x82e873a4
	if ctx.cr[6].eq {
	pc = 0x82E873A4; continue 'dispatch;
	}
	// 82E87350: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82E87354: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E87358: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E8735C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E87360: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E87364: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E87368: 4BFFD939  bl 0x82e84ca0
	ctx.lr = 0x82E8736C;
	sub_82E84CA0(ctx, base);
	// 82E8736C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E87370: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E87374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87378: 419A002C  beq cr6, 0x82e873a4
	if ctx.cr[6].eq {
	pc = 0x82E873A4; continue 'dispatch;
	}
	// 82E8737C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87380: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87384: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82E87388: 812A0198  lwz r9, 0x198(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E8738C: 912B0064  stw r9, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82E87390: 810A019C  lwz r8, 0x19c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E87394: 910B0068  stw r8, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82E87398: 80EA01A0  lwz r7, 0x1a0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E8739C: 90EB006C  stw r7, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82E873A0: 4BFFFBA1  bl 0x82e86f40
	ctx.lr = 0x82E873A4;
	sub_82E86F40(ctx, base);
	// 82E873A4: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E873A8: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E873AC: 409AFF60  bne cr6, 0x82e8730c
	if !ctx.cr[6].eq {
	pc = 0x82E8730C; continue 'dispatch;
	}
	// 82E873B0: 83180004  lwz r24, 4(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E873B4: 7F18B040  cmplw cr6, r24, r22
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E873B8: 409AFF18  bne cr6, 0x82e872d0
	if !ctx.cr[6].eq {
	pc = 0x82E872D0; continue 'dispatch;
	}
	// 82E873BC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E873C0: 48320DE0  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E873C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E873C8 size=372
    let mut pc: u32 = 0x82E873C8;
    'dispatch: loop {
        match pc {
            0x82E873C8 => {
    //   block [0x82E873C8..0x82E8753C)
	// 82E873C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E873CC: 48320D79  bl 0x831a8144
	ctx.lr = 0x82E873D0;
	sub_831A8130(ctx, base);
	// 82E873D0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E873D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E873D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E873DC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E873E0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E873E4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E873E8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E873EC: 4BFF834D  bl 0x82e7f738
	ctx.lr = 0x82E873F0;
	sub_82E7F738(ctx, base);
	// 82E873F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E873F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E873F8: 419A013C  beq cr6, 0x82e87534
	if ctx.cr[6].eq {
	pc = 0x82E87534; continue 'dispatch;
	}
	// 82E873FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87400: 4BFF7FF1  bl 0x82e7f3f0
	ctx.lr = 0x82E87404;
	sub_82E7F3F0(ctx, base);
	// 82E87404: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87408: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82E8740C: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82E87410: 828B0000  lwz r20, 0(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87414: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E87418: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8741C: 7F0BA040  cmplw cr6, r11, r20
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82E87420: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82E87424: 419A0110  beq cr6, 0x82e87534
	if ctx.cr[6].eq {
	pc = 0x82E87534; continue 'dispatch;
	}
	// 82E87428: 82C1005C  lwz r22, 0x5c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8742C: 3AE00002  li r23, 2
	ctx.r[23].s64 = 2;
	// 82E87430: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82E87434: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87438: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8743C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E87440: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E87444: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E87448: 419A00E0  beq cr6, 0x82e87528
	if ctx.cr[6].eq {
	pc = 0x82E87528; continue 'dispatch;
	}
	// 82E8744C: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E87450: 92A10058  stw r21, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 82E87454: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87458: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E8745C: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E87460: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87464: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E87468: 419A00C0  beq cr6, 0x82e87528
	if ctx.cr[6].eq {
	pc = 0x82E87528; continue 'dispatch;
	}
	// 82E8746C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87470: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87474: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82E87478: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8747C: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E87480: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 82E87484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E87488: 419A0094  beq cr6, 0x82e8751c
	if ctx.cr[6].eq {
	pc = 0x82E8751C; continue 'dispatch;
	}
	// 82E8748C: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E87490: 81230198  lwz r9, 0x198(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87494: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E87498: 409A0084  bne cr6, 0x82e8751c
	if !ctx.cr[6].eq {
	pc = 0x82E8751C; continue 'dispatch;
	}
	// 82E8749C: 5573BFFE  rlwinm r19, r11, 0x17, 0x1f, 0x1f
	ctx.r[19].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 82E874A0: 4BFF6621  bl 0x82e7dac0
	ctx.lr = 0x82E874A4;
	sub_82E7DAC0(ctx, base);
	// 82E874A4: 7D771850  subf r11, r23, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[23].s64;
	// 82E874A8: 7D589850  subf r10, r24, r19
	ctx.r[10].s64 = ctx.r[19].s64 - ctx.r[24].s64;
	// 82E874AC: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E874B0: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82E874B4: 5527DFFE  rlwinm r7, r9, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82E874B8: 5506DFFE  rlwinm r6, r8, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82E874BC: 7CE53038  and r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 & ctx.r[6].u64;
	// 82E874C0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E874C4: 419A0058  beq cr6, 0x82e8751c
	if ctx.cr[6].eq {
	pc = 0x82E8751C; continue 'dispatch;
	}
	// 82E874C8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82E874CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E874D0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E874D4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E874D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E874DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E874E0: 4BFFD7C1  bl 0x82e84ca0
	ctx.lr = 0x82E874E4;
	sub_82E84CA0(ctx, base);
	// 82E874E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E874E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E874EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E874F0: 419A002C  beq cr6, 0x82e8751c
	if ctx.cr[6].eq {
	pc = 0x82E8751C; continue 'dispatch;
	}
	// 82E874F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E874F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E874FC: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82E87500: 812A0198  lwz r9, 0x198(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87504: 912B0064  stw r9, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82E87508: 810A019C  lwz r8, 0x19c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E8750C: 910B0068  stw r8, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82E87510: 80EA01A0  lwz r7, 0x1a0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E87514: 90EB006C  stw r7, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82E87518: 4BFFFA29  bl 0x82e86f40
	ctx.lr = 0x82E8751C;
	sub_82E86F40(ctx, base);
	// 82E8751C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87520: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87524: 409AFF4C  bne cr6, 0x82e87470
	if !ctx.cr[6].eq {
	pc = 0x82E87470; continue 'dispatch;
	}
	// 82E87528: 82D60004  lwz r22, 4(r22)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8752C: 7F16A040  cmplw cr6, r22, r20
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82E87530: 409AFF04  bne cr6, 0x82e87434
	if !ctx.cr[6].eq {
	pc = 0x82E87434; continue 'dispatch;
	}
	// 82E87534: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E87538: 48320C5C  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87540 size=332
    let mut pc: u32 = 0x82E87540;
    'dispatch: loop {
        match pc {
            0x82E87540 => {
    //   block [0x82E87540..0x82E8768C)
	// 82E87540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87544: 48320C0D  bl 0x831a8150
	ctx.lr = 0x82E87548;
	sub_831A8130(ctx, base);
	// 82E87548: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8754C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E87550: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87554: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E87558: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E8755C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E87560: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87564: 4BFF81D5  bl 0x82e7f738
	ctx.lr = 0x82E87568;
	sub_82E7F738(ctx, base);
	// 82E87568: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8756C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87570: 419A0114  beq cr6, 0x82e87684
	if ctx.cr[6].eq {
	pc = 0x82E87684; continue 'dispatch;
	}
	// 82E87574: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87578: 4BFF7E79  bl 0x82e7f3f0
	ctx.lr = 0x82E8757C;
	sub_82E7F3F0(ctx, base);
	// 82E8757C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87580: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82E87584: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82E87588: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8758C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E87590: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E87594: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E87598: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82E8759C: 419A00E8  beq cr6, 0x82e87684
	if ctx.cr[6].eq {
	pc = 0x82E87684; continue 'dispatch;
	}
	// 82E875A0: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E875A4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E875A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E875AC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E875B0: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E875B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E875B8: 419A00C0  beq cr6, 0x82e87678
	if ctx.cr[6].eq {
	pc = 0x82E87678; continue 'dispatch;
	}
	// 82E875BC: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E875C0: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82E875C4: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E875C8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E875CC: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E875D0: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E875D4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E875D8: 419A00A0  beq cr6, 0x82e87678
	if ctx.cr[6].eq {
	pc = 0x82E87678; continue 'dispatch;
	}
	// 82E875DC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E875E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E875E4: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82E875E8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E875EC: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E875F0: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 82E875F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E875F8: 419A0074  beq cr6, 0x82e8766c
	if ctx.cr[6].eq {
	pc = 0x82E8766C; continue 'dispatch;
	}
	// 82E875FC: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E87600: 81430198  lwz r10, 0x198(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87604: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E87608: 409A0064  bne cr6, 0x82e8766c
	if !ctx.cr[6].eq {
	pc = 0x82E8766C; continue 'dispatch;
	}
	// 82E8760C: 4BFF64B5  bl 0x82e7dac0
	ctx.lr = 0x82E87610;
	sub_82E7DAC0(ctx, base);
	// 82E87610: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82E87614: 409A0058  bne cr6, 0x82e8766c
	if !ctx.cr[6].eq {
	pc = 0x82E8766C; continue 'dispatch;
	}
	// 82E87618: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82E8761C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E87620: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E87624: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E87628: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8762C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E87630: 4BFFD671  bl 0x82e84ca0
	ctx.lr = 0x82E87634;
	sub_82E84CA0(ctx, base);
	// 82E87634: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E87638: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8763C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87640: 419A002C  beq cr6, 0x82e8766c
	if ctx.cr[6].eq {
	pc = 0x82E8766C; continue 'dispatch;
	}
	// 82E87644: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87648: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8764C: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82E87650: 812A0198  lwz r9, 0x198(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87654: 912B0064  stw r9, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82E87658: 810A019C  lwz r8, 0x19c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E8765C: 910B0068  stw r8, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82E87660: 80EA01A0  lwz r7, 0x1a0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E87664: 90EB006C  stw r7, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82E87668: 4BFFF8D9  bl 0x82e86f40
	ctx.lr = 0x82E8766C;
	sub_82E86F40(ctx, base);
	// 82E8766C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87670: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87674: 409AFF6C  bne cr6, 0x82e875e0
	if !ctx.cr[6].eq {
	pc = 0x82E875E0; continue 'dispatch;
	}
	// 82E87678: 83180004  lwz r24, 4(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8767C: 7F18B040  cmplw cr6, r24, r22
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E87680: 409AFF24  bne cr6, 0x82e875a4
	if !ctx.cr[6].eq {
	pc = 0x82E875A4; continue 'dispatch;
	}
	// 82E87684: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E87688: 48320B18  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87690 size=348
    let mut pc: u32 = 0x82E87690;
    'dispatch: loop {
        match pc {
            0x82E87690 => {
    //   block [0x82E87690..0x82E877EC)
	// 82E87690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87694: 48320ABD  bl 0x831a8150
	ctx.lr = 0x82E87698;
	sub_831A8130(ctx, base);
	// 82E87698: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8769C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E876A0: 98A100E7  stb r5, 0xe7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(231 as u32), ctx.r[5].u8 ) };
	// 82E876A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E876A8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E876AC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E876B0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E876B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E876B8: 4BFF8081  bl 0x82e7f738
	ctx.lr = 0x82E876BC;
	sub_82E7F738(ctx, base);
	// 82E876BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E876C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E876C4: 419A0120  beq cr6, 0x82e877e4
	if ctx.cr[6].eq {
	pc = 0x82E877E4; continue 'dispatch;
	}
	// 82E876C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E876CC: 4BFF7D25  bl 0x82e7f3f0
	ctx.lr = 0x82E876D0;
	sub_82E7F3F0(ctx, base);
	// 82E876D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E876D4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82E876D8: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82E876DC: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E876E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E876E4: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E876E8: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E876EC: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82E876F0: 419A00F4  beq cr6, 0x82e877e4
	if ctx.cr[6].eq {
	pc = 0x82E877E4; continue 'dispatch;
	}
	// 82E876F4: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E876F8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E876FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87700: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E87704: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E87708: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8770C: 419A00CC  beq cr6, 0x82e877d8
	if ctx.cr[6].eq {
	pc = 0x82E877D8; continue 'dispatch;
	}
	// 82E87710: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E87714: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82E87718: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8771C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E87720: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E87724: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87728: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E8772C: 419A00AC  beq cr6, 0x82e877d8
	if ctx.cr[6].eq {
	pc = 0x82E877D8; continue 'dispatch;
	}
	// 82E87730: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87734: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87738: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82E8773C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87740: 814B00C8  lwz r10, 0xc8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E87744: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E87748: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8774C: 419A0080  beq cr6, 0x82e877cc
	if ctx.cr[6].eq {
	pc = 0x82E877CC; continue 'dispatch;
	}
	// 82E87750: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E87754: 812B0198  lwz r9, 0x198(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87758: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E8775C: 409A0070  bne cr6, 0x82e877cc
	if !ctx.cr[6].eq {
	pc = 0x82E877CC; continue 'dispatch;
	}
	// 82E87760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E87764: 386100E7  addi r3, r1, 0xe7
	ctx.r[3].s64 = ctx.r[1].s64 + 231;
	// 82E87768: 4BFFD4A9  bl 0x82e84c10
	ctx.lr = 0x82E8776C;
	sub_82E84C10(ctx, base);
	// 82E8776C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E87770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87774: 419A0058  beq cr6, 0x82e877cc
	if ctx.cr[6].eq {
	pc = 0x82E877CC; continue 'dispatch;
	}
	// 82E87778: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82E8777C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E87780: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E87784: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E87788: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8778C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E87790: 4BFFD511  bl 0x82e84ca0
	ctx.lr = 0x82E87794;
	sub_82E84CA0(ctx, base);
	// 82E87794: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E87798: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8779C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E877A0: 419A002C  beq cr6, 0x82e877cc
	if ctx.cr[6].eq {
	pc = 0x82E877CC; continue 'dispatch;
	}
	// 82E877A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E877A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E877AC: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82E877B0: 812A0198  lwz r9, 0x198(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E877B4: 912B0064  stw r9, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82E877B8: 810A019C  lwz r8, 0x19c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E877BC: 910B0068  stw r8, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82E877C0: 80EA01A0  lwz r7, 0x1a0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E877C4: 90EB006C  stw r7, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82E877C8: 4BFFF779  bl 0x82e86f40
	ctx.lr = 0x82E877CC;
	sub_82E86F40(ctx, base);
	// 82E877CC: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E877D0: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E877D4: 409AFF60  bne cr6, 0x82e87734
	if !ctx.cr[6].eq {
	pc = 0x82E87734; continue 'dispatch;
	}
	// 82E877D8: 83180004  lwz r24, 4(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E877DC: 7F18B040  cmplw cr6, r24, r22
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E877E0: 409AFF18  bne cr6, 0x82e876f8
	if !ctx.cr[6].eq {
	pc = 0x82E876F8; continue 'dispatch;
	}
	// 82E877E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E877E8: 483209B8  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E877F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E877F0 size=332
    let mut pc: u32 = 0x82E877F0;
    'dispatch: loop {
        match pc {
            0x82E877F0 => {
    //   block [0x82E877F0..0x82E8793C)
	// 82E877F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E877F4: 4832095D  bl 0x831a8150
	ctx.lr = 0x82E877F8;
	sub_831A8130(ctx, base);
	// 82E877F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E877FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E87800: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87804: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E87808: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E8780C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E87810: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87814: 4BFF7F25  bl 0x82e7f738
	ctx.lr = 0x82E87818;
	sub_82E7F738(ctx, base);
	// 82E87818: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8781C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87820: 419A0114  beq cr6, 0x82e87934
	if ctx.cr[6].eq {
	pc = 0x82E87934; continue 'dispatch;
	}
	// 82E87824: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87828: 4BFF7BC9  bl 0x82e7f3f0
	ctx.lr = 0x82E8782C;
	sub_82E7F3F0(ctx, base);
	// 82E8782C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87830: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82E87834: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82E87838: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8783C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E87840: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E87844: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E87848: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82E8784C: 419A00E8  beq cr6, 0x82e87934
	if ctx.cr[6].eq {
	pc = 0x82E87934; continue 'dispatch;
	}
	// 82E87850: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E87854: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87858: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8785C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E87860: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 82E87864: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E87868: 419A00C0  beq cr6, 0x82e87928
	if ctx.cr[6].eq {
	pc = 0x82E87928; continue 'dispatch;
	}
	// 82E8786C: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E87870: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82E87874: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87878: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E8787C: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E87880: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87884: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E87888: 419A00A0  beq cr6, 0x82e87928
	if ctx.cr[6].eq {
	pc = 0x82E87928; continue 'dispatch;
	}
	// 82E8788C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87890: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87894: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82E87898: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8789C: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E878A0: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 82E878A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E878A8: 419A0074  beq cr6, 0x82e8791c
	if ctx.cr[6].eq {
	pc = 0x82E8791C; continue 'dispatch;
	}
	// 82E878AC: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E878B0: 81430198  lwz r10, 0x198(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E878B4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E878B8: 409A0064  bne cr6, 0x82e8791c
	if !ctx.cr[6].eq {
	pc = 0x82E8791C; continue 'dispatch;
	}
	// 82E878BC: 4BFF6205  bl 0x82e7dac0
	ctx.lr = 0x82E878C0;
	sub_82E7DAC0(ctx, base);
	// 82E878C0: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 82E878C4: 409A0058  bne cr6, 0x82e8791c
	if !ctx.cr[6].eq {
	pc = 0x82E8791C; continue 'dispatch;
	}
	// 82E878C8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82E878CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E878D0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E878D4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E878D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E878DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E878E0: 4BFFD3C1  bl 0x82e84ca0
	ctx.lr = 0x82E878E4;
	sub_82E84CA0(ctx, base);
	// 82E878E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E878E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E878EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E878F0: 419A002C  beq cr6, 0x82e8791c
	if ctx.cr[6].eq {
	pc = 0x82E8791C; continue 'dispatch;
	}
	// 82E878F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E878F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E878FC: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82E87900: 812A0198  lwz r9, 0x198(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E87904: 912B0064  stw r9, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82E87908: 810A019C  lwz r8, 0x19c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E8790C: 910B0068  stw r8, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82E87910: 80EA01A0  lwz r7, 0x1a0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E87914: 90EB006C  stw r7, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82E87918: 4BFFF629  bl 0x82e86f40
	ctx.lr = 0x82E8791C;
	sub_82E86F40(ctx, base);
	// 82E8791C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87920: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E87924: 409AFF6C  bne cr6, 0x82e87890
	if !ctx.cr[6].eq {
	pc = 0x82E87890; continue 'dispatch;
	}
	// 82E87928: 83180004  lwz r24, 4(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8792C: 7F18B040  cmplw cr6, r24, r22
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82E87930: 409AFF24  bne cr6, 0x82e87854
	if !ctx.cr[6].eq {
	pc = 0x82E87854; continue 'dispatch;
	}
	// 82E87934: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E87938: 48320868  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E87940 size=400
    let mut pc: u32 = 0x82E87940;
    'dispatch: loop {
        match pc {
            0x82E87940 => {
    //   block [0x82E87940..0x82E87AD0)
	// 82E87940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87944: 48320825  bl 0x831a8168
	ctx.lr = 0x82E87948;
	sub_831A8130(ctx, base);
	// 82E87948: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8794C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87950: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 82E87954: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E87958: 394B3114  addi r10, r11, 0x3114
	ctx.r[10].s64 = ctx.r[11].s64 + 12564;
	// 82E8795C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E87960: 4BF8A579  bl 0x82e11ed8
	ctx.lr = 0x82E87964;
	sub_82E11ED8(ctx, base);
	// 82E87964: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82E87968: 3D008212  lis r8, -0x7dee
	ctx.r[8].s64 = -2112749568;
	// 82E8796C: 38E9E0D8  addi r7, r9, -0x1f28
	ctx.r[7].s64 = ctx.r[9].s64 + -7976;
	// 82E87970: 38C8E0CC  addi r6, r8, -0x1f34
	ctx.r[6].s64 = ctx.r[8].s64 + -7988;
	// 82E87974: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E87978: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E8797C: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82E87980: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87984: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E87988: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82E8798C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82E87990: 3BAB08B0  addi r29, r11, 0x8b0
	ctx.r[29].s64 = ctx.r[11].s64 + 2224;
	// 82E87994: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E87998: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E8799C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82E879A0: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E879A4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82E879A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E879AC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82E879B0: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82E879B4: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82E879B8: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82E879BC: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82E879C0: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82E879C4: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E879C8: 4BF6A701  bl 0x82df20c8
	ctx.lr = 0x82E879CC;
	sub_82DF20C8(ctx, base);
	// 82E879CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E879D0: 419A0008  beq cr6, 0x82e879d8
	if ctx.cr[6].eq {
	pc = 0x82E879D8; continue 'dispatch;
	}
	// 82E879D4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E879D8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E879DC: 41820008  beq 0x82e879e4
	if ctx.cr[0].eq {
	pc = 0x82E879E4; continue 'dispatch;
	}
	// 82E879E0: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E879E4: 907F003C  stw r3, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 82E879E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E879EC: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82E879F0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E879F4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E879F8: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E879FC: 4BF6A6CD  bl 0x82df20c8
	ctx.lr = 0x82E87A00;
	sub_82DF20C8(ctx, base);
	// 82E87A00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87A04: 419A0008  beq cr6, 0x82e87a0c
	if ctx.cr[6].eq {
	pc = 0x82E87A0C; continue 'dispatch;
	}
	// 82E87A08: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E87A0C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87A10: 41820008  beq 0x82e87a18
	if ctx.cr[0].eq {
	pc = 0x82E87A18; continue 'dispatch;
	}
	// 82E87A14: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E87A18: 907F0048  stw r3, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82E87A1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E87A20: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82E87A24: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E87A28: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E87A2C: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E87A30: 4BF6A699  bl 0x82df20c8
	ctx.lr = 0x82E87A34;
	sub_82DF20C8(ctx, base);
	// 82E87A34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87A38: 419A0008  beq cr6, 0x82e87a40
	if ctx.cr[6].eq {
	pc = 0x82E87A40; continue 'dispatch;
	}
	// 82E87A3C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E87A40: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87A44: 41820008  beq 0x82e87a4c
	if ctx.cr[0].eq {
	pc = 0x82E87A4C; continue 'dispatch;
	}
	// 82E87A48: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E87A4C: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82E87A50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E87A54: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82E87A58: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E87A5C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E87A60: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E87A64: 4BF6A665  bl 0x82df20c8
	ctx.lr = 0x82E87A68;
	sub_82DF20C8(ctx, base);
	// 82E87A68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87A6C: 419A0008  beq cr6, 0x82e87a74
	if ctx.cr[6].eq {
	pc = 0x82E87A74; continue 'dispatch;
	}
	// 82E87A70: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E87A74: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87A78: 41820008  beq 0x82e87a80
	if ctx.cr[0].eq {
	pc = 0x82E87A80; continue 'dispatch;
	}
	// 82E87A7C: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E87A80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87A84: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82E87A88: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82E87A8C: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82E87A90: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82E87A94: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82E87A98: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87A9C: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82E87AA0: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E87AA4: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82E87AA8: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E87AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87AB0: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82E87AB4: 419A0008  beq cr6, 0x82e87abc
	if ctx.cr[6].eq {
	pc = 0x82E87ABC; continue 'dispatch;
	}
	// 82E87AB8: 4B438DD9  bl 0x822c0890
	ctx.lr = 0x82E87ABC;
	sub_822C0890(ctx, base);
	// 82E87ABC: 3C600020  lis r3, 0x20
	ctx.r[3].s64 = 2097152;
	// 82E87AC0: 48005859  bl 0x82e8d318
	ctx.lr = 0x82E87AC4;
	sub_82E8D318(ctx, base);
	// 82E87AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87AC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E87ACC: 483206EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87AD0 size=1580
    let mut pc: u32 = 0x82E87AD0;
    'dispatch: loop {
        match pc {
            0x82E87AD0 => {
    //   block [0x82E87AD0..0x82E880FC)
	// 82E87AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87AD4: 4832068D  bl 0x831a8160
	ctx.lr = 0x82E87AD8;
	sub_831A8130(ctx, base);
	// 82E87AD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87ADC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E87AE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E87AE4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E87AE8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82E87AEC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82E87AF0: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82E87AF4: 93FC000C  stw r31, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82E87AF8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87B00: 419A05F0  beq cr6, 0x82e880f0
	if ctx.cr[6].eq {
	pc = 0x82E880F0; continue 'dispatch;
	}
	// 82E87B04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87B08: 3B60001C  li r27, 0x1c
	ctx.r[27].s64 = 28;
	// 82E87B0C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87B14: 419A0088  beq cr6, 0x82e87b9c
	if ctx.cr[6].eq {
	pc = 0x82E87B9C; continue 'dispatch;
	}
	// 82E87B18: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87B1C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87B20: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87B24: 41820078  beq 0x82e87b9c
	if ctx.cr[0].eq {
	pc = 0x82E87B9C; continue 'dispatch;
	}
	// 82E87B28: 574B04A4  rlwinm r11, r26, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87B2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87B30: 419A006C  beq cr6, 0x82e87b9c
	if ctx.cr[6].eq {
	pc = 0x82E87B9C; continue 'dispatch;
	}
	// 82E87B34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87B38: 4BF6A889  bl 0x82df23c0
	ctx.lr = 0x82E87B3C;
	sub_82DF23C0(ctx, base);
	// 82E87B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87B40: 419A001C  beq cr6, 0x82e87b5c
	if ctx.cr[6].eq {
	pc = 0x82E87B5C; continue 'dispatch;
	}
	// 82E87B44: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87B48: 38802000  li r4, 0x2000
	ctx.r[4].s64 = 8192;
	// 82E87B4C: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82E87B50: 4BFFD6C1  bl 0x82e85210
	ctx.lr = 0x82E87B54;
	sub_82E85210(ctx, base);
	// 82E87B54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87B58: 48000008  b 0x82e87b60
	pc = 0x82E87B60; continue 'dispatch;
	// 82E87B5C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87B60: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87B64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87B68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87B6C: 4BFFD26D  bl 0x82e84dd8
	ctx.lr = 0x82E87B70;
	sub_82E84DD8(ctx, base);
	// 82E87B70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87B74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87B78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87B7C: 4B438485  bl 0x822c0000
	ctx.lr = 0x82E87B80;
	sub_822C0000(ctx, base);
	// 82E87B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87B84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87B88: 4BFFF619  bl 0x82e871a0
	ctx.lr = 0x82E87B8C;
	sub_82E871A0(ctx, base);
	// 82E87B8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87B94: 419A0008  beq cr6, 0x82e87b9c
	if ctx.cr[6].eq {
	pc = 0x82E87B9C; continue 'dispatch;
	}
	// 82E87B98: 4B438CF9  bl 0x822c0890
	ctx.lr = 0x82E87B9C;
	sub_822C0890(ctx, base);
	// 82E87B9C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87BA0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87BA4: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87BAC: 419A0088  beq cr6, 0x82e87c34
	if ctx.cr[6].eq {
	pc = 0x82E87C34; continue 'dispatch;
	}
	// 82E87BB0: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87BB4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87BB8: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87BBC: 41820078  beq 0x82e87c34
	if ctx.cr[0].eq {
	pc = 0x82E87C34; continue 'dispatch;
	}
	// 82E87BC0: 574B0462  rlwinm r11, r26, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87BC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87BC8: 419A006C  beq cr6, 0x82e87c34
	if ctx.cr[6].eq {
	pc = 0x82E87C34; continue 'dispatch;
	}
	// 82E87BCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87BD0: 4BF6A7F1  bl 0x82df23c0
	ctx.lr = 0x82E87BD4;
	sub_82DF23C0(ctx, base);
	// 82E87BD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87BD8: 419A001C  beq cr6, 0x82e87bf4
	if ctx.cr[6].eq {
	pc = 0x82E87BF4; continue 'dispatch;
	}
	// 82E87BDC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87BE0: 38804000  li r4, 0x4000
	ctx.r[4].s64 = 16384;
	// 82E87BE4: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82E87BE8: 4BFFD629  bl 0x82e85210
	ctx.lr = 0x82E87BEC;
	sub_82E85210(ctx, base);
	// 82E87BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87BF0: 48000008  b 0x82e87bf8
	pc = 0x82E87BF8; continue 'dispatch;
	// 82E87BF4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87BF8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87BFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87C00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87C04: 4BFFD1D5  bl 0x82e84dd8
	ctx.lr = 0x82E87C08;
	sub_82E84DD8(ctx, base);
	// 82E87C08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87C0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87C10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87C14: 4B4383ED  bl 0x822c0000
	ctx.lr = 0x82E87C18;
	sub_822C0000(ctx, base);
	// 82E87C18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87C1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87C20: 4BFFF581  bl 0x82e871a0
	ctx.lr = 0x82E87C24;
	sub_82E871A0(ctx, base);
	// 82E87C24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87C28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87C2C: 419A0008  beq cr6, 0x82e87c34
	if ctx.cr[6].eq {
	pc = 0x82E87C34; continue 'dispatch;
	}
	// 82E87C30: 4B438C61  bl 0x822c0890
	ctx.lr = 0x82E87C34;
	sub_822C0890(ctx, base);
	// 82E87C34: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87C38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E87C3C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87C44: 419A008C  beq cr6, 0x82e87cd0
	if ctx.cr[6].eq {
	pc = 0x82E87CD0; continue 'dispatch;
	}
	// 82E87C48: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87C4C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87C50: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87C54: 4182007C  beq 0x82e87cd0
	if ctx.cr[0].eq {
	pc = 0x82E87CD0; continue 'dispatch;
	}
	// 82E87C58: 574B0420  rlwinm r11, r26, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87C5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87C60: 419A0070  beq cr6, 0x82e87cd0
	if ctx.cr[6].eq {
	pc = 0x82E87CD0; continue 'dispatch;
	}
	// 82E87C64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87C68: 4BF6A759  bl 0x82df23c0
	ctx.lr = 0x82E87C6C;
	sub_82DF23C0(ctx, base);
	// 82E87C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87C70: 419A0020  beq cr6, 0x82e87c90
	if ctx.cr[6].eq {
	pc = 0x82E87C90; continue 'dispatch;
	}
	// 82E87C74: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87C78: 3C800000  lis r4, 0
	ctx.r[4].s64 = 0;
	// 82E87C7C: 60848000  ori r4, r4, 0x8000
	ctx.r[4].u64 = ctx.r[4].u64 | 32768;
	// 82E87C80: 38AB0014  addi r5, r11, 0x14
	ctx.r[5].s64 = ctx.r[11].s64 + 20;
	// 82E87C84: 4BFFD58D  bl 0x82e85210
	ctx.lr = 0x82E87C88;
	sub_82E85210(ctx, base);
	// 82E87C88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87C8C: 48000008  b 0x82e87c94
	pc = 0x82E87C94; continue 'dispatch;
	// 82E87C90: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87C94: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87C98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87C9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87CA0: 4BFFD139  bl 0x82e84dd8
	ctx.lr = 0x82E87CA4;
	sub_82E84DD8(ctx, base);
	// 82E87CA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87CA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87CAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87CB0: 4B438351  bl 0x822c0000
	ctx.lr = 0x82E87CB4;
	sub_822C0000(ctx, base);
	// 82E87CB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87CB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87CBC: 4BFFF4E5  bl 0x82e871a0
	ctx.lr = 0x82E87CC0;
	sub_82E871A0(ctx, base);
	// 82E87CC0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87CC8: 419A0008  beq cr6, 0x82e87cd0
	if ctx.cr[6].eq {
	pc = 0x82E87CD0; continue 'dispatch;
	}
	// 82E87CCC: 4B438BC5  bl 0x822c0890
	ctx.lr = 0x82E87CD0;
	sub_822C0890(ctx, base);
	// 82E87CD0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87CD4: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E87CD8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87CE0: 419A0088  beq cr6, 0x82e87d68
	if ctx.cr[6].eq {
	pc = 0x82E87D68; continue 'dispatch;
	}
	// 82E87CE4: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87CE8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87CEC: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87CF0: 41820078  beq 0x82e87d68
	if ctx.cr[0].eq {
	pc = 0x82E87D68; continue 'dispatch;
	}
	// 82E87CF4: 574B03DE  rlwinm r11, r26, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87CFC: 419A006C  beq cr6, 0x82e87d68
	if ctx.cr[6].eq {
	pc = 0x82E87D68; continue 'dispatch;
	}
	// 82E87D00: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87D04: 4BF6A6BD  bl 0x82df23c0
	ctx.lr = 0x82E87D08;
	sub_82DF23C0(ctx, base);
	// 82E87D08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87D0C: 419A001C  beq cr6, 0x82e87d28
	if ctx.cr[6].eq {
	pc = 0x82E87D28; continue 'dispatch;
	}
	// 82E87D10: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87D14: 3C800001  lis r4, 1
	ctx.r[4].s64 = 65536;
	// 82E87D18: 38AB001C  addi r5, r11, 0x1c
	ctx.r[5].s64 = ctx.r[11].s64 + 28;
	// 82E87D1C: 4BFFD4F5  bl 0x82e85210
	ctx.lr = 0x82E87D20;
	sub_82E85210(ctx, base);
	// 82E87D20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87D24: 48000008  b 0x82e87d2c
	pc = 0x82E87D2C; continue 'dispatch;
	// 82E87D28: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87D2C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87D34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87D38: 4BFFD0A1  bl 0x82e84dd8
	ctx.lr = 0x82E87D3C;
	sub_82E84DD8(ctx, base);
	// 82E87D3C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87D40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87D44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87D48: 4B4382B9  bl 0x822c0000
	ctx.lr = 0x82E87D4C;
	sub_822C0000(ctx, base);
	// 82E87D4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87D50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87D54: 4BFFF44D  bl 0x82e871a0
	ctx.lr = 0x82E87D58;
	sub_82E871A0(ctx, base);
	// 82E87D58: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87D5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87D60: 419A0008  beq cr6, 0x82e87d68
	if ctx.cr[6].eq {
	pc = 0x82E87D68; continue 'dispatch;
	}
	// 82E87D64: 4B438B2D  bl 0x822c0890
	ctx.lr = 0x82E87D68;
	sub_822C0890(ctx, base);
	// 82E87D68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87D6C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E87D70: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87D78: 419A0088  beq cr6, 0x82e87e00
	if ctx.cr[6].eq {
	pc = 0x82E87E00; continue 'dispatch;
	}
	// 82E87D7C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87D80: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87D84: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87D88: 41820078  beq 0x82e87e00
	if ctx.cr[0].eq {
	pc = 0x82E87E00; continue 'dispatch;
	}
	// 82E87D8C: 574B039C  rlwinm r11, r26, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87D90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87D94: 419A006C  beq cr6, 0x82e87e00
	if ctx.cr[6].eq {
	pc = 0x82E87E00; continue 'dispatch;
	}
	// 82E87D98: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87D9C: 4BF6A625  bl 0x82df23c0
	ctx.lr = 0x82E87DA0;
	sub_82DF23C0(ctx, base);
	// 82E87DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87DA4: 419A001C  beq cr6, 0x82e87dc0
	if ctx.cr[6].eq {
	pc = 0x82E87DC0; continue 'dispatch;
	}
	// 82E87DA8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87DAC: 3C800002  lis r4, 2
	ctx.r[4].s64 = 131072;
	// 82E87DB0: 38AB0024  addi r5, r11, 0x24
	ctx.r[5].s64 = ctx.r[11].s64 + 36;
	// 82E87DB4: 4BFFD45D  bl 0x82e85210
	ctx.lr = 0x82E87DB8;
	sub_82E85210(ctx, base);
	// 82E87DB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87DBC: 48000008  b 0x82e87dc4
	pc = 0x82E87DC4; continue 'dispatch;
	// 82E87DC0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87DC4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87DC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87DCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87DD0: 4BFFD009  bl 0x82e84dd8
	ctx.lr = 0x82E87DD4;
	sub_82E84DD8(ctx, base);
	// 82E87DD4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87DD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87DDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87DE0: 4B438221  bl 0x822c0000
	ctx.lr = 0x82E87DE4;
	sub_822C0000(ctx, base);
	// 82E87DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87DE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87DEC: 4BFFF3B5  bl 0x82e871a0
	ctx.lr = 0x82E87DF0;
	sub_82E871A0(ctx, base);
	// 82E87DF0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87DF8: 419A0008  beq cr6, 0x82e87e00
	if ctx.cr[6].eq {
	pc = 0x82E87E00; continue 'dispatch;
	}
	// 82E87DFC: 4B438A95  bl 0x822c0890
	ctx.lr = 0x82E87E00;
	sub_822C0890(ctx, base);
	// 82E87E00: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87E04: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E87E08: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87E10: 419A0088  beq cr6, 0x82e87e98
	if ctx.cr[6].eq {
	pc = 0x82E87E98; continue 'dispatch;
	}
	// 82E87E14: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87E18: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87E1C: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87E20: 41820078  beq 0x82e87e98
	if ctx.cr[0].eq {
	pc = 0x82E87E98; continue 'dispatch;
	}
	// 82E87E24: 574B035A  rlwinm r11, r26, 0, 0xd, 0xd
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87E28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87E2C: 419A006C  beq cr6, 0x82e87e98
	if ctx.cr[6].eq {
	pc = 0x82E87E98; continue 'dispatch;
	}
	// 82E87E30: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87E34: 4BF6A58D  bl 0x82df23c0
	ctx.lr = 0x82E87E38;
	sub_82DF23C0(ctx, base);
	// 82E87E38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87E3C: 419A001C  beq cr6, 0x82e87e58
	if ctx.cr[6].eq {
	pc = 0x82E87E58; continue 'dispatch;
	}
	// 82E87E40: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87E44: 3C800004  lis r4, 4
	ctx.r[4].s64 = 262144;
	// 82E87E48: 38AB002C  addi r5, r11, 0x2c
	ctx.r[5].s64 = ctx.r[11].s64 + 44;
	// 82E87E4C: 4BFFD3C5  bl 0x82e85210
	ctx.lr = 0x82E87E50;
	sub_82E85210(ctx, base);
	// 82E87E50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87E54: 48000008  b 0x82e87e5c
	pc = 0x82E87E5C; continue 'dispatch;
	// 82E87E58: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87E5C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87E60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87E64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87E68: 4BFFCF71  bl 0x82e84dd8
	ctx.lr = 0x82E87E6C;
	sub_82E84DD8(ctx, base);
	// 82E87E6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87E70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87E74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87E78: 4B438189  bl 0x822c0000
	ctx.lr = 0x82E87E7C;
	sub_822C0000(ctx, base);
	// 82E87E7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87E80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87E84: 4BFFF31D  bl 0x82e871a0
	ctx.lr = 0x82E87E88;
	sub_82E871A0(ctx, base);
	// 82E87E88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87E8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87E90: 419A0008  beq cr6, 0x82e87e98
	if ctx.cr[6].eq {
	pc = 0x82E87E98; continue 'dispatch;
	}
	// 82E87E94: 4B4389FD  bl 0x822c0890
	ctx.lr = 0x82E87E98;
	sub_822C0890(ctx, base);
	// 82E87E98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87E9C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E87EA0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87EA8: 419A0088  beq cr6, 0x82e87f30
	if ctx.cr[6].eq {
	pc = 0x82E87F30; continue 'dispatch;
	}
	// 82E87EAC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87EB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87EB4: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87EB8: 41820078  beq 0x82e87f30
	if ctx.cr[0].eq {
	pc = 0x82E87F30; continue 'dispatch;
	}
	// 82E87EBC: 574B0318  rlwinm r11, r26, 0, 0xc, 0xc
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87EC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87EC4: 419A006C  beq cr6, 0x82e87f30
	if ctx.cr[6].eq {
	pc = 0x82E87F30; continue 'dispatch;
	}
	// 82E87EC8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87ECC: 4BF6A4F5  bl 0x82df23c0
	ctx.lr = 0x82E87ED0;
	sub_82DF23C0(ctx, base);
	// 82E87ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87ED4: 419A001C  beq cr6, 0x82e87ef0
	if ctx.cr[6].eq {
	pc = 0x82E87EF0; continue 'dispatch;
	}
	// 82E87ED8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87EDC: 3C800008  lis r4, 8
	ctx.r[4].s64 = 524288;
	// 82E87EE0: 38AB003C  addi r5, r11, 0x3c
	ctx.r[5].s64 = ctx.r[11].s64 + 60;
	// 82E87EE4: 4BFFD32D  bl 0x82e85210
	ctx.lr = 0x82E87EE8;
	sub_82E85210(ctx, base);
	// 82E87EE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87EEC: 48000008  b 0x82e87ef4
	pc = 0x82E87EF4; continue 'dispatch;
	// 82E87EF0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87EF4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87EF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87EFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87F00: 4BFFCED9  bl 0x82e84dd8
	ctx.lr = 0x82E87F04;
	sub_82E84DD8(ctx, base);
	// 82E87F04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87F0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87F10: 4B4380F1  bl 0x822c0000
	ctx.lr = 0x82E87F14;
	sub_822C0000(ctx, base);
	// 82E87F14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87F18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87F1C: 4BFFF285  bl 0x82e871a0
	ctx.lr = 0x82E87F20;
	sub_82E871A0(ctx, base);
	// 82E87F20: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87F24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87F28: 419A0008  beq cr6, 0x82e87f30
	if ctx.cr[6].eq {
	pc = 0x82E87F30; continue 'dispatch;
	}
	// 82E87F2C: 4B438965  bl 0x822c0890
	ctx.lr = 0x82E87F30;
	sub_822C0890(ctx, base);
	// 82E87F30: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87F34: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E87F38: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87F40: 419A0088  beq cr6, 0x82e87fc8
	if ctx.cr[6].eq {
	pc = 0x82E87FC8; continue 'dispatch;
	}
	// 82E87F44: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87F48: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87F4C: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87F50: 41820078  beq 0x82e87fc8
	if ctx.cr[0].eq {
	pc = 0x82E87FC8; continue 'dispatch;
	}
	// 82E87F54: 574B02D6  rlwinm r11, r26, 0, 0xb, 0xb
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87F58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87F5C: 419A006C  beq cr6, 0x82e87fc8
	if ctx.cr[6].eq {
	pc = 0x82E87FC8; continue 'dispatch;
	}
	// 82E87F60: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87F64: 4BF6A45D  bl 0x82df23c0
	ctx.lr = 0x82E87F68;
	sub_82DF23C0(ctx, base);
	// 82E87F68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87F6C: 419A001C  beq cr6, 0x82e87f88
	if ctx.cr[6].eq {
	pc = 0x82E87F88; continue 'dispatch;
	}
	// 82E87F70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87F74: 3C800010  lis r4, 0x10
	ctx.r[4].s64 = 1048576;
	// 82E87F78: 38AB0044  addi r5, r11, 0x44
	ctx.r[5].s64 = ctx.r[11].s64 + 68;
	// 82E87F7C: 4BFFD295  bl 0x82e85210
	ctx.lr = 0x82E87F80;
	sub_82E85210(ctx, base);
	// 82E87F80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87F84: 48000008  b 0x82e87f8c
	pc = 0x82E87F8C; continue 'dispatch;
	// 82E87F88: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E87F8C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E87F90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87F98: 4BFFCE41  bl 0x82e84dd8
	ctx.lr = 0x82E87F9C;
	sub_82E84DD8(ctx, base);
	// 82E87F9C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E87FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87FA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E87FA8: 4B438059  bl 0x822c0000
	ctx.lr = 0x82E87FAC;
	sub_822C0000(ctx, base);
	// 82E87FAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E87FB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E87FB4: 4BFFF1ED  bl 0x82e871a0
	ctx.lr = 0x82E87FB8;
	sub_82E871A0(ctx, base);
	// 82E87FB8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87FBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E87FC0: 419A0008  beq cr6, 0x82e87fc8
	if ctx.cr[6].eq {
	pc = 0x82E87FC8; continue 'dispatch;
	}
	// 82E87FC4: 4B4388CD  bl 0x822c0890
	ctx.lr = 0x82E87FC8;
	sub_822C0890(ctx, base);
	// 82E87FC8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87FCC: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E87FD0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87FD8: 419A0088  beq cr6, 0x82e88060
	if ctx.cr[6].eq {
	pc = 0x82E88060; continue 'dispatch;
	}
	// 82E87FDC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87FE0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E87FE4: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E87FE8: 41820078  beq 0x82e88060
	if ctx.cr[0].eq {
	pc = 0x82E88060; continue 'dispatch;
	}
	// 82E87FEC: 574B0294  rlwinm r11, r26, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E87FF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87FF4: 419A006C  beq cr6, 0x82e88060
	if ctx.cr[6].eq {
	pc = 0x82E88060; continue 'dispatch;
	}
	// 82E87FF8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E87FFC: 4BF6A3C5  bl 0x82df23c0
	ctx.lr = 0x82E88000;
	sub_82DF23C0(ctx, base);
	// 82E88000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88004: 419A001C  beq cr6, 0x82e88020
	if ctx.cr[6].eq {
	pc = 0x82E88020; continue 'dispatch;
	}
	// 82E88008: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8800C: 3C800020  lis r4, 0x20
	ctx.r[4].s64 = 2097152;
	// 82E88010: 38AB004C  addi r5, r11, 0x4c
	ctx.r[5].s64 = ctx.r[11].s64 + 76;
	// 82E88014: 4BFFD1FD  bl 0x82e85210
	ctx.lr = 0x82E88018;
	sub_82E85210(ctx, base);
	// 82E88018: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8801C: 48000008  b 0x82e88024
	pc = 0x82E88024; continue 'dispatch;
	// 82E88020: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E88024: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E88028: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8802C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E88030: 4BFFCDA9  bl 0x82e84dd8
	ctx.lr = 0x82E88034;
	sub_82E84DD8(ctx, base);
	// 82E88034: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E88038: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8803C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E88040: 4B437FC1  bl 0x822c0000
	ctx.lr = 0x82E88044;
	sub_822C0000(ctx, base);
	// 82E88044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E88048: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8804C: 4BFFF155  bl 0x82e871a0
	ctx.lr = 0x82E88050;
	sub_82E871A0(ctx, base);
	// 82E88050: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E88054: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88058: 419A0008  beq cr6, 0x82e88060
	if ctx.cr[6].eq {
	pc = 0x82E88060; continue 'dispatch;
	}
	// 82E8805C: 4B438835  bl 0x822c0890
	ctx.lr = 0x82E88060;
	sub_822C0890(ctx, base);
	// 82E88060: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88064: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E88068: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8806C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88070: 419A0080  beq cr6, 0x82e880f0
	if ctx.cr[6].eq {
	pc = 0x82E880F0; continue 'dispatch;
	}
	// 82E88074: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88078: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E8807C: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E88080: 41820070  beq 0x82e880f0
	if ctx.cr[0].eq {
	pc = 0x82E880F0; continue 'dispatch;
	}
	// 82E88084: 574B0252  rlwinm r11, r26, 0, 9, 9
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 82E88088: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8808C: 419A0064  beq cr6, 0x82e880f0
	if ctx.cr[6].eq {
	pc = 0x82E880F0; continue 'dispatch;
	}
	// 82E88090: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E88094: 4BF6A32D  bl 0x82df23c0
	ctx.lr = 0x82E88098;
	sub_82DF23C0(ctx, base);
	// 82E88098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8809C: 419A0018  beq cr6, 0x82e880b4
	if ctx.cr[6].eq {
	pc = 0x82E880B4; continue 'dispatch;
	}
	// 82E880A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E880A4: 3C800040  lis r4, 0x40
	ctx.r[4].s64 = 4194304;
	// 82E880A8: 38AB0034  addi r5, r11, 0x34
	ctx.r[5].s64 = ctx.r[11].s64 + 52;
	// 82E880AC: 4BFFD165  bl 0x82e85210
	ctx.lr = 0x82E880B0;
	sub_82E85210(ctx, base);
	// 82E880B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E880B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E880B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E880BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E880C0: 4BFFCD19  bl 0x82e84dd8
	ctx.lr = 0x82E880C4;
	sub_82E84DD8(ctx, base);
	// 82E880C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E880C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E880CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E880D0: 4B437F31  bl 0x822c0000
	ctx.lr = 0x82E880D4;
	sub_822C0000(ctx, base);
	// 82E880D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E880D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E880DC: 4BFFF0C5  bl 0x82e871a0
	ctx.lr = 0x82E880E0;
	sub_82E871A0(ctx, base);
	// 82E880E0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E880E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E880E8: 419A0008  beq cr6, 0x82e880f0
	if ctx.cr[6].eq {
	pc = 0x82E880F0; continue 'dispatch;
	}
	// 82E880EC: 4B4387A5  bl 0x822c0890
	ctx.lr = 0x82E880F0;
	sub_822C0890(ctx, base);
	// 82E880F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E880F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E880F8: 483200B8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88100 size=256
    let mut pc: u32 = 0x82E88100;
    'dispatch: loop {
        match pc {
            0x82E88100 => {
    //   block [0x82E88100..0x82E88200)
	// 82E88100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88104: 4832005D  bl 0x831a8160
	ctx.lr = 0x82E88108;
	sub_831A8130(ctx, base);
	// 82E88108: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8810C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E88110: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E88114: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E88118: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8811C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E88120: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88124: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E88128: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82E8812C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E88130: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E88134: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E88138: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8813C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88140: 13EA5C07  vcmpneb. (lvlx128) v31, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88144: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E88148: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8814C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E88150: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88154: 13805C07  vcmpneb. (lvlx128) v28, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88158: C00508A4  lfs f0, 0x8a4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88200 size=256
    let mut pc: u32 = 0x82E88200;
    'dispatch: loop {
        match pc {
            0x82E88200 => {
    //   block [0x82E88200..0x82E88300)
	// 82E88200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88204: 4831FF5D  bl 0x831a8160
	ctx.lr = 0x82E88208;
	sub_831A8130(ctx, base);
	// 82E88208: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8820C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E88210: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E88214: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E88218: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8821C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E88220: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88224: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E88228: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82E8822C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E88230: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E88234: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E88238: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8823C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88240: 13EA5C07  vcmpneb. (lvlx128) v31, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88244: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E88248: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8824C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E88250: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88254: 13805C07  vcmpneb. (lvlx128) v28, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88258: C00508A4  lfs f0, 0x8a4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88300 size=256
    let mut pc: u32 = 0x82E88300;
    'dispatch: loop {
        match pc {
            0x82E88300 => {
    //   block [0x82E88300..0x82E88400)
	// 82E88300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88304: 4831FE5D  bl 0x831a8160
	ctx.lr = 0x82E88308;
	sub_831A8130(ctx, base);
	// 82E88308: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8830C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E88310: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E88314: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E88318: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8831C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E88320: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88324: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E88328: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82E8832C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E88330: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E88334: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E88338: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8833C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88340: 13EA5C07  vcmpneb. (lvlx128) v31, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88344: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E88348: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8834C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E88350: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88354: 13805C07  vcmpneb. (lvlx128) v28, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88358: C00508A4  lfs f0, 0x8a4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88400 size=256
    let mut pc: u32 = 0x82E88400;
    'dispatch: loop {
        match pc {
            0x82E88400 => {
    //   block [0x82E88400..0x82E88500)
	// 82E88400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88404: 4831FD5D  bl 0x831a8160
	ctx.lr = 0x82E88408;
	sub_831A8130(ctx, base);
	// 82E88408: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8840C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E88410: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E88414: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E88418: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8841C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E88420: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88424: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E88428: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82E8842C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E88430: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E88434: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E88438: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8843C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88440: 13EA5C07  vcmpneb. (lvlx128) v31, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88444: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E88448: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8844C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E88450: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88454: 13805C07  vcmpneb. (lvlx128) v28, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88458: C00508A4  lfs f0, 0x8a4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88500 size=256
    let mut pc: u32 = 0x82E88500;
    'dispatch: loop {
        match pc {
            0x82E88500 => {
    //   block [0x82E88500..0x82E88600)
	// 82E88500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88504: 4831FC5D  bl 0x831a8160
	ctx.lr = 0x82E88508;
	sub_831A8130(ctx, base);
	// 82E88508: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8850C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E88510: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E88514: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E88518: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8851C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E88520: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88524: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E88528: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82E8852C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E88530: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E88534: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E88538: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8853C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88540: 13EA5C07  vcmpneb. (lvlx128) v31, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88544: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E88548: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8854C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E88550: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88554: 13805C07  vcmpneb. (lvlx128) v28, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88558: C00508A4  lfs f0, 0x8a4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88600 size=64
    let mut pc: u32 = 0x82E88600;
    'dispatch: loop {
        match pc {
            0x82E88600 => {
    //   block [0x82E88600..0x82E88640)
	// 82E88600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88608: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8860C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E88610: 816B694C  lwz r11, 0x694c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26956 as u32) ) } as u64;
	// 82E88614: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88618: 409A0018  bne cr6, 0x82e88630
	if !ctx.cr[6].eq {
	pc = 0x82E88630; continue 'dispatch;
	}
	// 82E8861C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E88620: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E88624: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E88628: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8862C: 4BFFFAD5  bl 0x82e88100
	ctx.lr = 0x82E88630;
	sub_82E88100(ctx, base);
	// 82E88630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88640 size=48
    let mut pc: u32 = 0x82E88640;
    'dispatch: loop {
        match pc {
            0x82E88640 => {
    //   block [0x82E88640..0x82E88670)
	// 82E88640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88648: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8864C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E88650: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E88654: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E88658: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8865C: 4BFFFBA5  bl 0x82e88200
	ctx.lr = 0x82E88660;
	sub_82E88200(ctx, base);
	// 82E88660: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8866C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88670 size=48
    let mut pc: u32 = 0x82E88670;
    'dispatch: loop {
        match pc {
            0x82E88670 => {
    //   block [0x82E88670..0x82E886A0)
	// 82E88670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88678: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8867C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E88680: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E88684: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E88688: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8868C: 4BFFFC75  bl 0x82e88300
	ctx.lr = 0x82E88690;
	sub_82E88300(ctx, base);
	// 82E88690: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8869C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E886A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E886A0 size=64
    let mut pc: u32 = 0x82E886A0;
    'dispatch: loop {
        match pc {
            0x82E886A0 => {
    //   block [0x82E886A0..0x82E886E0)
	// 82E886A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E886A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E886A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E886AC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E886B0: 816B6948  lwz r11, 0x6948(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26952 as u32) ) } as u64;
	// 82E886B4: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E886B8: 409A0018  bne cr6, 0x82e886d0
	if !ctx.cr[6].eq {
	pc = 0x82E886D0; continue 'dispatch;
	}
	// 82E886BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E886C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E886C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E886C8: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E886CC: 4BFFFD35  bl 0x82e88400
	ctx.lr = 0x82E886D0;
	sub_82E88400(ctx, base);
	// 82E886D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E886D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E886D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E886DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E886E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E886E0 size=136
    let mut pc: u32 = 0x82E886E0;
    'dispatch: loop {
        match pc {
            0x82E886E0 => {
    //   block [0x82E886E0..0x82E88768)
	// 82E886E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E886E4: 4831FA81  bl 0x831a8164
	ctx.lr = 0x82E886E8;
	sub_831A8130(ctx, base);
	// 82E886E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E886EC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E886F0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E886F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E886F8: 3BEB6940  addi r31, r11, 0x6940
	ctx.r[31].s64 = ctx.r[11].s64 + 26944;
	// 82E886FC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E88700: 816A6944  lwz r11, 0x6944(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26948 as u32) ) } as u64;
	// 82E88704: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E88708: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E8870C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82E88710: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E88714: 409A001C  bne cr6, 0x82e88730
	if !ctx.cr[6].eq {
	pc = 0x82E88730; continue 'dispatch;
	}
	// 82E88718: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E8871C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82E88720: 916A6944  stw r11, 0x6944(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(26948 as u32), ctx.r[11].u32 ) };
	// 82E88724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88728: 38899430  addi r4, r9, -0x6bd0
	ctx.r[4].s64 = ctx.r[9].s64 + -27600;
	// 82E8872C: 4BF70E05  bl 0x82df9530
	ctx.lr = 0x82E88730;
	sub_82DF9530(ctx, base);
	// 82E88730: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88734: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88738: 409A0028  bne cr6, 0x82e88760
	if !ctx.cr[6].eq {
	pc = 0x82E88760; continue 'dispatch;
	}
	// 82E8873C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E88740: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E88744: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E88748: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8874C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E88750: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E88754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E88758: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8875C: 4BFFFDA5  bl 0x82e88500
	ctx.lr = 0x82E88760;
	sub_82E88500(ctx, base);
	// 82E88760: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E88764: 4831FA50  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88768 size=240
    let mut pc: u32 = 0x82E88768;
    'dispatch: loop {
        match pc {
            0x82E88768 => {
    //   block [0x82E88768..0x82E88858)
	// 82E88768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8876C: 4831F9F9  bl 0x831a8164
	ctx.lr = 0x82E88770;
	sub_831A8130(ctx, base);
	// 82E88770: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E88774: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88778: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8877C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88780: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E88784: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E88788: C3FE0008  lfs f31, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8878C: 4BF69C35  bl 0x82df23c0
	ctx.lr = 0x82E88790;
	sub_82DF23C0(ctx, base);
	// 82E88790: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E88794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88798: 419A0010  beq cr6, 0x82e887a8
	if ctx.cr[6].eq {
	pc = 0x82E887A8; continue 'dispatch;
	}
	// 82E8879C: 4800062D  bl 0x82e88dc8
	ctx.lr = 0x82E887A0;
	sub_82E88DC8(ctx, base);
	// 82E887A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E887A4: 48000008  b 0x82e887ac
	pc = 0x82E887AC; continue 'dispatch;
	// 82E887A8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82E887AC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82E887B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E887B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E887B8: 4BFFC621  bl 0x82e84dd8
	ctx.lr = 0x82E887BC;
	sub_82E84DD8(ctx, base);
	// 82E887BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E887C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E887C4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E887C8: 4B437839  bl 0x822c0000
	ctx.lr = 0x82E887CC;
	sub_822C0000(ctx, base);
	// 82E887CC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E887D0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E887D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E887D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E887DC: D3EB0008  stfs f31, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E887E0: 80DE0028  lwz r6, 0x28(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E887E4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E887E8: 4BFFF2E9  bl 0x82e87ad0
	ctx.lr = 0x82E887EC;
	sub_82E87AD0(ctx, base);
	// 82E887EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E887F0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82E887F4: 4BFFE475  bl 0x82e86c68
	ctx.lr = 0x82E887F8;
	sub_82E86C68(ctx, base);
	// 82E887F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E887FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88800: 419A0024  beq cr6, 0x82e88824
	if ctx.cr[6].eq {
	pc = 0x82E88824; continue 'dispatch;
	}
	// 82E88804: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E88808: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8880C: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E88810: 4BFFD629  bl 0x82e85e38
	ctx.lr = 0x82E88814;
	sub_82E85E38(ctx, base);
	// 82E88814: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E88818: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E8881C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E88820: 4BF69969  bl 0x82df2188
	ctx.lr = 0x82E88824;
	sub_82DF2188(ctx, base);
	// 82E88824: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82E88828: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82E8882C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82E88830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88834: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82E88838: 480009E9  bl 0x82e89220
	ctx.lr = 0x82E8883C;
	sub_82E89220(ctx, base);
	// 82E8883C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E88840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88844: 419A0008  beq cr6, 0x82e8884c
	if ctx.cr[6].eq {
	pc = 0x82E8884C; continue 'dispatch;
	}
	// 82E88848: 4B438049  bl 0x822c0890
	ctx.lr = 0x82E8884C;
	sub_822C0890(ctx, base);
	// 82E8884C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E88850: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E88854: 4831F960  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88858 size=252
    let mut pc: u32 = 0x82E88858;
    'dispatch: loop {
        match pc {
            0x82E88858 => {
    //   block [0x82E88858..0x82E88954)
	// 82E88858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8885C: 4831F909  bl 0x831a8164
	ctx.lr = 0x82E88860;
	sub_831A8130(ctx, base);
	// 82E88860: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E88864: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8886C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88870: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E88874: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E88878: C3FE00BC  lfs f31, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8887C: 4BF69B45  bl 0x82df23c0
	ctx.lr = 0x82E88880;
	sub_82DF23C0(ctx, base);
	// 82E88880: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E88884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88888: 419A0010  beq cr6, 0x82e88898
	if ctx.cr[6].eq {
	pc = 0x82E88898; continue 'dispatch;
	}
	// 82E8888C: 4800053D  bl 0x82e88dc8
	ctx.lr = 0x82E88890;
	sub_82E88DC8(ctx, base);
	// 82E88890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88894: 48000008  b 0x82e8889c
	pc = 0x82E8889C; continue 'dispatch;
	// 82E88898: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82E8889C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82E888A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E888A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E888A8: 4BFFC531  bl 0x82e84dd8
	ctx.lr = 0x82E888AC;
	sub_82E84DD8(ctx, base);
	// 82E888AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E888B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E888B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E888B8: 4B437749  bl 0x822c0000
	ctx.lr = 0x82E888BC;
	sub_822C0000(ctx, base);
	// 82E888BC: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E888C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E888C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E888C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E888CC: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E888D0: 80DE00C8  lwz r6, 0xc8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E888D4: 4BFFF1FD  bl 0x82e87ad0
	ctx.lr = 0x82E888D8;
	sub_82E87AD0(ctx, base);
	// 82E888D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E888DC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82E888E0: 4BFFE389  bl 0x82e86c68
	ctx.lr = 0x82E888E4;
	sub_82E86C68(ctx, base);
	// 82E888E4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E888E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E888EC: 419A0024  beq cr6, 0x82e88910
	if ctx.cr[6].eq {
	pc = 0x82E88910; continue 'dispatch;
	}
	// 82E888F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E888F4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E888F8: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E888FC: 4BFFD53D  bl 0x82e85e38
	ctx.lr = 0x82E88900;
	sub_82E85E38(ctx, base);
	// 82E88900: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E88904: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E88908: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8890C: 4BF6987D  bl 0x82df2188
	ctx.lr = 0x82E88910;
	sub_82DF2188(ctx, base);
	// 82E88910: 93FE016C  stw r31, 0x16c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(364 as u32), ctx.r[31].u32 ) };
	// 82E88914: 397E016C  addi r11, r30, 0x16c
	ctx.r[11].s64 = ctx.r[30].s64 + 364;
	// 82E88918: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82E8891C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82E88920: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82E88924: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E88928: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82E8892C: 4B43BB35  bl 0x822c4460
	ctx.lr = 0x82E88930;
	sub_822C4460(ctx, base);
	// 82E88930: 387E0158  addi r3, r30, 0x158
	ctx.r[3].s64 = ctx.r[30].s64 + 344;
	// 82E88934: 4BFF544D  bl 0x82e7dd80
	ctx.lr = 0x82E88938;
	sub_82E7DD80(ctx, base);
	// 82E88938: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8893C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88940: 419A0008  beq cr6, 0x82e88948
	if ctx.cr[6].eq {
	pc = 0x82E88948; continue 'dispatch;
	}
	// 82E88944: 4B437F4D  bl 0x822c0890
	ctx.lr = 0x82E88948;
	sub_822C0890(ctx, base);
	// 82E88948: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8894C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E88950: 4831F864  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E88958 size=44
    let mut pc: u32 = 0x82E88958;
    'dispatch: loop {
        match pc {
            0x82E88958 => {
    //   block [0x82E88958..0x82E88984)
	// 82E88958: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8895C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88960: 419A001C  beq cr6, 0x82e8897c
	if ctx.cr[6].eq {
	pc = 0x82E8897C; continue 'dispatch;
	}
	// 82E88964: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88968: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 82E8896C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E88970: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82E88974: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E88978: 4098000C  bge cr6, 0x82e88984
	if !ctx.cr[6].lt {
		sub_82E88984(ctx, base);
		return;
	}
	// 82E8897C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E88980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88984(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E88984 size=28
    let mut pc: u32 = 0x82E88984;
    'dispatch: loop {
        match pc {
            0x82E88984 => {
    //   block [0x82E88984..0x82E889A0)
	// 82E88984: 386AFFFE  addi r3, r10, -2
	ctx.r[3].s64 = ctx.r[10].s64 + -2;
	// 82E88988: 1D43001C  mulli r10, r3, 0x1c
	ctx.r[10].s64 = ctx.r[3].s64 * 28;
	// 82E8898C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E88990: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E88994: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88998: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8899C: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E889A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E889A0 size=24
    let mut pc: u32 = 0x82E889A0;
    'dispatch: loop {
        match pc {
            0x82E889A0 => {
    //   block [0x82E889A0..0x82E889B8)
	// 82E889A0: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 82E889A4: 3863FFFF  addi r3, r3, -1
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	// 82E889A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E889AC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E889B0: 4198FFF0  blt cr6, 0x82e889a0
	if ctx.cr[6].lt {
	pc = 0x82E889A0; continue 'dispatch;
	}
	// 82E889B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E889B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E889B8 size=36
    let mut pc: u32 = 0x82E889B8;
    'dispatch: loop {
        match pc {
            0x82E889B8 => {
    //   block [0x82E889B8..0x82E889DC)
	// 82E889B8: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E889BC: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E889C0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E889C4: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E889C8: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E889CC: ED4C00BA  fmadds f10, f12, f2, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E889D0: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E889D4: D1230008  stfs f9, 8(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E889D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E889E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E889E0 size=36
    let mut pc: u32 = 0x82E889E0;
    'dispatch: loop {
        match pc {
            0x82E889E0 => {
    //   block [0x82E889E0..0x82E88A04)
	// 82E889E0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E889E4: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E889E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E889EC: 409A0018  bne cr6, 0x82e88a04
	if !ctx.cr[6].eq {
		sub_82E88A04(ctx, base);
		return;
	}
	// 82E889F0: C0050008  lfs f0, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E889F4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E889F8: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E889FC: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88A00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88A04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E88A04 size=96
    let mut pc: u32 = 0x82E88A04;
    'dispatch: loop {
        match pc {
            0x82E88A04 => {
    //   block [0x82E88A04..0x82E88A64)
	// 82E88A04: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88A08: C1A50010  lfs f13, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88A0C: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88A10: FD606850  fneg f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88A14: C1040004  lfs f8, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E88A18: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E88A1C: ECC14028  fsubs f6, f1, f8
	ctx.f[6].f64 = (((ctx.f[1].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E88A20: C125000C  lfs f9, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E88A24: C0E40008  lfs f7, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E88A28: C0A50008  lfs f5, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E88A2C: C0850004  lfs f4, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E88A30: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88A34: EC644028  fsubs f3, f4, f8
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E88A38: EC2A6028  fsubs f1, f10, f12
	ctx.f[1].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E88A3C: EC095828  fsubs f0, f9, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E88A40: EDA61824  fdivs f13, f6, f3
	ctx.f[13].f64 = ((ctx.f[6].f64 / ctx.f[3].f64) as f32) as f64;
	// 82E88A44: ED8160BA  fmadds f12, f1, f2, f12
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[2].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E88A48: ED6058BA  fmadds f11, f0, f2, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E88A4C: ED4C382A  fadds f10, f12, f7
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E88A50: ED2B282A  fadds f9, f11, f5
	ctx.f[9].f64 = ((ctx.f[11].f64 + ctx.f[5].f64) as f32) as f64;
	// 82E88A54: ED095028  fsubs f8, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E88A58: ECE8537A  fmadds f7, f8, f13, f10
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E88A5C: D0E30008  stfs f7, 8(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E88A68 size=472
    let mut pc: u32 = 0x82E88A68;
    'dispatch: loop {
        match pc {
            0x82E88A68 => {
    //   block [0x82E88A68..0x82E88C40)
	// 82E88A68: DBA1FFE8  stfd f29, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[29].u64 ) };
	// 82E88A6C: DBC1FFF0  stfd f30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[30].u64 ) };
	// 82E88A70: DBE1FFF8  stfd f31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82E88A74: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88A78: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88A7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E88A80: 409A0020  bne cr6, 0x82e88aa0
	if !ctx.cr[6].eq {
	pc = 0x82E88AA0; continue 'dispatch;
	}
	// 82E88A84: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88A88: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88A8C: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88A90: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88A94: CBA1FFE8  lfd f29, -0x18(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88A98: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88A9C: 4E800020  blr
	return;
	// 82E88AA0: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88AA4: 4098004C  bge cr6, 0x82e88af0
	if !ctx.cr[6].lt {
	pc = 0x82E88AF0; continue 'dispatch;
	}
	// 82E88AA8: C0040010  lfs f0, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88AAC: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88AB0: C184000C  lfs f12, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E88AB4: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E88AB8: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E88ABC: ED2A58BA  fmadds f9, f10, f2, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[2].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E88AC0: ED09682A  fadds f8, f9, f13
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E88AC4: D1030008  stfs f8, 8(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88AC8: C0E40014  lfs f7, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E88ACC: C0C40004  lfs f6, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E88AD0: ECA13028  fsubs f5, f1, f6
	ctx.f[5].f64 = (((ctx.f[1].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E88AD4: EC8541FA  fmadds f4, f5, f7, f8
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[7].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E88AD8: D0830008  stfs f4, 8(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88ADC: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88AE0: CBA1FFE8  lfd f29, -0x18(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88AE4: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88AE8: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E88AEC: 4E800020  blr
	return;
	// 82E88AF0: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E88AF4: 4099004C  ble cr6, 0x82e88b40
	if !ctx.cr[6].gt {
	pc = 0x82E88B40; continue 'dispatch;
	}
	// 82E88AF8: C0050010  lfs f0, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88AFC: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88B00: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E88B04: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E88B08: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E88B0C: ED2A58BA  fmadds f9, f10, f2, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[2].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E88B10: ED09682A  fadds f8, f9, f13
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E88B14: D1030008  stfs f8, 8(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88B18: C0A50018  lfs f5, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E88B1C: C0E50004  lfs f7, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E88B20: ECC13828  fsubs f6, f1, f7
	ctx.f[6].f64 = (((ctx.f[1].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E88B24: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88B28: EC86417A  fmadds f4, f6, f5, f8
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[5].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E88B2C: D0830008  stfs f4, 8(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88B30: CBA1FFE8  lfd f29, -0x18(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88B34: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88B38: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E88B3C: 4E800020  blr
	return;
	// 82E88B40: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88B44: 40980030  bge cr6, 0x82e88b74
	if !ctx.cr[6].lt {
	pc = 0x82E88B74; continue 'dispatch;
	}
	// 82E88B48: C0050010  lfs f0, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88B4C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88B50: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E88B54: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88B58: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E88B5C: ED4B68BA  fmadds f10, f11, f2, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E88B60: D1430008  stfs f10, 8(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88B64: CBA1FFE8  lfd f29, -0x18(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88B68: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88B6C: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E88B70: 4E800020  blr
	return;
	// 82E88B74: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88B78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E88B7C: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88B80: ED610028  fsubs f11, f1, f0
	ctx.f[11].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E88B84: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E88B88: C1250010  lfs f9, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E88B8C: C0E40010  lfs f7, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E88B90: FD004850  fneg f8, f9
	ctx.f[8].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88B94: FCA03850  fneg f5, f7
	ctx.f[5].u64 = ctx.f[7].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E88B98: C0C5000C  lfs f6, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E88B9C: C084000C  lfs f4, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E88BA0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82E88BA4: C0650008  lfs f3, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E88BA8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E88BAC: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E88BB0: C0E40018  lfs f7, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E88BB4: C3C50014  lfs f30, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E88BB8: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88BBC: EFEB02F2  fmuls f31, f11, f11
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E88BC0: C00BA1C4  lfs f0, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88BC4: ED405030  fres f10, f10
	ctx.f[10].f64 = (1.0f32 / (ctx.f[10].f64 as f32)) as f64;
	// 82E88BC8: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88BCC: ECC64028  fsubs f6, f6, f8
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E88BD0: C18908A8  lfs f12, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E88BD4: EC842828  fsubs f4, f4, f5
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[5].f64) as f32) as f64);
	// 82E88BD8: EC2A02B2  fmuls f1, f10, f10
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E88BDC: ED0640BA  fmadds f8, f6, f2, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E88BE0: ECC428BA  fmadds f6, f4, f2, f5
	ctx.f[6].f64 = (((ctx.f[4].f64 * ctx.f[2].f64 + ctx.f[5].f64) as f32) as f64);
	// 82E88BE4: EFBF02B2  fmuls f29, f31, f10
	ctx.f[29].f64 = (((ctx.f[31].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E88BE8: ECBF0072  fmuls f5, f31, f1
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E88BEC: EC88182A  fadds f4, f8, f3
	ctx.f[4].f64 = ((ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64;
	// 82E88BF0: EC66482A  fadds f3, f6, f9
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E88BF4: EC4502F2  fmuls f2, f5, f11
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E88BF8: EC250032  fmuls f1, f5, f0
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E88BFC: EC0202B2  fmuls f0, f2, f10
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E88C00: ED42E828  fsubs f10, f2, f29
	ctx.f[10].f64 = (((ctx.f[2].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E88C04: ED200372  fmuls f9, f0, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E88C08: ED0AE828  fsubs f8, f10, f29
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E88C0C: ECA14828  fsubs f5, f1, f9
	ctx.f[5].f64 = (((ctx.f[1].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E88C10: ECC90828  fsubs f6, f9, f1
	ctx.f[6].f64 = (((ctx.f[9].f64 - ctx.f[1].f64) as f32) as f64);
	// 82E88C14: EC48582A  fadds f2, f8, f11
	ctx.f[2].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E88C18: EC040172  fmuls f0, f4, f5
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[5].f64) as f32) as f64);
	// 82E88C1C: EC26602A  fadds f1, f6, f12
	ctx.f[1].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E88C20: EDA3007A  fmadds f13, f3, f1, f0
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E88C24: ED8269FA  fmadds f12, f2, f7, f13
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E88C28: ED7E62BA  fmadds f11, f30, f10, f12
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E88C2C: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88C30: CBA1FFE8  lfd f29, -0x18(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88C34: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88C38: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E88C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88C40 size=280
    let mut pc: u32 = 0x82E88C40;
    'dispatch: loop {
        match pc {
            0x82E88C40 => {
    //   block [0x82E88C40..0x82E88D58)
	// 82E88C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88C48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88C4C: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88C50: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E88C54: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E88C58: 38650004  addi r3, r5, 4
	ctx.r[3].s64 = ctx.r[5].s64 + 4;
	// 82E88C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88C60: 419A004C  beq cr6, 0x82e88cac
	if ctx.cr[6].eq {
	pc = 0x82E88CAC; continue 'dispatch;
	}
	// 82E88C64: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88C68: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 82E88C6C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E88C70: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82E88C74: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82E88C78: 409A0034  bne cr6, 0x82e88cac
	if !ctx.cr[6].eq {
	pc = 0x82E88CAC; continue 'dispatch;
	}
	// 82E88C7C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E88C80: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88C84: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88C88: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E88C8C: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E88C90: D0260004  stfs f1, 4(r6)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88C94: ED4C58BA  fmadds f10, f12, f2, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[2].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E88C98: D1460008  stfs f10, 8(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88C9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88CA8: 4E800020  blr
	return;
	// 82E88CAC: 80E1008C  lwz r7, 0x8c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E88CB0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82E88CB4: 4BFFFCA5  bl 0x82e88958
	ctx.lr = 0x82E88CB8;
	sub_82E88958(ctx, base);
	// 82E88CB8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88CBC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82E88CC0: 419A0070  beq cr6, 0x82e88d30
	if ctx.cr[6].eq {
	pc = 0x82E88D30; continue 'dispatch;
	}
	// 82E88CC4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82E88CC8: 419A002C  beq cr6, 0x82e88cf4
	if ctx.cr[6].eq {
	pc = 0x82E88CF4; continue 'dispatch;
	}
	// 82E88CCC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88CD0: 1D43001C  mulli r10, r3, 0x1c
	ctx.r[10].s64 = ctx.r[3].s64 * 28;
	// 82E88CD4: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E88CD8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82E88CDC: 38A4001C  addi r5, r4, 0x1c
	ctx.r[5].s64 = ctx.r[4].s64 + 28;
	// 82E88CE0: 4BFFFD01  bl 0x82e889e0
	ctx.lr = 0x82E88CE4;
	sub_82E889E0(ctx, base);
	// 82E88CE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88CE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88CEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88CF0: 4E800020  blr
	return;
	// 82E88CF4: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88CF8: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 82E88CFC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E88D00: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88D04: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88D08: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E88D0C: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E88D10: D0260004  stfs f1, 4(r6)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88D14: ED4C00BA  fmadds f10, f12, f2, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E88D18: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E88D1C: D1260008  stfs f9, 8(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88D20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88D24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88D28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88D2C: 4E800020  blr
	return;
	// 82E88D30: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88D34: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 82E88D38: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E88D3C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82E88D40: 38A4001C  addi r5, r4, 0x1c
	ctx.r[5].s64 = ctx.r[4].s64 + 28;
	// 82E88D44: 4BFFFD25  bl 0x82e88a68
	ctx.lr = 0x82E88D48;
	sub_82E88A68(ctx, base);
	// 82E88D48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88D4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88D50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88D58 size=112
    let mut pc: u32 = 0x82E88D58;
    'dispatch: loop {
        match pc {
            0x82E88D58 => {
    //   block [0x82E88D58..0x82E88DC8)
	// 82E88D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E88D64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88D68: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E88D6C: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 82E88D70: 394BE17C  addi r10, r11, -0x1e84
	ctx.r[10].s64 = ctx.r[11].s64 + -7812;
	// 82E88D74: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E88D78: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E88D80: 419A0024  beq cr6, 0x82e88da4
	if ctx.cr[6].eq {
	pc = 0x82E88DA4; continue 'dispatch;
	}
	// 82E88D84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E88D88: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E88D8C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88D90: 4BFFD0A9  bl 0x82e85e38
	ctx.lr = 0x82E88D94;
	sub_82E85E38(ctx, base);
	// 82E88D94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E88D98: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88D9C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E88DA0: 4BF693E9  bl 0x82df2188
	ctx.lr = 0x82E88DA4;
	sub_82DF2188(ctx, base);
	// 82E88DA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E88DA8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E88DAC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E88DB0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E88DB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E88DB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88DBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88DC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88DC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E88DC8 size=48
    let mut pc: u32 = 0x82E88DC8;
    'dispatch: loop {
        match pc {
            0x82E88DC8 => {
    //   block [0x82E88DC8..0x82E88DF8)
	// 82E88DC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E88DCC: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82E88DD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E88DD4: 3909E17C  addi r8, r9, -0x1e84
	ctx.r[8].s64 = ctx.r[9].s64 + -7812;
	// 82E88DD8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88DDC: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E88DE0: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E88DE4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E88DE8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E88DEC: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E88DF0: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E88DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88DF8 size=80
    let mut pc: u32 = 0x82E88DF8;
    'dispatch: loop {
        match pc {
            0x82E88DF8 => {
    //   block [0x82E88DF8..0x82E88E48)
	// 82E88DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E88E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E88E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88E10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E88E14: 4BFFFF45  bl 0x82e88d58
	ctx.lr = 0x82E88E18;
	sub_82E88D58(ctx, base);
	// 82E88E18: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E88E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88E24: 419A000C  beq cr6, 0x82e88e30
	if ctx.cr[6].eq {
	pc = 0x82E88E30; continue 'dispatch;
	}
	// 82E88E28: 4BF695B1  bl 0x82df23d8
	ctx.lr = 0x82E88E2C;
	sub_82DF23D8(ctx, base);
	// 82E88E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E88E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E88E48 size=8
    let mut pc: u32 = 0x82E88E48;
    'dispatch: loop {
        match pc {
            0x82E88E48 => {
    //   block [0x82E88E48..0x82E88E50)
	// 82E88E48: C0230038  lfs f1, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E88E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88E50 size=96
    let mut pc: u32 = 0x82E88E50;
    'dispatch: loop {
        match pc {
            0x82E88E50 => {
    //   block [0x82E88E50..0x82E88EB0)
	// 82E88E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88E5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E88E60: 39400150  li r10, 0x150
	ctx.r[10].s64 = 336;
	// 82E88E64: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82E88E68: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82E88E6C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E88E70: C00B0190  lfs f0, 0x190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88E74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E88E78: C1AB0194  lfs f13, 0x194(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88E7C: C18B0198  lfs f12, 0x198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E88E80: C16B019C  lfs f11, 0x19c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E88E84: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E88E88: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E88E8C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E88E90: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E88E94: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88EB0 size=120
    let mut pc: u32 = 0x82E88EB0;
    'dispatch: loop {
        match pc {
            0x82E88EB0 => {
    //   block [0x82E88EB0..0x82E88F28)
	// 82E88EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88EB8: DBA1FFE0  stfd f29, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[29].u64 ) };
	// 82E88EBC: DBC1FFE8  stfd f30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 82E88EC0: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82E88EC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88EC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E88ECC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E88ED0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88ED4: EFC20032  fmuls f30, f2, f0
	ctx.f[30].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E88ED8: EFBEF82A  fadds f29, f30, f31
	ctx.f[29].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E88EDC: 48322DED  bl 0x831abcc8
	ctx.lr = 0x82E88EE0;
	sub_831ABCC8(ctx, base);
	// 82E88EE0: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 82E88EE4: EDBFF028  fsubs f13, f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82E88EE8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82E88EEC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E88EF0: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E88EF4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82E88EF8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E88EFC: C0094E28  lfs f0, 0x4e28(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88F00: ED2DE828  fsubs f9, f13, f29
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E88F04: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E88F08: EC28EA7A  fmadds f1, f8, f9, f29
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[9].f64 + ctx.f[29].f64) as f32) as f64);
	// 82E88F0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E88F10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88F14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88F18: CBA1FFE0  lfd f29, -0x20(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E88F1C: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88F20: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88F24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88F28 size=388
    let mut pc: u32 = 0x82E88F28;
    'dispatch: loop {
        match pc {
            0x82E88F28 => {
    //   block [0x82E88F28..0x82E890AC)
	// 82E88F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88F2C: 4831F239  bl 0x831a8164
	ctx.lr = 0x82E88F30;
	sub_831A8130(ctx, base);
	// 82E88F30: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88F34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E88F38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E88F3C: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82E88F40: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 82E88F44: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 82E88F48: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 82E88F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88F50: 419A001C  beq cr6, 0x82e88f6c
	if ctx.cr[6].eq {
	pc = 0x82E88F6C; continue 'dispatch;
	}
	// 82E88F54: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E88F58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88F5C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88F60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E88F64: 4E800421  bctrl
	ctx.lr = 0x82E88F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88F68: 4800002C  b 0x82e88f94
	pc = 0x82E88F94; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E890B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E890B0 size=216
    let mut pc: u32 = 0x82E890B0;
    'dispatch: loop {
        match pc {
            0x82E890B0 => {
    //   block [0x82E890B0..0x82E89188)
	// 82E890B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E890B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E890B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E890BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E890C0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E890C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E890C8: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 82E890CC: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 82E890D0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E890D4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E890D8: 38E00040  li r7, 0x40
	ctx.r[7].s64 = 64;
	// 82E890DC: 39000050  li r8, 0x50
	ctx.r[8].s64 = 80;
	// 82E890E0: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 82E890E4: 388B0078  addi r4, r11, 0x78
	ctx.r[4].s64 = ctx.r[11].s64 + 120;
	// 82E890E8: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82E890EC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E890F0: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82E890F4: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E890F8: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82E890FC: 88AB000C  lbz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E89100: 98BF000C  stb r5, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u8 ) };
	// 82E89104: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89108: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8910C: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89110: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E89114: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E89118: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8911C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E89188 size=148
    let mut pc: u32 = 0x82E89188;
    'dispatch: loop {
        match pc {
            0x82E89188 => {
    //   block [0x82E89188..0x82E8921C)
	// 82E89188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8918C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E89194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8919C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E891A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E891A4: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82E891A8: 395E0010  addi r10, r30, 0x10
	ctx.r[10].s64 = ctx.r[30].s64 + 16;
	// 82E891AC: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82E891B0: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89220 size=28
    let mut pc: u32 = 0x82E89220;
    'dispatch: loop {
        match pc {
            0x82E89220 => {
    //   block [0x82E89220..0x82E8923C)
	// 82E89220: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89224: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E89228: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82E8922C: 394B00F0  addi r10, r11, 0xf0
	ctx.r[10].s64 = ctx.r[11].s64 + 240;
	// 82E89230: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82E89234: 912B00F0  stw r9, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[9].u32 ) };
	// 82E89238: 4B43B228  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89240 size=196
    let mut pc: u32 = 0x82E89240;
    'dispatch: loop {
        match pc {
            0x82E89240 => {
    //   block [0x82E89240..0x82E89304)
	// 82E89240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8924C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89254: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E89258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8925C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E89260: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E89264: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E89268: 4B4376D1  bl 0x822c0938
	ctx.lr = 0x82E8926C;
	sub_822C0938(ctx, base);
	// 82E8926C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E89270: 419A0028  beq cr6, 0x82e89298
	if ctx.cr[6].eq {
	pc = 0x82E89298; continue 'dispatch;
	}
	// 82E89274: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E89278: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82E8927C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E89280: 392BE180  addi r9, r11, -0x1e80
	ctx.r[9].s64 = ctx.r[11].s64 + -7808;
	// 82E89284: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E89288: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8928C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E89290: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E89294: 48000008  b 0x82e8929c
	pc = 0x82E8929C; continue 'dispatch;
	// 82E89298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8929C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E892A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E892A4: 409A0044  bne cr6, 0x82e892e8
	if !ctx.cr[6].eq {
	pc = 0x82E892E8; continue 'dispatch;
	}
	// 82E892A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E892AC: 419A001C  beq cr6, 0x82e892c8
	if ctx.cr[6].eq {
	pc = 0x82E892C8; continue 'dispatch;
	}
	// 82E892B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E892B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E892B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E892BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E892C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E892C4: 4E800421  bctrl
	ctx.lr = 0x82E892C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E892C8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E892CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E892D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E892D4: 392A0828  addi r9, r10, 0x828
	ctx.r[9].s64 = ctx.r[10].s64 + 2088;
	// 82E892D8: 816BBAFC  lwz r11, -0x4504(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17668 as u32) ) } as u64;
	// 82E892DC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82E892E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E892E4: 4B436D1D  bl 0x822c0000
	ctx.lr = 0x82E892E8;
	sub_822C0000(ctx, base);
	// 82E892E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E892EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E892F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E892F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E892F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E892FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E89308 size=136
    let mut pc: u32 = 0x82E89308;
    'dispatch: loop {
        match pc {
            0x82E89308 => {
    //   block [0x82E89308..0x82E89390)
	// 82E89308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8930C: 4831EE61  bl 0x831a816c
	ctx.lr = 0x82E89310;
	sub_831A8130(ctx, base);
	// 82E89310: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82E89314: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82E89318: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E8931C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89320: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E89324: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E89328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8932C: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E89330: C05D0000  lfs f2, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E89334: 4BFFFB7D  bl 0x82e88eb0
	ctx.lr = 0x82E89338;
	sub_82E88EB0(ctx, base);
	// 82E89338: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E8933C: C05D0004  lfs f2, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E89340: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E89344: 4BFFFB6D  bl 0x82e88eb0
	ctx.lr = 0x82E89348;
	sub_82E88EB0(ctx, base);
	// 82E89348: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82E8934C: C05D0008  lfs f2, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E89350: C03E0008  lfs f1, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E89354: 4BFFFB5D  bl 0x82e88eb0
	ctx.lr = 0x82E89358;
	sub_82E88EB0(ctx, base);
	// 82E89358: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82E8935C: C05D000C  lfs f2, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E89360: C03E000C  lfs f1, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E89364: 4BFFFB4D  bl 0x82e88eb0
	ctx.lr = 0x82E89368;
	sub_82E88EB0(ctx, base);
	// 82E89368: D3FF0000  stfs f31, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8936C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89370: D3DF0004  stfs f30, 4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E89374: D3BF0008  stfs f29, 8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E89378: D03F000C  stfs f1, 0xc(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8937C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E89380: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E89384: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E89388: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E8938C: 4831EE30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89390 size=80
    let mut pc: u32 = 0x82E89390;
    'dispatch: loop {
        match pc {
            0x82E89390 => {
    //   block [0x82E89390..0x82E893E0)
	// 82E89390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89394: 4831EDD9  bl 0x831a816c
	ctx.lr = 0x82E89398;
	sub_831A8130(ctx, base);
	// 82E89398: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E8939C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E893A0: 83C3010C  lwz r30, 0x10c(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E893A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E893A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E893AC: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E893B0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E893B4: 419A0020  beq cr6, 0x82e893d4
	if ctx.cr[6].eq {
	pc = 0x82E893D4; continue 'dispatch;
	}
	// 82E893B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E893BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E893C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E893C4: 4BFF47E5  bl 0x82e7dba8
	ctx.lr = 0x82E893C8;
	sub_82E7DBA8(ctx, base);
	// 82E893C8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E893CC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E893D0: 409AFFE8  bne cr6, 0x82e893b8
	if !ctx.cr[6].eq {
	pc = 0x82E893B8; continue 'dispatch;
	}
	// 82E893D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E893D8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E893DC: 4831EDE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E893E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E893E0 size=360
    let mut pc: u32 = 0x82E893E0;
    'dispatch: loop {
        match pc {
            0x82E893E0 => {
    //   block [0x82E893E0..0x82E89548)
	// 82E893E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E893E4: 4831ED7D  bl 0x831a8160
	ctx.lr = 0x82E893E8;
	sub_831A8130(ctx, base);
	// 82E893E8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 82E893EC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82E893F0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82E893F4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E893F8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E893FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E89400: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E89404: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82E89408: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E8940C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E89410: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89414: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E89418: 40980008  bge cr6, 0x82e89420
	if !ctx.cr[6].lt {
	pc = 0x82E89420; continue 'dispatch;
	}
	// 82E8941C: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82E89420: 817E00FC  lwz r11, 0xfc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 82E89424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89428: 419A010C  beq cr6, 0x82e89534
	if ctx.cr[6].eq {
	pc = 0x82E89534; continue 'dispatch;
	}
	// 82E8942C: 813E0024  lwz r9, 0x24(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E89430: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82E89434: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E89438: 839E010C  lwz r28, 0x10c(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8943C: C19E011C  lfs f12, 0x11c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E89440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E89444: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82E89448: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8944C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82E89450: C00ADFB0  lfs f0, -0x2050(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89454: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E89458: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8945C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E89460: EFC90332  fmuls f30, f9, f12
	ctx.f[30].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E89464: 41980008  blt cr6, 0x82e8946c
	if ctx.cr[6].lt {
	pc = 0x82E8946C; continue 'dispatch;
	}
	// 82E89468: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8946C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E89470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89474: 419A0068  beq cr6, 0x82e894dc
	if ctx.cr[6].eq {
	pc = 0x82E894DC; continue 'dispatch;
	}
	// 82E89478: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8947C: 419A00B8  beq cr6, 0x82e89534
	if ctx.cr[6].eq {
	pc = 0x82E89534; continue 'dispatch;
	}
	// 82E89480: FC00F65E  fctidz f0, f30
	ctx.f[0].s64 = if ctx.f[30].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[30].f64.trunc() as i64 };
	// 82E89484: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82E89488: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8948C: 807E00FC  lwz r3, 0xfc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 82E89490: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82E89494: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89498: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82E8949C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82E894A0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E894A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E894A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E894AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E894B0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E894B4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82E894B8: 4E800421  bctrl
	ctx.lr = 0x82E894BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E894BC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E894C0: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E894C4: 409AFFC8  bne cr6, 0x82e8948c
	if !ctx.cr[6].eq {
	pc = 0x82E8948C; continue 'dispatch;
	}
	// 82E894C8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E894CC: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82E894D0: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E894D4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E894D8: 4831ECD8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E894DC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E894E0: 419A0054  beq cr6, 0x82e89534
	if ctx.cr[6].eq {
	pc = 0x82E89534; continue 'dispatch;
	}
	// 82E894E4: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E894E8: C00600BC  lfs f0, 0xbc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E894EC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E894F0: 40990038  ble cr6, 0x82e89528
	if !ctx.cr[6].gt {
	pc = 0x82E89528; continue 'dispatch;
	}
	// 82E894F4: 807E00FC  lwz r3, 0xfc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 82E894F8: FC00F65E  fctidz f0, f30
	ctx.f[0].s64 = if ctx.f[30].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[30].f64.trunc() as i64 };
	// 82E894FC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82E89500: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E89504: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82E89508: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82E8950C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E89510: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E89514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E89518: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8951C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89520: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82E89524: 4E800421  bctrl
	ctx.lr = 0x82E89528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89528: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8952C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E89530: 409AFFB4  bne cr6, 0x82e894e4
	if !ctx.cr[6].eq {
	pc = 0x82E894E4; continue 'dispatch;
	}
	// 82E89534: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E89538: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82E8953C: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E89540: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E89544: 4831EC6C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89548 size=140
    let mut pc: u32 = 0x82E89548;
    'dispatch: loop {
        match pc {
            0x82E89548 => {
    //   block [0x82E89548..0x82E895D4)
	// 82E89548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8954C: 4831EC21  bl 0x831a816c
	ctx.lr = 0x82E89550;
	sub_831A8130(ctx, base);
	// 82E89550: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E89554: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89558: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8955C: 83A3010C  lwz r29, 0x10c(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E89560: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E89564: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E89568: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8956C: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89570: 814B0088  lwz r10, 0x88(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E89574: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E89578: 4E800421  bctrl
	ctx.lr = 0x82E8957C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8957C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E89580: 419A0038  beq cr6, 0x82e895b8
	if ctx.cr[6].eq {
	pc = 0x82E895B8; continue 'dispatch;
	}
	// 82E89584: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89588: 4BFF4539  bl 0x82e7dac0
	ctx.lr = 0x82E8958C;
	sub_82E7DAC0(ctx, base);
	// 82E8958C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E89590: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E89594: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89598: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8959C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E895A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E895A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E895A8: 4E800421  bctrl
	ctx.lr = 0x82E895AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E895AC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E895B0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E895B4: 409AFFD0  bne cr6, 0x82e89584
	if !ctx.cr[6].eq {
	pc = 0x82E89584; continue 'dispatch;
	}
	// 82E895B8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E895BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E895C0: 419A0008  beq cr6, 0x82e895c8
	if ctx.cr[6].eq {
	pc = 0x82E895C8; continue 'dispatch;
	}
	// 82E895C4: 4B4372CD  bl 0x822c0890
	ctx.lr = 0x82E895C8;
	sub_822C0890(ctx, base);
	// 82E895C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E895CC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E895D0: 4831EBEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E895D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E895D8 size=428
    let mut pc: u32 = 0x82E895D8;
    'dispatch: loop {
        match pc {
            0x82E895D8 => {
    //   block [0x82E895D8..0x82E89784)
	// 82E895D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E895DC: 4831EB91  bl 0x831a816c
	ctx.lr = 0x82E895E0;
	sub_831A8130(ctx, base);
	// 82E895E0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82E895E4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E895E8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E895EC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E895F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E895F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E895F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E895FC: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E89600: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E89604: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E89608: 4E800421  bctrl
	ctx.lr = 0x82E8960C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8960C: 80DF0104  lwz r6, 0x104(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82E89610: 80BF00F0  lwz r5, 0xf0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82E89614: 83BF00F4  lwz r29, 0xf4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82E89618: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8961C: 419A0024  beq cr6, 0x82e89640
	if ctx.cr[6].eq {
	pc = 0x82E89640; continue 'dispatch;
	}
	// 82E89620: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82E89624: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E89628: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8962C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E89630: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E89634: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E89638: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8963C: 4082FFE8  bne 0x82e89624
	if !ctx.cr[0].eq {
	pc = 0x82E89624; continue 'dispatch;
	}
	// 82E89640: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E89644: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E89648: 811F0028  lwz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E8964C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89650: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89654: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89658: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8965C: 4E800421  bctrl
	ctx.lr = 0x82E89660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89660: C1BF0144  lfs f13, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89664: ED8D0372  fmuls f12, f13, f13
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E89668: C17F0140  lfs f11, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8966C: C15F0148  lfs f10, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E89670: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82E89674: 3BDF0140  addi r30, r31, 0x140
	ctx.r[30].s64 = ctx.r[31].s64 + 320;
	// 82E89678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8967C: C009DFB0  lfs f0, -0x2050(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89680: ED2B62FA  fmadds f9, f11, f11, f12
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E89684: ED0A4ABA  fmadds f8, f10, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64);
	// 82E89688: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82E8968C: 41980008  blt cr6, 0x82e89694
	if ctx.cr[6].lt {
	pc = 0x82E89694; continue 'dispatch;
	}
	// 82E89690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E89698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8969C: 409A00B8  bne cr6, 0x82e89754
	if !ctx.cr[6].eq {
	pc = 0x82E89754; continue 'dispatch;
	}
	// 82E896A0: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 82E896A4: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E896A8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E896AC: C1BF0194  lfs f13, 0x194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E896B0: C19F0198  lfs f12, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E896B4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82E896B8: C17F019C  lfs f11, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E896BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E896C0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E896C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E896C8: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E896CC: 397F0190  addi r11, r31, 0x190
	ctx.r[11].s64 = ctx.r[31].s64 + 400;
	// 82E896D0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E896D4: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E896D8: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E89788 size=312
    let mut pc: u32 = 0x82E89788;
    'dispatch: loop {
        match pc {
            0x82E89788 => {
    //   block [0x82E89788..0x82E898C0)
	// 82E89788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8978C: 4831E9D9  bl 0x831a8164
	ctx.lr = 0x82E89790;
	sub_831A8130(ctx, base);
	// 82E89790: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82E89794: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E89798: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8979C: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E897A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E897A4: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82E897A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E897AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E897B0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E897B4: C1BE0120  lfs f13, 0x120(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E897B8: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E897BC: C3FE0030  lfs f31, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E897C0: ED8DF028  fsubs f12, f13, f30
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 82E897C4: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E897C8: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82E897CC: 419900E0  bgt cr6, 0x82e898ac
	if ctx.cr[6].gt {
	pc = 0x82E898AC; continue 'dispatch;
	}
	// 82E897D0: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E897D4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E897D8: 4099000C  ble cr6, 0x82e897e4
	if !ctx.cr[6].gt {
	pc = 0x82E897E4; continue 'dispatch;
	}
	// 82E897DC: 4BFFFC05  bl 0x82e893e0
	ctx.lr = 0x82E897E0;
	sub_82E893E0(ctx, base);
	// 82E897E0: 48000078  b 0x82e89858
	pc = 0x82E89858; continue 'dispatch;
	// 82E897E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E897E8: C00BC0AC  lfs f0, -0x3f54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E897EC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E897F0: 40980008  bge cr6, 0x82e897f8
	if !ctx.cr[6].lt {
	pc = 0x82E897F8; continue 'dispatch;
	}
	// 82E897F4: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82E897F8: FC006A10  fabs f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82E897FC: EC20F824  fdivs f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 82E89800: 48322299  bl 0x831aba98
	ctx.lr = 0x82E89804;
	sub_831ABA98(ctx, base);
	// 82E89804: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E89808: FD80681E  fctiwz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82E8980C: D9810050  stfd f12, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[12].u64 ) };
	// 82E89810: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E89814: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82E89818: 40990040  ble cr6, 0x82e89858
	if !ctx.cr[6].gt {
	pc = 0x82E89858; continue 'dispatch;
	}
	// 82E8981C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E89820: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 82E89824: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82E89828: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82E8982C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E89830: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E89834: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E89838: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8983C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E89840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89844: EC2C07F2  fmuls f1, f12, f31
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89848: 4BFFFB99  bl 0x82e893e0
	ctx.lr = 0x82E8984C;
	sub_82E893E0(ctx, base);
	// 82E8984C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E89850: 7F1FD800  cmpw cr6, r31, r27
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82E89854: 4198FFCC  blt cr6, 0x82e89820
	if ctx.cr[6].lt {
	pc = 0x82E89820; continue 'dispatch;
	}
	// 82E89858: C01E0030  lfs f0, 0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8985C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E89860: D01E0120  stfs f0, 0x120(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82E89864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89868: 4BFFF6C1  bl 0x82e88f28
	ctx.lr = 0x82E8986C;
	sub_82E88F28(ctx, base);
	// 82E8986C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E89870: 39400180  li r10, 0x180
	ctx.r[10].s64 = 384;
	// 82E89874: C1A10090  lfs f13, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89878: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8987C: C1610098  lfs f11, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E89880: C141009C  lfs f10, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E89884: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E89888: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8988C: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E89890: D141005C  stfs f10, 0x5c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E89894: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E898C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E898C0 size=380
    let mut pc: u32 = 0x82E898C0;
    'dispatch: loop {
        match pc {
            0x82E898C0 => {
    //   block [0x82E898C0..0x82E89A3C)
	// 82E898C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E898C4: 4831E8A9  bl 0x831a816c
	ctx.lr = 0x82E898C8;
	sub_831A8130(ctx, base);
	// 82E898C8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82E898CC: 4831F1AD  bl 0x831a8a78
	ctx.lr = 0x82E898D0;
	sub_831A8A40(ctx, base);
	// 82E898D0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E898D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E898D8: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82E898DC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E898E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E898E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E898E8: C3FF0124  lfs f31, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E898EC: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82E898F0: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E898F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E898F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E898FC: 41980008  blt cr6, 0x82e89904
	if ctx.cr[6].lt {
	pc = 0x82E89904; continue 'dispatch;
	}
	// 82E89900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89904: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E89908: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82E8990C: 5568063E  clrlwi r8, r11, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E89910: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E89914: C3AA08A4  lfs f29, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E89918: C3C9FB3C  lfs f30, -0x4c4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-1220 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E8991C: 409A0064  bne cr6, 0x82e89980
	if !ctx.cr[6].eq {
	pc = 0x82E89980; continue 'dispatch;
	}
	// 82E89920: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89924: C03F0008  lfs f1, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E89928: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8992C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E89930: 409A0028  bne cr6, 0x82e89958
	if !ctx.cr[6].eq {
	pc = 0x82E89958; continue 'dispatch;
	}
	// 82E89934: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E89938: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8993C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E89940: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E89944: 419A000C  beq cr6, 0x82e89950
	if ctx.cr[6].eq {
	pc = 0x82E89950; continue 'dispatch;
	}
	// 82E89948: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8994C: 48000010  b 0x82e8995c
	pc = 0x82E8995C; continue 'dispatch;
	// 82E89950: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E89954: 48000008  b 0x82e8995c
	pc = 0x82E8995C; continue 'dispatch;
	// 82E89958: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E8995C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E89960: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82E89964: 41990010  bgt cr6, 0x82e89974
	if ctx.cr[6].gt {
	pc = 0x82E89974; continue 'dispatch;
	}
	// 82E89968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8996C: 4BFF8705  bl 0x82e82070
	ctx.lr = 0x82E89970;
	sub_82E82070(ctx, base);
	// 82E89970: 48000010  b 0x82e89980
	pc = 0x82E89980; continue 'dispatch;
	// 82E89974: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89978: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E8997C: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E89980: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E89984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89988: 4BFFF5A1  bl 0x82e88f28
	ctx.lr = 0x82E8998C;
	sub_82E88F28(ctx, base);
	// 82E8998C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E89990: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89994: 39400160  li r10, 0x160
	ctx.r[10].s64 = 352;
	// 82E89998: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8999C: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E899A0: C161009C  lfs f11, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E899A4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E899A8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E899AC: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E899B0: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E899B4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89A40 size=148
    let mut pc: u32 = 0x82E89A40;
    'dispatch: loop {
        match pc {
            0x82E89A40 => {
    //   block [0x82E89A40..0x82E89AD4)
	// 82E89A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89A44: 4831E729  bl 0x831a816c
	ctx.lr = 0x82E89A48;
	sub_831A8130(ctx, base);
	// 82E89A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89A4C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E89A50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E89A54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E89A58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E89A5C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E89A60: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E89A64: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E89A68: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82E89A6C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E89A70: 4BF68659  bl 0x82df20c8
	ctx.lr = 0x82E89A74;
	sub_82DF20C8(ctx, base);
	// 82E89A74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E89A78: 419A0008  beq cr6, 0x82e89a80
	if ctx.cr[6].eq {
	pc = 0x82E89A80; continue 'dispatch;
	}
	// 82E89A7C: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E89A80: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89A84: 41820008  beq 0x82e89a8c
	if ctx.cr[0].eq {
	pc = 0x82E89A8C; continue 'dispatch;
	}
	// 82E89A88: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E89A8C: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89A90: 4182003C  beq 0x82e89acc
	if ctx.cr[0].eq {
	pc = 0x82E89ACC; continue 'dispatch;
	}
	// 82E89A94: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89A98: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E89A9C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89AA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E89AA4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E89AA8: 419A0024  beq cr6, 0x82e89acc
	if ctx.cr[6].eq {
	pc = 0x82E89ACC; continue 'dispatch;
	}
	// 82E89AAC: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82E89AB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E89AB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E89AB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E89ABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E89AC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E89AC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E89AC8: 4082FFE8  bne 0x82e89ab0
	if !ctx.cr[0].eq {
	pc = 0x82E89AB0; continue 'dispatch;
	}
	// 82E89ACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E89AD0: 4831E6EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89AD8 size=252
    let mut pc: u32 = 0x82E89AD8;
    'dispatch: loop {
        match pc {
            0x82E89AD8 => {
    //   block [0x82E89AD8..0x82E89BD4)
	// 82E89AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89ADC: 4831E68D  bl 0x831a8168
	ctx.lr = 0x82E89AE0;
	sub_831A8130(ctx, base);
	// 82E89AE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E89AE8: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82E89AEC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E89AF0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E89AF4: 4BF688CD  bl 0x82df23c0
	ctx.lr = 0x82E89AF8;
	sub_82DF23C0(ctx, base);
	// 82E89AF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E89AFC: 419A0010  beq cr6, 0x82e89b0c
	if ctx.cr[6].eq {
	pc = 0x82E89B0C; continue 'dispatch;
	}
	// 82E89B00: 480038A9  bl 0x82e8d3a8
	ctx.lr = 0x82E89B04;
	sub_82E8D3A8(ctx, base);
	// 82E89B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89B08: 48000008  b 0x82e89b10
	pc = 0x82E89B10; continue 'dispatch;
	// 82E89B0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E89B10: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82E89B14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89B18: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E89B1C: 4BFFF725  bl 0x82e89240
	ctx.lr = 0x82E89B20;
	sub_82E89240(ctx, base);
	// 82E89B20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E89B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89B28: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E89B2C: 4B4364D5  bl 0x822c0000
	ctx.lr = 0x82E89B30;
	sub_822C0000(ctx, base);
	// 82E89B30: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E89B34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89B38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E89B3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89B40: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89B44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E89B48: 4E800421  bctrl
	ctx.lr = 0x82E89B4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89B4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E89B50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E89B54: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82E89B58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89B5C: 3BFE00FC  addi r31, r30, 0xfc
	ctx.r[31].s64 = ctx.r[30].s64 + 252;
	// 82E89B60: 4BFFF6E1  bl 0x82e89240
	ctx.lr = 0x82E89B64;
	sub_82E89240(ctx, base);
	// 82E89B64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E89B68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89B6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E89B70: 4B436491  bl 0x822c0000
	ctx.lr = 0x82E89B74;
	sub_822C0000(ctx, base);
	// 82E89B74: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E89B78: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E89B7C: 913E00FC  stw r9, 0xfc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(252 as u32), ctx.r[9].u32 ) };
	// 82E89B80: 807E0100  lwz r3, 0x100(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) } as u64;
	// 82E89B84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E89B88: 911E0100  stw r8, 0x100(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[8].u32 ) };
	// 82E89B8C: 419A0008  beq cr6, 0x82e89b94
	if ctx.cr[6].eq {
	pc = 0x82E89B94; continue 'dispatch;
	}
	// 82E89B90: 4B436D01  bl 0x822c0890
	ctx.lr = 0x82E89B94;
	sub_822C0890(ctx, base);
	// 82E89B94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89B98: 38DE00A0  addi r6, r30, 0xa0
	ctx.r[6].s64 = ctx.r[30].s64 + 160;
	// 82E89B9C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E89BA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E89BA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89BA8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89BAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E89BB0: 4E800421  bctrl
	ctx.lr = 0x82E89BB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89BB4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E89BB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E89BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E89BC0: 993E0128  stb r9, 0x128(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(296 as u32), ctx.r[9].u8 ) };
	// 82E89BC4: 419A0008  beq cr6, 0x82e89bcc
	if ctx.cr[6].eq {
	pc = 0x82E89BCC; continue 'dispatch;
	}
	// 82E89BC8: 4B436CC9  bl 0x822c0890
	ctx.lr = 0x82E89BCC;
	sub_822C0890(ctx, base);
	// 82E89BCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E89BD0: 4831E5E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E89BD8 size=620
    let mut pc: u32 = 0x82E89BD8;
    'dispatch: loop {
        match pc {
            0x82E89BD8 => {
    //   block [0x82E89BD8..0x82E89E44)
	// 82E89BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89BDC: 4831E591  bl 0x831a816c
	ctx.lr = 0x82E89BE0;
	sub_831A8130(ctx, base);
	// 82E89BE0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82E89BE4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E89BE8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89BEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89BF0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E89BF4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E89BF8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82E89BFC: 4BFF83AD  bl 0x82e81fa8
	ctx.lr = 0x82E89C00;
	sub_82E81FA8(ctx, base);
	// 82E89C00: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E89C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89C08: 409A022C  bne cr6, 0x82e89e34
	if !ctx.cr[6].eq {
	pc = 0x82E89E34; continue 'dispatch;
	}
	// 82E89C0C: 897F0128  lbz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82E89C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89C14: 419A0014  beq cr6, 0x82e89c28
	if ctx.cr[6].eq {
	pc = 0x82E89C28; continue 'dispatch;
	}
	// 82E89C18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89C1C: 80BF0090  lwz r5, 0x90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E89C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89C24: 4BFFFEB5  bl 0x82e89ad8
	ctx.lr = 0x82E89C28;
	sub_82E89AD8(ctx, base);
	// 82E89C28: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89C2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89C30: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E89C34: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E89C38: 4BFF8389  bl 0x82e81fc0
	ctx.lr = 0x82E89C3C;
	sub_82E81FC0(ctx, base);
	// 82E89C3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E89C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89C44: 409A01E0  bne cr6, 0x82e89e24
	if !ctx.cr[6].eq {
	pc = 0x82E89E24; continue 'dispatch;
	}
	// 82E89C48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E89C4C: C1BF0004  lfs f13, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89C50: C00B17A0  lfs f0, 0x17a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89C54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E89C58: 41990054  bgt cr6, 0x82e89cac
	if ctx.cr[6].gt {
	pc = 0x82E89CAC; continue 'dispatch;
	}
	// 82E89C5C: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E89C60: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82E89C64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89C68: 419A009C  beq cr6, 0x82e89d04
	if ctx.cr[6].eq {
	pc = 0x82E89D04; continue 'dispatch;
	}
	// 82E89C6C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82E89C70: 419A0094  beq cr6, 0x82e89d04
	if ctx.cr[6].eq {
	pc = 0x82E89D04; continue 'dispatch;
	}
	// 82E89C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89C78: 4BFF82F9  bl 0x82e81f70
	ctx.lr = 0x82E89C7C;
	sub_82E81F70(ctx, base);
	// 82E89C7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E89C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89C84: 419A0080  beq cr6, 0x82e89d04
	if ctx.cr[6].eq {
	pc = 0x82E89D04; continue 'dispatch;
	}
	// 82E89C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89C8C: C03F0008  lfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E89C90: 4BFF8269  bl 0x82e81ef8
	ctx.lr = 0x82E89C94;
	sub_82E81EF8(ctx, base);
	// 82E89C94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89CA0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E89CA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E89CA8: 4E800421  bctrl
	ctx.lr = 0x82E89CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89CB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E89CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89CB8: 897F012A  lbz r11, 0x12a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(298 as u32) ) } as u64;
	// 82E89CBC: 409A008C  bne cr6, 0x82e89d48
	if !ctx.cr[6].eq {
	pc = 0x82E89D48; continue 'dispatch;
	}
	// 82E89CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89CC4: 409A008C  bne cr6, 0x82e89d50
	if !ctx.cr[6].eq {
	pc = 0x82E89D50; continue 'dispatch;
	}
	// 82E89CC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89CCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E89CD0: 55690000  rlwinm r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E89CD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E89CD8: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E89CDC: 409A003C  bne cr6, 0x82e89d18
	if !ctx.cr[6].eq {
	pc = 0x82E89D18; continue 'dispatch;
	}
	// 82E89CE0: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E89CE4: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89CE8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E89CEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E89CF0: 419A001C  beq cr6, 0x82e89d0c
	if ctx.cr[6].eq {
	pc = 0x82E89D0C; continue 'dispatch;
	}
	// 82E89CF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E89CF8: C00BFB3C  lfs f0, -0x4c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89CFC: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E89D00: 4800001C  b 0x82e89d1c
	pc = 0x82E89D1C; continue 'dispatch;
	// 82E89D04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E89D08: 4BFFFFA8  b 0x82e89cb0
	pc = 0x82E89CB0; continue 'dispatch;
	// 82E89D0C: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89D10: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E89D14: 48000008  b 0x82e89d1c
	pc = 0x82E89D1C; continue 'dispatch;
	// 82E89D18: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82E89D1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89D20: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82E89D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89D28: 4BFFF8B1  bl 0x82e895d8
	ctx.lr = 0x82E89D2C;
	sub_82E895D8(ctx, base);
	// 82E89D2C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82E89D30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89D34: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82E89D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89D3C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82E89D40: 4BFFFA49  bl 0x82e89788
	ctx.lr = 0x82E89D44;
	sub_82E89788(ctx, base);
	// 82E89D44: 480000E0  b 0x82e89e24
	pc = 0x82E89E24; continue 'dispatch;
	// 82E89D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89D4C: 419A001C  beq cr6, 0x82e89d68
	if ctx.cr[6].eq {
	pc = 0x82E89D68; continue 'dispatch;
	}
	// 82E89D50: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E89D54: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E89D58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89D60: 4BFFFB61  bl 0x82e898c0
	ctx.lr = 0x82E89D64;
	sub_82E898C0(ctx, base);
	// 82E89D64: 480000C0  b 0x82e89e24
	pc = 0x82E89E24; continue 'dispatch;
	// 82E89D68: C01F0144  lfs f0, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89D6C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E89D70: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E89D74: C19F0140  lfs f12, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E89D78: C17F0148  lfs f11, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E89D7C: 3BDF0140  addi r30, r31, 0x140
	ctx.r[30].s64 = ctx.r[31].s64 + 320;
	// 82E89D80: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89D84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E89D88: ED4C6B3A  fmadds f10, f12, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E89D8C: ED2B52FA  fmadds f9, f11, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E89D90: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82E89D94: 41980008  blt cr6, 0x82e89d9c
	if ctx.cr[6].lt {
	pc = 0x82E89D9C; continue 'dispatch;
	}
	// 82E89D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89D9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E89DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89DA4: 409A0080  bne cr6, 0x82e89e24
	if !ctx.cr[6].eq {
	pc = 0x82E89E24; continue 'dispatch;
	}
	// 82E89DA8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E89DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89DB0: 4BFFF0A1  bl 0x82e88e50
	ctx.lr = 0x82E89DB4;
	sub_82E88E50(ctx, base);
	// 82E89DB4: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89DB8: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E89DBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E89DC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E89DC4: C3CBCEE4  lfs f30, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E89DC8: EC2D07B2  fmuls f1, f13, f30
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E89DCC: 4BFF25D5  bl 0x82e7c3a0
	ctx.lr = 0x82E89DD0;
	sub_82E7C3A0(ctx, base);
	// 82E89DD0: C19F0144  lfs f12, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E89DD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E89DD8: ED6C07F2  fmuls f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89DDC: EC2B07B2  fmuls f1, f11, f30
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E89DE0: 4BFF26C1  bl 0x82e7c4a0
	ctx.lr = 0x82E89DE4;
	sub_82E7C4A0(ctx, base);
	// 82E89DE4: C15F0148  lfs f10, 0x148(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E89DE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E89DEC: ED2A07F2  fmuls f9, f10, f31
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89DF0: EC2907B2  fmuls f1, f9, f30
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E89DF4: 4BFF27AD  bl 0x82e7c5a0
	ctx.lr = 0x82E89DF8;
	sub_82E7C5A0(ctx, base);
	// 82E89DF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E89DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E89E00: 4BFF3009  bl 0x82e7ce08
	ctx.lr = 0x82E89E04;
	sub_82E7CE08(ctx, base);
	// 82E89E04: C1030000  lfs f8, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E89E08: D11F0190  stfs f8, 0x190(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82E89E0C: C0E30004  lfs f7, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E89E10: D0FF0194  stfs f7, 0x194(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82E89E14: C0C30008  lfs f6, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E89E18: D0DF0198  stfs f6, 0x198(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82E89E1C: C0A3000C  lfs f5, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E89E20: D0BF019C  stfs f5, 0x19c(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82E89E24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89E28: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E89E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89E30: 4BFFF719  bl 0x82e89548
	ctx.lr = 0x82E89E34;
	sub_82E89548(ctx, base);
	// 82E89E34: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E89E38: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E89E3C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E89E40: 4831E37C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E89E48 size=432
    let mut pc: u32 = 0x82E89E48;
    'dispatch: loop {
        match pc {
            0x82E89E48 => {
    //   block [0x82E89E48..0x82E89FF8)
	// 82E89E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89E4C: 4831E321  bl 0x831a816c
	ctx.lr = 0x82E89E50;
	sub_831A8130(ctx, base);
	// 82E89E50: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82E89E54: 4831EC25  bl 0x831a8a78
	ctx.lr = 0x82E89E58;
	sub_831A8A40(ctx, base);
	// 82E89E58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89E60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E89E64: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82E89E68: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82E89E6C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E89E70: 4BFFF241  bl 0x82e890b0
	ctx.lr = 0x82E89E74;
	sub_82E890B0(ctx, base);
	// 82E89E74: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 82E89E78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89E7C: 4BFFF30D  bl 0x82e89188
	ctx.lr = 0x82E89E80;
	sub_82E89188(ctx, base);
	// 82E89E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89E84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E89E88: 80BF0090  lwz r5, 0x90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E89E8C: 4BFFFC4D  bl 0x82e89ad8
	ctx.lr = 0x82E89E90;
	sub_82E89AD8(ctx, base);
	// 82E89E90: 48321E39  bl 0x831abcc8
	ctx.lr = 0x82E89E94;
	sub_831ABCC8(ctx, base);
	// 82E89E94: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E89E98: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E89E9C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E89EA0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E89EA4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E89EA8: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E89EAC: C3EA4E28  lfs f31, 0x4e28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20008 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E89EB0: EFCC07F2  fmuls f30, f12, f31
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89EB4: 48321E15  bl 0x831abcc8
	ctx.lr = 0x82E89EB8;
	sub_831ABCC8(ctx, base);
	// 82E89EB8: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 82E89EBC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82E89EC0: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E89EC4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82E89EC8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E89ECC: EFA907F2  fmuls f29, f9, f31
	ctx.f[29].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89ED0: 48321DF9  bl 0x831abcc8
	ctx.lr = 0x82E89ED4;
	sub_831ABCC8(ctx, base);
	// 82E89ED4: 7C6807B4  extsw r8, r3
	ctx.r[8].s64 = ctx.r[3].s32 as i64;
	// 82E89ED8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82E89EDC: C9010050  lfd f8, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E89EE0: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82E89EE4: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82E89EE8: EF8607F2  fmuls f28, f6, f31
	ctx.f[28].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89EEC: 48321DDD  bl 0x831abcc8
	ctx.lr = 0x82E89EF0;
	sub_831ABCC8(ctx, base);
	// 82E89EF0: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 82E89EF4: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82E89EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E89EFC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82E89F00: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82E89F04: C8A10050  lfd f5, 0x50(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E89F08: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82E89F0C: FC002018  frsp f0, f4
	ctx.f[0].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82E89F10: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82E89F14: EC8007F2  fmuls f4, f0, f31
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E89F18: 480035E9  bl 0x82e8d500
	ctx.lr = 0x82E89F1C;
	sub_82E8D500(ctx, base);
	// 82E89F1C: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89F20: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 82E89F24: 38A00150  li r5, 0x150
	ctx.r[5].s64 = 336;
	// 82E89F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89F2C: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 82E89F30: 90DF0104  stw r6, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[6].u32 ) };
	// 82E89F34: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89FF8 size=160
    let mut pc: u32 = 0x82E89FF8;
    'dispatch: loop {
        match pc {
            0x82E89FF8 => {
    //   block [0x82E89FF8..0x82E8A098)
	// 82E89FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A008: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A00C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A010: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82E8A014: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A018: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82E8A01C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A020: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82E8A024: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E8A028: 4098004C  bge cr6, 0x82e8a074
	if !ctx.cr[6].lt {
	pc = 0x82E8A074; continue 'dispatch;
	}
	// 82E8A02C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E8A030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A034: 388B960C  addi r4, r11, -0x69f4
	ctx.r[4].s64 = ctx.r[11].s64 + -27124;
	// 82E8A038: 4B43B891  bl 0x822c58c8
	ctx.lr = 0x82E8A03C;
	sub_822C58C8(ctx, base);
	// 82E8A03C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8A040: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E8A044: 4B43B7D5  bl 0x822c5818
	ctx.lr = 0x82E8A048;
	sub_822C5818(ctx, base);
	// 82E8A048: 4B43A269  bl 0x822c42b0
	ctx.lr = 0x82E8A04C;
	sub_822C42B0(ctx, base);
	// 82E8A04C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82E8A050: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E8A054: 392A94A0  addi r9, r10, -0x6b60
	ctx.r[9].s64 = ctx.r[10].s64 + -27488;
	// 82E8A058: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82E8A05C: 4B43B415  bl 0x822c5470
	ctx.lr = 0x82E8A060;
	sub_822C5470(ctx, base);
	// 82E8A060: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E8A064: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82E8A068: 4198000C  blt cr6, 0x82e8a074
	if ctx.cr[6].lt {
	pc = 0x82E8A074; continue 'dispatch;
	}
	// 82E8A06C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8A070: 4B4361F9  bl 0x822c0268
	ctx.lr = 0x82E8A074;
	sub_822C0268(ctx, base);
	// 82E8A074: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A078: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E8A07C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8A080: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8A084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A08C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A098 size=140
    let mut pc: u32 = 0x82E8A098;
    'dispatch: loop {
        match pc {
            0x82E8A098 => {
    //   block [0x82E8A098..0x82E8A124)
	// 82E8A098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A0A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A0A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A0A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A0AC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A0B0: 387F0108  addi r3, r31, 0x108
	ctx.r[3].s64 = ctx.r[31].s64 + 264;
	// 82E8A0B4: 394BE190  addi r10, r11, -0x1e70
	ctx.r[10].s64 = ctx.r[11].s64 + -7792;
	// 82E8A0B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A0BC: 4BFF3CC5  bl 0x82e7dd80
	ctx.lr = 0x82E8A0C0;
	sub_82E7DD80(ctx, base);
	// 82E8A0C0: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82E8A0C4: 809F010C  lwz r4, 0x10c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8A0C8: 8069110C  lwz r3, 0x110c(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8A0CC: 4BF680BD  bl 0x82df2188
	ctx.lr = 0x82E8A0D0;
	sub_82DF2188(ctx, base);
	// 82E8A0D0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E8A0D4: 911F010C  stw r8, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[8].u32 ) };
	// 82E8A0D8: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82E8A0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A0E0: 419A0008  beq cr6, 0x82e8a0e8
	if ctx.cr[6].eq {
	pc = 0x82E8A0E8; continue 'dispatch;
	}
	// 82E8A0E4: 4B4367AD  bl 0x822c0890
	ctx.lr = 0x82E8A0E8;
	sub_822C0890(ctx, base);
	// 82E8A0E8: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82E8A0EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A0F0: 419A0008  beq cr6, 0x82e8a0f8
	if ctx.cr[6].eq {
	pc = 0x82E8A0F8; continue 'dispatch;
	}
	// 82E8A0F4: 4B43679D  bl 0x822c0890
	ctx.lr = 0x82E8A0F8;
	sub_822C0890(ctx, base);
	// 82E8A0F8: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 82E8A0FC: 4BF6932D  bl 0x82df3428
	ctx.lr = 0x82E8A100;
	sub_82DF3428(ctx, base);
	// 82E8A100: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 82E8A104: 4BF69325  bl 0x82df3428
	ctx.lr = 0x82E8A108;
	sub_82DF3428(ctx, base);
	// 82E8A108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A10C: 4BFF7DB5  bl 0x82e81ec0
	ctx.lr = 0x82E8A110;
	sub_82E81EC0(ctx, base);
	// 82E8A110: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A114: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A118: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A11C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A128 size=212
    let mut pc: u32 = 0x82E8A128;
    'dispatch: loop {
        match pc {
            0x82E8A128 => {
    //   block [0x82E8A128..0x82E8A1FC)
	// 82E8A128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A12C: 4831E029  bl 0x831a8154
	ctx.lr = 0x82E8A130;
	sub_831A8130(ctx, base);
	// 82E8A130: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A134: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8A138: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82E8A13C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82E8A140: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8A144: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E8A148: 419A00AC  beq cr6, 0x82e8a1f4
	if ctx.cr[6].eq {
	pc = 0x82E8A1F4; continue 'dispatch;
	}
	// 82E8A14C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8A150: 3F008335  lis r24, -0x7ccb
	ctx.r[24].s64 = -2093678592;
	// 82E8A154: 3B2B08B0  addi r25, r11, 0x8b0
	ctx.r[25].s64 = ctx.r[11].s64 + 2224;
	// 82E8A158: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8A15C: 8078110C  lwz r3, 0x110c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8A160: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E8A164: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A168: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E8A16C: 4BF67F5D  bl 0x82df20c8
	ctx.lr = 0x82E8A170;
	sub_82DF20C8(ctx, base);
	// 82E8A170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A174: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8A178: 419A0008  beq cr6, 0x82e8a180
	if ctx.cr[6].eq {
	pc = 0x82E8A180; continue 'dispatch;
	}
	// 82E8A17C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82E8A180: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82E8A184: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8A188: 419A0008  beq cr6, 0x82e8a190
	if ctx.cr[6].eq {
	pc = 0x82E8A190; continue 'dispatch;
	}
	// 82E8A18C: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82E8A190: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A194: 4182003C  beq 0x82e8a1d0
	if ctx.cr[0].eq {
	pc = 0x82E8A1D0; continue 'dispatch;
	}
	// 82E8A198: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A19C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A1A0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8A1A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8A1A8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8A1AC: 419A0024  beq cr6, 0x82e8a1d0
	if ctx.cr[6].eq {
	pc = 0x82E8A1D0; continue 'dispatch;
	}
	// 82E8A1B0: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82E8A1B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E8A1B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8A1BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E8A1C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8A1C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E8A1C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8A1CC: 4082FFE8  bne 0x82e8a1b4
	if !ctx.cr[0].eq {
	pc = 0x82E8A1B4; continue 'dispatch;
	}
	// 82E8A1D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8A1D4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8A1D8: 4BFFFE21  bl 0x82e89ff8
	ctx.lr = 0x82E8A1DC;
	sub_82E89FF8(ctx, base);
	// 82E8A1DC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82E8A1E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A1E4: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E8A1E8: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A1EC: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E8A1F0: 409AFF68  bne cr6, 0x82e8a158
	if !ctx.cr[6].eq {
	pc = 0x82E8A158; continue 'dispatch;
	}
	// 82E8A1F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8A1F8: 4831DFAC  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8A200 size=336
    let mut pc: u32 = 0x82E8A200;
    'dispatch: loop {
        match pc {
            0x82E8A200 => {
    //   block [0x82E8A200..0x82E8A350)
	// 82E8A200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A204: 4831DF69  bl 0x831a816c
	ctx.lr = 0x82E8A208;
	sub_831A8130(ctx, base);
	// 82E8A208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A20C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A210: 4BFF7C79  bl 0x82e81e88
	ctx.lr = 0x82E8A214;
	sub_82E81E88(ctx, base);
	// 82E8A214: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A218: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82E8A21C: 394BE190  addi r10, r11, -0x1e70
	ctx.r[10].s64 = ctx.r[11].s64 + -7792;
	// 82E8A220: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A224: 4B947385  bl 0x827d15a8
	ctx.lr = 0x82E8A228;
	sub_827D15A8(ctx, base);
	// 82E8A228: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 82E8A22C: 4BF68EC5  bl 0x82df30f0
	ctx.lr = 0x82E8A230;
	sub_82DF30F0(ctx, base);
	// 82E8A230: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8A234: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82E8A238: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82E8A23C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82E8A240: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 82E8A244: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E8A248: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 82E8A24C: 388808B0  addi r4, r8, 0x8b0
	ctx.r[4].s64 = ctx.r[8].s64 + 2224;
	// 82E8A250: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 82E8A254: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E8A258: 8069110C  lwz r3, 0x110c(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8A25C: 3BBF0108  addi r29, r31, 0x108
	ctx.r[29].s64 = ctx.r[31].s64 + 264;
	// 82E8A260: 4BF67E69  bl 0x82df20c8
	ctx.lr = 0x82E8A264;
	sub_82DF20C8(ctx, base);
	// 82E8A264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A268: 419A0008  beq cr6, 0x82e8a270
	if ctx.cr[6].eq {
	pc = 0x82E8A270; continue 'dispatch;
	}
	// 82E8A26C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E8A270: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A274: 41820008  beq 0x82e8a27c
	if ctx.cr[0].eq {
	pc = 0x82E8A27C; continue 'dispatch;
	}
	// 82E8A278: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82E8A27C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8A280: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82E8A284: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8A288: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8A28C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82E8A290: 9BDF0128  stb r30, 0x128(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u8 ) };
	// 82E8A294: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
	// 82E8A298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8A29C: 38C76910  addi r6, r7, 0x6910
	ctx.r[6].s64 = ctx.r[7].s64 + 26896;
	// 82E8A2A0: C1AA08A4  lfs f13, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8A2A4: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8A2A8: 997F0129  stb r11, 0x129(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(297 as u32), ctx.r[11].u8 ) };
	// 82E8A2AC: C1889450  lfs f12, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8A2B0: 997F012A  stb r11, 0x12a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(298 as u32), ctx.r[11].u8 ) };
	// 82E8A2B4: D1BF0114  stfs f13, 0x114(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82E8A2B8: 38A00140  li r5, 0x140
	ctx.r[5].s64 = 320;
	// 82E8A2BC: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82E8A2C0: 38800150  li r4, 0x150
	ctx.r[4].s64 = 336;
	// 82E8A2C4: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82E8A2C8: 39600160  li r11, 0x160
	ctx.r[11].s64 = 352;
	// 82E8A2CC: D19F0120  stfs f12, 0x120(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82E8A2D0: 39400170  li r10, 0x170
	ctx.r[10].s64 = 368;
	// 82E8A2D4: D1BF0124  stfs f13, 0x124(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82E8A2D8: 39200180  li r9, 0x180
	ctx.r[9].s64 = 384;
	// 82E8A2DC: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82E8A2E0: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 82E8A2E4: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82E8A2E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8A2EC: D01F0138  stfs f0, 0x138(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82E8A2F0: 38E8BA80  addi r7, r8, -0x4580
	ctx.r[7].s64 = ctx.r[8].s64 + -17792;
	// 82E8A2F4: D1BF013C  stfs f13, 0x13c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82E8A2F8: 13E030C7  vcmpequd (lvx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A350 size=80
    let mut pc: u32 = 0x82E8A350;
    'dispatch: loop {
        match pc {
            0x82E8A350 => {
    //   block [0x82E8A350..0x82E8A3A0)
	// 82E8A350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A35C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A368: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A36C: 4BFFFD2D  bl 0x82e8a098
	ctx.lr = 0x82E8A370;
	sub_82E8A098(ctx, base);
	// 82E8A370: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8A374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8A37C: 419A000C  beq cr6, 0x82e8a388
	if ctx.cr[6].eq {
	pc = 0x82E8A388; continue 'dispatch;
	}
	// 82E8A380: 4BF68059  bl 0x82df23d8
	ctx.lr = 0x82E8A384;
	sub_82DF23D8(ctx, base);
	// 82E8A384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A388: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A38C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A394: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A398: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A3A0 size=88
    let mut pc: u32 = 0x82E8A3A0;
    'dispatch: loop {
        match pc {
            0x82E8A3A0 => {
    //   block [0x82E8A3A0..0x82E8A3F8)
	// 82E8A3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A3A4: 4831DDC9  bl 0x831a816c
	ctx.lr = 0x82E8A3A8;
	sub_831A8130(ctx, base);
	// 82E8A3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A3AC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A3B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8A3B4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E8A3B8: 3BEB0108  addi r31, r11, 0x108
	ctx.r[31].s64 = ctx.r[11].s64 + 264;
	// 82E8A3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A3C0: 916A0174  stw r11, 0x174(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82E8A3C4: 83CB010C  lwz r30, 0x10c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8A3C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8A3CC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A3D0: 4BFFF671  bl 0x82e89a40
	ctx.lr = 0x82E8A3D4;
	sub_82E89A40(ctx, base);
	// 82E8A3D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8A3D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8A3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A3E0: 4BFFFC19  bl 0x82e89ff8
	ctx.lr = 0x82E8A3E4;
	sub_82E89FF8(ctx, base);
	// 82E8A3E4: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E8A3E8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A3EC: 93A90000  stw r29, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E8A3F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A3F4: 4831DDC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A3F8 size=148
    let mut pc: u32 = 0x82E8A3F8;
    'dispatch: loop {
        match pc {
            0x82E8A3F8 => {
    //   block [0x82E8A3F8..0x82E8A48C)
	// 82E8A3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A40C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E8A410: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8A414: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A418: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E8A41C: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82E8A420: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E8A424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A428: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8A42C: 4BF67C9D  bl 0x82df20c8
	ctx.lr = 0x82E8A430;
	sub_82DF20C8(ctx, base);
	// 82E8A430: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8A434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8A438: 419A0008  beq cr6, 0x82e8a440
	if ctx.cr[6].eq {
	pc = 0x82E8A440; continue 'dispatch;
	}
	// 82E8A43C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8A440: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8A444: 41820008  beq 0x82e8a44c
	if ctx.cr[0].eq {
	pc = 0x82E8A44C; continue 'dispatch;
	}
	// 82E8A448: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8A44C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8A450: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8A454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A458: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8A45C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E8A460: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A464: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A468: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A46C: 4BFFFCBD  bl 0x82e8a128
	ctx.lr = 0x82E8A470;
	sub_82E8A128(ctx, base);
	// 82E8A470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A47C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8A490 size=644
    let mut pc: u32 = 0x82E8A490;
    'dispatch: loop {
        match pc {
            0x82E8A490 => {
    //   block [0x82E8A490..0x82E8A714)
	// 82E8A490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A494: 4831DCD9  bl 0x831a816c
	ctx.lr = 0x82E8A498;
	sub_831A8130(ctx, base);
	// 82E8A498: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82E8A49C: 4831E5BD  bl 0x831a8a58
	ctx.lr = 0x82E8A4A0;
	sub_831A8A40(ctx, base);
	// 82E8A4A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A4A4: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82E8A4A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8A4B0: 419A0050  beq cr6, 0x82e8a500
	if ctx.cr[6].eq {
	pc = 0x82E8A500; continue 'dispatch;
	}
	// 82E8A4B4: 389F0108  addi r4, r31, 0x108
	ctx.r[4].s64 = ctx.r[31].s64 + 264;
	// 82E8A4B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A4BC: 4BFFFF3D  bl 0x82e8a3f8
	ctx.lr = 0x82E8A4C0;
	sub_82E8A3F8(ctx, base);
	// 82E8A4C0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8A4C4: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A4C8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E8A4CC: 419A001C  beq cr6, 0x82e8a4e8
	if ctx.cr[6].eq {
	pc = 0x82E8A4E8; continue 'dispatch;
	}
	// 82E8A4D0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A4D4: 386B0158  addi r3, r11, 0x158
	ctx.r[3].s64 = ctx.r[11].s64 + 344;
	// 82E8A4D8: 4BFF38A9  bl 0x82e7dd80
	ctx.lr = 0x82E8A4DC;
	sub_82E7DD80(ctx, base);
	// 82E8A4DC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A4E0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E8A4E4: 409AFFEC  bne cr6, 0x82e8a4d0
	if !ctx.cr[6].eq {
	pc = 0x82E8A4D0; continue 'dispatch;
	}
	// 82E8A4E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A4EC: 4BFF3895  bl 0x82e7dd80
	ctx.lr = 0x82E8A4F0;
	sub_82E7DD80(ctx, base);
	// 82E8A4F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E8A4F4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8A4F8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8A4FC: 4BF67C8D  bl 0x82df2188
	ctx.lr = 0x82E8A500;
	sub_82DF2188(ctx, base);
	// 82E8A500: 483217C9  bl 0x831abcc8
	ctx.lr = 0x82E8A504;
	sub_831ABCC8(ctx, base);
	// 82E8A504: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E8A508: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E8A50C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E8A510: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8A514: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E8A518: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E8A51C: C3EA4E28  lfs f31, 0x4e28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20008 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8A520: EFCC07F2  fmuls f30, f12, f31
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8A524: 483217A5  bl 0x831abcc8
	ctx.lr = 0x82E8A528;
	sub_831ABCC8(ctx, base);
	// 82E8A528: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 82E8A52C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82E8A530: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8A534: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82E8A538: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E8A53C: EFA907F2  fmuls f29, f9, f31
	ctx.f[29].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8A540: 48321789  bl 0x831abcc8
	ctx.lr = 0x82E8A544;
	sub_831ABCC8(ctx, base);
	// 82E8A544: 7C6807B4  extsw r8, r3
	ctx.r[8].s64 = ctx.r[3].s32 as i64;
	// 82E8A548: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82E8A54C: C9010050  lfd f8, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8A550: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82E8A554: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82E8A558: EF8607F2  fmuls f28, f6, f31
	ctx.f[28].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8A55C: 4832176D  bl 0x831abcc8
	ctx.lr = 0x82E8A560;
	sub_831ABCC8(ctx, base);
	// 82E8A560: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 82E8A564: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82E8A568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A56C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82E8A570: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82E8A574: C8A10050  lfd f5, 0x50(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8A578: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82E8A57C: FC002018  frsp f0, f4
	ctx.f[0].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82E8A580: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82E8A584: EC8007F2  fmuls f4, f0, f31
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8A588: 48002F79  bl 0x82e8d500
	ctx.lr = 0x82E8A58C;
	sub_82E8D500(ctx, base);
	// 82E8A58C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82E8A590: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 82E8A594: 38800150  li r4, 0x150
	ctx.r[4].s64 = 336;
	// 82E8A598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A59C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A5A0: 13FF28C7  vcmpequd (lvx128) v31, v31, v5
	tmp.u32 = ctx.r[31].u32 + ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8A5A4: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A718 size=132
    let mut pc: u32 = 0x82E8A718;
    'dispatch: loop {
        match pc {
            0x82E8A718 => {
    //   block [0x82E8A718..0x82E8A79C)
	// 82E8A718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A71C: 4831DA4D  bl 0x831a8168
	ctx.lr = 0x82E8A720;
	sub_831A8130(ctx, base);
	// 82E8A720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A728: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A72C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E8A730: 4BF689C1  bl 0x82df30f0
	ctx.lr = 0x82E8A734;
	sub_82DF30F0(ctx, base);
	// 82E8A734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A738: 4BF68CF9  bl 0x82df3430
	ctx.lr = 0x82E8A73C;
	sub_82DF3430(ctx, base);
	// 82E8A73C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E8A740: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8A744: 4BF68CED  bl 0x82df3430
	ctx.lr = 0x82E8A748;
	sub_82DF3430(ctx, base);
	// 82E8A748: 7D7C1A14  add r11, r28, r3
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 82E8A74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A750: 388B000A  addi r4, r11, 0xa
	ctx.r[4].s64 = ctx.r[11].s64 + 10;
	// 82E8A754: 4823D38D  bl 0x830c7ae0
	ctx.lr = 0x82E8A758;
	sub_830C7AE0(ctx, base);
	// 82E8A758: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A760: 388BE1A8  addi r4, r11, -0x1e58
	ctx.r[4].s64 = ctx.r[11].s64 + -7768;
	// 82E8A764: 4BF68E15  bl 0x82df3578
	ctx.lr = 0x82E8A768;
	sub_82DF3578(ctx, base);
	// 82E8A768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A76C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8A770: 4BF68F69  bl 0x82df36d8
	ctx.lr = 0x82E8A774;
	sub_82DF36D8(ctx, base);
	// 82E8A774: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82E8A778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A77C: 388A9FD8  addi r4, r10, -0x6028
	ctx.r[4].s64 = ctx.r[10].s64 + -24616;
	// 82E8A780: 4BF68DF9  bl 0x82df3578
	ctx.lr = 0x82E8A784;
	sub_82DF3578(ctx, base);
	// 82E8A784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A788: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8A78C: 4BF68F4D  bl 0x82df36d8
	ctx.lr = 0x82E8A790;
	sub_82DF36D8(ctx, base);
	// 82E8A790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A794: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8A798: 4831DA20  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A7A0 size=76
    let mut pc: u32 = 0x82E8A7A0;
    'dispatch: loop {
        match pc {
            0x82E8A7A0 => {
    //   block [0x82E8A7A0..0x82E8A7EC)
	// 82E8A7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A7B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A7B4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8A7B8: 48003011  bl 0x82e8d7c8
	ctx.lr = 0x82E8A7BC;
	sub_82E8D7C8(ctx, base);
	// 82E8A7BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A7C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8A7C4: 419A0010  beq cr6, 0x82e8a7d4
	if ctx.cr[6].eq {
	pc = 0x82E8A7D4; continue 'dispatch;
	}
	// 82E8A7C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8A7CC: 48002FDD  bl 0x82e8d7a8
	ctx.lr = 0x82E8A7D0;
	sub_82E8D7A8(ctx, base);
	// 82E8A7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A7D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A7E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A7E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8A7F0 size=16
    let mut pc: u32 = 0x82E8A7F0;
    'dispatch: loop {
        match pc {
            0x82E8A7F0 => {
    //   block [0x82E8A7F0..0x82E8A800)
	// 82E8A7F0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A7F4: 394BE1B4  addi r10, r11, -0x1e4c
	ctx.r[10].s64 = ctx.r[11].s64 + -7756;
	// 82E8A7F8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A7FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A800 size=236
    let mut pc: u32 = 0x82E8A800;
    'dispatch: loop {
        match pc {
            0x82E8A800 => {
    //   block [0x82E8A800..0x82E8A848)
	// 82E8A800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A808: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A80C: 2B040006  cmplwi cr6, r4, 6
	ctx.cr[6].compare_u32(ctx.r[4].u32, 6 as u32, &mut ctx.xer);
	// 82E8A810: 419900C8  bgt cr6, 0x82e8a8d8
	if ctx.cr[6].gt {
	pc = 0x82E8A8D8; continue 'dispatch;
	}
	// 82E8A814: 3D8082E9  lis r12, -0x7d17
	ctx.r[12].s64 = -2098659328;
	// 82E8A818: 398CA82C  addi r12, r12, -0x57d4
	ctx.r[12].s64 = ctx.r[12].s64 + -22484;
	// 82E8A81C: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82E8A820: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82E8A824: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82E8A828: 4E800420  bctr
	match ctx.r[4].u64 {
		0 => {
	pc = 0x82E8A848; continue 'dispatch;
		},
		1 => {
	pc = 0x82E8A848; continue 'dispatch;
		},
		2 => {
	pc = 0x82E8A86C; continue 'dispatch;
		},
		3 => {
	pc = 0x82E8A8D8; continue 'dispatch;
		},
		4 => {
	pc = 0x82E8A890; continue 'dispatch;
		},
		5 => {
	pc = 0x82E8A8B4; continue 'dispatch;
		},
		6 => {
	pc = 0x82E8A848; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82E8A82C: 82E8A848  lwz r23, -0x57b8(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22456 as u32) ) } as u64;
	// 82E8A830: 82E8A848  lwz r23, -0x57b8(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22456 as u32) ) } as u64;
	// 82E8A834: 82E8A86C  lwz r23, -0x5794(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22420 as u32) ) } as u64;
	// 82E8A838: 82E8A8D8  lwz r23, -0x5728(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22312 as u32) ) } as u64;
	// 82E8A83C: 82E8A890  lwz r23, -0x5770(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22384 as u32) ) } as u64;
	// 82E8A840: 82E8A8B4  lwz r23, -0x574c(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22348 as u32) ) } as u64;
	// 82E8A844: 82E8A848  lwz r23, -0x57b8(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22456 as u32) ) } as u64;
            }
            0x82E8A848 => {
    //   block [0x82E8A848..0x82E8A86C)
	// 82E8A848: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 82E8A84C: 4BF67B75  bl 0x82df23c0
	ctx.lr = 0x82E8A850;
	sub_82DF23C0(ctx, base);
	// 82E8A850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A854: 419A0084  beq cr6, 0x82e8a8d8
	if ctx.cr[6].eq {
	pc = 0x82E8A8D8; continue 'dispatch;
	}
	// 82E8A858: 48004969  bl 0x82e8f1c0
	ctx.lr = 0x82E8A85C;
	sub_82E8F1C0(ctx, base);
	// 82E8A85C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A868: 4E800020  blr
	return;
            }
            0x82E8A86C => {
    //   block [0x82E8A86C..0x82E8A890)
	// 82E8A86C: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82E8A870: 4BF67B51  bl 0x82df23c0
	ctx.lr = 0x82E8A874;
	sub_82DF23C0(ctx, base);
	// 82E8A874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A878: 419A0060  beq cr6, 0x82e8a8d8
	if ctx.cr[6].eq {
	pc = 0x82E8A8D8; continue 'dispatch;
	}
	// 82E8A87C: 480039CD  bl 0x82e8e248
	ctx.lr = 0x82E8A880;
	sub_82E8E248(ctx, base);
	// 82E8A880: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A88C: 4E800020  blr
	return;
            }
            0x82E8A890 => {
    //   block [0x82E8A890..0x82E8A8B4)
	// 82E8A890: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 82E8A894: 4BF67B2D  bl 0x82df23c0
	ctx.lr = 0x82E8A898;
	sub_82DF23C0(ctx, base);
	// 82E8A898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A89C: 419A003C  beq cr6, 0x82e8a8d8
	if ctx.cr[6].eq {
	pc = 0x82E8A8D8; continue 'dispatch;
	}
	// 82E8A8A0: 48003731  bl 0x82e8dfd0
	ctx.lr = 0x82E8A8A4;
	sub_82E8DFD0(ctx, base);
	// 82E8A8A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A8A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A8AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A8B0: 4E800020  blr
	return;
            }
            0x82E8A8B4 => {
    //   block [0x82E8A8B4..0x82E8A8D8)
	// 82E8A8B4: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82E8A8B8: 4BF67B09  bl 0x82df23c0
	ctx.lr = 0x82E8A8BC;
	sub_82DF23C0(ctx, base);
	// 82E8A8BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8A8C0: 419A0018  beq cr6, 0x82e8a8d8
	if ctx.cr[6].eq {
	pc = 0x82E8A8D8; continue 'dispatch;
	}
	// 82E8A8C4: 4800302D  bl 0x82e8d8f0
	ctx.lr = 0x82E8A8C8;
	sub_82E8D8F0(ctx, base);
	// 82E8A8C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A8CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A8D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A8D4: 4E800020  blr
	return;
            }
            0x82E8A8D8 => {
    //   block [0x82E8A8D8..0x82E8A8EC)
	// 82E8A8D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8A8DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A8E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A8E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A8F0 size=72
    let mut pc: u32 = 0x82E8A8F0;
    'dispatch: loop {
        match pc {
            0x82E8A8F0 => {
    //   block [0x82E8A8F0..0x82E8A938)
	// 82E8A8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A8F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A8FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A904: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A908: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82E8A90C: 392BE1B4  addi r9, r11, -0x1e4c
	ctx.r[9].s64 = ctx.r[11].s64 + -7756;
	// 82E8A910: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8A914: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8A918: 419A000C  beq cr6, 0x82e8a924
	if ctx.cr[6].eq {
	pc = 0x82E8A924; continue 'dispatch;
	}
	// 82E8A91C: 4BF67ABD  bl 0x82df23d8
	ctx.lr = 0x82E8A920;
	sub_82DF23D8(ctx, base);
	// 82E8A920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A924: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A92C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8A938 size=16
    let mut pc: u32 = 0x82E8A938;
    'dispatch: loop {
        match pc {
            0x82E8A938 => {
    //   block [0x82E8A938..0x82E8A948)
	// 82E8A938: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A93C: 394BE1BC  addi r10, r11, -0x1e44
	ctx.r[10].s64 = ctx.r[11].s64 + -7748;
	// 82E8A940: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A948 size=72
    let mut pc: u32 = 0x82E8A948;
    'dispatch: loop {
        match pc {
            0x82E8A948 => {
    //   block [0x82E8A948..0x82E8A990)
	// 82E8A948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A950: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A954: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A95C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8A960: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82E8A964: 392BE1BC  addi r9, r11, -0x1e44
	ctx.r[9].s64 = ctx.r[11].s64 + -7748;
	// 82E8A968: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8A96C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8A970: 419A000C  beq cr6, 0x82e8a97c
	if ctx.cr[6].eq {
	pc = 0x82E8A97C; continue 'dispatch;
	}
	// 82E8A974: 4BF67A65  bl 0x82df23d8
	ctx.lr = 0x82E8A978;
	sub_82DF23D8(ctx, base);
	// 82E8A978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A97C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8A990 size=320
    let mut pc: u32 = 0x82E8A990;
    'dispatch: loop {
        match pc {
            0x82E8A990 => {
    //   block [0x82E8A990..0x82E8AAD0)
	// 82E8A990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A994: 4831D7BD  bl 0x831a8150
	ctx.lr = 0x82E8A998;
	sub_831A8130(ctx, base);
	// 82E8A998: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82E8A99C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82E8A9A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A9A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E8A9A8: 90C1011C  stw r6, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[6].u32 ) };
	// 82E8A9AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8A9B0: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82E8A9B4: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 82E8A9B8: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8A9BC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8A9C0: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82E8A9C4: 41980010  blt cr6, 0x82e8a9d4
	if ctx.cr[6].lt {
	pc = 0x82E8A9D4; continue 'dispatch;
	}
	// 82E8A9C8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82E8A9CC: 41980008  blt cr6, 0x82e8a9d4
	if ctx.cr[6].lt {
	pc = 0x82E8A9D4; continue 'dispatch;
	}
	// 82E8A9D0: D03D0004  stfs f1, 4(r29)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8A9D4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8A9D8: 3B3D000C  addi r25, r29, 0xc
	ctx.r[25].s64 = ctx.r[29].s64 + 12;
	// 82E8A9DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8A9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8A9E4: 419A0010  beq cr6, 0x82e8a9f4
	if ctx.cr[6].eq {
	pc = 0x82E8A9F4; continue 'dispatch;
	}
	// 82E8A9E8: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A9EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E8A9F0: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E8A9F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A9F8: 409900C8  ble cr6, 0x82e8aac0
	if !ctx.cr[6].gt {
	pc = 0x82E8AAC0; continue 'dispatch;
	}
	// 82E8A9FC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82E8AA00: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82E8AA04: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82E8AA08: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 82E8AA0C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8AA10: C3C994AC  lfs f30, -0x6b54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E8AA14: 3B0B384C  addi r24, r11, 0x384c
	ctx.r[24].s64 = ctx.r[11].s64 + 14412;
	// 82E8AA18: 3B6A3854  addi r27, r10, 0x3854
	ctx.r[27].s64 = ctx.r[10].s64 + 14420;
	// 82E8AA1C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AA20: 7FFC582E  lwzx r31, r28, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8AA24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8AA28: 419A008C  beq cr6, 0x82e8aab4
	if ctx.cr[6].eq {
	pc = 0x82E8AAB4; continue 'dispatch;
	}
	// 82E8AA2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AA30: 7D6AB038  and r10, r11, r22
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[22].u64;
	// 82E8AA34: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8AA38: 419A007C  beq cr6, 0x82e8aab4
	if ctx.cr[6].eq {
	pc = 0x82E8AAB4; continue 'dispatch;
	}
	// 82E8AA3C: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82E8AA40: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8AA44: 3941011C  addi r10, r1, 0x11c
	ctx.r[10].s64 = ctx.r[1].s64 + 284;
	// 82E8AA48: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8AA4C: 557E07BE  clrlwi r30, r11, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82E8AA50: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8AA54: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E8AA58: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82E8AA5C: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E8AA60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8AA64: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E8AA68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8AA6C: C03D0004  lfs f1, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8AA70: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8AA74: 7D1E50AE  lbzx r8, r30, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8AA78: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82E8AA7C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8AA80: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E8AA84: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E8AA88: EC4C07B2  fmuls f2, f12, f30
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E8AA8C: 4BFFE1B5  bl 0x82e88c40
	ctx.lr = 0x82E8AA90;
	sub_82E88C40(ctx, base);
	// 82E8AA90: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AA94: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 82E8AA98: 21660012  subfic r11, r6, 0x12
	ctx.xer.ca = ctx.r[6].u32 <= 18 as u32;
	ctx.r[11].s64 = (18 as i64) - ctx.r[6].s64;
	// 82E8AA9C: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 82E8AAA0: 41990010  bgt cr6, 0x82e8aab0
	if ctx.cr[6].gt {
	pc = 0x82E8AAB0; continue 'dispatch;
	}
	// 82E8AAA4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8AAA8: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8AAAC: 7C0BBD2E  stfsx f0, r11, r23
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32), tmp.u32) };
	// 82E8AAB0: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 82E8AAB4: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82E8AAB8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82E8AABC: 4082FF60  bne 0x82e8aa1c
	if !ctx.cr[0].eq {
	pc = 0x82E8AA1C; continue 'dispatch;
	}
	// 82E8AAC0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82E8AAC4: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82E8AAC8: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82E8AACC: 4831D6D4  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8AAD0 size=144
    let mut pc: u32 = 0x82E8AAD0;
    'dispatch: loop {
        match pc {
            0x82E8AAD0 => {
    //   block [0x82E8AAD0..0x82E8AB60)
	// 82E8AAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8AAD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8AADC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E8AAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8AAE4: 788B0020  clrldi r11, r4, 0x20
	ctx.r[11].u64 = ctx.r[4].u64 & 0x00000000FFFFFFFFu64;
	// 82E8AAE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8AAEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E8AAF0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8AAF4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E8AAF8: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E8AAFC: 483211CD  bl 0x831abcc8
	ctx.lr = 0x82E8AB00;
	sub_831ABCC8(ctx, base);
	// 82E8AB00: 7BEA0020  clrldi r10, r31, 0x20
	ctx.r[10].u64 = ctx.r[31].u64 & 0x00000000FFFFFFFFu64;
	// 82E8AB04: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 82E8AB08: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E8AB0C: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8AB10: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82E8AB14: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8AB18: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82E8AB1C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82E8AB20: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82E8AB24: C0084E28  lfs f0, 0x4e28(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8AB28: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82E8AB2C: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E8AB30: ECA7F828  fsubs f5, f7, f31
	ctx.f[5].f64 = (((ctx.f[7].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E8AB34: ECC80032  fmuls f6, f8, f0
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8AB38: EC86F97A  fmadds f4, f6, f5, f31
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[5].f64 + ctx.f[31].f64) as f32) as f64);
	// 82E8AB3C: FC60265E  fctidz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[4].f64.trunc() as i64 };
	// 82E8AB40: D8610050  stfd f3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[3].u64 ) };
	// 82E8AB44: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8AB48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8AB4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8AB50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8AB54: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8AB58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8AB5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8AB60 size=240
    let mut pc: u32 = 0x82E8AB60;
    'dispatch: loop {
        match pc {
            0x82E8AB60 => {
    //   block [0x82E8AB60..0x82E8AC50)
	// 82E8AB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AB64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8AB68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8AB6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8AB70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8AB74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8AB78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E8AB7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8AB80: 4BFF28D1  bl 0x82e7d450
	ctx.lr = 0x82E8AB84;
	sub_82E7D450(ctx, base);
	// 82E8AB84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8AB88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E8AB8C: 4BFF28C5  bl 0x82e7d450
	ctx.lr = 0x82E8AB90;
	sub_82E7D450(ctx, base);
	// 82E8AB90: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82E8AB94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8AB98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AB9C: 4BFF2785  bl 0x82e7d320
	ctx.lr = 0x82E8ABA0;
	sub_82E7D320(ctx, base);
	// 82E8ABA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8ABA4: 4BFF28ED  bl 0x82e7d490
	ctx.lr = 0x82E8ABA8;
	sub_82E7D490(ctx, base);
	// 82E8ABA8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E8ABAC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82E8ABB0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82E8ABB4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82E8ABB8: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8ABBC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8AC50 size=44
    let mut pc: u32 = 0x82E8AC50;
    'dispatch: loop {
        match pc {
            0x82E8AC50 => {
    //   block [0x82E8AC50..0x82E8AC7C)
	// 82E8AC50: 816400A8  lwz r11, 0xa8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 82E8AC54: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 82E8AC58: 419A0038  beq cr6, 0x82e8ac90
	if ctx.cr[6].eq {
		sub_82E8AC90(ctx, base);
		return;
	}
	// 82E8AC5C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82E8AC60: 419A001C  beq cr6, 0x82e8ac7c
	if ctx.cr[6].eq {
		sub_82E8AC7C(ctx, base);
		return;
	}
	// 82E8AC64: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 82E8AC68: 409A0034  bne cr6, 0x82e8ac9c
	if !ctx.cr[6].eq {
		sub_82E8AC9C(ctx, base);
		return;
	}
	// 82E8AC6C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AC70: 4080002C  bge 0x82e8ac9c
	if !ctx.cr[0].lt {
		sub_82E8AC9C(ctx, base);
		return;
	}
	// 82E8AC74: 3866FFFF  addi r3, r6, -1
	ctx.r[3].s64 = ctx.r[6].s64 + -1;
	// 82E8AC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AC7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8AC7C size=20
    let mut pc: u32 = 0x82E8AC7C;
    'dispatch: loop {
        match pc {
            0x82E8AC7C => {
    //   block [0x82E8AC7C..0x82E8AC90)
	// 82E8AC7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8AC80: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82E8AC84: 41980018  blt cr6, 0x82e8ac9c
	if ctx.cr[6].lt {
		sub_82E8AC9C(ctx, base);
		return;
	}
	// 82E8AC88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8AC90 size=12
    let mut pc: u32 = 0x82E8AC90;
    'dispatch: loop {
        match pc {
            0x82E8AC90 => {
    //   block [0x82E8AC90..0x82E8AC9C)
	// 82E8AC90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8AC94: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82E8AC98: 4BFFFE38  b 0x82e8aad0
	sub_82E8AAD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AC9C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8AC9C size=8
    let mut pc: u32 = 0x82E8AC9C;
    'dispatch: loop {
        match pc {
            0x82E8AC9C => {
    //   block [0x82E8AC9C..0x82E8ACA4)
	// 82E8AC9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8ACA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8ACA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8ACA8 size=112
    let mut pc: u32 = 0x82E8ACA8;
    'dispatch: loop {
        match pc {
            0x82E8ACA8 => {
    //   block [0x82E8ACA8..0x82E8AD18)
	// 82E8ACA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8ACAC: 4831D4C1  bl 0x831a816c
	ctx.lr = 0x82E8ACB0;
	sub_831A8130(ctx, base);
	// 82E8ACB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8ACB4: 83C400B4  lwz r30, 0xb4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E8ACB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8ACBC: 806400B0  lwz r3, 0xb0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(176 as u32) ) } as u64;
	// 82E8ACC0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E8ACC4: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 82E8ACC8: 41980048  blt cr6, 0x82e8ad10
	if ctx.cr[6].lt {
	pc = 0x82E8AD10; continue 'dispatch;
	}
	// 82E8ACCC: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82E8ACD0: 41990040  bgt cr6, 0x82e8ad10
	if ctx.cr[6].gt {
	pc = 0x82E8AD10; continue 'dispatch;
	}
	// 82E8ACD4: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8ACD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8ACDC: EC001028  fsubs f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 82E8ACE0: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8ACE4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8ACE8: 40980024  bge cr6, 0x82e8ad0c
	if !ctx.cr[6].lt {
	pc = 0x82E8AD0C; continue 'dispatch;
	}
	// 82E8ACEC: 48004575  bl 0x82e8f260
	ctx.lr = 0x82E8ACF0;
	sub_82E8F260(ctx, base);
	// 82E8ACF0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82E8ACF4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8ACF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8ACFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8AD00: 4BFFFF51  bl 0x82e8ac50
	ctx.lr = 0x82E8AD04;
	sub_82E8AC50(ctx, base);
	// 82E8AD04: C01F008C  lfs f0, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8AD08: 907F00A8  stw r3, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 82E8AD0C: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E8AD10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8AD14: 4831D4A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8AD18 size=124
    let mut pc: u32 = 0x82E8AD18;
    'dispatch: loop {
        match pc {
            0x82E8AD18 => {
    //   block [0x82E8AD18..0x82E8AD94)
	// 82E8AD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AD1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8AD20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8AD24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8AD28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E8AD2C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8AD30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8AD34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E8AD38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8AD3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AD40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8AD44: 409A0018  bne cr6, 0x82e8ad5c
	if !ctx.cr[6].eq {
	pc = 0x82E8AD5C; continue 'dispatch;
	}
	// 82E8AD48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AD4C: 4B44888D  bl 0x822d35d8
	ctx.lr = 0x82E8AD50;
	sub_822D35D8(ctx, base);
	// 82E8AD50: 4B4352B1  bl 0x822c0000
	ctx.lr = 0x82E8AD54;
	sub_822C0000(ctx, base);
	// 82E8AD54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AD58: 4B447AB9  bl 0x822d2810
	ctx.lr = 0x82E8AD5C;
	sub_822D2810(ctx, base);
	// 82E8AD5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AD60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8AD64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8AD68: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82E8AD6C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AD70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8AD74: 4E800421  bctrl
	ctx.lr = 0x82E8AD78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8AD78: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8AD7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8AD80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8AD84: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E8AD88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8AD8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8AD90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8AD98 size=1400
    let mut pc: u32 = 0x82E8AD98;
    'dispatch: loop {
        match pc {
            0x82E8AD98 => {
    //   block [0x82E8AD98..0x82E8B310)
	// 82E8AD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AD9C: 4831D395  bl 0x831a8130
	ctx.lr = 0x82E8ADA0;
	sub_831A8130(ctx, base);
	// 82E8ADA0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82E8ADA4: 4831DC9D  bl 0x831a8a40
	ctx.lr = 0x82E8ADA8;
	sub_831A8A40(ctx, base);
	// 82E8ADA8: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8ADAC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E8ADB0: FDE00890  fmr f15, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[15].f64 = ctx.f[1].f64;
	// 82E8ADB4: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 82E8ADB8: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 82E8ADBC: 807D0140  lwz r3, 0x140(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(320 as u32) ) } as u64;
	// 82E8ADC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8ADC4: 419A0028  beq cr6, 0x82e8adec
	if ctx.cr[6].eq {
	pc = 0x82E8ADEC; continue 'dispatch;
	}
	// 82E8ADC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8ADCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8ADD0: 419A001C  beq cr6, 0x82e8adec
	if ctx.cr[6].eq {
	pc = 0x82E8ADEC; continue 'dispatch;
	}
	// 82E8ADD4: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 82E8ADD8: 396B7AE0  addi r11, r11, 0x7ae0
	ctx.r[11].s64 = ctx.r[11].s64 + 31456;
	// 82E8ADDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8ADE0: 419A000C  beq cr6, 0x82e8adec
	if ctx.cr[6].eq {
	pc = 0x82E8ADEC; continue 'dispatch;
	}
	// 82E8ADE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8ADE8: 4BFFFF31  bl 0x82e8ad18
	ctx.lr = 0x82E8ADEC;
	sub_82E8AD18(ctx, base);
	// 82E8ADEC: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 82E8ADF0: 837D00C8  lwz r27, 0xc8(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8ADF4: 3A200060  li r17, 0x60
	ctx.r[17].s64 = 96;
	// 82E8ADF8: C2DD0190  lfs f22, 0x190(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(400 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82E8ADFC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82E8AE00: 81DD00B4  lwz r14, 0xb4(r29)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E8AE04: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82E8AE08: 807D0174  lwz r3, 0x174(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 82E8AE0C: 5768B7FE  rlwinm r8, r27, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[27].u32 as u64 & 0x000003FFu64;
	// 82E8AE10: D2C10088  stfs f22, 0x88(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E8AE14: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82E8AE18: 13DD58C7  vcmpequd (lvx128) v30, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8AE1C: 13FD88C7  vcmpequd (lvx128) v31, v29, v17
	tmp.u32 = ctx.r[29].u32 + ctx.r[17].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8AE20: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B310 size=44
    let mut pc: u32 = 0x82E8B310;
    'dispatch: loop {
        match pc {
            0x82E8B310 => {
    //   block [0x82E8B310..0x82E8B33C)
	// 82E8B310: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82E8B314: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B318: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E8B31C: 41990040  bgt cr6, 0x82e8b35c
	if ctx.cr[6].gt {
		sub_82E8B35C(ctx, base);
		return;
	}
	// 82E8B320: 419A0034  beq cr6, 0x82e8b354
	if ctx.cr[6].eq {
		sub_82E8B354(ctx, base);
		return;
	}
	// 82E8B324: 2F052000  cmpwi cr6, r5, 0x2000
	ctx.cr[6].compare_i32(ctx.r[5].s32, 8192, &mut ctx.xer);
	// 82E8B328: 419A0024  beq cr6, 0x82e8b34c
	if ctx.cr[6].eq {
		sub_82E8B34C(ctx, base);
		return;
	}
	// 82E8B32C: 2F054000  cmpwi cr6, r5, 0x4000
	ctx.cr[6].compare_i32(ctx.r[5].s32, 16384, &mut ctx.xer);
	// 82E8B330: 419A0014  beq cr6, 0x82e8b344
	if ctx.cr[6].eq {
		sub_82E8B344(ctx, base);
		return;
	}
	// 82E8B334: 2B058000  cmplwi cr6, r5, 0x8000
	ctx.cr[6].compare_u32(ctx.r[5].u32, 32768 as u32, &mut ctx.xer);
	// 82E8B338: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B33C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B33C size=8
    let mut pc: u32 = 0x82E8B33C;
    'dispatch: loop {
        match pc {
            0x82E8B33C => {
    //   block [0x82E8B33C..0x82E8B344)
	// 82E8B33C: D0030018  stfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8B340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B344(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B344 size=8
    let mut pc: u32 = 0x82E8B344;
    'dispatch: loop {
        match pc {
            0x82E8B344 => {
    //   block [0x82E8B344..0x82E8B34C)
	// 82E8B344: D0030014  stfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8B348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B34C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B34C size=8
    let mut pc: u32 = 0x82E8B34C;
    'dispatch: loop {
        match pc {
            0x82E8B34C => {
    //   block [0x82E8B34C..0x82E8B354)
	// 82E8B34C: D0030010  stfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8B350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B354(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B354 size=8
    let mut pc: u32 = 0x82E8B354;
    'dispatch: loop {
        match pc {
            0x82E8B354 => {
    //   block [0x82E8B354..0x82E8B35C)
	// 82E8B354: D0030020  stfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8B358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B35C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B35C size=24
    let mut pc: u32 = 0x82E8B35C;
    'dispatch: loop {
        match pc {
            0x82E8B35C => {
    //   block [0x82E8B35C..0x82E8B374)
	// 82E8B35C: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 82E8B360: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E8B364: 419A0018  beq cr6, 0x82e8b37c
	if ctx.cr[6].eq {
		sub_82E8B37C(ctx, base);
		return;
	}
	// 82E8B368: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 82E8B36C: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E8B370: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B374(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B374 size=8
    let mut pc: u32 = 0x82E8B374;
    'dispatch: loop {
        match pc {
            0x82E8B374 => {
    //   block [0x82E8B374..0x82E8B37C)
	// 82E8B374: D0030028  stfs f0, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E8B378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B37C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B37C size=8
    let mut pc: u32 = 0x82E8B37C;
    'dispatch: loop {
        match pc {
            0x82E8B37C => {
    //   block [0x82E8B37C..0x82E8B384)
	// 82E8B37C: D0030024  stfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8B380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B388 size=48
    let mut pc: u32 = 0x82E8B388;
    'dispatch: loop {
        match pc {
            0x82E8B388 => {
    //   block [0x82E8B388..0x82E8B3B8)
	// 82E8B388: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E8B38C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E8B390: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82E8B394: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82E8B398: 38EAE1C4  addi r7, r10, -0x1e3c
	ctx.r[7].s64 = ctx.r[10].s64 + -7740;
	// 82E8B39C: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82E8B3A0: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E8B3A4: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B3B8 size=72
    let mut pc: u32 = 0x82E8B3B8;
    'dispatch: loop {
        match pc {
            0x82E8B3B8 => {
    //   block [0x82E8B3B8..0x82E8B400)
	// 82E8B3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B3C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B3C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B3C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B3CC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8B3D0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82E8B3D4: 392BE1C4  addi r9, r11, -0x1e3c
	ctx.r[9].s64 = ctx.r[11].s64 + -7740;
	// 82E8B3D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8B3DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8B3E0: 419A000C  beq cr6, 0x82e8b3ec
	if ctx.cr[6].eq {
	pc = 0x82E8B3EC; continue 'dispatch;
	}
	// 82E8B3E4: 4BF66FF5  bl 0x82df23d8
	ctx.lr = 0x82E8B3E8;
	sub_82DF23D8(ctx, base);
	// 82E8B3E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B3EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8B3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B3F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B400 size=316
    let mut pc: u32 = 0x82E8B400;
    'dispatch: loop {
        match pc {
            0x82E8B400 => {
    //   block [0x82E8B400..0x82E8B53C)
	// 82E8B400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B404: 4831CD4D  bl 0x831a8150
	ctx.lr = 0x82E8B408;
	sub_831A8130(ctx, base);
	// 82E8B408: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82E8B40C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82E8B410: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B414: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8B418: 90A10114  stw r5, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[5].u32 ) };
	// 82E8B41C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B420: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82E8B424: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82E8B428: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B42C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8B430: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82E8B434: 41980010  blt cr6, 0x82e8b444
	if ctx.cr[6].lt {
	pc = 0x82E8B444; continue 'dispatch;
	}
	// 82E8B438: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82E8B43C: 41980008  blt cr6, 0x82e8b444
	if ctx.cr[6].lt {
	pc = 0x82E8B444; continue 'dispatch;
	}
	// 82E8B440: D03E0004  stfs f1, 4(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8B444: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8B448: 3B1E000C  addi r24, r30, 0xc
	ctx.r[24].s64 = ctx.r[30].s64 + 12;
	// 82E8B44C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8B450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8B454: 419A0010  beq cr6, 0x82e8b464
	if ctx.cr[6].eq {
	pc = 0x82E8B464; continue 'dispatch;
	}
	// 82E8B458: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8B45C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E8B460: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E8B464: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B468: 409900C4  ble cr6, 0x82e8b52c
	if !ctx.cr[6].gt {
	pc = 0x82E8B52C; continue 'dispatch;
	}
	// 82E8B46C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82E8B470: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82E8B474: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82E8B478: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 82E8B47C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E8B480: C3C994AC  lfs f30, -0x6b54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E8B484: 3B8B384C  addi r28, r11, 0x384c
	ctx.r[28].s64 = ctx.r[11].s64 + 14412;
	// 82E8B488: 3B6A3854  addi r27, r10, 0x3854
	ctx.r[27].s64 = ctx.r[10].s64 + 14420;
	// 82E8B48C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B490: 7FFA582E  lwzx r31, r26, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8B494: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8B498: 419A0088  beq cr6, 0x82e8b520
	if ctx.cr[6].eq {
	pc = 0x82E8B520; continue 'dispatch;
	}
	// 82E8B49C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B4A0: 7D6AB038  and r10, r11, r22
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[22].u64;
	// 82E8B4A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8B4A8: 419A0078  beq cr6, 0x82e8b520
	if ctx.cr[6].eq {
	pc = 0x82E8B520; continue 'dispatch;
	}
	// 82E8B4AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8B4B0: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 82E8B4B4: 41980008  blt cr6, 0x82e8b4bc
	if ctx.cr[6].lt {
	pc = 0x82E8B4BC; continue 'dispatch;
	}
	// 82E8B4B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8B4BC: 57AB07BE  clrlwi r11, r29, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82E8B4C0: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8B4C4: 39410114  addi r10, r1, 0x114
	ctx.r[10].s64 = ctx.r[1].s64 + 276;
	// 82E8B4C8: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8B4CC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8B4D0: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82E8B4D4: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E8B4D8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8B4DC: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E8B4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B4E4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E8B4E8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8B4EC: 7D0B50AE  lbzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8B4F0: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8B4F4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82E8B4F8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8B4FC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E8B500: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E8B504: EC4C07B2  fmuls f2, f12, f30
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E8B508: 4BFFD739  bl 0x82e88c40
	ctx.lr = 0x82E8B50C;
	sub_82E88C40(ctx, base);
	// 82E8B50C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8B510: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B514: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8B518: 4BFFFDF9  bl 0x82e8b310
	ctx.lr = 0x82E8B51C;
	sub_82E8B310(ctx, base);
	// 82E8B51C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82E8B520: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82E8B524: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82E8B528: 4082FF64  bne 0x82e8b48c
	if !ctx.cr[0].eq {
	pc = 0x82E8B48C; continue 'dispatch;
	}
	// 82E8B52C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82E8B530: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82E8B534: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82E8B538: 4831CC68  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B540 size=384
    let mut pc: u32 = 0x82E8B540;
    'dispatch: loop {
        match pc {
            0x82E8B540 => {
    //   block [0x82E8B540..0x82E8B6C0)
	// 82E8B540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B544: 4831CC25  bl 0x831a8168
	ctx.lr = 0x82E8B548;
	sub_831A8130(ctx, base);
	// 82E8B548: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E8B54C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B550: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E8B554: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82E8B558: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82E8B55C: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82E8B560: 390A4620  addi r8, r10, 0x4620
	ctx.r[8].s64 = ctx.r[10].s64 + 17952;
	// 82E8B564: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 82E8B568: 3B830020  addi r28, r3, 0x20
	ctx.r[28].s64 = ctx.r[3].s64 + 32;
	// 82E8B56C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8B570: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8B574: 57C704E6  rlwinm r7, r30, 0, 0x13, 0x13
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8B578: 13C040C7  vcmpequd (lvx128) v30, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8B57C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B6C0 size=332
    let mut pc: u32 = 0x82E8B6C0;
    'dispatch: loop {
        match pc {
            0x82E8B6C0 => {
    //   block [0x82E8B6C0..0x82E8B80C)
	// 82E8B6C0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82E8B6C4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8B6C8: ED010072  fmuls f8, f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E8B6CC: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B810 size=12
    let mut pc: u32 = 0x82E8B810;
    'dispatch: loop {
        match pc {
            0x82E8B810 => {
    //   block [0x82E8B810..0x82E8B81C)
	// 82E8B810: 816306A0  lwz r11, 0x6a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1696 as u32) ) } as u64;
	// 82E8B814: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82E8B818: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B81C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B81C size=328
    let mut pc: u32 = 0x82E8B81C;
    'dispatch: loop {
        match pc {
            0x82E8B81C => {
    //   block [0x82E8B81C..0x82E8B964)
	// 82E8B81C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B964(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B964 size=92
    let mut pc: u32 = 0x82E8B964;
    'dispatch: loop {
        match pc {
            0x82E8B964 => {
    //   block [0x82E8B964..0x82E8B9C0)
	// 82E8B964: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 82E8B968: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82E8B96C: 38C0FFD0  li r6, -0x30
	ctx.r[6].s64 = -48;
	// 82E8B970: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E8B974: 3900FFE0  li r8, -0x20
	ctx.r[8].s64 = -32;
	// 82E8B978: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 82E8B97C: 126B28C7  vcmpequd (lvx128) v19, v11, v5
	tmp.u32 = ctx.r[11].u32 + ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[51] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8B980: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E8B984: 124050C7  vcmpequd (lvx128) v18, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[50] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B9C0 size=772
    let mut pc: u32 = 0x82E8B9C0;
    'dispatch: loop {
        match pc {
            0x82E8B9C0 => {
    //   block [0x82E8B9C0..0x82E8BCC4)
	// 82E8B9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B9C4: 4831C77D  bl 0x831a8140
	ctx.lr = 0x82E8B9C8;
	sub_831A8130(ctx, base);
	// 82E8B9C8: 816306A0  lwz r11, 0x6a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1696 as u32) ) } as u64;
	// 82E8B9CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B9D0: 419A02F0  beq cr6, 0x82e8bcc0
	if ctx.cr[6].eq {
	pc = 0x82E8BCC0; continue 'dispatch;
	}
	// 82E8B9D4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E8B9D8: 419A02E8  beq cr6, 0x82e8bcc0
	if ctx.cr[6].eq {
	pc = 0x82E8BCC0; continue 'dispatch;
	}
	// 82E8B9DC: 78AA0020  clrldi r10, r5, 0x20
	ctx.r[10].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 82E8B9E0: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82E8B9E4: F941FEA8  std r10, -0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-344 as u32), ctx.r[10].u64 ) };
	// 82E8B9E8: C801FEA8  lfd f0, -0x158(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-344 as u32) ) };
	// 82E8B9EC: F921FEA8  std r9, -0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-344 as u32), ctx.r[9].u64 ) };
	// 82E8B9F0: C9A1FEA8  lfd f13, -0x158(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-344 as u32) ) };
	// 82E8B9F4: FD40069C  fcfid f10, f0
	ctx.f[10].f64 = (ctx.f[0].s64 as f64);
	// 82E8B9F8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82E8B9FC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82E8BA00: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BA04: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E8BA08: D001FEB0  stfs f0, -0x150(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-336 as u32), tmp.u32 ) };
	// 82E8BA0C: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82E8BA10: 3961FEA0  addi r11, r1, -0x160
	ctx.r[11].s64 = ctx.r[1].s64 + -352;
	// 82E8BA14: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82E8BA18: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82E8BA1C: 38C1FEA0  addi r6, r1, -0x160
	ctx.r[6].s64 = ctx.r[1].s64 + -352;
	// 82E8BA20: C167E830  lfs f11, -0x17d0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8BA24: 3941FEB0  addi r10, r1, -0x150
	ctx.r[10].s64 = ctx.r[1].s64 + -336;
	// 82E8BA28: 38E1FEA0  addi r7, r1, -0x160
	ctx.r[7].s64 = ctx.r[1].s64 + -352;
	// 82E8BA2C: 3BE1FEA8  addi r31, r1, -0x158
	ctx.r[31].s64 = ctx.r[1].s64 + -344;
	// 82E8BA30: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8BA34: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E8BA38: C1889524  lfs f12, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8BA3C: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8BA40: 39450003  addi r10, r5, 3
	ctx.r[10].s64 = ctx.r[5].s64 + 3;
	// 82E8BA44: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BA48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8BA4C: EC094024  fdivs f0, f9, f8
	ctx.f[0].f64 = ((ctx.f[9].f64 / ctx.f[8].f64) as f32) as f64;
	// 82E8BA50: D001FEA0  stfs f0, -0x160(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-352 as u32), tmp.u32 ) };
	// 82E8BA54: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8BCC8 size=120
    let mut pc: u32 = 0x82E8BCC8;
    'dispatch: loop {
        match pc {
            0x82E8BCC8 => {
    //   block [0x82E8BCC8..0x82E8BD40)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8BD40 size=644
    let mut pc: u32 = 0x82E8BD40;
    'dispatch: loop {
        match pc {
            0x82E8BD40 => {
    //   block [0x82E8BD40..0x82E8BFC4)
	// 82E8BD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8BD48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8BD4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8BD50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BD54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BD58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8BD5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8BD60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BD64: 914B06A0  stw r10, 0x6a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1696 as u32), ctx.r[10].u32 ) };
	// 82E8BD68: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BD6C: 80E5000C  lwz r7, 0xc(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8BD70: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82E8BD74: 40990014  ble cr6, 0x82e8bd88
	if !ctx.cr[6].gt {
	pc = 0x82E8BD88; continue 'dispatch;
	}
	// 82E8BD78: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BD7C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E8BD80: 7D0B3A14  add r8, r11, r7
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82E8BD84: 48000008  b 0x82e8bd8c
	pc = 0x82E8BD8C; continue 'dispatch;
	// 82E8BD88: 7D0A3850  subf r8, r10, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 82E8BD8C: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 82E8BD90: 40990200  ble cr6, 0x82e8bf90
	if !ctx.cr[6].gt {
	pc = 0x82E8BF90; continue 'dispatch;
	}
	// 82E8BD94: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BD98: 2F080014  cmpwi cr6, r8, 0x14
	ctx.cr[6].compare_i32(ctx.r[8].s32, 20, &mut ctx.xer);
	// 82E8BD9C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BDA0: 409800EC  bge cr6, 0x82e8be8c
	if !ctx.cr[6].lt {
	pc = 0x82E8BE8C; continue 'dispatch;
	}
	// 82E8BDA4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8BDA8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BDAC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BDB0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8BDB4: 409A0018  bne cr6, 0x82e8bdcc
	if !ctx.cr[6].eq {
	pc = 0x82E8BDCC; continue 'dispatch;
	}
	// 82E8BDB8: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BDBC: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BDC0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8BDC4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BDC8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BDCC: 390AFFF4  addi r8, r10, -0xc
	ctx.r[8].s64 = ctx.r[10].s64 + -12;
	// 82E8BDD0: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BDD4: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82E8BDD8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BDDC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BDE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8BDE4: 409A0020  bne cr6, 0x82e8be04
	if !ctx.cr[6].eq {
	pc = 0x82E8BE04; continue 'dispatch;
	}
	// 82E8BDE8: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BDEC: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BDF0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8BDF4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BDF8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BDFC: 394BFFF4  addi r10, r11, -0xc
	ctx.r[10].s64 = ctx.r[11].s64 + -12;
	// 82E8BE00: 48000008  b 0x82e8be08
	pc = 0x82E8BE08; continue 'dispatch;
	// 82E8BE04: 394AFFF4  addi r10, r10, -0xc
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	// 82E8BE08: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8BE0C: 419A0184  beq cr6, 0x82e8bf90
	if ctx.cr[6].eq {
	pc = 0x82E8BF90; continue 'dispatch;
	}
	// 82E8BE10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8BE14: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BE18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BE1C: 812B06A0  lwz r9, 0x6a0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1696 as u32) ) } as u64;
	// 82E8BE20: 2F090014  cmpwi cr6, r9, 0x14
	ctx.cr[6].compare_i32(ctx.r[9].s32, 20, &mut ctx.xer);
	// 82E8BE24: 40980030  bge cr6, 0x82e8be54
	if !ctx.cr[6].lt {
	pc = 0x82E8BE54; continue 'dispatch;
	}
	// 82E8BE28: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82E8BE2C: 55293032  slwi r9, r9, 6
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BE30: 90EB06A0  stw r7, 0x6a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1696 as u32), ctx.r[7].u32 ) };
	// 82E8BE34: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8BE38: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E8BE3C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8BE40: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8BE44: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8BE48: C16A0008  lfs f11, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8BE4C: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8BE50: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8BE54: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BE58: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8BE5C: 409A0020  bne cr6, 0x82e8be7c
	if !ctx.cr[6].eq {
	pc = 0x82E8BE7C; continue 'dispatch;
	}
	// 82E8BE60: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BE64: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BE68: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8BE6C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8BE70: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8BE74: 394BFFF4  addi r10, r11, -0xc
	ctx.r[10].s64 = ctx.r[11].s64 + -12;
	// 82E8BE78: 48000008  b 0x82e8be80
	pc = 0x82E8BE80; continue 'dispatch;
	// 82E8BE7C: 394AFFF4  addi r10, r10, -0xc
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	// 82E8BE80: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8BE84: 409AFF94  bne cr6, 0x82e8be18
	if !ctx.cr[6].eq {
	pc = 0x82E8BE18; continue 'dispatch;
	}
	// 82E8BE88: 48000108  b 0x82e8bf90
	pc = 0x82E8BF90; continue 'dispatch;
	// 82E8BE8C: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8BE90: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 82E8BE94: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BE98: 7D2833D6  divw r9, r8, r6
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[6].s32;
	// 82E8BE9C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BEA0: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 82E8BEA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E8BEA8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8BEAC: 409A0018  bne cr6, 0x82e8bec4
	if !ctx.cr[6].eq {
	pc = 0x82E8BEC4; continue 'dispatch;
	}
	// 82E8BEB0: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BEB4: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BEB8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8BEBC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BEC0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BEC4: 38CAFFF4  addi r6, r10, -0xc
	ctx.r[6].s64 = ctx.r[10].s64 + -12;
	// 82E8BEC8: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BECC: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82E8BED0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BED4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BED8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8BEDC: 409A0020  bne cr6, 0x82e8befc
	if !ctx.cr[6].eq {
	pc = 0x82E8BEFC; continue 'dispatch;
	}
	// 82E8BEE0: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BEE4: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BEE8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8BEEC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BEF0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8BEF4: 394BFFF4  addi r10, r11, -0xc
	ctx.r[10].s64 = ctx.r[11].s64 + -12;
	// 82E8BEF8: 48000008  b 0x82e8bf00
	pc = 0x82E8BF00; continue 'dispatch;
	// 82E8BEFC: 394AFFF4  addi r10, r10, -0xc
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	// 82E8BF00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82E8BF04: 419A008C  beq cr6, 0x82e8bf90
	if ctx.cr[6].eq {
	pc = 0x82E8BF90; continue 'dispatch;
	}
	// 82E8BF08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8BF0C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BF10: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E8BF14: 409A0044  bne cr6, 0x82e8bf58
	if !ctx.cr[6].eq {
	pc = 0x82E8BF58; continue 'dispatch;
	}
	// 82E8BF18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BF1C: 812B06A0  lwz r9, 0x6a0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1696 as u32) ) } as u64;
	// 82E8BF20: 2F090014  cmpwi cr6, r9, 0x14
	ctx.cr[6].compare_i32(ctx.r[9].s32, 20, &mut ctx.xer);
	// 82E8BF24: 40980030  bge cr6, 0x82e8bf54
	if !ctx.cr[6].lt {
	pc = 0x82E8BF54; continue 'dispatch;
	}
	// 82E8BF28: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 82E8BF2C: 55293032  slwi r9, r9, 6
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8BF30: 910B06A0  stw r8, 0x6a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1696 as u32), ctx.r[8].u32 ) };
	// 82E8BF34: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8BF38: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E8BF3C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8BF40: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8BF44: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8BF48: C16A0008  lfs f11, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8BF4C: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8BF50: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8BF54: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82E8BF58: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BF5C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82E8BF60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8BF64: 409A0020  bne cr6, 0x82e8bf84
	if !ctx.cr[6].eq {
	pc = 0x82E8BF84; continue 'dispatch;
	}
	// 82E8BF68: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8BF6C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8BF70: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8BF74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8BF78: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8BF7C: 394BFFF4  addi r10, r11, -0xc
	ctx.r[10].s64 = ctx.r[11].s64 + -12;
	// 82E8BF80: 48000008  b 0x82e8bf88
	pc = 0x82E8BF88; continue 'dispatch;
	// 82E8BF84: 394AFFF4  addi r10, r10, -0xc
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	// 82E8BF88: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82E8BF8C: 409AFF84  bne cr6, 0x82e8bf10
	if !ctx.cr[6].eq {
	pc = 0x82E8BF10; continue 'dispatch;
	}
	// 82E8BF90: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BF94: 4BFFF87D  bl 0x82e8b810
	ctx.lr = 0x82E8BF98;
	sub_82E8B810(ctx, base);
	// 82E8BF98: 38A00015  li r5, 0x15
	ctx.r[5].s64 = 21;
	// 82E8BF9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8BFA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BFA4: 4BFFFA1D  bl 0x82e8b9c0
	ctx.lr = 0x82E8BFA8;
	sub_82E8B9C0(ctx, base);
	// 82E8BFA8: 38600015  li r3, 0x15
	ctx.r[3].s64 = 21;
	// 82E8BFAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8BFB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8BFB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8BFB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8BFBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8BFC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8BFC8 size=132
    let mut pc: u32 = 0x82E8BFC8;
    'dispatch: loop {
        match pc {
            0x82E8BFC8 => {
    //   block [0x82E8BFC8..0x82E8C04C)
	// 82E8BFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8BFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8BFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8BFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BFE0: 48003309  bl 0x82e8f2e8
	ctx.lr = 0x82E8BFE4;
	sub_82E8F2E8(ctx, base);
	// 82E8BFE4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8BFE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8BFEC: 394BE1DC  addi r10, r11, -0x1e24
	ctx.r[10].s64 = ctx.r[11].s64 + -7716;
	// 82E8BFF0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E8BFF4: 386006B0  li r3, 0x6b0
	ctx.r[3].s64 = 1712;
	// 82E8BFF8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8BFFC: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8C000: 4B434939  bl 0x822c0938
	ctx.lr = 0x82E8C004;
	sub_822C0938(ctx, base);
	// 82E8C004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8C008: 419A000C  beq cr6, 0x82e8c014
	if ctx.cr[6].eq {
	pc = 0x82E8C014; continue 'dispatch;
	}
	// 82E8C00C: 4BFFFCBD  bl 0x82e8bcc8
	ctx.lr = 0x82E8C010;
	sub_82E8BCC8(ctx, base);
	// 82E8C010: 48000008  b 0x82e8c018
	pc = 0x82E8C018; continue 'dispatch;
	// 82E8C014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8C018: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C01C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82E8C020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8C024: 419A000C  beq cr6, 0x82e8c030
	if ctx.cr[6].eq {
	pc = 0x82E8C030; continue 'dispatch;
	}
	// 82E8C028: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8C02C: 4B43423D  bl 0x822c0268
	ctx.lr = 0x82E8C030;
	sub_822C0268(ctx, base);
	// 82E8C030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8C038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C03C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8C044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8C048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C050 size=224
    let mut pc: u32 = 0x82E8C050;
    'dispatch: loop {
        match pc {
            0x82E8C050 => {
    //   block [0x82E8C050..0x82E8C130)
	// 82E8C050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C054: 4831C10D  bl 0x831a8160
	ctx.lr = 0x82E8C058;
	sub_831A8130(ctx, base);
	// 82E8C058: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C05C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8C060: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E8C064: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E8C068: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8C06C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C070: 816B0160  lwz r11, 0x160(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(352 as u32) ) } as u64;
	// 82E8C074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8C078: 419A00AC  beq cr6, 0x82e8c124
	if ctx.cr[6].eq {
	pc = 0x82E8C124; continue 'dispatch;
	}
	// 82E8C07C: 1D6B002C  mulli r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 * 44;
	// 82E8C080: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8C084: 5564043E  clrlwi r4, r11, 0x10
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82E8C088: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 82E8C08C: 4800112D  bl 0x82e8d1b8
	ctx.lr = 0x82E8C090;
	sub_82E8D1B8(ctx, base);
	// 82E8C090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C094: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8C098: 419A008C  beq cr6, 0x82e8c124
	if ctx.cr[6].eq {
	pc = 0x82E8C124; continue 'dispatch;
	}
	// 82E8C09C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C0A0: 4BFF1A39  bl 0x82e7dad8
	ctx.lr = 0x82E8C0A4;
	sub_82E7DAD8(ctx, base);
	// 82E8C0A4: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C0A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C0AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8C0B0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82E8C0B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8C0B8: 419A0024  beq cr6, 0x82e8c0dc
	if ctx.cr[6].eq {
	pc = 0x82E8C0DC; continue 'dispatch;
	}
	// 82E8C0BC: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 82E8C0C0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82E8C0C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8C0C8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82E8C0CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8C0D0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E8C0D4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8C0D8: 4082FFE8  bne 0x82e8c0c0
	if !ctx.cr[0].eq {
	pc = 0x82E8C0C0; continue 'dispatch;
	}
	// 82E8C0DC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8C0E0: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82E8C0E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82E8C0E8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E8C0EC: 4B438375  bl 0x822c4460
	ctx.lr = 0x82E8C0F0;
	sub_822C4460(ctx, base);
	// 82E8C0F0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8C0F4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E8C0F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C0FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8C100: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8C104: 48003295  bl 0x82e8f398
	ctx.lr = 0x82E8C108;
	sub_82E8F398(ctx, base);
	// 82E8C108: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8C10C: 419A000C  beq cr6, 0x82e8c118
	if ctx.cr[6].eq {
	pc = 0x82E8C118; continue 'dispatch;
	}
	// 82E8C110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C114: 4B43477D  bl 0x822c0890
	ctx.lr = 0x82E8C118;
	sub_822C0890(ctx, base);
	// 82E8C118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C11C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8C120: 4831C090  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8C124: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8C128: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8C12C: 4831C084  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8C130 size=1632
    let mut pc: u32 = 0x82E8C130;
    'dispatch: loop {
        match pc {
            0x82E8C130 => {
    //   block [0x82E8C130..0x82E8C790)
	// 82E8C130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C134: 4831C00D  bl 0x831a8140
	ctx.lr = 0x82E8C138;
	sub_831A8130(ctx, base);
	// 82E8C138: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82E8C13C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82E8C140: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C144: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82E8C148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8C14C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8C150: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82E8C154: 82970000  lwz r20, 0(r23)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C158: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E8C15C: 81540004  lwz r10, 4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C160: 55490000  rlwinm r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8C164: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8C168: 409A0034  bne cr6, 0x82e8c19c
	if !ctx.cr[6].eq {
	pc = 0x82E8C19C; continue 'dispatch;
	}
	// 82E8C16C: 89740010  lbz r11, 0x10(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C170: C1B40004  lfs f13, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8C174: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8C178: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8C17C: 419A0014  beq cr6, 0x82e8c190
	if ctx.cr[6].eq {
	pc = 0x82E8C190; continue 'dispatch;
	}
	// 82E8C180: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E8C184: C00BFB3C  lfs f0, -0x4c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C188: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8C18C: 48000014  b 0x82e8c1a0
	pc = 0x82E8C1A0; continue 'dispatch;
	// 82E8C190: C0140008  lfs f0, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C194: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8C198: 48000008  b 0x82e8c1a0
	pc = 0x82E8C1A0; continue 'dispatch;
	// 82E8C19C: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82E8C1A0: 3BF70020  addi r31, r23, 0x20
	ctx.r[31].s64 = ctx.r[23].s64 + 32;
	// 82E8C1A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8C1A8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82E8C1AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8C1B0: 48001A39  bl 0x82e8dbe8
	ctx.lr = 0x82E8C1B4;
	sub_82E8DBE8(ctx, base);
	// 82E8C1B4: 815400C4  lwz r10, 0xc4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E8C1B8: 817400C0  lwz r11, 0xc0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8C1BC: 38B400C0  addi r5, r20, 0xc0
	ctx.r[5].s64 = ctx.r[20].s64 + 192;
	// 82E8C1C0: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8C1C4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8C1C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8C1CC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8C1D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8C1D4: 40980014  bge cr6, 0x82e8c1e8
	if !ctx.cr[6].lt {
	pc = 0x82E8C1E8; continue 'dispatch;
	}
	// 82E8C1D8: 7C005A2C  dcbt 0, r11
	// 82E8C1DC: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 82E8C1E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8C1E4: 4198FFF4  blt cr6, 0x82e8c1d8
	if ctx.cr[6].lt {
	pc = 0x82E8C1D8; continue 'dispatch;
	}
	// 82E8C1E8: 8105000C  lwz r8, 0xc(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8C1EC: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C1F0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8C1F4: 40990014  ble cr6, 0x82e8c208
	if !ctx.cr[6].gt {
	pc = 0x82E8C208; continue 'dispatch;
	}
	// 82E8C1F8: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C1FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E8C200: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82E8C204: 48000008  b 0x82e8c20c
	pc = 0x82E8C20C; continue 'dispatch;
	// 82E8C208: 7D694050  subf r11, r9, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82E8C20C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82E8C210: 40980018  bge cr6, 0x82e8c228
	if !ctx.cr[6].lt {
	pc = 0x82E8C228; continue 'dispatch;
	}
	// 82E8C214: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8C218: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 82E8C21C: CBC1FF78  lfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82E8C220: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82E8C224: 4831BF6C  b 0x831a8190
	sub_831A8180(ctx, base);
	return;
	// 82E8C228: 897400E2  lbz r11, 0xe2(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(226 as u32) ) } as u64;
	// 82E8C22C: 3AA00015  li r21, 0x15
	ctx.r[21].s64 = 21;
	// 82E8C230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8C234: 409A01D4  bne cr6, 0x82e8c408
	if !ctx.cr[6].eq {
	pc = 0x82E8C408; continue 'dispatch;
	}
	// 82E8C238: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82E8C23C: C03400D4  lfs f1, 0xd4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8C240: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8C244: 4BFFFAFD  bl 0x82e8bd40
	ctx.lr = 0x82E8C248;
	sub_82E8BD40(ctx, base);
	// 82E8C248: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82E8C24C: 2B150002  cmplwi cr6, r21, 2
	ctx.cr[6].compare_u32(ctx.r[21].u32, 2 as u32, &mut ctx.xer);
	// 82E8C250: 4198FFC4  blt cr6, 0x82e8c214
	if ctx.cr[6].lt {
	pc = 0x82E8C214; continue 'dispatch;
	}
	// 82E8C254: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E8C258: 81570010  lwz r10, 0x10(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C25C: D3C10054  stfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8C260: 392BBB44  addi r9, r11, -0x44bc
	ctx.r[9].s64 = ctx.r[11].s64 + -17596;
	// 82E8C264: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E8C268: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8C26C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8C270: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8C274: C00BBB44  lfs f0, -0x44bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17596 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C278: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8C27C: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8C280: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8C284: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E8C288: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8C28C: 419A0088  beq cr6, 0x82e8c314
	if ctx.cr[6].eq {
	pc = 0x82E8C314; continue 'dispatch;
	}
	// 82E8C290: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8C294: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8C298: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8C29C: FD206090  fmr f9, f12
	ctx.f[9].f64 = ctx.f[12].f64;
	// 82E8C2A0: FCE05890  fmr f7, f11
	ctx.f[7].f64 = ctx.f[11].f64;
	// 82E8C2A4: C08B0000  lfs f4, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E8C2A8: C06B0004  lfs f3, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E8C2AC: ED4C07F2  fmuls f10, f12, f31
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8C2B0: ED0B07F2  fmuls f8, f11, f31
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8C2B4: C04B000C  lfs f2, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E8C2B8: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8C2BC: FD802090  fmr f12, f4
	ctx.f[12].f64 = ctx.f[4].f64;
	// 82E8C2C0: FD601890  fmr f11, f3
	ctx.f[11].f64 = ctx.f[3].f64;
	// 82E8C2C4: ECC907F2  fmuls f6, f9, f31
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8C2C8: ECA707F2  fmuls f5, f7, f31
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8C2CC: FD201090  fmr f9, f2
	ctx.f[9].f64 = ctx.f[2].f64;
	// 82E8C2D0: FCE00890  fmr f7, f1
	ctx.f[7].f64 = ctx.f[1].f64;
	// 82E8C2D4: EC8402BA  fmadds f4, f4, f10, f0
	ctx.f[4].f64 = (((ctx.f[4].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8C2D8: D0810050  stfs f4, 0x50(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8C2DC: EC42023A  fmadds f2, f2, f8, f0
	ctx.f[2].f64 = (((ctx.f[2].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8C2E0: D0410058  stfs f2, 0x58(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8C2E4: EC6302B2  fmuls f3, f3, f10
	ctx.f[3].f64 = (((ctx.f[3].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E8C2E8: D0610054  stfs f3, 0x54(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8C2EC: EC210232  fmuls f1, f1, f8
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[8].f64) as f32) as f64);
	// 82E8C2F0: D021005C  stfs f1, 0x5c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E8C2F4: EC066B3A  fmadds f0, f6, f12, f13
	ctx.f[0].f64 = (((ctx.f[6].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8C2F8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E8C2FC: ED8B01B2  fmuls f12, f11, f6
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[6].f64) as f32) as f64);
	// 82E8C300: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8C304: ED69697A  fmadds f11, f9, f5, f13
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8C308: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8C30C: ED470172  fmuls f10, f7, f5
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[5].f64) as f32) as f64);
	// 82E8C310: D141006C  stfs f10, 0x6c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8C314: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82E8C318: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C31C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82E8C320: 81170018  lwz r8, 0x18(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8C324: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82E8C328: C0370014  lfs f1, 0x14(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8C32C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E8C330: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E8C334: C00A7700  lfs f0, 0x7700(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C338: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82E8C33C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E8C340: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82E8C344: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C790 size=112
    let mut pc: u32 = 0x82E8C790;
    'dispatch: loop {
        match pc {
            0x82E8C790 => {
    //   block [0x82E8C790..0x82E8C800)
	// 82E8C790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8C798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8C79C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8C7A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C7A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C7A8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8C7AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8C7B0: 394BE1DC  addi r10, r11, -0x1e24
	ctx.r[10].s64 = ctx.r[11].s64 + -7716;
	// 82E8C7B4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C7B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8C7BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8C7C0: 419A0008  beq cr6, 0x82e8c7c8
	if ctx.cr[6].eq {
	pc = 0x82E8C7C8; continue 'dispatch;
	}
	// 82E8C7C4: 4B433AA5  bl 0x822c0268
	ctx.lr = 0x82E8C7C8;
	sub_822C0268(ctx, base);
	// 82E8C7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C7CC: 48002B5D  bl 0x82e8f328
	ctx.lr = 0x82E8C7D0;
	sub_82E8F328(ctx, base);
	// 82E8C7D0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8C7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8C7DC: 419A000C  beq cr6, 0x82e8c7e8
	if ctx.cr[6].eq {
	pc = 0x82E8C7E8; continue 'dispatch;
	}
	// 82E8C7E0: 4BF65BF9  bl 0x82df23d8
	ctx.lr = 0x82E8C7E4;
	sub_82DF23D8(ctx, base);
	// 82E8C7E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C7E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8C7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C7F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8C7F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8C7FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8C800 size=80
    let mut pc: u32 = 0x82E8C800;
    'dispatch: loop {
        match pc {
            0x82E8C800 => {
    //   block [0x82E8C800..0x82E8C850)
	// 82E8C800: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8C804: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82E8C808: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8C80C: 396BE1F0  addi r11, r11, -0x1e10
	ctx.r[11].s64 = ctx.r[11].s64 + -7696;
	// 82E8C810: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8C814: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82E8C818: 7DAA5C2E  lfsx f13, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8C81C: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C820: 7D8A442E  lfsx f12, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8C824: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8C828: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8C82C: ED4C0028  fsubs f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8C830: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8C834: D1A30010  stfs f13, 0x10(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8C838: D1830014  stfs f12, 0x14(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8C83C: D1630018  stfs f11, 0x18(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8C840: D143001C  stfs f10, 0x1c(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E8C844: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8C848: D1430024  stfs f10, 0x24(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8C84C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8C850 size=436
    let mut pc: u32 = 0x82E8C850;
    'dispatch: loop {
        match pc {
            0x82E8C850 => {
    //   block [0x82E8C850..0x82E8CA04)
	// 82E8C850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8C858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8C85C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8C860: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82E8C864: 4831C20D  bl 0x831a8a70
	ctx.lr = 0x82E8C868;
	sub_831A8A40(ctx, base);
	// 82E8C868: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C86C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82E8C870: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8C874: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8C878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8C87C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C880: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8C884: EDBD0032  fmuls f13, f29, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8C888: EC2D0332  fmuls f1, f13, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E8C88C: 4831F7B5  bl 0x831ac040
	ctx.lr = 0x82E8C890;
	sub_831AC040(ctx, base);
	// 82E8C890: C17E0008  lfs f11, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8C894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8C898: ED5D02F2  fmuls f10, f29, f11
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E8C89C: C13E0004  lfs f9, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8C8A0: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8C8A4: EC2A0272  fmuls f1, f10, f9
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82E8C8A8: 4831F799  bl 0x831ac040
	ctx.lr = 0x82E8C8AC;
	sub_831AC040(ctx, base);
	// 82E8C8AC: C11E0014  lfs f8, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8C8B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8C8B4: ECFD0232  fmuls f7, f29, f8
	ctx.f[7].f64 = (((ctx.f[29].f64 * ctx.f[8].f64) as f32) as f64);
	// 82E8C8B8: C0DE000C  lfs f6, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E8C8BC: FFC00818  frsp f30, f1
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8C8C0: EC2701B2  fmuls f1, f7, f6
	ctx.f[1].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82E8C8C4: 4831F77D  bl 0x831ac040
	ctx.lr = 0x82E8C8C8;
	sub_831AC040(ctx, base);
	// 82E8C8C8: C0BE0014  lfs f5, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E8C8CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8C8D0: EC9D0172  fmuls f4, f29, f5
	ctx.f[4].f64 = (((ctx.f[29].f64 * ctx.f[5].f64) as f32) as f64);
	// 82E8C8D4: C07E0010  lfs f3, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E8C8D8: FFA00818  frsp f29, f1
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8C8DC: EC2400F2  fmuls f1, f4, f3
	ctx.f[1].f64 = (((ctx.f[4].f64 * ctx.f[3].f64) as f32) as f64);
	// 82E8C8E0: 4831F761  bl 0x831ac040
	ctx.lr = 0x82E8C8E4;
	sub_831AC040(ctx, base);
	// 82E8C8E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8C8E8: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8C8EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8C8F0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C8F4: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8C8F8: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82E8C8FC: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82E8C900: 40980008  bge cr6, 0x82e8c908
	if !ctx.cr[6].lt {
	pc = 0x82E8C908; continue 'dispatch;
	}
	// 82E8C904: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82E8C908: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 82E8C90C: 40980008  bge cr6, 0x82e8c914
	if !ctx.cr[6].lt {
	pc = 0x82E8C914; continue 'dispatch;
	}
	// 82E8C910: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82E8C914: ED3E0028  fsubs f9, f30, f0
	ctx.f[9].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8C918: C15F0000  lfs f10, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8C91C: ECFD6028  fsubs f7, f29, f12
	ctx.f[7].f64 = (((ctx.f[29].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8C920: C11F0004  lfs f8, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8C924: ECAB0028  fsubs f5, f11, f0
	ctx.f[5].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8C928: C0DF0008  lfs f6, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E8C92C: EDBF6028  fsubs f13, f31, f12
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8C930: C09F000C  lfs f4, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E8C934: C07F0010  lfs f3, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E8C938: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E8C93C: C03F0018  lfs f1, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8C940: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8C944: C19F0020  lfs f12, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8C948: C17F0024  lfs f11, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8C94C: C3FF0028  lfs f31, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8C950: ED09402A  fadds f8, f9, f8
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[8].f64) as f32) as f64;
	// 82E8C954: C3DF002C  lfs f30, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E8C958: ECC7302A  fadds f6, f7, f6
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E8C95C: C3BF0030  lfs f29, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E8C960: EC85202A  fadds f4, f5, f4
	ctx.f[4].f64 = ((ctx.f[5].f64 + ctx.f[4].f64) as f32) as f64;
	// 82E8C964: C39F0034  lfs f28, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E8C968: ED4D502A  fadds f10, f13, f10
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82E8C96C: C37F0038  lfs f27, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E8C970: EC6D182A  fadds f3, f13, f3
	ctx.f[3].f64 = ((ctx.f[13].f64 + ctx.f[3].f64) as f32) as f64;
	// 82E8C974: C35F003C  lfs f26, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82E8C978: EC49102A  fadds f2, f9, f2
	ctx.f[2].f64 = ((ctx.f[9].f64 + ctx.f[2].f64) as f32) as f64;
	// 82E8C97C: D15F0000  stfs f10, 0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8C980: EC27082A  fadds f1, f7, f1
	ctx.f[1].f64 = ((ctx.f[7].f64 + ctx.f[1].f64) as f32) as f64;
	// 82E8C984: D11F0004  stfs f8, 4(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8C988: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E8C98C: D0DF0008  stfs f6, 8(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8C990: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E8C994: D09F000C  stfs f4, 0xc(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8C998: ED69582A  fadds f11, f9, f11
	ctx.f[11].f64 = ((ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E8C99C: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8C9A0: ED47F82A  fadds f10, f7, f31
	ctx.f[10].f64 = ((ctx.f[7].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E8C9A4: D05F0014  stfs f2, 0x14(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8C9A8: ED05F02A  fadds f8, f5, f30
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E8C9AC: ECCDE82A  fadds f6, f13, f29
	ctx.f[6].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82E8C9B0: D03F0018  stfs f1, 0x18(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8C9B4: EC89E02A  fadds f4, f9, f28
	ctx.f[4].f64 = ((ctx.f[9].f64 + ctx.f[28].f64) as f32) as f64;
	// 82E8C9B8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E8C9BC: EC67D82A  fadds f3, f7, f27
	ctx.f[3].f64 = ((ctx.f[7].f64 + ctx.f[27].f64) as f32) as f64;
	// 82E8C9C0: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8C9C4: EC45D02A  fadds f2, f5, f26
	ctx.f[2].f64 = ((ctx.f[5].f64 + ctx.f[26].f64) as f32) as f64;
	// 82E8C9C8: D17F0024  stfs f11, 0x24(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8C9CC: D15F0028  stfs f10, 0x28(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E8C9D0: D11F002C  stfs f8, 0x2c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E8C9D4: D0DF0030  stfs f6, 0x30(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E8C9D8: D09F0034  stfs f4, 0x34(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E8C9DC: D07F0038  stfs f3, 0x38(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E8C9E0: D05F003C  stfs f2, 0x3c(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E8C9E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8C9E8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82E8C9EC: 4831C0D1  bl 0x831a8abc
	ctx.lr = 0x82E8C9F0;
	sub_831A8A8C(ctx, base);
	// 82E8C9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8C9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8CA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CA08 size=68
    let mut pc: u32 = 0x82E8CA08;
    'dispatch: loop {
        match pc {
            0x82E8CA08 => {
    //   block [0x82E8CA08..0x82E8CA4C)
	// 82E8CA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8CA10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8CA14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CA1C: 480028CD  bl 0x82e8f2e8
	ctx.lr = 0x82E8CA20;
	sub_82E8F2E8(ctx, base);
	// 82E8CA20: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8CA24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8CA28: 392BE238  addi r9, r11, -0x1dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -7624;
	// 82E8CA2C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8CA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8CA34: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8CA38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8CA3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8CA40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8CA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8CA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CA50 size=92
    let mut pc: u32 = 0x82E8CA50;
    'dispatch: loop {
        match pc {
            0x82E8CA50 => {
    //   block [0x82E8CA50..0x82E8CAAC)
	// 82E8CA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8CA58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8CA5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8CA60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CA64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CA68: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8CA6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8CA70: 394BE238  addi r10, r11, -0x1dc8
	ctx.r[10].s64 = ctx.r[11].s64 + -7624;
	// 82E8CA74: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8CA78: 480028B1  bl 0x82e8f328
	ctx.lr = 0x82E8CA7C;
	sub_82E8F328(ctx, base);
	// 82E8CA7C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8CA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8CA84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8CA88: 419A000C  beq cr6, 0x82e8ca94
	if ctx.cr[6].eq {
	pc = 0x82E8CA94; continue 'dispatch;
	}
	// 82E8CA8C: 4BF6594D  bl 0x82df23d8
	ctx.lr = 0x82E8CA90;
	sub_82DF23D8(ctx, base);
	// 82E8CA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8CA94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8CA98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8CA9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8CAA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8CAA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8CAA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8CAB0 size=1016
    let mut pc: u32 = 0x82E8CAB0;
    'dispatch: loop {
        match pc {
            0x82E8CAB0 => {
    //   block [0x82E8CAB0..0x82E8CEA8)
	// 82E8CAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CAB4: 4831B6B1  bl 0x831a8164
	ctx.lr = 0x82E8CAB8;
	sub_831A8130(ctx, base);
	// 82E8CAB8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CABC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82E8CAC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8CAC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E8CAC8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CACC: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CAD0: 893E0009  lbz r9, 9(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(9 as u32) ) } as u64;
	// 82E8CAD4: C19C0028  lfs f12, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8CAD8: 5568403E  rotlwi r8, r11, 8
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 82E8CADC: C17C002C  lfs f11, 0x2c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8CAE0: 88FE000A  lbz r7, 0xa(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 82E8CAE4: 808A00A8  lwz r4, 0xa8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(168 as u32) ) } as u64;
	// 82E8CAE8: 7D034B78  or r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 82E8CAEC: 88DE000B  lbz r6, 0xb(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 82E8CAF0: 548B06BE  clrlwi r11, r4, 0x1a
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000003Fu64;
	// 82E8CAF4: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8CAF8: 5469402E  slwi r9, r3, 8
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8CAFC: 390B0006  addi r8, r11, 6
	ctx.r[8].s64 = ctx.r[11].s64 + 6;
	// 82E8CB00: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8CB04: 55041838  slwi r4, r8, 3
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82E8CB08: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82E8CB0C: 7D2B3B78  or r11, r9, r7
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 82E8CB10: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E8CB14: 5569402E  slwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8CB18: 7D44E42E  lfsx f10, r4, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8CB1C: C1230034  lfs f9, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8CB20: EC0A0332  fmuls f0, f10, f12
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E8CB24: EDA902F2  fmuls f13, f9, f11
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E8CB28: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E8CB2C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8CB30: 7D3D3378  or r29, r9, r6
	ctx.r[29].u64 = ctx.r[9].u64 | ctx.r[6].u64;
	// 82E8CB34: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8CB38: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8CB3C: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E8CB40: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E8CB44: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E8CB48: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E8CB4C: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E8CB50: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E8CB54: ED6D582A  fadds f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E8CB58: D1610084  stfs f11, 0x84(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E8CB5C: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E8CB60: D161008C  stfs f11, 0x8c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E8CB64: D1810090  stfs f12, 0x90(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82E8CB68: D1810098  stfs f12, 0x98(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E8CB6C: D1610094  stfs f11, 0x94(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E8CB70: D161009C  stfs f11, 0x9c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82E8CB74: 419A0058  beq cr6, 0x82e8cbcc
	if ctx.cr[6].eq {
	pc = 0x82E8CBCC; continue 'dispatch;
	}
	// 82E8CB78: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CB7C: 55690000  rlwinm r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8CB80: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8CB84: 409A0034  bne cr6, 0x82e8cbb8
	if !ctx.cr[6].eq {
	pc = 0x82E8CBB8; continue 'dispatch;
	}
	// 82E8CB88: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8CB8C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8CB90: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8CB94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8CB98: 419A0014  beq cr6, 0x82e8cbac
	if ctx.cr[6].eq {
	pc = 0x82E8CBAC; continue 'dispatch;
	}
	// 82E8CB9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E8CBA0: C00BFB3C  lfs f0, -0x4c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8CBA4: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8CBA8: 48000018  b 0x82e8cbc0
	pc = 0x82E8CBC0; continue 'dispatch;
	// 82E8CBAC: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8CBB0: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8CBB4: 4800000C  b 0x82e8cbc0
	pc = 0x82E8CBC0; continue 'dispatch;
	// 82E8CBB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8CBBC: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8CBC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8CBC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8CBC8: 4BFFFC89  bl 0x82e8c850
	ctx.lr = 0x82E8CBCC;
	sub_82E8C850(ctx, base);
	// 82E8CBCC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E8CBD0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CBD4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82E8CBD8: 80FE0018  lwz r7, 0x18(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8CBDC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E8CBE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E8CBE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E8CBE8: C00B7700  lfs f0, 0x7700(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8CBEC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82E8CBF0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8CBF4: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82E8CBF8: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8CBFC: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82E8CC00: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8CEA8 size=408
    let mut pc: u32 = 0x82E8CEA8;
    'dispatch: loop {
        match pc {
            0x82E8CEA8 => {
    //   block [0x82E8CEA8..0x82E8D040)
	// 82E8CEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CEAC: 4831B2B5  bl 0x831a8160
	ctx.lr = 0x82E8CEB0;
	sub_831A8130(ctx, base);
	// 82E8CEB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CEB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8CEB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CEBC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E8CEC0: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E8CEC4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CEC8: 816B0160  lwz r11, 0x160(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(352 as u32) ) } as u64;
	// 82E8CECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8CED0: 419A0164  beq cr6, 0x82e8d034
	if ctx.cr[6].eq {
	pc = 0x82E8D034; continue 'dispatch;
	}
	// 82E8CED4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8CED8: 5564143A  rlwinm r4, r11, 2, 0x10, 0x1d
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82E8CEDC: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 82E8CEE0: 480002D9  bl 0x82e8d1b8
	ctx.lr = 0x82E8CEE4;
	sub_82E8D1B8(ctx, base);
	// 82E8CEE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8CEE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8CEEC: 419A0148  beq cr6, 0x82e8d034
	if ctx.cr[6].eq {
	pc = 0x82E8D034; continue 'dispatch;
	}
	// 82E8CEF0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CEF4: 4BFF0BE5  bl 0x82e7dad8
	ctx.lr = 0x82E8CEF8;
	sub_82E7DAD8(ctx, base);
	// 82E8CEF8: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CEFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CF00: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8CF04: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82E8CF08: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8CF0C: 419A0024  beq cr6, 0x82e8cf30
	if ctx.cr[6].eq {
	pc = 0x82E8CF30; continue 'dispatch;
	}
	// 82E8CF10: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 82E8CF14: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82E8CF18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8CF1C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82E8CF20: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8CF24: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E8CF28: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8CF2C: 4082FFE8  bne 0x82e8cf14
	if !ctx.cr[0].eq {
	pc = 0x82E8CF14; continue 'dispatch;
	}
	// 82E8CF30: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8CF34: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 82E8CF38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82E8CF3C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E8CF40: 4B437521  bl 0x822c4460
	ctx.lr = 0x82E8CF44;
	sub_822C4460(ctx, base);
	// 82E8CF44: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CF48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8CF4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8CF50: A1090196  lhz r8, 0x196(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(406 as u32) ) } as u64;
	// 82E8CF54: A0E90194  lhz r7, 0x194(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E8CF58: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8CF5C: 7D060734  extsh r6, r8
	ctx.r[6].s64 = ctx.r[8].s16 as i64;
	// 82E8CF60: 7CEA0734  extsh r10, r7
	ctx.r[10].s64 = ctx.r[7].s16 as i64;
	// 82E8CF64: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 82E8CF68: 7D4407B4  extsw r4, r10
	ctx.r[4].s64 = ctx.r[10].s32 as i64;
	// 82E8CF6C: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82E8CF70: 7D0651D7  mullw. r8, r6, r10
	ctx.r[8].s64 = (ctx.r[6].s32 as i64) * (ctx.r[10].s32 as i64);
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E8CF74: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8CF78: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82E8CF7C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8CF80: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82E8CF84: FD406E9C  fcfid f10, f13
	ctx.f[10].f64 = (ctx.f[13].s64 as f64);
	// 82E8CF88: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E8CF8C: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E8CF90: ECE04824  fdivs f7, f0, f9
	ctx.f[7].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 82E8CF94: D0FF0028  stfs f7, 0x28(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E8CF98: ECC04024  fdivs f6, f0, f8
	ctx.f[6].f64 = ((ctx.f[0].f64 / ctx.f[8].f64) as f32) as f64;
	// 82E8CF9C: D0DF002C  stfs f6, 0x2c(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E8CFA0: 41820060  beq 0x82e8d000
	if ctx.cr[0].eq {
	pc = 0x82E8D000; continue 'dispatch;
	}
	// 82E8CFA4: 393F0034  addi r9, r31, 0x34
	ctx.r[9].s64 = ctx.r[31].s64 + 52;
	// 82E8CFA8: 7CEB5396  divwu r7, r11, r10
	ctx.r[7].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82E8CFAC: 7CCB5396  divwu r6, r11, r10
	ctx.r[6].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82E8CFB0: 7CA751D6  mullw r5, r7, r10
	ctx.r[5].s64 = (ctx.r[7].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82E8CFB4: 7C855850  subf r4, r5, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82E8CFB8: 78C30020  clrldi r3, r6, 0x20
	ctx.r[3].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 82E8CFBC: 78870020  clrldi r7, r4, 0x20
	ctx.r[7].u64 = ctx.r[4].u64 & 0x00000000FFFFFFFFu64;
	// 82E8CFC0: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82E8CFC4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8CFC8: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82E8CFCC: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E8CFD0: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 82E8CFD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8CFD8: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 82E8CFDC: 0CCA0000  twi 6, r10, 0
	// 82E8CFE0: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E8CFE4: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8CFE8: 0CCA0000  twi 6, r10, 0
	// 82E8CFEC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8CFF0: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E8CFF4: D129FFFC  stfs f9, -4(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E8CFF8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82E8CFFC: 4198FFAC  blt cr6, 0x82e8cfa8
	if ctx.cr[6].lt {
	pc = 0x82E8CFA8; continue 'dispatch;
	}
	// 82E8D000: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8D004: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E8D008: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8D00C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8D010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D014: 48002385  bl 0x82e8f398
	ctx.lr = 0x82E8D018;
	sub_82E8F398(ctx, base);
	// 82E8D018: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8D01C: 419A000C  beq cr6, 0x82e8d028
	if ctx.cr[6].eq {
	pc = 0x82E8D028; continue 'dispatch;
	}
	// 82E8D020: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8D024: 4B43386D  bl 0x822c0890
	ctx.lr = 0x82E8D028;
	sub_822C0890(ctx, base);
	// 82E8D028: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8D02C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8D030: 4831B180  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D034: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D038: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8D03C: 4831B174  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D040 size=92
    let mut pc: u32 = 0x82E8D040;
    'dispatch: loop {
        match pc {
            0x82E8D040 => {
    //   block [0x82E8D040..0x82E8D09C)
	// 82E8D040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D04C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D054: 4800054D  bl 0x82e8d5a0
	ctx.lr = 0x82E8D058;
	sub_82E8D5A0(ctx, base);
	// 82E8D058: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E8D05C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D060: 392AE248  addi r9, r10, -0x1db8
	ctx.r[9].s64 = ctx.r[10].s64 + -7608;
	// 82E8D064: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82E8D068: B17F0070  sth r11, 0x70(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D06C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D074: B11F0074  sth r8, 0x74(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[8].u16 ) };
	// 82E8D078: B17F0078  sth r11, 0x78(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u16 ) };
	// 82E8D07C: B17F007A  sth r11, 0x7a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[11].u16 ) };
	// 82E8D080: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82E8D084: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82E8D088: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D08C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D0A0 size=16
    let mut pc: u32 = 0x82E8D0A0;
    'dispatch: loop {
        match pc {
            0x82E8D0A0 => {
    //   block [0x82E8D0A0..0x82E8D0B0)
	// 82E8D0A0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E8D0A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D0A8: 916A695C  stw r11, 0x695c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(26972 as u32), ctx.r[11].u32 ) };
	// 82E8D0AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D0B0 size=64
    let mut pc: u32 = 0x82E8D0B0;
    'dispatch: loop {
        match pc {
            0x82E8D0B0 => {
    //   block [0x82E8D0B0..0x82E8D0F0)
	// 82E8D0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D0B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D0BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D0C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8D0C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D0C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8D0CC: 4E800421  bctrl
	ctx.lr = 0x82E8D0D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8D0D0: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82E8D0D4: 81696960  lwz r11, 0x6960(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26976 as u32) ) } as u64;
	// 82E8D0D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8D0DC: 91696960  stw r11, 0x6960(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(26976 as u32), ctx.r[11].u32 ) };
	// 82E8D0E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D0E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D0E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D0F0 size=16
    let mut pc: u32 = 0x82E8D0F0;
    'dispatch: loop {
        match pc {
            0x82E8D0F0 => {
    //   block [0x82E8D0F0..0x82E8D100)
	// 82E8D0F0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8D0F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E8D0F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8D0FC: 48002924  b 0x82e8fa20
	sub_82E8FA20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D100 size=92
    let mut pc: u32 = 0x82E8D100;
    'dispatch: loop {
        match pc {
            0x82E8D100 => {
    //   block [0x82E8D100..0x82E8D15C)
	// 82E8D100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D108: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D10C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D110: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D118: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D11C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D120: 394BE248  addi r10, r11, -0x1db8
	ctx.r[10].s64 = ctx.r[11].s64 + -7608;
	// 82E8D124: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8D128: 48000459  bl 0x82e8d580
	ctx.lr = 0x82E8D12C;
	sub_82E8D580(ctx, base);
	// 82E8D12C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8D130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8D138: 419A000C  beq cr6, 0x82e8d144
	if ctx.cr[6].eq {
	pc = 0x82E8D144; continue 'dispatch;
	}
	// 82E8D13C: 4B43312D  bl 0x822c0268
	ctx.lr = 0x82E8D140;
	sub_822C0268(ctx, base);
	// 82E8D140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D14C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D150: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D160 size=88
    let mut pc: u32 = 0x82E8D160;
    'dispatch: loop {
        match pc {
            0x82E8D160 => {
    //   block [0x82E8D160..0x82E8D1B8)
	// 82E8D160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D16C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D170: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E8D174: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82E8D178: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8D17C: 809F6954  lwz r4, 0x6954(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26964 as u32) ) } as u64;
	// 82E8D180: 4BF65009  bl 0x82df2188
	ctx.lr = 0x82E8D184;
	sub_82DF2188(ctx, base);
	// 82E8D184: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 82E8D188: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
	// 82E8D18C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D190: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8D194: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8D198: 917F6954  stw r11, 0x6954(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(26964 as u32), ctx.r[11].u32 ) };
	// 82E8D19C: 9148695C  stw r10, 0x695c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(26972 as u32), ctx.r[10].u32 ) };
	// 82E8D1A0: 91276958  stw r9, 0x6958(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(26968 as u32), ctx.r[9].u32 ) };
	// 82E8D1A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D1B8 size=348
    let mut pc: u32 = 0x82E8D1B8;
    'dispatch: loop {
        match pc {
            0x82E8D1B8 => {
    //   block [0x82E8D1B8..0x82E8D314)
	// 82E8D1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D1BC: 4831AFA5  bl 0x831a8160
	ctx.lr = 0x82E8D1C0;
	sub_831A8130(ctx, base);
	// 82E8D1C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D1C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D1C8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E8D1CC: 57DA043E  clrlwi r26, r30, 0x10
	ctx.r[26].u64 = ctx.r[30].u32 as u64 & 0x0000FFFFu64;
	// 82E8D1D0: 57EA0BFC  rlwinm r10, r31, 1, 0xf, 0x1e
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x7FFFFFFFu64;
	// 82E8D1D4: 1D7A001C  mulli r11, r26, 0x1c
	ctx.r[11].s64 = ctx.r[26].s64 * 28;
	// 82E8D1D8: 3BAB0090  addi r29, r11, 0x90
	ctx.r[29].s64 = ctx.r[11].s64 + 144;
	// 82E8D1DC: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82E8D1E0: 7D6AEA14  add r11, r10, r29
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82E8D1E4: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 82E8D1E8: 396B009F  addi r11, r11, 0x9f
	ctx.r[11].s64 = ctx.r[11].s64 + 159;
	// 82E8D1EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E8D1F0: 556A0036  rlwinm r10, r11, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8D1F4: 8169695C  lwz r11, 0x695c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26972 as u32) ) } as u64;
	// 82E8D1F8: 57FC043E  clrlwi r28, r31, 0x10
	ctx.r[28].u64 = ctx.r[31].u32 as u64 & 0x0000FFFFu64;
	// 82E8D1FC: 81086958  lwz r8, 0x6958(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26968 as u32) ) } as u64;
	// 82E8D200: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8D204: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8D208: 40990010  ble cr6, 0x82e8d218
	if !ctx.cr[6].gt {
	pc = 0x82E8D218; continue 'dispatch;
	}
	// 82E8D20C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D210: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D214: 4831AF9C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D218: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 82E8D21C: 9149695C  stw r10, 0x695c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(26972 as u32), ctx.r[10].u32 ) };
	// 82E8D220: 3CC08338  lis r6, -0x7cc8
	ctx.r[6].s64 = -2093481984;
	// 82E8D224: 81086954  lwz r8, 0x6954(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26964 as u32) ) } as u64;
	// 82E8D228: 80E66960  lwz r7, 0x6960(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(26976 as u32) ) } as u64;
	// 82E8D22C: 7C685A15  add. r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82E8D230: 39670001  addi r11, r7, 1
	ctx.r[11].s64 = ctx.r[7].s64 + 1;
	// 82E8D234: 91666960  stw r11, 0x6960(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(26976 as u32), ctx.r[11].u32 ) };
	// 82E8D238: 4182000C  beq 0x82e8d244
	if ctx.cr[0].eq {
	pc = 0x82E8D244; continue 'dispatch;
	}
	// 82E8D23C: 4BFFFE05  bl 0x82e8d040
	ctx.lr = 0x82E8D240;
	sub_82E8D040(ctx, base);
	// 82E8D240: 48000008  b 0x82e8d248
	pc = 0x82E8D248; continue 'dispatch;
	// 82E8D244: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D248: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 82E8D24C: B3C3007A  sth r30, 0x7a(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(122 as u32), ctx.r[30].u16 ) };
	// 82E8D250: B3E30078  sth r31, 0x78(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[31].u16 ) };
	// 82E8D254: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8D258: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82E8D25C: 7D63EA14  add r11, r3, r29
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[29].u64;
	// 82E8D260: 409A0008  bne cr6, 0x82e8d268
	if !ctx.cr[6].eq {
	pc = 0x82E8D268; continue 'dispatch;
	}
	// 82E8D264: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D268: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82E8D26C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D270: B3630074  sth r27, 0x74(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[27].u16 ) };
	// 82E8D274: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8D278: 419A0050  beq cr6, 0x82e8d2c8
	if ctx.cr[6].eq {
	pc = 0x82E8D2C8; continue 'dispatch;
	}
	// 82E8D27C: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82E8D280: 419A0034  beq cr6, 0x82e8d2b4
	if ctx.cr[6].eq {
	pc = 0x82E8D2B4; continue 'dispatch;
	}
	// 82E8D284: 2F1B0006  cmpwi cr6, r27, 6
	ctx.cr[6].compare_i32(ctx.r[27].s32, 6, &mut ctx.xer);
	// 82E8D288: 419A001C  beq cr6, 0x82e8d2a4
	if ctx.cr[6].eq {
	pc = 0x82E8D2A4; continue 'dispatch;
	}
	// 82E8D28C: 2F1B000D  cmpwi cr6, r27, 0xd
	ctx.cr[6].compare_i32(ctx.r[27].s32, 13, &mut ctx.xer);
	// 82E8D290: 409A0078  bne cr6, 0x82e8d308
	if !ctx.cr[6].eq {
	pc = 0x82E8D308; continue 'dispatch;
	}
	// 82E8D294: 578BF0BE  srwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8D298: B1630070  sth r11, 0x70(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D29C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D2A0: 4831AF10  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D2A4: 397CFFFE  addi r11, r28, -2
	ctx.r[11].s64 = ctx.r[28].s64 + -2;
	// 82E8D2A8: B1630070  sth r11, 0x70(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D2AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D2B0: 4831AF00  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D2B4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82E8D2B8: 7D7C5BD6  divw r11, r28, r11
	ctx.r[11].s32 = ctx.r[28].s32 / ctx.r[11].s32;
	// 82E8D2BC: B1630070  sth r11, 0x70(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D2C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D2C4: 4831AEEC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D2C8: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82E8D2CC: 419A0034  beq cr6, 0x82e8d300
	if ctx.cr[6].eq {
	pc = 0x82E8D300; continue 'dispatch;
	}
	// 82E8D2D0: 2F1B0006  cmpwi cr6, r27, 6
	ctx.cr[6].compare_i32(ctx.r[27].s32, 6, &mut ctx.xer);
	// 82E8D2D4: 419A001C  beq cr6, 0x82e8d2f0
	if ctx.cr[6].eq {
	pc = 0x82E8D2F0; continue 'dispatch;
	}
	// 82E8D2D8: 2F1B000D  cmpwi cr6, r27, 0xd
	ctx.cr[6].compare_i32(ctx.r[27].s32, 13, &mut ctx.xer);
	// 82E8D2DC: 409A002C  bne cr6, 0x82e8d308
	if !ctx.cr[6].eq {
	pc = 0x82E8D308; continue 'dispatch;
	}
	// 82E8D2E0: 574BF0BE  srwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8D2E4: B1630070  sth r11, 0x70(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D2E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D2EC: 4831AEC4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D2F0: 397AFFFE  addi r11, r26, -2
	ctx.r[11].s64 = ctx.r[26].s64 + -2;
	// 82E8D2F4: B1630070  sth r11, 0x70(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D2F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D2FC: 4831AEB4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E8D300: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82E8D304: 7D7A5BD6  divw r11, r26, r11
	ctx.r[11].s32 = ctx.r[26].s32 / ctx.r[11].s32;
	// 82E8D308: B1630070  sth r11, 0x70(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u16 ) };
	// 82E8D30C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D310: 4831AEA0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D318 size=140
    let mut pc: u32 = 0x82E8D318;
    'dispatch: loop {
        match pc {
            0x82E8D318 => {
    //   block [0x82E8D318..0x82E8D3A4)
	// 82E8D318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D31C: 4831AE49  bl 0x831a8164
	ctx.lr = 0x82E8D320;
	sub_831A8130(ctx, base);
	// 82E8D320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D324: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E8D328: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82E8D32C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D330: 809C6954  lwz r4, 0x6954(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26964 as u32) ) } as u64;
	// 82E8D334: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8D338: 4BF64E51  bl 0x82df2188
	ctx.lr = 0x82E8D33C;
	sub_82DF2188(ctx, base);
	// 82E8D33C: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E8D340: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8D344: 3FA08338  lis r29, -0x7cc8
	ctx.r[29].s64 = -2093481984;
	// 82E8D348: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D34C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8D350: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8D354: 917C6954  stw r11, 0x6954(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(26964 as u32), ctx.r[11].u32 ) };
	// 82E8D358: 915E695C  stw r10, 0x695c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(26972 as u32), ctx.r[10].u32 ) };
	// 82E8D35C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D360: 913D6958  stw r9, 0x6958(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(26968 as u32), ctx.r[9].u32 ) };
	// 82E8D364: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E8D368: 388BE254  addi r4, r11, -0x1dac
	ctx.r[4].s64 = ctx.r[11].s64 + -7596;
	// 82E8D36C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E8D370: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 82E8D374: 4BF64E8D  bl 0x82df2200
	ctx.lr = 0x82E8D378;
	sub_82DF2200(ctx, base);
	// 82E8D378: 907C6954  stw r3, 0x6954(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(26964 as u32), ctx.r[3].u32 ) };
	// 82E8D37C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D380: 409A000C  bne cr6, 0x82e8d38c
	if !ctx.cr[6].eq {
	pc = 0x82E8D38C; continue 'dispatch;
	}
	// 82E8D384: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8D388: 4831AE2C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 82E8D38C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D390: 93FD6958  stw r31, 0x6958(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(26968 as u32), ctx.r[31].u32 ) };
	// 82E8D394: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8D398: 917E695C  stw r11, 0x695c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(26972 as u32), ctx.r[11].u32 ) };
	// 82E8D39C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8D3A0: 4831AE14  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D3A8 size=16
    let mut pc: u32 = 0x82E8D3A8;
    'dispatch: loop {
        match pc {
            0x82E8D3A8 => {
    //   block [0x82E8D3A8..0x82E8D3B8)
	// 82E8D3A8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D3AC: 394BE290  addi r10, r11, -0x1d70
	ctx.r[10].s64 = ctx.r[11].s64 + -7536;
	// 82E8D3B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8D3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D3B8 size=224
    let mut pc: u32 = 0x82E8D3B8;
    'dispatch: loop {
        match pc {
            0x82E8D3B8 => {
    //   block [0x82E8D3B8..0x82E8D3F4)
	// 82E8D3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D3C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D3C4: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 82E8D3C8: 419900BC  bgt cr6, 0x82e8d484
	if ctx.cr[6].gt {
	pc = 0x82E8D484; continue 'dispatch;
	}
	// 82E8D3CC: 3D8082E9  lis r12, -0x7d17
	ctx.r[12].s64 = -2098659328;
	// 82E8D3D0: 398CD3E4  addi r12, r12, -0x2c1c
	ctx.r[12].s64 = ctx.r[12].s64 + -11292;
	// 82E8D3D4: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82E8D3D8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82E8D3DC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82E8D3E0: 4E800420  bctr
	match ctx.r[4].u64 {
		0 => {
	pc = 0x82E8D3F4; continue 'dispatch;
		},
		1 => {
	pc = 0x82E8D418; continue 'dispatch;
		},
		2 => {
	pc = 0x82E8D43C; continue 'dispatch;
		},
		3 => {
	pc = 0x82E8D460; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82E8D3E4: 82E8D3F4  lwz r23, -0x2c0c(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11276 as u32) ) } as u64;
	// 82E8D3E8: 82E8D418  lwz r23, -0x2be8(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11240 as u32) ) } as u64;
	// 82E8D3EC: 82E8D43C  lwz r23, -0x2bc4(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11204 as u32) ) } as u64;
	// 82E8D3F0: 82E8D460  lwz r23, -0x2ba0(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11168 as u32) ) } as u64;
            }
            0x82E8D3F4 => {
    //   block [0x82E8D3F4..0x82E8D418)
	// 82E8D3F4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82E8D3F8: 4BF64FC9  bl 0x82df23c0
	ctx.lr = 0x82E8D3FC;
	sub_82DF23C0(ctx, base);
	// 82E8D3FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D400: 419A0084  beq cr6, 0x82e8d484
	if ctx.cr[6].eq {
	pc = 0x82E8D484; continue 'dispatch;
	}
	// 82E8D404: 48003F2D  bl 0x82e91330
	ctx.lr = 0x82E8D408;
	sub_82E91330(ctx, base);
	// 82E8D408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D40C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D414: 4E800020  blr
	return;
            }
            0x82E8D418 => {
    //   block [0x82E8D418..0x82E8D43C)
	// 82E8D418: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82E8D41C: 4BF64FA5  bl 0x82df23c0
	ctx.lr = 0x82E8D420;
	sub_82DF23C0(ctx, base);
	// 82E8D420: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D424: 419A0060  beq cr6, 0x82e8d484
	if ctx.cr[6].eq {
	pc = 0x82E8D484; continue 'dispatch;
	}
	// 82E8D428: 48003971  bl 0x82e90d98
	ctx.lr = 0x82E8D42C;
	sub_82E90D98(ctx, base);
	// 82E8D42C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D438: 4E800020  blr
	return;
            }
            0x82E8D43C => {
    //   block [0x82E8D43C..0x82E8D460)
	// 82E8D43C: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82E8D440: 4BF64F81  bl 0x82df23c0
	ctx.lr = 0x82E8D444;
	sub_82DF23C0(ctx, base);
	// 82E8D444: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D448: 419A003C  beq cr6, 0x82e8d484
	if ctx.cr[6].eq {
	pc = 0x82E8D484; continue 'dispatch;
	}
	// 82E8D44C: 4800301D  bl 0x82e90468
	ctx.lr = 0x82E8D450;
	sub_82E90468(ctx, base);
	// 82E8D450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D45C: 4E800020  blr
	return;
            }
            0x82E8D460 => {
    //   block [0x82E8D460..0x82E8D498)
	// 82E8D460: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82E8D464: 4BF64F5D  bl 0x82df23c0
	ctx.lr = 0x82E8D468;
	sub_82DF23C0(ctx, base);
	// 82E8D468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D46C: 419A0018  beq cr6, 0x82e8d484
	if ctx.cr[6].eq {
	pc = 0x82E8D484; continue 'dispatch;
	}
	// 82E8D470: 48002851  bl 0x82e8fcc0
	ctx.lr = 0x82E8D474;
	sub_82E8FCC0(ctx, base);
	// 82E8D474: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D47C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D480: 4E800020  blr
	return;
	// 82E8D484: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D48C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D498 size=72
    let mut pc: u32 = 0x82E8D498;
    'dispatch: loop {
        match pc {
            0x82E8D498 => {
    //   block [0x82E8D498..0x82E8D4E0)
	// 82E8D498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D4A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D4A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D4A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D4AC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D4B0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82E8D4B4: 392BE290  addi r9, r11, -0x1d70
	ctx.r[9].s64 = ctx.r[11].s64 + -7536;
	// 82E8D4B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8D4BC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D4C0: 419A000C  beq cr6, 0x82e8d4cc
	if ctx.cr[6].eq {
	pc = 0x82E8D4CC; continue 'dispatch;
	}
	// 82E8D4C4: 4BF64F15  bl 0x82df23d8
	ctx.lr = 0x82E8D4C8;
	sub_82DF23D8(ctx, base);
	// 82E8D4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D4CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D4D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D4D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D4D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D4DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D4E0 size=32
    let mut pc: u32 = 0x82E8D4E0;
    'dispatch: loop {
        match pc {
            0x82E8D4E0 => {
    //   block [0x82E8D4E0..0x82E8D500)
	// 82E8D4E0: 548B463E  srwi r11, r4, 0x18
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(24);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8D4E4: 98830003  stb r4, 3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(3 as u32), ctx.r[4].u8 ) };
	// 82E8D4E8: 548A863E  rlwinm r10, r4, 0x10, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 82E8D4EC: 5489C63E  rlwinm r9, r4, 0x18, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82E8D4F0: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82E8D4F4: 99430001  stb r10, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 82E8D4F8: 99230002  stb r9, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 82E8D4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8D500 size=92
    let mut pc: u32 = 0x82E8D500;
    'dispatch: loop {
        match pc {
            0x82E8D500 => {
    //   block [0x82E8D500..0x82E8D55C)
	// 82E8D500: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82E8D504: C00BC3C8  lfs f0, -0x3c38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8D508: EDA20032  fmuls f13, f2, f0
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8D50C: ED830032  fmuls f12, f3, f0
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8D510: ED640032  fmuls f11, f4, f0
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8D514: ED410032  fmuls f10, f1, f0
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8D518: FD206E5E  fctidz f9, f13
	ctx.f[9].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82E8D51C: D921FFF0  stfd f9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[9].u64 ) };
	// 82E8D520: 8941FFF7  lbz r10, -9(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 82E8D524: FD00665E  fctidz f8, f12
	ctx.f[8].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82E8D528: D901FFF0  stfd f8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[8].u64 ) };
	// 82E8D52C: 8921FFF7  lbz r9, -9(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 82E8D530: FCE05E5E  fctidz f7, f11
	ctx.f[7].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82E8D534: D8E1FFF0  stfd f7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[7].u64 ) };
	// 82E8D538: 8901FFF7  lbz r8, -9(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 82E8D53C: FCC0565E  fctidz f6, f10
	ctx.f[6].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82E8D540: D8C1FFF0  stfd f6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[6].u64 ) };
	// 82E8D544: 88E1FFF7  lbz r7, -9(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 82E8D548: 98E30000  stb r7, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 82E8D54C: 99430001  stb r10, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 82E8D550: 99230002  stb r9, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 82E8D554: 99030003  stb r8, 3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 82E8D558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D560 size=8
    let mut pc: u32 = 0x82E8D560;
    'dispatch: loop {
        match pc {
            0x82E8D560 => {
    //   block [0x82E8D560..0x82E8D568)
	// 82E8D560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D564: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D568 size=20
    let mut pc: u32 = 0x82E8D568;
    'dispatch: loop {
        match pc {
            0x82E8D568 => {
    //   block [0x82E8D568..0x82E8D57C)
	// 82E8D568: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D56C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8D570: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D574: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8D578: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D57C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D57C size=4
    let mut pc: u32 = 0x82E8D57C;
    'dispatch: loop {
        match pc {
            0x82E8D57C => {
    //   block [0x82E8D57C..0x82E8D580)
	// 82E8D57C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D580 size=24
    let mut pc: u32 = 0x82E8D580;
    'dispatch: loop {
        match pc {
            0x82E8D580 => {
    //   block [0x82E8D580..0x82E8D598)
	// 82E8D580: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D584: 394BE298  addi r10, r11, -0x1d68
	ctx.r[10].s64 = ctx.r[11].s64 + -7528;
	// 82E8D588: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8D58C: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8D590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D594: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D598 size=8
    let mut pc: u32 = 0x82E8D598;
    'dispatch: loop {
        match pc {
            0x82E8D598 => {
    //   block [0x82E8D598..0x82E8D5A0)
	// 82E8D598: 4B4332F8  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 82E8D59C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8D5A0 size=120
    let mut pc: u32 = 0x82E8D5A0;
    'dispatch: loop {
        match pc {
            0x82E8D5A0 => {
    //   block [0x82E8D5A0..0x82E8D618)
	// 82E8D5A0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D5A4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E8D5A8: 392BE298  addi r9, r11, -0x1d68
	ctx.r[9].s64 = ctx.r[11].s64 + -7528;
	// 82E8D5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D5B0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D5B4: 38CA6880  addi r6, r10, 0x6880
	ctx.r[6].s64 = ctx.r[10].s64 + 26752;
	// 82E8D5B8: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E8D5BC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8D5C0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E8D5C4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E8D5C8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E8D5CC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E8D5D0: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 82E8D5D4: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D5D8: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82E8D5DC: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D5E0: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D5E4: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D618 size=104
    let mut pc: u32 = 0x82E8D618;
    'dispatch: loop {
        match pc {
            0x82E8D618 => {
    //   block [0x82E8D618..0x82E8D680)
	// 82E8D618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D62C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D630: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D634: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D638: 394BE298  addi r10, r11, -0x1d68
	ctx.r[10].s64 = ctx.r[11].s64 + -7528;
	// 82E8D63C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8D640: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8D644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D648: 419A0008  beq cr6, 0x82e8d650
	if ctx.cr[6].eq {
	pc = 0x82E8D650; continue 'dispatch;
	}
	// 82E8D64C: 4B433245  bl 0x822c0890
	ctx.lr = 0x82E8D650;
	sub_822C0890(ctx, base);
	// 82E8D650: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8D654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D65C: 419A000C  beq cr6, 0x82e8d668
	if ctx.cr[6].eq {
	pc = 0x82E8D668; continue 'dispatch;
	}
	// 82E8D660: 4B432C09  bl 0x822c0268
	ctx.lr = 0x82E8D664;
	sub_822C0268(ctx, base);
	// 82E8D664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D66C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D674: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D678: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D680 size=132
    let mut pc: u32 = 0x82E8D680;
    'dispatch: loop {
        match pc {
            0x82E8D680 => {
    //   block [0x82E8D680..0x82E8D704)
	// 82E8D680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D68C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D698: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D69C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D6A0: 394BE2A4  addi r10, r11, -0x1d5c
	ctx.r[10].s64 = ctx.r[11].s64 + -7516;
	// 82E8D6A4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8D6A8: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E8D6AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D6B0: 419A0008  beq cr6, 0x82e8d6b8
	if ctx.cr[6].eq {
	pc = 0x82E8D6B8; continue 'dispatch;
	}
	// 82E8D6B4: 4B4331DD  bl 0x822c0890
	ctx.lr = 0x82E8D6B8;
	sub_822C0890(ctx, base);
	// 82E8D6B8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D6BC: 394BE298  addi r10, r11, -0x1d68
	ctx.r[10].s64 = ctx.r[11].s64 + -7528;
	// 82E8D6C0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8D6C4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8D6C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D6CC: 419A0008  beq cr6, 0x82e8d6d4
	if ctx.cr[6].eq {
	pc = 0x82E8D6D4; continue 'dispatch;
	}
	// 82E8D6D0: 4B4331C1  bl 0x822c0890
	ctx.lr = 0x82E8D6D4;
	sub_822C0890(ctx, base);
	// 82E8D6D4: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8D6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D6E0: 419A000C  beq cr6, 0x82e8d6ec
	if ctx.cr[6].eq {
	pc = 0x82E8D6EC; continue 'dispatch;
	}
	// 82E8D6E4: 4B432B85  bl 0x822c0268
	ctx.lr = 0x82E8D6E8;
	sub_822C0268(ctx, base);
	// 82E8D6E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D6EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D6F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D6FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D708 size=160
    let mut pc: u32 = 0x82E8D708;
    'dispatch: loop {
        match pc {
            0x82E8D708 => {
    //   block [0x82E8D708..0x82E8D7A8)
	// 82E8D708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D70C: 4831AA51  bl 0x831a815c
	ctx.lr = 0x82E8D710;
	sub_831A8130(ctx, base);
	// 82E8D710: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8D718: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E8D71C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E8D720: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E8D724: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E8D728: 838B015C  lwz r28, 0x15c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(348 as u32) ) } as u64;
	// 82E8D72C: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D730: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8D734: 419A006C  beq cr6, 0x82e8d7a0
	if ctx.cr[6].eq {
	pc = 0x82E8D7A0; continue 'dispatch;
	}
	// 82E8D738: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8D73C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D740: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8D744: 419A0024  beq cr6, 0x82e8d768
	if ctx.cr[6].eq {
	pc = 0x82E8D768; continue 'dispatch;
	}
	// 82E8D748: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82E8D74C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E8D750: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8D754: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E8D758: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8D75C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E8D760: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8D764: 4082FFE8  bne 0x82e8d74c
	if !ctx.cr[0].eq {
	pc = 0x82E8D74C; continue 'dispatch;
	}
	// 82E8D768: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D76C: 419A0018  beq cr6, 0x82e8d784
	if ctx.cr[6].eq {
	pc = 0x82E8D784; continue 'dispatch;
	}
	// 82E8D770: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82E8D774: 80FD0070  lwz r7, 0x70(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E8D778: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E8D77C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8D780: 48001129  bl 0x82e8e8a8
	ctx.lr = 0x82E8D784;
	sub_82E8E8A8(ctx, base);
	// 82E8D784: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8D788: 419A000C  beq cr6, 0x82e8d794
	if ctx.cr[6].eq {
	pc = 0x82E8D794; continue 'dispatch;
	}
	// 82E8D78C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8D790: 4B433101  bl 0x822c0890
	ctx.lr = 0x82E8D794;
	sub_822C0890(ctx, base);
	// 82E8D794: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D798: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8D79C: 409AFF9C  bne cr6, 0x82e8d738
	if !ctx.cr[6].eq {
	pc = 0x82E8D738; continue 'dispatch;
	}
	// 82E8D7A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D7A4: 4831AA08  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D7A8 size=28
    let mut pc: u32 = 0x82E8D7A8;
    'dispatch: loop {
        match pc {
            0x82E8D7A8 => {
    //   block [0x82E8D7A8..0x82E8D7C4)
	// 82E8D7A8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D7AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8D7B0: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82E8D7B4: 394B0070  addi r10, r11, 0x70
	ctx.r[10].s64 = ctx.r[11].s64 + 112;
	// 82E8D7B8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82E8D7BC: 912B0070  stw r9, 0x70(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82E8D7C0: 4B436CA0  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8D7C8 size=200
    let mut pc: u32 = 0x82E8D7C8;
    'dispatch: loop {
        match pc {
            0x82E8D7C8 => {
    //   block [0x82E8D7C8..0x82E8D890)
	// 82E8D7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D7CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D7D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D7D4: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 82E8D7D8: 4B433161  bl 0x822c0938
	ctx.lr = 0x82E8D7DC;
	sub_822C0938(ctx, base);
	// 82E8D7DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D7E0: 419A009C  beq cr6, 0x82e8d87c
	if ctx.cr[6].eq {
	pc = 0x82E8D87C; continue 'dispatch;
	}
	// 82E8D7E4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D7E8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E8D7EC: 392BE298  addi r9, r11, -0x1d68
	ctx.r[9].s64 = ctx.r[11].s64 + -7528;
	// 82E8D7F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D7F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D7F8: 38CA6880  addi r6, r10, 0x6880
	ctx.r[6].s64 = ctx.r[10].s64 + 26752;
	// 82E8D7FC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E8D800: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8D804: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E8D808: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E8D80C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E8D810: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E8D814: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 82E8D818: 3C808212  lis r4, -0x7dee
	ctx.r[4].s64 = -2112749568;
	// 82E8D81C: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D820: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D824: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82E8D828: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D82C: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8D830: 38C4E2A4  addi r6, r4, -0x1d5c
	ctx.r[6].s64 = ctx.r[4].s64 + -7516;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D890 size=36
    let mut pc: u32 = 0x82E8D890;
    'dispatch: loop {
        match pc {
            0x82E8D890 => {
    //   block [0x82E8D890..0x82E8D8B4)
	// 82E8D890: 814300C8  lwz r10, 0xc8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8D894: 396300C0  addi r11, r3, 0xc0
	ctx.r[11].s64 = ctx.r[3].s64 + 192;
	// 82E8D898: 812300CC  lwz r9, 0xcc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 82E8D89C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8D8A0: 40990014  ble cr6, 0x82e8d8b4
	if !ctx.cr[6].gt {
		sub_82E8D8B4(ctx, base);
		return;
	}
	// 82E8D8A4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D8A8: 7D4A4050  subf r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82E8D8AC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8D8B0: 48000008  b 0x82e8d8b8
	sub_82E8D8B4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D8B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D8B4 size=12
    let mut pc: u32 = 0x82E8D8B4;
    'dispatch: loop {
        match pc {
            0x82E8D8B4 => {
    //   block [0x82E8D8B4..0x82E8D8C0)
	// 82E8D8B4: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82E8D8B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8D8BC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D8C0 size=16
    let mut pc: u32 = 0x82E8D8C0;
    'dispatch: loop {
        match pc {
            0x82E8D8C0 => {
    //   block [0x82E8D8C0..0x82E8D8D0)
	// 82E8D8C0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8D8C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D8C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8D8CC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8D8D0 size=28
    let mut pc: u32 = 0x82E8D8D0;
    'dispatch: loop {
        match pc {
            0x82E8D8D0 => {
    //   block [0x82E8D8D0..0x82E8D8EC)
	// 82E8D8D0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D8D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8D8D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8D8DC: 41980008  blt cr6, 0x82e8d8e4
	if ctx.cr[6].lt {
	pc = 0x82E8D8E4; continue 'dispatch;
	}
	// 82E8D8E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8D8E4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E8D8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8D8F0 size=116
    let mut pc: u32 = 0x82E8D8F0;
    'dispatch: loop {
        match pc {
            0x82E8D8F0 => {
    //   block [0x82E8D8F0..0x82E8D964)
	// 82E8D8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D8F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D8FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D904: 48003E25  bl 0x82e91728
	ctx.lr = 0x82E8D908;
	sub_82E91728(ctx, base);
	// 82E8D908: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8D90C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8D910: 392BE2E0  addi r9, r11, -0x1d20
	ctx.r[9].s64 = ctx.r[11].s64 + -7456;
	// 82E8D914: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D918: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D920: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82E8D924: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82E8D928: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8D92C: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82E8D930: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82E8D934: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82E8D938: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82E8D93C: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82E8D940: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82E8D944: 997F00E0  stb r11, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 82E8D948: 997F00E1  stb r11, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[11].u8 ) };
	// 82E8D94C: 997F00E2  stb r11, 0xe2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(226 as u32), ctx.r[11].u8 ) };
	// 82E8D950: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D95C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8D968 size=188
    let mut pc: u32 = 0x82E8D968;
    'dispatch: loop {
        match pc {
            0x82E8D968 => {
    //   block [0x82E8D968..0x82E8DA24)
	// 82E8D968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D96C: 4831A7FD  bl 0x831a8168
	ctx.lr = 0x82E8D970;
	sub_831A8130(ctx, base);
	// 82E8D970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D978: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E8D97C: 48003F65  bl 0x82e918e0
	ctx.lr = 0x82E8D980;
	sub_82E918E0(ctx, base);
	// 82E8D980: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8D984: C01D00A0  lfs f0, 0xa0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8D988: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82E8D98C: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8D990: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8D994: 40980008  bge cr6, 0x82e8d99c
	if !ctx.cr[6].lt {
	pc = 0x82E8D99C; continue 'dispatch;
	}
	// 82E8D998: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82E8D99C: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82E8D9A0: 817D00A4  lwz r11, 0xa4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(164 as u32) ) } as u64;
	// 82E8D9A4: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82E8D9A8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82E8D9AC: 40980008  bge cr6, 0x82e8d9b4
	if !ctx.cr[6].lt {
	pc = 0x82E8D9B4; continue 'dispatch;
	}
	// 82E8D9B0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82E8D9B4: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82E8D9B8: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82E8D9BC: 817D00C8  lwz r11, 0xc8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8D9C0: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82E8D9C4: 995F00E1  stb r10, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[10].u8 ) };
	// 82E8D9C8: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82E8D9CC: 3BCB0002  addi r30, r11, 2
	ctx.r[30].s64 = ctx.r[11].s64 + 2;
	// 82E8D9D0: 809F00C0  lwz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8D9D4: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8D9D8: 4BF647B1  bl 0x82df2188
	ctx.lr = 0x82E8D9DC;
	sub_82DF2188(ctx, base);
	// 82E8D9DC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8D9E0: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8D9E4: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82E8D9E8: 7D1E5A14  add r8, r30, r11
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82E8D9EC: 3889E2B0  addi r4, r9, -0x1d50
	ctx.r[4].s64 = ctx.r[9].s64 + -7504;
	// 82E8D9F0: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E8D9F4: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 82E8D9F8: 4BF646D1  bl 0x82df20c8
	ctx.lr = 0x82E8D9FC;
	sub_82DF20C8(ctx, base);
	// 82E8D9FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8DA00: 907F00C0  stw r3, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u32 ) };
	// 82E8DA04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8DA08: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82E8DA0C: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82E8DA10: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 82E8DA14: 88FD01A5  lbz r7, 0x1a5(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(421 as u32) ) } as u64;
	// 82E8DA18: 98FF00E2  stb r7, 0xe2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(226 as u32), ctx.r[7].u8 ) };
	// 82E8DA1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8DA20: 4831A798  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8DA28 size=52
    let mut pc: u32 = 0x82E8DA28;
    'dispatch: loop {
        match pc {
            0x82E8DA28 => {
    //   block [0x82E8DA28..0x82E8DA5C)
	// 82E8DA28: 816300CC  lwz r11, 0xcc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 82E8DA2C: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8DA30: 812300C4  lwz r9, 0xc4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E8DA34: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8DA38: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82E8DA3C: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8DA40: 394300C0  addi r10, r3, 0xc0
	ctx.r[10].s64 = ctx.r[3].s64 + 192;
	// 82E8DA44: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8DA48: 41980008  blt cr6, 0x82e8da50
	if ctx.cr[6].lt {
	pc = 0x82E8DA50; continue 'dispatch;
	}
	// 82E8DA4C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E8DA50: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8DA54: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8DA58: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DA5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8DA5C size=40
    let mut pc: u32 = 0x82E8DA5C;
    'dispatch: loop {
        match pc {
            0x82E8DA5C => {
    //   block [0x82E8DA5C..0x82E8DA84)
	// 82E8DA5C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E8DA60: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DA64: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82E8DA68: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8DA6C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8DA70: D00B0000  stfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8DA74: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8DA78: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8DA7C: 90EA000C  stw r7, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82E8DA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8DA88 size=40
    let mut pc: u32 = 0x82E8DA88;
    'dispatch: loop {
        match pc {
            0x82E8DA88 => {
    //   block [0x82E8DA88..0x82E8DAB0)
	// 82E8DA88: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8DA8C: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8DA90: 814300CC  lwz r10, 0xcc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 82E8DA94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8DA98: C02908A4  lfs f1, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8DA9C: 40990014  ble cr6, 0x82e8dab0
	if !ctx.cr[6].gt {
		sub_82E8DAB0(ctx, base);
		return;
	}
	// 82E8DAA0: 812300C4  lwz r9, 0xc4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E8DAA4: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82E8DAA8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8DAAC: 48000008  b 0x82e8dab4
	sub_82E8DAB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8DAB0 size=196
    let mut pc: u32 = 0x82E8DAB0;
    'dispatch: loop {
        match pc {
            0x82E8DAB0 => {
    //   block [0x82E8DAB0..0x82E8DB74)
	// 82E8DAB0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E8DAB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8DAB8: 409900B4  ble cr6, 0x82e8db6c
	if !ctx.cr[6].gt {
	pc = 0x82E8DB6C; continue 'dispatch;
	}
	// 82E8DABC: 816300CC  lwz r11, 0xcc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 82E8DAC0: 814300C8  lwz r10, 0xc8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8DAC4: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E8DAC8: 80C300C0  lwz r6, 0xc0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8DACC: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82E8DAD0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82E8DAD4: 7D0A3A14  add r8, r10, r7
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82E8DAD8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8DADC: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8DAE0: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82E8DAE4: 7D0A3214  add r8, r10, r6
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 82E8DAE8: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8DAEC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8DAF0: 419A007C  beq cr6, 0x82e8db6c
	if ctx.cr[6].eq {
	pc = 0x82E8DB6C; continue 'dispatch;
	}
	// 82E8DAF4: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E8DAF8: 54C7003E  slwi r7, r6, 0
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82E8DAFC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8DB00: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8DB04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8DB08: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82E8DB0C: 392BFFF4  addi r9, r11, -0xc
	ctx.r[9].s64 = ctx.r[11].s64 + -12;
	// 82E8DB10: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8DB14: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82E8DB18: 419A0008  beq cr6, 0x82e8db20
	if ctx.cr[6].eq {
	pc = 0x82E8DB20; continue 'dispatch;
	}
	// 82E8DB1C: 396A000C  addi r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 + 12;
	// 82E8DB20: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8DB24: 419A003C  beq cr6, 0x82e8db60
	if ctx.cr[6].eq {
	pc = 0x82E8DB60; continue 'dispatch;
	}
	// 82E8DB28: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8DB2C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8DB30: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8DB34: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8DB38: C14A0008  lfs f10, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8DB3C: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8DB40: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8DB44: C0EA0000  lfs f7, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E8DB48: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E8DB4C: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E8DB50: EC892A7A  fmadds f4, f9, f9, f5
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 82E8DB54: EC6621BA  fmadds f3, f6, f6, f4
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64);
	// 82E8DB58: EC40182C  fsqrts f2, f3
	ctx.f[2].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 82E8DB5C: EC22082A  fadds f1, f2, f1
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[1].f64) as f32) as f64;
	// 82E8DB60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E8DB64: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E8DB68: 409AFFA8  bne cr6, 0x82e8db10
	if !ctx.cr[6].eq {
	pc = 0x82E8DB10; continue 'dispatch;
	}
	// 82E8DB6C: D02300D8  stfs f1, 0xd8(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82E8DB70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8DB78 size=112
    let mut pc: u32 = 0x82E8DB78;
    'dispatch: loop {
        match pc {
            0x82E8DB78 => {
    //   block [0x82E8DB78..0x82E8DBE8)
	// 82E8DB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8DB80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8DB84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8DB88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DB8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8DB90: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8DB94: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82E8DB98: 392BE2E0  addi r9, r11, -0x1d20
	ctx.r[9].s64 = ctx.r[11].s64 + -7456;
	// 82E8DB9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8DBA0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8DBA4: 809F00C0  lwz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8DBA8: 806A110C  lwz r3, 0x110c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E8DBAC: 4BF645DD  bl 0x82df2188
	ctx.lr = 0x82E8DBB0;
	sub_82DF2188(ctx, base);
	// 82E8DBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8DBB4: 48003A55  bl 0x82e91608
	ctx.lr = 0x82E8DBB8;
	sub_82E91608(ctx, base);
	// 82E8DBB8: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8DBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8DBC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E8DBC4: 419A000C  beq cr6, 0x82e8dbd0
	if ctx.cr[6].eq {
	pc = 0x82E8DBD0; continue 'dispatch;
	}
	// 82E8DBC8: 4BF64811  bl 0x82df23d8
	ctx.lr = 0x82E8DBCC;
	sub_82DF23D8(ctx, base);
	// 82E8DBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8DBD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8DBD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8DBD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8DBDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8DBE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8DBE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8DBE8 size=584
    let mut pc: u32 = 0x82E8DBE8;
    'dispatch: loop {
        match pc {
            0x82E8DBE8 => {
    //   block [0x82E8DBE8..0x82E8DE30)
	// 82E8DBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8DBF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DBF4: C00300DC  lfs f0, 0xdc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8DBF8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8DBFC: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82E8DC00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8DC04: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8DC08: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82E8DC0C: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82E8DC10: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82E8DC14: 41980008  blt cr6, 0x82e8dc1c
	if ctx.cr[6].lt {
	pc = 0x82E8DC1C; continue 'dispatch;
	}
	// 82E8DC18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8DC1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E8DC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC24: 409A01CC  bne cr6, 0x82e8ddf0
	if !ctx.cr[6].eq {
	pc = 0x82E8DDF0; continue 'dispatch;
	}
	// 82E8DC28: D02300DC  stfs f1, 0xdc(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82E8DC2C: 4BFFFE5D  bl 0x82e8da88
	ctx.lr = 0x82E8DC30;
	sub_82E8DA88(ctx, base);
	// 82E8DC30: 896300E1  lbz r11, 0xe1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(225 as u32) ) } as u64;
	// 82E8DC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC38: 419A00D4  beq cr6, 0x82e8dd0c
	if ctx.cr[6].eq {
	pc = 0x82E8DD0C; continue 'dispatch;
	}
	// 82E8DC3C: C00300D4  lfs f0, 0xd4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8DC40: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82E8DC44: 419800BC  blt cr6, 0x82e8dd00
	if ctx.cr[6].lt {
	pc = 0x82E8DD00; continue 'dispatch;
	}
	// 82E8DC48: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8DC4C: 814300CC  lwz r10, 0xcc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 82E8DC50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8DC54: 40990014  ble cr6, 0x82e8dc68
	if !ctx.cr[6].gt {
	pc = 0x82E8DC68; continue 'dispatch;
	}
	// 82E8DC58: 812300C4  lwz r9, 0xc4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E8DC5C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82E8DC60: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8DC64: 48000008  b 0x82e8dc6c
	pc = 0x82E8DC6C; continue 'dispatch;
	// 82E8DC68: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E8DC6C: 814300D0  lwz r10, 0xd0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 82E8DC70: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8DC74: 41990008  bgt cr6, 0x82e8dc7c
	if ctx.cr[6].gt {
	pc = 0x82E8DC7C; continue 'dispatch;
	}
	// 82E8DC78: 4BFFFC19  bl 0x82e8d890
	ctx.lr = 0x82E8DC7C;
	sub_82E8D890(ctx, base);
	// 82E8DC7C: 896300E0  lbz r11, 0xe0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 82E8DC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC84: 409A0010  bne cr6, 0x82e8dc94
	if !ctx.cr[6].eq {
	pc = 0x82E8DC94; continue 'dispatch;
	}
	// 82E8DC88: 4BFFFDA1  bl 0x82e8da28
	ctx.lr = 0x82E8DC8C;
	sub_82E8DA28(ctx, base);
	// 82E8DC8C: 4BFFFD9D  bl 0x82e8da28
	ctx.lr = 0x82E8DC90;
	sub_82E8DA28(ctx, base);
	// 82E8DC90: 98A300E0  stb r5, 0xe0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[5].u8 ) };
	// 82E8DC94: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 82E8DC98: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8DE30 size=12
    let mut pc: u32 = 0x82E8DE30;
    'dispatch: loop {
        match pc {
            0x82E8DE30 => {
    //   block [0x82E8DE30..0x82E8DE3C)
	// 82E8DE30: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8DE34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8DE38: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8DE3C size=20
    let mut pc: u32 = 0x82E8DE3C;
    'dispatch: loop {
        match pc {
            0x82E8DE3C => {
    //   block [0x82E8DE3C..0x82E8DE50)
	// 82E8DE3C: 806300C0  lwz r3, 0xc0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8DE40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DE44: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8DE48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8DE4C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8DE50 size=4
    let mut pc: u32 = 0x82E8DE50;
    'dispatch: loop {
        match pc {
            0x82E8DE50 => {
    //   block [0x82E8DE50..0x82E8DE54)
	// 82E8DE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8DE58 size=12
    let mut pc: u32 = 0x82E8DE58;
    'dispatch: loop {
        match pc {
            0x82E8DE58 => {
    //   block [0x82E8DE58..0x82E8DE64)
	// 82E8DE58: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8DE5C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82E8DE60: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8DE64 size=20
    let mut pc: u32 = 0x82E8DE64;
    'dispatch: loop {
        match pc {
            0x82E8DE64 => {
    //   block [0x82E8DE64..0x82E8DE78)
	// 82E8DE64: 806300C0  lwz r3, 0xc0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8DE68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DE6C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8DE70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8DE74: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8DE78 size=4
    let mut pc: u32 = 0x82E8DE78;
    'dispatch: loop {
        match pc {
            0x82E8DE78 => {
    //   block [0x82E8DE78..0x82E8DE7C)
	// 82E8DE78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8DE80 size=332
    let mut pc: u32 = 0x82E8DE80;
    'dispatch: loop {
        match pc {
            0x82E8DE80 => {
    //   block [0x82E8DE80..0x82E8DFCC)
	// 82E8DE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8DE88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8DE8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8DE90: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8DE98: 814500C8  lwz r10, 0xc8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8DE9C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82E8DEA0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82E8DEA4: 55481FFE  rlwinm r8, r10, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82E8DEA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E8DEAC: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8DFD0 size=88
    let mut pc: u32 = 0x82E8DFD0;
    'dispatch: loop {
        match pc {
            0x82E8DFD0 => {
    //   block [0x82E8DFD0..0x82E8E028)
	// 82E8DFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8DFD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8DFDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DFE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8DFE4: 48003745  bl 0x82e91728
	ctx.lr = 0x82E8DFE8;
	sub_82E91728(ctx, base);
	// 82E8DFE8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8DFEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8DFF0: 392BE310  addi r9, r11, -0x1cf0
	ctx.r[9].s64 = ctx.r[11].s64 + -7408;
	// 82E8DFF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8DFF8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8DFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E000: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82E8E004: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E008: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82E8E00C: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82E8E010: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82E8E014: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8E018: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8E01C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8E020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8E024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8E028 size=112
    let mut pc: u32 = 0x82E8E028;
    'dispatch: loop {
        match pc {
            0x82E8E028 => {
    //   block [0x82E8E028..0x82E8E098)
	// 82E8E028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8E030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8E034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8E038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E03C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E040: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8E044: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8E048: 394BE310  addi r10, r11, -0x1cf0
	ctx.r[10].s64 = ctx.r[11].s64 + -7408;
	// 82E8E04C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8E050: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E8E054: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8E058: 419A0008  beq cr6, 0x82e8e060
	if ctx.cr[6].eq {
	pc = 0x82E8E060; continue 'dispatch;
	}
	// 82E8E05C: 4B432835  bl 0x822c0890
	ctx.lr = 0x82E8E060;
	sub_822C0890(ctx, base);
	// 82E8E060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E064: 480035A5  bl 0x82e91608
	ctx.lr = 0x82E8E068;
	sub_82E91608(ctx, base);
	// 82E8E068: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8E06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E074: 419A000C  beq cr6, 0x82e8e080
	if ctx.cr[6].eq {
	pc = 0x82E8E080; continue 'dispatch;
	}
	// 82E8E078: 4BF64361  bl 0x82df23d8
	ctx.lr = 0x82E8E07C;
	sub_82DF23D8(ctx, base);
	// 82E8E07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8E084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8E088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8E08C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8E090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8E094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E098 size=320
    let mut pc: u32 = 0x82E8E098;
    'dispatch: loop {
        match pc {
            0x82E8E098 => {
    //   block [0x82E8E098..0x82E8E1D8)
	// 82E8E098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E09C: 4831A0C9  bl 0x831a8164
	ctx.lr = 0x82E8E0A0;
	sub_831A8130(ctx, base);
	// 82E8E0A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E0A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8E0A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8E0AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E8E0B0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E8E0B4: 4800382D  bl 0x82e918e0
	ctx.lr = 0x82E8E0B8;
	sub_82E918E0(ctx, base);
	// 82E8E0B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E0BC: 4BFEFA0D  bl 0x82e7dac8
	ctx.lr = 0x82E8E0C0;
	sub_82E7DAC8(ctx, base);
	// 82E8E0C0: 907E00C8  stw r3, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[3].u32 ) };
	// 82E8E0C4: 817C00E0  lwz r11, 0xe0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) } as u64;
	// 82E8E0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E0CC: 419A0100  beq cr6, 0x82e8e1cc
	if ctx.cr[6].eq {
	pc = 0x82E8E1CC; continue 'dispatch;
	}
	// 82E8E0D0: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 82E8E0D4: 4BF642ED  bl 0x82df23c0
	ctx.lr = 0x82E8E0D8;
	sub_82DF23C0(ctx, base);
	// 82E8E0D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8E0DC: 419A0010  beq cr6, 0x82e8e0ec
	if ctx.cr[6].eq {
	pc = 0x82E8E0EC; continue 'dispatch;
	}
	// 82E8E0E0: 4BFF2F41  bl 0x82e81020
	ctx.lr = 0x82E8E0E4;
	sub_82E81020(ctx, base);
	// 82E8E0E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E0E8: 48000008  b 0x82e8e0f0
	pc = 0x82E8E0F0; continue 'dispatch;
	// 82E8E0EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8E0F0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E8E0F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8E0F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E8E0FC: 4BFF6CDD  bl 0x82e84dd8
	ctx.lr = 0x82E8E100;
	sub_82E84DD8(ctx, base);
	// 82E8E100: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E8E104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8E108: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E8E10C: 4B431EF5  bl 0x822c0000
	ctx.lr = 0x82E8E110;
	sub_822C0000(ctx, base);
	// 82E8E110: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E8E114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8E118: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8E11C: 80BC00E0  lwz r5, 0xe0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) } as u64;
	// 82E8E120: 4BFF6E81  bl 0x82e84fa0
	ctx.lr = 0x82E8E124;
	sub_82E84FA0(ctx, base);
	// 82E8E124: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8E128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E12C: 419A0090  beq cr6, 0x82e8e1bc
	if ctx.cr[6].eq {
	pc = 0x82E8E1BC; continue 'dispatch;
	}
	// 82E8E130: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8E134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E138: 419A0084  beq cr6, 0x82e8e1bc
	if ctx.cr[6].eq {
	pc = 0x82E8E1BC; continue 'dispatch;
	}
	// 82E8E13C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E140: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E8E144: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E8E148: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8E14C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E8E150: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8E154: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8E158: 4E800421  bctrl
	ctx.lr = 0x82E8E15C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8E15C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8E160: 395E00C0  addi r10, r30, 0xc0
	ctx.r[10].s64 = ctx.r[30].s64 + 192;
	// 82E8E164: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82E8E168: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82E8E16C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E170: 913E00C0  stw r9, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 82E8E174: 4B4362ED  bl 0x822c4460
	ctx.lr = 0x82E8E178;
	sub_822C4460(ctx, base);
	// 82E8E178: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8E17C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8E180: 419A0008  beq cr6, 0x82e8e188
	if ctx.cr[6].eq {
	pc = 0x82E8E188; continue 'dispatch;
	}
	// 82E8E184: 4B43270D  bl 0x822c0890
	ctx.lr = 0x82E8E188;
	sub_822C0890(ctx, base);
	// 82E8E188: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E18C: 4BFEF93D  bl 0x82e7dac8
	ctx.lr = 0x82E8E190;
	sub_82E7DAC8(ctx, base);
	// 82E8E190: 907E00C8  stw r3, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[3].u32 ) };
	// 82E8E194: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E198: 4BFEF939  bl 0x82e7dad0
	ctx.lr = 0x82E8E19C;
	sub_82E7DAD0(ctx, base);
	// 82E8E19C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8E1A0: D03E00CC  stfs f1, 0xcc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82E8E1A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1A8: 419A0008  beq cr6, 0x82e8e1b0
	if ctx.cr[6].eq {
	pc = 0x82E8E1B0; continue 'dispatch;
	}
	// 82E8E1AC: 4B4326E5  bl 0x822c0890
	ctx.lr = 0x82E8E1B0;
	sub_822C0890(ctx, base);
	// 82E8E1B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8E1B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8E1B8: 48319FFC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 82E8E1BC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8E1C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1C4: 419A0008  beq cr6, 0x82e8e1cc
	if ctx.cr[6].eq {
	pc = 0x82E8E1CC; continue 'dispatch;
	}
	// 82E8E1C8: 4B4326C9  bl 0x822c0890
	ctx.lr = 0x82E8E1CC;
	sub_822C0890(ctx, base);
	// 82E8E1CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8E1D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8E1D4: 48319FE0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8E1D8 size=16
    let mut pc: u32 = 0x82E8E1D8;
    'dispatch: loop {
        match pc {
            0x82E8E1D8 => {
    //   block [0x82E8E1D8..0x82E8E1E8)
	// 82E8E1D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8E1DC: 806B0140  lwz r3, 0x140(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 82E8E1E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E1E8 size=52
    let mut pc: u32 = 0x82E8E1E8;
    'dispatch: loop {
        match pc {
            0x82E8E1E8 => {
    //   block [0x82E8E1E8..0x82E8E21C)
	// 82E8E1E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8E1EC: 55490000  rlwinm r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8E1F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1F4: 409A0034  bne cr6, 0x82e8e228
	if !ctx.cr[6].eq {
		sub_82E8E228(ctx, base);
		return;
	}
	// 82E8E1F8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8E1FC: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E200: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8E204: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8E208: 419A0014  beq cr6, 0x82e8e21c
	if ctx.cr[6].eq {
		sub_82E8E21C(ctx, base);
		return;
	}
	// 82E8E20C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82E8E210: C00AFB3C  lfs f0, -0x4c4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E214: EC406828  fsubs f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E218: 48000018  b 0x82e8e230
	sub_82E8E228(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E21C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E21C size=12
    let mut pc: u32 = 0x82E8E21C;
    'dispatch: loop {
        match pc {
            0x82E8E21C => {
    //   block [0x82E8E21C..0x82E8E228)
	// 82E8E21C: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E220: EC406828  fsubs f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E224: 4800000C  b 0x82e8e230
	sub_82E8E228(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E228 size=24
    let mut pc: u32 = 0x82E8E228;
    'dispatch: loop {
        match pc {
            0x82E8E228 => {
    //   block [0x82E8E228..0x82E8E240)
	// 82E8E228: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E22C: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E8E230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E234: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E8E238: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8E23C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8E240 size=4
    let mut pc: u32 = 0x82E8E240;
    'dispatch: loop {
        match pc {
            0x82E8E240 => {
    //   block [0x82E8E240..0x82E8E244)
	// 82E8E240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E248 size=220
    let mut pc: u32 = 0x82E8E248;
    'dispatch: loop {
        match pc {
            0x82E8E248 => {
    //   block [0x82E8E248..0x82E8E324)
	// 82E8E248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8E250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8E254: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E25C: 480034CD  bl 0x82e91728
	ctx.lr = 0x82E8E260;
	sub_82E91728(ctx, base);
	// 82E8E260: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E8E264: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E8E268: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82E8E26C: 390000D0  li r8, 0xd0
	ctx.r[8].s64 = 208;
	// 82E8E270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8E274: 38EAE340  addi r7, r10, -0x1cc0
	ctx.r[7].s64 = ctx.r[10].s64 + -7360;
	// 82E8E278: 38C000E0  li r6, 0xe0
	ctx.r[6].s64 = 224;
	// 82E8E27C: 997F00C0  stb r11, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 82E8E280: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E8E284: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E8E288: 3C808332  lis r4, -0x7cce
	ctx.r[4].s64 = -2093875200;
	// 82E8E28C: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E328 size=124
    let mut pc: u32 = 0x82E8E328;
    'dispatch: loop {
        match pc {
            0x82E8E328 => {
    //   block [0x82E8E328..0x82E8E3A4)
	// 82E8E328: C00300D4  lfs f0, 0xd4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E32C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E8E330: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8E334: C18300D0  lfs f12, 0xd0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E338: C16300D8  lfs f11, 0xd8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E33C: 396300D0  addi r11, r3, 0xd0
	ctx.r[11].s64 = ctx.r[3].s64 + 208;
	// 82E8E340: C00ADFB0  lfs f0, -0x2050(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E344: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E8E348: ED4C6B3A  fmadds f10, f12, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8E34C: ED2B52FA  fmadds f9, f11, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E8E350: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82E8E354: 41980008  blt cr6, 0x82e8e35c
	if ctx.cr[6].lt {
	pc = 0x82E8E35C; continue 'dispatch;
	}
	// 82E8E358: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8E35C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82E8E360: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8E364: 409A0034  bne cr6, 0x82e8e398
	if !ctx.cr[6].eq {
	pc = 0x82E8E398; continue 'dispatch;
	}
	// 82E8E368: C00300E0  lfs f0, 0xe0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E36C: C1A300E4  lfs f13, 0xe4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E370: C18300E8  lfs f12, 0xe8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E374: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E378: C14300D4  lfs f10, 0xd4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8E37C: ED2102FA  fmadds f9, f1, f11, f0
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E380: C10300D8  lfs f8, 0xd8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8E384: ECEA687A  fmadds f7, f10, f1, f13
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8E388: ECC8607A  fmadds f6, f8, f1, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E8E38C: D12300E0  stfs f9, 0xe0(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82E8E390: D0E300E4  stfs f7, 0xe4(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82E8E394: D0C300E8  stfs f6, 0xe8(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82E8E398: 896300C0  lbz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E8E39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E3A0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E3A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8E3A4 size=8
    let mut pc: u32 = 0x82E8E3A4;
    'dispatch: loop {
        match pc {
            0x82E8E3A4 => {
    //   block [0x82E8E3A4..0x82E8E3AC)
	// 82E8E3A4: 4BFFFE34  b 0x82e8e1d8
	sub_82E8E1D8(ctx, base);
	return;
	// 82E8E3A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E3B0 size=1268
    let mut pc: u32 = 0x82E8E3B0;
    'dispatch: loop {
        match pc {
            0x82E8E3B0 => {
    //   block [0x82E8E3B0..0x82E8E8A4)
	// 82E8E3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E3B4: 48319DA9  bl 0x831a815c
	ctx.lr = 0x82E8E3B8;
	sub_831A8130(ctx, base);
	// 82E8E3B8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82E8E3BC: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E3C0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E8E3C4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E8E3C8: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 82E8E3CC: 3BCB6880  addi r30, r11, 0x6880
	ctx.r[30].s64 = ctx.r[11].s64 + 26752;
	// 82E8E3D0: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 82E8E3D4: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 82E8E3D8: 815D00C8  lwz r10, 0xc8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8E3DC: 39210170  addi r9, r1, 0x170
	ctx.r[9].s64 = ctx.r[1].s64 + 368;
	// 82E8E3E0: 39010180  addi r8, r1, 0x180
	ctx.r[8].s64 = ctx.r[1].s64 + 384;
	// 82E8E3E4: 38E10190  addi r7, r1, 0x190
	ctx.r[7].s64 = ctx.r[1].s64 + 400;
	// 82E8E3E8: 13E0F407  vcmpneb. (lvlx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8E3EC: 38C101A0  addi r6, r1, 0x1a0
	ctx.r[6].s64 = ctx.r[1].s64 + 416;
	// 82E8E3F0: 13DAF407  vcmpneb. (lvlx128) v30, v26, v30
	tmp.u32 = ctx.r[26].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8E3F4: 55451FFE  rlwinm r5, r10, 3, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82E8E3F8: 13BBF407  vcmpneb. (lvlx128) v29, v27, v30
	tmp.u32 = ctx.r[27].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8E3FC: 139CF407  vcmpneb. (lvlx128) v28, v28, v30
	tmp.u32 = ctx.r[28].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8E400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E404: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E8A8 size=604
    let mut pc: u32 = 0x82E8E8A8;
    'dispatch: loop {
        match pc {
            0x82E8E8A8 => {
    //   block [0x82E8E8A8..0x82E8EB04)
	// 82E8E8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E8AC: 483198AD  bl 0x831a8158
	ctx.lr = 0x82E8E8B0;
	sub_831A8130(ctx, base);
	// 82E8E8B0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82E8E8B4: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E8B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E8BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8E8C0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E8E8C4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E8E8C8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E8E8CC: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82E8E8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E8D4: 419A0224  beq cr6, 0x82e8eaf8
	if ctx.cr[6].eq {
	pc = 0x82E8EAF8; continue 'dispatch;
	}
	// 82E8E8D8: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E8E8DC: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E8E0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82E8E8E4: 556A0528  rlwinm r10, r11, 0, 0x14, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E8E8E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E8EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8E8F0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E8E8F4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8E8F8: 419A0020  beq cr6, 0x82e8e918
	if ctx.cr[6].eq {
	pc = 0x82E8E918; continue 'dispatch;
	}
	// 82E8E8FC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8E900: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8E904: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E908: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E8E90C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8EB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8EB08 size=144
    let mut pc: u32 = 0x82E8EB08;
    'dispatch: loop {
        match pc {
            0x82E8EB08 => {
    //   block [0x82E8EB08..0x82E8EB98)
	// 82E8EB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8EB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8EB10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8EB14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8EB18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8EB1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8EB20: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8EB24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8EB28: 394BE340  addi r10, r11, -0x1cc0
	ctx.r[10].s64 = ctx.r[11].s64 + -7360;
	// 82E8EB2C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82E8EB30: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8EB34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8EB38: 419A0018  beq cr6, 0x82e8eb50
	if ctx.cr[6].eq {
	pc = 0x82E8EB50; continue 'dispatch;
	}
	// 82E8EB3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EB40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8EB44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EB48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8EB4C: 4E800421  bctrl
	ctx.lr = 0x82E8EB50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8EB50: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82E8EB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8EB58: 419A0008  beq cr6, 0x82e8eb60
	if ctx.cr[6].eq {
	pc = 0x82E8EB60; continue 'dispatch;
	}
	// 82E8EB5C: 4B431D35  bl 0x822c0890
	ctx.lr = 0x82E8EB60;
	sub_822C0890(ctx, base);
	// 82E8EB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EB64: 48002AA5  bl 0x82e91608
	ctx.lr = 0x82E8EB68;
	sub_82E91608(ctx, base);
	// 82E8EB68: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8EB6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8EB74: 419A000C  beq cr6, 0x82e8eb80
	if ctx.cr[6].eq {
	pc = 0x82E8EB80; continue 'dispatch;
	}
	// 82E8EB78: 4BF63861  bl 0x82df23d8
	ctx.lr = 0x82E8EB7C;
	sub_82DF23D8(ctx, base);
	// 82E8EB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EB80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8EB84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8EB88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8EB8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8EB90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8EB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8EB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8EB98 size=1576
    let mut pc: u32 = 0x82E8EB98;
    'dispatch: loop {
        match pc {
            0x82E8EB98 => {
    //   block [0x82E8EB98..0x82E8F1C0)
	// 82E8EB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8EB9C: 483195B9  bl 0x831a8154
	ctx.lr = 0x82E8EBA0;
	sub_831A8130(ctx, base);
	// 82E8EBA0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82E8EBA4: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 82E8EBA8: 4831C06D  bl 0x831aac14
	ctx.lr = 0x82E8EBAC;
	sub_831AA9A0(ctx, base);
	// 82E8EBAC: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8EBB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8EBB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8EBB8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E8EBBC: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82E8EBC0: 48002D21  bl 0x82e918e0
	ctx.lr = 0x82E8EBC4;
	sub_82E918E0(ctx, base);
	// 82E8EBC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8EBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8EBCC: 419A05DC  beq cr6, 0x82e8f1a8
	if ctx.cr[6].eq {
	pc = 0x82E8F1A8; continue 'dispatch;
	}
	// 82E8EBD0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EBD4: 39400180  li r10, 0x180
	ctx.r[10].s64 = 384;
	// 82E8EBD8: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 82E8EBDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8EBE0: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82E8EBE4: 13FA50C7  vcmpequd (lvx128) v31, v26, v10
	tmp.u32 = ctx.r[26].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F1C0 size=60
    let mut pc: u32 = 0x82E8F1C0;
    'dispatch: loop {
        match pc {
            0x82E8F1C0 => {
    //   block [0x82E8F1C0..0x82E8F1FC)
	// 82E8F1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F1C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8F1CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F1D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8F1D4: 48002555  bl 0x82e91728
	ctx.lr = 0x82E8F1D8;
	sub_82E91728(ctx, base);
	// 82E8F1D8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8F1DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F1E0: 394BE370  addi r10, r11, -0x1c90
	ctx.r[10].s64 = ctx.r[11].s64 + -7312;
	// 82E8F1E4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8F1E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F1EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F1F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F200 size=92
    let mut pc: u32 = 0x82E8F200;
    'dispatch: loop {
        match pc {
            0x82E8F200 => {
    //   block [0x82E8F200..0x82E8F25C)
	// 82E8F200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8F20C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8F210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8F218: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8F21C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8F220: 394BE370  addi r10, r11, -0x1c90
	ctx.r[10].s64 = ctx.r[11].s64 + -7312;
	// 82E8F224: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8F228: 480023E1  bl 0x82e91608
	ctx.lr = 0x82E8F22C;
	sub_82E91608(ctx, base);
	// 82E8F22C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8F230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F234: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8F238: 419A000C  beq cr6, 0x82e8f244
	if ctx.cr[6].eq {
	pc = 0x82E8F244; continue 'dispatch;
	}
	// 82E8F23C: 4BF6319D  bl 0x82df23d8
	ctx.lr = 0x82E8F240;
	sub_82DF23D8(ctx, base);
	// 82E8F240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8F248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F24C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F250: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8F254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F260 size=36
    let mut pc: u32 = 0x82E8F260;
    'dispatch: loop {
        match pc {
            0x82E8F260 => {
    //   block [0x82E8F260..0x82E8F284)
	// 82E8F260: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8F264: 2B030005  cmplwi cr6, r3, 5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 5 as u32, &mut ctx.xer);
	// 82E8F268: 41990074  bgt cr6, 0x82e8f2dc
	if ctx.cr[6].gt {
		sub_82E8F2D8(ctx, base);
		return;
	}
	// 82E8F26C: 3D8082E9  lis r12, -0x7d17
	ctx.r[12].s64 = -2098659328;
	// 82E8F270: 398CF284  addi r12, r12, -0xd7c
	ctx.r[12].s64 = ctx.r[12].s64 + -3452;
	// 82E8F274: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82E8F278: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82E8F27C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82E8F280: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
			// ERROR: 0x82E8F29C
			return;
		},
		1 => {
			// ERROR: 0x82E8F2A8
			return;
		},
		2 => {
			// ERROR: 0x82E8F2B4
			return;
		},
		3 => {
			// ERROR: 0x82E8F2C0
			return;
		},
		4 => {
			// ERROR: 0x82E8F2CC
			return;
		},
		5 => {
			// ERROR: 0x82E8F2D8
			return;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F284(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F284 size=36
    let mut pc: u32 = 0x82E8F284;
    'dispatch: loop {
        match pc {
            0x82E8F284 => {
    //   block [0x82E8F284..0x82E8F2A8)
	// 82E8F284: 82E8F29C  lwz r23, -0xd64(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-3428 as u32) ) } as u64;
	// 82E8F288: 82E8F2A8  lwz r23, -0xd58(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-3416 as u32) ) } as u64;
	// 82E8F28C: 82E8F2B4  lwz r23, -0xd4c(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-3404 as u32) ) } as u64;
	// 82E8F290: 82E8F2C0  lwz r23, -0xd40(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-3392 as u32) ) } as u64;
	// 82E8F294: 82E8F2CC  lwz r23, -0xd34(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-3380 as u32) ) } as u64;
	// 82E8F298: 82E8F2D8  lwz r23, -0xd28(r8)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-3368 as u32) ) } as u64;
	// 82E8F29C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8F2A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8F2A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F2A8 size=12
    let mut pc: u32 = 0x82E8F2A8;
    'dispatch: loop {
        match pc {
            0x82E8F2A8 => {
    //   block [0x82E8F2A8..0x82E8F2B4)
	// 82E8F2A8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82E8F2AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8F2B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F2B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F2B4 size=12
    let mut pc: u32 = 0x82E8F2B4;
    'dispatch: loop {
        match pc {
            0x82E8F2B4 => {
    //   block [0x82E8F2B4..0x82E8F2C0)
	// 82E8F2B4: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82E8F2B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8F2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F2C0 size=12
    let mut pc: u32 = 0x82E8F2C0;
    'dispatch: loop {
        match pc {
            0x82E8F2C0 => {
    //   block [0x82E8F2C0..0x82E8F2CC)
	// 82E8F2C0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82E8F2C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8F2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F2CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F2CC size=12
    let mut pc: u32 = 0x82E8F2CC;
    'dispatch: loop {
        match pc {
            0x82E8F2CC => {
    //   block [0x82E8F2CC..0x82E8F2D8)
	// 82E8F2CC: 39600019  li r11, 0x19
	ctx.r[11].s64 = 25;
	// 82E8F2D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8F2D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F2D8 size=12
    let mut pc: u32 = 0x82E8F2D8;
    'dispatch: loop {
        match pc {
            0x82E8F2D8 => {
    //   block [0x82E8F2D8..0x82E8F2E4)
	// 82E8F2D8: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	// 82E8F2DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8F2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F2E8 size=60
    let mut pc: u32 = 0x82E8F2E8;
    'dispatch: loop {
        match pc {
            0x82E8F2E8 => {
    //   block [0x82E8F2E8..0x82E8F324)
	// 82E8F2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F2F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8F2F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F2F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8F2FC: 48003A6D  bl 0x82e92d68
	ctx.lr = 0x82E8F300;
	sub_82E92D68(ctx, base);
	// 82E8F300: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8F304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F308: 394BE3A0  addi r10, r11, -0x1c60
	ctx.r[10].s64 = ctx.r[11].s64 + -7264;
	// 82E8F30C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8F310: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F314: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F318: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F31C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F328 size=16
    let mut pc: u32 = 0x82E8F328;
    'dispatch: loop {
        match pc {
            0x82E8F328 => {
    //   block [0x82E8F328..0x82E8F338)
	// 82E8F328: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8F32C: 394BE3A0  addi r10, r11, -0x1c60
	ctx.r[10].s64 = ctx.r[11].s64 + -7264;
	// 82E8F330: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8F334: 48003A34  b 0x82e92d68
	sub_82E92D68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F338 size=92
    let mut pc: u32 = 0x82E8F338;
    'dispatch: loop {
        match pc {
            0x82E8F338 => {
    //   block [0x82E8F338..0x82E8F394)
	// 82E8F338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8F344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8F348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F34C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8F350: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8F354: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8F358: 394BE3A0  addi r10, r11, -0x1c60
	ctx.r[10].s64 = ctx.r[11].s64 + -7264;
	// 82E8F35C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8F360: 48003A09  bl 0x82e92d68
	ctx.lr = 0x82E8F364;
	sub_82E92D68(ctx, base);
	// 82E8F364: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8F368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F36C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8F370: 419A000C  beq cr6, 0x82e8f37c
	if ctx.cr[6].eq {
	pc = 0x82E8F37C; continue 'dispatch;
	}
	// 82E8F374: 4BF63065  bl 0x82df23d8
	ctx.lr = 0x82E8F378;
	sub_82DF23D8(ctx, base);
	// 82E8F378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F37C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8F380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8F38C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F398 size=1672
    let mut pc: u32 = 0x82E8F398;
    'dispatch: loop {
        match pc {
            0x82E8F398 => {
    //   block [0x82E8F398..0x82E8FA20)
	// 82E8F398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F39C: 48318D95  bl 0x831a8130
	ctx.lr = 0x82E8F3A0;
	sub_831A8130(ctx, base);
	// 82E8F3A0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82E8F3A4: 483196C9  bl 0x831a8a6c
	ctx.lr = 0x82E8F3A8;
	sub_831A8A40(ctx, base);
	// 82E8F3A8: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8FA20 size=424
    let mut pc: u32 = 0x82E8FA20;
    'dispatch: loop {
        match pc {
            0x82E8FA20 => {
    //   block [0x82E8FA20..0x82E8FBC8)
	// 82E8FA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FA24: 48318745  bl 0x831a8168
	ctx.lr = 0x82E8FA28;
	sub_831A8130(ctx, base);
	// 82E8FA28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FA2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8FA30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8FA34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8FA38: 419A0188  beq cr6, 0x82e8fbc0
	if ctx.cr[6].eq {
	pc = 0x82E8FBC0; continue 'dispatch;
	}
	// 82E8FA3C: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8FA40: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8FA44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8FA48: 419A0024  beq cr6, 0x82e8fa6c
	if ctx.cr[6].eq {
	pc = 0x82E8FA6C; continue 'dispatch;
	}
	// 82E8FA4C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82E8FA50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E8FA54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8FA58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E8FA5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8FA60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E8FA64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E8FA68: 4082FFE8  bne 0x82e8fa50
	if !ctx.cr[0].eq {
	pc = 0x82E8FA50; continue 'dispatch;
	}
	// 82E8FA6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8FA70: 419A0140  beq cr6, 0x82e8fbb0
	if ctx.cr[6].eq {
	pc = 0x82E8FBB0; continue 'dispatch;
	}
	// 82E8FA74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8FA78: 4BF6ED69  bl 0x82dfe7e0
	ctx.lr = 0x82E8FA7C;
	sub_82DFE7E0(ctx, base);
	// 82E8FA7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8FA80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FA84: 419A012C  beq cr6, 0x82e8fbb0
	if ctx.cr[6].eq {
	pc = 0x82E8FBB0; continue 'dispatch;
	}
	// 82E8FA88: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8FA8C: 88DF0060  lbz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E8FA90: 389F0064  addi r4, r31, 0x64
	ctx.r[4].s64 = ctx.r[31].s64 + 100;
	// 82E8FA94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8FA98: 4BFEEFF9  bl 0x82e7ea90
	ctx.lr = 0x82E8FA9C;
	sub_82E7EA90(ctx, base);
	// 82E8FA9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8FAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FAA4: 419A010C  beq cr6, 0x82e8fbb0
	if ctx.cr[6].eq {
	pc = 0x82E8FBB0; continue 'dispatch;
	}
	// 82E8FAA8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8FAAC: 4BFF50CD  bl 0x82e84b78
	ctx.lr = 0x82E8FAB0;
	sub_82E84B78(ctx, base);
	// 82E8FAB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8FAB4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FAB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FABC: 409A0018  bne cr6, 0x82e8fad4
	if !ctx.cr[6].eq {
	pc = 0x82E8FAD4; continue 'dispatch;
	}
	// 82E8FAC0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8FAC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FAC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E8FACC: 388BE3B0  addi r4, r11, -0x1c50
	ctx.r[4].s64 = ctx.r[11].s64 + -7248;
	// 82E8FAD0: 4BF7F699  bl 0x82e0f168
	ctx.lr = 0x82E8FAD4;
	sub_82E0F168(ctx, base);
	// 82E8FAD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FAD8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FADC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FAE0: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E8FAE4: 419A0010  beq cr6, 0x82e8faf4
	if ctx.cr[6].eq {
	pc = 0x82E8FAF4; continue 'dispatch;
	}
	// 82E8FAE8: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82E8FAEC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FAF0: 4BD48DE1  bl 0x82bd88d0
	ctx.lr = 0x82E8FAF4;
	sub_82BD88D0(ctx, base);
	// 82E8FAF4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8FAF8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FAFC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82E8FB00: 4BF7F959  bl 0x82e0f458
	ctx.lr = 0x82E8FB04;
	sub_82E0F458(ctx, base);
	// 82E8FB04: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82E8FB08: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FB0C: 4BF7F9ED  bl 0x82e0f4f8
	ctx.lr = 0x82E8FB10;
	sub_82E0F4F8(ctx, base);
	// 82E8FB10: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E8FB14: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E8FB18: 419A0058  beq cr6, 0x82e8fb70
	if ctx.cr[6].eq {
	pc = 0x82E8FB70; continue 'dispatch;
	}
	// 82E8FB1C: 3960001C  li r11, 0x1c
	ctx.r[11].s64 = 28;
	// 82E8FB20: A15F0074  lhz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E8FB24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E8FB28: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8FB2C: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 82E8FB30: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FB34: 396909A8  addi r11, r9, 0x9a8
	ctx.r[11].s64 = ctx.r[9].s64 + 2472;
	// 82E8FB38: A0FF0070  lhz r7, 0x70(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E8FB3C: 549E1838  slwi r30, r4, 3
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82E8FB40: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82E8FB44: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 82E8FB48: A0DF007A  lhz r6, 0x7a(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82E8FB4C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82E8FB50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8FB54: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FB58: 7FFE582E  lwzx r31, r30, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8FB5C: 7D7EE82E  lwzx r11, r30, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E8FB60: 7CFF39D6  mullw r7, r31, r7
	ctx.r[7].s64 = (ctx.r[31].s32 as i64) * (ctx.r[7].s32 as i64);
	// 82E8FB64: 7CE75A14  add r7, r7, r11
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82E8FB68: 4BD4E2E9  bl 0x82bdde50
	ctx.lr = 0x82E8FB6C;
	sub_82BDDE50(ctx, base);
	// 82E8FB6C: 48000044  b 0x82e8fbb0
	pc = 0x82E8FBB0; continue 'dispatch;
	// 82E8FB70: A17F0074  lhz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E8FB74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8FB78: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FB7C: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 82E8FB80: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 82E8FB84: A13F0070  lhz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E8FB88: 396A09A8  addi r11, r10, 0x9a8
	ctx.r[11].s64 = ctx.r[10].s64 + 2472;
	// 82E8FB8C: 80DF0080  lwz r6, 0x80(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82E8FB90: 54851838  slwi r5, r4, 3
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82E8FB94: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82E8FB98: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FB9C: 7D05582E  lwzx r8, r5, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8FBA0: 7D65502E  lwzx r11, r5, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8FBA4: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82E8FBA8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E8FBAC: 4BD4DD3D  bl 0x82bdd8e8
	ctx.lr = 0x82E8FBB0;
	sub_82BDD8E8(ctx, base);
	// 82E8FBB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8FBB4: 419A000C  beq cr6, 0x82e8fbc0
	if ctx.cr[6].eq {
	pc = 0x82E8FBC0; continue 'dispatch;
	}
	// 82E8FBB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8FBBC: 4B430CD5  bl 0x822c0890
	ctx.lr = 0x82E8FBC0;
	sub_822C0890(ctx, base);
	// 82E8FBC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8FBC4: 483185F4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8FBC8 size=44
    let mut pc: u32 = 0x82E8FBC8;
    'dispatch: loop {
        match pc {
            0x82E8FBC8 => {
    //   block [0x82E8FBC8..0x82E8FBF4)
	// 82E8FBC8: 39660030  addi r11, r6, 0x30
	ctx.r[11].s64 = ctx.r[6].s64 + 48;
	// 82E8FBCC: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 82E8FBD0: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82E8FBD4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E8FBD8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FBDC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E8FBE0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8FBE4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E8FBE8: 4200FFF0  bdnz 0x82e8fbd8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E8FBD8; continue 'dispatch;
	}
	// 82E8FBEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8FBF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8FBF8 size=196
    let mut pc: u32 = 0x82E8FBF8;
    'dispatch: loop {
        match pc {
            0x82E8FBF8 => {
    //   block [0x82E8FBF8..0x82E8FCBC)
	// 82E8FBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8FC00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8FC04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8FC08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FC0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8FC10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8FC14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E8FC18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8FC1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8FC20: 4B430D19  bl 0x822c0938
	ctx.lr = 0x82E8FC24;
	sub_822C0938(ctx, base);
	// 82E8FC24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8FC28: 419A0028  beq cr6, 0x82e8fc50
	if ctx.cr[6].eq {
	pc = 0x82E8FC50; continue 'dispatch;
	}
	// 82E8FC2C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8FC30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82E8FC34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E8FC38: 392BE180  addi r9, r11, -0x1e80
	ctx.r[9].s64 = ctx.r[11].s64 + -7808;
	// 82E8FC3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8FC40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8FC44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8FC48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E8FC4C: 48000008  b 0x82e8fc54
	pc = 0x82E8FC54; continue 'dispatch;
	// 82E8FC50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8FC54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8FC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FC5C: 409A0044  bne cr6, 0x82e8fca0
	if !ctx.cr[6].eq {
	pc = 0x82E8FCA0; continue 'dispatch;
	}
	// 82E8FC60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8FC64: 419A001C  beq cr6, 0x82e8fc80
	if ctx.cr[6].eq {
	pc = 0x82E8FC80; continue 'dispatch;
	}
	// 82E8FC68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FC6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8FC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FC74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FC78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8FC7C: 4E800421  bctrl
	ctx.lr = 0x82E8FC80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8FC80: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E8FC84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8FC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8FC8C: 392A0828  addi r9, r10, 0x828
	ctx.r[9].s64 = ctx.r[10].s64 + 2088;
	// 82E8FC90: 816BBBD4  lwz r11, -0x442c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17452 as u32) ) } as u64;
	// 82E8FC94: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82E8FC98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E8FC9C: 4B430365  bl 0x822c0000
	ctx.lr = 0x82E8FCA0;
	sub_822C0000(ctx, base);
	// 82E8FCA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8FCA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8FCA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8FCAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8FCB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8FCB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8FCB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8FCC0 size=120
    let mut pc: u32 = 0x82E8FCC0;
    'dispatch: loop {
        match pc {
            0x82E8FCC0 => {
    //   block [0x82E8FCC0..0x82E8FD38)
	// 82E8FCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FCC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8FCC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8FCCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FCD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8FCD4: 480036C5  bl 0x82e93398
	ctx.lr = 0x82E8FCD8;
	sub_82E93398(ctx, base);
	// 82E8FCD8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8FCDC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82E8FCE0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82E8FCE4: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82E8FCE8: 38CBE3F8  addi r6, r11, -0x1c08
	ctx.r[6].s64 = ctx.r[11].s64 + -7176;
	// 82E8FCEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8FCF0: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82E8FCF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8FCF8: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82E8FCFC: C009D7BC  lfs f0, -0x2844(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FD00: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82E8FD04: C1A8D200  lfs f13, -0x2e00(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FD08: C187D0F8  lfs f12, -0x2f08(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FD0C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E8FD10: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8FD14: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E8FD18: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8FD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FD20: D19F0010  stfs f12, 0x10(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8FD24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8FD28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8FD2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8FD30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8FD34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8FD38 size=112
    let mut pc: u32 = 0x82E8FD38;
    'dispatch: loop {
        match pc {
            0x82E8FD38 => {
    //   block [0x82E8FD38..0x82E8FDA8)
	// 82E8FD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8FD40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8FD44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8FD48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FD4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8FD50: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E8FD54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8FD58: 394BE3F8  addi r10, r11, -0x1c08
	ctx.r[10].s64 = ctx.r[11].s64 + -7176;
	// 82E8FD5C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8FD60: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E8FD64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8FD68: 419A0008  beq cr6, 0x82e8fd70
	if ctx.cr[6].eq {
	pc = 0x82E8FD70; continue 'dispatch;
	}
	// 82E8FD6C: 4B430B25  bl 0x822c0890
	ctx.lr = 0x82E8FD70;
	sub_822C0890(ctx, base);
	// 82E8FD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FD74: 48003625  bl 0x82e93398
	ctx.lr = 0x82E8FD78;
	sub_82E93398(ctx, base);
	// 82E8FD78: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E8FD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FD80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FD84: 419A000C  beq cr6, 0x82e8fd90
	if ctx.cr[6].eq {
	pc = 0x82E8FD90; continue 'dispatch;
	}
	// 82E8FD88: 4BF62651  bl 0x82df23d8
	ctx.lr = 0x82E8FD8C;
	sub_82DF23D8(ctx, base);
	// 82E8FD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FD90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8FD94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8FD98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8FD9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8FDA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8FDA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8FDA8 size=888
    let mut pc: u32 = 0x82E8FDA8;
    'dispatch: loop {
        match pc {
            0x82E8FDA8 => {
    //   block [0x82E8FDA8..0x82E90120)
	// 82E8FDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FDAC: 48318391  bl 0x831a813c
	ctx.lr = 0x82E8FDB0;
	sub_831A8130(ctx, base);
	// 82E8FDB0: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 82E8FDB4: 48318CAD  bl 0x831a8a60
	ctx.lr = 0x82E8FDB8;
	sub_831A8A40(ctx, base);
	// 82E8FDB8: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FDBC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E8FDC0: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 82E8FDC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8FDC8: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82E8FDCC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8FDD0: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 82E8FDD4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E8FDD8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FDDC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82E8FDE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8FDE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E8FDE8: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E8FDEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E8FDF0: 4E800421  bctrl
	ctx.lr = 0x82E8FDF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8FDF4: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E8FDF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8FDFC: 419A0304  beq cr6, 0x82e90100
	if ctx.cr[6].eq {
	pc = 0x82E90100; continue 'dispatch;
	}
	// 82E8FE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FE04: 4BFEDCBD  bl 0x82e7dac0
	ctx.lr = 0x82E8FE08;
	sub_82E7DAC0(ctx, base);
	// 82E8FE08: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82E8FE0C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82E8FE10: 82FF00C8  lwz r23, 0xc8(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E8FE14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8FE18: 4BFF9111  bl 0x82e88f28
	ctx.lr = 0x82E8FE1C;
	sub_82E88F28(ctx, base);
	// 82E8FE1C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8FE20: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 82E8FE24: C03F009C  lfs f1, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8FE28: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 82E8FE2C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82E8FE30: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 82E8FE34: 39010100  addi r8, r1, 0x100
	ctx.r[8].s64 = ctx.r[1].s64 + 256;
	// 82E8FE38: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 82E8FE3C: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E8FE40: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 82E8FE44: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 82E8FE48: 13F85C07  vcmpneb. (lvlx128) v31, v24, v11
	tmp.u32 = ctx.r[24].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E8FE4C: 3AC100D0  addi r22, r1, 0xd0
	ctx.r[22].s64 = ctx.r[1].s64 + 208;
	// 82E8FE50: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90120 size=92
    let mut pc: u32 = 0x82E90120;
    'dispatch: loop {
        match pc {
            0x82E90120 => {
    //   block [0x82E90120..0x82E9017C)
	// 82E90120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E9012C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90134: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E90138: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 82E9013C: 9BC30004  stb r30, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E90140: 3886002C  addi r4, r6, 0x2c
	ctx.r[4].s64 = ctx.r[6].s64 + 44;
	// 82E90144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90148: 4BF63A89  bl 0x82df3bd0
	ctx.lr = 0x82E9014C;
	sub_82DF3BD0(ctx, base);
	// 82E9014C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90150: 4BF632E1  bl 0x82df3430
	ctx.lr = 0x82E90154;
	sub_82DF3430(ctx, base);
	// 82E90154: 7D7E1850  subf r11, r30, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 82E90158: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E9015C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82E90160: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82E90164: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E9016C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90170: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E90174: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90180 size=244
    let mut pc: u32 = 0x82E90180;
    'dispatch: loop {
        match pc {
            0x82E90180 => {
    //   block [0x82E90180..0x82E90274)
	// 82E90180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90184: 48317FE5  bl 0x831a8168
	ctx.lr = 0x82E90188;
	sub_831A8130(ctx, base);
	// 82E90188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9018C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90190: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E90194: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E90198: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E9019C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E901A0: 409A000C  bne cr6, 0x82e901ac
	if !ctx.cr[6].eq {
	pc = 0x82E901AC; continue 'dispatch;
	}
	// 82E901A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E901A8: 48000010  b 0x82e901b8
	pc = 0x82E901B8; continue 'dispatch;
	// 82E901AC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E901B0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E901B4: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82E901B8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E901BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E901C0: 419A0010  beq cr6, 0x82e901d0
	if ctx.cr[6].eq {
	pc = 0x82E901D0; continue 'dispatch;
	}
	// 82E901C4: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E901C8: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82E901CC: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82E901D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E901D4: 409A0098  bne cr6, 0x82e9026c
	if !ctx.cr[6].eq {
	pc = 0x82E9026C; continue 'dispatch;
	}
	// 82E901D8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E901DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E901E0: 419A008C  beq cr6, 0x82e9026c
	if ctx.cr[6].eq {
	pc = 0x82E9026C; continue 'dispatch;
	}
	// 82E901E4: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E901E8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E901EC: 7D3E1E71  srawi. r30, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E901F0: 4182007C  beq 0x82e9026c
	if ctx.cr[0].eq {
	pc = 0x82E9026C; continue 'dispatch;
	}
	// 82E901F4: 4831BAD5  bl 0x831abcc8
	ctx.lr = 0x82E901F8;
	sub_831ABCC8(ctx, base);
	// 82E901F8: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82E901FC: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 82E90200: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E90204: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E90208: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E9020C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E90210: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E90214: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82E90218: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82E9021C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82E90220: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82E90224: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E90228: C0084E28  lfs f0, 0x4e28(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E9022C: C1A708A8  lfs f13, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90230: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E90234: ECE96828  fsubs f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E90238: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E9023C: ECC801F2  fmuls f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 82E90240: FCA0365E  fctidz f5, f6
	ctx.f[5].s64 = if ctx.f[6].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[6].f64.trunc() as i64 };
	// 82E90244: D8A10050  stfd f5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[5].u64 ) };
	// 82E90248: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E9024C: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82E90250: 7C89282E  lwzx r4, r9, r5
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82E90254: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90278 size=128
    let mut pc: u32 = 0x82E90278;
    'dispatch: loop {
        match pc {
            0x82E90278 => {
    //   block [0x82E90278..0x82E902F8)
	// 82E90278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9027C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90280: DBA1FFE0  stfd f29, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[29].u64 ) };
	// 82E90284: DBC1FFE8  stfd f30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 82E90288: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82E9028C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90290: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 82E90294: C3E10090  lfs f31, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E90298: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E9029C: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E902A0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E902A4: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E902A8: EFBEF82A  fadds f29, f30, f31
	ctx.f[29].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E902AC: 4831BA1D  bl 0x831abcc8
	ctx.lr = 0x82E902B0;
	sub_831ABCC8(ctx, base);
	// 82E902B0: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 82E902B4: ED9FF028  fsubs f12, f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82E902B8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82E902BC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E902C0: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E902C4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82E902C8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E902CC: C0094E28  lfs f0, 0x4e28(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E902D0: ED0CE828  fsubs f8, f12, f29
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E902D4: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E902D8: EC27EA3A  fmadds f1, f7, f8, f29
	ctx.f[1].f64 = (((ctx.f[7].f64 * ctx.f[8].f64 + ctx.f[29].f64) as f32) as f64);
	// 82E902DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E902E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E902E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E902E8: CBA1FFE0  lfd f29, -0x20(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E902EC: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E902F0: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E902F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E902F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E902F8 size=220
    let mut pc: u32 = 0x82E902F8;
    'dispatch: loop {
        match pc {
            0x82E902F8 => {
    //   block [0x82E902F8..0x82E903D4)
	// 82E902F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E902FC: 48317E69  bl 0x831a8164
	ctx.lr = 0x82E90300;
	sub_831A8130(ctx, base);
	// 82E90300: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90304: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E90308: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E9030C: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 82E90310: 394BE404  addi r10, r11, -0x1bfc
	ctx.r[10].s64 = ctx.r[11].s64 + -7164;
	// 82E90314: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82E90318: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E9031C: 807C002C  lwz r3, 0x2c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E90320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90324: 419A0020  beq cr6, 0x82e90344
	if ctx.cr[6].eq {
	pc = 0x82E90344; continue 'dispatch;
	}
	// 82E90328: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E9032C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E90330: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E90334: 4B941F55  bl 0x827d2288
	ctx.lr = 0x82E90338;
	sub_827D2288(ctx, base);
	// 82E90338: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E9033C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E90340: 4BF61E49  bl 0x82df2188
	ctx.lr = 0x82E90344;
	sub_82DF2188(ctx, base);
	// 82E90344: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E90348: 3BDC0018  addi r30, r28, 0x18
	ctx.r[30].s64 = ctx.r[28].s64 + 24;
	// 82E9034C: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E90350: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E90354: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E90358: 807C001C  lwz r3, 0x1c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E9035C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90360: 419A0020  beq cr6, 0x82e90380
	if ctx.cr[6].eq {
	pc = 0x82E90380; continue 'dispatch;
	}
	// 82E90364: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E90368: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E9036C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E90370: 4B941F19  bl 0x827d2288
	ctx.lr = 0x82E90374;
	sub_827D2288(ctx, base);
	// 82E90374: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E90378: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E9037C: 4BF61E0D  bl 0x82df2188
	ctx.lr = 0x82E90380;
	sub_82DF2188(ctx, base);
	// 82E90380: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E90384: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E90388: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E9038C: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E90390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90394: 419A0018  beq cr6, 0x82e903ac
	if ctx.cr[6].eq {
	pc = 0x82E903AC; continue 'dispatch;
	}
	// 82E90398: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E9039C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E903A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E903A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E903A8: 4E800421  bctrl
	ctx.lr = 0x82E903AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E903AC: 807C0010  lwz r3, 0x10(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E903B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E903B4: 419A0008  beq cr6, 0x82e903bc
	if ctx.cr[6].eq {
	pc = 0x82E903BC; continue 'dispatch;
	}
	// 82E903B8: 4B4304D9  bl 0x822c0890
	ctx.lr = 0x82E903BC;
	sub_822C0890(ctx, base);
	// 82E903BC: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 82E903C0: 4BF63069  bl 0x82df3428
	ctx.lr = 0x82E903C4;
	sub_82DF3428(ctx, base);
	// 82E903C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E903C8: 48002FD1  bl 0x82e93398
	ctx.lr = 0x82E903CC;
	sub_82E93398(ctx, base);
	// 82E903CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E903D0: 48317DE4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E903D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E903D8 size=140
    let mut pc: u32 = 0x82E903D8;
    'dispatch: loop {
        match pc {
            0x82E903D8 => {
    //   block [0x82E903D8..0x82E90464)
	// 82E903D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E903DC: 48317D91  bl 0x831a816c
	ctx.lr = 0x82E903E0;
	sub_831A8130(ctx, base);
	// 82E903E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E903E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E903E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E903EC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82E903F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E903F4: 4B4367B5  bl 0x822c6ba8
	ctx.lr = 0x82E903F8;
	sub_822C6BA8(ctx, base);
	// 82E903F8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82E903FC: 4B4367AD  bl 0x822c6ba8
	ctx.lr = 0x82E90400;
	sub_822C6BA8(ctx, base);
	// 82E90400: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82E90404: 4BF62CED  bl 0x82df30f0
	ctx.lr = 0x82E90408;
	sub_82DF30F0(ctx, base);
	// 82E90408: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 82E9040C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82E90410: 4BF637C1  bl 0x82df3bd0
	ctx.lr = 0x82E90414;
	sub_82DF3BD0(ctx, base);
	// 82E90414: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90418: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E9041C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E90420: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E90424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90428: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E9042C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E90430: 4E800421  bctrl
	ctx.lr = 0x82E90434;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E90434: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E90438: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82E9043C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E90440: 419A0014  beq cr6, 0x82e90454
	if ctx.cr[6].eq {
	pc = 0x82E90454; continue 'dispatch;
	}
	// 82E90444: 4BF62FE5  bl 0x82df3428
	ctx.lr = 0x82E90448;
	sub_82DF3428(ctx, base);
	// 82E90448: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E9044C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E90450: 48317D6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 82E90454: 4BF62FD5  bl 0x82df3428
	ctx.lr = 0x82E90458;
	sub_82DF3428(ctx, base);
	// 82E90458: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E9045C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E90460: 48317D5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90468 size=124
    let mut pc: u32 = 0x82E90468;
    'dispatch: loop {
        match pc {
            0x82E90468 => {
    //   block [0x82E90468..0x82E904E4)
	// 82E90468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9046C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E90474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9047C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90480: 48002F19  bl 0x82e93398
	ctx.lr = 0x82E90484;
	sub_82E93398(ctx, base);
	// 82E90484: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E90488: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E9048C: 394BE404  addi r10, r11, -0x1bfc
	ctx.r[10].s64 = ctx.r[11].s64 + -7164;
	// 82E90490: 9BDF0004  stb r30, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E90494: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82E90498: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E9049C: 9BDF0005  stb r30, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[30].u8 ) };
	// 82E904A0: 4BF62C51  bl 0x82df30f0
	ctx.lr = 0x82E904A4;
	sub_82DF30F0(ctx, base);
	// 82E904A4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E904A8: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82E904AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E904B0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E904B4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82E904B8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82E904BC: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82E904C0: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82E904C4: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82E904C8: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82E904CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E904D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E904D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E904D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E904DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E904E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E904E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E904E8 size=80
    let mut pc: u32 = 0x82E904E8;
    'dispatch: loop {
        match pc {
            0x82E904E8 => {
    //   block [0x82E904E8..0x82E90538)
	// 82E904E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E904EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E904F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E904F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E904F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E904FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90500: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E90504: 4BFFFDF5  bl 0x82e902f8
	ctx.lr = 0x82E90508;
	sub_82E902F8(ctx, base);
	// 82E90508: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E9050C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90514: 419A000C  beq cr6, 0x82e90520
	if ctx.cr[6].eq {
	pc = 0x82E90520; continue 'dispatch;
	}
	// 82E90518: 4BF61EC1  bl 0x82df23d8
	ctx.lr = 0x82E9051C;
	sub_82DF23D8(ctx, base);
	// 82E9051C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E9052C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E90530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90538 size=328
    let mut pc: u32 = 0x82E90538;
    'dispatch: loop {
        match pc {
            0x82E90538 => {
    //   block [0x82E90538..0x82E90680)
	// 82E90538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9053C: 48317C15  bl 0x831a8150
	ctx.lr = 0x82E90540;
	sub_831A8130(ctx, base);
	// 82E90540: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90544: 82E40008  lwz r23, 8(r4)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E90548: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82E9054C: 83640004  lwz r27, 4(r4)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E90550: 7F1BB840  cmplw cr6, r27, r23
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82E90554: 419A0124  beq cr6, 0x82e90678
	if ctx.cr[6].eq {
	pc = 0x82E90678; continue 'dispatch;
	}
	// 82E90558: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E9055C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82E90560: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E90564: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E90568: 830B002C  lwz r24, 0x2c(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E9056C: 834B0014  lwz r26, 0x14(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E90570: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E90574: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E90578: 4BD4EC11  bl 0x82bdf188
	ctx.lr = 0x82E9057C;
	sub_82BDF188(ctx, base);
	// 82E9057C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E90580: 419A00E4  beq cr6, 0x82e90664
	if ctx.cr[6].eq {
	pc = 0x82E90664; continue 'dispatch;
	}
	// 82E90584: 3BB90028  addi r29, r25, 0x28
	ctx.r[29].s64 = ctx.r[25].s64 + 40;
	// 82E90588: 3B990018  addi r28, r25, 0x18
	ctx.r[28].s64 = ctx.r[25].s64 + 24;
	// 82E9058C: 3BE30014  addi r31, r3, 0x14
	ctx.r[31].s64 = ctx.r[3].s64 + 20;
	// 82E90590: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E90594: 4BF61E2D  bl 0x82df23c0
	ctx.lr = 0x82E90598;
	sub_82DF23C0(ctx, base);
	// 82E90598: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82E9059C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E905A0: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82E905A4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E905A8: 4B433F39  bl 0x822c44e0
	ctx.lr = 0x82E905AC;
	sub_822C44E0(ctx, base);
	// 82E905AC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82E905B0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E905B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E905B8: 4B42FA49  bl 0x822c0000
	ctx.lr = 0x82E905BC;
	sub_822C0000(ctx, base);
	// 82E905BC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E905C0: C01FFFEC  lfs f0, -0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E905C4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82E905C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E905CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E905D0: C1BFFFF0  lfs f13, -0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E905D4: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E905D8: C19FFFF4  lfs f12, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E905DC: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E905E0: 4BD22B29  bl 0x82bb3108
	ctx.lr = 0x82E905E4;
	sub_82BB3108(ctx, base);
	// 82E905E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E905E8: 4BF61DD9  bl 0x82df23c0
	ctx.lr = 0x82E905EC;
	sub_82DF23C0(ctx, base);
	// 82E905EC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82E905F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E905F4: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82E905F8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E905FC: 4B433EE5  bl 0x822c44e0
	ctx.lr = 0x82E90600;
	sub_822C44E0(ctx, base);
	// 82E90600: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82E90604: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E90608: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E9060C: 4B42F9F5  bl 0x822c0000
	ctx.lr = 0x82E90610;
	sub_822C0000(ctx, base);
	// 82E90610: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E90614: C17FFFF8  lfs f11, -8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E90618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E9061C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E90620: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90624: C15FFFFC  lfs f10, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E90628: D14B0004  stfs f10, 4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E9062C: C13F0000  lfs f9, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E90630: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E90634: 4BD22AD5  bl 0x82bb3108
	ctx.lr = 0x82E90638;
	sub_82BB3108(ctx, base);
	// 82E90638: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E9063C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90640: 419A0008  beq cr6, 0x82e90648
	if ctx.cr[6].eq {
	pc = 0x82E90648; continue 'dispatch;
	}
	// 82E90644: 4B43024D  bl 0x822c0890
	ctx.lr = 0x82E90648;
	sub_822C0890(ctx, base);
	// 82E90648: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E9064C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90650: 419A0008  beq cr6, 0x82e90658
	if ctx.cr[6].eq {
	pc = 0x82E90658; continue 'dispatch;
	}
	// 82E90654: 4B43023D  bl 0x822c0890
	ctx.lr = 0x82E90658;
	sub_822C0890(ctx, base);
	// 82E90658: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E9065C: 7FFFD214  add r31, r31, r26
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[26].u64;
	// 82E90660: 4082FF30  bne 0x82e90590
	if !ctx.cr[0].eq {
	pc = 0x82E90590; continue 'dispatch;
	}
	// 82E90664: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E90668: 4BD4EB71  bl 0x82bdf1d8
	ctx.lr = 0x82E9066C;
	sub_82BDF1D8(ctx, base);
	// 82E9066C: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82E90670: 7F1BB840  cmplw cr6, r27, r23
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82E90674: 409AFEE4  bne cr6, 0x82e90558
	if !ctx.cr[6].eq {
	pc = 0x82E90558; continue 'dispatch;
	}
	// 82E90678: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E9067C: 48317B24  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90680 size=472
    let mut pc: u32 = 0x82E90680;
    'dispatch: loop {
        match pc {
            0x82E90680 => {
    //   block [0x82E90680..0x82E90858)
	// 82E90680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90684: 48317AE9  bl 0x831a816c
	ctx.lr = 0x82E90688;
	sub_831A8130(ctx, base);
	// 82E90688: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9068C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90690: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E90694: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E90698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E9069C: 409A01B0  bne cr6, 0x82e9084c
	if !ctx.cr[6].eq {
	pc = 0x82E9084C; continue 'dispatch;
	}
	// 82E906A0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82E906A4: 419A0058  beq cr6, 0x82e906fc
	if ctx.cr[6].eq {
	pc = 0x82E906FC; continue 'dispatch;
	}
	// 82E906A8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E906AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E906B0: 4BF9A439  bl 0x82e2aae8
	ctx.lr = 0x82E906B4;
	sub_82E2AAE8(ctx, base);
	// 82E906B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E906B8: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82E906BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E906C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E906C4: 4BF9E7AD  bl 0x82e2ee70
	ctx.lr = 0x82E906C8;
	sub_82E2EE70(ctx, base);
	// 82E906C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E906CC: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E906D0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82E906D4: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82E906D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E906DC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E906E0: 4B433D81  bl 0x822c4460
	ctx.lr = 0x82E906E4;
	sub_822C4460(ctx, base);
	// 82E906E4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E906E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E906EC: 419A0008  beq cr6, 0x82e906f4
	if ctx.cr[6].eq {
	pc = 0x82E906F4; continue 'dispatch;
	}
	// 82E906F0: 4B4301A1  bl 0x822c0890
	ctx.lr = 0x82E906F4;
	sub_822C0890(ctx, base);
	// 82E906F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E906F8: 4BF9A409  bl 0x82e2ab00
	ctx.lr = 0x82E906FC;
	sub_82E2AB00(ctx, base);
	// 82E906FC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E90700: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 82E90704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90708: 419A0144  beq cr6, 0x82e9084c
	if ctx.cr[6].eq {
	pc = 0x82E9084C; continue 'dispatch;
	}
	// 82E9070C: 4BF6E0D5  bl 0x82dfe7e0
	ctx.lr = 0x82E90710;
	sub_82DFE7E0(ctx, base);
	// 82E90710: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E90714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90718: 419A0134  beq cr6, 0x82e9084c
	if ctx.cr[6].eq {
	pc = 0x82E9084C; continue 'dispatch;
	}
	// 82E9071C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90724: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82E90728: 4BFFFE11  bl 0x82e90538
	ctx.lr = 0x82E9072C;
	sub_82E90538(ctx, base);
	// 82E9072C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90734: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 82E90738: 4BFFFE01  bl 0x82e90538
	ctx.lr = 0x82E9073C;
	sub_82E90538(ctx, base);
	// 82E9073C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90744: 388B0040  addi r4, r11, 0x40
	ctx.r[4].s64 = ctx.r[11].s64 + 64;
	// 82E90748: 4BFFFDF1  bl 0x82e90538
	ctx.lr = 0x82E9074C;
	sub_82E90538(ctx, base);
	// 82E9074C: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 82E90750: 4BF61C71  bl 0x82df23c0
	ctx.lr = 0x82E90754;
	sub_82DF23C0(ctx, base);
	// 82E90754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90758: 419A0010  beq cr6, 0x82e90768
	if ctx.cr[6].eq {
	pc = 0x82E90768; continue 'dispatch;
	}
	// 82E9075C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E90760: 48002491  bl 0x82e92bf0
	ctx.lr = 0x82E90764;
	sub_82E92BF0(ctx, base);
	// 82E90764: 48000008  b 0x82e9076c
	pc = 0x82E9076C; continue 'dispatch;
	// 82E90768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E9076C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E90770: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82E90774: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82E90778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E9077C: 419A001C  beq cr6, 0x82e90798
	if ctx.cr[6].eq {
	pc = 0x82E90798; continue 'dispatch;
	}
	// 82E90780: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90784: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E90788: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E9078C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90790: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E90794: 4E800421  bctrl
	ctx.lr = 0x82E90798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E90798: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 82E9079C: C01D0190  lfs f0, 0x190(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E907A0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82E907A4: C1BD0194  lfs f13, 0x194(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E907A8: C19D0198  lfs f12, 0x198(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E907AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E907B0: C17D019C  lfs f11, 0x19c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E907B4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82E907B8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E907BC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E907C0: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E907C4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E907C8: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E907CC: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90858 size=708
    let mut pc: u32 = 0x82E90858;
    'dispatch: loop {
        match pc {
            0x82E90858 => {
    //   block [0x82E90858..0x82E90B1C)
	// 82E90858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9085C: 483178E9  bl 0x831a8144
	ctx.lr = 0x82E90860;
	sub_831A8130(ctx, base);
	// 82E90860: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 82E90864: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82E90868: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9086C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E90870: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E90874: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82E90878: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E9087C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E90880: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E90884: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82E90888: 897C0005  lbz r11, 5(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(5 as u32) ) } as u64;
	// 82E9088C: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 82E90890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90894: 419A001C  beq cr6, 0x82e908b0
	if ctx.cr[6].eq {
	pc = 0x82E908B0; continue 'dispatch;
	}
	// 82E90898: 4BFFFB41  bl 0x82e903d8
	ctx.lr = 0x82E9089C;
	sub_82E903D8(ctx, base);
	// 82E9089C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E908A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E908A4: 419A000C  beq cr6, 0x82e908b0
	if ctx.cr[6].eq {
	pc = 0x82E908B0; continue 'dispatch;
	}
	// 82E908A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E908AC: 997C0005  stb r11, 5(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 82E908B0: 897C0004  lbz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E908B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E908B8: 409A0024  bne cr6, 0x82e908dc
	if !ctx.cr[6].eq {
	pc = 0x82E908DC; continue 'dispatch;
	}
	// 82E908BC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 82E908C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E908C4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82E908C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E908CC: 4BFFFDB5  bl 0x82e90680
	ctx.lr = 0x82E908D0;
	sub_82E90680(ctx, base);
	// 82E908D0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E908D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E908D8: 419A0234  beq cr6, 0x82e90b0c
	if ctx.cr[6].eq {
	pc = 0x82E90B0C; continue 'dispatch;
	}
	// 82E908DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E908E0: 4BFED1E1  bl 0x82e7dac0
	ctx.lr = 0x82E908E4;
	sub_82E7DAC0(ctx, base);
	// 82E908E4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E908E8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82E908EC: 837F00C8  lwz r27, 0xc8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E908F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E908F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E908F8: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E908FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E90900: 4E800421  bctrl
	ctx.lr = 0x82E90904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E90904: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E90908: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E9090C: 419A01F0  beq cr6, 0x82e90afc
	if ctx.cr[6].eq {
	pc = 0x82E90AFC; continue 'dispatch;
	}
	// 82E90910: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82E90914: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E90918: 4BFF8611  bl 0x82e88f28
	ctx.lr = 0x82E9091C;
	sub_82E88F28(ctx, base);
	// 82E9091C: 39600170  li r11, 0x170
	ctx.r[11].s64 = 368;
	// 82E90920: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82E90924: C03F009C  lfs f1, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E90928: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82E9092C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82E90930: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E90934: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82E90938: 13F758C7  vcmpequd (lvx128) v31, v23, v11
	tmp.u32 = ctx.r[23].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90B20 size=144
    let mut pc: u32 = 0x82E90B20;
    'dispatch: loop {
        match pc {
            0x82E90B20 => {
    //   block [0x82E90B20..0x82E90BB0)
	// 82E90B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90B28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90B2C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E90B30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90B38: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E90B3C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90B44: 419A0054  beq cr6, 0x82e90b98
	if ctx.cr[6].eq {
	pc = 0x82E90B98; continue 'dispatch;
	}
	// 82E90B48: 4831B181  bl 0x831abcc8
	ctx.lr = 0x82E90B4C;
	sub_831ABCC8(ctx, base);
	// 82E90B4C: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E90B50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E90B54: C1BF0008  lfs f13, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90B58: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E90B5C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E90B60: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82E90B64: C15F000C  lfs f10, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E90B68: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90B6C: ED2A6828  fsubs f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E90B70: ED00F824  fdivs f8, f0, f31
	ctx.f[8].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 82E90B74: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82E90B78: FCE05818  frsp f7, f11
	ctx.f[7].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E90B7C: C0094E28  lfs f0, 0x4e28(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90B80: ECC80272  fmuls f6, f8, f9
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82E90B84: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E90B88: EC880272  fmuls f4, f8, f9
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82E90B8C: D09F0014  stfs f4, 0x14(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E90B90: EC66697A  fmadds f3, f6, f5, f13
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E90B94: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E90B98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90B9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90BA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90BA4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E90BA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90BAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90BB0 size=196
    let mut pc: u32 = 0x82E90BB0;
    'dispatch: loop {
        match pc {
            0x82E90BB0 => {
    //   block [0x82E90BB0..0x82E90C74)
	// 82E90BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90BBC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E90BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90BC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E90BCC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 82E90BD0: C3EB4E28  lfs f31, 0x4e28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20008 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E90BD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E90BD8: 409A0024  bne cr6, 0x82e90bfc
	if !ctx.cr[6].eq {
	pc = 0x82E90BFC; continue 'dispatch;
	}
	// 82E90BDC: 4831B0ED  bl 0x831abcc8
	ctx.lr = 0x82E90BE0;
	sub_831ABCC8(ctx, base);
	// 82E90BE0: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E90BE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E90BE8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E90BEC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E90BF0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E90BF4: ED6C07F2  fmuls f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E90BF8: D17F001C  stfs f11, 0x1c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E90BFC: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90C00: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90C04: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90C08: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E90C0C: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E90C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90C14: 419A0018  beq cr6, 0x82e90c2c
	if ctx.cr[6].eq {
	pc = 0x82E90C2C; continue 'dispatch;
	}
	// 82E90C18: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90C1C: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90C20: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E90C24: D19F0010  stfs f12, 0x10(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E90C28: 48000034  b 0x82e90c5c
	pc = 0x82E90C5C; continue 'dispatch;
	// 82E90C2C: 4831B09D  bl 0x831abcc8
	ctx.lr = 0x82E90C30;
	sub_831ABCC8(ctx, base);
	// 82E90C30: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E90C34: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90C38: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E90C3C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E90C40: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82E90C44: C17F000C  lfs f11, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E90C48: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E90C4C: ED2B0028  fsubs f9, f11, f0
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E90C50: ED0A07F2  fmuls f8, f10, f31
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E90C54: ECE9023A  fmadds f7, f9, f8, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E90C58: D0FF0010  stfs f7, 0x10(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E90C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90C60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90C64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90C68: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E90C6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90C78 size=104
    let mut pc: u32 = 0x82E90C78;
    'dispatch: loop {
        match pc {
            0x82E90C78 => {
    //   block [0x82E90C78..0x82E90CE0)
	// 82E90C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90C7C: 483174F1  bl 0x831a816c
	ctx.lr = 0x82E90C80;
	sub_831A8130(ctx, base);
	// 82E90C80: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E90C84: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90C88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90C8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E90C90: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E90C94: C3FF0010  lfs f31, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E90C98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E90C9C: 4831812D  bl 0x831a8dc8
	ctx.lr = 0x82E90CA0;
	sub_831A8DC8(ctx, base);
	// 82E90CA0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E90CA4: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90CA8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E90CAC: 483181FD  bl 0x831a8ea8
	ctx.lr = 0x82E90CB0;
	sub_831A8EA8(ctx, base);
	// 82E90CB0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E90CB4: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90CB8: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E90CBC: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E90CC0: D17E0000  stfs f11, 0(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90CC4: C15F0018  lfs f10, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E90CC8: C13D0000  lfs f9, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E90CCC: ED0A0272  fmuls f8, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82E90CD0: D11D0000  stfs f8, 0(r29)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90CD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E90CD8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E90CDC: 483174E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E90CE0 size=8
    let mut pc: u32 = 0x82E90CE0;
    'dispatch: loop {
        match pc {
            0x82E90CE0 => {
    //   block [0x82E90CE0..0x82E90CE8)
	// 82E90CE0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E90CE4: 4BF616F4  b 0x82df23d8
	sub_82DF23D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90CE8 size=172
    let mut pc: u32 = 0x82E90CE8;
    'dispatch: loop {
        match pc {
            0x82E90CE8 => {
    //   block [0x82E90CE8..0x82E90D94)
	// 82E90CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90CEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90CF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E90CF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90CF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90CFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E90D04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E90D08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E90D0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E90D10: 4B42FC29  bl 0x822c0938
	ctx.lr = 0x82E90D14;
	sub_822C0938(ctx, base);
	// 82E90D14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90D18: 419A0028  beq cr6, 0x82e90d40
	if ctx.cr[6].eq {
	pc = 0x82E90D40; continue 'dispatch;
	}
	// 82E90D1C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E90D20: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E90D24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E90D28: 392BE410  addi r9, r11, -0x1bf0
	ctx.r[9].s64 = ctx.r[11].s64 + -7152;
	// 82E90D2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E90D30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E90D34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E90D38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E90D3C: 48000008  b 0x82e90d44
	pc = 0x82E90D44; continue 'dispatch;
	// 82E90D40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E90D44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E90D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90D4C: 409A002C  bne cr6, 0x82e90d78
	if !ctx.cr[6].eq {
	pc = 0x82E90D78; continue 'dispatch;
	}
	// 82E90D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E90D54: 4BF61685  bl 0x82df23d8
	ctx.lr = 0x82E90D58;
	sub_82DF23D8(ctx, base);
	// 82E90D58: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E90D5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E90D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E90D64: 392A0828  addi r9, r10, 0x828
	ctx.r[9].s64 = ctx.r[10].s64 + 2088;
	// 82E90D68: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82E90D6C: 816BBBDC  lwz r11, -0x4424(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17444 as u32) ) } as u64;
	// 82E90D70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E90D74: 4B42F28D  bl 0x822c0000
	ctx.lr = 0x82E90D78;
	sub_822C0000(ctx, base);
	// 82E90D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90D80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90D84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90D88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E90D8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90D98 size=132
    let mut pc: u32 = 0x82E90D98;
    'dispatch: loop {
        match pc {
            0x82E90D98 => {
    //   block [0x82E90D98..0x82E90E1C)
	// 82E90D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90DA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90DA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90DAC: 480025ED  bl 0x82e93398
	ctx.lr = 0x82E90DB0;
	sub_82E93398(ctx, base);
	// 82E90DB0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E90DB4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E90DB8: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82E90DBC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82E90DC0: 38CBE420  addi r6, r11, -0x1be0
	ctx.r[6].s64 = ctx.r[11].s64 + -7136;
	// 82E90DC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E90DC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E90DCC: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82E90DD0: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82E90DD4: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90DD8: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82E90DDC: C1A8D7BC  lfs f13, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90DE0: C187D200  lfs f12, -0x2e00(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E90DE4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E90DE8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E90DEC: 997F0005  stb r11, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 82E90DF0: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E90DF4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E90DF8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E90DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90E00: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E90E04: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E90E08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E90E0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90E10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90E14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90E20 size=112
    let mut pc: u32 = 0x82E90E20;
    'dispatch: loop {
        match pc {
            0x82E90E20 => {
    //   block [0x82E90E20..0x82E90E90)
	// 82E90E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90E28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E90E2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90E34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90E38: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E90E3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E90E40: 394BE420  addi r10, r11, -0x1be0
	ctx.r[10].s64 = ctx.r[11].s64 + -7136;
	// 82E90E44: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E90E48: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E90E4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E90E50: 419A0008  beq cr6, 0x82e90e58
	if ctx.cr[6].eq {
	pc = 0x82E90E58; continue 'dispatch;
	}
	// 82E90E54: 4B42FA3D  bl 0x822c0890
	ctx.lr = 0x82E90E58;
	sub_822C0890(ctx, base);
	// 82E90E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90E5C: 4800253D  bl 0x82e93398
	ctx.lr = 0x82E90E60;
	sub_82E93398(ctx, base);
	// 82E90E60: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E90E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90E68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90E6C: 419A000C  beq cr6, 0x82e90e78
	if ctx.cr[6].eq {
	pc = 0x82E90E78; continue 'dispatch;
	}
	// 82E90E70: 4BF61569  bl 0x82df23d8
	ctx.lr = 0x82E90E74;
	sub_82DF23D8(ctx, base);
	// 82E90E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90E78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90E84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E90E88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E90E90 size=820
    let mut pc: u32 = 0x82E90E90;
    'dispatch: loop {
        match pc {
            0x82E90E90 => {
    //   block [0x82E90E90..0x82E911C4)
	// 82E90E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90E94: 483172B5  bl 0x831a8148
	ctx.lr = 0x82E90E98;
	sub_831A8130(ctx, base);
	// 82E90E98: DBA1FF80  stfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[29].u64 ) };
	// 82E90E9C: DBC1FF88  stfd f30, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82E90EA0: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82E90EA4: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90EA8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82E90EAC: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82E90EB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90EB4: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E90EB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E90EBC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E90EC0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E90EC4: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82E90EC8: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82E90ECC: 4BFECBF5  bl 0x82e7dac0
	ctx.lr = 0x82E90ED0;
	sub_82E7DAC0(ctx, base);
	// 82E90ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90ED4: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82E90ED8: 833E00C8  lwz r25, 0xc8(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E90EDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E90EE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E90EE4: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E90EE8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E90EEC: 4E800421  bctrl
	ctx.lr = 0x82E90EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E90EF0: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E90EF4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E90EF8: 419A02A8  beq cr6, 0x82e911a0
	if ctx.cr[6].eq {
	pc = 0x82E911A0; continue 'dispatch;
	}
	// 82E90EFC: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 82E90F00: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90F04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E90F08: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90F0C: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82E90F10: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E90F14: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E90F18: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82E90F1C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82E90F20: 13FB58C7  vcmpequd (lvx128) v31, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E90F24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E90F28: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E90F2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82E90F30: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E90F34: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E911C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E911C8 size=200
    let mut pc: u32 = 0x82E911C8;
    'dispatch: loop {
        match pc {
            0x82E911C8 => {
    //   block [0x82E911C8..0x82E91290)
	// 82E911C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E911CC: 48316FA1  bl 0x831a816c
	ctx.lr = 0x82E911D0;
	sub_831A8130(ctx, base);
	// 82E911D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E911D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E911D8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E911DC: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82E911E0: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82E911E4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82E911E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E911EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E911F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E911F4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E911F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E911FC: 4200FFF0  bdnz 0x82e911ec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E911EC; continue 'dispatch;
	}
	// 82E91200: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82E91204: 4BF611BD  bl 0x82df23c0
	ctx.lr = 0x82E91208;
	sub_82DF23C0(ctx, base);
	// 82E91208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E9120C: 419A0034  beq cr6, 0x82e91240
	if ctx.cr[6].eq {
	pc = 0x82E91240; continue 'dispatch;
	}
	// 82E91210: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E91214: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E91218: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E9121C: 88BF0005  lbz r5, 5(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 82E91220: C03F000C  lfs f1, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E91224: 889E0000  lbz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E91228: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E9122C: EC6D0032  fmuls f3, f13, f0
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E91230: EC4C0032  fmuls f2, f12, f0
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E91234: 4800247D  bl 0x82e936b0
	ctx.lr = 0x82E91238;
	sub_82E936B0(ctx, base);
	// 82E91238: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E9123C: 48000008  b 0x82e91244
	pc = 0x82E91244; continue 'dispatch;
	// 82E91240: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E91244: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E91248: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E9124C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E91250: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 82E91254: 4BFFFA95  bl 0x82e90ce8
	ctx.lr = 0x82E91258;
	sub_82E90CE8(ctx, base);
	// 82E91258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E9125C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E91260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E91264: 4B42ED9D  bl 0x822c0000
	ctx.lr = 0x82E91268;
	sub_822C0000(ctx, base);
	// 82E91268: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E9126C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E91270: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E91274: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E91278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E9127C: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82E91280: 419A0008  beq cr6, 0x82e91288
	if ctx.cr[6].eq {
	pc = 0x82E91288; continue 'dispatch;
	}
	// 82E91284: 4B42F60D  bl 0x822c0890
	ctx.lr = 0x82E91288;
	sub_822C0890(ctx, base);
	// 82E91288: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E9128C: 48316F30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E91290 size=40
    let mut pc: u32 = 0x82E91290;
    'dispatch: loop {
        match pc {
            0x82E91290 => {
    //   block [0x82E91290..0x82E912B8)
	// 82E91290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E91294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E91298: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9129C: 38860010  addi r4, r6, 0x10
	ctx.r[4].s64 = ctx.r[6].s64 + 16;
	// 82E912A0: 4BFFFF29  bl 0x82e911c8
	ctx.lr = 0x82E912A4;
	sub_82E911C8(ctx, base);
	// 82E912A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E912A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E912AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E912B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E912B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E912B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E912B8 size=92
    let mut pc: u32 = 0x82E912B8;
    'dispatch: loop {
        match pc {
            0x82E912B8 => {
    //   block [0x82E912B8..0x82E91314)
	// 82E912B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E912BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E912C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E912C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E912C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E912CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E912D0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E912D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E912D8: 394BE42C  addi r10, r11, -0x1bd4
	ctx.r[10].s64 = ctx.r[11].s64 + -7124;
	// 82E912DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E912E0: 480020B9  bl 0x82e93398
	ctx.lr = 0x82E912E4;
	sub_82E93398(ctx, base);
	// 82E912E4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E912E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E912EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E912F0: 419A000C  beq cr6, 0x82e912fc
	if ctx.cr[6].eq {
	pc = 0x82E912FC; continue 'dispatch;
	}
	// 82E912F4: 4BF610E5  bl 0x82df23d8
	ctx.lr = 0x82E912F8;
	sub_82DF23D8(ctx, base);
	// 82E912F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E912FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E91300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E91304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E91308: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E9130C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E91310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E91318 size=24
    let mut pc: u32 = 0x82E91318;
    'dispatch: loop {
        match pc {
            0x82E91318 => {
    //   block [0x82E91318..0x82E91330)
	// 82E91318: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E9131C: 13E030C7  vcmpequd (lvx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E91320: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E91324: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E91330 size=80
    let mut pc: u32 = 0x82E91330;
    'dispatch: loop {
        match pc {
            0x82E91330 => {
    //   block [0x82E91330..0x82E91380)
	// 82E91330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E91334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E91338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E9133C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E91340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E91344: 48002055  bl 0x82e93398
	ctx.lr = 0x82E91348;
	sub_82E93398(ctx, base);
	// 82E91348: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E9134C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E91350: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82E91354: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82E91358: 38EAE42C  addi r7, r10, -0x1bd4
	ctx.r[7].s64 = ctx.r[10].s64 + -7124;
	// 82E9135C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E91360: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E91364: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E91380 size=648
    let mut pc: u32 = 0x82E91380;
    'dispatch: loop {
        match pc {
            0x82E91380 => {
    //   block [0x82E91380..0x82E91608)
	// 82E91380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E91384: 48316DBD  bl 0x831a8140
	ctx.lr = 0x82E91388;
	sub_831A8130(ctx, base);
	// 82E91388: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82E9138C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82E91390: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E91394: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E91398: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E9139C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E913A0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E913A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E913A8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E913AC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E913B0: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82E913B4: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 82E913B8: 4BFEC709  bl 0x82e7dac0
	ctx.lr = 0x82E913BC;
	sub_82E7DAC0(ctx, base);
	// 82E913BC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E913C0: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82E913C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E913C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E913CC: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E913D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E913D4: 4E800421  bctrl
	ctx.lr = 0x82E913D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E913D8: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E913DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E913E0: 839F00C8  lwz r28, 0xc8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82E913E4: 419A0204  beq cr6, 0x82e915e8
	if ctx.cr[6].eq {
	pc = 0x82E915E8; continue 'dispatch;
	}
	// 82E913E8: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82E913EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E913F0: 4BFF7B39  bl 0x82e88f28
	ctx.lr = 0x82E913F4;
	sub_82E88F28(ctx, base);
	// 82E913F4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E913F8: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82E913FC: 3B2B6910  addi r25, r11, 0x6910
	ctx.r[25].s64 = ctx.r[11].s64 + 26896;
	// 82E91400: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82E91404: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E91408: 4BFEA8C1  bl 0x82e7bcc8
	ctx.lr = 0x82E9140C;
	sub_82E7BCC8(ctx, base);
	// 82E9140C: 39600170  li r11, 0x170
	ctx.r[11].s64 = 368;
	// 82E91410: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82E91414: C03F009C  lfs f1, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E91418: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82E9141C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82E91420: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E91424: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82E91428: 13FB58C7  vcmpequd (lvx128) v31, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E91608 size=16
    let mut pc: u32 = 0x82E91608;
    'dispatch: loop {
        match pc {
            0x82E91608 => {
    //   block [0x82E91608..0x82E91618)
	// 82E91608: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E9160C: 394BE438  addi r10, r11, -0x1bc8
	ctx.r[10].s64 = ctx.r[11].s64 + -7112;
	// 82E91610: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E91614: 4BFF08AC  b 0x82e81ec0
	sub_82E81EC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E91618 size=8
    let mut pc: u32 = 0x82E91618;
    'dispatch: loop {
        match pc {
            0x82E91618 => {
    //   block [0x82E91618..0x82E91620)
	// 82E91618: 386300B0  addi r3, r3, 0xb0
	ctx.r[3].s64 = ctx.r[3].s64 + 176;
	// 82E9161C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E91620 size=92
    let mut pc: u32 = 0x82E91620;
    'dispatch: loop {
        match pc {
            0x82E91620 => {
    //   block [0x82E91620..0x82E9167C)
	// 82E91620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E91624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E91628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E9162C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E91630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E91634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E91638: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E9163C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E91640: 394BE438  addi r10, r11, -0x1bc8
	ctx.r[10].s64 = ctx.r[11].s64 + -7112;
	// 82E91644: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E91648: 4BFF0879  bl 0x82e81ec0
	ctx.lr = 0x82E9164C;
	sub_82E81EC0(ctx, base);
	// 82E9164C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82E91650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E91654: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E91658: 419A000C  beq cr6, 0x82e91664
	if ctx.cr[6].eq {
	pc = 0x82E91664; continue 'dispatch;
	}
	// 82E9165C: 4BF60D7D  bl 0x82df23d8
	ctx.lr = 0x82E91660;
	sub_82DF23D8(ctx, base);
	// 82E91660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E91664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E91668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E9166C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E91670: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E91674: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E91678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E91680 size=168
    let mut pc: u32 = 0x82E91680;
    'dispatch: loop {
        match pc {
            0x82E91680 => {
    //   block [0x82E91680..0x82E91728)
	// 82E91680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E91684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E91688: DBA1FFE0  stfd f29, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[29].u64 ) };
	// 82E9168C: DBC1FFE8  stfd f30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 82E91690: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82E91694: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E91698: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82E9169C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82E916A0: A1210096  lhz r9, 0x96(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(150 as u32) ) } as u64;
	// 82E916A4: A1610094  lhz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E916A8: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 82E916AC: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82E916B0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E916B4: 7D250734  extsh r5, r9
	ctx.r[5].s64 = ctx.r[9].s16 as i64;
	// 82E916B8: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E916BC: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82E916C0: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E916C4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82E916C8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E916CC: FD206E9C  fcfid f9, f13
	ctx.f[9].f64 = (ctx.f[13].s64 as f64);
	// 82E916D0: EFEA0032  fmuls f31, f10, f0
	ctx.f[31].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E916D4: FFC04818  frsp f30, f9
	ctx.f[30].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82E916D8: EFBEF82A  fadds f29, f30, f31
	ctx.f[29].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E916DC: 4831A5ED  bl 0x831abcc8
	ctx.lr = 0x82E916E0;
	sub_831ABCC8(ctx, base);
	// 82E916E0: 7C6407B4  extsw r4, r3
	ctx.r[4].s64 = ctx.r[3].s32 as i64;
	// 82E916E4: ED1EF828  fsubs f8, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E916E8: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 82E916EC: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82E916F0: C8E10050  lfd f7, 0x50(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E916F4: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82E916F8: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82E916FC: C0034E28  lfs f0, 0x4e28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E91700: EC88E828  fsubs f4, f8, f29
	ctx.f[4].f64 = (((ctx.f[8].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E91704: EC650032  fmuls f3, f5, f0
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E91708: EC23E93A  fmadds f1, f3, f4, f29
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[4].f64 + ctx.f[29].f64) as f32) as f64);
	// 82E9170C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E91710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E91714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E91718: CBA1FFE0  lfd f29, -0x20(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E9171C: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E91720: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E91724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E91728 size=248
    let mut pc: u32 = 0x82E91728;
    'dispatch: loop {
        match pc {
            0x82E91728 => {
    //   block [0x82E91728..0x82E91820)
	// 82E91728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9172C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E91730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E91734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E91738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9173C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E91740: 4BFF0749  bl 0x82e81e88
	ctx.lr = 0x82E91744;
	sub_82E81E88(ctx, base);
	// 82E91744: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E91748: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 82E9174C: 394BE438  addi r10, r11, -0x1bc8
	ctx.r[10].s64 = ctx.r[11].s64 + -7112;
	// 82E91750: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E91754: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E91758: 4BFFBD89  bl 0x82e8d4e0
	ctx.lr = 0x82E9175C;
	sub_82E8D4E0(ctx, base);
	// 82E9175C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E91760: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 82E91764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E91768: 38E8BA80  addi r7, r8, -0x4580
	ctx.r[7].s64 = ctx.r[8].s64 + -17792;
	// 82E9176C: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82E91770: 3CC08203  lis r6, -0x7dfd
	ctx.r[6].s64 = -2113732608;
	// 82E91774: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E91778: 3CA08338  lis r5, -0x7cc8
	ctx.r[5].s64 = -2093481984;
	// 82E9177C: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E91780: 38864620  addi r4, r6, 0x4620
	ctx.r[4].s64 = ctx.r[6].s64 + 17952;
	// 82E91784: C1A8BA80  lfs f13, -0x4580(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E91788: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82E9178C: D1BF00B0  stfs f13, 0xb0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82E91790: 39256910  addi r9, r5, 0x6910
	ctx.r[9].s64 = ctx.r[5].s64 + 26896;
	// 82E91794: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E91798: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 82E9179C: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82E917A0: 38C00070  li r6, 0x70
	ctx.r[6].s64 = 112;
	// 82E917A4: C1A70008  lfs f13, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E917A8: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 82E917AC: D1BF00B8  stfs f13, 0xb8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82E917B0: 3BC00060  li r30, 0x60
	ctx.r[30].s64 = 96;
	// 82E917B4: C1A7000C  lfs f13, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E917B8: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82E917BC: D1BF00BC  stfs f13, 0xbc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82E917C0: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E91820 size=192
    let mut pc: u32 = 0x82E91820;
    'dispatch: loop {
        match pc {
            0x82E91820 => {
    //   block [0x82E91820..0x82E918E0)
	// 82E91820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E91824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E91828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E9182C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E91830: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E91834: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E91838: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E9183C: 392B6880  addi r9, r11, 0x6880
	ctx.r[9].s64 = ctx.r[11].s64 + 26752;
	// 82E91840: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E91844: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 82E91848: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82E9184C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82E91850: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82E91854: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E91858: 3BC10090  addi r30, r1, 0x90
	ctx.r[30].s64 = ctx.r[1].s64 + 144;
	// 82E9185C: 13CA4C07  vcmpneb. (lvlx128) v30, v10, v9
	tmp.u32 = ctx.r[10].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E91860: 13A84C07  vcmpneb. (lvlx128) v29, v8, v9
	tmp.u32 = ctx.r[8].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E91864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E91868: 13874C07  vcmpneb. (lvlx128) v28, v7, v9
	tmp.u32 = ctx.r[7].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E9186C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E918E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E918E0 size=564
    let mut pc: u32 = 0x82E918E0;
    'dispatch: loop {
        match pc {
            0x82E918E0 => {
    //   block [0x82E918E0..0x82E91B14)
	// 82E918E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E918E4: 48316889  bl 0x831a816c
	ctx.lr = 0x82E918E8;
	sub_831A8130(ctx, base);
	// 82E918E8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82E918EC: 48317189  bl 0x831a8a74
	ctx.lr = 0x82E918F0;
	sub_831A8A40(ctx, base);
	// 82E918F0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E918F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E918F8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82E918FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E91900: 4831A3C9  bl 0x831abcc8
	ctx.lr = 0x82E91904;
	sub_831ABCC8(ctx, base);
	// 82E91904: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E91908: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E9190C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E91910: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E91914: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82E91918: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E9191C: C3EA4E28  lfs f31, 0x4e28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20008 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E91920: EFAC07F2  fmuls f29, f12, f31
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E91924: 4831A3A5  bl 0x831abcc8
	ctx.lr = 0x82E91928;
	sub_831ABCC8(ctx, base);
	// 82E91928: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 82E9192C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82E91930: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E91934: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82E91938: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82E9193C: EF8907F2  fmuls f28, f9, f31
	ctx.f[28].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E91940: 4831A389  bl 0x831abcc8
	ctx.lr = 0x82E91944;
	sub_831ABCC8(ctx, base);
	// 82E91944: 7C6807B4  extsw r8, r3
	ctx.r[8].s64 = ctx.r[3].s32 as i64;
	// 82E91948: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82E9194C: C9010050  lfd f8, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E91950: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82E91954: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82E91958: EF6607F2  fmuls f27, f6, f31
	ctx.f[27].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E9195C: 4831A36D  bl 0x831abcc8
	ctx.lr = 0x82E91960;
	sub_831ABCC8(ctx, base);
	// 82E91960: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 82E91964: FC60D890  fmr f3, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[27].f64;
	// 82E91968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E9196C: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82E91970: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82E91974: C8A10050  lfd f5, 0x50(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E91978: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82E9197C: FC002018  frsp f0, f4
	ctx.f[0].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82E91980: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E91984: EC8007F2  fmuls f4, f0, f31
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E91988: 4BFFBB79  bl 0x82e8d500
	ctx.lr = 0x82E9198C;
	sub_82E8D500(ctx, base);
	// 82E9198C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82E91990: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82E91994: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82E91998: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82E9199C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82E919A0: 88E60000  lbz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E919A4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82E919A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E919AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E919B0: 3BBF00A0  addi r29, r31, 0xa0
	ctx.r[29].s64 = ctx.r[31].s64 + 160;
	// 82E919B4: 98FF00A0  stb r7, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[7].u8 ) };
	// 82E919B8: 88E60001  lbz r7, 1(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(1 as u32) ) } as u64;
	// 82E919BC: 98FF00A1  stb r7, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[7].u8 ) };
	// 82E919C0: 88E60002  lbz r7, 2(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 82E919C4: 98FF00A2  stb r7, 0xa2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(162 as u32), ctx.r[7].u8 ) };
	// 82E919C8: 88C60003  lbz r6, 3(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(3 as u32) ) } as u64;
	// 82E919CC: 98DF00A3  stb r6, 0xa3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(163 as u32), ctx.r[6].u8 ) };
	// 82E919D0: 13FE58C7  vcmpequd (lvx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E919D4: 13DE50C7  vcmpequd (lvx128) v30, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E91B18 size=36
    let mut pc: u32 = 0x82E91B18;
    'dispatch: loop {
        match pc {
            0x82E91B18 => {
    //   block [0x82E91B18..0x82E91B3C)
	// 82E91B18: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E91B1C: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E91B20: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82E91B24: 40980018  bge cr6, 0x82e91b3c
	if !ctx.cr[6].lt {
		sub_82E91B3C(ctx, base);
		return;
	}
	// 82E91B28: EDA10028  fsubs f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E91B2C: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E91B30: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82E91B34: 4198FFF4  blt cr6, 0x82e91b28
	if ctx.cr[6].lt {
	pc = 0x82E91B28; continue 'dispatch;
	}
	// 82E91B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91B3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E91B3C size=12
    let mut pc: u32 = 0x82E91B3C;
    'dispatch: loop {
        match pc {
            0x82E91B3C => {
    //   block [0x82E91B3C..0x82E91B48)
	// 82E91B3C: FDA00050  fneg f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E91B40: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82E91B44: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E91B48 size=28
    let mut pc: u32 = 0x82E91B48;
    'dispatch: loop {
        match pc {
            0x82E91B48 => {
    //   block [0x82E91B48..0x82E91B64)
	// 82E91B48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E91B4C: C18B9524  lfs f12, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E91B50: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E91B54: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82E91B58: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82E91B5C: 4199FFF8  bgt cr6, 0x82e91b54
	if ctx.cr[6].gt {
	pc = 0x82E91B54; continue 'dispatch;
	}
	// 82E91B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E91B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E91B68 size=80
    let mut pc: u32 = 0x82E91B68;
    'dispatch: loop {
        match pc {
            0x82E91B68 => {
    //   block [0x82E91B68..0x82E91BB8)
	// 82E91B68: ED210072  fmuls f9, f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E91B6C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E91B70: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E91B74: 392BE47C  addi r9, r11, -0x1b84
	ctx.r[9].s64 = ctx.r[11].s64 + -7044;
	// 82E91B78: 3D008212  lis r8, -0x7dee
	ctx.r[8].s64 = -2112749568;
	// 82E91B7C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82E91B80: C00BE47C  lfs f0, -0x1b84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E91B84: C1AAE1D4  lfs f13, -0x1e2c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7724 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E91B88: C189FFF8  lfs f12, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E91B8C: C168E1CC  lfs f11, -0x1e34(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-7732 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E91B90: C149FFF0  lfs f10, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E91B94: ED096838  fmsubs f8, f9, f0, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E91B98: C007952C  lfs f0, -0x6ad4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E91B9C: ECE90072  fmuls f7, f9, f1
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E91BA0: ECC8627A  fmadds f6, f8, f9, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E91BA4: ECA65A78  fmsubs f5, f6, f9, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E91BA8: EC85527A  fmadds f4, f5, f9, f10
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E91BAC: EC640278  fmsubs f3, f4, f9, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E91BB0: EC2309FA  fmadds f1, f3, f7, f1
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[7].f64 + ctx.f[1].f64) as f32) as f64);
	// 82E91BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


