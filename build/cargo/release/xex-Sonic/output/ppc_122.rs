pub fn sub_829BB388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BB388 size=80
    let mut pc: u32 = 0x829BB388;
    'dispatch: loop {
        match pc {
            0x829BB388 => {
    //   block [0x829BB388..0x829BB3D8)
	// 829BB388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BB390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BB394: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BB39C: 4BFE7C95  bl 0x829a3030
	ctx.lr = 0x829BB3A0;
	sub_829A3030(ctx, base);
	// 829BB3A0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BB3A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BB3A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829BB3AC: 394A2BA8  addi r10, r10, 0x2ba8
	ctx.r[10].s64 = ctx.r[10].s64 + 11176;
	// 829BB3B0: 993F0014  stb r9, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 829BB3B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB3B8: C00B9E84  lfs f0, -0x617c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24956 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BB3BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829BB3C0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BB3C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BB3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BB3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BB3D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB3D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BB3D8 size=380
    let mut pc: u32 = 0x829BB3D8;
    'dispatch: loop {
        match pc {
            0x829BB3D8 => {
    //   block [0x829BB3D8..0x829BB554)
	// 829BB3D8: DBA1FFE8  stfd f29, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[29].u64 ) };
	// 829BB3DC: DBC1FFF0  stfd f30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[30].u64 ) };
	// 829BB3E0: DBE1FFF8  stfd f31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 829BB3E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BB3E8: 89240014  lbz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829BB3EC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BB3F0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 829BB3F4: 396B9EA8  addi r11, r11, -0x6158
	ctx.r[11].s64 = ctx.r[11].s64 + -24920;
	// 829BB3F8: C06A08A4  lfs f3, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829BB3FC: FC001890  fmr f0, f3
	ctx.f[0].f64 = ctx.f[3].f64;
	// 829BB400: 409A0024  bne cr6, 0x829bb424
	if !ctx.cr[6].eq {
	pc = 0x829BB424; continue 'dispatch;
	}
	// 829BB404: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BB408: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BB40C: C00BFFE0  lfs f0, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BB410: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829BB414: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BB418: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829BB41C: 41980008  blt cr6, 0x829bb424
	if ctx.cr[6].lt {
	pc = 0x829BB424; continue 'dispatch;
	}
	// 829BB420: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 829BB424: C1ABFFE4  lfs f13, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BB428: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BB42C: C0AB0004  lfs f5, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 829BB430: ECC56828  fsubs f6, f5, f13
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BB434: C18BFFE8  lfs f12, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BB438: C08B0008  lfs f4, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 829BB43C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829BB440: C16BFFEC  lfs f11, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BB444: EC446028  fsubs f2, f4, f12
	ctx.f[2].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 829BB448: C0AB000C  lfs f5, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 829BB44C: C14BFFF0  lfs f10, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829BB450: EC255828  fsubs f1, f5, f11
	ctx.f[1].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 829BB454: C08B0010  lfs f4, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 829BB458: C12BFFF4  lfs f9, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829BB45C: EFE45028  fsubs f31, f4, f10
	ctx.f[31].f64 = (((ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 829BB460: C0AB0014  lfs f5, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 829BB464: C10BFFF8  lfs f8, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829BB468: EFC54828  fsubs f30, f5, f9
	ctx.f[30].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 829BB46C: C08B0018  lfs f4, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 829BB470: C0EBFFFC  lfs f7, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 829BB474: EFA44028  fsubs f29, f4, f8
	ctx.f[29].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 829BB478: C0AB001C  lfs f5, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 829BB47C: EDA6683A  fmadds f13, f6, f0, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 829BB480: C0CB0000  lfs f6, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 829BB484: ECA53828  fsubs f5, f5, f7
	ctx.f[5].f64 = (((ctx.f[5].f64 - ctx.f[7].f64) as f32) as f64);
	// 829BB488: C08B0020  lfs f4, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 829BB48C: ED82603A  fmadds f12, f2, f0, f12
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 829BB490: EC843028  fsubs f4, f4, f6
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[6].f64) as f32) as f64);
	// 829BB494: ED61583A  fmadds f11, f1, f0, f11
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 829BB498: ED5F503A  fmadds f10, f31, f0, f10
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 829BB49C: ED3E483A  fmadds f9, f30, f0, f9
	ctx.f[9].f64 = (((ctx.f[30].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 829BB4A0: ED1D403A  fmadds f8, f29, f0, f8
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 829BB4A4: ECE5383A  fmadds f7, f5, f0, f7
	ctx.f[7].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 829BB4A8: EC04303A  fmadds f0, f4, f0, f6
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 829BB4AC: 41980088  blt cr6, 0x829bb534
	if ctx.cr[6].lt {
	pc = 0x829BB534; continue 'dispatch;
	}
	// 829BB4B0: 419A006C  beq cr6, 0x829bb51c
	if ctx.cr[6].eq {
	pc = 0x829BB51C; continue 'dispatch;
	}
	// 829BB4B4: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 829BB4B8: 41980054  blt cr6, 0x829bb50c
	if ctx.cr[6].lt {
	pc = 0x829BB50C; continue 'dispatch;
	}
	// 829BB4BC: 419A0044  beq cr6, 0x829bb500
	if ctx.cr[6].eq {
	pc = 0x829BB500; continue 'dispatch;
	}
	// 829BB4C0: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 829BB4C4: 4198002C  blt cr6, 0x829bb4f0
	if ctx.cr[6].lt {
	pc = 0x829BB4F0; continue 'dispatch;
	}
	// 829BB4C8: D063000C  stfs f3, 0xc(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BB4CC: 419A0014  beq cr6, 0x829bb4e0
	if ctx.cr[6].eq {
	pc = 0x829BB4E0; continue 'dispatch;
	}
	// 829BB4D0: D0630000  stfs f3, 0(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BB4D4: D0630004  stfs f3, 4(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB4D8: D0630008  stfs f3, 8(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BB4DC: 48000068  b 0x829bb544
	pc = 0x829BB544; continue 'dispatch;
	// 829BB4E0: D0E30004  stfs f7, 4(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB4E4: FDA04850  fneg f13, f9
	ctx.f[13].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BB4E8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BB4EC: 48000054  b 0x829bb540
	pc = 0x829BB540; continue 'dispatch;
	// 829BB4F0: D1030004  stfs f8, 4(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB4F4: FDA05050  fneg f13, f10
	ctx.f[13].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BB4F8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BB4FC: 48000040  b 0x829bb53c
	pc = 0x829BB53C; continue 'dispatch;
	// 829BB500: D1230000  stfs f9, 0(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BB504: D0E30004  stfs f7, 4(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB508: 4800000C  b 0x829bb514
	pc = 0x829BB514; continue 'dispatch;
	// 829BB50C: D1430000  stfs f10, 0(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BB510: D1030004  stfs f8, 4(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB514: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BB518: 48000014  b 0x829bb52c
	pc = 0x829BB52C; continue 'dispatch;
	// 829BB51C: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BB520: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BB524: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB528: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BB52C: D063000C  stfs f3, 0xc(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BB530: 48000014  b 0x829bb544
	pc = 0x829BB544; continue 'dispatch;
	// 829BB534: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BB538: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BB53C: D063000C  stfs f3, 0xc(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BB540: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BB544: CBA1FFE8  lfd f29, -0x18(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BB548: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB54C: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 829BB550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BB558 size=172
    let mut pc: u32 = 0x829BB558;
    'dispatch: loop {
        match pc {
            0x829BB558 => {
    //   block [0x829BB558..0x829BB604)
	// 829BB558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BB560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BB564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BB568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB56C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BB570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BB574: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BB578: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BB57C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB580: 4B9053B9  bl 0x822c0938
	ctx.lr = 0x829BB584;
	sub_822C0938(ctx, base);
	// 829BB584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BB588: 41820028  beq 0x829bb5b0
	if ctx.cr[0].eq {
	pc = 0x829BB5B0; continue 'dispatch;
	}
	// 829BB58C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BB590: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BB594: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BB598: 392B2BC0  addi r9, r11, 0x2bc0
	ctx.r[9].s64 = ctx.r[11].s64 + 11200;
	// 829BB59C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BB5A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BB5A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BB5A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BB5AC: 48000008  b 0x829bb5b4
	pc = 0x829BB5B4; continue 'dispatch;
	// 829BB5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BB5B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BB5BC: 409A002C  bne cr6, 0x829bb5e8
	if !ctx.cr[6].eq {
	pc = 0x829BB5E8; continue 'dispatch;
	}
	// 829BB5C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB5C4: 4B904CA5  bl 0x822c0268
	ctx.lr = 0x829BB5C8;
	sub_822C0268(ctx, base);
	// 829BB5C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BB5CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BB5D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BB5D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BB5D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BB5DC: 816B9EDC  lwz r11, -0x6124(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24868 as u32) ) } as u64;
	// 829BB5E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BB5E4: 4B904A1D  bl 0x822c0000
	ctx.lr = 0x829BB5E8;
	sub_822C0000(ctx, base);
	// 829BB5E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BB5EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BB5F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BB5F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BB5F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BB5FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BB608 size=196
    let mut pc: u32 = 0x829BB608;
    'dispatch: loop {
        match pc {
            0x829BB608 => {
    //   block [0x829BB608..0x829BB6CC)
	// 829BB608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB60C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BB610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BB614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BB618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB61C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BB620: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BB624: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BB628: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BB62C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB630: 4B905309  bl 0x822c0938
	ctx.lr = 0x829BB634;
	sub_822C0938(ctx, base);
	// 829BB634: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BB638: 41820028  beq 0x829bb660
	if ctx.cr[0].eq {
	pc = 0x829BB660; continue 'dispatch;
	}
	// 829BB63C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BB640: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BB644: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BB648: 392B2BD4  addi r9, r11, 0x2bd4
	ctx.r[9].s64 = ctx.r[11].s64 + 11220;
	// 829BB64C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BB650: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BB654: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BB658: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BB65C: 48000008  b 0x829bb664
	pc = 0x829BB664; continue 'dispatch;
	// 829BB660: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BB664: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BB66C: 409A0044  bne cr6, 0x829bb6b0
	if !ctx.cr[6].eq {
	pc = 0x829BB6B0; continue 'dispatch;
	}
	// 829BB670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BB674: 419A001C  beq cr6, 0x829bb690
	if ctx.cr[6].eq {
	pc = 0x829BB690; continue 'dispatch;
	}
	// 829BB678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BB67C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BB680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB684: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BB688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BB68C: 4E800421  bctrl
	ctx.lr = 0x829BB690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BB690: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BB694: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BB698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BB69C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BB6A0: 816B9EDC  lwz r11, -0x6124(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24868 as u32) ) } as u64;
	// 829BB6A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BB6A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BB6AC: 4B904955  bl 0x822c0000
	ctx.lr = 0x829BB6B0;
	sub_822C0000(ctx, base);
	// 829BB6B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BB6B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BB6B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BB6BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BB6C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BB6C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB6C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BB6D0 size=156
    let mut pc: u32 = 0x829BB6D0;
    'dispatch: loop {
        match pc {
            0x829BB6D0 => {
    //   block [0x829BB6D0..0x829BB76C)
	// 829BB6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BB6D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BB6DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BB6E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BB6E8: 396B1A38  addi r11, r11, 0x1a38
	ctx.r[11].s64 = ctx.r[11].s64 + 6712;
	// 829BB6EC: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829BB6F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB6F4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829BB6F8: 419A0008  beq cr6, 0x829bb700
	if ctx.cr[6].eq {
	pc = 0x829BB700; continue 'dispatch;
	}
	// 829BB6FC: 481D2E25  bl 0x82b8e520
	ctx.lr = 0x829BB700;
	sub_82B8E520(ctx, base);
	// 829BB700: 807F01A4  lwz r3, 0x1a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 829BB704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB708: 419A0008  beq cr6, 0x829bb710
	if ctx.cr[6].eq {
	pc = 0x829BB710; continue 'dispatch;
	}
	// 829BB70C: 4B905185  bl 0x822c0890
	ctx.lr = 0x829BB710;
	sub_822C0890(ctx, base);
	// 829BB710: 807F019C  lwz r3, 0x19c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 829BB714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB718: 419A0008  beq cr6, 0x829bb720
	if ctx.cr[6].eq {
	pc = 0x829BB720; continue 'dispatch;
	}
	// 829BB71C: 4B905175  bl 0x822c0890
	ctx.lr = 0x829BB720;
	sub_822C0890(ctx, base);
	// 829BB720: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 829BB724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB728: 419A0008  beq cr6, 0x829bb730
	if ctx.cr[6].eq {
	pc = 0x829BB730; continue 'dispatch;
	}
	// 829BB72C: 4B905165  bl 0x822c0890
	ctx.lr = 0x829BB730;
	sub_822C0890(ctx, base);
	// 829BB730: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BB734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB738: 419A0008  beq cr6, 0x829bb740
	if ctx.cr[6].eq {
	pc = 0x829BB740; continue 'dispatch;
	}
	// 829BB73C: 4B905155  bl 0x822c0890
	ctx.lr = 0x829BB740;
	sub_822C0890(ctx, base);
	// 829BB740: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829BB744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB748: 419A0008  beq cr6, 0x829bb750
	if ctx.cr[6].eq {
	pc = 0x829BB750; continue 'dispatch;
	}
	// 829BB74C: 4B905145  bl 0x822c0890
	ctx.lr = 0x829BB750;
	sub_822C0890(ctx, base);
	// 829BB750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB754: 484A0E35  bl 0x82e5c588
	ctx.lr = 0x829BB758;
	sub_82E5C588(ctx, base);
	// 829BB758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BB75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BB760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BB764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BB770 size=952
    let mut pc: u32 = 0x829BB770;
    'dispatch: loop {
        match pc {
            0x829BB770 => {
    //   block [0x829BB770..0x829BBB28)
	// 829BB770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB774: 487EC9F1  bl 0x831a8164
	ctx.lr = 0x829BB778;
	sub_831A8130(ctx, base);
	// 829BB778: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 829BB77C: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829BB780: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829BB784: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB788: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829BB78C: 48798E75  bl 0x83154600
	ctx.lr = 0x829BB790;
	sub_83154600(ctx, base);
	// 829BB790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BB794: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829BB798: 4849DFE1  bl 0x82e59778
	ctx.lr = 0x829BB79C;
	sub_82E59778(ctx, base);
	// 829BB79C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BB7A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BB7A4: 807B016C  lwz r3, 0x16c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(364 as u32) ) } as u64;
	// 829BB7A8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829BB7AC: C00B94B0  lfs f0, -0x6b50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27472 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BB7B0: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BB7B4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BB7B8: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 829BB7BC: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 829BB7C0: D3E100CC  stfs f31, 0xcc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 829BB7C4: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 829BB7C8: 419A0038  beq cr6, 0x829bb800
	if ctx.cr[6].eq {
	pc = 0x829BB800; continue 'dispatch;
	}
	// 829BB7CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BB7D0: 3BC100C0  addi r30, r1, 0xc0
	ctx.r[30].s64 = ctx.r[1].s64 + 192;
	// 829BB7D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829BB7D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BB7DC: 4E800421  bctrl
	ctx.lr = 0x829BB7E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BB7E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BB7E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BB7E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BB7EC: 484C04DD  bl 0x82e7bcc8
	ctx.lr = 0x829BB7F0;
	sub_82E7BCC8(ctx, base);
	// 829BB7F0: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 829BB7F4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BBB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BBB28 size=120
    let mut pc: u32 = 0x829BBB28;
    'dispatch: loop {
        match pc {
            0x829BBB28 => {
    //   block [0x829BBB28..0x829BBBA0)
	// 829BBB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BBB2C: 487EC641  bl 0x831a816c
	ctx.lr = 0x829BBB30;
	sub_831A8130(ctx, base);
	// 829BBB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BBB34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BBB38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BBB3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BBB40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BBB44: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829BBB48: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829BBB4C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 829BBB50: 48436899  bl 0x82df23e8
	ctx.lr = 0x829BBB54;
	sub_82DF23E8(ctx, base);
	// 829BBB54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BBB58: 41820014  beq 0x829bbb6c
	if ctx.cr[0].eq {
	pc = 0x829BBB6C; continue 'dispatch;
	}
	// 829BBB5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BBB60: 48199A89  bl 0x82b555e8
	ctx.lr = 0x829BBB64;
	sub_82B555E8(ctx, base);
	// 829BBB64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BBB68: 48000008  b 0x829bbb70
	pc = 0x829BBB70; continue 'dispatch;
	// 829BBB6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829BBB70: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829BBB74: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829BBB78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BBB7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BBB80: 4BBBC301  bl 0x82577e80
	ctx.lr = 0x829BBB84;
	sub_82577E80(ctx, base);
	// 829BBB84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BBB88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BBB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BBB90: 4B904471  bl 0x822c0000
	ctx.lr = 0x829BBB94;
	sub_822C0000(ctx, base);
	// 829BBB94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BBB98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BBB9C: 487EC620  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BBBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BBBA0 size=112
    let mut pc: u32 = 0x829BBBA0;
    'dispatch: loop {
        match pc {
            0x829BBBA0 => {
    //   block [0x829BBBA0..0x829BBC10)
	// 829BBBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BBBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BBBA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BBBAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BBBB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BBBB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829BBBB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BBBBC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829BBBC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BBBC4: 4BFFFA45  bl 0x829bb608
	ctx.lr = 0x829BBBC8;
	sub_829BB608(ctx, base);
	// 829BBBC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BBBCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BBBD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BBBD4: 4B90442D  bl 0x822c0000
	ctx.lr = 0x829BBBD8;
	sub_822C0000(ctx, base);
	// 829BBBD8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BBBDC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BBBE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BBBE4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BBBE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BBBEC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BBBF0: 419A0008  beq cr6, 0x829bbbf8
	if ctx.cr[6].eq {
	pc = 0x829BBBF8; continue 'dispatch;
	}
	// 829BBBF4: 4B904C9D  bl 0x822c0890
	ctx.lr = 0x829BBBF8;
	sub_822C0890(ctx, base);
	// 829BBBF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BBBFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BBC00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BBC04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BBC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BBC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BBC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BBC10 size=1088
    let mut pc: u32 = 0x829BBC10;
    'dispatch: loop {
        match pc {
            0x829BBC10 => {
    //   block [0x829BBC10..0x829BC050)
	// 829BBC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BBC14: 487EC541  bl 0x831a8154
	ctx.lr = 0x829BBC18;
	sub_831A8130(ctx, base);
	// 829BBC18: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 829BBC1C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BBC20: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829BBC24: 487989DD  bl 0x83154600
	ctx.lr = 0x829BBC28;
	sub_83154600(ctx, base);
	// 829BBC28: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829BBC2C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 829BBC30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BBC34: 9AFB046C  stb r23, 0x46c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(1132 as u32), ctx.r[23].u8 ) };
	// 829BBC38: 4BB53F09  bl 0x8250fb40
	ctx.lr = 0x829BBC3C;
	sub_8250FB40(ctx, base);
	// 829BBC3C: 3BDB01BC  addi r30, r27, 0x1bc
	ctx.r[30].s64 = ctx.r[27].s64 + 444;
	// 829BBC40: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 829BBC44: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 829BBC48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829BBC4C: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829BBC50: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BBC54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829BBC58: 4BB54599  bl 0x825101f0
	ctx.lr = 0x829BBC5C;
	sub_825101F0(ctx, base);
	// 829BBC5C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829BBC60: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829BBC64: 4082FFE4  bne 0x829bbc48
	if !ctx.cr[0].eq {
	pc = 0x829BBC48; continue 'dispatch;
	}
	// 829BBC68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BBC6C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829BBC70: 4BFEB201  bl 0x829a6e70
	ctx.lr = 0x829BBC74;
	sub_829A6E70(ctx, base);
	// 829BBC74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829BBC78: 809B0460  lwz r4, 0x460(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1120 as u32) ) } as u64;
	// 829BBC7C: 4BB56025  bl 0x82511ca0
	ctx.lr = 0x829BBC80;
	sub_82511CA0(ctx, base);
	// 829BBC80: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BBC84: 4BFFA755  bl 0x829b63d8
	ctx.lr = 0x829BBC88;
	sub_829B63D8(ctx, base);
	// 829BBC88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BBC8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BBC90: 3B2B2C00  addi r25, r11, 0x2c00
	ctx.r[25].s64 = ctx.r[11].s64 + 11264;
	// 829BBC94: 38A00124  li r5, 0x124
	ctx.r[5].s64 = 292;
	// 829BBC98: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829BBC9C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829BBCA0: 4B904739  bl 0x822c03d8
	ctx.lr = 0x829BBCA4;
	sub_822C03D8(ctx, base);
	// 829BBCA4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829BBCA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BBCAC: 41820010  beq 0x829bbcbc
	if ctx.cr[0].eq {
	pc = 0x829BBCBC; continue 'dispatch;
	}
	// 829BBCB0: 4BFFF6D9  bl 0x829bb388
	ctx.lr = 0x829BBCB4;
	sub_829BB388(ctx, base);
	// 829BBCB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BBCB8: 48000008  b 0x829bbcc0
	pc = 0x829BBCC0; continue 'dispatch;
	// 829BBCBC: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 829BBCC0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829BBCC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BBCC8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829BBCCC: 4BFFF88D  bl 0x829bb558
	ctx.lr = 0x829BBCD0;
	sub_829BB558(ctx, base);
	// 829BBCD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BBCD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BBCD8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829BBCDC: 4B904325  bl 0x822c0000
	ctx.lr = 0x829BBCE0;
	sub_822C0000(ctx, base);
	// 829BBCE0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829BBCE4: 3BFA01A0  addi r31, r26, 0x1a0
	ctx.r[31].s64 = ctx.r[26].s64 + 416;
	// 829BBCE8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 829BBCEC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829BBCF0: 917A01A0  stw r11, 0x1a0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 829BBCF4: 4B90876D  bl 0x822c4460
	ctx.lr = 0x829BBCF8;
	sub_822C4460(ctx, base);
	// 829BBCF8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BBCFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BBD00: 419A0008  beq cr6, 0x829bbd08
	if ctx.cr[6].eq {
	pc = 0x829BBD08; continue 'dispatch;
	}
	// 829BBD04: 4B904B8D  bl 0x822c0890
	ctx.lr = 0x829BBD08;
	sub_822C0890(ctx, base);
	// 829BBD08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BBD0C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBD10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBD14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829BBD18: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829BBD1C: 419A0024  beq cr6, 0x829bbd40
	if ctx.cr[6].eq {
	pc = 0x829BBD40; continue 'dispatch;
	}
	// 829BBD20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BBD24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BBD28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBD2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BBD30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BBD34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BBD38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBD3C: 4082FFE8  bne 0x829bbd24
	if !ctx.cr[0].eq {
	pc = 0x829BBD24; continue 'dispatch;
	}
	// 829BBD40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BBD44: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BBD48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829BBD4C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BBD50: 4BFE9311  bl 0x829a5060
	ctx.lr = 0x829BBD54;
	sub_829A5060(ctx, base);
	// 829BBD54: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829BBD58: 9B1A0168  stb r24, 0x168(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(360 as u32), ctx.r[24].u8 ) };
	// 829BBD5C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829BBD60: 3BFB0148  addi r31, r27, 0x148
	ctx.r[31].s64 = ctx.r[27].s64 + 328;
	// 829BBD64: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 829BBD68: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 829BBD6C: 3B8A6910  addi r28, r10, 0x6910
	ctx.r[28].s64 = ctx.r[10].s64 + 26896;
	// 829BBD70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829BBD74: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBD78: 4BBCF0F1  bl 0x8258ae68
	ctx.lr = 0x829BBD7C;
	sub_8258AE68(ctx, base);
	// 829BBD7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BBD80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBD84: 4BBCF12D  bl 0x8258aeb0
	ctx.lr = 0x829BBD88;
	sub_8258AEB0(ctx, base);
	// 829BBD88: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829BBD8C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829BBD90: 4082FFE0  bne 0x829bbd70
	if !ctx.cr[0].eq {
	pc = 0x829BBD70; continue 'dispatch;
	}
	// 829BBD94: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 829BBD98: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 829BBD9C: 9301006C  stw r24, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[24].u32 ) };
	// 829BBDA0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829BBDA4: 4BFFFD85  bl 0x829bbb28
	ctx.lr = 0x829BBDA8;
	sub_829BBB28(ctx, base);
	// 829BBDA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBDAC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829BBDB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BBDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBDB8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829BBDBC: 419A0024  beq cr6, 0x829bbde0
	if ctx.cr[6].eq {
	pc = 0x829BBDE0; continue 'dispatch;
	}
	// 829BBDC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BBDC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BBDC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBDCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BBDD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BBDD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BBDD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBDDC: 4082FFE8  bne 0x829bbdc4
	if !ctx.cr[0].eq {
	pc = 0x829BBDC4; continue 'dispatch;
	}
	// 829BBDE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BBDE4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BBDE8: 4BB536E1  bl 0x8250f4c8
	ctx.lr = 0x829BBDEC;
	sub_8250F4C8(ctx, base);
	// 829BBDEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBDF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBDF4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BBDF8: 409A0008  bne cr6, 0x829bbe00
	if !ctx.cr[6].eq {
	pc = 0x829BBE00; continue 'dispatch;
	}
	// 829BBDFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BBE00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BBE04: 3BFB0028  addi r31, r27, 0x28
	ctx.r[31].s64 = ctx.r[27].s64 + 40;
	// 829BBE08: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 829BBE0C: 4BB4CC0D  bl 0x82508a18
	ctx.lr = 0x829BBE10;
	sub_82508A18(ctx, base);
	// 829BBE10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BBE14: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BBE18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829BBE1C: 38A00149  li r5, 0x149
	ctx.r[5].s64 = 329;
	// 829BBE20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BBE24: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BBE28: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829BBE2C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BBE30: 4849CC11  bl 0x82e58a40
	ctx.lr = 0x829BBE34;
	sub_82E58A40(ctx, base);
	// 829BBE34: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BBE38: 48435E59  bl 0x82df1c90
	ctx.lr = 0x829BBE3C;
	sub_82DF1C90(ctx, base);
	// 829BBE3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BBE40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BBE44: 419A0008  beq cr6, 0x829bbe4c
	if ctx.cr[6].eq {
	pc = 0x829BBE4C; continue 'dispatch;
	}
	// 829BBE48: 4B904A49  bl 0x822c0890
	ctx.lr = 0x829BBE4C;
	sub_822C0890(ctx, base);
	// 829BBE4C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829BBE50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BBE54: 419A0008  beq cr6, 0x829bbe5c
	if ctx.cr[6].eq {
	pc = 0x829BBE5C; continue 'dispatch;
	}
	// 829BBE58: 4B904A39  bl 0x822c0890
	ctx.lr = 0x829BBE5C;
	sub_822C0890(ctx, base);
	// 829BBE5C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829BBE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBE64: 419A0044  beq cr6, 0x829bbea8
	if ctx.cr[6].eq {
	pc = 0x829BBEA8; continue 'dispatch;
	}
	// 829BBE68: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829BBE6C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829BBE70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BBE74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBE78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BBE7C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829BBE80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BBE84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBE88: 4082FFE8  bne 0x829bbe70
	if !ctx.cr[0].eq {
	pc = 0x829BBE70; continue 'dispatch;
	}
	// 829BBE8C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 829BBE90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BBE94: 409A0014  bne cr6, 0x829bbea8
	if !ctx.cr[6].eq {
	pc = 0x829BBEA8; continue 'dispatch;
	}
	// 829BBE98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBE9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829BBEA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BBEA4: 4E800421  bctrl
	ctx.lr = 0x829BBEA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BBEA8: 397A0180  addi r11, r26, 0x180
	ctx.r[11].s64 = ctx.r[26].s64 + 384;
	// 829BBEAC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BBEB0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BBEB4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829BBEB8: 4B961319  bl 0x8231d1d0
	ctx.lr = 0x829BBEBC;
	sub_8231D1D0(ctx, base);
	// 829BBEBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBEC0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829BBEC4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BBEC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBECC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829BBED0: 419A0024  beq cr6, 0x829bbef4
	if ctx.cr[6].eq {
	pc = 0x829BBEF4; continue 'dispatch;
	}
	// 829BBED4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BBED8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BBEDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBEE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BBEE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BBEE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BBEEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBEF0: 4082FFE8  bne 0x829bbed8
	if !ctx.cr[0].eq {
	pc = 0x829BBED8; continue 'dispatch;
	}
	// 829BBEF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BBEF8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BBEFC: 4BB535CD  bl 0x8250f4c8
	ctx.lr = 0x829BBF00;
	sub_8250F4C8(ctx, base);
	// 829BBF00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBF08: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BBF0C: 409A0008  bne cr6, 0x829bbf14
	if !ctx.cr[6].eq {
	pc = 0x829BBF14; continue 'dispatch;
	}
	// 829BBF10: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BBF14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BBF18: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 829BBF1C: 4BB4CAFD  bl 0x82508a18
	ctx.lr = 0x829BBF20;
	sub_82508A18(ctx, base);
	// 829BBF20: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BBF24: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829BBF28: 38A0014F  li r5, 0x14f
	ctx.r[5].s64 = 335;
	// 829BBF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BBF30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829BBF34: 4849B0B5  bl 0x82e56fe8
	ctx.lr = 0x829BBF38;
	sub_82E56FE8(ctx, base);
	// 829BBF38: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BBF3C: 48435D55  bl 0x82df1c90
	ctx.lr = 0x829BBF40;
	sub_82DF1C90(ctx, base);
	// 829BBF40: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829BBF44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BBF48: 419A0008  beq cr6, 0x829bbf50
	if ctx.cr[6].eq {
	pc = 0x829BBF50; continue 'dispatch;
	}
	// 829BBF4C: 4B904945  bl 0x822c0890
	ctx.lr = 0x829BBF50;
	sub_822C0890(ctx, base);
	// 829BBF50: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829BBF54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BBF58: 419A0008  beq cr6, 0x829bbf60
	if ctx.cr[6].eq {
	pc = 0x829BBF60; continue 'dispatch;
	}
	// 829BBF5C: 4B904935  bl 0x822c0890
	ctx.lr = 0x829BBF60;
	sub_822C0890(ctx, base);
	// 829BBF60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BBF64: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829BBF68: 4BB53561  bl 0x8250f4c8
	ctx.lr = 0x829BBF6C;
	sub_8250F4C8(ctx, base);
	// 829BBF6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBF74: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BBF78: 409A0008  bne cr6, 0x829bbf80
	if !ctx.cr[6].eq {
	pc = 0x829BBF80; continue 'dispatch;
	}
	// 829BBF7C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BBF80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BBF84: 4BB4C55D  bl 0x825084e0
	ctx.lr = 0x829BBF88;
	sub_825084E0(ctx, base);
	// 829BBF88: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829BBF8C: 48435D05  bl 0x82df1c90
	ctx.lr = 0x829BBF90;
	sub_82DF1C90(ctx, base);
	// 829BBF90: 9AE10050  stb r23, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u8 ) };
	// 829BBF94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829BBF98: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829BBF9C: 4BB06AFD  bl 0x824c2a98
	ctx.lr = 0x829BBFA0;
	sub_824C2A98(ctx, base);
	// 829BBFA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBFA4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829BBFA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BBFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBFB0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 829BBFB4: 419A0024  beq cr6, 0x829bbfd8
	if ctx.cr[6].eq {
	pc = 0x829BBFD8; continue 'dispatch;
	}
	// 829BBFB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BBFBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BBFC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBFC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BBFC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BBFCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BBFD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BBFD4: 4082FFE8  bne 0x829bbfbc
	if !ctx.cr[0].eq {
	pc = 0x829BBFBC; continue 'dispatch;
	}
	// 829BBFD8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BBFDC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829BBFE0: 4BB534E9  bl 0x8250f4c8
	ctx.lr = 0x829BBFE4;
	sub_8250F4C8(ctx, base);
	// 829BBFE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BBFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BBFEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BBFF0: 409A0008  bne cr6, 0x829bbff8
	if !ctx.cr[6].eq {
	pc = 0x829BBFF8; continue 'dispatch;
	}
	// 829BBFF4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BBFF8: 3BC10078  addi r30, r1, 0x78
	ctx.r[30].s64 = ctx.r[1].s64 + 120;
	// 829BBFFC: 4BB4CA85  bl 0x82508a80
	ctx.lr = 0x829BC000;
	sub_82508A80(ctx, base);
	// 829BC000: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BC004: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BC008: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829BC00C: 38A0015A  li r5, 0x15a
	ctx.r[5].s64 = 346;
	// 829BC010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BC014: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829BC018: 4849CA29  bl 0x82e58a40
	ctx.lr = 0x829BC01C;
	sub_82E58A40(ctx, base);
	// 829BC01C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829BC020: 48435C71  bl 0x82df1c90
	ctx.lr = 0x829BC024;
	sub_82DF1C90(ctx, base);
	// 829BC024: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829BC028: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC02C: 419A0008  beq cr6, 0x829bc034
	if ctx.cr[6].eq {
	pc = 0x829BC034; continue 'dispatch;
	}
	// 829BC030: 4B904861  bl 0x822c0890
	ctx.lr = 0x829BC034;
	sub_822C0890(ctx, base);
	// 829BC034: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829BC038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC03C: 419A0008  beq cr6, 0x829bc044
	if ctx.cr[6].eq {
	pc = 0x829BC044; continue 'dispatch;
	}
	// 829BC040: 4B904851  bl 0x822c0890
	ctx.lr = 0x829BC044;
	sub_822C0890(ctx, base);
	// 829BC044: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 829BC048: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 829BC04C: 487EC158  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BC050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BC050 size=776
    let mut pc: u32 = 0x829BC050;
    'dispatch: loop {
        match pc {
            0x829BC050 => {
    //   block [0x829BC050..0x829BC358)
	// 829BC050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BC054: 487EC10D  bl 0x831a8160
	ctx.lr = 0x829BC058;
	sub_831A8130(ctx, base);
	// 829BC058: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829BC05C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BC060: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829BC064: 4879859D  bl 0x83154600
	ctx.lr = 0x829BC068;
	sub_83154600(ctx, base);
	// 829BC068: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BC06C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829BC070: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BC074: 9B5D046C  stb r26, 0x46c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1132 as u32), ctx.r[26].u8 ) };
	// 829BC078: 4BB53AC9  bl 0x8250fb40
	ctx.lr = 0x829BC07C;
	sub_8250FB40(ctx, base);
	// 829BC07C: 3BDD01BC  addi r30, r29, 0x1bc
	ctx.r[30].s64 = ctx.r[29].s64 + 444;
	// 829BC080: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 829BC084: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 829BC088: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829BC08C: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829BC090: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BC094: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC098: 4BB54AC1  bl 0x82510b58
	ctx.lr = 0x829BC09C;
	sub_82510B58(ctx, base);
	// 829BC09C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829BC0A0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829BC0A4: 4082FFE4  bne 0x829bc088
	if !ctx.cr[0].eq {
	pc = 0x829BC088; continue 'dispatch;
	}
	// 829BC0A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BC0AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC0B0: 4BFEADC1  bl 0x829a6e70
	ctx.lr = 0x829BC0B4;
	sub_829A6E70(ctx, base);
	// 829BC0B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC0B8: 809D0460  lwz r4, 0x460(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1120 as u32) ) } as u64;
	// 829BC0BC: 4BB55C05  bl 0x82511cc0
	ctx.lr = 0x829BC0C0;
	sub_82511CC0(ctx, base);
	// 829BC0C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC0C4: 80BD0464  lwz r5, 0x464(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1124 as u32) ) } as u64;
	// 829BC0C8: 809D0460  lwz r4, 0x460(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1120 as u32) ) } as u64;
	// 829BC0CC: 4BB55C0D  bl 0x82511cd8
	ctx.lr = 0x829BC0D0;
	sub_82511CD8(ctx, base);
	// 829BC0D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BC0D4: 4BBBC875  bl 0x82578948
	ctx.lr = 0x829BC0D8;
	sub_82578948(ctx, base);
	// 829BC0D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC0DC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BC0E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BC0E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC0E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829BC0EC: 419A0024  beq cr6, 0x829bc110
	if ctx.cr[6].eq {
	pc = 0x829BC110; continue 'dispatch;
	}
	// 829BC0F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BC0F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BC0F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC0FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BC100: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BC104: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BC108: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC10C: 4082FFE8  bne 0x829bc0f4
	if !ctx.cr[0].eq {
	pc = 0x829BC0F4; continue 'dispatch;
	}
	// 829BC110: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC114: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829BC118: 4BB533B1  bl 0x8250f4c8
	ctx.lr = 0x829BC11C;
	sub_8250F4C8(ctx, base);
	// 829BC11C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC124: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC128: 409A0008  bne cr6, 0x829bc130
	if !ctx.cr[6].eq {
	pc = 0x829BC130; continue 'dispatch;
	}
	// 829BC12C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BC130: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BC134: 3BDD0028  addi r30, r29, 0x28
	ctx.r[30].s64 = ctx.r[29].s64 + 40;
	// 829BC138: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 829BC13C: 4BB4C8DD  bl 0x82508a18
	ctx.lr = 0x829BC140;
	sub_82508A18(ctx, base);
	// 829BC140: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BC144: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BC148: 3B8B2C00  addi r28, r11, 0x2c00
	ctx.r[28].s64 = ctx.r[11].s64 + 11264;
	// 829BC14C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BC150: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829BC154: 38A00187  li r5, 0x187
	ctx.r[5].s64 = 391;
	// 829BC158: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BC15C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BC160: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829BC164: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BC168: 4849C8D9  bl 0x82e58a40
	ctx.lr = 0x829BC16C;
	sub_82E58A40(ctx, base);
	// 829BC16C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829BC170: 48435B21  bl 0x82df1c90
	ctx.lr = 0x829BC174;
	sub_82DF1C90(ctx, base);
	// 829BC174: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BC178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC17C: 419A0008  beq cr6, 0x829bc184
	if ctx.cr[6].eq {
	pc = 0x829BC184; continue 'dispatch;
	}
	// 829BC180: 4B904711  bl 0x822c0890
	ctx.lr = 0x829BC184;
	sub_822C0890(ctx, base);
	// 829BC184: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829BC188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC18C: 419A0008  beq cr6, 0x829bc194
	if ctx.cr[6].eq {
	pc = 0x829BC194; continue 'dispatch;
	}
	// 829BC190: 4B904701  bl 0x822c0890
	ctx.lr = 0x829BC194;
	sub_822C0890(ctx, base);
	// 829BC194: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC198: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829BC19C: 4BB5332D  bl 0x8250f4c8
	ctx.lr = 0x829BC1A0;
	sub_8250F4C8(ctx, base);
	// 829BC1A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC1A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC1A8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829BC1AC: 409A0008  bne cr6, 0x829bc1b4
	if !ctx.cr[6].eq {
	pc = 0x829BC1B4; continue 'dispatch;
	}
	// 829BC1B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829BC1B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BC1B8: 4BB4E799  bl 0x8250a950
	ctx.lr = 0x829BC1BC;
	sub_8250A950(ctx, base);
	// 829BC1BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829BC1C0: 48435AD1  bl 0x82df1c90
	ctx.lr = 0x829BC1C4;
	sub_82DF1C90(ctx, base);
	// 829BC1C4: 807B0198  lwz r3, 0x198(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(408 as u32) ) } as u64;
	// 829BC1C8: 3BFB0198  addi r31, r27, 0x198
	ctx.r[31].s64 = ctx.r[27].s64 + 408;
	// 829BC1CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829BC1D0: 419A0040  beq cr6, 0x829bc210
	if ctx.cr[6].eq {
	pc = 0x829BC210; continue 'dispatch;
	}
	// 829BC1D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BC1D8: 484C5569  bl 0x82e81740
	ctx.lr = 0x829BC1DC;
	sub_82E81740(ctx, base);
	// 829BC1DC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 829BC1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC1E4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829BC1E8: 409A0008  bne cr6, 0x829bc1f0
	if !ctx.cr[6].eq {
	pc = 0x829BC1F0; continue 'dispatch;
	}
	// 829BC1EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BC1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BC1F4: 4BE1780D  bl 0x827d3a00
	ctx.lr = 0x829BC1F8;
	sub_827D3A00(ctx, base);
	// 829BC1F8: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 829BC1FC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BC200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC204: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 829BC208: 419A0008  beq cr6, 0x829bc210
	if ctx.cr[6].eq {
	pc = 0x829BC210; continue 'dispatch;
	}
	// 829BC20C: 4B904685  bl 0x822c0890
	ctx.lr = 0x829BC210;
	sub_822C0890(ctx, base);
	// 829BC210: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BC214: 48435A7D  bl 0x82df1c90
	ctx.lr = 0x829BC218;
	sub_82DF1C90(ctx, base);
	// 829BC218: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 829BC21C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829BC220: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829BC224: 4BB06875  bl 0x824c2a98
	ctx.lr = 0x829BC228;
	sub_824C2A98(ctx, base);
	// 829BC228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC22C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829BC230: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BC234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC238: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829BC23C: 419A0024  beq cr6, 0x829bc260
	if ctx.cr[6].eq {
	pc = 0x829BC260; continue 'dispatch;
	}
	// 829BC240: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BC244: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BC248: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC24C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BC250: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BC254: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BC258: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC25C: 4082FFE8  bne 0x829bc244
	if !ctx.cr[0].eq {
	pc = 0x829BC244; continue 'dispatch;
	}
	// 829BC260: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC264: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BC268: 4BB53261  bl 0x8250f4c8
	ctx.lr = 0x829BC26C;
	sub_8250F4C8(ctx, base);
	// 829BC26C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC274: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC278: 409A0008  bne cr6, 0x829bc280
	if !ctx.cr[6].eq {
	pc = 0x829BC280; continue 'dispatch;
	}
	// 829BC27C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BC280: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 829BC284: 4BB4C7FD  bl 0x82508a80
	ctx.lr = 0x829BC288;
	sub_82508A80(ctx, base);
	// 829BC288: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BC28C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BC290: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829BC294: 38A001A7  li r5, 0x1a7
	ctx.r[5].s64 = 423;
	// 829BC298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BC29C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829BC2A0: 4849C7A1  bl 0x82e58a40
	ctx.lr = 0x829BC2A4;
	sub_82E58A40(ctx, base);
	// 829BC2A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BC2A8: 484359E9  bl 0x82df1c90
	ctx.lr = 0x829BC2AC;
	sub_82DF1C90(ctx, base);
	// 829BC2AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BC2B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC2B4: 419A0008  beq cr6, 0x829bc2bc
	if ctx.cr[6].eq {
	pc = 0x829BC2BC; continue 'dispatch;
	}
	// 829BC2B8: 4B9045D9  bl 0x822c0890
	ctx.lr = 0x829BC2BC;
	sub_822C0890(ctx, base);
	// 829BC2BC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829BC2C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC2C4: 419A0008  beq cr6, 0x829bc2cc
	if ctx.cr[6].eq {
	pc = 0x829BC2CC; continue 'dispatch;
	}
	// 829BC2C8: 4B9045C9  bl 0x822c0890
	ctx.lr = 0x829BC2CC;
	sub_822C0890(ctx, base);
	// 829BC2CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC2D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BC2D4: 4BB53245  bl 0x8250f518
	ctx.lr = 0x829BC2D8;
	sub_8250F518(ctx, base);
	// 829BC2D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC2DC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829BC2E0: 4BB531E9  bl 0x8250f4c8
	ctx.lr = 0x829BC2E4;
	sub_8250F4C8(ctx, base);
	// 829BC2E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC2EC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 829BC2F0: 409A0008  bne cr6, 0x829bc2f8
	if !ctx.cr[6].eq {
	pc = 0x829BC2F8; continue 'dispatch;
	}
	// 829BC2F4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829BC2F8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829BC2FC: 48435995  bl 0x82df1c90
	ctx.lr = 0x829BC300;
	sub_82DF1C90(ctx, base);
	// 829BC300: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC304: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829BC308: 4BB531C1  bl 0x8250f4c8
	ctx.lr = 0x829BC30C;
	sub_8250F4C8(ctx, base);
	// 829BC30C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC314: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC318: 409A0008  bne cr6, 0x829bc320
	if !ctx.cr[6].eq {
	pc = 0x829BC320; continue 'dispatch;
	}
	// 829BC31C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BC320: 4BB4C209  bl 0x82508528
	ctx.lr = 0x829BC324;
	sub_82508528(ctx, base);
	// 829BC324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BC328: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829BC32C: 48435965  bl 0x82df1c90
	ctx.lr = 0x829BC330;
	sub_82DF1C90(ctx, base);
	// 829BC330: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829BC334: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BC338: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829BC33C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC340: 4BFEA771  bl 0x829a6ab0
	ctx.lr = 0x829BC344;
	sub_829A6AB0(ctx, base);
	// 829BC344: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BC348: 48435949  bl 0x82df1c90
	ctx.lr = 0x829BC34C;
	sub_82DF1C90(ctx, base);
	// 829BC34C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 829BC350: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829BC354: 487EBE5C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BC358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BC358 size=1264
    let mut pc: u32 = 0x829BC358;
    'dispatch: loop {
        match pc {
            0x829BC358 => {
    //   block [0x829BC358..0x829BC848)
	// 829BC358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BC35C: 487EBE01  bl 0x831a815c
	ctx.lr = 0x829BC360;
	sub_831A8130(ctx, base);
	// 829BC360: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BC364: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 829BC368: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829BC36C: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 829BC370: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 829BC374: 4879828D  bl 0x83154600
	ctx.lr = 0x829BC378;
	sub_83154600(ctx, base);
	// 829BC378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BC37C: 807B0160  lwz r3, 0x160(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(352 as u32) ) } as u64;
	// 829BC380: 3B5B0160  addi r26, r27, 0x160
	ctx.r[26].s64 = ctx.r[27].s64 + 352;
	// 829BC384: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829BC388: 419A0010  beq cr6, 0x829bc398
	if ctx.cr[6].eq {
	pc = 0x829BC398; continue 'dispatch;
	}
	// 829BC38C: 481D21B5  bl 0x82b8e540
	ctx.lr = 0x829BC390;
	sub_82B8E540(ctx, base);
	// 829BC390: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BC394: 408204AC  bne 0x829bc840
	if !ctx.cr[0].eq {
	pc = 0x829BC840; continue 'dispatch;
	}
	// 829BC398: 8BFB0168  lbz r31, 0x168(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(360 as u32) ) } as u64;
	// 829BC39C: 7FEB0774  extsb r11, r31
	ctx.r[11].s64 = ctx.r[31].s8 as i64;
	// 829BC3A0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 829BC3A4: 41980034  blt cr6, 0x829bc3d8
	if ctx.cr[6].lt {
	pc = 0x829BC3D8; continue 'dispatch;
	}
	// 829BC3A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829BC3AC: 4BFFF3C5  bl 0x829bb770
	ctx.lr = 0x829BC3B0;
	sub_829BB770(ctx, base);
	// 829BC3B0: 9B3D046C  stb r25, 0x46c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1132 as u32), ctx.r[25].u8 ) };
	// 829BC3B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC3B8: 4BFE6CE1  bl 0x829a3098
	ctx.lr = 0x829BC3BC;
	sub_829A3098(ctx, base);
	// 829BC3BC: 987D03D8  stb r3, 0x3d8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(984 as u32), ctx.r[3].u8 ) };
	// 829BC3C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC3C4: 4BFF3FD5  bl 0x829b0398
	ctx.lr = 0x829BC3C8;
	sub_829B0398(ctx, base);
	// 829BC3C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BC3CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC3D0: 4BFE8999  bl 0x829a4d68
	ctx.lr = 0x829BC3D4;
	sub_829A4D68(ctx, base);
	// 829BC3D4: 4800046C  b 0x829bc840
	pc = 0x829BC840; continue 'dispatch;
	// 829BC3D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829BC3DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC3E0: 997B0168  stb r11, 0x168(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(360 as u32), ctx.r[11].u8 ) };
	// 829BC3E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BC3E8: 4BB530E1  bl 0x8250f4c8
	ctx.lr = 0x829BC3EC;
	sub_8250F4C8(ctx, base);
	// 829BC3EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC3F4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC3F8: 409A0008  bne cr6, 0x829bc400
	if !ctx.cr[6].eq {
	pc = 0x829BC400; continue 'dispatch;
	}
	// 829BC3FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829BC400: 4BB4C129  bl 0x82508528
	ctx.lr = 0x829BC404;
	sub_82508528(ctx, base);
	// 829BC404: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BC408: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829BC40C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC410: 4BF58A61  bl 0x82914e70
	ctx.lr = 0x829BC414;
	sub_82914E70(ctx, base);
	// 829BC414: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BC418: 48435879  bl 0x82df1c90
	ctx.lr = 0x829BC41C;
	sub_82DF1C90(ctx, base);
	// 829BC41C: 7FFC0774  extsb r28, r31
	ctx.r[28].s64 = ctx.r[31].s8 as i64;
	// 829BC420: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BC424: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829BC428: 396B9ECC  addi r11, r11, -0x6134
	ctx.r[11].s64 = ctx.r[11].s64 + -24884;
	// 829BC42C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC430: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829BC434: 484375D5  bl 0x82df3a08
	ctx.lr = 0x829BC438;
	sub_82DF3A08(ctx, base);
	// 829BC438: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BC43C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BC440: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BC444: 481C359D  bl 0x82b7f9e0
	ctx.lr = 0x829BC448;
	sub_82B7F9E0(ctx, base);
	// 829BC448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC44C: 48436FDD  bl 0x82df3428
	ctx.lr = 0x829BC450;
	sub_82DF3428(ctx, base);
	// 829BC450: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BC454: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BC458: 388B2C00  addi r4, r11, 0x2c00
	ctx.r[4].s64 = ctx.r[11].s64 + 11264;
	// 829BC45C: 38A001F8  li r5, 0x1f8
	ctx.r[5].s64 = 504;
	// 829BC460: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 829BC464: 48435F85  bl 0x82df23e8
	ctx.lr = 0x829BC468;
	sub_82DF23E8(ctx, base);
	// 829BC468: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829BC46C: 41820044  beq 0x829bc4b0
	if ctx.cr[0].eq {
	pc = 0x829BC4B0; continue 'dispatch;
	}
	// 829BC470: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC474: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829BC478: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829BC47C: 4BB5304D  bl 0x8250f4c8
	ctx.lr = 0x829BC480;
	sub_8250F4C8(ctx, base);
	// 829BC480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC488: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC48C: 409A0008  bne cr6, 0x829bc494
	if !ctx.cr[6].eq {
	pc = 0x829BC494; continue 'dispatch;
	}
	// 829BC490: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829BC494: 4BB4C095  bl 0x82508528
	ctx.lr = 0x829BC498;
	sub_82508528(ctx, base);
	// 829BC498: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829BC49C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 829BC4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BC4A4: 481D57ED  bl 0x82b91c90
	ctx.lr = 0x829BC4A8;
	sub_82B91C90(ctx, base);
	// 829BC4A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BC4AC: 48000008  b 0x829bc4b4
	pc = 0x829BC4B4; continue 'dispatch;
	// 829BC4B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829BC4B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BC4B8: 4BFFF6E9  bl 0x829bbba0
	ctx.lr = 0x829BC4BC;
	sub_829BBBA0(ctx, base);
	// 829BC4BC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BC4C0: 4182000C  beq 0x829bc4cc
	if ctx.cr[0].eq {
	pc = 0x829BC4CC; continue 'dispatch;
	}
	// 829BC4C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829BC4C8: 484357C9  bl 0x82df1c90
	ctx.lr = 0x829BC4CC;
	sub_82DF1C90(ctx, base);
	// 829BC4CC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829BC4D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC4D4: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 829BC4D8: 48437531  bl 0x82df3a08
	ctx.lr = 0x829BC4DC;
	sub_82DF3A08(ctx, base);
	// 829BC4DC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BC4E0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC4E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC4E8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829BC4EC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829BC4F0: 419A0024  beq cr6, 0x829bc514
	if ctx.cr[6].eq {
	pc = 0x829BC514; continue 'dispatch;
	}
	// 829BC4F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BC4F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BC4FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC500: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BC504: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BC508: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BC50C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC510: 4082FFE8  bne 0x829bc4f8
	if !ctx.cr[0].eq {
	pc = 0x829BC4F8; continue 'dispatch;
	}
	// 829BC514: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC518: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BC51C: 4BB52FAD  bl 0x8250f4c8
	ctx.lr = 0x829BC520;
	sub_8250F4C8(ctx, base);
	// 829BC520: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC528: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 829BC52C: 409A0008  bne cr6, 0x829bc534
	if !ctx.cr[6].eq {
	pc = 0x829BC534; continue 'dispatch;
	}
	// 829BC530: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 829BC534: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829BC538: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BC53C: 4BB52F8D  bl 0x8250f4c8
	ctx.lr = 0x829BC540;
	sub_8250F4C8(ctx, base);
	// 829BC540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC548: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 829BC54C: 409A0008  bne cr6, 0x829bc554
	if !ctx.cr[6].eq {
	pc = 0x829BC554; continue 'dispatch;
	}
	// 829BC550: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 829BC554: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BC558: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BC55C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829BC560: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 829BC564: 4BB4F0ED  bl 0x8250b650
	ctx.lr = 0x829BC568;
	sub_8250B650(ctx, base);
	// 829BC568: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BC56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BC570: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BC574: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BC578: 4BB50F91  bl 0x8250d508
	ctx.lr = 0x829BC57C;
	sub_8250D508(ctx, base);
	// 829BC57C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BC580: 48435711  bl 0x82df1c90
	ctx.lr = 0x829BC584;
	sub_82DF1C90(ctx, base);
	// 829BC584: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829BC588: 48435709  bl 0x82df1c90
	ctx.lr = 0x829BC58C;
	sub_82DF1C90(ctx, base);
	// 829BC58C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BC590: 48435701  bl 0x82df1c90
	ctx.lr = 0x829BC594;
	sub_82DF1C90(ctx, base);
	// 829BC594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC598: 48436E91  bl 0x82df3428
	ctx.lr = 0x829BC59C;
	sub_82DF3428(ctx, base);
	// 829BC59C: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 829BC5A0: 409A0014  bne cr6, 0x829bc5b4
	if !ctx.cr[6].eq {
	pc = 0x829BC5B4; continue 'dispatch;
	}
	// 829BC5A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BC5A8: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC5AC: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BC5B0: 481D20B1  bl 0x82b8e660
	ctx.lr = 0x829BC5B4;
	sub_82B8E660(ctx, base);
	// 829BC5B4: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC5B8: 481D3039  bl 0x82b8f5f0
	ctx.lr = 0x829BC5BC;
	sub_82B8F5F0(ctx, base);
	// 829BC5BC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829BC5C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC5C4: 419A0008  beq cr6, 0x829bc5cc
	if ctx.cr[6].eq {
	pc = 0x829BC5CC; continue 'dispatch;
	}
	// 829BC5C8: 4B9042C9  bl 0x822c0890
	ctx.lr = 0x829BC5CC;
	sub_822C0890(ctx, base);
	// 829BC5CC: 897B0168  lbz r11, 0x168(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(360 as u32) ) } as u64;
	// 829BC5D0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829BC5D4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 829BC5D8: 4198003C  blt cr6, 0x829bc614
	if ctx.cr[6].lt {
	pc = 0x829BC614; continue 'dispatch;
	}
	// 829BC5DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BC5E0: 815B01A0  lwz r10, 0x1a0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(416 as u32) ) } as u64;
	// 829BC5E4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829BC5E8: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 829BC5EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC5F0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BC5F4: 992A0014  stb r9, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 829BC5F8: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BC5FC: 809D0460  lwz r4, 0x460(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1120 as u32) ) } as u64;
	// 829BC600: 80A86714  lwz r5, 0x6714(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26388 as u32) ) } as u64;
	// 829BC604: 4BB556D5  bl 0x82511cd8
	ctx.lr = 0x829BC608;
	sub_82511CD8(ctx, base);
	// 829BC608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BC60C: 809D0460  lwz r4, 0x460(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1120 as u32) ) } as u64;
	// 829BC610: 4BB556B1  bl 0x82511cc0
	ctx.lr = 0x829BC614;
	sub_82511CC0(ctx, base);
	// 829BC614: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BC618: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 829BC61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC620: 388B20E4  addi r4, r11, 0x20e4
	ctx.r[4].s64 = ctx.r[11].s64 + 8420;
	// 829BC624: 484373E5  bl 0x82df3a08
	ctx.lr = 0x829BC628;
	sub_82DF3A08(ctx, base);
	// 829BC628: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829BC62C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829BC630: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC634: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829BC638: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829BC63C: 481D2C1D  bl 0x82b8f258
	ctx.lr = 0x829BC640;
	sub_82B8F258(ctx, base);
	// 829BC640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BC644: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829BC648: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829BC64C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC650: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829BC654: 4B907E0D  bl 0x822c4460
	ctx.lr = 0x829BC658;
	sub_822C4460(ctx, base);
	// 829BC658: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829BC65C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC660: 419A0008  beq cr6, 0x829bc668
	if ctx.cr[6].eq {
	pc = 0x829BC668; continue 'dispatch;
	}
	// 829BC664: 4B90422D  bl 0x822c0890
	ctx.lr = 0x829BC668;
	sub_822C0890(ctx, base);
	// 829BC668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC66C: 48436DBD  bl 0x82df3428
	ctx.lr = 0x829BC670;
	sub_82DF3428(ctx, base);
	// 829BC670: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829BC674: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BC678: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BC67C: 3B8B3568  addi r28, r11, 0x3568
	ctx.r[28].s64 = ctx.r[11].s64 + 13672;
	// 829BC680: 419A00C8  beq cr6, 0x829bc748
	if ctx.cr[6].eq {
	pc = 0x829BC748; continue 'dispatch;
	}
	// 829BC684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BC688: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 829BC68C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829BC690: 481CF1B1  bl 0x82b8b840
	ctx.lr = 0x829BC694;
	sub_82B8B840(ctx, base);
	// 829BC694: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BC698: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829BC69C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829BC6A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC6A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BC6A8: 4B907DB9  bl 0x822c4460
	ctx.lr = 0x829BC6AC;
	sub_822C4460(ctx, base);
	// 829BC6AC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829BC6B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC6B4: 419A0008  beq cr6, 0x829bc6bc
	if ctx.cr[6].eq {
	pc = 0x829BC6BC; continue 'dispatch;
	}
	// 829BC6B8: 4B9041D9  bl 0x822c0890
	ctx.lr = 0x829BC6BC;
	sub_822C0890(ctx, base);
	// 829BC6BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BC6C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC6C4: 419A0008  beq cr6, 0x829bc6cc
	if ctx.cr[6].eq {
	pc = 0x829BC6CC; continue 'dispatch;
	}
	// 829BC6C8: 4B9041C9  bl 0x822c0890
	ctx.lr = 0x829BC6CC;
	sub_822C0890(ctx, base);
	// 829BC6CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829BC6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC6D4: 48437335  bl 0x82df3a08
	ctx.lr = 0x829BC6D8;
	sub_82DF3A08(ctx, base);
	// 829BC6D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BC6DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BC6E0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829BC6E4: 481CEFA5  bl 0x82b8b688
	ctx.lr = 0x829BC6E8;
	sub_82B8B688(ctx, base);
	// 829BC6E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BC6EC: 3BFB016C  addi r31, r27, 0x16c
	ctx.r[31].s64 = ctx.r[27].s64 + 364;
	// 829BC6F0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829BC6F4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829BC6F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC6FC: 917B016C  stw r11, 0x16c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 829BC700: 4B907D61  bl 0x822c4460
	ctx.lr = 0x829BC704;
	sub_822C4460(ctx, base);
	// 829BC704: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829BC708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC70C: 419A0008  beq cr6, 0x829bc714
	if ctx.cr[6].eq {
	pc = 0x829BC714; continue 'dispatch;
	}
	// 829BC710: 4B904181  bl 0x822c0890
	ctx.lr = 0x829BC714;
	sub_822C0890(ctx, base);
	// 829BC714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC718: 48436D11  bl 0x82df3428
	ctx.lr = 0x829BC71C;
	sub_82DF3428(ctx, base);
	// 829BC71C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC720: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BC724: 419A0024  beq cr6, 0x829bc748
	if ctx.cr[6].eq {
	pc = 0x829BC748; continue 'dispatch;
	}
	// 829BC728: 3BBD0148  addi r29, r29, 0x148
	ctx.r[29].s64 = ctx.r[29].s64 + 328;
	// 829BC72C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 829BC730: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC734: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC738: 48456899  bl 0x82e12fd0
	ctx.lr = 0x829BC73C;
	sub_82E12FD0(ctx, base);
	// 829BC73C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829BC740: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829BC744: 4082FFEC  bne 0x829bc730
	if !ctx.cr[0].eq {
	pc = 0x829BC730; continue 'dispatch;
	}
	// 829BC748: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BC74C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 829BC750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC754: 388B624C  addi r4, r11, 0x624c
	ctx.r[4].s64 = ctx.r[11].s64 + 25164;
	// 829BC758: 484372B1  bl 0x82df3a08
	ctx.lr = 0x829BC75C;
	sub_82DF3A08(ctx, base);
	// 829BC75C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829BC760: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829BC764: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC768: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829BC76C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829BC770: 481D2AE9  bl 0x82b8f258
	ctx.lr = 0x829BC774;
	sub_82B8F258(ctx, base);
	// 829BC774: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BC778: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829BC77C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829BC780: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC784: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BC788: 4B907CD9  bl 0x822c4460
	ctx.lr = 0x829BC78C;
	sub_822C4460(ctx, base);
	// 829BC78C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829BC790: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC794: 419A0008  beq cr6, 0x829bc79c
	if ctx.cr[6].eq {
	pc = 0x829BC79C; continue 'dispatch;
	}
	// 829BC798: 4B9040F9  bl 0x822c0890
	ctx.lr = 0x829BC79C;
	sub_822C0890(ctx, base);
	// 829BC79C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC7A0: 48436C89  bl 0x82df3428
	ctx.lr = 0x829BC7A4;
	sub_82DF3428(ctx, base);
	// 829BC7A4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829BC7A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BC7AC: 409A0024  bne cr6, 0x829bc7d0
	if !ctx.cr[6].eq {
	pc = 0x829BC7D0; continue 'dispatch;
	}
	// 829BC7B0: 933B0190  stw r25, 0x190(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(400 as u32), ctx.r[25].u32 ) };
	// 829BC7B4: 397B0190  addi r11, r27, 0x190
	ctx.r[11].s64 = ctx.r[27].s64 + 400;
	// 829BC7B8: 807B0194  lwz r3, 0x194(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(404 as u32) ) } as u64;
	// 829BC7BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC7C0: 933B0194  stw r25, 0x194(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(404 as u32), ctx.r[25].u32 ) };
	// 829BC7C4: 419A005C  beq cr6, 0x829bc820
	if ctx.cr[6].eq {
	pc = 0x829BC820; continue 'dispatch;
	}
	// 829BC7C8: 4B9040C9  bl 0x822c0890
	ctx.lr = 0x829BC7CC;
	sub_822C0890(ctx, base);
	// 829BC7CC: 48000054  b 0x829bc820
	pc = 0x829BC820; continue 'dispatch;
	// 829BC7D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829BC7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC7D8: 48437231  bl 0x82df3a08
	ctx.lr = 0x829BC7DC;
	sub_82DF3A08(ctx, base);
	// 829BC7DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BC7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BC7E4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829BC7E8: 481CEEA1  bl 0x82b8b688
	ctx.lr = 0x829BC7EC;
	sub_82B8B688(ctx, base);
	// 829BC7EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BC7F0: 395B0190  addi r10, r27, 0x190
	ctx.r[10].s64 = ctx.r[27].s64 + 400;
	// 829BC7F4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829BC7F8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 829BC7FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC800: 917B0190  stw r11, 0x190(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 829BC804: 4B907C5D  bl 0x822c4460
	ctx.lr = 0x829BC808;
	sub_822C4460(ctx, base);
	// 829BC808: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829BC80C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC810: 419A0008  beq cr6, 0x829bc818
	if ctx.cr[6].eq {
	pc = 0x829BC818; continue 'dispatch;
	}
	// 829BC814: 4B90407D  bl 0x822c0890
	ctx.lr = 0x829BC818;
	sub_822C0890(ctx, base);
	// 829BC818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BC81C: 48436C0D  bl 0x82df3428
	ctx.lr = 0x829BC820;
	sub_82DF3428(ctx, base);
	// 829BC820: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BC824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC828: 419A0008  beq cr6, 0x829bc830
	if ctx.cr[6].eq {
	pc = 0x829BC830; continue 'dispatch;
	}
	// 829BC82C: 4B904065  bl 0x822c0890
	ctx.lr = 0x829BC830;
	sub_822C0890(ctx, base);
	// 829BC830: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BC834: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC838: 419A0008  beq cr6, 0x829bc840
	if ctx.cr[6].eq {
	pc = 0x829BC840; continue 'dispatch;
	}
	// 829BC83C: 4B904055  bl 0x822c0890
	ctx.lr = 0x829BC840;
	sub_822C0890(ctx, base);
	// 829BC840: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 829BC844: 487EB968  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BC848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BC848 size=488
    let mut pc: u32 = 0x829BC848;
    'dispatch: loop {
        match pc {
            0x829BC848 => {
    //   block [0x829BC848..0x829BCA30)
	// 829BC848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BC84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BC850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BC854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BC858: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BC85C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BC860: 4BFFFAF9  bl 0x829bc358
	ctx.lr = 0x829BC864;
	sub_829BC358(ctx, base);
	// 829BC864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BC868: 48797D99  bl 0x83154600
	ctx.lr = 0x829BC86C;
	sub_83154600(ctx, base);
	// 829BC86C: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 829BC870: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BC874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BC878: 419A00E4  beq cr6, 0x829bc95c
	if ctx.cr[6].eq {
	pc = 0x829BC95C; continue 'dispatch;
	}
	// 829BC87C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC880: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 829BC884: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829BC888: 3BE96910  addi r31, r9, 0x6910
	ctx.r[31].s64 = ctx.r[9].s64 + 26896;
	// 829BC88C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 829BC890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BC894: 4E800421  bctrl
	ctx.lr = 0x829BC898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BC898: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BC89C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BC8A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BC8A4: 484BF425  bl 0x82e7bcc8
	ctx.lr = 0x829BC8A8;
	sub_82E7BCC8(ctx, base);
	// 829BC8A8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829BC8AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BC8B0: 4B9B8229  bl 0x82374ad8
	ctx.lr = 0x829BC8B4;
	sub_82374AD8(ctx, base);
	// 829BC8B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC8B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829BC8BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BC8C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC8C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BC8C8: 419A0024  beq cr6, 0x829bc8ec
	if ctx.cr[6].eq {
	pc = 0x829BC8EC; continue 'dispatch;
	}
	// 829BC8CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BC8D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BC8D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC8D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BC8DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BC8E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BC8E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC8E8: 4082FFE8  bne 0x829bc8d0
	if !ctx.cr[0].eq {
	pc = 0x829BC8D0; continue 'dispatch;
	}
	// 829BC8EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BC8F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BC8F4: 4BB52BD5  bl 0x8250f4c8
	ctx.lr = 0x829BC8F8;
	sub_8250F4C8(ctx, base);
	// 829BC8F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC900: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC904: 409A0008  bne cr6, 0x829bc90c
	if !ctx.cr[6].eq {
	pc = 0x829BC90C; continue 'dispatch;
	}
	// 829BC908: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829BC90C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BC910: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 829BC914: 4BB4C105  bl 0x82508a18
	ctx.lr = 0x829BC918;
	sub_82508A18(ctx, base);
	// 829BC918: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BC91C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BC920: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BC924: 388A2C00  addi r4, r10, 0x2c00
	ctx.r[4].s64 = ctx.r[10].s64 + 11264;
	// 829BC928: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 829BC92C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829BC930: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BC934: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829BC938: 4849C109  bl 0x82e58a40
	ctx.lr = 0x829BC93C;
	sub_82E58A40(ctx, base);
	// 829BC93C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BC940: 48435351  bl 0x82df1c90
	ctx.lr = 0x829BC944;
	sub_82DF1C90(ctx, base);
	// 829BC944: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BC948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BC94C: 419A0008  beq cr6, 0x829bc954
	if ctx.cr[6].eq {
	pc = 0x829BC954; continue 'dispatch;
	}
	// 829BC950: 4B903F41  bl 0x822c0890
	ctx.lr = 0x829BC954;
	sub_822C0890(ctx, base);
	// 829BC954: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829BC958: 480000B4  b 0x829bca0c
	pc = 0x829BCA0C; continue 'dispatch;
	// 829BC95C: 389F0180  addi r4, r31, 0x180
	ctx.r[4].s64 = ctx.r[31].s64 + 384;
	// 829BC960: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829BC964: 4B9B8175  bl 0x82374ad8
	ctx.lr = 0x829BC968;
	sub_82374AD8(ctx, base);
	// 829BC968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC96C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BC970: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BC974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC978: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829BC97C: 419A0024  beq cr6, 0x829bc9a0
	if ctx.cr[6].eq {
	pc = 0x829BC9A0; continue 'dispatch;
	}
	// 829BC980: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BC984: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BC988: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC98C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BC990: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BC994: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BC998: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BC99C: 4082FFE8  bne 0x829bc984
	if !ctx.cr[0].eq {
	pc = 0x829BC984; continue 'dispatch;
	}
	// 829BC9A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BC9A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BC9A8: 4BB52B21  bl 0x8250f4c8
	ctx.lr = 0x829BC9AC;
	sub_8250F4C8(ctx, base);
	// 829BC9AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BC9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BC9B4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BC9B8: 409A0008  bne cr6, 0x829bc9c0
	if !ctx.cr[6].eq {
	pc = 0x829BC9C0; continue 'dispatch;
	}
	// 829BC9BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829BC9C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BC9C4: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 829BC9C8: 4BB4C051  bl 0x82508a18
	ctx.lr = 0x829BC9CC;
	sub_82508A18(ctx, base);
	// 829BC9CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BC9D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BC9D4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BC9D8: 388A2C00  addi r4, r10, 0x2c00
	ctx.r[4].s64 = ctx.r[10].s64 + 11264;
	// 829BC9DC: 38A001C2  li r5, 0x1c2
	ctx.r[5].s64 = 450;
	// 829BC9E0: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829BC9E4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BC9E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829BC9EC: 4849C055  bl 0x82e58a40
	ctx.lr = 0x829BC9F0;
	sub_82E58A40(ctx, base);
	// 829BC9F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BC9F4: 4843529D  bl 0x82df1c90
	ctx.lr = 0x829BC9F8;
	sub_82DF1C90(ctx, base);
	// 829BC9F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BC9FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BCA00: 419A0008  beq cr6, 0x829bca08
	if ctx.cr[6].eq {
	pc = 0x829BCA08; continue 'dispatch;
	}
	// 829BCA04: 4B903E8D  bl 0x822c0890
	ctx.lr = 0x829BCA08;
	sub_822C0890(ctx, base);
	// 829BCA08: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829BCA0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BCA10: 419A0008  beq cr6, 0x829bca18
	if ctx.cr[6].eq {
	pc = 0x829BCA18; continue 'dispatch;
	}
	// 829BCA14: 4B903E7D  bl 0x822c0890
	ctx.lr = 0x829BCA18;
	sub_822C0890(ctx, base);
	// 829BCA18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829BCA1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BCA20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BCA24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BCA28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BCA2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BCA30 size=108
    let mut pc: u32 = 0x829BCA30;
    'dispatch: loop {
        match pc {
            0x829BCA30 => {
    //   block [0x829BCA30..0x829BCA9C)
	// 829BCA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BCA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BCA38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BCA3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BCA40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BCA44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BCA48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829BCA4C: 4BFE65E5  bl 0x829a3030
	ctx.lr = 0x829BCA50;
	sub_829A3030(ctx, base);
	// 829BCA50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BCA54: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 829BCA58: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829BCA5C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BCA60: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829BCA64: 39292C5C  addi r9, r9, 0x2c5c
	ctx.r[9].s64 = ctx.r[9].s64 + 11356;
	// 829BCA68: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCA6C: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 829BCA70: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829BCA74: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BCA78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCA7C: C00A9FB8  lfs f0, -0x6048(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCA80: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BCA84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BCA88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BCA8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BCA90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BCA94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BCA98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829BCAA0 size=12
    let mut pc: u32 = 0x829BCAA0;
    'dispatch: loop {
        match pc {
            0x829BCAA0 => {
    //   block [0x829BCAA0..0x829BCAAC)
	// 829BCAA0: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 829BCAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BCAA8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCAAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCAAC size=32
    let mut pc: u32 = 0x829BCAAC;
    'dispatch: loop {
        match pc {
            0x829BCAAC => {
    //   block [0x829BCAAC..0x829BCACC)
	// 829BCAAC: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCAB0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BCAB4: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCAB8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BCABC: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829BCAC0: C1AB9FD8  lfs f13, -0x6028(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24616 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCAC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829BCAC8: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCACC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCACC size=20
    let mut pc: u32 = 0x829BCACC;
    'dispatch: loop {
        match pc {
            0x829BCACC => {
    //   block [0x829BCACC..0x829BCAE0)
	// 829BCACC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829BCAD0: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BCAD4: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829BCAD8: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 829BCADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCAE0 size=68
    let mut pc: u32 = 0x829BCAE0;
    'dispatch: loop {
        match pc {
            0x829BCAE0 => {
    //   block [0x829BCAE0..0x829BCB24)
	// 829BCAE0: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BCAE4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BCAE8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829BCAEC: 396B9FE0  addi r11, r11, -0x6020
	ctx.r[11].s64 = ctx.r[11].s64 + -24608;
	// 829BCAF0: 419800CC  blt cr6, 0x829bcbbc
	if ctx.cr[6].lt {
		sub_829BCBBC(ctx, base);
		return;
	}
	// 829BCAF4: 419A0098  beq cr6, 0x829bcb8c
	if ctx.cr[6].eq {
		sub_829BCB8C(ctx, base);
		return;
	}
	// 829BCAF8: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 829BCAFC: 41980088  blt cr6, 0x829bcb84
	if ctx.cr[6].lt {
		sub_829BCB84(ctx, base);
		return;
	}
	// 829BCB00: 419A0058  beq cr6, 0x829bcb58
	if ctx.cr[6].eq {
		sub_829BCB58(ctx, base);
		return;
	}
	// 829BCB04: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 829BCB08: 4198001C  blt cr6, 0x829bcb24
	if ctx.cr[6].lt {
		sub_829BCB24(ctx, base);
		return;
	}
	// 829BCB0C: 409A00E0  bne cr6, 0x829bcbec
	if !ctx.cr[6].eq {
		sub_829BCBBC(ctx, base);
		return;
	}
	// 829BCB10: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB14: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCB18: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCB1C: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCB20: 480000A8  b 0x829bcbc8
	sub_829BCBBC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCB24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCB24 size=52
    let mut pc: u32 = 0x829BCB24;
    'dispatch: loop {
        match pc {
            0x829BCB24 => {
    //   block [0x829BCB24..0x829BCB58)
	// 829BCB24: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829BCB28: C00BFFE8  lfs f0, -0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB2C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 829BCB30: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCB34: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCB38: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 829BCB3C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 829BCB40: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB44: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCB48: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 829BCB4C: D1A1FFFC  stfs f13, -4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 829BCB50: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BCB54: 48000094  b 0x829bcbe8
	sub_829BCBBC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCB58 size=44
    let mut pc: u32 = 0x829BCB58;
    'dispatch: loop {
        match pc {
            0x829BCB58 => {
    //   block [0x829BCB58..0x829BCB84)
	// 829BCB58: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829BCB5C: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB60: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 829BCB64: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 829BCB68: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCB6C: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCB70: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 829BCB74: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB78: D181FFF8  stfs f12, -8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 829BCB7C: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 829BCB80: 4BFFFFD0  b 0x829bcb50
	sub_829BCB24(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCB84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCB84 size=8
    let mut pc: u32 = 0x829BCB84;
    'dispatch: loop {
        match pc {
            0x829BCB84 => {
    //   block [0x829BCB84..0x829BCB8C)
	// 829BCB84: C00BFFE8  lfs f0, -0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB88: 4BFFFF90  b 0x829bcb18
	sub_829BCAE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCB8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCB8C size=48
    let mut pc: u32 = 0x829BCB8C;
    'dispatch: loop {
        match pc {
            0x829BCB8C => {
    //   block [0x829BCB8C..0x829BCBBC)
	// 829BCB8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BCB90: C00BFFDC  lfs f0, -0x24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCB94: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 829BCB98: C1ABFFE0  lfs f13, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCB9C: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 829BCBA0: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCBA4: D1A1FFF0  stfs f13, -0x10(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 829BCBA8: C00BFFE4  lfs f0, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCBAC: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCBB0: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 829BCBB4: D1A1FFFC  stfs f13, -4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 829BCBB8: 4800002C  b 0x829bcbe4
	sub_829BCBBC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCBBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCBBC size=60
    let mut pc: u32 = 0x829BCBBC;
    'dispatch: loop {
        match pc {
            0x829BCBBC => {
    //   block [0x829BCBBC..0x829BCBF8)
	// 829BCBBC: C00BFFDC  lfs f0, -0x24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCBC0: C1ABFFE0  lfs f13, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCBC4: C18BFFE4  lfs f12, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCBC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BCBCC: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 829BCBD0: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 829BCBD4: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 829BCBD8: D181FFF8  stfs f12, -8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 829BCBDC: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCBE0: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 829BCBE4: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCBF8 size=68
    let mut pc: u32 = 0x829BCBF8;
    'dispatch: loop {
        match pc {
            0x829BCBF8 => {
    //   block [0x829BCBF8..0x829BCC3C)
	// 829BCBF8: 8944001C  lbz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 829BCBFC: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 829BCC00: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCC04: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BCC08: C1640018  lfs f11, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BCC0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BCC10: ED405828  fsubs f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 829BCC14: C1230004  lfs f9, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829BCC18: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCC1C: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829BCC20: C009E830  lfs f0, -0x17d0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCC24: 40820018  bne 0x829bcc3c
	if !ctx.cr[0].eq {
		sub_829BCC3C(ctx, base);
		return;
	}
	// 829BCC28: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BCC2C: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCC30: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BCC34: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 829BCC38: 48000014  b 0x829bcc4c
	sub_829BCC3C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCC3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BCC3C size=32
    let mut pc: u32 = 0x829BCC3C;
    'dispatch: loop {
        match pc {
            0x829BCC3C => {
    //   block [0x829BCC3C..0x829BCC5C)
	// 829BCC3C: ED6A02F2  fmuls f11, f10, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 829BCC40: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCC44: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BCC48: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BCC4C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BCC50: EC004B3A  fmadds f0, f0, f12, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 829BCC54: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BCC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BCC60 size=136
    let mut pc: u32 = 0x829BCC60;
    'dispatch: loop {
        match pc {
            0x829BCC60 => {
    //   block [0x829BCC60..0x829BCCE8)
	// 829BCC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BCC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BCC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BCC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BCC70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BCC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BCC78: 48797989  bl 0x83154600
	ctx.lr = 0x829BCC7C;
	sub_83154600(ctx, base);
	// 829BCC7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BCC80: 807E0378  lwz r3, 0x378(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(888 as u32) ) } as u64;
	// 829BCC84: 4BE3874D  bl 0x827f53d0
	ctx.lr = 0x829BCC88;
	sub_827F53D0(ctx, base);
	// 829BCC88: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829BCC8C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BCC90: C01F0184  lfs f0, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCC94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BCCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BCCE8 size=1668
    let mut pc: u32 = 0x829BCCE8;
    'dispatch: loop {
        match pc {
            0x829BCCE8 => {
    //   block [0x829BCCE8..0x829BD36C)
	// 829BCCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BCCEC: 487EB481  bl 0x831a816c
	ctx.lr = 0x829BCCF0;
	sub_831A8130(ctx, base);
	// 829BCCF0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829BCCF4: 487EBD85  bl 0x831a8a78
	ctx.lr = 0x829BCCF8;
	sub_831A8A40(ctx, base);
	// 829BCCF8: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BCCFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BCD00: 48797901  bl 0x83154600
	ctx.lr = 0x829BCD04;
	sub_83154600(ctx, base);
	// 829BCD04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BCD08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BCD0C: 895E03B4  lbz r10, 0x3b4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(948 as u32) ) } as u64;
	// 829BCD10: C38B08A8  lfs f28, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829BCD14: 7D4B0775  extsb. r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BCD18: 41810010  bgt 0x829bcd28
	if ctx.cr[0].gt {
	pc = 0x829BCD28; continue 'dispatch;
	}
	// 829BCD1C: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCD20: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 829BCD24: 40980638  bge cr6, 0x829bd35c
	if !ctx.cr[6].lt {
	pc = 0x829BD35C; continue 'dispatch;
	}
	// 829BCD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCD2C: 4849CA35  bl 0x82e59760
	ctx.lr = 0x829BCD30;
	sub_82E59760(ctx, base);
	// 829BCD30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BCD34: FF01E000  fcmpu cr6, f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[28].f64);
	// 829BCD38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCD3C: C3AB2C8C  lfs f29, 0x2c8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11404 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829BCD40: 4098001C  bge cr6, 0x829bcd5c
	if !ctx.cr[6].lt {
	pc = 0x829BCD5C; continue 'dispatch;
	}
	// 829BCD44: 4849CA1D  bl 0x82e59760
	ctx.lr = 0x829BCD48;
	sub_82E59760(ctx, base);
	// 829BCD48: C01F0178  lfs f0, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCD4C: C1BF0170  lfs f13, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCD50: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BCD54: EFED007A  fmadds f31, f13, f1, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BCD58: 48000028  b 0x829bcd80
	pc = 0x829BCD80; continue 'dispatch;
	// 829BCD5C: 4849CA05  bl 0x82e59760
	ctx.lr = 0x829BCD60;
	sub_82E59760(ctx, base);
	// 829BCD60: EC010772  fmuls f0, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[29].f64) as f32) as f64);
	// 829BCD64: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 829BCD68: 41980008  blt cr6, 0x829bcd70
	if ctx.cr[6].lt {
	pc = 0x829BCD70; continue 'dispatch;
	}
	// 829BCD6C: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 829BCD70: C1BF0170  lfs f13, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCD74: C19F0174  lfs f12, 0x174(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCD78: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BCD7C: EFEC683A  fmadds f31, f12, f0, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 829BCD80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BCD84: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 829BCD88: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829BCD8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BCD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCD94: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829BCD98: D3C100B4  stfs f30, 0xb4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829BCD9C: D3C100B8  stfs f30, 0xb8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829BCDA0: D3C100BC  stfs f30, 0xbc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 829BCDA4: 480015B5  bl 0x829be358
	ctx.lr = 0x829BCDA8;
	sub_829BE358(ctx, base);
	// 829BCDA8: D3E100D0  stfs f31, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 829BCDAC: D3C100D4  stfs f30, 0xd4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 829BCDB0: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 829BCDB4: D3C100D8  stfs f30, 0xd8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 829BCDB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BCDBC: D3C100DC  stfs f30, 0xdc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 829BCDC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCDC4: 48001595  bl 0x829be358
	ctx.lr = 0x829BCDC8;
	sub_829BE358(ctx, base);
	// 829BCDC8: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829BCDCC: D3C10094  stfs f30, 0x94(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829BCDD0: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829BCDD4: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829BCDD8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829BCDDC: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829BCDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCDE4: 48001575  bl 0x829be358
	ctx.lr = 0x829BCDE8;
	sub_829BE358(ctx, base);
	// 829BCDE8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 829BCDEC: 38A10200  addi r5, r1, 0x200
	ctx.r[5].s64 = ctx.r[1].s64 + 512;
	// 829BCDF0: 807E03F0  lwz r3, 0x3f0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BCDF4: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 829BCDF8: 4B913261  bl 0x822d0058
	ctx.lr = 0x829BCDFC;
	sub_822D0058(ctx, base);
	// 829BCDFC: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BCE00: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BCE04: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829BCE08: C1810078  lfs f12, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BCE0C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829BCE10: C161007C  lfs f11, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BCE14: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCE18: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCE1C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BCE20: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCE24: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BCE28: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BCE2C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BCE30: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BCE34: 396101C0  addi r11, r1, 0x1c0
	ctx.r[11].s64 = ctx.r[1].s64 + 448;
	// 829BCE38: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829BCE3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BCE40: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BCE44: 13FE50C7  vcmpequd (lvx128) v31, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BD370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BD370 size=556
    let mut pc: u32 = 0x829BD370;
    'dispatch: loop {
        match pc {
            0x829BD370 => {
    //   block [0x829BD370..0x829BD59C)
	// 829BD370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BD374: 487EADF9  bl 0x831a816c
	ctx.lr = 0x829BD378;
	sub_831A8130(ctx, base);
	// 829BD378: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829BD37C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829BD380: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BD384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BD388: 48797279  bl 0x83154600
	ctx.lr = 0x829BD38C;
	sub_83154600(ctx, base);
	// 829BD38C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BD390: 4BB52049  bl 0x8250f3d8
	ctx.lr = 0x829BD394;
	sub_8250F3D8(ctx, base);
	// 829BD394: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BD398: 418201F4  beq 0x829bd58c
	if ctx.cr[0].eq {
	pc = 0x829BD58C; continue 'dispatch;
	}
	// 829BD39C: A17D03BC  lhz r11, 0x3bc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(956 as u32) ) } as u64;
	// 829BD3A0: A15F016C  lhz r10, 0x16c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 829BD3A4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 829BD3A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829BD3AC: 419A01E0  beq cr6, 0x829bd58c
	if ctx.cr[6].eq {
	pc = 0x829BD58C; continue 'dispatch;
	}
	// 829BD3B0: B17F016C  sth r11, 0x16c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u16 ) };
	// 829BD3B4: 807D0148  lwz r3, 0x148(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(328 as u32) ) } as u64;
	// 829BD3B8: 4BE38019  bl 0x827f53d0
	ctx.lr = 0x829BD3BC;
	sub_827F53D0(ctx, base);
	// 829BD3BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BD3C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829BD3C4: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD3C8: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829BD3CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BD3D0: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829BD3D4: 995F0164  stb r10, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u8 ) };
	// 829BD3D8: D3DF0160  stfs f30, 0x160(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BD3DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BD3E0: 388B1FFC  addi r4, r11, 0x1ffc
	ctx.r[4].s64 = ctx.r[11].s64 + 8188;
	// 829BD3E4: 48436625  bl 0x82df3a08
	ctx.lr = 0x829BD3E8;
	sub_82DF3A08(ctx, base);
	// 829BD3E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BD3EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BD3F0: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BD3F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829BD3F8: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BD3FC: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BD400: 481F5F79  bl 0x82bb3378
	ctx.lr = 0x829BD404;
	sub_82BB3378(ctx, base);
	// 829BD404: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BD408: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BD40C: 419A0008  beq cr6, 0x829bd414
	if ctx.cr[6].eq {
	pc = 0x829BD414; continue 'dispatch;
	}
	// 829BD410: 4B903481  bl 0x822c0890
	ctx.lr = 0x829BD414;
	sub_822C0890(ctx, base);
	// 829BD414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BD418: 48436011  bl 0x82df3428
	ctx.lr = 0x829BD41C;
	sub_82DF3428(ctx, base);
	// 829BD41C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BD420: 4BB2D669  bl 0x824eaa88
	ctx.lr = 0x829BD424;
	sub_824EAA88(ctx, base);
	// 829BD424: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD428: 4BB2C429  bl 0x824e9850
	ctx.lr = 0x829BD42C;
	sub_824E9850(ctx, base);
	// 829BD42C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829BD430: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829BD434: C3EBACFC  lfs f31, -0x5304(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BD438: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829BD43C: 41980008  blt cr6, 0x829bd444
	if ctx.cr[6].lt {
	pc = 0x829BD444; continue 'dispatch;
	}
	// 829BD440: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829BD444: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BD448: 48434849  bl 0x82df1c90
	ctx.lr = 0x829BD44C;
	sub_82DF1C90(ctx, base);
	// 829BD44C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BD450: 41820010  beq 0x829bd460
	if ctx.cr[0].eq {
	pc = 0x829BD460; continue 'dispatch;
	}
	// 829BD454: C01F0170  lfs f0, 0x170(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD458: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BD45C: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 829BD460: C01F0170  lfs f0, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD464: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829BD468: 41980054  blt cr6, 0x829bd4bc
	if ctx.cr[6].lt {
	pc = 0x829BD4BC; continue 'dispatch;
	}
	// 829BD46C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BD470: 4BB2D619  bl 0x824eaa88
	ctx.lr = 0x829BD474;
	sub_824EAA88(ctx, base);
	// 829BD474: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BD478: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BD47C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD480: 4BB51F49  bl 0x8250f3c8
	ctx.lr = 0x829BD484;
	sub_8250F3C8(ctx, base);
	// 829BD484: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BD488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BD48C: 4BB2DB85  bl 0x824eb010
	ctx.lr = 0x829BD490;
	sub_824EB010(ctx, base);
	// 829BD490: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829BD494: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829BD498: 41980008  blt cr6, 0x829bd4a0
	if ctx.cr[6].lt {
	pc = 0x829BD4A0; continue 'dispatch;
	}
	// 829BD49C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829BD4A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BD4A4: 484347ED  bl 0x82df1c90
	ctx.lr = 0x829BD4A8;
	sub_82DF1C90(ctx, base);
	// 829BD4A8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BD4AC: 40820054  bne 0x829bd500
	if !ctx.cr[0].eq {
	pc = 0x829BD500; continue 'dispatch;
	}
	// 829BD4B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BD4B4: C00B78D8  lfs f0, 0x78d8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD4B8: 48000050  b 0x829bd508
	pc = 0x829BD508; continue 'dispatch;
	// 829BD4BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BD4C0: 4BB2D5C9  bl 0x824eaa88
	ctx.lr = 0x829BD4C4;
	sub_824EAA88(ctx, base);
	// 829BD4C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BD4C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BD4CC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD4D0: 4BB51EF9  bl 0x8250f3c8
	ctx.lr = 0x829BD4D4;
	sub_8250F3C8(ctx, base);
	// 829BD4D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BD4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BD4DC: 4BB2DB35  bl 0x824eb010
	ctx.lr = 0x829BD4E0;
	sub_824EB010(ctx, base);
	// 829BD4E0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829BD4E4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829BD4E8: 41980008  blt cr6, 0x829bd4f0
	if ctx.cr[6].lt {
	pc = 0x829BD4F0; continue 'dispatch;
	}
	// 829BD4EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829BD4F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BD4F4: 4843479D  bl 0x82df1c90
	ctx.lr = 0x829BD4F8;
	sub_82DF1C90(ctx, base);
	// 829BD4F8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BD4FC: 4082FFB4  bne 0x829bd4b0
	if !ctx.cr[0].eq {
	pc = 0x829BD4B0; continue 'dispatch;
	}
	// 829BD500: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BD504: C00B2C54  lfs f0, 0x2c54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD508: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829BD50C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 829BD510: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829BD514: 807D03F0  lwz r3, 0x3f0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BD518: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 829BD51C: 4B912B3D  bl 0x822d0058
	ctx.lr = 0x829BD520;
	sub_822D0058(ctx, base);
	// 829BD520: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 829BD524: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829BD528: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BD52C: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 829BD530: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD534: C1A10084  lfs f13, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BD538: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 829BD53C: C1810088  lfs f12, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BD540: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BD544: C161008C  lfs f11, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BD548: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BD54C: 13FD50C7  vcmpequd (lvx128) v31, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BD550: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BD5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BD5A0 size=172
    let mut pc: u32 = 0x829BD5A0;
    'dispatch: loop {
        match pc {
            0x829BD5A0 => {
    //   block [0x829BD5A0..0x829BD64C)
	// 829BD5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BD5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BD5A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BD5AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BD5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BD5B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BD5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BD5BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BD5C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BD5C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BD5C8: 4B903371  bl 0x822c0938
	ctx.lr = 0x829BD5CC;
	sub_822C0938(ctx, base);
	// 829BD5CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BD5D0: 41820028  beq 0x829bd5f8
	if ctx.cr[0].eq {
	pc = 0x829BD5F8; continue 'dispatch;
	}
	// 829BD5D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BD5D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BD5DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BD5E0: 392B2C74  addi r9, r11, 0x2c74
	ctx.r[9].s64 = ctx.r[11].s64 + 11380;
	// 829BD5E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BD5E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BD5EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BD5F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BD5F4: 48000008  b 0x829bd5fc
	pc = 0x829BD5FC; continue 'dispatch;
	// 829BD5F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BD5FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BD600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BD604: 409A002C  bne cr6, 0x829bd630
	if !ctx.cr[6].eq {
	pc = 0x829BD630; continue 'dispatch;
	}
	// 829BD608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BD60C: 4B902C5D  bl 0x822c0268
	ctx.lr = 0x829BD610;
	sub_822C0268(ctx, base);
	// 829BD610: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BD614: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BD618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BD61C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BD620: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BD624: 816BA008  lwz r11, -0x5ff8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24568 as u32) ) } as u64;
	// 829BD628: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BD62C: 4B9029D5  bl 0x822c0000
	ctx.lr = 0x829BD630;
	sub_822C0000(ctx, base);
	// 829BD630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BD634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BD638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BD63C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BD640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BD644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BD648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BD650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BD650 size=272
    let mut pc: u32 = 0x829BD650;
    'dispatch: loop {
        match pc {
            0x829BD650 => {
    //   block [0x829BD650..0x829BD760)
	// 829BD650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BD654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BD658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BD65C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BD660: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BD664: 48796F9D  bl 0x83154600
	ctx.lr = 0x829BD668;
	sub_83154600(ctx, base);
	// 829BD668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BD66C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BD670: 4BB2D419  bl 0x824eaa88
	ctx.lr = 0x829BD674;
	sub_824EAA88(ctx, base);
	// 829BD674: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BD678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BD67C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD680: 4BB51D49  bl 0x8250f3c8
	ctx.lr = 0x829BD684;
	sub_8250F3C8(ctx, base);
	// 829BD684: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BD688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BD68C: 4BB2D985  bl 0x824eb010
	ctx.lr = 0x829BD690;
	sub_824EB010(ctx, base);
	// 829BD690: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BD694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BD698: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BD69C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BD6A0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 829BD6A4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829BD6A8: 8BC1005F  lbz r30, 0x5f(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 829BD6AC: 484345E5  bl 0x82df1c90
	ctx.lr = 0x829BD6B0;
	sub_82DF1C90(ctx, base);
	// 829BD6B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 829BD6B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BD6B8: 41980060  blt cr6, 0x829bd718
	if ctx.cr[6].lt {
	pc = 0x829BD718; continue 'dispatch;
	}
	// 829BD6BC: 419A0034  beq cr6, 0x829bd6f0
	if ctx.cr[6].eq {
	pc = 0x829BD6F0; continue 'dispatch;
	}
	// 829BD6C0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BD6C4: 40980084  bge cr6, 0x829bd748
	if !ctx.cr[6].lt {
	pc = 0x829BD748; continue 'dispatch;
	}
	// 829BD6C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD6CC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BD6D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BD6D4: 38AA2CB0  addi r5, r10, 0x2cb0
	ctx.r[5].s64 = ctx.r[10].s64 + 11440;
	// 829BD6D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BD6DC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829BD6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BD6E4: 4E800421  bctrl
	ctx.lr = 0x829BD6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BD6E8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BD6EC: 48000050  b 0x829bd73c
	pc = 0x829BD73C; continue 'dispatch;
	// 829BD6F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD6F4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BD6F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BD6FC: 38AA2CA0  addi r5, r10, 0x2ca0
	ctx.r[5].s64 = ctx.r[10].s64 + 11424;
	// 829BD700: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BD704: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829BD708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BD70C: 4E800421  bctrl
	ctx.lr = 0x829BD710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BD710: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829BD714: 48000028  b 0x829bd73c
	pc = 0x829BD73C; continue 'dispatch;
	// 829BD718: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BD71C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BD720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BD724: 38AA2C90  addi r5, r10, 0x2c90
	ctx.r[5].s64 = ctx.r[10].s64 + 11408;
	// 829BD728: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BD72C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829BD730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829BD734: 4E800421  bctrl
	ctx.lr = 0x829BD738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829BD738: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829BD73C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BD740: 419A0008  beq cr6, 0x829bd748
	if ctx.cr[6].eq {
	pc = 0x829BD748; continue 'dispatch;
	}
	// 829BD744: 4B90314D  bl 0x822c0890
	ctx.lr = 0x829BD748;
	sub_822C0890(ctx, base);
	// 829BD748: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829BD74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BD750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BD754: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BD758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BD75C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BD760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829BD760 size=992
    let mut pc: u32 = 0x829BD760;
    'dispatch: loop {
        match pc {
            0x829BD760 => {
    //   block [0x829BD760..0x829BDB40)
	// 829BD760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BD764: 487EAA09  bl 0x831a816c
	ctx.lr = 0x829BD768;
	sub_831A8130(ctx, base);
	// 829BD768: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 829BD76C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829BD770: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829BD774: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BDB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BDB40 size=1524
    let mut pc: u32 = 0x829BDB40;
    'dispatch: loop {
        match pc {
            0x829BDB40 => {
    //   block [0x829BDB40..0x829BE134)
	// 829BDB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BDB44: 487EA621  bl 0x831a8164
	ctx.lr = 0x829BDB48;
	sub_831A8130(ctx, base);
	// 829BDB48: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 829BDB4C: 487EAF2D  bl 0x831a8a78
	ctx.lr = 0x829BDB50;
	sub_831A8A40(ctx, base);
	// 829BDB50: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BDB54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BDB58: 48796AA9  bl 0x83154600
	ctx.lr = 0x829BDB5C;
	sub_83154600(ctx, base);
	// 829BDB5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BDB60: C3FD0160  lfs f31, 0x160(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BDB64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BDB68: 4849BC11  bl 0x82e59778
	ctx.lr = 0x829BDB6C;
	sub_82E59778(ctx, base);
	// 829BDB6C: 897D0164  lbz r11, 0x164(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 829BDB70: C01D0160  lfs f0, 0x160(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BDB74: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829BDB78: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BDB7C: D1BD0160  stfs f13, 0x160(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BDB80: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BDB84: 41980320  blt cr6, 0x829bdea4
	if ctx.cr[6].lt {
	pc = 0x829BDEA4; continue 'dispatch;
	}
	// 829BDB88: 419A003C  beq cr6, 0x829bdbc4
	if ctx.cr[6].eq {
	pc = 0x829BDBC4; continue 'dispatch;
	}
	// 829BDB8C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BDB90: 40980594  bge cr6, 0x829be124
	if !ctx.cr[6].lt {
	pc = 0x829BE124; continue 'dispatch;
	}
	// 829BDB94: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829BDB98: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BDB9C: 40810588  ble 0x829be124
	if !ctx.cr[0].gt {
	pc = 0x829BE124; continue 'dispatch;
	}
	// 829BDBA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BDBA4: C00B2D14  lfs f0, 0x2d14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11540 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BDBA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BDBAC: 41980578  blt cr6, 0x829be124
	if ctx.cr[6].lt {
	pc = 0x829BE124; continue 'dispatch;
	}
	// 829BDBB0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829BDBB4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BDBB8: D01D0160  stfs f0, 0x160(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BDBBC: 997D0164  stb r11, 0x164(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(356 as u32), ctx.r[11].u8 ) };
	// 829BDBC0: 48000564  b 0x829be124
	pc = 0x829BE124; continue 'dispatch;
	// 829BDBC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BDBC8: C00B2D10  lfs f0, 0x2d10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BDBCC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829BDBD0: 41990218  bgt cr6, 0x829bdde8
	if ctx.cr[6].gt {
	pc = 0x829BDDE8; continue 'dispatch;
	}
	// 829BDBD4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BDBD8: 40990210  ble cr6, 0x829bdde8
	if !ctx.cr[6].gt {
	pc = 0x829BDDE8; continue 'dispatch;
	}
	// 829BDBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BDBE0: 4BB53F09  bl 0x82511ae8
	ctx.lr = 0x829BDBE4;
	sub_82511AE8(ctx, base);
	// 829BDBE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BDBE8: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE138 size=384
    let mut pc: u32 = 0x829BE138;
    'dispatch: loop {
        match pc {
            0x829BE138 => {
    //   block [0x829BE138..0x829BE2B8)
	// 829BE138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BE140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BE144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BE148: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829BE14C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE150: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BE154: 487964AD  bl 0x83154600
	ctx.lr = 0x829BE158;
	sub_83154600(ctx, base);
	// 829BE158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BE15C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BE160: 4BFFF9E1  bl 0x829bdb40
	ctx.lr = 0x829BE164;
	sub_829BDB40(ctx, base);
	// 829BE164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BE168: 4BFFEB81  bl 0x829bcce8
	ctx.lr = 0x829BE16C;
	sub_829BCCE8(ctx, base);
	// 829BE16C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BE170: 4BFFF201  bl 0x829bd370
	ctx.lr = 0x829BE174;
	sub_829BD370(ctx, base);
	// 829BE174: 897E0164  lbz r11, 0x164(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 829BE178: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829BE17C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 829BE180: 4198011C  blt cr6, 0x829be29c
	if ctx.cr[6].lt {
	pc = 0x829BE29C; continue 'dispatch;
	}
	// 829BE184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BE188: C01E0160  lfs f0, 0x160(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE18C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BE190: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829BE194: 41980108  blt cr6, 0x829be29c
	if ctx.cr[6].lt {
	pc = 0x829BE29C; continue 'dispatch;
	}
	// 829BE198: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829BE19C: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BE1A0: 408100FC  ble 0x829be29c
	if !ctx.cr[0].gt {
	pc = 0x829BE29C; continue 'dispatch;
	}
	// 829BE1A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BE1A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BE1AC: 388B2CC0  addi r4, r11, 0x2cc0
	ctx.r[4].s64 = ctx.r[11].s64 + 11456;
	// 829BE1B0: 38A0015E  li r5, 0x15e
	ctx.r[5].s64 = 350;
	// 829BE1B4: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 829BE1B8: 48434231  bl 0x82df23e8
	ctx.lr = 0x829BE1BC;
	sub_82DF23E8(ctx, base);
	// 829BE1BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829BE1C0: 41820028  beq 0x829be1e8
	if ctx.cr[0].eq {
	pc = 0x829BE1E8; continue 'dispatch;
	}
	// 829BE1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE1C8: 4849E761  bl 0x82e5c928
	ctx.lr = 0x829BE1CC;
	sub_82E5C928(ctx, base);
	// 829BE1CC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BE1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BE1D4: 394A1948  addi r10, r10, 0x1948
	ctx.r[10].s64 = ctx.r[10].s64 + 6472;
	// 829BE1D8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829BE1DC: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 829BE1E0: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 829BE1E4: 48000008  b 0x829be1ec
	pc = 0x829BE1EC; continue 'dispatch;
	// 829BE1E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829BE1EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829BE1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BE1F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BE1F8: 4BFE6851  bl 0x829a4a48
	ctx.lr = 0x829BE1FC;
	sub_829A4A48(ctx, base);
	// 829BE1FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BE200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BE204: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BE208: 4B901DF9  bl 0x822c0000
	ctx.lr = 0x829BE20C;
	sub_822C0000(ctx, base);
	// 829BE20C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BE210: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BE214: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE218: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829BE21C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BE220: 419A0024  beq cr6, 0x829be244
	if ctx.cr[6].eq {
	pc = 0x829BE244; continue 'dispatch;
	}
	// 829BE224: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BE228: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BE22C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BE230: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BE234: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BE238: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BE23C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BE240: 4082FFE8  bne 0x829be228
	if !ctx.cr[0].eq {
	pc = 0x829BE228; continue 'dispatch;
	}
	// 829BE244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BE248: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829BE24C: 487963B5  bl 0x83154600
	ctx.lr = 0x829BE250;
	sub_83154600(ctx, base);
	// 829BE250: 388300E8  addi r4, r3, 0xe8
	ctx.r[4].s64 = ctx.r[3].s64 + 232;
	// 829BE254: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BE258: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BE25C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BE260: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BE264: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829BE268: 484A0441  bl 0x82e5e6a8
	ctx.lr = 0x829BE26C;
	sub_82E5E6A8(ctx, base);
	// 829BE26C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BE270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BE274: 419A0008  beq cr6, 0x829be27c
	if ctx.cr[6].eq {
	pc = 0x829BE27C; continue 'dispatch;
	}
	// 829BE278: 4B902619  bl 0x822c0890
	ctx.lr = 0x829BE27C;
	sub_822C0890(ctx, base);
	// 829BE27C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BE280: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BE284: 419A0008  beq cr6, 0x829be28c
	if ctx.cr[6].eq {
	pc = 0x829BE28C; continue 'dispatch;
	}
	// 829BE288: 4B902609  bl 0x822c0890
	ctx.lr = 0x829BE28C;
	sub_822C0890(ctx, base);
	// 829BE28C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE290: 419A000C  beq cr6, 0x829be29c
	if ctx.cr[6].eq {
	pc = 0x829BE29C; continue 'dispatch;
	}
	// 829BE294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE298: 4B9025F9  bl 0x822c0890
	ctx.lr = 0x829BE29C;
	sub_822C0890(ctx, base);
	// 829BE29C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829BE2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BE2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BE2A8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829BE2AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BE2B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BE2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE2B8 size=156
    let mut pc: u32 = 0x829BE2B8;
    'dispatch: loop {
        match pc {
            0x829BE2B8 => {
    //   block [0x829BE2B8..0x829BE354)
	// 829BE2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE2BC: 487E9EB1  bl 0x831a816c
	ctx.lr = 0x829BE2C0;
	sub_831A8130(ctx, base);
	// 829BE2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE2C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BE2C8: 48796339  bl 0x83154600
	ctx.lr = 0x829BE2CC;
	sub_83154600(ctx, base);
	// 829BE2CC: 3BFF0124  addi r31, r31, 0x124
	ctx.r[31].s64 = ctx.r[31].s64 + 292;
	// 829BE2D0: 3BC30148  addi r30, r3, 0x148
	ctx.r[30].s64 = ctx.r[3].s64 + 328;
	// 829BE2D4: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 829BE2D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BE2DC: 4BE370F5  bl 0x827f53d0
	ctx.lr = 0x829BE2E0;
	sub_827F53D0(ctx, base);
	// 829BE2E0: 3960FF7C  li r11, -0x84
	ctx.r[11].s64 = -132;
	// 829BE2E4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BE2E8: 3940FF3C  li r10, -0xc4
	ctx.r[10].s64 = -196;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BE358 size=24
    let mut pc: u32 = 0x829BE358;
    'dispatch: loop {
        match pc {
            0x829BE358 => {
    //   block [0x829BE358..0x829BE370)
	// 829BE358: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 829BE35C: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BE360: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 829BE364: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BE370 size=52
    let mut pc: u32 = 0x829BE370;
    'dispatch: loop {
        match pc {
            0x829BE370 => {
    //   block [0x829BE370..0x829BE3A4)
	// 829BE370: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 829BE374: C0050000  lfs f0, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE378: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829BE37C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829BE380: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 829BE384: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BE388: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE38C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BE390: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE394: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BE398: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE39C: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BE3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE3A8 size=292
    let mut pc: u32 = 0x829BE3A8;
    'dispatch: loop {
        match pc {
            0x829BE3A8 => {
    //   block [0x829BE3A8..0x829BE4CC)
	// 829BE3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE3AC: 487E9DB5  bl 0x831a8160
	ctx.lr = 0x829BE3B0;
	sub_831A8130(ctx, base);
	// 829BE3B0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829BE3B4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE3B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BE3BC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829BE3C0: 48796241  bl 0x83154600
	ctx.lr = 0x829BE3C4;
	sub_83154600(ctx, base);
	// 829BE3C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829BE3C8: 3BFF00A0  addi r31, r31, 0xa0
	ctx.r[31].s64 = ctx.r[31].s64 + 160;
	// 829BE3CC: 3B9B0148  addi r28, r27, 0x148
	ctx.r[28].s64 = ctx.r[27].s64 + 328;
	// 829BE3D0: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 829BE3D4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 829BE3D8: 38BFFFC0  addi r5, r31, -0x40
	ctx.r[5].s64 = ctx.r[31].s64 + -64;
	// 829BE3DC: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BE3E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BE3E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BE3E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE3EC: 484BF255  bl 0x82e7d640
	ctx.lr = 0x829BE3F0;
	sub_82E7D640(ctx, base);
	// 829BE3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BE3F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BE3F8: 4BBCCA71  bl 0x8258ae68
	ctx.lr = 0x829BE3FC;
	sub_8258AE68(ctx, base);
	// 829BE3FC: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 829BE400: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 829BE404: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BE408: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BE40C: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BE410: 484BEEB9  bl 0x82e7d2c8
	ctx.lr = 0x829BE414;
	sub_82E7D2C8(ctx, base);
	// 829BE414: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829BE418: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829BE41C: 4BBCCA95  bl 0x8258aeb0
	ctx.lr = 0x829BE420;
	sub_8258AEB0(ctx, base);
	// 829BE420: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829BE424: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829BE428: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 829BE42C: 4082FFAC  bne 0x829be3d8
	if !ctx.cr[0].eq {
	pc = 0x829BE3D8; continue 'dispatch;
	}
	// 829BE430: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BE434: 4BE36F9D  bl 0x827f53d0
	ctx.lr = 0x829BE438;
	sub_827F53D0(ctx, base);
	// 829BE438: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 829BE43C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BE440: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829BE444: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829BE448: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE4D0 size=132
    let mut pc: u32 = 0x829BE4D0;
    'dispatch: loop {
        match pc {
            0x829BE4D0 => {
    //   block [0x829BE4D0..0x829BE554)
	// 829BE4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE4D4: 487E9C99  bl 0x831a816c
	ctx.lr = 0x829BE4D8;
	sub_831A8130(ctx, base);
	// 829BE4D8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829BE4DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE4E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BE4E4: 4879611D  bl 0x83154600
	ctx.lr = 0x829BE4E8;
	sub_83154600(ctx, base);
	// 829BE4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BE4EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BE4F0: 4BFFFDC9  bl 0x829be2b8
	ctx.lr = 0x829BE4F4;
	sub_829BE2B8(ctx, base);
	// 829BE4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE4F8: 4BFEB589  bl 0x829a9a80
	ctx.lr = 0x829BE4FC;
	sub_829A9A80(ctx, base);
	// 829BE4FC: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BE500: 83BF03F8  lwz r29, 0x3f8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 829BE504: 4B911A1D  bl 0x822cff20
	ctx.lr = 0x829BE508;
	sub_822CFF20(ctx, base);
	// 829BE508: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BE50C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829BE510: 4B911A11  bl 0x822cff20
	ctx.lr = 0x829BE514;
	sub_822CFF20(ctx, base);
	// 829BE514: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 829BE518: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BE51C: D1BF0410  stfs f13, 0x410(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829BE520: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE524: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BE528: 40980018  bge cr6, 0x829be540
	if !ctx.cr[6].lt {
	pc = 0x829BE540; continue 'dispatch;
	}
	// 829BE52C: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BE530: 4B9119E1  bl 0x822cff10
	ctx.lr = 0x829BE534;
	sub_822CFF10(ctx, base);
	// 829BE534: C01F0410  lfs f0, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE538: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BE53C: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829BE540: C01F0410  lfs f0, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE544: D01E016C  stfs f0, 0x16c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 829BE548: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829BE54C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829BE550: 487E9C6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE558 size=128
    let mut pc: u32 = 0x829BE558;
    'dispatch: loop {
        match pc {
            0x829BE558 => {
    //   block [0x829BE558..0x829BE5D8)
	// 829BE558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BE560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BE564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BE56C: 4849E3BD  bl 0x82e5c928
	ctx.lr = 0x829BE570;
	sub_82E5C928(ctx, base);
	// 829BE570: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BE574: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BE578: 392BA098  addi r9, r11, -0x5f68
	ctx.r[9].s64 = ctx.r[11].s64 + -24424;
	// 829BE57C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829BE580: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829BE584: 39082D1C  addi r8, r8, 0x2d1c
	ctx.r[8].s64 = ctx.r[8].s64 + 11548;
	// 829BE588: C18BA098  lfs f12, -0x5f68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24424 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BE58C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE590: 98FF0180  stb r7, 0x180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[7].u8 ) };
	// 829BE594: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 829BE598: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829BE59C: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829BE5A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE5A4: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829BE5A8: D01F017C  stfs f0, 0x17c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 829BE5AC: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BE5B0: C1A90030  lfs f13, 0x30(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BE5B4: D1BF0164  stfs f13, 0x164(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 829BE5B8: D19F0168  stfs f12, 0x168(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829BE5BC: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BE5C0: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BE5C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BE5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BE5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BE5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BE5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829BE5D8 size=356
    let mut pc: u32 = 0x829BE5D8;
    'dispatch: loop {
        match pc {
            0x829BE5D8 => {
    //   block [0x829BE5D8..0x829BE73C)
	// 829BE5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE5DC: 487E9B91  bl 0x831a816c
	ctx.lr = 0x829BE5E0;
	sub_831A8130(ctx, base);
	// 829BE5E0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 829BE5E4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829BE5E8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829BE5EC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE740 size=272
    let mut pc: u32 = 0x829BE740;
    'dispatch: loop {
        match pc {
            0x829BE740 => {
    //   block [0x829BE740..0x829BE850)
	// 829BE740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BE748: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BE74C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BE750: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 829BE754: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829BE758: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829BE75C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BE764: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE768: 419A00C4  beq cr6, 0x829be82c
	if ctx.cr[6].eq {
	pc = 0x829BE82C; continue 'dispatch;
	}
	// 829BE76C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BE770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE774: 388B2D4C  addi r4, r11, 0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + 11596;
	// 829BE778: 48435291  bl 0x82df3a08
	ctx.lr = 0x829BE77C;
	sub_82DF3A08(ctx, base);
	// 829BE77C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BE780: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829BE784: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 829BE788: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829BE78C: 3BCBA0A8  addi r30, r11, -0x5f58
	ctx.r[30].s64 = ctx.r[11].s64 + -24408;
	// 829BE790: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BE794: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BE798: 389EFFFC  addi r4, r30, -4
	ctx.r[4].s64 = ctx.r[30].s64 + -4;
	// 829BE79C: C3C96218  lfs f30, 0x6218(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829BE7A0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 829BE7A4: C3A80790  lfs f29, 0x790(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1936 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829BE7A8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829BE7AC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829BE7B0: 4BBE4A01  bl 0x825a31b0
	ctx.lr = 0x829BE7B4;
	sub_825A31B0(ctx, base);
	// 829BE7B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829BE7B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829BE7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE7C0: 4BBE2FB1  bl 0x825a1770
	ctx.lr = 0x829BE7C4;
	sub_825A1770(ctx, base);
	// 829BE7C4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829BE7C8: 48434C61  bl 0x82df3428
	ctx.lr = 0x829BE7CC;
	sub_82DF3428(ctx, base);
	// 829BE7CC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829BE7D0: 4B90A4E9  bl 0x822c8cb8
	ctx.lr = 0x829BE7D4;
	sub_822C8CB8(ctx, base);
	// 829BE7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE7D8: 48434C51  bl 0x82df3428
	ctx.lr = 0x829BE7DC;
	sub_82DF3428(ctx, base);
	// 829BE7DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BE7E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE7E4: 388B2D40  addi r4, r11, 0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + 11584;
	// 829BE7E8: 48435221  bl 0x82df3a08
	ctx.lr = 0x829BE7EC;
	sub_82DF3A08(ctx, base);
	// 829BE7EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BE7F0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829BE7F4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 829BE7F8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829BE7FC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829BE800: 4BBE49B1  bl 0x825a31b0
	ctx.lr = 0x829BE804;
	sub_825A31B0(ctx, base);
	// 829BE804: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829BE808: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829BE80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE810: 4BBE2F61  bl 0x825a1770
	ctx.lr = 0x829BE814;
	sub_825A1770(ctx, base);
	// 829BE814: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829BE818: 48434C11  bl 0x82df3428
	ctx.lr = 0x829BE81C;
	sub_82DF3428(ctx, base);
	// 829BE81C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829BE820: 4B90A499  bl 0x822c8cb8
	ctx.lr = 0x829BE824;
	sub_822C8CB8(ctx, base);
	// 829BE824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE828: 48434C01  bl 0x82df3428
	ctx.lr = 0x829BE82C;
	sub_82DF3428(ctx, base);
	// 829BE82C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 829BE830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BE834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BE838: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829BE83C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829BE840: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829BE844: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BE848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BE84C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BE850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BE850 size=2152
    let mut pc: u32 = 0x829BE850;
    'dispatch: loop {
        match pc {
            0x829BE850 => {
    //   block [0x829BE850..0x829BF0B8)
	// 829BE850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BE854: 487E98F5  bl 0x831a8148
	ctx.lr = 0x829BE858;
	sub_831A8130(ctx, base);
	// 829BE858: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 829BE85C: 487EA219  bl 0x831a8a74
	ctx.lr = 0x829BE860;
	sub_831A8A40(ctx, base);
	// 829BE860: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BE864: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BE868: 48795D99  bl 0x83154600
	ctx.lr = 0x829BE86C;
	sub_83154600(ctx, base);
	// 829BE86C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829BE870: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 829BE874: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829BE878: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BE87C: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 829BE880: 48433379  bl 0x82df1bf8
	ctx.lr = 0x829BE884;
	sub_82DF1BF8(ctx, base);
	// 829BE884: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 829BE888: 481889B9  bl 0x82b47240
	ctx.lr = 0x829BE88C;
	sub_82B47240(ctx, base);
	// 829BE88C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 829BE890: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829BE894: 484333FD  bl 0x82df1c90
	ctx.lr = 0x829BE898;
	sub_82DF1C90(ctx, base);
	// 829BE898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE89C: 4BAB3A5D  bl 0x824722f8
	ctx.lr = 0x829BE8A0;
	sub_824722F8(ctx, base);
	// 829BE8A0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BE8A4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BE8A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE8AC: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 829BE8B0: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 829BE8B4: 419A0024  beq cr6, 0x829be8d8
	if ctx.cr[6].eq {
	pc = 0x829BE8D8; continue 'dispatch;
	}
	// 829BE8B8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BE8BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BE8C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BE8C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BE8C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BE8CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BE8D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BE8D4: 4082FFE8  bne 0x829be8bc
	if !ctx.cr[0].eq {
	pc = 0x829BE8BC; continue 'dispatch;
	}
	// 829BE8D8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829BE8DC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829BE8E0: 4BB50BE9  bl 0x8250f4c8
	ctx.lr = 0x829BE8E4;
	sub_8250F4C8(ctx, base);
	// 829BE8E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BE8E8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829BE8EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BE8F0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BE8F4: 409A0008  bne cr6, 0x829be8fc
	if !ctx.cr[6].eq {
	pc = 0x829BE8FC; continue 'dispatch;
	}
	// 829BE8F8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BE8FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BE900: 3B970028  addi r28, r23, 0x28
	ctx.r[28].s64 = ctx.r[23].s64 + 40;
	// 829BE904: 3B410068  addi r26, r1, 0x68
	ctx.r[26].s64 = ctx.r[1].s64 + 104;
	// 829BE908: 4BB4A111  bl 0x82508a18
	ctx.lr = 0x829BE90C;
	sub_82508A18(ctx, base);
	// 829BE90C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BE910: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BE914: 3B6B2D58  addi r27, r11, 0x2d58
	ctx.r[27].s64 = ctx.r[11].s64 + 11608;
	// 829BE918: 38A001B6  li r5, 0x1b6
	ctx.r[5].s64 = 438;
	// 829BE91C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BE920: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829BE924: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829BE928: 484986C1  bl 0x82e56fe8
	ctx.lr = 0x829BE92C;
	sub_82E56FE8(ctx, base);
	// 829BE92C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829BE930: 48433361  bl 0x82df1c90
	ctx.lr = 0x829BE934;
	sub_82DF1C90(ctx, base);
	// 829BE934: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829BE938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BE93C: 419A0008  beq cr6, 0x829be944
	if ctx.cr[6].eq {
	pc = 0x829BE944; continue 'dispatch;
	}
	// 829BE940: 4B901F51  bl 0x822c0890
	ctx.lr = 0x829BE944;
	sub_822C0890(ctx, base);
	// 829BE944: 8ADD0034  lbz r22, 0x34(r29)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 829BE948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE94C: 419A000C  beq cr6, 0x829be958
	if ctx.cr[6].eq {
	pc = 0x829BE958; continue 'dispatch;
	}
	// 829BE950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BE954: 4B901F3D  bl 0x822c0890
	ctx.lr = 0x829BE958;
	sub_822C0890(ctx, base);
	// 829BE958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BE95C: 4BFCC58D  bl 0x8298aee8
	ctx.lr = 0x829BE960;
	sub_8298AEE8(ctx, base);
	// 829BE960: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BE964: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BE968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE96C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 829BE970: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 829BE974: 419A0024  beq cr6, 0x829be998
	if ctx.cr[6].eq {
	pc = 0x829BE998; continue 'dispatch;
	}
	// 829BE978: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BE97C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BE980: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BE984: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BE988: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BE98C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BE990: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BE994: 4082FFE8  bne 0x829be97c
	if !ctx.cr[0].eq {
	pc = 0x829BE97C; continue 'dispatch;
	}
	// 829BE998: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829BE99C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829BE9A0: 4BB50B29  bl 0x8250f4c8
	ctx.lr = 0x829BE9A4;
	sub_8250F4C8(ctx, base);
	// 829BE9A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BE9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BE9AC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BE9B0: 409A0008  bne cr6, 0x829be9b8
	if !ctx.cr[6].eq {
	pc = 0x829BE9B8; continue 'dispatch;
	}
	// 829BE9B4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BE9B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BE9BC: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 829BE9C0: 4BB4A059  bl 0x82508a18
	ctx.lr = 0x829BE9C4;
	sub_82508A18(ctx, base);
	// 829BE9C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BE9C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BE9CC: 38A001BD  li r5, 0x1bd
	ctx.r[5].s64 = 445;
	// 829BE9D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829BE9D4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829BE9D8: 48498611  bl 0x82e56fe8
	ctx.lr = 0x829BE9DC;
	sub_82E56FE8(ctx, base);
	// 829BE9DC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829BE9E0: 484332B1  bl 0x82df1c90
	ctx.lr = 0x829BE9E4;
	sub_82DF1C90(ctx, base);
	// 829BE9E4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829BE9E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BE9EC: 419A0008  beq cr6, 0x829be9f4
	if ctx.cr[6].eq {
	pc = 0x829BE9F4; continue 'dispatch;
	}
	// 829BE9F0: 4B901EA1  bl 0x822c0890
	ctx.lr = 0x829BE9F4;
	sub_822C0890(ctx, base);
	// 829BE9F4: 8B3D001C  lbz r25, 0x1c(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 829BE9F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BE9FC: 419A000C  beq cr6, 0x829bea08
	if ctx.cr[6].eq {
	pc = 0x829BEA08; continue 'dispatch;
	}
	// 829BEA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BEA04: 4B901E8D  bl 0x822c0890
	ctx.lr = 0x829BEA08;
	sub_822C0890(ctx, base);
	// 829BEA08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BEA0C: 4BE499F5  bl 0x82808400
	ctx.lr = 0x829BEA10;
	sub_82808400(ctx, base);
	// 829BEA10: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BEA14: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BEA18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BEA1C: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 829BEA20: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 829BEA24: 419A0024  beq cr6, 0x829bea48
	if ctx.cr[6].eq {
	pc = 0x829BEA48; continue 'dispatch;
	}
	// 829BEA28: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BEA2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BEA30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BEA34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BEA38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BEA3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BEA40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BEA44: 4082FFE8  bne 0x829bea2c
	if !ctx.cr[0].eq {
	pc = 0x829BEA2C; continue 'dispatch;
	}
	// 829BEA48: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829BEA4C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829BEA50: 4BB50A79  bl 0x8250f4c8
	ctx.lr = 0x829BEA54;
	sub_8250F4C8(ctx, base);
	// 829BEA54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BEA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BEA5C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BEA60: 409A0008  bne cr6, 0x829bea68
	if !ctx.cr[6].eq {
	pc = 0x829BEA68; continue 'dispatch;
	}
	// 829BEA64: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BEA68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BEA6C: 3B410078  addi r26, r1, 0x78
	ctx.r[26].s64 = ctx.r[1].s64 + 120;
	// 829BEA70: 4BB49FA9  bl 0x82508a18
	ctx.lr = 0x829BEA74;
	sub_82508A18(ctx, base);
	// 829BEA74: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BEA78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BEA7C: 38A001C4  li r5, 0x1c4
	ctx.r[5].s64 = 452;
	// 829BEA80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829BEA84: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829BEA88: 48498561  bl 0x82e56fe8
	ctx.lr = 0x829BEA8C;
	sub_82E56FE8(ctx, base);
	// 829BEA8C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829BEA90: 48433201  bl 0x82df1c90
	ctx.lr = 0x829BEA94;
	sub_82DF1C90(ctx, base);
	// 829BEA94: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829BEA98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BEA9C: 419A0008  beq cr6, 0x829beaa4
	if ctx.cr[6].eq {
	pc = 0x829BEAA4; continue 'dispatch;
	}
	// 829BEAA0: 4B901DF1  bl 0x822c0890
	ctx.lr = 0x829BEAA4;
	sub_822C0890(ctx, base);
	// 829BEAA4: 8B5D0018  lbz r26, 0x18(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 829BEAA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BEAAC: 419A000C  beq cr6, 0x829beab8
	if ctx.cr[6].eq {
	pc = 0x829BEAB8; continue 'dispatch;
	}
	// 829BEAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BEAB4: 4B901DDD  bl 0x822c0890
	ctx.lr = 0x829BEAB8;
	sub_822C0890(ctx, base);
	// 829BEAB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BEABC: 4BE59CBD  bl 0x82818778
	ctx.lr = 0x829BEAC0;
	sub_82818778(ctx, base);
	// 829BEAC0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BEAC4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BEAC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BEACC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 829BEAD0: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829BEAD4: 419A0024  beq cr6, 0x829beaf8
	if ctx.cr[6].eq {
	pc = 0x829BEAF8; continue 'dispatch;
	}
	// 829BEAD8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BEADC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BEAE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BEAE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BEAE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BEAEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BEAF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BEAF4: 4082FFE8  bne 0x829beadc
	if !ctx.cr[0].eq {
	pc = 0x829BEADC; continue 'dispatch;
	}
	// 829BEAF8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829BEAFC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829BEB00: 4BB509C9  bl 0x8250f4c8
	ctx.lr = 0x829BEB04;
	sub_8250F4C8(ctx, base);
	// 829BEB04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BEB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BEB0C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829BEB10: 409A0008  bne cr6, 0x829beb18
	if !ctx.cr[6].eq {
	pc = 0x829BEB18; continue 'dispatch;
	}
	// 829BEB14: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829BEB18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BEB1C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 829BEB20: 4BB49EF9  bl 0x82508a18
	ctx.lr = 0x829BEB24;
	sub_82508A18(ctx, base);
	// 829BEB24: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829BEB28: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829BEB2C: 38A001CB  li r5, 0x1cb
	ctx.r[5].s64 = 459;
	// 829BEB30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829BEB34: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 829BEB38: 484984B1  bl 0x82e56fe8
	ctx.lr = 0x829BEB3C;
	sub_82E56FE8(ctx, base);
	// 829BEB3C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829BEB40: 48433151  bl 0x82df1c90
	ctx.lr = 0x829BEB44;
	sub_82DF1C90(ctx, base);
	// 829BEB44: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BEB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BEB4C: 419A0008  beq cr6, 0x829beb54
	if ctx.cr[6].eq {
	pc = 0x829BEB54; continue 'dispatch;
	}
	// 829BEB50: 4B901D41  bl 0x822c0890
	ctx.lr = 0x829BEB54;
	sub_822C0890(ctx, base);
	// 829BEB54: 8B9D0018  lbz r28, 0x18(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 829BEB58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BEB5C: 419A000C  beq cr6, 0x829beb68
	if ctx.cr[6].eq {
	pc = 0x829BEB68; continue 'dispatch;
	}
	// 829BEB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BEB64: 4B901D2D  bl 0x822c0890
	ctx.lr = 0x829BEB68;
	sub_822C0890(ctx, base);
	// 829BEB68: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BEB6C: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEB70: 41820010  beq 0x829beb80
	if ctx.cr[0].eq {
	pc = 0x829BEB80; continue 'dispatch;
	}
	// 829BEB74: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEB78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829BEB7C: 40820008  bne 0x829beb84
	if !ctx.cr[0].eq {
	pc = 0x829BEB84; continue 'dispatch;
	}
	// 829BEB80: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829BEB84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BEB88: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829BEB8C: 4849ABED  bl 0x82e59778
	ctx.lr = 0x829BEB90;
	sub_82E59778(ctx, base);
	// 829BEB90: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BEB94: 895E0180  lbz r10, 0x180(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 829BEB98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829BEB9C: 3BABA0C8  addi r29, r11, -0x5f38
	ctx.r[29].s64 = ctx.r[11].s64 + -24376;
	// 829BEBA0: C01E0184  lfs f0, 0x184(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEBA4: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 829BEBA8: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BEBAC: D01E0184  stfs f0, 0x184(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BEBB0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BEBB4: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829BEBB8: 419800B0  blt cr6, 0x829bec68
	if ctx.cr[6].lt {
	pc = 0x829BEC68; continue 'dispatch;
	}
	// 829BEBBC: 419A009C  beq cr6, 0x829bec58
	if ctx.cr[6].eq {
	pc = 0x829BEC58; continue 'dispatch;
	}
	// 829BEBC0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BEBC4: 4198004C  blt cr6, 0x829bec10
	if ctx.cr[6].lt {
	pc = 0x829BEC10; continue 'dispatch;
	}
	// 829BEBC8: 419A0028  beq cr6, 0x829bebf0
	if ctx.cr[6].eq {
	pc = 0x829BEBF0; continue 'dispatch;
	}
	// 829BEBCC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829BEBD0: 41980018  blt cr6, 0x829bebe8
	if ctx.cr[6].lt {
	pc = 0x829BEBE8; continue 'dispatch;
	}
	// 829BEBD4: 409A00E4  bne cr6, 0x829becb8
	if !ctx.cr[6].eq {
	pc = 0x829BECB8; continue 'dispatch;
	}
	// 829BEBD8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEBDC: 408200DC  bne 0x829becb8
	if !ctx.cr[0].eq {
	pc = 0x829BECB8; continue 'dispatch;
	}
	// 829BEBE0: 9B1E0180  stb r24, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[24].u8 ) };
	// 829BEBE4: 480000D0  b 0x829becb4
	pc = 0x829BECB4; continue 'dispatch;
	// 829BEBE8: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEBEC: 4BFFFFF0  b 0x829bebdc
	pc = 0x829BEBDC; continue 'dispatch;
	// 829BEBF0: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEBF4: 4182000C  beq 0x829bec00
	if ctx.cr[0].eq {
	pc = 0x829BEC00; continue 'dispatch;
	}
	// 829BEBF8: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BEBFC: 9B1E0180  stb r24, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[24].u8 ) };
	// 829BEC00: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC04: 4182008C  beq 0x829bec90
	if ctx.cr[0].eq {
	pc = 0x829BEC90; continue 'dispatch;
	}
	// 829BEC08: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829BEC0C: 4800007C  b 0x829bec88
	pc = 0x829BEC88; continue 'dispatch;
	// 829BEC10: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC14: 408200A4  bne 0x829becb8
	if !ctx.cr[0].eq {
	pc = 0x829BECB8; continue 'dispatch;
	}
	// 829BEC18: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829BEC1C: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BEC20: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829BEC24: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829BEC28: C0170410  lfs f0, 0x410(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEC2C: D01E0178  stfs f0, 0x178(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829BEC30: 4BFE4461  bl 0x829a3090
	ctx.lr = 0x829BEC34;
	sub_829A3090(ctx, base);
	// 829BEC34: C01D000C  lfs f0, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEC38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC3C: 40820014  bne 0x829bec50
	if !ctx.cr[0].eq {
	pc = 0x829BEC50; continue 'dispatch;
	}
	// 829BEC40: C1BE0178  lfs f13, 0x178(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BEC44: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BEC48: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEC4C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 829BEC50: D01E017C  stfs f0, 0x17c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 829BEC54: 48000064  b 0x829becb8
	pc = 0x829BECB8; continue 'dispatch;
	// 829BEC58: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC5C: 40820034  bne 0x829bec90
	if !ctx.cr[0].eq {
	pc = 0x829BEC90; continue 'dispatch;
	}
	// 829BEC60: 9B1E0180  stb r24, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[24].u8 ) };
	// 829BEC64: 48000028  b 0x829bec8c
	pc = 0x829BEC8C; continue 'dispatch;
	// 829BEC68: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC6C: 41820010  beq 0x829bec7c
	if ctx.cr[0].eq {
	pc = 0x829BEC7C; continue 'dispatch;
	}
	// 829BEC70: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829BEC74: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BEC78: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829BEC7C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC80: 41820010  beq 0x829bec90
	if ctx.cr[0].eq {
	pc = 0x829BEC90; continue 'dispatch;
	}
	// 829BEC84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829BEC88: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829BEC8C: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BEC90: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEC94: 41820010  beq 0x829beca4
	if ctx.cr[0].eq {
	pc = 0x829BECA4; continue 'dispatch;
	}
	// 829BEC98: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 829BEC9C: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BECA0: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829BECA4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BECA8: 41820010  beq 0x829becb8
	if ctx.cr[0].eq {
	pc = 0x829BECB8; continue 'dispatch;
	}
	// 829BECAC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829BECB0: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829BECB4: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829BECB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BECBC: C1B50014  lfs f13, 0x14(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BECC0: C01DFFD8  lfs f0, -0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BECC4: FD80F090  fmr f12, f30
	ctx.f[12].f64 = ctx.f[30].f64;
	// 829BECC8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BECCC: C38B08A8  lfs f28, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829BECD0: 41980010  blt cr6, 0x829bece0
	if ctx.cr[6].lt {
	pc = 0x829BECE0; continue 'dispatch;
	}
	// 829BECD4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BECD8: ED7C0028  fsubs f11, f28, f0
	ctx.f[11].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BECDC: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 829BECE0: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BECE4: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 829BECE8: 41990010  bgt cr6, 0x829becf8
	if ctx.cr[6].gt {
	pc = 0x829BECF8; continue 'dispatch;
	}
	// 829BECEC: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829BECF0: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BECF4: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829BECF8: 897E0180  lbz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 829BECFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829BED00: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 829BED04: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829BED08: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BED0C: C36A9450  lfs f27, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829BED10: 419800C0  blt cr6, 0x829bedd0
	if ctx.cr[6].lt {
	pc = 0x829BEDD0; continue 'dispatch;
	}
	// 829BED14: 419A00A4  beq cr6, 0x829bedb8
	if ctx.cr[6].eq {
	pc = 0x829BEDB8; continue 'dispatch;
	}
	// 829BED18: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BED1C: 41980094  blt cr6, 0x829bedb0
	if ctx.cr[6].lt {
	pc = 0x829BEDB0; continue 'dispatch;
	}
	// 829BED20: 419A0024  beq cr6, 0x829bed44
	if ctx.cr[6].eq {
	pc = 0x829BED44; continue 'dispatch;
	}
	// 829BED24: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829BED28: 41980014  blt cr6, 0x829bed3c
	if ctx.cr[6].lt {
	pc = 0x829BED3C; continue 'dispatch;
	}
	// 829BED2C: 409A00BC  bne cr6, 0x829bede8
	if !ctx.cr[6].eq {
	pc = 0x829BEDE8; continue 'dispatch;
	}
	// 829BED30: C01DFFF4  lfs f0, -0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BED34: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BED38: 480000B0  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BED3C: C3FDFFF0  lfs f31, -0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BED40: 480000A8  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BED44: C01E0184  lfs f0, 0x184(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BED48: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BED4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829BED50: 41990088  bgt cr6, 0x829bedd8
	if ctx.cr[6].gt {
	pc = 0x829BEDD8; continue 'dispatch;
	}
	// 829BED54: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829BED58: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829BED5C: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BED60: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BED64: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 829BED68: 487EA061  bl 0x831a8dc8
	ctx.lr = 0x829BED6C;
	sub_831A8DC8(ctx, base);
	// 829BED6C: C01E0178  lfs f0, 0x178(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BED70: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BED74: C19E017C  lfs f12, 0x17c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BED78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BED7C: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BED80: EFEC037A  fmadds f31, f12, f13, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BED84: 4849A9F5  bl 0x82e59778
	ctx.lr = 0x829BED88;
	sub_82E59778(ctx, base);
	// 829BED88: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 829BED8C: 4099001C  ble cr6, 0x829beda8
	if !ctx.cr[6].gt {
	pc = 0x829BEDA8; continue 'dispatch;
	}
	// 829BED90: C0170410  lfs f0, 0x410(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BED94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BED98: EFE0F828  fsubs f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 829BED9C: 4849A9DD  bl 0x82e59778
	ctx.lr = 0x829BEDA0;
	sub_82E59778(ctx, base);
	// 829BEDA0: EFFF0824  fdivs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 829BEDA4: 48000044  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BEDA8: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 829BEDAC: 4800003C  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BEDB0: C3FDFFE8  lfs f31, -0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BEDB4: 48000034  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BEDB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BEDBC: 4849A9BD  bl 0x82e59778
	ctx.lr = 0x829BEDC0;
	sub_82E59778(ctx, base);
	// 829BEDC0: C1BE0174  lfs f13, 0x174(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BEDC4: C01DFFE4  lfs f0, -0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEDC8: EFE1683C  fnmsubs f31, f1, f0, f13
	ctx.f[31].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BEDCC: 4800001C  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BEDD0: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BEDD4: 41820010  beq 0x829bede4
	if ctx.cr[0].eq {
	pc = 0x829BEDE4; continue 'dispatch;
	}
	// 829BEDD8: C01DFFDC  lfs f0, -0x24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEDDC: EFE00332  fmuls f31, f0, f12
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829BEDE0: 48000008  b 0x829bede8
	pc = 0x829BEDE8; continue 'dispatch;
	// 829BEDE4: C3FDFFE0  lfs f31, -0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-32 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BEDE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BEDEC: 4849A98D  bl 0x82e59778
	ctx.lr = 0x829BEDF0;
	sub_82E59778(ctx, base);
	// 829BEDF0: C0170410  lfs f0, 0x410(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEDF4: EC0107FC  fnmsubs f0, f1, f31, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BEDF8: D0170410  stfs f0, 0x410(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829BEDFC: D3FE0174  stfs f31, 0x174(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829BEE00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BEE04: 4849A975  bl 0x82e59778
	ctx.lr = 0x829BEE08;
	sub_82E59778(ctx, base);
	// 829BEE08: C01E0170  lfs f0, 0x170(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEE0C: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BEE10: C01DFFF8  lfs f0, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEE14: D1BE0170  stfs f13, 0x170(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 829BEE18: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829BEE1C: FF0CE000  fcmpu cr6, f12, f28
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[28].f64);
	// 829BEE20: 40990008  ble cr6, 0x829bee28
	if !ctx.cr[6].gt {
	pc = 0x829BEE28; continue 'dispatch;
	}
	// 829BEE24: FD80E090  fmr f12, f28
	ctx.f[12].f64 = ctx.f[28].f64;
	// 829BEE28: C01E016C  lfs f0, 0x16c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEE2C: C1BDFFFC  lfs f13, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BEE30: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BEE34: ED6B033A  fmadds f11, f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BEE38: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 829BEE3C: 40980008  bge cr6, 0x829bee44
	if !ctx.cr[6].lt {
	pc = 0x829BEE44; continue 'dispatch;
	}
	// 829BEE40: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 829BEE44: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BEE48: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BEE4C: EC0A033A  fmadds f0, f10, f12, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BEE50: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BEE54: 40990008  ble cr6, 0x829bee5c
	if !ctx.cr[6].gt {
	pc = 0x829BEE5C; continue 'dispatch;
	}
	// 829BEE58: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 829BEE5C: C1B70410  lfs f13, 0x410(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BEE60: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 829BEE64: 40980008  bge cr6, 0x829bee6c
	if !ctx.cr[6].lt {
	pc = 0x829BEE6C; continue 'dispatch;
	}
	// 829BEE68: D1770410  stfs f11, 0x410(r23)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829BEE6C: C1B70410  lfs f13, 0x410(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BEE70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BEE74: 40990008  ble cr6, 0x829bee7c
	if !ctx.cr[6].gt {
	pc = 0x829BEE7C; continue 'dispatch;
	}
	// 829BEE78: D0170410  stfs f0, 0x410(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829BEE7C: 807703F8  lwz r3, 0x3f8(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1016 as u32) ) } as u64;
	// 829BEE80: 4B9110A1  bl 0x822cff20
	ctx.lr = 0x829BEE84;
	sub_822CFF20(ctx, base);
	// 829BEE84: C0170410  lfs f0, 0x410(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BEE88: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEE8C: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BEE90: 4B9110A1  bl 0x822cff30
	ctx.lr = 0x829BEE94;
	sub_822CFF30(ctx, base);
	// 829BEE94: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEE98: 4B911089  bl 0x822cff20
	ctx.lr = 0x829BEE9C;
	sub_822CFF20(ctx, base);
	// 829BEE9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BEEA0: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEEA4: C3AB9524  lfs f29, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829BEEA8: EFE1E82A  fadds f31, f1, f29
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[29].f64) as f32) as f64;
	// 829BEEAC: 4B911065  bl 0x822cff10
	ctx.lr = 0x829BEEB0;
	sub_822CFF10(ctx, base);
	// 829BEEB0: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 829BEEB4: 41980010  blt cr6, 0x829beec4
	if ctx.cr[6].lt {
	pc = 0x829BEEC4; continue 'dispatch;
	}
	// 829BEEB8: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEEBC: 4B911055  bl 0x822cff10
	ctx.lr = 0x829BEEC0;
	sub_822CFF10(ctx, base);
	// 829BEEC0: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 829BEEC4: 38E10190  addi r7, r1, 0x190
	ctx.r[7].s64 = ctx.r[1].s64 + 400;
	// 829BEEC8: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEECC: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 829BEED0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BEED4: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 829BEED8: 4B911249  bl 0x822d0120
	ctx.lr = 0x829BEEDC;
	sub_822D0120(ctx, base);
	// 829BEEDC: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEEE0: 4B911041  bl 0x822cff20
	ctx.lr = 0x829BEEE4;
	sub_822CFF20(ctx, base);
	// 829BEEE4: EFE1E828  fsubs f31, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[29].f64) as f32) as f64);
	// 829BEEE8: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 829BEEEC: 40980010  bge cr6, 0x829beefc
	if !ctx.cr[6].lt {
	pc = 0x829BEEFC; continue 'dispatch;
	}
	// 829BEEF0: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEEF4: 4B91101D  bl 0x822cff10
	ctx.lr = 0x829BEEF8;
	sub_822CFF10(ctx, base);
	// 829BEEF8: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 829BEEFC: 38E10160  addi r7, r1, 0x160
	ctx.r[7].s64 = ctx.r[1].s64 + 352;
	// 829BEF00: 807703F0  lwz r3, 0x3f0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BEF04: 38C10170  addi r6, r1, 0x170
	ctx.r[6].s64 = ctx.r[1].s64 + 368;
	// 829BEF08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BEF0C: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 829BEF10: 4B911211  bl 0x822d0120
	ctx.lr = 0x829BEF14;
	sub_822D0120(ctx, base);
	// 829BEF14: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 829BEF18: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 829BEF1C: FC20D890  fmr f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[27].f64;
	// 829BEF20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BEF24: 484BE71D  bl 0x82e7d640
	ctx.lr = 0x829BEF28;
	sub_82E7D640(ctx, base);
	// 829BEF28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BEF2C: 39410150  addi r10, r1, 0x150
	ctx.r[10].s64 = ctx.r[1].s64 + 336;
	// 829BEF30: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 829BEF34: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829BEF38: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BF0B8 size=112
    let mut pc: u32 = 0x829BF0B8;
    'dispatch: loop {
        match pc {
            0x829BF0B8 => {
    //   block [0x829BF0B8..0x829BF128)
	// 829BF0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BF0BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BF0C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BF0C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BF0C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BF0CC: 4BFE3F65  bl 0x829a3030
	ctx.lr = 0x829BF0D0;
	sub_829A3030(ctx, base);
	// 829BF0D0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829BF0D4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BF0D8: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 829BF0DC: 39292DA0  addi r9, r9, 0x2da0
	ctx.r[9].s64 = ctx.r[9].s64 + 11680;
	// 829BF0E0: C00AA0F0  lfs f0, -0x5f10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF0E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BF0E8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BF0EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829BF0F0: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829BF0F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829BF0F8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BF0FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BF100: 4200FFF8  bdnz 0x829bf0f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829BF0F8; continue 'dispatch;
	}
	// 829BF104: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BF108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BF10C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF110: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829BF114: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BF118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BF11C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BF120: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BF124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BF128 size=384
    let mut pc: u32 = 0x829BF128;
    'dispatch: loop {
        match pc {
            0x829BF128 => {
    //   block [0x829BF128..0x829BF2A8)
	// 829BF128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BF12C: 487E9035  bl 0x831a8160
	ctx.lr = 0x829BF130;
	sub_831A8130(ctx, base);
	// 829BF130: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829BF134: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BF138: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BF13C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829BF140: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 829BF144: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829BF148: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 829BF14C: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BF150: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF154: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF158: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BF15C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BF160: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829BF164: 40980008  bge cr6, 0x829bf16c
	if !ctx.cr[6].lt {
	pc = 0x829BF16C; continue 'dispatch;
	}
	// 829BF168: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BF16C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829BF170: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BF174: 4082FFDC  bne 0x829bf150
	if !ctx.cr[0].eq {
	pc = 0x829BF150; continue 'dispatch;
	}
	// 829BF178: C01D002C  lfs f0, 0x2c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF17C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF180: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF184: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829BF188: 3B6BA114  addi r27, r11, -0x5eec
	ctx.r[27].s64 = ctx.r[11].s64 + -24300;
	// 829BF18C: D01D002C  stfs f0, 0x2c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829BF190: C1BBFFFC  lfs f13, -4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF194: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829BF198: 41980104  blt cr6, 0x829bf29c
	if ctx.cr[6].lt {
	pc = 0x829BF29C; continue 'dispatch;
	}
	// 829BF19C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BF1A0: D01D002C  stfs f0, 0x2c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829BF1A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BF1A8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 829BF1AC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829BF1B0: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF1B4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829BF1B8: 40990010  ble cr6, 0x829bf1c8
	if !ctx.cr[6].gt {
	pc = 0x829BF1C8; continue 'dispatch;
	}
	// 829BF1BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829BF1C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829BF1C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829BF1C8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829BF1CC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 829BF1D0: 4082FFE0  bne 0x829bf1b0
	if !ctx.cr[0].eq {
	pc = 0x829BF1B0; continue 'dispatch;
	}
	// 829BF1D4: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829BF1D8: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 829BF1DC: 2B1F0006  cmplwi cr6, r31, 6
	ctx.cr[6].compare_u32(ctx.r[31].u32, 6 as u32, &mut ctx.xer);
	// 829BF1E0: 409800A0  bge cr6, 0x829bf280
	if !ctx.cr[6].lt {
	pc = 0x829BF280; continue 'dispatch;
	}
	// 829BF1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BF1E8: 4BB2B8A1  bl 0x824eaa88
	ctx.lr = 0x829BF1EC;
	sub_824EAA88(ctx, base);
	// 829BF1EC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BF1F0: 4BB2A661  bl 0x824e9850
	ctx.lr = 0x829BF1F4;
	sub_824E9850(ctx, base);
	// 829BF1F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BF1F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BF1FC: C00BA2EC  lfs f0, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF200: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BF204: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829BF208: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829BF20C: 8B41005F  lbz r26, 0x5f(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 829BF210: 48432A81  bl 0x82df1c90
	ctx.lr = 0x829BF214;
	sub_82DF1C90(ctx, base);
	// 829BF214: 213F0006  subfic r9, r31, 6
	ctx.xer.ca = ctx.r[31].u32 <= 6 as u32;
	ctx.r[9].s64 = (6 as i64) - ctx.r[31].s64;
	// 829BF218: 7F4A0774  extsb r10, r26
	ctx.r[10].s64 = ctx.r[26].s8 as i64;
	// 829BF21C: 0CC90000  twi 6, r9, 0
	// 829BF220: 7D0A4BD6  divw r8, r10, r9
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 829BF224: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 829BF228: 7D0849D6  mullw r8, r8, r9
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 829BF22C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829BF230: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829BF234: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 829BF238: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 829BF23C: 0CABFFFF  twi 5, r11, -1
	// 829BF240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BF244: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 829BF248: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF24C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829BF250: 41990014  bgt cr6, 0x829bf264
	if ctx.cr[6].gt {
	pc = 0x829BF264; continue 'dispatch;
	}
	// 829BF254: 7D290775  extsb. r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829BF258: 41820020  beq 0x829bf278
	if ctx.cr[0].eq {
	pc = 0x829BF278; continue 'dispatch;
	}
	// 829BF25C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 829BF260: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 829BF264: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829BF268: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 829BF26C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 829BF270: 4198FFD8  blt cr6, 0x829bf248
	if ctx.cr[6].lt {
	pc = 0x829BF248; continue 'dispatch;
	}
	// 829BF274: 48000010  b 0x829bf284
	pc = 0x829BF284; continue 'dispatch;
	// 829BF278: 7D7C0774  extsb r28, r11
	ctx.r[28].s64 = ctx.r[11].s8 as i64;
	// 829BF27C: 48000008  b 0x829bf284
	pc = 0x829BF284; continue 'dispatch;
	// 829BF280: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 829BF284: 7F8B0775  extsb. r11, r28
	ctx.r[11].s64 = ctx.r[28].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829BF288: 41800014  blt 0x829bf29c
	if ctx.cr[0].lt {
	pc = 0x829BF29C; continue 'dispatch;
	}
	// 829BF28C: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 829BF290: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF294: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829BF298: 7C0BED2E  stfsx f0, r11, r29
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 829BF29C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829BF2A0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829BF2A4: 487E8F0C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF2A8 size=64
    let mut pc: u32 = 0x829BF2A8;
    'dispatch: loop {
        match pc {
            0x829BF2A8 => {
    //   block [0x829BF2A8..0x829BF2E8)
	// 829BF2A8: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BF2AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BF2B0: 419800DC  blt cr6, 0x829bf38c
	if ctx.cr[6].lt {
		sub_829BF38C(ctx, base);
		return;
	}
	// 829BF2B4: 419A00A4  beq cr6, 0x829bf358
	if ctx.cr[6].eq {
		sub_829BF358(ctx, base);
		return;
	}
	// 829BF2B8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BF2BC: 41980084  blt cr6, 0x829bf340
	if ctx.cr[6].lt {
		sub_829BF340(ctx, base);
		return;
	}
	// 829BF2C0: 419A0068  beq cr6, 0x829bf328
	if ctx.cr[6].eq {
		sub_829BF328(ctx, base);
		return;
	}
	// 829BF2C4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829BF2C8: 41980044  blt cr6, 0x829bf30c
	if ctx.cr[6].lt {
		sub_829BF30C(ctx, base);
		return;
	}
	// 829BF2CC: 419A001C  beq cr6, 0x829bf2e8
	if ctx.cr[6].eq {
		sub_829BF2E8(ctx, base);
		return;
	}
	// 829BF2D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BF2D4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF2D8: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BF2DC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BF2E0: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BF2E4: 480000D0  b 0x829bf3b4
	sub_829BF38C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF2E8 size=36
    let mut pc: u32 = 0x829BF2E8;
    'dispatch: loop {
        match pc {
            0x829BF2E8 => {
    //   block [0x829BF2E8..0x829BF30C)
	// 829BF2E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF2EC: 392BA104  addi r9, r11, -0x5efc
	ctx.r[9].s64 = ctx.r[11].s64 + -24316;
	// 829BF2F0: C00BA104  lfs f0, -0x5efc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF2F4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BF2F8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF2FC: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF300: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BF304: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BF308: 48000070  b 0x829bf378
	sub_829BF358(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF30C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF30C size=28
    let mut pc: u32 = 0x829BF30C;
    'dispatch: loop {
        match pc {
            0x829BF30C => {
    //   block [0x829BF30C..0x829BF328)
	// 829BF30C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF310: 396BA104  addi r11, r11, -0x5efc
	ctx.r[11].s64 = ctx.r[11].s64 + -24316;
	// 829BF314: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF318: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BF31C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF320: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF324: 4800004C  b 0x829bf370
	sub_829BF358(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF328 size=24
    let mut pc: u32 = 0x829BF328;
    'dispatch: loop {
        match pc {
            0x829BF328 => {
    //   block [0x829BF328..0x829BF340)
	// 829BF328: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF32C: 392BA104  addi r9, r11, -0x5efc
	ctx.r[9].s64 = ctx.r[11].s64 + -24316;
	// 829BF330: C00BA104  lfs f0, -0x5efc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF334: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF338: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BF33C: 48000064  b 0x829bf3a0
	sub_829BF38C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF340 size=24
    let mut pc: u32 = 0x829BF340;
    'dispatch: loop {
        match pc {
            0x829BF340 => {
    //   block [0x829BF340..0x829BF358)
	// 829BF340: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF344: 396BA104  addi r11, r11, -0x5efc
	ctx.r[11].s64 = ctx.r[11].s64 + -24316;
	// 829BF348: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF34C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF350: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BF354: 4800004C  b 0x829bf3a0
	sub_829BF38C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF358 size=52
    let mut pc: u32 = 0x829BF358;
    'dispatch: loop {
        match pc {
            0x829BF358 => {
    //   block [0x829BF358..0x829BF38C)
	// 829BF358: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF35C: 396BA104  addi r11, r11, -0x5efc
	ctx.r[11].s64 = ctx.r[11].s64 + -24316;
	// 829BF360: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF364: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BF368: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF36C: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF370: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BF374: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BF378: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BF37C: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BF380: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BF384: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BF388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF38C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BF38C size=48
    let mut pc: u32 = 0x829BF38C;
    'dispatch: loop {
        match pc {
            0x829BF38C => {
    //   block [0x829BF38C..0x829BF3BC)
	// 829BF38C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF390: 396BA104  addi r11, r11, -0x5efc
	ctx.r[11].s64 = ctx.r[11].s64 + -24316;
	// 829BF394: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF398: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF39C: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BF3A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BF3A4: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BF3A8: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BF3AC: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BF3B0: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BF3B4: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BF3B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BF3C0 size=284
    let mut pc: u32 = 0x829BF3C0;
    'dispatch: loop {
        match pc {
            0x829BF3C0 => {
    //   block [0x829BF3C0..0x829BF4DC)
	// 829BF3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BF3C4: 487E8DA9  bl 0x831a816c
	ctx.lr = 0x829BF3C8;
	sub_831A8130(ctx, base);
	// 829BF3C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BF3CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BF3D0: 48795231  bl 0x83154600
	ctx.lr = 0x829BF3D4;
	sub_83154600(ctx, base);
	// 829BF3D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BF3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BF3DC: 4BFFF475  bl 0x829be850
	ctx.lr = 0x829BF3E0;
	sub_829BE850(ctx, base);
	// 829BF3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BF3E4: 4849A37D  bl 0x82e59760
	ctx.lr = 0x829BF3E8;
	sub_82E59760(ctx, base);
	// 829BF3E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF3EC: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829BF3F0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829BF3F4: 3BABA11C  addi r29, r11, -0x5ee4
	ctx.r[29].s64 = ctx.r[11].s64 + -24292;
	// 829BF3F8: C1ABA11C  lfs f13, -0x5ee4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF3FC: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF400: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829BF404: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF408: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BF40C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BF410: 487E99B9  bl 0x831a8dc8
	ctx.lr = 0x829BF414;
	sub_831A8DC8(ctx, base);
	// 829BF414: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BF418: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BF41C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829BF420: C1BDFFFC  lfs f13, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BF424: 3BDE0420  addi r30, r30, 0x420
	ctx.r[30].s64 = ctx.r[30].s64 + 1056;
	// 829BF428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BF42C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BF430: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF434: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BF438: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BF43C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BF440: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BF444: EC0D0332  fmuls f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 829BF448: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BF44C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BF4E0 size=172
    let mut pc: u32 = 0x829BF4E0;
    'dispatch: loop {
        match pc {
            0x829BF4E0 => {
    //   block [0x829BF4E0..0x829BF58C)
	// 829BF4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BF4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BF4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BF4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BF4F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BF4F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BF4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BF4FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BF500: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BF504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BF508: 4B901431  bl 0x822c0938
	ctx.lr = 0x829BF50C;
	sub_822C0938(ctx, base);
	// 829BF50C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BF510: 41820028  beq 0x829bf538
	if ctx.cr[0].eq {
	pc = 0x829BF538; continue 'dispatch;
	}
	// 829BF514: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BF518: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BF51C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BF520: 392B2DB8  addi r9, r11, 0x2db8
	ctx.r[9].s64 = ctx.r[11].s64 + 11704;
	// 829BF524: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BF528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BF52C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BF530: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BF534: 48000008  b 0x829bf53c
	pc = 0x829BF53C; continue 'dispatch;
	// 829BF538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BF53C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BF540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BF544: 409A002C  bne cr6, 0x829bf570
	if !ctx.cr[6].eq {
	pc = 0x829BF570; continue 'dispatch;
	}
	// 829BF548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BF54C: 4B900D1D  bl 0x822c0268
	ctx.lr = 0x829BF550;
	sub_822C0268(ctx, base);
	// 829BF550: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BF554: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BF558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BF55C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BF560: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BF564: 816BA138  lwz r11, -0x5ec8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24264 as u32) ) } as u64;
	// 829BF568: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BF56C: 4B900A95  bl 0x822c0000
	ctx.lr = 0x829BF570;
	sub_822C0000(ctx, base);
	// 829BF570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BF574: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BF578: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BF57C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BF580: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BF584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BF588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BF590 size=300
    let mut pc: u32 = 0x829BF590;
    'dispatch: loop {
        match pc {
            0x829BF590 => {
    //   block [0x829BF590..0x829BF6BC)
	// 829BF590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BF594: 487E8BD9  bl 0x831a816c
	ctx.lr = 0x829BF598;
	sub_831A8130(ctx, base);
	// 829BF598: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BF59C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BF5A0: 48795061  bl 0x83154600
	ctx.lr = 0x829BF5A4;
	sub_83154600(ctx, base);
	// 829BF5A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BF5A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BF5AC: 4BFFEF25  bl 0x829be4d0
	ctx.lr = 0x829BF5B0;
	sub_829BE4D0(ctx, base);
	// 829BF5B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BF5B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BF5B8: 388B2DC8  addi r4, r11, 0x2dc8
	ctx.r[4].s64 = ctx.r[11].s64 + 11720;
	// 829BF5BC: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 829BF5C0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 829BF5C4: 4B900E15  bl 0x822c03d8
	ctx.lr = 0x829BF5C8;
	sub_822C03D8(ctx, base);
	// 829BF5C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BF5CC: 41820010  beq 0x829bf5dc
	if ctx.cr[0].eq {
	pc = 0x829BF5DC; continue 'dispatch;
	}
	// 829BF5D0: 4BFFFAE9  bl 0x829bf0b8
	ctx.lr = 0x829BF5D4;
	sub_829BF0B8(ctx, base);
	// 829BF5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BF5D8: 48000008  b 0x829bf5e0
	pc = 0x829BF5E0; continue 'dispatch;
	// 829BF5DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829BF5E0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829BF5E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BF5E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BF5EC: 4BFFFEF5  bl 0x829bf4e0
	ctx.lr = 0x829BF5F0;
	sub_829BF4E0(ctx, base);
	// 829BF5F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BF5F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BF5F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BF5FC: 4B900A05  bl 0x822c0000
	ctx.lr = 0x829BF600;
	sub_822C0000(ctx, base);
	// 829BF600: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BF604: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BF608: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BF60C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829BF610: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BF614: 419A0024  beq cr6, 0x829bf638
	if ctx.cr[6].eq {
	pc = 0x829BF638; continue 'dispatch;
	}
	// 829BF618: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BF61C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BF620: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BF624: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BF628: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BF62C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BF630: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BF634: 4082FFE8  bne 0x829bf61c
	if !ctx.cr[0].eq {
	pc = 0x829BF61C; continue 'dispatch;
	}
	// 829BF638: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BF63C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BF640: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BF644: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BF648: 4BFE5A19  bl 0x829a5060
	ctx.lr = 0x829BF64C;
	sub_829A5060(ctx, base);
	// 829BF64C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BF650: 419A000C  beq cr6, 0x829bf65c
	if ctx.cr[6].eq {
	pc = 0x829BF65C; continue 'dispatch;
	}
	// 829BF654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BF658: 4B901239  bl 0x822c0890
	ctx.lr = 0x829BF65C;
	sub_822C0890(ctx, base);
	// 829BF65C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829BF660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BF664: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829BF668: 484343A1  bl 0x82df3a08
	ctx.lr = 0x829BF66C;
	sub_82DF3A08(ctx, base);
	// 829BF66C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BF670: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BF674: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BF678: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BF67C: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BF680: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BF684: 481F3CF5  bl 0x82bb3378
	ctx.lr = 0x829BF688;
	sub_82BB3378(ctx, base);
	// 829BF688: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BF68C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BF690: 419A0008  beq cr6, 0x829bf698
	if ctx.cr[6].eq {
	pc = 0x829BF698; continue 'dispatch;
	}
	// 829BF694: 4B9011FD  bl 0x822c0890
	ctx.lr = 0x829BF698;
	sub_822C0890(ctx, base);
	// 829BF698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BF69C: 48433D8D  bl 0x82df3428
	ctx.lr = 0x829BF6A0;
	sub_82DF3428(ctx, base);
	// 829BF6A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BF6A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829BF6A8: 995E0194  stb r10, 0x194(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(404 as u32), ctx.r[10].u8 ) };
	// 829BF6AC: C00B2960  lfs f0, 0x2960(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BF6B0: D01E0190  stfs f0, 0x190(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829BF6B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829BF6B8: 487E8B04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BF6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829BF6C0 size=952
    let mut pc: u32 = 0x829BF6C0;
    'dispatch: loop {
        match pc {
            0x829BF6C0 => {
    //   block [0x829BF6C0..0x829BFA78)
	// 829BF6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BF6C4: 487E8A85  bl 0x831a8148
	ctx.lr = 0x829BF6C8;
	sub_831A8130(ctx, base);
	// 829BF6C8: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 829BF6CC: 487E9399  bl 0x831a8a64
	ctx.lr = 0x829BF6D0;
	sub_831A8A40(ctx, base);
	// 829BF6D0: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BFA78 size=60
    let mut pc: u32 = 0x829BFA78;
    'dispatch: loop {
        match pc {
            0x829BFA78 => {
    //   block [0x829BFA78..0x829BFAB4)
	// 829BFA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFA7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFA80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFA84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFA88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BFA8C: 4BFFF935  bl 0x829bf3c0
	ctx.lr = 0x829BFA90;
	sub_829BF3C0(ctx, base);
	// 829BFA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFA94: 4B90056D  bl 0x822c0000
	ctx.lr = 0x829BFA98;
	sub_822C0000(ctx, base);
	// 829BFA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFA9C: 4BFFFC25  bl 0x829bf6c0
	ctx.lr = 0x829BFAA0;
	sub_829BF6C0(ctx, base);
	// 829BFAA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BFAA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BFAA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BFAAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BFAB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BFAB8 size=84
    let mut pc: u32 = 0x829BFAB8;
    'dispatch: loop {
        match pc {
            0x829BFAB8 => {
    //   block [0x829BFAB8..0x829BFB0C)
	// 829BFAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFAC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFAC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BFACC: 4BFE3565  bl 0x829a3030
	ctx.lr = 0x829BFAD0;
	sub_829A3030(ctx, base);
	// 829BFAD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BFAD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BFAD8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BFADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFAE0: 39292E1C  addi r9, r9, 0x2e1c
	ctx.r[9].s64 = ctx.r[9].s64 + 11804;
	// 829BFAE4: C00BFF14  lfs f0, -0xec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFAE8: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFAEC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BFAF0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BFAF4: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829BFAF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BFAFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BFB00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BFB04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BFB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BFB10 size=116
    let mut pc: u32 = 0x829BFB10;
    'dispatch: loop {
        match pc {
            0x829BFB10 => {
    //   block [0x829BFB10..0x829BFB84)
	// 829BFB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFB18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFB1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFB20: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BFB24: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFB28: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829BFB2C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829BFB30: 3BEBA1EC  addi r31, r11, -0x5e14
	ctx.r[31].s64 = ctx.r[11].s64 + -24084;
	// 829BFB34: C00BA1EC  lfs f0, -0x5e14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFB38: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829BFB3C: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFB40: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFB44: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BFB48: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BFB4C: 487E935D  bl 0x831a8ea8
	ctx.lr = 0x829BFB50;
	sub_831A8EA8(ctx, base);
	// 829BFB50: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BFB54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BFB58: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFB5C: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFB60: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BFB64: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFB68: EDAC6B7C  fnmsubs f13, f12, f13, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BFB6C: EC2D02FA  fmadds f1, f13, f11, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BFB70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BFB74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BFB78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BFB7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BFB80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BFB88 size=256
    let mut pc: u32 = 0x829BFB88;
    'dispatch: loop {
        match pc {
            0x829BFB88 => {
    //   block [0x829BFB88..0x829BFC88)
	// 829BFB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFB90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFB94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFB98: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829BFB9C: C1A40014  lfs f13, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFBA0: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829BFBA4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829BFBA8: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BFBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BFBB0: C00AA1E8  lfs f0, -0x5e18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFBB4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829BFBB8: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829BFBBC: C1A9DFAC  lfs f13, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFBC0: C0089524  lfs f0, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFBC4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BFBC8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BFBCC: 4198007C  blt cr6, 0x829bfc48
	if ctx.cr[6].lt {
	pc = 0x829BFC48; continue 'dispatch;
	}
	// 829BFBD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BFBD4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829BFBD8: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BFBDC: 419A003C  beq cr6, 0x829bfc18
	if ctx.cr[6].eq {
	pc = 0x829BFC18; continue 'dispatch;
	}
	// 829BFBE0: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 829BFBE4: 41980024  blt cr6, 0x829bfc08
	if ctx.cr[6].lt {
	pc = 0x829BFC08; continue 'dispatch;
	}
	// 829BFBE8: 419A0018  beq cr6, 0x829bfc00
	if ctx.cr[6].eq {
	pc = 0x829BFC00; continue 'dispatch;
	}
	// 829BFBEC: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 829BFBF0: 4098002C  bge cr6, 0x829bfc1c
	if !ctx.cr[6].lt {
	pc = 0x829BFC1C; continue 'dispatch;
	}
	// 829BFBF4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829BFBF8: C16B7BC4  lfs f11, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BFBFC: 48000014  b 0x829bfc10
	pc = 0x829BFC10; continue 'dispatch;
	// 829BFC00: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BFC04: 48000018  b 0x829bfc1c
	pc = 0x829BFC1C; continue 'dispatch;
	// 829BFC08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BFC0C: C16B9450  lfs f11, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BFC10: EC0D02FA  fmadds f0, f13, f11, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BFC14: 48000008  b 0x829bfc1c
	pc = 0x829BFC1C; continue 'dispatch;
	// 829BFC18: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BFC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BFC20: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BFC24: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BFC28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829BFC2C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BFC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFC34: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BFC38: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFC3C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BFC40: 484BD001  bl 0x82e7cc40
	ctx.lr = 0x829BFC44;
	sub_82E7CC40(ctx, base);
	// 829BFC44: 4800002C  b 0x829bfc70
	pc = 0x829BFC70; continue 'dispatch;
	// 829BFC48: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829BFC4C: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829BFC50: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFC54: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BFC58: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFC5C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BFC60: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFC64: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BFC68: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFC6C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BFC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFC74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BFC78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BFC7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BFC80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BFC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BFC88 size=428
    let mut pc: u32 = 0x829BFC88;
    'dispatch: loop {
        match pc {
            0x829BFC88 => {
    //   block [0x829BFC88..0x829BFE34)
	// 829BFC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFC8C: 487E84E1  bl 0x831a816c
	ctx.lr = 0x829BFC90;
	sub_831A8130(ctx, base);
	// 829BFC90: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829BFC94: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829BFC98: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFC9C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BFCA0: C1840014  lfs f12, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BFCA4: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829BFCA8: 3BEBA1D4  addi r31, r11, -0x5e2c
	ctx.r[31].s64 = ctx.r[11].s64 + -24108;
	// 829BFCAC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829BFCB0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BFCB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BFCB8: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFCBC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BFCC0: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFCC4: ED8C6824  fdivs f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 829BFCC8: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFCCC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BFCD0: EFEC0372  fmuls f31, f12, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BFCD4: 41980128  blt cr6, 0x829bfdfc
	if ctx.cr[6].lt {
	pc = 0x829BFDFC; continue 'dispatch;
	}
	// 829BFCD8: 419A00F8  beq cr6, 0x829bfdd0
	if ctx.cr[6].eq {
	pc = 0x829BFDD0; continue 'dispatch;
	}
	// 829BFCDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BFCE0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829BFCE4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BFCE8: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829BFCEC: C1899450  lfs f12, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BFCF0: 41980034  blt cr6, 0x829bfd24
	if ctx.cr[6].lt {
	pc = 0x829BFD24; continue 'dispatch;
	}
	// 829BFCF4: 419A0028  beq cr6, 0x829bfd1c
	if ctx.cr[6].eq {
	pc = 0x829BFD1C; continue 'dispatch;
	}
	// 829BFCF8: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829BFCFC: 41980018  blt cr6, 0x829bfd14
	if ctx.cr[6].lt {
	pc = 0x829BFD14; continue 'dispatch;
	}
	// 829BFD00: 409A0028  bne cr6, 0x829bfd28
	if !ctx.cr[6].eq {
	pc = 0x829BFD28; continue 'dispatch;
	}
	// 829BFD04: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829BFD08: C1AB7BC4  lfs f13, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFD0C: EFE0FB7A  fmadds f31, f0, f13, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64);
	// 829BFD10: 48000018  b 0x829bfd28
	pc = 0x829BFD28; continue 'dispatch;
	// 829BFD14: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 829BFD18: 48000010  b 0x829bfd28
	pc = 0x829BFD28; continue 'dispatch;
	// 829BFD1C: EFE0FB3A  fmadds f31, f0, f12, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64);
	// 829BFD20: 48000008  b 0x829bfd28
	pc = 0x829BFD28; continue 'dispatch;
	// 829BFD24: EFE0FFBA  fmadds f31, f0, f30, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 829BFD28: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BFD2C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829BFD30: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BFD34: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829BFD38: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 829BFD3C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829BFD40: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829BFD44: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829BFD48: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829BFD4C: 4BFFFDC5  bl 0x829bfb10
	ctx.lr = 0x829BFD50;
	sub_829BFB10(ctx, base);
	// 829BFD50: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829BFD54: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BFD58: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829BFD5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BFD60: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 829BFD64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829BFD68: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 829BFD6C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BFE38 size=60
    let mut pc: u32 = 0x829BFE38;
    'dispatch: loop {
        match pc {
            0x829BFE38 => {
    //   block [0x829BFE38..0x829BFE74)
	// 829BFE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFE3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFE40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFE44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFE48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BFE4C: 48001FCD  bl 0x829c1e18
	ctx.lr = 0x829BFE50;
	sub_829C1E18(ctx, base);
	// 829BFE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFE54: 4B9001AD  bl 0x822c0000
	ctx.lr = 0x829BFE58;
	sub_822C0000(ctx, base);
	// 829BFE58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFE5C: 487947A5  bl 0x83154600
	ctx.lr = 0x829BFE60;
	sub_83154600(ctx, base);
	// 829BFE60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BFE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BFE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BFE6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BFE70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BFE78 size=172
    let mut pc: u32 = 0x829BFE78;
    'dispatch: loop {
        match pc {
            0x829BFE78 => {
    //   block [0x829BFE78..0x829BFF24)
	// 829BFE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFE80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BFE84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFE88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFE8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BFE90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BFE94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BFE98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BFE9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BFEA0: 4B900A99  bl 0x822c0938
	ctx.lr = 0x829BFEA4;
	sub_822C0938(ctx, base);
	// 829BFEA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BFEA8: 41820028  beq 0x829bfed0
	if ctx.cr[0].eq {
	pc = 0x829BFED0; continue 'dispatch;
	}
	// 829BFEAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BFEB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BFEB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BFEB8: 392B2E34  addi r9, r11, 0x2e34
	ctx.r[9].s64 = ctx.r[11].s64 + 11828;
	// 829BFEBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BFEC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BFEC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BFEC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BFECC: 48000008  b 0x829bfed4
	pc = 0x829BFED4; continue 'dispatch;
	// 829BFED0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BFED4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BFED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BFEDC: 409A002C  bne cr6, 0x829bff08
	if !ctx.cr[6].eq {
	pc = 0x829BFF08; continue 'dispatch;
	}
	// 829BFEE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFEE4: 4B900385  bl 0x822c0268
	ctx.lr = 0x829BFEE8;
	sub_822C0268(ctx, base);
	// 829BFEE8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BFEEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BFEF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BFEF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BFEF8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BFEFC: 816BA200  lwz r11, -0x5e00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24064 as u32) ) } as u64;
	// 829BFF00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BFF04: 4B9000FD  bl 0x822c0000
	ctx.lr = 0x829BFF08;
	sub_822C0000(ctx, base);
	// 829BFF08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BFF0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BFF10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BFF14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BFF18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BFF1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BFF20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BFF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BFF28 size=304
    let mut pc: u32 = 0x829BFF28;
    'dispatch: loop {
        match pc {
            0x829BFF28 => {
    //   block [0x829BFF28..0x829C0058)
	// 829BFF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BFF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BFF30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BFF34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BFF38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BFF3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BFF40: 487946C1  bl 0x83154600
	ctx.lr = 0x829BFF44;
	sub_83154600(ctx, base);
	// 829BFF44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BFF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFF4C: 4BFFE585  bl 0x829be4d0
	ctx.lr = 0x829BFF50;
	sub_829BE4D0(ctx, base);
	// 829BFF50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BFF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BFF58: 388B2E48  addi r4, r11, 0x2e48
	ctx.r[4].s64 = ctx.r[11].s64 + 11848;
	// 829BFF5C: 38A00285  li r5, 0x285
	ctx.r[5].s64 = 645;
	// 829BFF60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829BFF64: 4B900475  bl 0x822c03d8
	ctx.lr = 0x829BFF68;
	sub_822C03D8(ctx, base);
	// 829BFF68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BFF6C: 41820010  beq 0x829bff7c
	if ctx.cr[0].eq {
	pc = 0x829BFF7C; continue 'dispatch;
	}
	// 829BFF70: 4BFFFB49  bl 0x829bfab8
	ctx.lr = 0x829BFF74;
	sub_829BFAB8(ctx, base);
	// 829BFF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BFF78: 48000008  b 0x829bff80
	pc = 0x829BFF80; continue 'dispatch;
	// 829BFF7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829BFF80: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829BFF84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BFF88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BFF8C: 4BFFFEED  bl 0x829bfe78
	ctx.lr = 0x829BFF90;
	sub_829BFE78(ctx, base);
	// 829BFF90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BFF94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BFF98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BFF9C: 4B900065  bl 0x822c0000
	ctx.lr = 0x829BFFA0;
	sub_822C0000(ctx, base);
	// 829BFFA0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BFFA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BFFA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BFFAC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829BFFB0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BFFB4: 419A0024  beq cr6, 0x829bffd8
	if ctx.cr[6].eq {
	pc = 0x829BFFD8; continue 'dispatch;
	}
	// 829BFFB8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BFFBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BFFC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BFFC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BFFC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BFFCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BFFD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BFFD4: 4082FFE8  bne 0x829bffbc
	if !ctx.cr[0].eq {
	pc = 0x829BFFBC; continue 'dispatch;
	}
	// 829BFFD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BFFDC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BFFE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BFFE4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BFFE8: 4BFE5079  bl 0x829a5060
	ctx.lr = 0x829BFFEC;
	sub_829A5060(ctx, base);
	// 829BFFEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BFFF0: 419A000C  beq cr6, 0x829bfffc
	if ctx.cr[6].eq {
	pc = 0x829BFFFC; continue 'dispatch;
	}
	// 829BFFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BFFF8: 4B900899  bl 0x822c0890
	ctx.lr = 0x829BFFFC;
	sub_822C0890(ctx, base);
	// 829BFFFC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C0000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C0004: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C0008: 48433A01  bl 0x82df3a08
	ctx.lr = 0x829C000C;
	sub_82DF3A08(ctx, base);
	// 829C000C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0010: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C0014: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C0018: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C001C: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C0020: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C0024: 481F3355  bl 0x82bb3378
	ctx.lr = 0x829C0028;
	sub_82BB3378(ctx, base);
	// 829C0028: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829C002C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C0030: 419A0008  beq cr6, 0x829c0038
	if ctx.cr[6].eq {
	pc = 0x829C0038; continue 'dispatch;
	}
	// 829C0034: 4B90085D  bl 0x822c0890
	ctx.lr = 0x829C0038;
	sub_822C0890(ctx, base);
	// 829C0038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C003C: 484333ED  bl 0x82df3428
	ctx.lr = 0x829C0040;
	sub_82DF3428(ctx, base);
	// 829C0040: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C0044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C0048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C004C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C0050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C0054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0058 size=108
    let mut pc: u32 = 0x829C0058;
    'dispatch: loop {
        match pc {
            0x829C0058 => {
    //   block [0x829C0058..0x829C00C4)
	// 829C0058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C005C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C0060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C0064: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C006C: 4BFE2FC5  bl 0x829a3030
	ctx.lr = 0x829C0070;
	sub_829A3030(ctx, base);
	// 829C0070: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0074: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C0078: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829C007C: 390AA2A4  addi r8, r10, -0x5d5c
	ctx.r[8].s64 = ctx.r[10].s64 + -23900;
	// 829C0080: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829C0084: C00BFF14  lfs f0, -0xec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C008C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C0090: 39672E98  addi r11, r7, 0x2e98
	ctx.r[11].s64 = ctx.r[7].s64 + 11928;
	// 829C0094: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0098: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829C009C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C00A0: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C00A4: C00AA2A4  lfs f0, -0x5d5c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C00A8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829C00AC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829C00B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C00B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C00B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C00BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C00C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C00C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C00C8 size=88
    let mut pc: u32 = 0x829C00C8;
    'dispatch: loop {
        match pc {
            0x829C00C8 => {
    //   block [0x829C00C8..0x829C0120)
	// 829C00C8: 3D20832E  lis r9, -0x7cd2
	ctx.r[9].s64 = -2094137344;
	// 829C00CC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C00D0: 38E9A2A4  addi r7, r9, -0x5d5c
	ctx.r[7].s64 = ctx.r[9].s64 + -23900;
	// 829C00D4: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 829C00D8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 829C00DC: C009A2A4  lfs f0, -0x5d5c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-23900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C00E0: C1889524  lfs f12, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C00E4: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C00E8: EDAD033A  fmadds f13, f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C00EC: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C00F0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C00F4: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C00F8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 829C00FC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C0100: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829C0104: 4198000C  blt cr6, 0x829c0110
	if ctx.cr[6].lt {
	pc = 0x829C0110; continue 'dispatch;
	}
	// 829C0108: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C010C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C0110: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829C0114: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829C0118: 4082FFD8  bne 0x829c00f0
	if !ctx.cr[0].eq {
	pc = 0x829C00F0; continue 'dispatch;
	}
	// 829C011C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C0120 size=40
    let mut pc: u32 = 0x829C0120;
    'dispatch: loop {
        match pc {
            0x829C0120 => {
    //   block [0x829C0120..0x829C0148)
	// 829C0120: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 829C0124: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C0128: 41980028  blt cr6, 0x829c0150
	if ctx.cr[6].lt {
		sub_829C0150(ctx, base);
		return;
	}
	// 829C012C: 419A001C  beq cr6, 0x829c0148
	if ctx.cr[6].eq {
		sub_829C0148(ctx, base);
		return;
	}
	// 829C0130: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 829C0134: 4198001C  blt cr6, 0x829c0150
	if ctx.cr[6].lt {
		sub_829C0150(ctx, base);
		return;
	}
	// 829C0138: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 829C013C: 4198000C  blt cr6, 0x829c0148
	if ctx.cr[6].lt {
		sub_829C0148(ctx, base);
		return;
	}
	// 829C0140: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829C0144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C0148 size=8
    let mut pc: u32 = 0x829C0148;
    'dispatch: loop {
        match pc {
            0x829C0148 => {
    //   block [0x829C0148..0x829C0150)
	// 829C0148: C1630018  lfs f11, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C014C: 48000008  b 0x829c0154
	sub_829C0150(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C0150 size=56
    let mut pc: u32 = 0x829C0150;
    'dispatch: loop {
        match pc {
            0x829C0150 => {
    //   block [0x829C0150..0x829C0188)
	// 829C0150: C1630014  lfs f11, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C0154: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0158: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C015C: 392BA2A4  addi r9, r11, -0x5d5c
	ctx.r[9].s64 = ctx.r[11].s64 + -23900;
	// 829C0160: C18BA2A4  lfs f12, -0x5d5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23900 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C0164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C0168: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C016C: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0170: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 829C0174: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 829C0178: 40990008  ble cr6, 0x829c0180
	if !ctx.cr[6].gt {
	pc = 0x829C0180; continue 'dispatch;
	}
	// 829C017C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C0180: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C0184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0188 size=164
    let mut pc: u32 = 0x829C0188;
    'dispatch: loop {
        match pc {
            0x829C0188 => {
    //   block [0x829C0188..0x829C022C)
	// 829C0188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C018C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C0190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C0194: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0198: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C019C: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C01A0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C01A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C01A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C01AC: C18A08A4  lfs f12, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C01B0: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C01B4: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 829C01B8: 41980028  blt cr6, 0x829c01e0
	if ctx.cr[6].lt {
	pc = 0x829C01E0; continue 'dispatch;
	}
	// 829C01BC: 419A0014  beq cr6, 0x829c01d0
	if ctx.cr[6].eq {
	pc = 0x829C01D0; continue 'dispatch;
	}
	// 829C01C0: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 829C01C4: 4198001C  blt cr6, 0x829c01e0
	if ctx.cr[6].lt {
	pc = 0x829C01E0; continue 'dispatch;
	}
	// 829C01C8: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 829C01CC: 40980020  bge cr6, 0x829c01ec
	if !ctx.cr[6].lt {
	pc = 0x829C01EC; continue 'dispatch;
	}
	// 829C01D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C01D4: C1ABD5B8  lfs f13, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C01D8: EDA0037A  fmadds f13, f0, f13, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C01DC: 48000010  b 0x829c01ec
	pc = 0x829C01EC; continue 'dispatch;
	// 829C01E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C01E4: C1ABD5B8  lfs f13, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C01E8: EDA0037C  fnmsubs f13, f0, f13, f0
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C01EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C01F0: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829C01F4: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C01F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C01FC: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C0200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0204: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C0208: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C020C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C0210: 484BCA31  bl 0x82e7cc40
	ctx.lr = 0x829C0214;
	sub_82E7CC40(ctx, base);
	// 829C0214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0218: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C021C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C0220: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C0224: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C0228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0230 size=700
    let mut pc: u32 = 0x829C0230;
    'dispatch: loop {
        match pc {
            0x829C0230 => {
    //   block [0x829C0230..0x829C04EC)
	// 829C0230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C0234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C0238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C023C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C0240: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 829C0244: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829C0248: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C024C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0250: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0254: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C0258: 390BBC40  addi r8, r11, -0x43c0
	ctx.r[8].s64 = ctx.r[11].s64 + -17344;
	// 829C025C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829C0260: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C0264: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C0268: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C026C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C0270: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C0274: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C0278: C3E708A4  lfs f31, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C027C: 3BEAA28C  addi r31, r10, -0x5d74
	ctx.r[31].s64 = ctx.r[10].s64 + -23924;
	// 829C0280: 419801CC  blt cr6, 0x829c044c
	if ctx.cr[6].lt {
	pc = 0x829C044C; continue 'dispatch;
	}
	// 829C0284: 419A01B8  beq cr6, 0x829c043c
	if ctx.cr[6].eq {
	pc = 0x829C043C; continue 'dispatch;
	}
	// 829C0288: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C028C: 41980120  blt cr6, 0x829c03ac
	if ctx.cr[6].lt {
	pc = 0x829C03AC; continue 'dispatch;
	}
	// 829C0290: 419A010C  beq cr6, 0x829c039c
	if ctx.cr[6].eq {
	pc = 0x829C039C; continue 'dispatch;
	}
	// 829C0294: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C0298: 4198008C  blt cr6, 0x829c0324
	if ctx.cr[6].lt {
	pc = 0x829C0324; continue 'dispatch;
	}
	// 829C029C: 409A01F8  bne cr6, 0x829c0494
	if !ctx.cr[6].eq {
	pc = 0x829C0494; continue 'dispatch;
	}
	// 829C02A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C02A4: C1ABD5B8  lfs f13, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C02A8: EFC0037A  fmadds f30, f0, f13, f0
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C02AC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C02B0: 487E8BF9  bl 0x831a8ea8
	ctx.lr = 0x829C02B4;
	sub_831A8EA8(ctx, base);
	// 829C02B4: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C02B8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C02BC: 487E8B0D  bl 0x831a8dc8
	ctx.lr = 0x829C02C0;
	sub_831A8DC8(ctx, base);
	// 829C02C0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C02C4: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C02C8: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C02CC: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C02D0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C02D4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C02D8: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C02DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C02E0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C02E4: 487E8AE5  bl 0x831a8dc8
	ctx.lr = 0x829C02E8;
	sub_831A8DC8(ctx, base);
	// 829C02E8: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C02EC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C02F0: 487E8BB9  bl 0x831a8ea8
	ctx.lr = 0x829C02F4;
	sub_831A8EA8(ctx, base);
	// 829C02F4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C02F8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C02FC: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0300: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829C0304: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829C0308: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C030C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C0310: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0314: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C0318: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C031C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C0320: 4800010C  b 0x829c042c
	pc = 0x829C042C; continue 'dispatch;
	// 829C0324: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0328: C1ABD5B8  lfs f13, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C032C: EFC0037A  fmadds f30, f0, f13, f0
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C0330: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C0334: 487E8B75  bl 0x831a8ea8
	ctx.lr = 0x829C0338;
	sub_831A8EA8(ctx, base);
	// 829C0338: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C033C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C0340: 487E8A89  bl 0x831a8dc8
	ctx.lr = 0x829C0344;
	sub_831A8DC8(ctx, base);
	// 829C0344: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C0348: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C034C: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0350: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C0354: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C0358: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C035C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C0360: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0364: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C0368: 487E8A61  bl 0x831a8dc8
	ctx.lr = 0x829C036C;
	sub_831A8DC8(ctx, base);
	// 829C036C: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C0370: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C0374: 487E8B35  bl 0x831a8ea8
	ctx.lr = 0x829C0378;
	sub_831A8EA8(ctx, base);
	// 829C0378: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C037C: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0380: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0384: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829C0388: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C038C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0390: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C0394: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C0398: 48000088  b 0x829c0420
	pc = 0x829C0420; continue 'dispatch;
	// 829C039C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C03A0: C1ABD5B8  lfs f13, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C03A4: EFC0037C  fnmsubs f30, f0, f13, f0
	ctx.f[30].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C03A8: 4BFFFF88  b 0x829c0330
	pc = 0x829C0330; continue 'dispatch;
	// 829C03AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C03B0: C1ABD5B8  lfs f13, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C03B4: EFC0037C  fnmsubs f30, f0, f13, f0
	ctx.f[30].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C03B8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C03BC: 487E8AED  bl 0x831a8ea8
	ctx.lr = 0x829C03C0;
	sub_831A8EA8(ctx, base);
	// 829C03C0: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C03C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C03C8: 487E8A01  bl 0x831a8dc8
	ctx.lr = 0x829C03CC;
	sub_831A8DC8(ctx, base);
	// 829C03CC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C03D0: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C03D4: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C03D8: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C03DC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C03E0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C03E4: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C03E8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C03EC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C03F0: 487E89D9  bl 0x831a8dc8
	ctx.lr = 0x829C03F4;
	sub_831A8DC8(ctx, base);
	// 829C03F4: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C03F8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829C03FC: 487E8AAD  bl 0x831a8ea8
	ctx.lr = 0x829C0400;
	sub_831A8EA8(ctx, base);
	// 829C0400: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0404: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C0408: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C040C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829C0410: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0414: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C0418: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C041C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C0420: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 829C0424: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C0428: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C042C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C0430: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C04F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C04F0 size=172
    let mut pc: u32 = 0x829C04F0;
    'dispatch: loop {
        match pc {
            0x829C04F0 => {
    //   block [0x829C04F0..0x829C059C)
	// 829C04F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C04F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C04F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C04FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C0500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0504: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C0508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C050C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C0510: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C0514: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C0518: 4B900421  bl 0x822c0938
	ctx.lr = 0x829C051C;
	sub_822C0938(ctx, base);
	// 829C051C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C0520: 41820028  beq 0x829c0548
	if ctx.cr[0].eq {
	pc = 0x829C0548; continue 'dispatch;
	}
	// 829C0524: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0528: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C052C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C0530: 392B2EB0  addi r9, r11, 0x2eb0
	ctx.r[9].s64 = ctx.r[11].s64 + 11952;
	// 829C0534: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C0538: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C053C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C0540: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C0544: 48000008  b 0x829c054c
	pc = 0x829C054C; continue 'dispatch;
	// 829C0548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C054C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C0550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C0554: 409A002C  bne cr6, 0x829c0580
	if !ctx.cr[6].eq {
	pc = 0x829C0580; continue 'dispatch;
	}
	// 829C0558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C055C: 4B8FFD0D  bl 0x822c0268
	ctx.lr = 0x829C0560;
	sub_822C0268(ctx, base);
	// 829C0560: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0564: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C0568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C056C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C0570: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C0574: 816BA2AC  lwz r11, -0x5d54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23892 as u32) ) } as u64;
	// 829C0578: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C057C: 4B8FFA85  bl 0x822c0000
	ctx.lr = 0x829C0580;
	sub_822C0000(ctx, base);
	// 829C0580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C0584: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C0588: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C058C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C0590: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C0594: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C0598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C05A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C05A0 size=304
    let mut pc: u32 = 0x829C05A0;
    'dispatch: loop {
        match pc {
            0x829C05A0 => {
    //   block [0x829C05A0..0x829C06D0)
	// 829C05A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C05A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C05A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C05AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C05B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C05B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C05B8: 48794049  bl 0x83154600
	ctx.lr = 0x829C05BC;
	sub_83154600(ctx, base);
	// 829C05BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C05C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C05C4: 4BFFDF0D  bl 0x829be4d0
	ctx.lr = 0x829C05C8;
	sub_829BE4D0(ctx, base);
	// 829C05C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C05CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C05D0: 388B2EC0  addi r4, r11, 0x2ec0
	ctx.r[4].s64 = ctx.r[11].s64 + 11968;
	// 829C05D4: 38A00175  li r5, 0x175
	ctx.r[5].s64 = 373;
	// 829C05D8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829C05DC: 4B8FFDFD  bl 0x822c03d8
	ctx.lr = 0x829C05E0;
	sub_822C03D8(ctx, base);
	// 829C05E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C05E4: 41820010  beq 0x829c05f4
	if ctx.cr[0].eq {
	pc = 0x829C05F4; continue 'dispatch;
	}
	// 829C05E8: 4BFFFA71  bl 0x829c0058
	ctx.lr = 0x829C05EC;
	sub_829C0058(ctx, base);
	// 829C05EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C05F0: 48000008  b 0x829c05f8
	pc = 0x829C05F8; continue 'dispatch;
	// 829C05F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829C05F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C05FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C0600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C0604: 4BFFFEED  bl 0x829c04f0
	ctx.lr = 0x829C0608;
	sub_829C04F0(ctx, base);
	// 829C0608: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C060C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C0610: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C0614: 4B8FF9ED  bl 0x822c0000
	ctx.lr = 0x829C0618;
	sub_822C0000(ctx, base);
	// 829C0618: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C061C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C0620: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C0624: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C0628: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C062C: 419A0024  beq cr6, 0x829c0650
	if ctx.cr[6].eq {
	pc = 0x829C0650; continue 'dispatch;
	}
	// 829C0630: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C0634: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C0638: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C063C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C0640: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C0644: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C0648: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C064C: 4082FFE8  bne 0x829c0634
	if !ctx.cr[0].eq {
	pc = 0x829C0634; continue 'dispatch;
	}
	// 829C0650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C0654: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C0658: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C065C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C0660: 4BFE4A01  bl 0x829a5060
	ctx.lr = 0x829C0664;
	sub_829A5060(ctx, base);
	// 829C0664: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C0668: 419A000C  beq cr6, 0x829c0674
	if ctx.cr[6].eq {
	pc = 0x829C0674; continue 'dispatch;
	}
	// 829C066C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0670: 4B900221  bl 0x822c0890
	ctx.lr = 0x829C0674;
	sub_822C0890(ctx, base);
	// 829C0674: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C0678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C067C: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C0680: 48433389  bl 0x82df3a08
	ctx.lr = 0x829C0684;
	sub_82DF3A08(ctx, base);
	// 829C0684: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0688: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C068C: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C0690: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C0694: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C0698: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C069C: 481F2CDD  bl 0x82bb3378
	ctx.lr = 0x829C06A0;
	sub_82BB3378(ctx, base);
	// 829C06A0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829C06A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C06A8: 419A0008  beq cr6, 0x829c06b0
	if ctx.cr[6].eq {
	pc = 0x829C06B0; continue 'dispatch;
	}
	// 829C06AC: 4B9001E5  bl 0x822c0890
	ctx.lr = 0x829C06B0;
	sub_822C0890(ctx, base);
	// 829C06B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C06B4: 48432D75  bl 0x82df3428
	ctx.lr = 0x829C06B8;
	sub_82DF3428(ctx, base);
	// 829C06B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C06BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C06C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C06C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C06C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C06CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C06D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C06D0 size=72
    let mut pc: u32 = 0x829C06D0;
    'dispatch: loop {
        match pc {
            0x829C06D0 => {
    //   block [0x829C06D0..0x829C0718)
	// 829C06D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C06D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C06D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C06DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C06E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C06E4: 4BFE294D  bl 0x829a3030
	ctx.lr = 0x829C06E8;
	sub_829A3030(ctx, base);
	// 829C06E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C06EC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C06F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C06F4: 394A2F18  addi r10, r10, 0x2f18
	ctx.r[10].s64 = ctx.r[10].s64 + 12056;
	// 829C06F8: C00BA340  lfs f0, -0x5cc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23744 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C06FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829C0700: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C0704: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C0708: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C070C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C0710: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C0714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C0718 size=64
    let mut pc: u32 = 0x829C0718;
    'dispatch: loop {
        match pc {
            0x829C0718 => {
    //   block [0x829C0718..0x829C0758)
	// 829C0718: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C071C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C0720: 419800DC  blt cr6, 0x829c07fc
	if ctx.cr[6].lt {
		sub_829C07FC(ctx, base);
		return;
	}
	// 829C0724: 419A00A4  beq cr6, 0x829c07c8
	if ctx.cr[6].eq {
		sub_829C07C8(ctx, base);
		return;
	}
	// 829C0728: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C072C: 41980084  blt cr6, 0x829c07b0
	if ctx.cr[6].lt {
		sub_829C07B0(ctx, base);
		return;
	}
	// 829C0730: 419A0068  beq cr6, 0x829c0798
	if ctx.cr[6].eq {
		sub_829C0798(ctx, base);
		return;
	}
	// 829C0734: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C0738: 41980044  blt cr6, 0x829c077c
	if ctx.cr[6].lt {
		sub_829C077C(ctx, base);
		return;
	}
	// 829C073C: 419A001C  beq cr6, 0x829c0758
	if ctx.cr[6].eq {
		sub_829C0758(ctx, base);
		return;
	}
	// 829C0740: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C0744: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0748: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C074C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C0750: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C0754: 480000D0  b 0x829c0824
	sub_829C07FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C0758 size=36
    let mut pc: u32 = 0x829C0758;
    'dispatch: loop {
        match pc {
            0x829C0758 => {
    //   block [0x829C0758..0x829C077C)
	// 829C0758: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C075C: 392BA354  addi r9, r11, -0x5cac
	ctx.r[9].s64 = ctx.r[11].s64 + -23724;
	// 829C0760: C00BA354  lfs f0, -0x5cac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0764: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C0768: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C076C: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C0770: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C0774: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C0778: 48000070  b 0x829c07e8
	sub_829C07C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C077C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C077C size=28
    let mut pc: u32 = 0x829C077C;
    'dispatch: loop {
        match pc {
            0x829C077C => {
    //   block [0x829C077C..0x829C0798)
	// 829C077C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0780: 396BA354  addi r11, r11, -0x5cac
	ctx.r[11].s64 = ctx.r[11].s64 + -23724;
	// 829C0784: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0788: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C078C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C0790: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0794: 4800004C  b 0x829c07e0
	sub_829C07C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C0798 size=24
    let mut pc: u32 = 0x829C0798;
    'dispatch: loop {
        match pc {
            0x829C0798 => {
    //   block [0x829C0798..0x829C07B0)
	// 829C0798: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C079C: 392BA354  addi r9, r11, -0x5cac
	ctx.r[9].s64 = ctx.r[11].s64 + -23724;
	// 829C07A0: C00BA354  lfs f0, -0x5cac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C07A4: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C07A8: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C07AC: 48000064  b 0x829c0810
	sub_829C07FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C07B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C07B0 size=24
    let mut pc: u32 = 0x829C07B0;
    'dispatch: loop {
        match pc {
            0x829C07B0 => {
    //   block [0x829C07B0..0x829C07C8)
	// 829C07B0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C07B4: 396BA354  addi r11, r11, -0x5cac
	ctx.r[11].s64 = ctx.r[11].s64 + -23724;
	// 829C07B8: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C07BC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C07C0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C07C4: 4800004C  b 0x829c0810
	sub_829C07FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C07C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C07C8 size=52
    let mut pc: u32 = 0x829C07C8;
    'dispatch: loop {
        match pc {
            0x829C07C8 => {
    //   block [0x829C07C8..0x829C07FC)
	// 829C07C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C07CC: 396BA354  addi r11, r11, -0x5cac
	ctx.r[11].s64 = ctx.r[11].s64 + -23724;
	// 829C07D0: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C07D4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C07D8: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C07DC: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C07E0: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C07E4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C07E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C07EC: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C07F0: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C07F4: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C07F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C07FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C07FC size=48
    let mut pc: u32 = 0x829C07FC;
    'dispatch: loop {
        match pc {
            0x829C07FC => {
    //   block [0x829C07FC..0x829C082C)
	// 829C07FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0800: 396BA354  addi r11, r11, -0x5cac
	ctx.r[11].s64 = ctx.r[11].s64 + -23724;
	// 829C0804: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0808: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C080C: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C0810: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C0814: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C0818: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C081C: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C0820: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C0824: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C0828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0830 size=308
    let mut pc: u32 = 0x829C0830;
    'dispatch: loop {
        match pc {
            0x829C0830 => {
    //   block [0x829C0830..0x829C0964)
	// 829C0830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C0834: 487E7939  bl 0x831a816c
	ctx.lr = 0x829C0838;
	sub_831A8130(ctx, base);
	// 829C0838: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829C083C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C0844: 48793DBD  bl 0x83154600
	ctx.lr = 0x829C0848;
	sub_83154600(ctx, base);
	// 829C0848: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C084C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0850: 4BFFE001  bl 0x829be850
	ctx.lr = 0x829C0854;
	sub_829BE850(ctx, base);
	// 829C0854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0858: 48498F09  bl 0x82e59760
	ctx.lr = 0x829C085C;
	sub_82E59760(ctx, base);
	// 829C085C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0860: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829C0864: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C0868: 3BABA36C  addi r29, r11, -0x5c94
	ctx.r[29].s64 = ctx.r[11].s64 + -23700;
	// 829C086C: C1ABA36C  lfs f13, -0x5c94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23700 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C0870: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0874: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C0878: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C087C: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C0880: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C0884: 487E8545  bl 0x831a8dc8
	ctx.lr = 0x829C0888;
	sub_831A8DC8(ctx, base);
	// 829C0888: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C088C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C0890: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829C0894: C01DFFFC  lfs f0, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0898: 3BDE0420  addi r30, r30, 0x420
	ctx.r[30].s64 = ctx.r[30].s64 + 1056;
	// 829C089C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C08A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C08A4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C08A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C08AC: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C08B0: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C08B4: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C08B8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C08BC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C08C0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0968 size=132
    let mut pc: u32 = 0x829C0968;
    'dispatch: loop {
        match pc {
            0x829C0968 => {
    //   block [0x829C0968..0x829C09EC)
	// 829C0968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C096C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C0970: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C0974: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0978: 48793C89  bl 0x83154600
	ctx.lr = 0x829C097C;
	sub_83154600(ctx, base);
	// 829C097C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C0984: 388B2038  addi r4, r11, 0x2038
	ctx.r[4].s64 = ctx.r[11].s64 + 8248;
	// 829C0988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C098C: 4843307D  bl 0x82df3a08
	ctx.lr = 0x829C0990;
	sub_82DF3A08(ctx, base);
	// 829C0990: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0994: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C0998: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C099C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C09A0: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C09A4: 481F2315  bl 0x82bb2cb8
	ctx.lr = 0x829C09A8;
	sub_82BB2CB8(ctx, base);
	// 829C09A8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C09AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C09B0: 419A0008  beq cr6, 0x829c09b8
	if ctx.cr[6].eq {
	pc = 0x829C09B8; continue 'dispatch;
	}
	// 829C09B4: 4B8FFEDD  bl 0x822c0890
	ctx.lr = 0x829C09B8;
	sub_822C0890(ctx, base);
	// 829C09B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C09BC: 48432A6D  bl 0x82df3428
	ctx.lr = 0x829C09C0;
	sub_82DF3428(ctx, base);
	// 829C09C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C09C4: 807F02E4  lwz r3, 0x2e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 829C09C8: 484C0D79  bl 0x82e81740
	ctx.lr = 0x829C09CC;
	sub_82E81740(ctx, base);
	// 829C09CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C09D0: 807F02EC  lwz r3, 0x2ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 829C09D4: 484C0D6D  bl 0x82e81740
	ctx.lr = 0x829C09D8;
	sub_82E81740(ctx, base);
	// 829C09D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C09DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C09E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C09E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C09E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C09F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C09F0 size=172
    let mut pc: u32 = 0x829C09F0;
    'dispatch: loop {
        match pc {
            0x829C09F0 => {
    //   block [0x829C09F0..0x829C0A9C)
	// 829C09F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C09F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C09F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C09FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C0A00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0A04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C0A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C0A0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C0A10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C0A14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C0A18: 4B8FFF21  bl 0x822c0938
	ctx.lr = 0x829C0A1C;
	sub_822C0938(ctx, base);
	// 829C0A1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C0A20: 41820028  beq 0x829c0a48
	if ctx.cr[0].eq {
	pc = 0x829C0A48; continue 'dispatch;
	}
	// 829C0A24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0A28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C0A2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C0A30: 392B2F30  addi r9, r11, 0x2f30
	ctx.r[9].s64 = ctx.r[11].s64 + 12080;
	// 829C0A34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C0A38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C0A3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C0A40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C0A44: 48000008  b 0x829c0a4c
	pc = 0x829C0A4C; continue 'dispatch;
	// 829C0A48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C0A4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C0A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C0A54: 409A002C  bne cr6, 0x829c0a80
	if !ctx.cr[6].eq {
	pc = 0x829C0A80; continue 'dispatch;
	}
	// 829C0A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0A5C: 4B8FF80D  bl 0x822c0268
	ctx.lr = 0x829C0A60;
	sub_822C0268(ctx, base);
	// 829C0A60: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C0A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C0A6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C0A70: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C0A74: 816BA380  lwz r11, -0x5c80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23680 as u32) ) } as u64;
	// 829C0A78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C0A7C: 4B8FF585  bl 0x822c0000
	ctx.lr = 0x829C0A80;
	sub_822C0000(ctx, base);
	// 829C0A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C0A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C0A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C0A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C0A90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C0A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C0A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0AA0 size=352
    let mut pc: u32 = 0x829C0AA0;
    'dispatch: loop {
        match pc {
            0x829C0AA0 => {
    //   block [0x829C0AA0..0x829C0C00)
	// 829C0AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C0AA4: 487E76C9  bl 0x831a816c
	ctx.lr = 0x829C0AA8;
	sub_831A8130(ctx, base);
	// 829C0AA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0AAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C0AB0: 48793B51  bl 0x83154600
	ctx.lr = 0x829C0AB4;
	sub_83154600(ctx, base);
	// 829C0AB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C0AB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C0ABC: 4BFFDA15  bl 0x829be4d0
	ctx.lr = 0x829C0AC0;
	sub_829BE4D0(ctx, base);
	// 829C0AC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0AC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C0AC8: 388B2F60  addi r4, r11, 0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + 12128;
	// 829C0ACC: 38A000E3  li r5, 0xe3
	ctx.r[5].s64 = 227;
	// 829C0AD0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829C0AD4: 4B8FF905  bl 0x822c03d8
	ctx.lr = 0x829C0AD8;
	sub_822C03D8(ctx, base);
	// 829C0AD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C0ADC: 41820010  beq 0x829c0aec
	if ctx.cr[0].eq {
	pc = 0x829C0AEC; continue 'dispatch;
	}
	// 829C0AE0: 4BFFFBF1  bl 0x829c06d0
	ctx.lr = 0x829C0AE4;
	sub_829C06D0(ctx, base);
	// 829C0AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C0AE8: 48000008  b 0x829c0af0
	pc = 0x829C0AF0; continue 'dispatch;
	// 829C0AEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829C0AF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C0AF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C0AF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C0AFC: 4BFFFEF5  bl 0x829c09f0
	ctx.lr = 0x829C0B00;
	sub_829C09F0(ctx, base);
	// 829C0B00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C0B04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C0B08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C0B0C: 4B8FF4F5  bl 0x822c0000
	ctx.lr = 0x829C0B10;
	sub_822C0000(ctx, base);
	// 829C0B10: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C0B14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C0B18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C0B1C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C0B20: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C0B24: 419A0024  beq cr6, 0x829c0b48
	if ctx.cr[6].eq {
	pc = 0x829C0B48; continue 'dispatch;
	}
	// 829C0B28: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C0B2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C0B30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C0B34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C0B38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C0B3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C0B40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C0B44: 4082FFE8  bne 0x829c0b2c
	if !ctx.cr[0].eq {
	pc = 0x829C0B2C; continue 'dispatch;
	}
	// 829C0B48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C0B4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C0B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C0B54: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C0B58: 4BFE4509  bl 0x829a5060
	ctx.lr = 0x829C0B5C;
	sub_829A5060(ctx, base);
	// 829C0B5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C0B60: 419A000C  beq cr6, 0x829c0b6c
	if ctx.cr[6].eq {
	pc = 0x829C0B6C; continue 'dispatch;
	}
	// 829C0B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C0B68: 4B8FFD29  bl 0x822c0890
	ctx.lr = 0x829C0B6C;
	sub_822C0890(ctx, base);
	// 829C0B6C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C0B70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C0B74: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C0B78: 48432E91  bl 0x82df3a08
	ctx.lr = 0x829C0B7C;
	sub_82DF3A08(ctx, base);
	// 829C0B7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0B80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C0B84: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C0B88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C0B8C: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C0B90: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C0B94: 481F27E5  bl 0x82bb3378
	ctx.lr = 0x829C0B98;
	sub_82BB3378(ctx, base);
	// 829C0B98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829C0B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C0BA0: 419A0008  beq cr6, 0x829c0ba8
	if ctx.cr[6].eq {
	pc = 0x829C0BA8; continue 'dispatch;
	}
	// 829C0BA4: 4B8FFCED  bl 0x822c0890
	ctx.lr = 0x829C0BA8;
	sub_822C0890(ctx, base);
	// 829C0BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C0BAC: 4843287D  bl 0x82df3428
	ctx.lr = 0x829C0BB0;
	sub_82DF3428(ctx, base);
	// 829C0BB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0BB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829C0BB8: 38AB2F40  addi r5, r11, 0x2f40
	ctx.r[5].s64 = ctx.r[11].s64 + 12096;
	// 829C0BBC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829C0BC0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C0BC4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829C0BC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C0BCC: 4E800421  bctrl
	ctx.lr = 0x829C0BD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C0BD0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829C0BD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C0BD8: 419A0008  beq cr6, 0x829c0be0
	if ctx.cr[6].eq {
	pc = 0x829C0BE0; continue 'dispatch;
	}
	// 829C0BDC: 4B8FFCB5  bl 0x822c0890
	ctx.lr = 0x829C0BE0;
	sub_822C0890(ctx, base);
	// 829C0BE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C0BE4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 829C0BE8: B15D0198  sth r10, 0x198(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(408 as u32), ctx.r[10].u16 ) };
	// 829C0BEC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0BF0: D01D0194  stfs f0, 0x194(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 829C0BF4: D01D0190  stfs f0, 0x190(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C0BF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829C0BFC: 487E75C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C0C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C0C00 size=1468
    let mut pc: u32 = 0x829C0C00;
    'dispatch: loop {
        match pc {
            0x829C0C00 => {
    //   block [0x829C0C00..0x829C11BC)
	// 829C0C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C0C04: 487E753D  bl 0x831a8140
	ctx.lr = 0x829C0C08;
	sub_831A8130(ctx, base);
	// 829C0C08: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 829C0C0C: 487E7E51  bl 0x831a8a5c
	ctx.lr = 0x829C0C10;
	sub_831A8A40(ctx, base);
	// 829C0C10: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C0C14: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829C0C18: 487939E9  bl 0x83154600
	ctx.lr = 0x829C0C1C;
	sub_83154600(ctx, base);
	// 829C0C1C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C0C20: A15C0198  lhz r10, 0x198(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(408 as u32) ) } as u64;
	// 829C0C24: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829C0C28: 3B6BA378  addi r27, r11, -0x5c88
	ctx.r[27].s64 = ctx.r[11].s64 + -23688;
	// 829C0C2C: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 829C0C30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829C0C34: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829C0C38: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829C0C3C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 829C0C40: 897BFFF8  lbz r11, -8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C0C44: C01BFFF4  lfs f0, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0C48: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 829C0C4C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829C0C50: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829C0C54: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829C0C58: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829C0C5C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829C0C60: EF206024  fdivs f25, f0, f12
	ctx.f[25].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 829C0C64: EFED0672  fmuls f31, f13, f25
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 829C0C68: 48498AF9  bl 0x82e59760
	ctx.lr = 0x829C0C6C;
	sub_82E59760(ctx, base);
	// 829C0C6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C0C70: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 829C0C74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C0C78: C2AB964C  lfs f21, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 829C0C7C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C0C80: 419904A8  bgt cr6, 0x829c1128
	if ctx.cr[6].gt {
	pc = 0x829C1128; continue 'dispatch;
	}
	// 829C0C84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C0C88: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 829C0C8C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C0C90: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829C0C94: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 829C0C98: C2EA2960  lfs f23, 0x2960(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 829C0C9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C0CA0: C30989AC  lfs f24, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 829C0CA4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C0CA8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C0CAC: C3C89450  lfs f30, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829C0CB0: C2C7C664  lfs f22, -0x399c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 829C0CB4: 3F20820A  lis r25, -0x7df6
	ctx.r[25].s64 = -2113273856;
	// 829C0CB8: C3469524  lfs f26, -0x6adc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 829C0CBC: 3EC08212  lis r22, -0x7dee
	ctx.r[22].s64 = -2112749568;
	// 829C0CC0: 3B0B2038  addi r24, r11, 0x2038
	ctx.r[24].s64 = ctx.r[11].s64 + 8248;
	// 829C0CC4: 3AEA2644  addi r23, r10, 0x2644
	ctx.r[23].s64 = ctx.r[10].s64 + 9796;
	// 829C0CC8: 3AA92F60  addi r21, r9, 0x2f60
	ctx.r[21].s64 = ctx.r[9].s64 + 12128;
	// 829C0CCC: A17C0198  lhz r11, 0x198(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(408 as u32) ) } as u64;
	// 829C0CD0: C01BFFF4  lfs f0, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C0CD4: C1B6DFAC  lfs f13, -0x2054(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C0CD8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829C0CDC: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 829C0CE0: C98100D8  lfd f12, 0xd8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 829C0CE4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829C0CE8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829C0CEC: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 829C0CF0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 829C0CF4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C0CF8: EFA006B2  fmuls f29, f0, f26
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 829C0CFC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829C0D00: 487E81A9  bl 0x831a8ea8
	ctx.lr = 0x829C0D04;
	sub_831A8EA8(ctx, base);
	// 829C0D04: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C0D08: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829C0D0C: 487E80BD  bl 0x831a8dc8
	ctx.lr = 0x829C0D10;
	sub_831A8DC8(ctx, base);
	// 829C0D10: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C0D14: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 829C0D18: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829C0D1C: 4099001C  ble cr6, 0x829c0d38
	if !ctx.cr[6].gt {
	pc = 0x829C0D38; continue 'dispatch;
	}
	// 829C0D20: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829C0D24: 487E80A5  bl 0x831a8dc8
	ctx.lr = 0x829C0D28;
	sub_831A8DC8(ctx, base);
	// 829C0D28: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C0D2C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 829C0D30: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 829C0D34: 419903BC  bgt cr6, 0x829c10f0
	if ctx.cr[6].gt {
	pc = 0x829C10F0; continue 'dispatch;
	}
	// 829C0D38: A17C0198  lhz r11, 0x198(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(408 as u32) ) } as u64;
	// 829C0D3C: C39B0004  lfs f28, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829C0D40: 807A0148  lwz r3, 0x148(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(328 as u32) ) } as u64;
	// 829C0D44: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C0D48: 41820034  beq 0x829c0d7c
	if ctx.cr[0].eq {
	pc = 0x829C0D7C; continue 'dispatch;
	}
	// 829C0D4C: D3010078  stfs f24, 0x78(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829C0D50: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 829C0D54: D3410070  stfs f26, 0x70(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829C0D58: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829C0D5C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829C0D60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C0D64: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829C0D68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C0D6C: 4E800421  bctrl
	ctx.lr = 0x829C0D70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C0D70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C0D74: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 829C0D78: 48000030  b 0x829c0da8
	pc = 0x829C0DA8; continue 'dispatch;
	// 829C0D7C: D2E10080  stfs f23, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829C0D80: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 829C0D84: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829C0D88: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829C0D8C: D3010088  stfs f24, 0x88(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829C0D90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C0D94: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829C0D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C0D9C: 4E800421  bctrl
	ctx.lr = 0x829C0DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C0DA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C0DA4: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829C0DA8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C0DAC: 484BAF1D  bl 0x82e7bcc8
	ctx.lr = 0x829C0DB0;
	sub_82E7BCC8(ctx, base);
	// 829C0DB0: 39610130  addi r11, r1, 0x130
	ctx.r[11].s64 = ctx.r[1].s64 + 304;
	// 829C0DB4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C0DB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C11C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C11C0 size=60
    let mut pc: u32 = 0x829C11C0;
    'dispatch: loop {
        match pc {
            0x829C11C0 => {
    //   block [0x829C11C0..0x829C11FC)
	// 829C11C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C11C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C11C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C11CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C11D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C11D4: 4BFFF65D  bl 0x829c0830
	ctx.lr = 0x829C11D8;
	sub_829C0830(ctx, base);
	// 829C11D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C11DC: 4B8FEE25  bl 0x822c0000
	ctx.lr = 0x829C11E0;
	sub_822C0000(ctx, base);
	// 829C11E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C11E4: 4BFFFA1D  bl 0x829c0c00
	ctx.lr = 0x829C11E8;
	sub_829C0C00(ctx, base);
	// 829C11E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C11EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C11F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C11F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C11F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1200 size=84
    let mut pc: u32 = 0x829C1200;
    'dispatch: loop {
        match pc {
            0x829C1200 => {
    //   block [0x829C1200..0x829C1254)
	// 829C1200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C120C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1214: 4BFE1E1D  bl 0x829a3030
	ctx.lr = 0x829C1218;
	sub_829A3030(ctx, base);
	// 829C1218: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C121C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C1220: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C1224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1228: 39292FB0  addi r9, r9, 0x2fb0
	ctx.r[9].s64 = ctx.r[9].s64 + 12208;
	// 829C122C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1230: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829C1234: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C1238: C00AA40C  lfs f0, -0x5bf4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23540 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C123C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1240: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C1244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C124C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C1258 size=36
    let mut pc: u32 = 0x829C1258;
    'dispatch: loop {
        match pc {
            0x829C1258 => {
    //   block [0x829C1258..0x829C127C)
	// 829C1258: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C125C: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1260: C00BA430  lfs f0, -0x5bd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C1268: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829C126C: 40980008  bge cr6, 0x829c1274
	if !ctx.cr[6].lt {
	pc = 0x829C1274; continue 'dispatch;
	}
	// 829C1270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C1274: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C1278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1280 size=536
    let mut pc: u32 = 0x829C1280;
    'dispatch: loop {
        match pc {
            0x829C1280 => {
    //   block [0x829C1280..0x829C1498)
	// 829C1280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C128C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1290: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1294: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829C1298: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C129C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C12A0: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C12A4: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C12A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C12AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C12B0: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C12B4: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C12B8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C12BC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C12C0: 41980194  blt cr6, 0x829c1454
	if ctx.cr[6].lt {
	pc = 0x829C1454; continue 'dispatch;
	}
	// 829C12C4: 419A015C  beq cr6, 0x829c1420
	if ctx.cr[6].eq {
	pc = 0x829C1420; continue 'dispatch;
	}
	// 829C12C8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C12CC: 41980104  blt cr6, 0x829c13d0
	if ctx.cr[6].lt {
	pc = 0x829C13D0; continue 'dispatch;
	}
	// 829C12D0: 419A00CC  beq cr6, 0x829c139c
	if ctx.cr[6].eq {
	pc = 0x829C139C; continue 'dispatch;
	}
	// 829C12D4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C12D8: 41980078  blt cr6, 0x829c1350
	if ctx.cr[6].lt {
	pc = 0x829C1350; continue 'dispatch;
	}
	// 829C12DC: 419A001C  beq cr6, 0x829c12f8
	if ctx.cr[6].eq {
	pc = 0x829C12F8; continue 'dispatch;
	}
	// 829C12E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C12E4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C12E8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C12EC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C12F0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C12F4: 48000188  b 0x829c147c
	pc = 0x829C147C; continue 'dispatch;
	// 829C12F8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829C12FC: C1AB2784  lfs f13, 0x2784(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1300: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C1304: 487E7BA5  bl 0x831a8ea8
	ctx.lr = 0x829C1308;
	sub_831A8EA8(ctx, base);
	// 829C1308: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C130C: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C1310: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1314: 392BA42C  addi r9, r11, -0x5bd4
	ctx.r[9].s64 = ctx.r[11].s64 + -23508;
	// 829C1318: C16BA42C  lfs f11, -0x5bd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23508 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C131C: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1320: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1324: C1A9FFFC  lfs f13, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1328: ED0D0028  fsubs f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C132C: C149FFF0  lfs f10, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C1330: ED6B5278  fmsubs f11, f11, f9, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 829C1334: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C1338: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C133C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1340: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1344: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1348: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C134C: 48000134  b 0x829c1480
	pc = 0x829C1480; continue 'dispatch;
	// 829C1350: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C1354: C1ABA2EC  lfs f13, -0x5d14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1358: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C135C: 487E7B4D  bl 0x831a8ea8
	ctx.lr = 0x829C1360;
	sub_831A8EA8(ctx, base);
	// 829C1360: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1364: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C1368: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C136C: 392BA42C  addi r9, r11, -0x5bd4
	ctx.r[9].s64 = ctx.r[11].s64 + -23508;
	// 829C1370: C18BA42C  lfs f12, -0x5bd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23508 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1374: C14A603C  lfs f10, 0x603c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24636 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C1378: C169FFF0  lfs f11, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C137C: ED6C5A78  fmsubs f11, f12, f9, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 829C1380: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1384: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829C1388: C1A9FFFC  lfs f13, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C138C: ED0D0028  fsubs f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C1390: C18808A4  lfs f12, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1394: EC0802BA  fmadds f0, f8, f10, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C1398: 4BFFFFA0  b 0x829c1338
	pc = 0x829C1338; continue 'dispatch;
	// 829C139C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829C13A0: C1ABE830  lfs f13, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C13A4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C13A8: 487E7B01  bl 0x831a8ea8
	ctx.lr = 0x829C13AC;
	sub_831A8EA8(ctx, base);
	// 829C13AC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C13B0: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C13B4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829C13B8: 392BA42C  addi r9, r11, -0x5bd4
	ctx.r[9].s64 = ctx.r[11].s64 + -23508;
	// 829C13BC: C18BA42C  lfs f12, -0x5bd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23508 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C13C0: C14A2F20  lfs f10, 0x2f20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12064 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C13C4: C169FFF0  lfs f11, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C13C8: ED6C5A7A  fmadds f11, f12, f9, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64);
	// 829C13CC: 4BFFFFB4  b 0x829c1380
	pc = 0x829C1380; continue 'dispatch;
	// 829C13D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829C13D4: C1ABD7BC  lfs f13, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C13D8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C13DC: 487E7ACD  bl 0x831a8ea8
	ctx.lr = 0x829C13E0;
	sub_831A8EA8(ctx, base);
	// 829C13E0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C13E4: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C13E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C13EC: 392BA42C  addi r9, r11, -0x5bd4
	ctx.r[9].s64 = ctx.r[11].s64 + -23508;
	// 829C13F0: C16BA42C  lfs f11, -0x5bd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23508 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C13F4: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C13F8: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C13FC: C189FFFC  lfs f12, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1400: ED0C0028  fsubs f8, f12, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C1404: C149FFF0  lfs f10, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C1408: C189FFF4  lfs f12, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C140C: ED6B527A  fmadds f11, f11, f9, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 829C1410: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1414: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1418: EC08037A  fmadds f0, f8, f13, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C141C: 4BFFFF28  b 0x829c1344
	pc = 0x829C1344; continue 'dispatch;
	// 829C1420: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1424: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1428: 396BA42C  addi r11, r11, -0x5bd4
	ctx.r[11].s64 = ctx.r[11].s64 + -23508;
	// 829C142C: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1430: C00BFFE4  lfs f0, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1434: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C1438: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C143C: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1440: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1444: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1448: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C144C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1450: 48000030  b 0x829c1480
	pc = 0x829C1480; continue 'dispatch;
	// 829C1454: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1458: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C145C: 396BA42C  addi r11, r11, -0x5bd4
	ctx.r[11].s64 = ctx.r[11].s64 + -23508;
	// 829C1460: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C1464: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1468: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C146C: C00BFFE4  lfs f0, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1470: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1474: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C1478: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C147C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C1488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C148C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1498 size=320
    let mut pc: u32 = 0x829C1498;
    'dispatch: loop {
        match pc {
            0x829C1498 => {
    //   block [0x829C1498..0x829C15D8)
	// 829C1498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C149C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C14A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C14A4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C14A8: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C14AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C14B0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C14B4: 419800E4  blt cr6, 0x829c1598
	if ctx.cr[6].lt {
	pc = 0x829C1598; continue 'dispatch;
	}
	// 829C14B8: 419A00E0  beq cr6, 0x829c1598
	if ctx.cr[6].eq {
	pc = 0x829C1598; continue 'dispatch;
	}
	// 829C14BC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C14C0: 41980094  blt cr6, 0x829c1554
	if ctx.cr[6].lt {
	pc = 0x829C1554; continue 'dispatch;
	}
	// 829C14C4: 419A0068  beq cr6, 0x829c152c
	if ctx.cr[6].eq {
	pc = 0x829C152C; continue 'dispatch;
	}
	// 829C14C8: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C14CC: 41980038  blt cr6, 0x829c1504
	if ctx.cr[6].lt {
	pc = 0x829C1504; continue 'dispatch;
	}
	// 829C14D0: 409A00CC  bne cr6, 0x829c159c
	if !ctx.cr[6].eq {
	pc = 0x829C159C; continue 'dispatch;
	}
	// 829C14D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C14D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C14DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C14E0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C14E4: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C14E8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C14EC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C14F0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C14F4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C14F8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C14FC: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1500: 48000080  b 0x829c1580
	pc = 0x829C1580; continue 'dispatch;
	// 829C1504: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1508: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C150C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829C1510: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1514: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1518: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C151C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C1520: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C1524: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C1528: 4BFFFFD0  b 0x829c14f8
	pc = 0x829C14F8; continue 'dispatch;
	// 829C152C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1530: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1534: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829C1538: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C153C: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1540: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829C1544: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829C1548: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829C154C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829C1550: 48000028  b 0x829c1578
	pc = 0x829C1578; continue 'dispatch;
	// 829C1554: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1558: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C155C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829C1560: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1564: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1568: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829C156C: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829C1570: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829C1574: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829C1578: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C157C: C1A89530  lfs f13, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1580: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C1584: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1588: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C158C: 484BB6B5  bl 0x82e7cc40
	ctx.lr = 0x829C1590;
	sub_82E7CC40(ctx, base);
	// 829C1590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1594: 48000030  b 0x829c15c4
	pc = 0x829C15C4; continue 'dispatch;
	// 829C1598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C159C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829C15A0: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829C15A4: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C15A8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C15AC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C15B0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C15B4: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C15B8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C15BC: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C15C0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C15C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829C15C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C15CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C15D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C15D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C15D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C15D8 size=172
    let mut pc: u32 = 0x829C15D8;
    'dispatch: loop {
        match pc {
            0x829C15D8 => {
    //   block [0x829C15D8..0x829C1684)
	// 829C15D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C15DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C15E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C15E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C15E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C15EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C15F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C15F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C15F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C15FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C1600: 4B8FF339  bl 0x822c0938
	ctx.lr = 0x829C1604;
	sub_822C0938(ctx, base);
	// 829C1604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C1608: 41820028  beq 0x829c1630
	if ctx.cr[0].eq {
	pc = 0x829C1630; continue 'dispatch;
	}
	// 829C160C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C1610: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C1614: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C1618: 392B2FC8  addi r9, r11, 0x2fc8
	ctx.r[9].s64 = ctx.r[11].s64 + 12232;
	// 829C161C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C1620: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C1624: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C1628: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C162C: 48000008  b 0x829c1634
	pc = 0x829C1634; continue 'dispatch;
	// 829C1630: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C1634: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C1638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C163C: 409A002C  bne cr6, 0x829c1668
	if !ctx.cr[6].eq {
	pc = 0x829C1668; continue 'dispatch;
	}
	// 829C1640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1644: 4B8FEC25  bl 0x822c0268
	ctx.lr = 0x829C1648;
	sub_822C0268(ctx, base);
	// 829C1648: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C164C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C1654: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C1658: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C165C: 816BA458  lwz r11, -0x5ba8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23464 as u32) ) } as u64;
	// 829C1660: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C1664: 4B8FE99D  bl 0x822c0000
	ctx.lr = 0x829C1668;
	sub_822C0000(ctx, base);
	// 829C1668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C166C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C1670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1678: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C167C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1688 size=300
    let mut pc: u32 = 0x829C1688;
    'dispatch: loop {
        match pc {
            0x829C1688 => {
    //   block [0x829C1688..0x829C17B4)
	// 829C1688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C168C: 487E6AE1  bl 0x831a816c
	ctx.lr = 0x829C1690;
	sub_831A8130(ctx, base);
	// 829C1690: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C1698: 48792F69  bl 0x83154600
	ctx.lr = 0x829C169C;
	sub_83154600(ctx, base);
	// 829C169C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C16A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C16A4: 4BFFCE2D  bl 0x829be4d0
	ctx.lr = 0x829C16A8;
	sub_829BE4D0(ctx, base);
	// 829C16A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C16AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C16B0: 388B2FD8  addi r4, r11, 0x2fd8
	ctx.r[4].s64 = ctx.r[11].s64 + 12248;
	// 829C16B4: 38A000E4  li r5, 0xe4
	ctx.r[5].s64 = 228;
	// 829C16B8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829C16BC: 4B8FED1D  bl 0x822c03d8
	ctx.lr = 0x829C16C0;
	sub_822C03D8(ctx, base);
	// 829C16C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C16C4: 41820010  beq 0x829c16d4
	if ctx.cr[0].eq {
	pc = 0x829C16D4; continue 'dispatch;
	}
	// 829C16C8: 4BFFFB39  bl 0x829c1200
	ctx.lr = 0x829C16CC;
	sub_829C1200(ctx, base);
	// 829C16CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C16D0: 48000008  b 0x829c16d8
	pc = 0x829C16D8; continue 'dispatch;
	// 829C16D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829C16D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C16DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C16E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C16E4: 4BFFFEF5  bl 0x829c15d8
	ctx.lr = 0x829C16E8;
	sub_829C15D8(ctx, base);
	// 829C16E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C16EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C16F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C16F4: 4B8FE90D  bl 0x822c0000
	ctx.lr = 0x829C16F8;
	sub_822C0000(ctx, base);
	// 829C16F8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C16FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C1700: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C1704: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C1708: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C170C: 419A0024  beq cr6, 0x829c1730
	if ctx.cr[6].eq {
	pc = 0x829C1730; continue 'dispatch;
	}
	// 829C1710: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C1714: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C1718: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C171C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C1720: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C1724: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C1728: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C172C: 4082FFE8  bne 0x829c1714
	if !ctx.cr[0].eq {
	pc = 0x829C1714; continue 'dispatch;
	}
	// 829C1730: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1734: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C1738: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C173C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C1740: 4BFE3921  bl 0x829a5060
	ctx.lr = 0x829C1744;
	sub_829A5060(ctx, base);
	// 829C1744: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C1748: 419A000C  beq cr6, 0x829c1754
	if ctx.cr[6].eq {
	pc = 0x829C1754; continue 'dispatch;
	}
	// 829C174C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1750: 4B8FF141  bl 0x822c0890
	ctx.lr = 0x829C1754;
	sub_822C0890(ctx, base);
	// 829C1754: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C1758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C175C: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C1760: 484322A9  bl 0x82df3a08
	ctx.lr = 0x829C1764;
	sub_82DF3A08(ctx, base);
	// 829C1764: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C1768: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C176C: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C1770: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C1774: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C1778: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C177C: 481F1BFD  bl 0x82bb3378
	ctx.lr = 0x829C1780;
	sub_82BB3378(ctx, base);
	// 829C1780: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829C1784: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C1788: 419A0008  beq cr6, 0x829c1790
	if ctx.cr[6].eq {
	pc = 0x829C1790; continue 'dispatch;
	}
	// 829C178C: 4B8FF105  bl 0x822c0890
	ctx.lr = 0x829C1790;
	sub_822C0890(ctx, base);
	// 829C1790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C1794: 48431C95  bl 0x82df3428
	ctx.lr = 0x829C1798;
	sub_82DF3428(ctx, base);
	// 829C1798: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C179C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829C17A0: 995E0194  stb r10, 0x194(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(404 as u32), ctx.r[10].u8 ) };
	// 829C17A4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C17A8: D01E0190  stfs f0, 0x190(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C17AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829C17B0: 487E6A0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C17B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C17B8 size=84
    let mut pc: u32 = 0x829C17B8;
    'dispatch: loop {
        match pc {
            0x829C17B8 => {
    //   block [0x829C17B8..0x829C180C)
	// 829C17B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C17BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C17C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C17C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C17C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C17CC: 4BFE1865  bl 0x829a3030
	ctx.lr = 0x829C17D0;
	sub_829A3030(ctx, base);
	// 829C17D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C17D4: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C17D8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C17DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C17E0: 39293030  addi r9, r9, 0x3030
	ctx.r[9].s64 = ctx.r[9].s64 + 12336;
	// 829C17E4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C17E8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829C17EC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C17F0: C00AA4F4  lfs f0, -0x5b0c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C17F4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C17F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C17FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C1810 size=20
    let mut pc: u32 = 0x829C1810;
    'dispatch: loop {
        match pc {
            0x829C1810 => {
    //   block [0x829C1810..0x829C1824)
	// 829C1810: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1814: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1818: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C181C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829C1820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C1828 size=64
    let mut pc: u32 = 0x829C1828;
    'dispatch: loop {
        match pc {
            0x829C1828 => {
    //   block [0x829C1828..0x829C1868)
	// 829C1828: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C182C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C1830: 419800DC  blt cr6, 0x829c190c
	if ctx.cr[6].lt {
		sub_829C190C(ctx, base);
		return;
	}
	// 829C1834: 419A00A4  beq cr6, 0x829c18d8
	if ctx.cr[6].eq {
		sub_829C18D8(ctx, base);
		return;
	}
	// 829C1838: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C183C: 41980084  blt cr6, 0x829c18c0
	if ctx.cr[6].lt {
		sub_829C18C0(ctx, base);
		return;
	}
	// 829C1840: 419A0068  beq cr6, 0x829c18a8
	if ctx.cr[6].eq {
		sub_829C18A8(ctx, base);
		return;
	}
	// 829C1844: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C1848: 41980044  blt cr6, 0x829c188c
	if ctx.cr[6].lt {
		sub_829C188C(ctx, base);
		return;
	}
	// 829C184C: 419A001C  beq cr6, 0x829c1868
	if ctx.cr[6].eq {
		sub_829C1868(ctx, base);
		return;
	}
	// 829C1850: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1854: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1858: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C185C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C1860: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1864: 480000D0  b 0x829c1934
	sub_829C190C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C1868 size=36
    let mut pc: u32 = 0x829C1868;
    'dispatch: loop {
        match pc {
            0x829C1868 => {
    //   block [0x829C1868..0x829C188C)
	// 829C1868: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C186C: 392BA508  addi r9, r11, -0x5af8
	ctx.r[9].s64 = ctx.r[11].s64 + -23288;
	// 829C1870: C00BA508  lfs f0, -0x5af8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1874: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C1878: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C187C: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1880: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1884: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C1888: 48000070  b 0x829c18f8
	sub_829C18D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C188C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C188C size=28
    let mut pc: u32 = 0x829C188C;
    'dispatch: loop {
        match pc {
            0x829C188C => {
    //   block [0x829C188C..0x829C18A8)
	// 829C188C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1890: 396BA508  addi r11, r11, -0x5af8
	ctx.r[11].s64 = ctx.r[11].s64 + -23288;
	// 829C1894: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1898: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C189C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C18A0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C18A4: 4800004C  b 0x829c18f0
	sub_829C18D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C18A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C18A8 size=24
    let mut pc: u32 = 0x829C18A8;
    'dispatch: loop {
        match pc {
            0x829C18A8 => {
    //   block [0x829C18A8..0x829C18C0)
	// 829C18A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C18AC: 392BA508  addi r9, r11, -0x5af8
	ctx.r[9].s64 = ctx.r[11].s64 + -23288;
	// 829C18B0: C00BA508  lfs f0, -0x5af8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C18B4: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C18B8: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C18BC: 48000064  b 0x829c1920
	sub_829C190C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C18C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C18C0 size=24
    let mut pc: u32 = 0x829C18C0;
    'dispatch: loop {
        match pc {
            0x829C18C0 => {
    //   block [0x829C18C0..0x829C18D8)
	// 829C18C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C18C4: 396BA508  addi r11, r11, -0x5af8
	ctx.r[11].s64 = ctx.r[11].s64 + -23288;
	// 829C18C8: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C18CC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C18D0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C18D4: 4800004C  b 0x829c1920
	sub_829C190C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C18D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C18D8 size=52
    let mut pc: u32 = 0x829C18D8;
    'dispatch: loop {
        match pc {
            0x829C18D8 => {
    //   block [0x829C18D8..0x829C190C)
	// 829C18D8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C18DC: 396BA508  addi r11, r11, -0x5af8
	ctx.r[11].s64 = ctx.r[11].s64 + -23288;
	// 829C18E0: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C18E4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C18E8: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C18EC: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C18F0: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C18F4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C18F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C18FC: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1900: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1904: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C190C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C190C size=48
    let mut pc: u32 = 0x829C190C;
    'dispatch: loop {
        match pc {
            0x829C190C => {
    //   block [0x829C190C..0x829C193C)
	// 829C190C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1910: 396BA508  addi r11, r11, -0x5af8
	ctx.r[11].s64 = ctx.r[11].s64 + -23288;
	// 829C1914: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1918: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C191C: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1920: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1924: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1928: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C192C: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C1930: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1934: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1940 size=212
    let mut pc: u32 = 0x829C1940;
    'dispatch: loop {
        match pc {
            0x829C1940 => {
    //   block [0x829C1940..0x829C1A14)
	// 829C1940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C194C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1950: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C1954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1958: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C195C: 41980064  blt cr6, 0x829c19c0
	if ctx.cr[6].lt {
	pc = 0x829C19C0; continue 'dispatch;
	}
	// 829C1960: 419A0030  beq cr6, 0x829c1990
	if ctx.cr[6].eq {
	pc = 0x829C1990; continue 'dispatch;
	}
	// 829C1964: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829C1968: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829C196C: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1970: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1974: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1978: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C197C: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1980: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C1984: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1988: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C198C: 48000074  b 0x829c1a00
	pc = 0x829C1A00; continue 'dispatch;
	// 829C1990: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1994: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1998: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C199C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C19A0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C19A4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C19A8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C19AC: C1A89530  lfs f13, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C19B0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C19B4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C19B8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C19BC: 48000030  b 0x829c19ec
	pc = 0x829C19EC; continue 'dispatch;
	// 829C19C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C19C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C19C8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C19CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829C19D0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C19D4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C19D8: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C19DC: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C19E0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C19E4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C19E8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C19EC: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C19F0: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C19F4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C19F8: 484BB249  bl 0x82e7cc40
	ctx.lr = 0x829C19FC;
	sub_82E7CC40(ctx, base);
	// 829C19FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1A00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C1A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C1A18 size=52
    let mut pc: u32 = 0x829C1A18;
    'dispatch: loop {
        match pc {
            0x829C1A18 => {
    //   block [0x829C1A18..0x829C1A4C)
	// 829C1A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1A24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1A2C: 480003ED  bl 0x829c1e18
	ctx.lr = 0x829C1A30;
	sub_829C1E18(ctx, base);
	// 829C1A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1A34: 4B8FE5CD  bl 0x822c0000
	ctx.lr = 0x829C1A38;
	sub_822C0000(ctx, base);
	// 829C1A38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C1A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C1A50 size=172
    let mut pc: u32 = 0x829C1A50;
    'dispatch: loop {
        match pc {
            0x829C1A50 => {
    //   block [0x829C1A50..0x829C1AFC)
	// 829C1A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1A58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C1A5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1A60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C1A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C1A6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C1A70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C1A74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C1A78: 4B8FEEC1  bl 0x822c0938
	ctx.lr = 0x829C1A7C;
	sub_822C0938(ctx, base);
	// 829C1A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C1A80: 41820028  beq 0x829c1aa8
	if ctx.cr[0].eq {
	pc = 0x829C1AA8; continue 'dispatch;
	}
	// 829C1A84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C1A88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C1A8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C1A90: 392B3048  addi r9, r11, 0x3048
	ctx.r[9].s64 = ctx.r[11].s64 + 12360;
	// 829C1A94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C1A98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C1A9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C1AA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C1AA4: 48000008  b 0x829c1aac
	pc = 0x829C1AAC; continue 'dispatch;
	// 829C1AA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C1AAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C1AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C1AB4: 409A002C  bne cr6, 0x829c1ae0
	if !ctx.cr[6].eq {
	pc = 0x829C1AE0; continue 'dispatch;
	}
	// 829C1AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1ABC: 4B8FE7AD  bl 0x822c0268
	ctx.lr = 0x829C1AC0;
	sub_822C0268(ctx, base);
	// 829C1AC0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1AC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C1ACC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C1AD0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C1AD4: 816BA518  lwz r11, -0x5ae8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23272 as u32) ) } as u64;
	// 829C1AD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C1ADC: 4B8FE525  bl 0x822c0000
	ctx.lr = 0x829C1AE0;
	sub_822C0000(ctx, base);
	// 829C1AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C1AE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C1AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1AF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C1AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1B00 size=248
    let mut pc: u32 = 0x829C1B00;
    'dispatch: loop {
        match pc {
            0x829C1B00 => {
    //   block [0x829C1B00..0x829C1BF8)
	// 829C1B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1B08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C1B0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1B10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1B18: 48792AE9  bl 0x83154600
	ctx.lr = 0x829C1B1C;
	sub_83154600(ctx, base);
	// 829C1B1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C1B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1B24: 4BFFC9AD  bl 0x829be4d0
	ctx.lr = 0x829C1B28;
	sub_829BE4D0(ctx, base);
	// 829C1B28: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C1B2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C1B30: 388B3058  addi r4, r11, 0x3058
	ctx.r[4].s64 = ctx.r[11].s64 + 12376;
	// 829C1B34: 38A000A5  li r5, 0xa5
	ctx.r[5].s64 = 165;
	// 829C1B38: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829C1B3C: 4B8FE89D  bl 0x822c03d8
	ctx.lr = 0x829C1B40;
	sub_822C03D8(ctx, base);
	// 829C1B40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C1B44: 41820010  beq 0x829c1b54
	if ctx.cr[0].eq {
	pc = 0x829C1B54; continue 'dispatch;
	}
	// 829C1B48: 4BFFFC71  bl 0x829c17b8
	ctx.lr = 0x829C1B4C;
	sub_829C17B8(ctx, base);
	// 829C1B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1B50: 48000008  b 0x829c1b58
	pc = 0x829C1B58; continue 'dispatch;
	// 829C1B54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829C1B58: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C1B5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C1B60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C1B64: 4BFFFEED  bl 0x829c1a50
	ctx.lr = 0x829C1B68;
	sub_829C1A50(ctx, base);
	// 829C1B68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C1B6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C1B70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C1B74: 4B8FE48D  bl 0x822c0000
	ctx.lr = 0x829C1B78;
	sub_822C0000(ctx, base);
	// 829C1B78: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C1B7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C1B80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C1B84: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C1B88: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C1B8C: 419A0024  beq cr6, 0x829c1bb0
	if ctx.cr[6].eq {
	pc = 0x829C1BB0; continue 'dispatch;
	}
	// 829C1B90: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C1B94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C1B98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C1B9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C1BA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C1BA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C1BA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C1BAC: 4082FFE8  bne 0x829c1b94
	if !ctx.cr[0].eq {
	pc = 0x829C1B94; continue 'dispatch;
	}
	// 829C1BB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1BB4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C1BB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C1BBC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C1BC0: 4BFE34A1  bl 0x829a5060
	ctx.lr = 0x829C1BC4;
	sub_829A5060(ctx, base);
	// 829C1BC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C1BC8: 419A000C  beq cr6, 0x829c1bd4
	if ctx.cr[6].eq {
	pc = 0x829C1BD4; continue 'dispatch;
	}
	// 829C1BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1BD0: 4B8FECC1  bl 0x822c0890
	ctx.lr = 0x829C1BD4;
	sub_822C0890(ctx, base);
	// 829C1BD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C1BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C1BDC: 4BFE32FD  bl 0x829a4ed8
	ctx.lr = 0x829C1BE0;
	sub_829A4ED8(ctx, base);
	// 829C1BE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C1BE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1BE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1BEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C1BF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1BF8 size=84
    let mut pc: u32 = 0x829C1BF8;
    'dispatch: loop {
        match pc {
            0x829C1BF8 => {
    //   block [0x829C1BF8..0x829C1C4C)
	// 829C1BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1C00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1C04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1C08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1C0C: 4BFE1425  bl 0x829a3030
	ctx.lr = 0x829C1C10;
	sub_829A3030(ctx, base);
	// 829C1C10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C1C14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1C18: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C1C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1C20: 392930AC  addi r9, r9, 0x30ac
	ctx.r[9].s64 = ctx.r[9].s64 + 12460;
	// 829C1C24: C00BFF14  lfs f0, -0xec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1C28: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1C2C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C1C30: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1C34: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829C1C38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C1C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1C44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C1C50 size=76
    let mut pc: u32 = 0x829C1C50;
    'dispatch: loop {
        match pc {
            0x829C1C50 => {
    //   block [0x829C1C50..0x829C1C9C)
	// 829C1C50: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1C54: C1630014  lfs f11, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C1C58: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1C5C: 392BA5E0  addi r9, r11, -0x5a20
	ctx.r[9].s64 = ctx.r[11].s64 + -23072;
	// 829C1C60: C1ABA5E0  lfs f13, -0x5a20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23072 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C1C68: C18A08A8  lfs f12, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1C6C: ED4D602A  fadds f10, f13, f12
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 829C1C70: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1C74: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1C78: C189FFFC  lfs f12, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1C7C: EDA0637A  fmadds f13, f0, f13, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 829C1C80: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1C84: EC0D02BA  fmadds f0, f13, f10, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C1C88: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 829C1C8C: 40980008  bge cr6, 0x829c1c94
	if !ctx.cr[6].lt {
	pc = 0x829C1C94; continue 'dispatch;
	}
	// 829C1C90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C1C94: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C1C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1CA0 size=116
    let mut pc: u32 = 0x829C1CA0;
    'dispatch: loop {
        match pc {
            0x829C1CA0 => {
    //   block [0x829C1CA0..0x829C1D14)
	// 829C1CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1CA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1CAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1CB0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1CB4: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1CB8: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829C1CBC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C1CC0: 3BEBA5BC  addi r31, r11, -0x5a44
	ctx.r[31].s64 = ctx.r[11].s64 + -23108;
	// 829C1CC4: C00BA5BC  lfs f0, -0x5a44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1CC8: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829C1CCC: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1CD0: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1CD4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C1CD8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C1CDC: 487E71CD  bl 0x831a8ea8
	ctx.lr = 0x829C1CE0;
	sub_831A8EA8(ctx, base);
	// 829C1CE0: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C1CE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C1CE8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1CEC: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1CF0: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C1CF4: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1CF8: EDAC6B7C  fnmsubs f13, f12, f13, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C1CFC: EC2D02FA  fmadds f1, f13, f11, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C1D00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C1D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1D18 size=256
    let mut pc: u32 = 0x829C1D18;
    'dispatch: loop {
        match pc {
            0x829C1D18 => {
    //   block [0x829C1D18..0x829C1E18)
	// 829C1D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1D20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1D24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1D28: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C1D2C: C1A40014  lfs f13, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1D30: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C1D34: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C1D38: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C1D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1D40: C00AA5B8  lfs f0, -0x5a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1D44: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829C1D48: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829C1D4C: C1A9DFAC  lfs f13, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1D50: C0089524  lfs f0, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1D54: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C1D58: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C1D5C: 4198007C  blt cr6, 0x829c1dd8
	if ctx.cr[6].lt {
	pc = 0x829C1DD8; continue 'dispatch;
	}
	// 829C1D60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1D64: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829C1D68: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1D6C: 419A003C  beq cr6, 0x829c1da8
	if ctx.cr[6].eq {
	pc = 0x829C1DA8; continue 'dispatch;
	}
	// 829C1D70: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 829C1D74: 41980024  blt cr6, 0x829c1d98
	if ctx.cr[6].lt {
	pc = 0x829C1D98; continue 'dispatch;
	}
	// 829C1D78: 419A0018  beq cr6, 0x829c1d90
	if ctx.cr[6].eq {
	pc = 0x829C1D90; continue 'dispatch;
	}
	// 829C1D7C: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 829C1D80: 4098002C  bge cr6, 0x829c1dac
	if !ctx.cr[6].lt {
	pc = 0x829C1DAC; continue 'dispatch;
	}
	// 829C1D84: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829C1D88: C16B7BC4  lfs f11, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C1D8C: 48000014  b 0x829c1da0
	pc = 0x829C1DA0; continue 'dispatch;
	// 829C1D90: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C1D94: 48000018  b 0x829c1dac
	pc = 0x829C1DAC; continue 'dispatch;
	// 829C1D98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C1D9C: C16B9450  lfs f11, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C1DA0: EC0D02FA  fmadds f0, f13, f11, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C1DA4: 48000008  b 0x829c1dac
	pc = 0x829C1DAC; continue 'dispatch;
	// 829C1DA8: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C1DAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1DB0: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C1DB4: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C1DB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C1DBC: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C1DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1DC4: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C1DC8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1DCC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C1DD0: 484BAE71  bl 0x82e7cc40
	ctx.lr = 0x829C1DD4;
	sub_82E7CC40(ctx, base);
	// 829C1DD4: 4800002C  b 0x829c1e00
	pc = 0x829C1E00; continue 'dispatch;
	// 829C1DD8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829C1DDC: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829C1DE0: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1DE4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C1DE8: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1DEC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C1DF0: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1DF4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C1DF8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1DFC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C1E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1E04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C1E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1E18 size=264
    let mut pc: u32 = 0x829C1E18;
    'dispatch: loop {
        match pc {
            0x829C1E18 => {
    //   block [0x829C1E18..0x829C1F20)
	// 829C1E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C1E20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C1E24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C1E28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C1E2C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C1E34: 487927CD  bl 0x83154600
	ctx.lr = 0x829C1E38;
	sub_83154600(ctx, base);
	// 829C1E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1E3C: 4BFFCA15  bl 0x829be850
	ctx.lr = 0x829C1E40;
	sub_829BE850(ctx, base);
	// 829C1E40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1E48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C1E4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C1E50: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C1E54: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C1E58: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C1E5C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C1E60: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C1E64: 4BFFC4F5  bl 0x829be358
	ctx.lr = 0x829C1E68;
	sub_829BE358(ctx, base);
	// 829C1E68: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829C1E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1E70: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 829C1E74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C1E78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C1E7C: 4BFFC4F5  bl 0x829be370
	ctx.lr = 0x829C1E80;
	sub_829BE370(ctx, base);
	// 829C1E80: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C1E84: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C1E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1E8C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C1E90: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829C1E94: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C1E98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C1E9C: 4BFFC4BD  bl 0x829be358
	ctx.lr = 0x829C1EA0;
	sub_829BE358(ctx, base);
	// 829C1EA0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C1EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1EA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C1EAC: 4BFFC4C5  bl 0x829be370
	ctx.lr = 0x829C1EB0;
	sub_829BE370(ctx, base);
	// 829C1EB0: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829C1EB4: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829C1EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1EBC: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829C1EC0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829C1EC4: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829C1EC8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829C1ECC: 4BFFC48D  bl 0x829be358
	ctx.lr = 0x829C1ED0;
	sub_829BE358(ctx, base);
	// 829C1ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1ED4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C1ED8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829C1EDC: 4BFFC495  bl 0x829be370
	ctx.lr = 0x829C1EE0;
	sub_829BE370(ctx, base);
	// 829C1EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1EE4: 4849787D  bl 0x82e59760
	ctx.lr = 0x829C1EE8;
	sub_82E59760(ctx, base);
	// 829C1EE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C1EEC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1EF0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829C1EF4: 40990008  ble cr6, 0x829c1efc
	if !ctx.cr[6].gt {
	pc = 0x829C1EFC; continue 'dispatch;
	}
	// 829C1EF8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 829C1EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C1F00: 4BFFC4A9  bl 0x829be3a8
	ctx.lr = 0x829C1F04;
	sub_829BE3A8(ctx, base);
	// 829C1F04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829C1F08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C1F0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C1F10: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829C1F14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C1F18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C1F1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C1F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C1F20 size=528
    let mut pc: u32 = 0x829C1F20;
    'dispatch: loop {
        match pc {
            0x829C1F20 => {
    //   block [0x829C1F20..0x829C2130)
	// 829C1F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C1F24: 487E6245  bl 0x831a8168
	ctx.lr = 0x829C1F28;
	sub_831A8130(ctx, base);
	// 829C1F28: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829C1F2C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829C1F30: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C1F34: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C1F38: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829C1F3C: 3BEBA5A4  addi r31, r11, -0x5a5c
	ctx.r[31].s64 = ctx.r[11].s64 + -23132;
	// 829C1F40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829C1F44: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C1F48: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C1F4C: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1F50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C1F54: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1F58: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C1F5C: ED606824  fdivs f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C1F60: C19D0014  lfs f12, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1F64: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1F68: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 829C1F6C: EFEC0372  fmuls f31, f12, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C1F70: 41980188  blt cr6, 0x829c20f8
	if ctx.cr[6].lt {
	pc = 0x829C20F8; continue 'dispatch;
	}
	// 829C1F74: 419A0158  beq cr6, 0x829c20cc
	if ctx.cr[6].eq {
	pc = 0x829C20CC; continue 'dispatch;
	}
	// 829C1F78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C1F7C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C1F80: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C1F84: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829C1F88: C1899450  lfs f12, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C1F8C: 41980034  blt cr6, 0x829c1fc0
	if ctx.cr[6].lt {
	pc = 0x829C1FC0; continue 'dispatch;
	}
	// 829C1F90: 419A0028  beq cr6, 0x829c1fb8
	if ctx.cr[6].eq {
	pc = 0x829C1FB8; continue 'dispatch;
	}
	// 829C1F94: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C1F98: 41980018  blt cr6, 0x829c1fb0
	if ctx.cr[6].lt {
	pc = 0x829C1FB0; continue 'dispatch;
	}
	// 829C1F9C: 409A0028  bne cr6, 0x829c1fc4
	if !ctx.cr[6].eq {
	pc = 0x829C1FC4; continue 'dispatch;
	}
	// 829C1FA0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829C1FA4: C1AB7BC4  lfs f13, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1FA8: EFE0FB7A  fmadds f31, f0, f13, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64);
	// 829C1FAC: 48000018  b 0x829c1fc4
	pc = 0x829C1FC4; continue 'dispatch;
	// 829C1FB0: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 829C1FB4: 48000010  b 0x829c1fc4
	pc = 0x829C1FC4; continue 'dispatch;
	// 829C1FB8: EFE0FB3A  fmadds f31, f0, f12, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64);
	// 829C1FBC: 48000008  b 0x829c1fc4
	pc = 0x829C1FC4; continue 'dispatch;
	// 829C1FC0: EFE0FFBA  fmadds f31, f0, f30, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 829C1FC4: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C1FC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C1FCC: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C1FD0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829C1FD4: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 829C1FD8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C1FDC: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C1FE0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C1FE4: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C1FE8: 4BFFFCB9  bl 0x829c1ca0
	ctx.lr = 0x829C1FEC;
	sub_829C1CA0(ctx, base);
	// 829C1FEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829C1FF0: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C1FF4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829C1FF8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829C1FFC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 829C2000: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829C2004: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 829C2008: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C2130 size=304
    let mut pc: u32 = 0x829C2130;
    'dispatch: loop {
        match pc {
            0x829C2130 => {
    //   block [0x829C2130..0x829C2260)
	// 829C2130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2134: 487E6035  bl 0x831a8168
	ctx.lr = 0x829C2138;
	sub_831A8130(ctx, base);
	// 829C2138: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829C213C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C2140: 487924C1  bl 0x83154600
	ctx.lr = 0x829C2144;
	sub_83154600(ctx, base);
	// 829C2144: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 829C2148: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 829C214C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 829C2150: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 829C2154: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829C2158: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 829C215C: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 829C2160: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 829C2164: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829C2168: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 829C216C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 829C2170: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 829C2174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C2178: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 829C217C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 829C2180: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 829C2184: 39200012  li r9, 0x12
	ctx.r[9].s64 = 18;
	// 829C2188: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C218C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 829C2190: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 829C2194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C2198: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C219C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829C21A0: 3BAB2038  addi r29, r11, 0x2038
	ctx.r[29].s64 = ctx.r[11].s64 + 8248;
	// 829C21A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829C21A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C21AC: 4843185D  bl 0x82df3a08
	ctx.lr = 0x829C21B0;
	sub_82DF3A08(ctx, base);
	// 829C21B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C21B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C21B8: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C21BC: 481F0A0D  bl 0x82bb2bc8
	ctx.lr = 0x829C21C0;
	sub_82BB2BC8(ctx, base);
	// 829C21C0: 7FE40734  extsh r4, r31
	ctx.r[4].s64 = ctx.r[31].s16 as i64;
	// 829C21C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C21C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829C21CC: 481F752D  bl 0x82bb96f8
	ctx.lr = 0x829C21D0;
	sub_82BB96F8(ctx, base);
	// 829C21D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C21D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C21D8: 419A0008  beq cr6, 0x829c21e0
	if ctx.cr[6].eq {
	pc = 0x829C21E0; continue 'dispatch;
	}
	// 829C21DC: 4B8FE6B5  bl 0x822c0890
	ctx.lr = 0x829C21E0;
	sub_822C0890(ctx, base);
	// 829C21E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C21E4: 48431245  bl 0x82df3428
	ctx.lr = 0x829C21E8;
	sub_82DF3428(ctx, base);
	// 829C21E8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 829C21EC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 829C21F0: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C21F4: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C21F8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829C21FC: 4098FFA8  bge cr6, 0x829c21a4
	if !ctx.cr[6].lt {
	pc = 0x829C21A4; continue 'dispatch;
	}
	// 829C2200: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829C2204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C2208: 48431801  bl 0x82df3a08
	ctx.lr = 0x829C220C;
	sub_82DF3A08(ctx, base);
	// 829C220C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C2210: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C2214: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C2218: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C221C: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C2220: 481F0A99  bl 0x82bb2cb8
	ctx.lr = 0x829C2224;
	sub_82BB2CB8(ctx, base);
	// 829C2224: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829C2228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C222C: 419A0008  beq cr6, 0x829c2234
	if ctx.cr[6].eq {
	pc = 0x829C2234; continue 'dispatch;
	}
	// 829C2230: 4B8FE661  bl 0x822c0890
	ctx.lr = 0x829C2234;
	sub_822C0890(ctx, base);
	// 829C2234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C2238: 484311F1  bl 0x82df3428
	ctx.lr = 0x829C223C;
	sub_82DF3428(ctx, base);
	// 829C223C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C2240: 807E02E4  lwz r3, 0x2e4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(740 as u32) ) } as u64;
	// 829C2244: 484BF4FD  bl 0x82e81740
	ctx.lr = 0x829C2248;
	sub_82E81740(ctx, base);
	// 829C2248: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C224C: 807E02EC  lwz r3, 0x2ec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(748 as u32) ) } as u64;
	// 829C2250: 484BF4F1  bl 0x82e81740
	ctx.lr = 0x829C2254;
	sub_82E81740(ctx, base);
	// 829C2254: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829C2258: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829C225C: 487E5F5C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C2260 size=172
    let mut pc: u32 = 0x829C2260;
    'dispatch: loop {
        match pc {
            0x829C2260 => {
    //   block [0x829C2260..0x829C230C)
	// 829C2260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C2268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C226C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C2270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C2274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C2278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C227C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C2280: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C2284: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C2288: 4B8FE6B1  bl 0x822c0938
	ctx.lr = 0x829C228C;
	sub_822C0938(ctx, base);
	// 829C228C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C2290: 41820028  beq 0x829c22b8
	if ctx.cr[0].eq {
	pc = 0x829C22B8; continue 'dispatch;
	}
	// 829C2294: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C2298: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C229C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C22A0: 392B30C4  addi r9, r11, 0x30c4
	ctx.r[9].s64 = ctx.r[11].s64 + 12484;
	// 829C22A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C22A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C22AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C22B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C22B4: 48000008  b 0x829c22bc
	pc = 0x829C22BC; continue 'dispatch;
	// 829C22B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C22BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C22C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C22C4: 409A002C  bne cr6, 0x829c22f0
	if !ctx.cr[6].eq {
	pc = 0x829C22F0; continue 'dispatch;
	}
	// 829C22C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C22CC: 4B8FDF9D  bl 0x822c0268
	ctx.lr = 0x829C22D0;
	sub_822C0268(ctx, base);
	// 829C22D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C22D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C22D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C22DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C22E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C22E4: 816BA5F0  lwz r11, -0x5a10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23056 as u32) ) } as u64;
	// 829C22E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C22EC: 4B8FDD15  bl 0x822c0000
	ctx.lr = 0x829C22F0;
	sub_822C0000(ctx, base);
	// 829C22F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C22F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C22F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C22FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C2300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C2304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C2308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C2310 size=320
    let mut pc: u32 = 0x829C2310;
    'dispatch: loop {
        match pc {
            0x829C2310 => {
    //   block [0x829C2310..0x829C2450)
	// 829C2310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2314: 487E5E55  bl 0x831a8168
	ctx.lr = 0x829C2318;
	sub_831A8130(ctx, base);
	// 829C2318: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C231C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C2320: 487922E1  bl 0x83154600
	ctx.lr = 0x829C2324;
	sub_83154600(ctx, base);
	// 829C2324: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C2328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C232C: 4BFFC1A5  bl 0x829be4d0
	ctx.lr = 0x829C2330;
	sub_829BE4D0(ctx, base);
	// 829C2330: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C2334: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C2338: 388B30F0  addi r4, r11, 0x30f0
	ctx.r[4].s64 = ctx.r[11].s64 + 12528;
	// 829C233C: 38A00174  li r5, 0x174
	ctx.r[5].s64 = 372;
	// 829C2340: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829C2344: 4B8FE095  bl 0x822c03d8
	ctx.lr = 0x829C2348;
	sub_822C03D8(ctx, base);
	// 829C2348: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829C234C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C2350: 41820010  beq 0x829c2360
	if ctx.cr[0].eq {
	pc = 0x829C2360; continue 'dispatch;
	}
	// 829C2354: 4BFFF8A5  bl 0x829c1bf8
	ctx.lr = 0x829C2358;
	sub_829C1BF8(ctx, base);
	// 829C2358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C235C: 48000008  b 0x829c2364
	pc = 0x829C2364; continue 'dispatch;
	// 829C2360: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 829C2364: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C2368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C236C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C2370: 4BFFFEF1  bl 0x829c2260
	ctx.lr = 0x829C2374;
	sub_829C2260(ctx, base);
	// 829C2374: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C2378: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C237C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C2380: 4B8FDC81  bl 0x822c0000
	ctx.lr = 0x829C2384;
	sub_822C0000(ctx, base);
	// 829C2384: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C2388: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C238C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C2390: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C2394: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C2398: 419A0024  beq cr6, 0x829c23bc
	if ctx.cr[6].eq {
	pc = 0x829C23BC; continue 'dispatch;
	}
	// 829C239C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C23A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C23A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C23A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C23AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C23B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C23B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C23B8: 4082FFE8  bne 0x829c23a0
	if !ctx.cr[0].eq {
	pc = 0x829C23A0; continue 'dispatch;
	}
	// 829C23BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C23C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C23C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C23C8: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C23CC: 4BFE2C95  bl 0x829a5060
	ctx.lr = 0x829C23D0;
	sub_829A5060(ctx, base);
	// 829C23D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C23D4: 419A000C  beq cr6, 0x829c23e0
	if ctx.cr[6].eq {
	pc = 0x829C23E0; continue 'dispatch;
	}
	// 829C23D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C23DC: 4B8FE4B5  bl 0x822c0890
	ctx.lr = 0x829C23E0;
	sub_822C0890(ctx, base);
	// 829C23E0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C23E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C23E8: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C23EC: 4843161D  bl 0x82df3a08
	ctx.lr = 0x829C23F0;
	sub_82DF3A08(ctx, base);
	// 829C23F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C23F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C23F8: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C23FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C2400: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C2404: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C2408: 481F0F71  bl 0x82bb3378
	ctx.lr = 0x829C240C;
	sub_82BB3378(ctx, base);
	// 829C240C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829C2410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C2414: 419A0008  beq cr6, 0x829c241c
	if ctx.cr[6].eq {
	pc = 0x829C241C; continue 'dispatch;
	}
	// 829C2418: 4B8FE479  bl 0x822c0890
	ctx.lr = 0x829C241C;
	sub_822C0890(ctx, base);
	// 829C241C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C2420: 48431009  bl 0x82df3428
	ctx.lr = 0x829C2424;
	sub_82DF3428(ctx, base);
	// 829C2424: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C2428: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C242C: 9B9E0194  stb r28, 0x194(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(404 as u32), ctx.r[28].u8 ) };
	// 829C2430: 9B9E0195  stb r28, 0x195(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(405 as u32), ctx.r[28].u8 ) };
	// 829C2434: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2438: D01E0198  stfs f0, 0x198(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829C243C: C00AA5EC  lfs f0, -0x5a14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2440: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C2444: D01E0190  stfs f0, 0x190(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C2448: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829C244C: 487E5D6C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C2450 size=2288
    let mut pc: u32 = 0x829C2450;
    'dispatch: loop {
        match pc {
            0x829C2450 => {
    //   block [0x829C2450..0x829C2D40)
	// 829C2450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2454: 487E5CE5  bl 0x831a8138
	ctx.lr = 0x829C2458;
	sub_831A8130(ctx, base);
	// 829C2458: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 829C245C: 487E6605  bl 0x831a8a60
	ctx.lr = 0x829C2460;
	sub_831A8A40(ctx, base);
	// 829C2460: 3980FF10  li r12, -0xf0
	ctx.r[12].s64 = -240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C2D40 size=60
    let mut pc: u32 = 0x829C2D40;
    'dispatch: loop {
        match pc {
            0x829C2D40 => {
    //   block [0x829C2D40..0x829C2D7C)
	// 829C2D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C2D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C2D4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C2D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C2D54: 4BFFF0C5  bl 0x829c1e18
	ctx.lr = 0x829C2D58;
	sub_829C1E18(ctx, base);
	// 829C2D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C2D5C: 4B8FD2A5  bl 0x822c0000
	ctx.lr = 0x829C2D60;
	sub_822C0000(ctx, base);
	// 829C2D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C2D64: 4BFFF6ED  bl 0x829c2450
	ctx.lr = 0x829C2D68;
	sub_829C2450(ctx, base);
	// 829C2D68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C2D6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C2D70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C2D74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C2D78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C2D80 size=112
    let mut pc: u32 = 0x829C2D80;
    'dispatch: loop {
        match pc {
            0x829C2D80 => {
    //   block [0x829C2D80..0x829C2DF0)
	// 829C2D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C2D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C2D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C2D90: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C2D94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C2D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C2D9C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829C2DA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829C2DA4: 4BFE028D  bl 0x829a3030
	ctx.lr = 0x829C2DA8;
	sub_829A3030(ctx, base);
	// 829C2DA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2DAC: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829C2DB0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C2DB4: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 829C2DB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829C2DBC: 394A3144  addi r10, r10, 0x3144
	ctx.r[10].s64 = ctx.r[10].s64 + 12612;
	// 829C2DC0: 993F001C  stb r9, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 829C2DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C2DC8: C00BA680  lfs f0, -0x5980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2DCC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829C2DD0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C2DD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C2DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C2DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C2DE0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829C2DE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C2DE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C2DEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2DF0 size=64
    let mut pc: u32 = 0x829C2DF0;
    'dispatch: loop {
        match pc {
            0x829C2DF0 => {
    //   block [0x829C2DF0..0x829C2E30)
	// 829C2DF0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C2DF4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C2DF8: 41980130  blt cr6, 0x829c2f28
	if ctx.cr[6].lt {
		sub_829C2F28(ctx, base);
		return;
	}
	// 829C2DFC: 419A0120  beq cr6, 0x829c2f1c
	if ctx.cr[6].eq {
		sub_829C2F1C(ctx, base);
		return;
	}
	// 829C2E00: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C2E04: 419800C8  blt cr6, 0x829c2ecc
	if ctx.cr[6].lt {
		sub_829C2ECC(ctx, base);
		return;
	}
	// 829C2E08: 419A009C  beq cr6, 0x829c2ea4
	if ctx.cr[6].eq {
		sub_829C2EA4(ctx, base);
		return;
	}
	// 829C2E0C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C2E10: 4198005C  blt cr6, 0x829c2e6c
	if ctx.cr[6].lt {
		sub_829C2E6C(ctx, base);
		return;
	}
	// 829C2E14: 419A001C  beq cr6, 0x829c2e30
	if ctx.cr[6].eq {
		sub_829C2E30(ctx, base);
		return;
	}
	// 829C2E18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C2E1C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2E20: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C2E24: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C2E28: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C2E2C: 48000124  b 0x829c2f50
	sub_829C2F28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2E30 size=44
    let mut pc: u32 = 0x829C2E30;
    'dispatch: loop {
        match pc {
            0x829C2E30 => {
    //   block [0x829C2E30..0x829C2E5C)
	// 829C2E30: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C2E34: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829C2E38: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2E3C: 40980020  bge cr6, 0x829c2e5c
	if !ctx.cr[6].lt {
		sub_829C2E5C(ctx, base);
		return;
	}
	// 829C2E40: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2E44: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C2E48: 392BA694  addi r9, r11, -0x596c
	ctx.r[9].s64 = ctx.r[11].s64 + -22892;
	// 829C2E4C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C2E50: C00BA694  lfs f0, -0x596c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22892 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2E54: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C2E58: 480000E8  b 0x829c2f40
	sub_829C2F28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2E5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2E5C size=16
    let mut pc: u32 = 0x829C2E5C;
    'dispatch: loop {
        match pc {
            0x829C2E5C => {
    //   block [0x829C2E5C..0x829C2E6C)
	// 829C2E5C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829C2E60: 396BA694  addi r11, r11, -0x596c
	ctx.r[11].s64 = ctx.r[11].s64 + -22892;
	// 829C2E64: C00A2514  lfs f0, 0x2514(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2E68: 48000088  b 0x829c2ef0
	sub_829C2EE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2E6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2E6C size=44
    let mut pc: u32 = 0x829C2E6C;
    'dispatch: loop {
        match pc {
            0x829C2E6C => {
    //   block [0x829C2E6C..0x829C2E98)
	// 829C2E6C: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C2E70: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829C2E74: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2E78: 396BA694  addi r11, r11, -0x596c
	ctx.r[11].s64 = ctx.r[11].s64 + -22892;
	// 829C2E7C: 4098001C  bge cr6, 0x829c2e98
	if !ctx.cr[6].lt {
		sub_829C2E98(ctx, base);
		return;
	}
	// 829C2E80: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2E84: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C2E88: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C2E8C: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2E90: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C2E94: 480000AC  b 0x829c2f40
	sub_829C2F28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2E98 size=12
    let mut pc: u32 = 0x829C2E98;
    'dispatch: loop {
        match pc {
            0x829C2E98 => {
    //   block [0x829C2E98..0x829C2EA4)
	// 829C2E98: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C2E9C: C00A2960  lfs f0, 0x2960(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2EA0: 48000050  b 0x829c2ef0
	sub_829C2EE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2EA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2EA4 size=24
    let mut pc: u32 = 0x829C2EA4;
    'dispatch: loop {
        match pc {
            0x829C2EA4 => {
    //   block [0x829C2EA4..0x829C2EBC)
	// 829C2EA4: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C2EA8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829C2EAC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2EB0: 4098000C  bge cr6, 0x829c2ebc
	if !ctx.cr[6].lt {
		sub_829C2EBC(ctx, base);
		return;
	}
	// 829C2EB4: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2EB8: 4BFFFF90  b 0x829c2e48
	sub_829C2E30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2EBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2EBC size=16
    let mut pc: u32 = 0x829C2EBC;
    'dispatch: loop {
        match pc {
            0x829C2EBC => {
    //   block [0x829C2EBC..0x829C2ECC)
	// 829C2EBC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C2EC0: 396BA694  addi r11, r11, -0x596c
	ctx.r[11].s64 = ctx.r[11].s64 + -22892;
	// 829C2EC4: C00AA1C4  lfs f0, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2EC8: 48000028  b 0x829c2ef0
	sub_829C2EE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2ECC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2ECC size=28
    let mut pc: u32 = 0x829C2ECC;
    'dispatch: loop {
        match pc {
            0x829C2ECC => {
    //   block [0x829C2ECC..0x829C2EE8)
	// 829C2ECC: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C2ED0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829C2ED4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2ED8: 396BA694  addi r11, r11, -0x596c
	ctx.r[11].s64 = ctx.r[11].s64 + -22892;
	// 829C2EDC: 4098000C  bge cr6, 0x829c2ee8
	if !ctx.cr[6].lt {
		sub_829C2EE8(ctx, base);
		return;
	}
	// 829C2EE0: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2EE4: 4BFFFFA4  b 0x829c2e88
	sub_829C2E6C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2EE8 size=52
    let mut pc: u32 = 0x829C2EE8;
    'dispatch: loop {
        match pc {
            0x829C2EE8 => {
    //   block [0x829C2EE8..0x829C2F1C)
	// 829C2EE8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C2EEC: C00A9524  lfs f0, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2EF0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829C2EF4: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C2EF8: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C2EFC: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C2F00: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2F04: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C2F08: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C2F0C: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C2F10: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C2F14: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C2F18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2F1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2F1C size=12
    let mut pc: u32 = 0x829C2F1C;
    'dispatch: loop {
        match pc {
            0x829C2F1C => {
    //   block [0x829C2F1C..0x829C2F28)
	// 829C2F1C: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2F20: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C2F24: 48000008  b 0x829c2f2c
	sub_829C2F28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C2F28 size=48
    let mut pc: u32 = 0x829C2F28;
    'dispatch: loop {
        match pc {
            0x829C2F28 => {
    //   block [0x829C2F28..0x829C2F58)
	// 829C2F28: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2F2C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2F30: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C2F34: 396BA694  addi r11, r11, -0x596c
	ctx.r[11].s64 = ctx.r[11].s64 + -22892;
	// 829C2F38: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C2F3C: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2F40: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C2F44: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C2F48: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C2F4C: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C2F50: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C2F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C2F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C2F58 size=616
    let mut pc: u32 = 0x829C2F58;
    'dispatch: loop {
        match pc {
            0x829C2F58 => {
    //   block [0x829C2F58..0x829C31C0)
	// 829C2F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C2F5C: 487E5211  bl 0x831a816c
	ctx.lr = 0x829C2F60;
	sub_831A8130(ctx, base);
	// 829C2F60: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829C2F64: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C2F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C2F6C: 48791695  bl 0x83154600
	ctx.lr = 0x829C2F70;
	sub_83154600(ctx, base);
	// 829C2F70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C2F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C2F78: 4BFFB8D9  bl 0x829be850
	ctx.lr = 0x829C2F7C;
	sub_829BE850(ctx, base);
	// 829C2F7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C2F80: 484967F9  bl 0x82e59778
	ctx.lr = 0x829C2F84;
	sub_82E59778(ctx, base);
	// 829C2F84: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 829C2F88: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C2F8C: C01F01B4  lfs f0, 0x1b4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C2F90: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829C2F94: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C2F98: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 829C2F9C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C2FA0: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C2FA4: 41980150  blt cr6, 0x829c30f4
	if ctx.cr[6].lt {
	pc = 0x829C30F4; continue 'dispatch;
	}
	// 829C2FA8: 419A00AC  beq cr6, 0x829c3054
	if ctx.cr[6].eq {
	pc = 0x829C3054; continue 'dispatch;
	}
	// 829C2FAC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C2FB0: 40980178  bge cr6, 0x829c3128
	if !ctx.cr[6].lt {
	pc = 0x829C3128; continue 'dispatch;
	}
	// 829C2FB4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C2FB8: C1ABA6D4  lfs f13, -0x592c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C2FBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829C2FC0: 41980168  blt cr6, 0x829c3128
	if ctx.cr[6].lt {
	pc = 0x829C3128; continue 'dispatch;
	}
	// 829C2FC4: 817F01D0  lwz r11, 0x1d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 829C2FC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C2FCC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829C2FD0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C2FD4: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 829C2FD8: 995F01B0  stb r10, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[10].u8 ) };
	// 829C2FDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C2FE0: 992B001C  stb r9, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 829C2FE4: 4BB27AA5  bl 0x824eaa88
	ctx.lr = 0x829C2FE8;
	sub_824EAA88(ctx, base);
	// 829C2FE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C2FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C2FF0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C2FF4: 4BB4C3D5  bl 0x8250f3c8
	ctx.lr = 0x829C2FF8;
	sub_8250F3C8(ctx, base);
	// 829C2FF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C2FFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C3000: 4BB28011  bl 0x824eb010
	ctx.lr = 0x829C3004;
	sub_824EB010(ctx, base);
	// 829C3004: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C3008: 895F01B8  lbz r10, 0x1b8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 829C300C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C3010: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 829C3014: C00B2960  lfs f0, 0x2960(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3018: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C301C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C3020: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829C3024: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C3028: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829C302C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829C3030: 997F01B8  stb r11, 0x1b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u8 ) };
	// 829C3034: 4842EC5D  bl 0x82df1c90
	ctx.lr = 0x829C3038;
	sub_82DF1C90(ctx, base);
	// 829C3038: 897F01B8  lbz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 829C303C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829C3040: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829C3044: 419800D4  blt cr6, 0x829c3118
	if ctx.cr[6].lt {
	pc = 0x829C3118; continue 'dispatch;
	}
	// 829C3048: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 829C304C: 997F01B8  stb r11, 0x1b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u8 ) };
	// 829C3050: 480000C8  b 0x829c3118
	pc = 0x829C3118; continue 'dispatch;
	// 829C3054: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3058: 3BABA6D4  addi r29, r11, -0x592c
	ctx.r[29].s64 = ctx.r[11].s64 + -22828;
	// 829C305C: C1BDFFFC  lfs f13, -4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3060: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C3064: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829C3068: 40990008  ble cr6, 0x829c3070
	if !ctx.cr[6].gt {
	pc = 0x829C3070; continue 'dispatch;
	}
	// 829C306C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829C3070: 897F01B8  lbz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 829C3074: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C3078: C1BE0444  lfs f13, 0x444(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C307C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829C3080: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829C3084: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 829C3088: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829C308C: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829C3090: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829C3094: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3098: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829C309C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C30A0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C30A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829C30A8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C30AC: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C30B0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C30B4: 484BA58D  bl 0x82e7d640
	ctx.lr = 0x829C30B8;
	sub_82E7D640(ctx, base);
	// 829C30B8: 39600420  li r11, 0x420
	ctx.r[11].s64 = 1056;
	// 829C30BC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C30C0: C1BDFFFC  lfs f13, -4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C31C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C31C0 size=172
    let mut pc: u32 = 0x829C31C0;
    'dispatch: loop {
        match pc {
            0x829C31C0 => {
    //   block [0x829C31C0..0x829C326C)
	// 829C31C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C31C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C31C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C31CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C31D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C31D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C31D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C31DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C31E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C31E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C31E8: 4B8FD751  bl 0x822c0938
	ctx.lr = 0x829C31EC;
	sub_822C0938(ctx, base);
	// 829C31EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C31F0: 41820028  beq 0x829c3218
	if ctx.cr[0].eq {
	pc = 0x829C3218; continue 'dispatch;
	}
	// 829C31F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C31F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C31FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C3200: 392B315C  addi r9, r11, 0x315c
	ctx.r[9].s64 = ctx.r[11].s64 + 12636;
	// 829C3204: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C3208: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C320C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C3210: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C3214: 48000008  b 0x829c321c
	pc = 0x829C321C; continue 'dispatch;
	// 829C3218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C321C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C3220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C3224: 409A002C  bne cr6, 0x829c3250
	if !ctx.cr[6].eq {
	pc = 0x829C3250; continue 'dispatch;
	}
	// 829C3228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C322C: 4B8FD03D  bl 0x822c0268
	ctx.lr = 0x829C3230;
	sub_822C0268(ctx, base);
	// 829C3230: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3234: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C3238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C323C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C3240: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C3244: 816BA6E0  lwz r11, -0x5920(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22816 as u32) ) } as u64;
	// 829C3248: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C324C: 4B8FCDB5  bl 0x822c0000
	ctx.lr = 0x829C3250;
	sub_822C0000(ctx, base);
	// 829C3250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C3254: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C3258: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C325C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C3260: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C3264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C3268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C3270 size=172
    let mut pc: u32 = 0x829C3270;
    'dispatch: loop {
        match pc {
            0x829C3270 => {
    //   block [0x829C3270..0x829C331C)
	// 829C3270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C3274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C3278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C327C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C3280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C3284: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C3288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C328C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C3290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C3294: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C3298: 4B8FD6A1  bl 0x822c0938
	ctx.lr = 0x829C329C;
	sub_822C0938(ctx, base);
	// 829C329C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C32A0: 41820028  beq 0x829c32c8
	if ctx.cr[0].eq {
	pc = 0x829C32C8; continue 'dispatch;
	}
	// 829C32A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C32A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C32AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C32B0: 392B3170  addi r9, r11, 0x3170
	ctx.r[9].s64 = ctx.r[11].s64 + 12656;
	// 829C32B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C32B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C32BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C32C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C32C4: 48000008  b 0x829c32cc
	pc = 0x829C32CC; continue 'dispatch;
	// 829C32C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C32CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C32D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C32D4: 409A002C  bne cr6, 0x829c3300
	if !ctx.cr[6].eq {
	pc = 0x829C3300; continue 'dispatch;
	}
	// 829C32D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C32DC: 4B8FCF8D  bl 0x822c0268
	ctx.lr = 0x829C32E0;
	sub_822C0268(ctx, base);
	// 829C32E0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C32E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C32E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C32EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C32F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C32F4: 816BA6E0  lwz r11, -0x5920(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22816 as u32) ) } as u64;
	// 829C32F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C32FC: 4B8FCD05  bl 0x822c0000
	ctx.lr = 0x829C3300;
	sub_822C0000(ctx, base);
	// 829C3300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C3304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C3308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C330C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C3310: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C3314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C3318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C3320 size=1932
    let mut pc: u32 = 0x829C3320;
    'dispatch: loop {
        match pc {
            0x829C3320 => {
    //   block [0x829C3320..0x829C3AAC)
	// 829C3320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C3324: 487E4E15  bl 0x831a8138
	ctx.lr = 0x829C3328;
	sub_831A8130(ctx, base);
	// 829C3328: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 829C332C: 487E5735  bl 0x831a8a60
	ctx.lr = 0x829C3330;
	sub_831A8A40(ctx, base);
	// 829C3330: 3980FF10  li r12, -0xf0
	ctx.r[12].s64 = -240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C3AB0 size=60
    let mut pc: u32 = 0x829C3AB0;
    'dispatch: loop {
        match pc {
            0x829C3AB0 => {
    //   block [0x829C3AB0..0x829C3AEC)
	// 829C3AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C3AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C3AB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C3ABC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C3AC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C3AC4: 4BFFF495  bl 0x829c2f58
	ctx.lr = 0x829C3AC8;
	sub_829C2F58(ctx, base);
	// 829C3AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C3ACC: 4B8FC535  bl 0x822c0000
	ctx.lr = 0x829C3AD0;
	sub_822C0000(ctx, base);
	// 829C3AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C3AD4: 4BFFF84D  bl 0x829c3320
	ctx.lr = 0x829C3AD8;
	sub_829C3320(ctx, base);
	// 829C3AD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C3ADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C3AE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C3AE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C3AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C3AF0 size=612
    let mut pc: u32 = 0x829C3AF0;
    'dispatch: loop {
        match pc {
            0x829C3AF0 => {
    //   block [0x829C3AF0..0x829C3D54)
	// 829C3AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C3AF4: 487E466D  bl 0x831a8160
	ctx.lr = 0x829C3AF8;
	sub_831A8130(ctx, base);
	// 829C3AF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C3AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C3B00: 48790B01  bl 0x83154600
	ctx.lr = 0x829C3B04;
	sub_83154600(ctx, base);
	// 829C3B04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C3B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C3B0C: 4BFFA9C5  bl 0x829be4d0
	ctx.lr = 0x829C3B10;
	sub_829BE4D0(ctx, base);
	// 829C3B10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C3B14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C3B18: 3B4B3180  addi r26, r11, 0x3180
	ctx.r[26].s64 = ctx.r[11].s64 + 12672;
	// 829C3B1C: 38A00293  li r5, 0x293
	ctx.r[5].s64 = 659;
	// 829C3B20: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829C3B24: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 829C3B28: 4B8FC8B1  bl 0x822c03d8
	ctx.lr = 0x829C3B2C;
	sub_822C03D8(ctx, base);
	// 829C3B2C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829C3B30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C3B34: 41820018  beq 0x829c3b4c
	if ctx.cr[0].eq {
	pc = 0x829C3B4C; continue 'dispatch;
	}
	// 829C3B38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C3B3C: C03D0444  lfs f1, 0x444(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C3B40: 4BFFF241  bl 0x829c2d80
	ctx.lr = 0x829C3B44;
	sub_829C2D80(ctx, base);
	// 829C3B44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C3B48: 48000008  b 0x829c3b50
	pc = 0x829C3B50; continue 'dispatch;
	// 829C3B4C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829C3B50: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829C3B54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829C3B58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C3B5C: 4BFFF665  bl 0x829c31c0
	ctx.lr = 0x829C3B60;
	sub_829C31C0(ctx, base);
	// 829C3B60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C3B64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829C3B68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C3B6C: 4B8FC495  bl 0x822c0000
	ctx.lr = 0x829C3B70;
	sub_822C0000(ctx, base);
	// 829C3B70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C3B74: 3BDF01D0  addi r30, r31, 0x1d0
	ctx.r[30].s64 = ctx.r[31].s64 + 464;
	// 829C3B78: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829C3B7C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829C3B80: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 829C3B84: 4B9008DD  bl 0x822c4460
	ctx.lr = 0x829C3B88;
	sub_822C4460(ctx, base);
	// 829C3B88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C3B8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C3B90: 419A0008  beq cr6, 0x829c3b98
	if ctx.cr[6].eq {
	pc = 0x829C3B98; continue 'dispatch;
	}
	// 829C3B94: 4B8FCCFD  bl 0x822c0890
	ctx.lr = 0x829C3B98;
	sub_822C0890(ctx, base);
	// 829C3B98: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C3B9C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C3BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C3BA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C3BA8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C3BAC: 419A0024  beq cr6, 0x829c3bd0
	if ctx.cr[6].eq {
	pc = 0x829C3BD0; continue 'dispatch;
	}
	// 829C3BB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829C3BB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C3BB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C3BBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C3BC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C3BC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C3BC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C3BCC: 4082FFE8  bne 0x829c3bb4
	if !ctx.cr[0].eq {
	pc = 0x829C3BB4; continue 'dispatch;
	}
	// 829C3BD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C3BD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C3BD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C3BDC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C3BE0: 4BFE1481  bl 0x829a5060
	ctx.lr = 0x829C3BE4;
	sub_829A5060(ctx, base);
	// 829C3BE4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C3BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C3BEC: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C3BF0: 4842FE19  bl 0x82df3a08
	ctx.lr = 0x829C3BF4;
	sub_82DF3A08(ctx, base);
	// 829C3BF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C3BF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C3BFC: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C3C00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C3C04: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C3C08: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C3C0C: 481EF76D  bl 0x82bb3378
	ctx.lr = 0x829C3C10;
	sub_82BB3378(ctx, base);
	// 829C3C10: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C3C14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C3C18: 419A0008  beq cr6, 0x829c3c20
	if ctx.cr[6].eq {
	pc = 0x829C3C20; continue 'dispatch;
	}
	// 829C3C1C: 4B8FCC75  bl 0x822c0890
	ctx.lr = 0x829C3C20;
	sub_822C0890(ctx, base);
	// 829C3C20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C3C24: 4842F805  bl 0x82df3428
	ctx.lr = 0x829C3C28;
	sub_82DF3428(ctx, base);
	// 829C3C28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C3C2C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C3C30: 9B7F0194  stb r27, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[27].u8 ) };
	// 829C3C34: 9B7F01B0  stb r27, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[27].u8 ) };
	// 829C3C38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C3C3C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3C40: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829C3C44: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 829C3C48: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 829C3C4C: C00AA6D8  lfs f0, -0x5928(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3C50: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C3C54: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C3C58: 4BB26E31  bl 0x824eaa88
	ctx.lr = 0x829C3C5C;
	sub_824EAA88(ctx, base);
	// 829C3C5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C3C60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C3C64: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C3C68: 4BB4B761  bl 0x8250f3c8
	ctx.lr = 0x829C3C6C;
	sub_8250F3C8(ctx, base);
	// 829C3C6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C3C70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C3C74: 4BB2739D  bl 0x824eb010
	ctx.lr = 0x829C3C78;
	sub_824EB010(ctx, base);
	// 829C3C78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C3C7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C3C80: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3C84: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3C88: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C3C8C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829C3C90: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 829C3C94: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 829C3C98: 997F01B8  stb r11, 0x1b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u8 ) };
	// 829C3C9C: 4842DFF5  bl 0x82df1c90
	ctx.lr = 0x829C3CA0;
	sub_82DF1C90(ctx, base);
	// 829C3CA0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3CA4: 397D0420  addi r11, r29, 0x420
	ctx.r[11].s64 = ctx.r[29].s64 + 1056;
	// 829C3CA8: 392ABC40  addi r9, r10, -0x43c0
	ctx.r[9].s64 = ctx.r[10].s64 + -17344;
	// 829C3CAC: 390001C0  li r8, 0x1c0
	ctx.r[8].s64 = 448;
	// 829C3CB0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C3CB4: 3B9F01A0  addi r28, r31, 0x1a0
	ctx.r[28].s64 = ctx.r[31].s64 + 416;
	// 829C3CB8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C3CBC: 3BCAA6F0  addi r30, r10, -0x5910
	ctx.r[30].s64 = ctx.r[10].s64 + -22800;
	// 829C3CC0: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C3CC4: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C3D58 size=84
    let mut pc: u32 = 0x829C3D58;
    'dispatch: loop {
        match pc {
            0x829C3D58 => {
    //   block [0x829C3D58..0x829C3DAC)
	// 829C3D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C3D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C3D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C3D64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C3D68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C3D6C: 4BFDF2C5  bl 0x829a3030
	ctx.lr = 0x829C3D70;
	sub_829A3030(ctx, base);
	// 829C3D70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C3D74: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C3D78: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C3D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C3D80: 39293204  addi r9, r9, 0x3204
	ctx.r[9].s64 = ctx.r[9].s64 + 12804;
	// 829C3D84: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3D88: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829C3D8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C3D90: C00AAE60  lfs f0, -0x51a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20896 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3D94: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C3D98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C3D9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C3DA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C3DA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C3DA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C3DB0 size=20
    let mut pc: u32 = 0x829C3DB0;
    'dispatch: loop {
        match pc {
            0x829C3DB0 => {
    //   block [0x829C3DB0..0x829C3DC4)
	// 829C3DB0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3DB4: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3DB8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C3DBC: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829C3DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C3DC8 size=36
    let mut pc: u32 = 0x829C3DC8;
    'dispatch: loop {
        match pc {
            0x829C3DC8 => {
    //   block [0x829C3DC8..0x829C3DEC)
	// 829C3DC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C3DCC: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3DD0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3DD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C3DD8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829C3DDC: 40980008  bge cr6, 0x829c3de4
	if !ctx.cr[6].lt {
	pc = 0x829C3DE4; continue 'dispatch;
	}
	// 829C3DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C3DE4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C3DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C3DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C3DF0 size=636
    let mut pc: u32 = 0x829C3DF0;
    'dispatch: loop {
        match pc {
            0x829C3DF0 => {
    //   block [0x829C3DF0..0x829C406C)
	// 829C3DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C3DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C3DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C3DFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C3E00: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C3E04: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3E08: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C3E10: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C3E14: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C3E18: 41980210  blt cr6, 0x829c4028
	if ctx.cr[6].lt {
	pc = 0x829C4028; continue 'dispatch;
	}
	// 829C3E1C: 419A01D8  beq cr6, 0x829c3ff4
	if ctx.cr[6].eq {
	pc = 0x829C3FF4; continue 'dispatch;
	}
	// 829C3E20: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C3E24: 41980168  blt cr6, 0x829c3f8c
	if ctx.cr[6].lt {
	pc = 0x829C3F8C; continue 'dispatch;
	}
	// 829C3E28: 419A00FC  beq cr6, 0x829c3f24
	if ctx.cr[6].eq {
	pc = 0x829C3F24; continue 'dispatch;
	}
	// 829C3E2C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C3E30: 41980098  blt cr6, 0x829c3ec8
	if ctx.cr[6].lt {
	pc = 0x829C3EC8; continue 'dispatch;
	}
	// 829C3E34: 419A001C  beq cr6, 0x829c3e50
	if ctx.cr[6].eq {
	pc = 0x829C3E50; continue 'dispatch;
	}
	// 829C3E38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C3E3C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3E40: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C3E44: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C3E48: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C3E4C: 48000204  b 0x829c4050
	pc = 0x829C4050; continue 'dispatch;
	// 829C3E50: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829C3E54: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3E58: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3E5C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3E60: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3E64: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3E68: 487E5041  bl 0x831a8ea8
	ctx.lr = 0x829C3E6C;
	sub_831A8EA8(ctx, base);
	// 829C3E6C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3E70: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C3E74: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3E78: 392BAE70  addi r9, r11, -0x5190
	ctx.r[9].s64 = ctx.r[11].s64 + -20880;
	// 829C3E7C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C3E80: C00BAE70  lfs f0, -0x5190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3E84: FD200050  fneg f9, f0
	ctx.f[9].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C3E88: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3E8C: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3E90: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C3E94: ED0C0028  fsubs f8, f12, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C3E98: C168D5B8  lfs f11, -0x2a48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C3E9C: ED4A6B7C  fnmsubs f10, f10, f13, f13
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C3EA0: EC0A023A  fmadds f0, f10, f8, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C3EA4: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 829C3EA8: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829C3EAC: D13F0000  stfs f9, 0(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C3EB0: C18708A4  lfs f12, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C3EB4: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C3EB8: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3EBC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C3EC0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C3EC4: 48000190  b 0x829c4054
	pc = 0x829C4054; continue 'dispatch;
	// 829C3EC8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829C3ECC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3ED0: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3ED4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3ED8: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3EDC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3EE0: 487E4FC9  bl 0x831a8ea8
	ctx.lr = 0x829C3EE4;
	sub_831A8EA8(ctx, base);
	// 829C3EE4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3EE8: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C3EEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3EF0: 392BAE70  addi r9, r11, -0x5190
	ctx.r[9].s64 = ctx.r[11].s64 + -20880;
	// 829C3EF4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C3EF8: C00BAE70  lfs f0, -0x5190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3EFC: FD200050  fneg f9, f0
	ctx.f[9].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C3F00: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3F04: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3F08: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C3F0C: ED0C0028  fsubs f8, f12, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C3F10: C168D5B8  lfs f11, -0x2a48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C3F14: ED4A6B7C  fnmsubs f10, f10, f13, f13
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C3F18: EC0A023A  fmadds f0, f10, f8, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C3F1C: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 829C3F20: 4BFFFF88  b 0x829c3ea8
	pc = 0x829C3EA8; continue 'dispatch;
	// 829C3F24: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829C3F28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3F2C: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3F30: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3F34: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3F38: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3F3C: 487E4F6D  bl 0x831a8ea8
	ctx.lr = 0x829C3F40;
	sub_831A8EA8(ctx, base);
	// 829C3F40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3F44: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C3F48: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3F4C: 392BAE70  addi r9, r11, -0x5190
	ctx.r[9].s64 = ctx.r[11].s64 + -20880;
	// 829C3F50: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C3F54: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829C3F58: C18BAE70  lfs f12, -0x5190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C3F5C: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3F60: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3F64: C169000C  lfs f11, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C3F68: ED0B0028  fsubs f8, f11, f0
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C3F6C: C148D5B8  lfs f10, -0x2a48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C3F70: ED296B7C  fnmsubs f9, f9, f13, f13
	ctx.f[9].f64 = -(((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C3F74: C16708A4  lfs f11, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C3F78: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C3F7C: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C3F80: EC09023A  fmadds f0, f9, f8, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C3F84: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 829C3F88: 4BFFFF30  b 0x829c3eb8
	pc = 0x829C3EB8; continue 'dispatch;
	// 829C3F8C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829C3F90: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3F94: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3F98: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3F9C: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3FA0: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C3FA4: 487E4F05  bl 0x831a8ea8
	ctx.lr = 0x829C3FA8;
	sub_831A8EA8(ctx, base);
	// 829C3FA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3FAC: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C3FB0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C3FB4: 392BAE70  addi r9, r11, -0x5190
	ctx.r[9].s64 = ctx.r[11].s64 + -20880;
	// 829C3FB8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C3FBC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829C3FC0: C18BAE70  lfs f12, -0x5190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C3FC4: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C3FC8: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C3FCC: C169000C  lfs f11, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C3FD0: ED0B0028  fsubs f8, f11, f0
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C3FD4: C148D5B8  lfs f10, -0x2a48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C3FD8: ED296B7C  fnmsubs f9, f9, f13, f13
	ctx.f[9].f64 = -(((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C3FDC: C16708A4  lfs f11, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C3FE0: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C3FE4: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C3FE8: EC09023A  fmadds f0, f9, f8, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C3FEC: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 829C3FF0: 4BFFFEC8  b 0x829c3eb8
	pc = 0x829C3EB8; continue 'dispatch;
	// 829C3FF4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C3FF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C3FFC: 396BAE70  addi r11, r11, -0x5190
	ctx.r[11].s64 = ctx.r[11].s64 + -20880;
	// 829C4000: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4004: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4008: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C400C: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4010: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4014: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4018: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C401C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4020: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4024: 48000030  b 0x829c4054
	pc = 0x829C4054; continue 'dispatch;
	// 829C4028: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C402C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4030: 396BAE70  addi r11, r11, -0x5190
	ctx.r[11].s64 = ctx.r[11].s64 + -20880;
	// 829C4034: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C4038: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C403C: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4040: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4044: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C4048: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C404C: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4050: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C405C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C4060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C4064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C4068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4070 size=432
    let mut pc: u32 = 0x829C4070;
    'dispatch: loop {
        match pc {
            0x829C4070 => {
    //   block [0x829C4070..0x829C4220)
	// 829C4070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C407C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4080: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C4084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4088: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C408C: 41980144  blt cr6, 0x829c41d0
	if ctx.cr[6].lt {
	pc = 0x829C41D0; continue 'dispatch;
	}
	// 829C4090: 419A0118  beq cr6, 0x829c41a8
	if ctx.cr[6].eq {
	pc = 0x829C41A8; continue 'dispatch;
	}
	// 829C4094: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C4098: 419800E8  blt cr6, 0x829c4180
	if ctx.cr[6].lt {
	pc = 0x829C4180; continue 'dispatch;
	}
	// 829C409C: 419A00B4  beq cr6, 0x829c4150
	if ctx.cr[6].eq {
	pc = 0x829C4150; continue 'dispatch;
	}
	// 829C40A0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C40A4: 41980070  blt cr6, 0x829c4114
	if ctx.cr[6].lt {
	pc = 0x829C4114; continue 'dispatch;
	}
	// 829C40A8: 419A0030  beq cr6, 0x829c40d8
	if ctx.cr[6].eq {
	pc = 0x829C40D8; continue 'dispatch;
	}
	// 829C40AC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829C40B0: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829C40B4: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C40B8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C40BC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C40C0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C40C4: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C40C8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C40CC: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C40D0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C40D4: 48000138  b 0x829c420c
	pc = 0x829C420C; continue 'dispatch;
	// 829C40D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C40DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C40E0: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C40E4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C40E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C40EC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C40F0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C40F4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C40F8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C40FC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C4100: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C4104: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4108: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C410C: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C4110: 480000F4  b 0x829c4204
	pc = 0x829C4204; continue 'dispatch;
	// 829C4114: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4118: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C411C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C4120: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829C4124: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4128: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C412C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C4130: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4134: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C4138: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C413C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C4140: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C4144: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4148: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C414C: 480000B4  b 0x829c4200
	pc = 0x829C4200; continue 'dispatch;
	// 829C4150: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C4154: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4158: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829C415C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4160: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4164: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829C4168: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829C416C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829C4170: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829C4174: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C4178: C1A89530  lfs f13, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C417C: 4BFFFFC4  b 0x829c4140
	pc = 0x829C4140; continue 'dispatch;
	// 829C4180: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C4184: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4188: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829C418C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4190: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4194: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829C4198: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829C419C: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829C41A0: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829C41A4: 4BFFFFD0  b 0x829c4174
	pc = 0x829C4174; continue 'dispatch;
	// 829C41A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C41AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C41B0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829C41B4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C41B8: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C41BC: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829C41C0: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829C41C4: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829C41C8: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829C41CC: 48000028  b 0x829c41f4
	pc = 0x829C41F4; continue 'dispatch;
	// 829C41D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C41D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C41D8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 829C41DC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C41E0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C41E4: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829C41E8: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829C41EC: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829C41F0: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 829C41F4: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C41F8: C1A9DFAC  lfs f13, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C41FC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C4200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4204: 484B8A3D  bl 0x82e7cc40
	ctx.lr = 0x829C4208;
	sub_82E7CC40(ctx, base);
	// 829C4208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C420C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829C4210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C4214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C4218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C421C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C4220 size=172
    let mut pc: u32 = 0x829C4220;
    'dispatch: loop {
        match pc {
            0x829C4220 => {
    //   block [0x829C4220..0x829C42CC)
	// 829C4220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4228: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C422C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4234: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C4238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C423C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C4240: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C4244: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C4248: 4B8FC6F1  bl 0x822c0938
	ctx.lr = 0x829C424C;
	sub_822C0938(ctx, base);
	// 829C424C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C4250: 41820028  beq 0x829c4278
	if ctx.cr[0].eq {
	pc = 0x829C4278; continue 'dispatch;
	}
	// 829C4254: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C4258: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C425C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C4260: 392B321C  addi r9, r11, 0x321c
	ctx.r[9].s64 = ctx.r[11].s64 + 12828;
	// 829C4264: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C4268: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C426C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C4270: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C4274: 48000008  b 0x829c427c
	pc = 0x829C427C; continue 'dispatch;
	// 829C4278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C427C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C4280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C4284: 409A002C  bne cr6, 0x829c42b0
	if !ctx.cr[6].eq {
	pc = 0x829C42B0; continue 'dispatch;
	}
	// 829C4288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C428C: 4B8FBFDD  bl 0x822c0268
	ctx.lr = 0x829C4290;
	sub_822C0268(ctx, base);
	// 829C4290: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4294: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C429C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C42A0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C42A4: 816BAE94  lwz r11, -0x516c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20844 as u32) ) } as u64;
	// 829C42A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C42AC: 4B8FBD55  bl 0x822c0000
	ctx.lr = 0x829C42B0;
	sub_822C0000(ctx, base);
	// 829C42B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C42B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C42B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C42BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C42C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C42C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C42C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C42D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C42D0 size=360
    let mut pc: u32 = 0x829C42D0;
    'dispatch: loop {
        match pc {
            0x829C42D0 => {
    //   block [0x829C42D0..0x829C4438)
	// 829C42D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C42D4: 487E3E99  bl 0x831a816c
	ctx.lr = 0x829C42D8;
	sub_831A8130(ctx, base);
	// 829C42D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C42DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C42E0: 48790321  bl 0x83154600
	ctx.lr = 0x829C42E4;
	sub_83154600(ctx, base);
	// 829C42E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C42E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C42EC: 4BFFA1E5  bl 0x829be4d0
	ctx.lr = 0x829C42F0;
	sub_829BE4D0(ctx, base);
	// 829C42F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C42F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C42F8: 388B3230  addi r4, r11, 0x3230
	ctx.r[4].s64 = ctx.r[11].s64 + 12848;
	// 829C42FC: 38A000CA  li r5, 0xca
	ctx.r[5].s64 = 202;
	// 829C4300: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829C4304: 4B8FC0D5  bl 0x822c03d8
	ctx.lr = 0x829C4308;
	sub_822C03D8(ctx, base);
	// 829C4308: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C430C: 41820010  beq 0x829c431c
	if ctx.cr[0].eq {
	pc = 0x829C431C; continue 'dispatch;
	}
	// 829C4310: 4BFFFA49  bl 0x829c3d58
	ctx.lr = 0x829C4314;
	sub_829C3D58(ctx, base);
	// 829C4314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4318: 48000008  b 0x829c4320
	pc = 0x829C4320; continue 'dispatch;
	// 829C431C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829C4320: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C4324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C4328: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C432C: 4BFFFEF5  bl 0x829c4220
	ctx.lr = 0x829C4330;
	sub_829C4220(ctx, base);
	// 829C4330: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C4334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C4338: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C433C: 4B8FBCC5  bl 0x822c0000
	ctx.lr = 0x829C4340;
	sub_822C0000(ctx, base);
	// 829C4340: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C4344: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C4348: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C434C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C4350: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C4354: 419A0024  beq cr6, 0x829c4378
	if ctx.cr[6].eq {
	pc = 0x829C4378; continue 'dispatch;
	}
	// 829C4358: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C435C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C4360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C4364: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C4368: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C436C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C4370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C4374: 4082FFE8  bne 0x829c435c
	if !ctx.cr[0].eq {
	pc = 0x829C435C; continue 'dispatch;
	}
	// 829C4378: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C437C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C4380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C4384: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C4388: 4BFE0CD9  bl 0x829a5060
	ctx.lr = 0x829C438C;
	sub_829A5060(ctx, base);
	// 829C438C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C4390: 419A000C  beq cr6, 0x829c439c
	if ctx.cr[6].eq {
	pc = 0x829C439C; continue 'dispatch;
	}
	// 829C4394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4398: 4B8FC4F9  bl 0x822c0890
	ctx.lr = 0x829C439C;
	sub_822C0890(ctx, base);
	// 829C439C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C43A0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829C43A4: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 829C43A8: 39200420  li r9, 0x420
	ctx.r[9].s64 = 1056;
	// 829C43AC: 390ABA80  addi r8, r10, -0x4580
	ctx.r[8].s64 = ctx.r[10].s64 + -17792;
	// 829C43B0: 3CE08207  lis r7, -0x7df9
	ctx.r[7].s64 = -2113470464;
	// 829C43B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C43B8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C43BC: 3887D748  addi r4, r7, -0x28b8
	ctx.r[4].s64 = ctx.r[7].s64 + -10424;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4438 size=780
    let mut pc: u32 = 0x829C4438;
    'dispatch: loop {
        match pc {
            0x829C4438 => {
    //   block [0x829C4438..0x829C4744)
	// 829C4438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C443C: 487E3D09  bl 0x831a8144
	ctx.lr = 0x829C4440;
	sub_831A8130(ctx, base);
	// 829C4440: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 829C4444: 487E4631  bl 0x831a8a74
	ctx.lr = 0x829C4448;
	sub_831A8A40(ctx, base);
	// 829C4448: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C444C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4450: 487901B1  bl 0x83154600
	ctx.lr = 0x829C4454;
	sub_83154600(ctx, base);
	// 829C4454: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829C4458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C445C: 4849531D  bl 0x82e59778
	ctx.lr = 0x829C4460;
	sub_82E59778(ctx, base);
	// 829C4460: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4464: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C4468: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C446C: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C4470: 3BABAE8C  addi r29, r11, -0x5174
	ctx.r[29].s64 = ctx.r[11].s64 + -20852;
	// 829C4474: C01DFFF8  lfs f0, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4478: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829C447C: 419802B8  blt cr6, 0x829c4734
	if ctx.cr[6].lt {
	pc = 0x829C4734; continue 'dispatch;
	}
	// 829C4480: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829C4484: 891DFFF4  lbz r8, -0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) } as u64;
	// 829C4488: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 829C448C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C4490: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C4494: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C4498: C3A79450  lfs f29, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829C449C: 3F208338  lis r25, -0x7cc8
	ctx.r[25].s64 = -2093481984;
	// 829C44A0: C38608A4  lfs f28, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829C44A4: 3AEB27F0  addi r23, r11, 0x27f0
	ctx.r[23].s64 = ctx.r[11].s64 + 10224;
	// 829C44A8: 3ACA27E0  addi r22, r10, 0x27e0
	ctx.r[22].s64 = ctx.r[10].s64 + 10208;
	// 829C44AC: 3B093230  addi r24, r9, 0x3230
	ctx.r[24].s64 = ctx.r[9].s64 + 12848;
	// 829C44B0: C1BF0190  lfs f13, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C44B4: 7D0B0775  extsb. r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C44B8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829C44BC: C3DD0004  lfs f30, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829C44C0: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C44C4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829C44C8: 40810218  ble 0x829c46e0
	if !ctx.cr[0].gt {
	pc = 0x829C46E0; continue 'dispatch;
	}
	// 829C44CC: D3810094  stfs f28, 0x94(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829C44D0: D381009C  stfs f28, 0x9c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829C44D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829C44D8: C019D180  lfs f0, -0x2e80(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-11904 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C44DC: 7F6A07B4  extsw r10, r27
	ctx.r[10].s64 = ctx.r[27].s32 as i64;
	// 829C44E0: 893F0194  lbz r9, 0x194(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 829C44E4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829C44E8: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 829C44EC: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 829C44F0: 552B07FF  clrlwi. r11, r9, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C44F4: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 829C44F8: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829C44FC: C9810070  lfd f12, 0x70(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 829C4500: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 829C4504: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829C4508: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 829C450C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829C4510: EDAC6F7C  fnmsubs f13, f12, f29, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[29].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C4514: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C4518: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 829C451C: 4182000C  beq 0x829c4528
	if ctx.cr[0].eq {
	pc = 0x829C4528; continue 'dispatch;
	}
	// 829C4520: 13E0B0C7  vcmpequd (lvx128) v31, v0, v22
	tmp.u32 = ctx.r[22].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C4524: 48000008  b 0x829c452c
	pc = 0x829C452C; continue 'dispatch;
	// 829C4528: 13E0B8C7  vcmpequd (lvx128) v31, v0, v23
	tmp.u32 = ctx.r[23].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C4748 size=60
    let mut pc: u32 = 0x829C4748;
    'dispatch: loop {
        match pc {
            0x829C4748 => {
    //   block [0x829C4748..0x829C4784)
	// 829C4748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C474C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4754: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C475C: 4BFFD6BD  bl 0x829c1e18
	ctx.lr = 0x829C4760;
	sub_829C1E18(ctx, base);
	// 829C4760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4764: 4B8FB89D  bl 0x822c0000
	ctx.lr = 0x829C4768;
	sub_822C0000(ctx, base);
	// 829C4768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C476C: 4BFFFCCD  bl 0x829c4438
	ctx.lr = 0x829C4770;
	sub_829C4438(ctx, base);
	// 829C4770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C4774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C4778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C477C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C4780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4788 size=112
    let mut pc: u32 = 0x829C4788;
    'dispatch: loop {
        match pc {
            0x829C4788 => {
    //   block [0x829C4788..0x829C47F8)
	// 829C4788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C478C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C4794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4798: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C479C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C47A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C47A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829C47A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829C47AC: 4BFDE885  bl 0x829a3030
	ctx.lr = 0x829C47B0;
	sub_829A3030(ctx, base);
	// 829C47B0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C47B4: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829C47B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C47BC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 829C47C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829C47C4: 394A3284  addi r10, r10, 0x3284
	ctx.r[10].s64 = ctx.r[10].s64 + 12932;
	// 829C47C8: 993F001C  stb r9, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 829C47CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C47D0: C00BAF28  lfs f0, -0x50d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C47D4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829C47D8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C47DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C47E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C47E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C47E8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829C47EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C47F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C47F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C47F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C47F8 size=64
    let mut pc: u32 = 0x829C47F8;
    'dispatch: loop {
        match pc {
            0x829C47F8 => {
    //   block [0x829C47F8..0x829C4838)
	// 829C47F8: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C47FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C4800: 41980130  blt cr6, 0x829c4930
	if ctx.cr[6].lt {
		sub_829C4930(ctx, base);
		return;
	}
	// 829C4804: 419A0120  beq cr6, 0x829c4924
	if ctx.cr[6].eq {
		sub_829C4924(ctx, base);
		return;
	}
	// 829C4808: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C480C: 419800C8  blt cr6, 0x829c48d4
	if ctx.cr[6].lt {
		sub_829C48D4(ctx, base);
		return;
	}
	// 829C4810: 419A009C  beq cr6, 0x829c48ac
	if ctx.cr[6].eq {
		sub_829C48AC(ctx, base);
		return;
	}
	// 829C4814: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C4818: 4198005C  blt cr6, 0x829c4874
	if ctx.cr[6].lt {
		sub_829C4874(ctx, base);
		return;
	}
	// 829C481C: 419A001C  beq cr6, 0x829c4838
	if ctx.cr[6].eq {
		sub_829C4838(ctx, base);
		return;
	}
	// 829C4820: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C4824: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4828: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C482C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4830: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4834: 48000124  b 0x829c4958
	sub_829C4930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C4838 size=44
    let mut pc: u32 = 0x829C4838;
    'dispatch: loop {
        match pc {
            0x829C4838 => {
    //   block [0x829C4838..0x829C4864)
	// 829C4838: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C483C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829C4840: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4844: 40980020  bge cr6, 0x829c4864
	if !ctx.cr[6].lt {
		sub_829C4864(ctx, base);
		return;
	}
	// 829C4848: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C484C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C4850: 392BAF3C  addi r9, r11, -0x50c4
	ctx.r[9].s64 = ctx.r[11].s64 + -20676;
	// 829C4854: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4858: C00BAF3C  lfs f0, -0x50c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20676 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C485C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4860: 480000E8  b 0x829c4948
	sub_829C4930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4864(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C4864 size=16
    let mut pc: u32 = 0x829C4864;
    'dispatch: loop {
        match pc {
            0x829C4864 => {
    //   block [0x829C4864..0x829C4874)
	// 829C4864: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829C4868: 396BAF3C  addi r11, r11, -0x50c4
	ctx.r[11].s64 = ctx.r[11].s64 + -20676;
	// 829C486C: C00A2514  lfs f0, 0x2514(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4870: 48000088  b 0x829c48f8
	sub_829C48F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4874(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C4874 size=44
    let mut pc: u32 = 0x829C4874;
    'dispatch: loop {
        match pc {
            0x829C4874 => {
    //   block [0x829C4874..0x829C48A0)
	// 829C4874: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C4878: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829C487C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4880: 396BAF3C  addi r11, r11, -0x50c4
	ctx.r[11].s64 = ctx.r[11].s64 + -20676;
	// 829C4884: 4098001C  bge cr6, 0x829c48a0
	if !ctx.cr[6].lt {
		sub_829C48A0(ctx, base);
		return;
	}
	// 829C4888: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C488C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C4890: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4894: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4898: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C489C: 480000AC  b 0x829c4948
	sub_829C4930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C48A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C48A0 size=12
    let mut pc: u32 = 0x829C48A0;
    'dispatch: loop {
        match pc {
            0x829C48A0 => {
    //   block [0x829C48A0..0x829C48AC)
	// 829C48A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C48A4: C00A2960  lfs f0, 0x2960(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C48A8: 48000050  b 0x829c48f8
	sub_829C48F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C48AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C48AC size=24
    let mut pc: u32 = 0x829C48AC;
    'dispatch: loop {
        match pc {
            0x829C48AC => {
    //   block [0x829C48AC..0x829C48C4)
	// 829C48AC: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C48B0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829C48B4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C48B8: 4098000C  bge cr6, 0x829c48c4
	if !ctx.cr[6].lt {
		sub_829C48C4(ctx, base);
		return;
	}
	// 829C48BC: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C48C0: 4BFFFF90  b 0x829c4850
	sub_829C4838(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C48C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C48C4 size=16
    let mut pc: u32 = 0x829C48C4;
    'dispatch: loop {
        match pc {
            0x829C48C4 => {
    //   block [0x829C48C4..0x829C48D4)
	// 829C48C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C48C8: 396BAF3C  addi r11, r11, -0x50c4
	ctx.r[11].s64 = ctx.r[11].s64 + -20676;
	// 829C48CC: C00AA1C4  lfs f0, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C48D0: 48000028  b 0x829c48f8
	sub_829C48F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C48D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C48D4 size=28
    let mut pc: u32 = 0x829C48D4;
    'dispatch: loop {
        match pc {
            0x829C48D4 => {
    //   block [0x829C48D4..0x829C48F0)
	// 829C48D4: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C48D8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829C48DC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C48E0: 396BAF3C  addi r11, r11, -0x50c4
	ctx.r[11].s64 = ctx.r[11].s64 + -20676;
	// 829C48E4: 4098000C  bge cr6, 0x829c48f0
	if !ctx.cr[6].lt {
		sub_829C48F0(ctx, base);
		return;
	}
	// 829C48E8: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C48EC: 4BFFFFA4  b 0x829c4890
	sub_829C4874(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C48F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C48F0 size=52
    let mut pc: u32 = 0x829C48F0;
    'dispatch: loop {
        match pc {
            0x829C48F0 => {
    //   block [0x829C48F0..0x829C4924)
	// 829C48F0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C48F4: C00A9524  lfs f0, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C48F8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829C48FC: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4900: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C4904: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4908: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C490C: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4910: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C4914: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4918: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C491C: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4924(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C4924 size=12
    let mut pc: u32 = 0x829C4924;
    'dispatch: loop {
        match pc {
            0x829C4924 => {
    //   block [0x829C4924..0x829C4930)
	// 829C4924: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4928: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C492C: 48000008  b 0x829c4934
	sub_829C4930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C4930 size=48
    let mut pc: u32 = 0x829C4930;
    'dispatch: loop {
        match pc {
            0x829C4930 => {
    //   block [0x829C4930..0x829C4960)
	// 829C4930: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4934: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4938: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C493C: 396BAF3C  addi r11, r11, -0x50c4
	ctx.r[11].s64 = ctx.r[11].s64 + -20676;
	// 829C4940: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4944: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4948: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C494C: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4950: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4954: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4958: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C495C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4960 size=556
    let mut pc: u32 = 0x829C4960;
    'dispatch: loop {
        match pc {
            0x829C4960 => {
    //   block [0x829C4960..0x829C4B8C)
	// 829C4960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4964: 487E3809  bl 0x831a816c
	ctx.lr = 0x829C4968;
	sub_831A8130(ctx, base);
	// 829C4968: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829C496C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4974: 4878FC8D  bl 0x83154600
	ctx.lr = 0x829C4978;
	sub_83154600(ctx, base);
	// 829C4978: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C497C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4980: 4BFF9ED1  bl 0x829be850
	ctx.lr = 0x829C4984;
	sub_829BE850(ctx, base);
	// 829C4984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4988: 48494DF1  bl 0x82e59778
	ctx.lr = 0x829C498C;
	sub_82E59778(ctx, base);
	// 829C498C: 897F0195  lbz r11, 0x195(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(405 as u32) ) } as u64;
	// 829C4990: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4994: C01F0198  lfs f0, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4998: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829C499C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829C49A0: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829C49A4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C49A8: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C49AC: 419800B4  blt cr6, 0x829c4a60
	if ctx.cr[6].lt {
	pc = 0x829C4A60; continue 'dispatch;
	}
	// 829C49B0: 409A0148  bne cr6, 0x829c4af8
	if !ctx.cr[6].eq {
	pc = 0x829C4AF8; continue 'dispatch;
	}
	// 829C49B4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C49B8: C1ABAF54  lfs f13, -0x50ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20652 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C49BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829C49C0: 41980138  blt cr6, 0x829c4af8
	if ctx.cr[6].lt {
	pc = 0x829C4AF8; continue 'dispatch;
	}
	// 829C49C4: 815F01B0  lwz r10, 0x1b0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 829C49C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C49CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829C49D0: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829C49D4: 997F0195  stb r11, 0x195(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(405 as u32), ctx.r[11].u8 ) };
	// 829C49D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C49DC: 996A001C  stb r11, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 829C49E0: 4BB260A9  bl 0x824eaa88
	ctx.lr = 0x829C49E4;
	sub_824EAA88(ctx, base);
	// 829C49E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C49E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C49EC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C49F0: 4BB4A9D9  bl 0x8250f3c8
	ctx.lr = 0x829C49F4;
	sub_8250F3C8(ctx, base);
	// 829C49F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C49F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C49FC: 4BB26615  bl 0x824eb010
	ctx.lr = 0x829C4A00;
	sub_824EB010(ctx, base);
	// 829C4A00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C4A04: 895F019C  lbz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 829C4A08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C4A0C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 829C4A10: C00B2960  lfs f0, 0x2960(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4A14: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C4A18: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C4A1C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829C4A20: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C4A24: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829C4A28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829C4A2C: 997F019C  stb r11, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u8 ) };
	// 829C4A30: 4842D261  bl 0x82df1c90
	ctx.lr = 0x829C4A34;
	sub_82DF1C90(ctx, base);
	// 829C4A34: 897F019C  lbz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 829C4A38: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829C4A3C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829C4A40: 4198000C  blt cr6, 0x829c4a4c
	if ctx.cr[6].lt {
	pc = 0x829C4A4C; continue 'dispatch;
	}
	// 829C4A44: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 829C4A48: 997F019C  stb r11, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u8 ) };
	// 829C4A4C: 39600420  li r11, 0x420
	ctx.r[11].s64 = 1056;
	// 829C4A50: 394001A0  li r10, 0x1a0
	ctx.r[10].s64 = 416;
	// 829C4A54: 13FE58C7  vcmpequd (lvx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C4B90 size=60
    let mut pc: u32 = 0x829C4B90;
    'dispatch: loop {
        match pc {
            0x829C4B90 => {
    //   block [0x829C4B90..0x829C4BCC)
	// 829C4B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4B98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4B9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4BA4: 4BFFFDBD  bl 0x829c4960
	ctx.lr = 0x829C4BA8;
	sub_829C4960(ctx, base);
	// 829C4BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4BAC: 4B8FB455  bl 0x822c0000
	ctx.lr = 0x829C4BB0;
	sub_822C0000(ctx, base);
	// 829C4BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4BB4: 4878FA4D  bl 0x83154600
	ctx.lr = 0x829C4BB8;
	sub_83154600(ctx, base);
	// 829C4BB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C4BBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C4BC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C4BC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C4BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C4BD0 size=172
    let mut pc: u32 = 0x829C4BD0;
    'dispatch: loop {
        match pc {
            0x829C4BD0 => {
    //   block [0x829C4BD0..0x829C4C7C)
	// 829C4BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C4BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4BE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C4BE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C4BEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C4BF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C4BF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C4BF8: 4B8FBD41  bl 0x822c0938
	ctx.lr = 0x829C4BFC;
	sub_822C0938(ctx, base);
	// 829C4BFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C4C00: 41820028  beq 0x829c4c28
	if ctx.cr[0].eq {
	pc = 0x829C4C28; continue 'dispatch;
	}
	// 829C4C04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C4C08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C4C0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C4C10: 392B329C  addi r9, r11, 0x329c
	ctx.r[9].s64 = ctx.r[11].s64 + 12956;
	// 829C4C14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C4C18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C4C1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C4C20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C4C24: 48000008  b 0x829c4c2c
	pc = 0x829C4C2C; continue 'dispatch;
	// 829C4C28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C4C2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C4C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C4C34: 409A002C  bne cr6, 0x829c4c60
	if !ctx.cr[6].eq {
	pc = 0x829C4C60; continue 'dispatch;
	}
	// 829C4C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4C3C: 4B8FB62D  bl 0x822c0268
	ctx.lr = 0x829C4C40;
	sub_822C0268(ctx, base);
	// 829C4C40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4C44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4C48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C4C4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C4C50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C4C54: 816BAF70  lwz r11, -0x5090(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20624 as u32) ) } as u64;
	// 829C4C58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C4C5C: 4B8FB3A5  bl 0x822c0000
	ctx.lr = 0x829C4C60;
	sub_822C0000(ctx, base);
	// 829C4C60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C4C64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C4C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C4C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C4C70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C4C74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C4C78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4C80 size=432
    let mut pc: u32 = 0x829C4C80;
    'dispatch: loop {
        match pc {
            0x829C4C80 => {
    //   block [0x829C4C80..0x829C4E30)
	// 829C4C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4C84: 487E34E5  bl 0x831a8168
	ctx.lr = 0x829C4C88;
	sub_831A8130(ctx, base);
	// 829C4C88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4C90: 4878F971  bl 0x83154600
	ctx.lr = 0x829C4C94;
	sub_83154600(ctx, base);
	// 829C4C94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C4C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4C9C: 4BFF9835  bl 0x829be4d0
	ctx.lr = 0x829C4CA0;
	sub_829BE4D0(ctx, base);
	// 829C4CA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C4CA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C4CA8: 388B32B0  addi r4, r11, 0x32b0
	ctx.r[4].s64 = ctx.r[11].s64 + 12976;
	// 829C4CAC: 38A00144  li r5, 0x144
	ctx.r[5].s64 = 324;
	// 829C4CB0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 829C4CB4: 4B8FB725  bl 0x822c03d8
	ctx.lr = 0x829C4CB8;
	sub_822C03D8(ctx, base);
	// 829C4CB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829C4CBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C4CC0: 41820018  beq 0x829c4cd8
	if ctx.cr[0].eq {
	pc = 0x829C4CD8; continue 'dispatch;
	}
	// 829C4CC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C4CC8: C03D0444  lfs f1, 0x444(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C4CCC: 4BFFFABD  bl 0x829c4788
	ctx.lr = 0x829C4CD0;
	sub_829C4788(ctx, base);
	// 829C4CD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C4CD4: 48000008  b 0x829c4cdc
	pc = 0x829C4CDC; continue 'dispatch;
	// 829C4CD8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 829C4CDC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829C4CE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829C4CE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C4CE8: 4BFFFEE9  bl 0x829c4bd0
	ctx.lr = 0x829C4CEC;
	sub_829C4BD0(ctx, base);
	// 829C4CEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C4CF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829C4CF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C4CF8: 4B8FB309  bl 0x822c0000
	ctx.lr = 0x829C4CFC;
	sub_822C0000(ctx, base);
	// 829C4CFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C4D00: 3BDF01B0  addi r30, r31, 0x1b0
	ctx.r[30].s64 = ctx.r[31].s64 + 432;
	// 829C4D04: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829C4D08: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829C4D0C: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 829C4D10: 4B8FF751  bl 0x822c4460
	ctx.lr = 0x829C4D14;
	sub_822C4460(ctx, base);
	// 829C4D14: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C4D18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C4D1C: 419A0008  beq cr6, 0x829c4d24
	if ctx.cr[6].eq {
	pc = 0x829C4D24; continue 'dispatch;
	}
	// 829C4D20: 4B8FBB71  bl 0x822c0890
	ctx.lr = 0x829C4D24;
	sub_822C0890(ctx, base);
	// 829C4D24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C4D28: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C4D2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C4D30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C4D34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C4D38: 419A0024  beq cr6, 0x829c4d5c
	if ctx.cr[6].eq {
	pc = 0x829C4D5C; continue 'dispatch;
	}
	// 829C4D3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829C4D40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C4D44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C4D48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C4D4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C4D50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C4D54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C4D58: 4082FFE8  bne 0x829c4d40
	if !ctx.cr[0].eq {
	pc = 0x829C4D40; continue 'dispatch;
	}
	// 829C4D5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C4D60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C4D64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C4D68: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C4D6C: 4BFE02F5  bl 0x829a5060
	ctx.lr = 0x829C4D70;
	sub_829A5060(ctx, base);
	// 829C4D70: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829C4D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C4D78: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829C4D7C: 4842EC8D  bl 0x82df3a08
	ctx.lr = 0x829C4D80;
	sub_82DF3A08(ctx, base);
	// 829C4D80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C4D84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C4D88: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829C4D8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C4D90: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829C4D94: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829C4D98: 481EE5E1  bl 0x82bb3378
	ctx.lr = 0x829C4D9C;
	sub_82BB3378(ctx, base);
	// 829C4D9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C4DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C4DA4: 419A0008  beq cr6, 0x829c4dac
	if ctx.cr[6].eq {
	pc = 0x829C4DAC; continue 'dispatch;
	}
	// 829C4DA8: 4B8FBAE9  bl 0x822c0890
	ctx.lr = 0x829C4DAC;
	sub_822C0890(ctx, base);
	// 829C4DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C4DB0: 4842E679  bl 0x82df3428
	ctx.lr = 0x829C4DB4;
	sub_82DF3428(ctx, base);
	// 829C4DB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C4DB8: 9B9F0194  stb r28, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[28].u8 ) };
	// 829C4DBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C4DC0: 9B9F0195  stb r28, 0x195(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(405 as u32), ctx.r[28].u8 ) };
	// 829C4DC4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4DC8: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 829C4DCC: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829C4DD0: 4BB25CB9  bl 0x824eaa88
	ctx.lr = 0x829C4DD4;
	sub_824EAA88(ctx, base);
	// 829C4DD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C4DD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C4DDC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C4DE0: 4BB4A5E9  bl 0x8250f3c8
	ctx.lr = 0x829C4DE4;
	sub_8250F3C8(ctx, base);
	// 829C4DE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C4DE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C4DEC: 4BB26225  bl 0x824eb010
	ctx.lr = 0x829C4DF0;
	sub_824EB010(ctx, base);
	// 829C4DF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C4DF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829C4DF8: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4DFC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C4E00: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C4E04: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829C4E08: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 829C4E0C: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 829C4E10: 997F019C  stb r11, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u8 ) };
	// 829C4E14: 4842CE7D  bl 0x82df1c90
	ctx.lr = 0x829C4E18;
	sub_82DF1C90(ctx, base);
	// 829C4E18: 39600420  li r11, 0x420
	ctx.r[11].s64 = 1056;
	// 829C4E1C: 394001A0  li r10, 0x1a0
	ctx.r[10].s64 = 416;
	// 829C4E20: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4E30 size=72
    let mut pc: u32 = 0x829C4E30;
    'dispatch: loop {
        match pc {
            0x829C4E30 => {
    //   block [0x829C4E30..0x829C4E78)
	// 829C4E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4E34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4E38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4E3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4E40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4E44: 4BFDE1ED  bl 0x829a3030
	ctx.lr = 0x829C4E48;
	sub_829A3030(ctx, base);
	// 829C4E48: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4E4C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C4E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C4E54: 394A3308  addi r10, r10, 0x3308
	ctx.r[10].s64 = ctx.r[10].s64 + 13064;
	// 829C4E58: C00BB00C  lfs f0, -0x4ff4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20468 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4E5C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829C4E60: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4E64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C4E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C4E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C4E70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C4E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C4E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C4E78 size=448
    let mut pc: u32 = 0x829C4E78;
    'dispatch: loop {
        match pc {
            0x829C4E78 => {
    //   block [0x829C4E78..0x829C5038)
	// 829C4E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C4E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C4E80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C4E84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C4E88: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4E8C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829C4E90: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4E94: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C4E98: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C4E9C: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C4EA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C4EA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C4EA8: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4EAC: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4EB0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829C4EB4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C4EB8: 4198013C  blt cr6, 0x829c4ff4
	if ctx.cr[6].lt {
	pc = 0x829C4FF4; continue 'dispatch;
	}
	// 829C4EBC: 419A0104  beq cr6, 0x829c4fc0
	if ctx.cr[6].eq {
	pc = 0x829C4FC0; continue 'dispatch;
	}
	// 829C4EC0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C4EC4: 419800D4  blt cr6, 0x829c4f98
	if ctx.cr[6].lt {
	pc = 0x829C4F98; continue 'dispatch;
	}
	// 829C4EC8: 419A0098  beq cr6, 0x829c4f60
	if ctx.cr[6].eq {
	pc = 0x829C4F60; continue 'dispatch;
	}
	// 829C4ECC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C4ED0: 41980064  blt cr6, 0x829c4f34
	if ctx.cr[6].lt {
	pc = 0x829C4F34; continue 'dispatch;
	}
	// 829C4ED4: 419A001C  beq cr6, 0x829c4ef0
	if ctx.cr[6].eq {
	pc = 0x829C4EF0; continue 'dispatch;
	}
	// 829C4ED8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C4EDC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4EE0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C4EE4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4EE8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4EEC: 48000130  b 0x829c501c
	pc = 0x829C501C; continue 'dispatch;
	// 829C4EF0: 487E3FB9  bl 0x831a8ea8
	ctx.lr = 0x829C4EF4;
	sub_831A8EA8(ctx, base);
	// 829C4EF4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4EF8: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C4EFC: 392BB028  addi r9, r11, -0x4fd8
	ctx.r[9].s64 = ctx.r[11].s64 + -20440;
	// 829C4F00: C16BB028  lfs f11, -0x4fd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20440 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C4F04: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4F08: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4F0C: FD200050  fneg f9, f0
	ctx.f[9].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C4F10: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4F14: ED8C5ABA  fmadds f12, f12, f10, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 829C4F18: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4F1C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C4F20: D13F0000  stfs f9, 0(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4F24: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4F28: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4F2C: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4F30: 480000F0  b 0x829c5020
	pc = 0x829C5020; continue 'dispatch;
	// 829C4F34: 487E3F75  bl 0x831a8ea8
	ctx.lr = 0x829C4F38;
	sub_831A8EA8(ctx, base);
	// 829C4F38: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4F3C: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C4F40: 396BB028  addi r11, r11, -0x4fd8
	ctx.r[11].s64 = ctx.r[11].s64 + -20440;
	// 829C4F44: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4F48: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4F4C: FD200050  fneg f9, f0
	ctx.f[9].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C4F50: C16BFFFC  lfs f11, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C4F54: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4F58: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 829C4F5C: 4BFFFFBC  b 0x829c4f18
	pc = 0x829C4F18; continue 'dispatch;
	// 829C4F60: 487E3F49  bl 0x831a8ea8
	ctx.lr = 0x829C4F64;
	sub_831A8EA8(ctx, base);
	// 829C4F64: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4F68: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C4F6C: 392BB028  addi r9, r11, -0x4fd8
	ctx.r[9].s64 = ctx.r[11].s64 + -20440;
	// 829C4F70: C14BB028  lfs f10, -0x4fd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20440 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C4F74: C1690004  lfs f11, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C4F78: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4F7C: C1A9FFF8  lfs f13, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4F80: ED6B527C  fnmsubs f11, f11, f9, f10
	ctx.f[11].f64 = -(((ctx.f[11].f64 * ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 829C4F84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4F88: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4F8C: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4F90: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4F94: 48000084  b 0x829c5018
	pc = 0x829C5018; continue 'dispatch;
	// 829C4F98: 487E3F11  bl 0x831a8ea8
	ctx.lr = 0x829C4F9C;
	sub_831A8EA8(ctx, base);
	// 829C4F9C: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829C4FA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4FA4: 396BB028  addi r11, r11, -0x4fd8
	ctx.r[11].s64 = ctx.r[11].s64 + -20440;
	// 829C4FA8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C4FAC: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829C4FB0: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4FB4: ED6B527A  fmadds f11, f11, f9, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 829C4FB8: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4FBC: 4BFFFFC8  b 0x829c4f84
	pc = 0x829C4F84; continue 'dispatch;
	// 829C4FC0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4FC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4FC8: 396BB028  addi r11, r11, -0x4fd8
	ctx.r[11].s64 = ctx.r[11].s64 + -20440;
	// 829C4FCC: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C4FD0: C00BFFE8  lfs f0, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4FD4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829C4FD8: C1ABFFEC  lfs f13, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C4FDC: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C4FE0: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C4FE4: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C4FE8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C4FEC: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C4FF0: 48000030  b 0x829c5020
	pc = 0x829C5020; continue 'dispatch;
	// 829C4FF4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C4FF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C4FFC: 396BB028  addi r11, r11, -0x4fd8
	ctx.r[11].s64 = ctx.r[11].s64 + -20440;
	// 829C5000: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C5004: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C5008: C00BFFE8  lfs f0, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C500C: C1ABFFEC  lfs f13, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5010: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C5014: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C5018: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C501C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C5020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5024: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C502C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5030: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5038 size=320
    let mut pc: u32 = 0x829C5038;
    'dispatch: loop {
        match pc {
            0x829C5038 => {
    //   block [0x829C5038..0x829C5178)
	// 829C5038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C503C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5044: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5048: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829C504C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C5050: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C5054: 419800E4  blt cr6, 0x829c5138
	if ctx.cr[6].lt {
	pc = 0x829C5138; continue 'dispatch;
	}
	// 829C5058: 419A00E0  beq cr6, 0x829c5138
	if ctx.cr[6].eq {
	pc = 0x829C5138; continue 'dispatch;
	}
	// 829C505C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829C5060: 41980094  blt cr6, 0x829c50f4
	if ctx.cr[6].lt {
	pc = 0x829C50F4; continue 'dispatch;
	}
	// 829C5064: 419A0068  beq cr6, 0x829c50cc
	if ctx.cr[6].eq {
	pc = 0x829C50CC; continue 'dispatch;
	}
	// 829C5068: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829C506C: 41980038  blt cr6, 0x829c50a4
	if ctx.cr[6].lt {
	pc = 0x829C50A4; continue 'dispatch;
	}
	// 829C5070: 409A00CC  bne cr6, 0x829c513c
	if !ctx.cr[6].eq {
	pc = 0x829C513C; continue 'dispatch;
	}
	// 829C5074: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C5078: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C507C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C5080: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5084: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5088: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829C508C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829C5090: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829C5094: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829C5098: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C509C: C1A89530  lfs f13, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C50A0: 48000080  b 0x829c5120
	pc = 0x829C5120; continue 'dispatch;
	// 829C50A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C50A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C50AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829C50B0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C50B4: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C50B8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C50BC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C50C0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C50C4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C50C8: 4BFFFFD0  b 0x829c5098
	pc = 0x829C5098; continue 'dispatch;
	// 829C50CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C50D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C50D4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829C50D8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C50DC: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C50E0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829C50E4: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829C50E8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829C50EC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829C50F0: 48000028  b 0x829c5118
	pc = 0x829C5118; continue 'dispatch;
	// 829C50F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C50F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C50FC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829C5100: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5104: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5108: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829C510C: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829C5110: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829C5114: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829C5118: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C511C: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5120: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829C5124: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5128: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829C512C: 484B7B15  bl 0x82e7cc40
	ctx.lr = 0x829C5130;
	sub_82E7CC40(ctx, base);
	// 829C5130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5134: 48000030  b 0x829c5164
	pc = 0x829C5164; continue 'dispatch;
	// 829C5138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C513C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829C5140: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829C5144: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5148: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829C514C: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5150: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829C5154: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5158: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829C515C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5160: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829C5164: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829C5168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C516C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5178 size=172
    let mut pc: u32 = 0x829C5178;
    'dispatch: loop {
        match pc {
            0x829C5178 => {
    //   block [0x829C5178..0x829C5224)
	// 829C5178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C517C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C5184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C518C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C5190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C5194: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C5198: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C519C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C51A0: 4B8FB799  bl 0x822c0938
	ctx.lr = 0x829C51A4;
	sub_822C0938(ctx, base);
	// 829C51A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C51A8: 41820028  beq 0x829c51d0
	if ctx.cr[0].eq {
	pc = 0x829C51D0; continue 'dispatch;
	}
	// 829C51AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C51B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C51B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C51B8: 392B3320  addi r9, r11, 0x3320
	ctx.r[9].s64 = ctx.r[11].s64 + 13088;
	// 829C51BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C51C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C51C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C51C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C51CC: 48000008  b 0x829c51d4
	pc = 0x829C51D4; continue 'dispatch;
	// 829C51D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C51D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C51D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C51DC: 409A002C  bne cr6, 0x829c5208
	if !ctx.cr[6].eq {
	pc = 0x829C5208; continue 'dispatch;
	}
	// 829C51E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C51E4: 4B8FB085  bl 0x822c0268
	ctx.lr = 0x829C51E8;
	sub_822C0268(ctx, base);
	// 829C51E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C51EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C51F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C51F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C51F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C51FC: 816BB030  lwz r11, -0x4fd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20432 as u32) ) } as u64;
	// 829C5200: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C5204: 4B8FADFD  bl 0x822c0000
	ctx.lr = 0x829C5208;
	sub_822C0000(ctx, base);
	// 829C5208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C520C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C5210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C521C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5228 size=364
    let mut pc: u32 = 0x829C5228;
    'dispatch: loop {
        match pc {
            0x829C5228 => {
    //   block [0x829C5228..0x829C5394)
	// 829C5228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C522C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C5234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C523C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C5240: 4878F3C1  bl 0x83154600
	ctx.lr = 0x829C5244;
	sub_83154600(ctx, base);
	// 829C5244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C5248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C524C: 4BFF9285  bl 0x829be4d0
	ctx.lr = 0x829C5250;
	sub_829BE4D0(ctx, base);
	// 829C5250: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C5254: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C5258: 388B3330  addi r4, r11, 0x3330
	ctx.r[4].s64 = ctx.r[11].s64 + 13104;
	// 829C525C: 38A000B4  li r5, 0xb4
	ctx.r[5].s64 = 180;
	// 829C5260: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829C5264: 4B8FB175  bl 0x822c03d8
	ctx.lr = 0x829C5268;
	sub_822C03D8(ctx, base);
	// 829C5268: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C526C: 41820010  beq 0x829c527c
	if ctx.cr[0].eq {
	pc = 0x829C527C; continue 'dispatch;
	}
	// 829C5270: 4BFFFBC1  bl 0x829c4e30
	ctx.lr = 0x829C5274;
	sub_829C4E30(ctx, base);
	// 829C5274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C5278: 48000008  b 0x829c5280
	pc = 0x829C5280; continue 'dispatch;
	// 829C527C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829C5280: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829C5284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5288: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C528C: 4BFFFEED  bl 0x829c5178
	ctx.lr = 0x829C5290;
	sub_829C5178(ctx, base);
	// 829C5290: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829C5294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5298: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C529C: 4B8FAD65  bl 0x822c0000
	ctx.lr = 0x829C52A0;
	sub_822C0000(ctx, base);
	// 829C52A0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C52A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C52A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C52AC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829C52B0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829C52B4: 419A0024  beq cr6, 0x829c52d8
	if ctx.cr[6].eq {
	pc = 0x829C52D8; continue 'dispatch;
	}
	// 829C52B8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829C52BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829C52C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C52C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829C52C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829C52CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829C52D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829C52D4: 4082FFE8  bne 0x829c52bc
	if !ctx.cr[0].eq {
	pc = 0x829C52BC; continue 'dispatch;
	}
	// 829C52D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C52DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C52E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C52E4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829C52E8: 4BFDFD79  bl 0x829a5060
	ctx.lr = 0x829C52EC;
	sub_829A5060(ctx, base);
	// 829C52EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C52F0: 419A000C  beq cr6, 0x829c52fc
	if ctx.cr[6].eq {
	pc = 0x829C52FC; continue 'dispatch;
	}
	// 829C52F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C52F8: 4B8FB599  bl 0x822c0890
	ctx.lr = 0x829C52FC;
	sub_822C0890(ctx, base);
	// 829C52FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829C5300: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829C5304: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 829C5308: 39200420  li r9, 0x420
	ctx.r[9].s64 = 1056;
	// 829C530C: 390ABA80  addi r8, r10, -0x4580
	ctx.r[8].s64 = ctx.r[10].s64 + -17792;
	// 829C5310: 3CE08207  lis r7, -0x7df9
	ctx.r[7].s64 = -2113470464;
	// 829C5314: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C5318: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C531C: 3887D748  addi r4, r7, -0x28b8
	ctx.r[4].s64 = ctx.r[7].s64 + -10424;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5398 size=80
    let mut pc: u32 = 0x829C5398;
    'dispatch: loop {
        match pc {
            0x829C5398 => {
    //   block [0x829C5398..0x829C53E8)
	// 829C5398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C539C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C53A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C53A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C53A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C53AC: 484942D5  bl 0x82e59680
	ctx.lr = 0x829C53B0;
	sub_82E59680(ctx, base);
	// 829C53B0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C53B4: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 829C53B8: 394A3D2C  addi r10, r10, 0x3d2c
	ctx.r[10].s64 = ctx.r[10].s64 + 15660;
	// 829C53BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829C53C0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829C53C4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829C53C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C53CC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 829C53D0: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 829C53D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C53D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C53DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C53E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C53E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C53E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C53E8 size=88
    let mut pc: u32 = 0x829C53E8;
    'dispatch: loop {
        match pc {
            0x829C53E8 => {
    //   block [0x829C53E8..0x829C5440)
	// 829C53E8: 814302B0  lwz r10, 0x2b0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C53EC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C53F0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C53F4: 81630314  lwz r11, 0x314(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(788 as u32) ) } as u64;
	// 829C53F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C53FC: 392934EC  addi r9, r9, 0x34ec
	ctx.r[9].s64 = ctx.r[9].s64 + 13548;
	// 829C5400: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829C5404: C1880A90  lfs f12, 0xa90(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2704 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C5408: 7D4A4AAA  lwax r10, r10, r9
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as i32) as i64;
	// 829C540C: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 829C5410: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5414: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C5418: C1A79450  lfs f13, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C541C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C5420: ED806B3A  fmadds f12, f0, f12, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 829C5424: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 829C5428: D981FFF0  stfd f12, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[12].u64 ) };
	// 829C542C: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 829C5430: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 829C5434: 4199000C  bgt cr6, 0x829c5440
	if ctx.cr[6].gt {
		sub_829C5440(ctx, base);
		return;
	}
	// 829C5438: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 829C543C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C5440 size=36
    let mut pc: u32 = 0x829C5440;
    'dispatch: loop {
        match pc {
            0x829C5440 => {
    //   block [0x829C5440..0x829C5464)
	// 829C5440: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829C5444: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829C5448: C18AFD2C  lfs f12, -0x2d4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-724 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C544C: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 829C5450: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C5454: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 829C5458: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 829C545C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 829C5460: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5464(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5464 size=8
    let mut pc: u32 = 0x829C5464;
    'dispatch: loop {
        match pc {
            0x829C5464 => {
    //   block [0x829C5464..0x829C546C)
	// 829C5464: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829C5468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5470 size=88
    let mut pc: u32 = 0x829C5470;
    'dispatch: loop {
        match pc {
            0x829C5470 => {
    //   block [0x829C5470..0x829C54C8)
	// 829C5470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C547C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C5480: 4BFFFF69  bl 0x829c53e8
	ctx.lr = 0x829C5484;
	sub_829C53E8(ctx, base);
	// 829C5484: 81660314  lwz r11, 0x314(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(788 as u32) ) } as u64;
	// 829C5488: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829C548C: 7D645851  subf. r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5490: 91660314  stw r11, 0x314(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(788 as u32), ctx.r[11].u32 ) };
	// 829C5494: 4080000C  bge 0x829c54a0
	if !ctx.cr[0].lt {
	pc = 0x829C54A0; continue 'dispatch;
	}
	// 829C5498: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C549C: 91660314  stw r11, 0x314(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(788 as u32), ctx.r[11].u32 ) };
	// 829C54A0: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 829C54A4: 4BFFFF45  bl 0x829c53e8
	ctx.lr = 0x829C54A8;
	sub_829C53E8(ctx, base);
	// 829C54A8: 7D651850  subf r11, r5, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[5].s64;
	// 829C54AC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829C54B0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829C54B4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 829C54B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C54BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C54C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C54C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C54C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C54C8 size=20
    let mut pc: u32 = 0x829C54C8;
    'dispatch: loop {
        match pc {
            0x829C54C8 => {
    //   block [0x829C54C8..0x829C54DC)
	// 829C54C8: 816301F0  lwz r11, 0x1f0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(496 as u32) ) } as u64;
	// 829C54CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829C54D0: 916301F0  stw r11, 0x1f0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
	// 829C54D4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 829C54D8: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C54DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C54DC size=12
    let mut pc: u32 = 0x829C54DC;
    'dispatch: loop {
        match pc {
            0x829C54DC => {
    //   block [0x829C54DC..0x829C54E8)
	// 829C54DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C54E0: 996301ED  stb r11, 0x1ed(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(493 as u32), ctx.r[11].u8 ) };
	// 829C54E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C54E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C54E8 size=16
    let mut pc: u32 = 0x829C54E8;
    'dispatch: loop {
        match pc {
            0x829C54E8 => {
    //   block [0x829C54E8..0x829C54F8)
	// 829C54E8: 816301F0  lwz r11, 0x1f0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(496 as u32) ) } as u64;
	// 829C54EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C54F0: 916301F0  stw r11, 0x1f0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
	// 829C54F4: 4D810020  bgtlr
	if ctx.cr[0].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C54F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C54F8 size=24
    let mut pc: u32 = 0x829C54F8;
    'dispatch: loop {
        match pc {
            0x829C54F8 => {
    //   block [0x829C54F8..0x829C5510)
	// 829C54F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C54FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C5500: 994301ED  stb r10, 0x1ed(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(493 as u32), ctx.r[10].u8 ) };
	// 829C5504: C00B3524  lfs f0, 0x3524(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5508: D00301F4  stfs f0, 0x1f4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 829C550C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5510 size=12
    let mut pc: u32 = 0x829C5510;
    'dispatch: loop {
        match pc {
            0x829C5510 => {
    //   block [0x829C5510..0x829C551C)
	// 829C5510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C5514: 996302BA  stb r11, 0x2ba(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(698 as u32), ctx.r[11].u8 ) };
	// 829C5518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5520 size=8
    let mut pc: u32 = 0x829C5520;
    'dispatch: loop {
        match pc {
            0x829C5520 => {
    //   block [0x829C5520..0x829C5528)
	// 829C5520: 88630311  lbz r3, 0x311(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(785 as u32) ) } as u64;
	// 829C5524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5528 size=24
    let mut pc: u32 = 0x829C5528;
    'dispatch: loop {
        match pc {
            0x829C5528 => {
    //   block [0x829C5528..0x829C5540)
	// 829C5528: 816302B0  lwz r11, 0x2b0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C552C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C5530: 394A34EC  addi r10, r10, 0x34ec
	ctx.r[10].s64 = ctx.r[10].s64 + 13548;
	// 829C5534: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5538: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C553C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5540 size=128
    let mut pc: u32 = 0x829C5540;
    'dispatch: loop {
        match pc {
            0x829C5540 => {
    //   block [0x829C5540..0x829C55C0)
	// 829C5540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5548: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C554C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829C5550: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829C5554: 4BFFFE95  bl 0x829c53e8
	ctx.lr = 0x829C5558;
	sub_829C53E8(ctx, base);
	// 829C5558: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C555C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 829C5560: 396BB184  addi r11, r11, -0x4e7c
	ctx.r[11].s64 = ctx.r[11].s64 + -20092;
	// 829C5564: 41980014  blt cr6, 0x829c5578
	if ctx.cr[6].lt {
	pc = 0x829C5578; continue 'dispatch;
	}
	// 829C5568: 419A001C  beq cr6, 0x829c5584
	if ctx.cr[6].eq {
	pc = 0x829C5584; continue 'dispatch;
	}
	// 829C556C: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 829C5570: 41980028  blt cr6, 0x829c5598
	if ctx.cr[6].lt {
	pc = 0x829C5598; continue 'dispatch;
	}
	// 829C5574: 48000038  b 0x829c55ac
	pc = 0x829C55AC; continue 'dispatch;
	// 829C5578: 814502B0  lwz r10, 0x2b0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C557C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 829C5580: 7CCA582E  lwzx r6, r10, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C5584: 814502B0  lwz r10, 0x2b0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C5588: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 829C558C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 829C5590: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 829C5594: 7CCA3214  add r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 829C5598: 814502B0  lwz r10, 0x2b0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C559C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829C55A0: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 829C55A4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C55A8: 7CCB3214  add r6, r11, r6
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 829C55AC: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 829C55B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C55B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C55B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C55BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C55C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C55C0 size=132
    let mut pc: u32 = 0x829C55C0;
    'dispatch: loop {
        match pc {
            0x829C55C0 => {
    //   block [0x829C55C0..0x829C5644)
	// 829C55C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C55C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C55C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C55CC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C55D0: 4BFFFE19  bl 0x829c53e8
	ctx.lr = 0x829C55D4;
	sub_829C53E8(ctx, base);
	// 829C55D4: 816602B0  lwz r11, 0x2b0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C55D8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C55DC: 894602B8  lbz r10, 0x2b8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(696 as u32) ) } as u64;
	// 829C55E0: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829C55E4: 396934EC  addi r11, r9, 0x34ec
	ctx.r[11].s64 = ctx.r[9].s64 + 13548;
	// 829C55E8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829C55EC: 392B000C  addi r9, r11, 0xc
	ctx.r[9].s64 = ctx.r[11].s64 + 12;
	// 829C55F0: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 829C55F4: 546A083C  slwi r10, r3, 1
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C55F8: 7D085AAA  lwax r8, r8, r11
	ctx.r[8].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as i32) as i64;
	// 829C55FC: 54EBDFFE  rlwinm r11, r7, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 829C5600: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 829C5604: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C5608: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C560C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829C5610: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C5614: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829C5618: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C561C: C0079450  lfs f0, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5620: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C5624: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C5628: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C562C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829C5630: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C5634: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C563C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5648 size=300
    let mut pc: u32 = 0x829C5648;
    'dispatch: loop {
        match pc {
            0x829C5648 => {
    //   block [0x829C5648..0x829C5774)
	// 829C5648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C564C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5654: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5658: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C565C: 80A602B0  lwz r5, 0x2b0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C5660: 4BFFFD89  bl 0x829c53e8
	ctx.lr = 0x829C5664;
	sub_829C53E8(ctx, base);
	// 829C5664: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C5668: 894602B8  lbz r10, 0x2b8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(696 as u32) ) } as u64;
	// 829C566C: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829C5670: 396B34EC  addi r11, r11, 0x34ec
	ctx.r[11].s64 = ctx.r[11].s64 + 13548;
	// 829C5674: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829C5678: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 829C567C: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 829C5680: 546A083C  slwi r10, r3, 1
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C5684: 7D295AAA  lwax r9, r9, r11
	ctx.r[9].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as i32) as i64;
	// 829C5688: 54EBDFFE  rlwinm r11, r7, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 829C568C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 829C5690: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C5694: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C5698: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829C569C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C56A0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829C56A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C56A8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 829C56AC: C1679450  lfs f11, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829C56B0: 7DAB442E  lfsx f13, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C56B4: EC0D583A  fmadds f0, f13, f0, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 829C56B8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C56BC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829C56C0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C56C4: 4BFFFD25  bl 0x829c53e8
	ctx.lr = 0x829C56C8;
	sub_829C53E8(ctx, base);
	// 829C56C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C56CC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 829C56D0: 3BEBB184  addi r31, r11, -0x4e7c
	ctx.r[31].s64 = ctx.r[11].s64 + -20092;
	// 829C56D4: 41980074  blt cr6, 0x829c5748
	if ctx.cr[6].lt {
	pc = 0x829C5748; continue 'dispatch;
	}
	// 829C56D8: 419A0080  beq cr6, 0x829c5758
	if ctx.cr[6].eq {
	pc = 0x829C5758; continue 'dispatch;
	}
	// 829C56DC: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 829C56E0: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 829C56E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829C56E8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C56EC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C56F0: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C56F4: 4BFFFCF5  bl 0x829c53e8
	ctx.lr = 0x829C56F8;
	sub_829C53E8(ctx, base);
	// 829C56F8: 1D650003  mulli r11, r5, 3
	ctx.r[11].s64 = ctx.r[5].s64 * 3;
	// 829C56FC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829C5700: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829C5704: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5708: C00A6218  lfs f0, 0x6218(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C570C: 7D6BFAAA  lwax r11, r11, r31
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as i32) as i64;
	// 829C5710: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829C5714: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C5718: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 829C571C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 829C5720: EDAA6824  fdivs f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 / ctx.f[13].f64) as f32) as f64;
	// 829C5724: EC0D583A  fmadds f0, f13, f0, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 829C5728: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C572C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829C5730: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C5734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C5738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C573C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5744: 4E800020  blr
	return;
	// 829C5748: 1D65000C  mulli r11, r5, 0xc
	ctx.r[11].s64 = ctx.r[5].s64 * 12;
	// 829C574C: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 829C5750: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C5754: 7C8B2050  subf r4, r11, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 829C5758: 1D65000C  mulli r11, r5, 0xc
	ctx.r[11].s64 = ctx.r[5].s64 * 12;
	// 829C575C: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 829C5760: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C5764: 7C8B2051  subf. r4, r11, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 829C5768: 4181FF74  bgt 0x829c56dc
	if ctx.cr[0].gt {
	pc = 0x829C56DC; continue 'dispatch;
	}
	// 829C576C: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829C5770: 4BFFFFC4  b 0x829c5734
	pc = 0x829C5734; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5778 size=152
    let mut pc: u32 = 0x829C5778;
    'dispatch: loop {
        match pc {
            0x829C5778 => {
    //   block [0x829C5778..0x829C5810)
	// 829C5778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C577C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5780: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5784: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C5788: 4BFFFC61  bl 0x829c53e8
	ctx.lr = 0x829C578C;
	sub_829C53E8(ctx, base);
	// 829C578C: 816602B0  lwz r11, 0x2b0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C5790: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C5794: 894602B8  lbz r10, 0x2b8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(696 as u32) ) } as u64;
	// 829C5798: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829C579C: 80E60314  lwz r7, 0x314(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(788 as u32) ) } as u64;
	// 829C57A0: 396934EC  addi r11, r9, 0x34ec
	ctx.r[11].s64 = ctx.r[9].s64 + 13548;
	// 829C57A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829C57A8: 392B000C  addi r9, r11, 0xc
	ctx.r[9].s64 = ctx.r[11].s64 + 12;
	// 829C57AC: 7D460034  cntlzw r6, r10
	ctx.r[6].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 829C57B0: 546A083C  slwi r10, r3, 1
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C57B4: 7D085AAA  lwax r8, r8, r11
	ctx.r[8].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as i32) as i64;
	// 829C57B8: 54CBDFFE  rlwinm r11, r6, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 829C57BC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 829C57C0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C57C4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C57C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829C57CC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C57D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C57D4: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 829C57D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829C57DC: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C57E0: C0069450  lfs f0, -0x6bb0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C57E4: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829C57E8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C57EC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829C57F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829C57F4: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829C57F8: 40990008  ble cr6, 0x829c5800
	if !ctx.cr[6].gt {
	pc = 0x829C5800; continue 'dispatch;
	}
	// 829C57FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829C5800: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C580C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5810 size=100
    let mut pc: u32 = 0x829C5810;
    'dispatch: loop {
        match pc {
            0x829C5810 => {
    //   block [0x829C5810..0x829C5874)
	// 829C5810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5818: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C581C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C5820: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829C5824: 4BFFFBC5  bl 0x829c53e8
	ctx.lr = 0x829C5828;
	sub_829C53E8(ctx, base);
	// 829C5828: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 829C582C: 41980020  blt cr6, 0x829c584c
	if ctx.cr[6].lt {
	pc = 0x829C584C; continue 'dispatch;
	}
	// 829C5830: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 829C5834: 4098002C  bge cr6, 0x829c5860
	if !ctx.cr[6].lt {
	pc = 0x829C5860; continue 'dispatch;
	}
	// 829C5838: 8966031C  lbz r11, 0x31c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(796 as u32) ) } as u64;
	// 829C583C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829C5840: 41990020  bgt cr6, 0x829c5860
	if ctx.cr[6].gt {
	pc = 0x829C5860; continue 'dispatch;
	}
	// 829C5844: 20AB0002  subfic r5, r11, 2
	ctx.xer.ca = ctx.r[11].u32 <= 2 as u32;
	ctx.r[5].s64 = (2 as i64) - ctx.r[11].s64;
	// 829C5848: 48000018  b 0x829c5860
	pc = 0x829C5860; continue 'dispatch;
	// 829C584C: 8966031C  lbz r11, 0x31c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(796 as u32) ) } as u64;
	// 829C5850: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 829C5854: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 829C5858: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829C585C: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 829C5860: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 829C5864: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C586C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C5878 size=40
    let mut pc: u32 = 0x829C5878;
    'dispatch: loop {
        match pc {
            0x829C5878 => {
    //   block [0x829C5878..0x829C58A0)
	// 829C5878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C587C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C5880: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 829C5884: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829C5888: 994302BB  stb r10, 0x2bb(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(699 as u32), ctx.r[10].u8 ) };
	// 829C588C: 912302C0  stw r9, 0x2c0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(704 as u32), ctx.r[9].u32 ) };
	// 829C5890: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5894: 910302C4  stw r8, 0x2c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(708 as u32), ctx.r[8].u32 ) };
	// 829C5898: D00302BC  stfs f0, 0x2bc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 829C589C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C58A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C58A0 size=36
    let mut pc: u32 = 0x829C58A0;
    'dispatch: loop {
        match pc {
            0x829C58A0 => {
    //   block [0x829C58A0..0x829C58C4)
	// 829C58A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C58A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C58A8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 829C58AC: 996302BB  stb r11, 0x2bb(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(699 as u32), ctx.r[11].u8 ) };
	// 829C58B0: 912302C0  stw r9, 0x2c0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(704 as u32), ctx.r[9].u32 ) };
	// 829C58B4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C58B8: 916302C4  stw r11, 0x2c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 829C58BC: D00302BC  stfs f0, 0x2bc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 829C58C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C58C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C58C8 size=44
    let mut pc: u32 = 0x829C58C8;
    'dispatch: loop {
        match pc {
            0x829C58C8 => {
    //   block [0x829C58C8..0x829C58F4)
	// 829C58C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C58CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C58D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C58D4: 4BFFFB15  bl 0x829c53e8
	ctx.lr = 0x829C58D8;
	sub_829C53E8(ctx, base);
	// 829C58D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C58DC: 396B352C  addi r11, r11, 0x352c
	ctx.r[11].s64 = ctx.r[11].s64 + 13612;
	// 829C58E0: 7C6358AE  lbzx r3, r3, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C58E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C58E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C58EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C58F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C58F8 size=180
    let mut pc: u32 = 0x829C58F8;
    'dispatch: loop {
        match pc {
            0x829C58F8 => {
    //   block [0x829C58F8..0x829C59AC)
	// 829C58F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C58FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5904: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5908: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 829C590C: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 829C5910: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 829C5914: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829C5918: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 829C591C: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 829C5920: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 829C5924: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829C5928: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829C592C: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 829C5930: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829C5934: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 829C5938: 3BE100A0  addi r31, r1, 0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + 160;
	// 829C593C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829C5940: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C5944: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 829C5948: 90E10088  stw r7, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 829C594C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 829C5950: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 829C5954: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 829C5958: 90E100A0  stw r7, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u32 ) };
	// 829C595C: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 829C5960: 910100A8  stw r8, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 829C5964: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 829C5968: 912100B0  stw r9, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 829C596C: 914100B4  stw r10, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[10].u32 ) };
	// 829C5970: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 829C5974: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 829C5978: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829C597C: 4BFFFA6D  bl 0x829c53e8
	ctx.lr = 0x829C5980;
	sub_829C53E8(ctx, base);
	// 829C5980: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5984: 81460324  lwz r10, 0x324(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(804 as u32) ) } as u64;
	// 829C5988: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829C598C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C5990: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 829C5994: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C5998: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829C599C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C59A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C59A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C59A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C59B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C59B0 size=184
    let mut pc: u32 = 0x829C59B0;
    'dispatch: loop {
        match pc {
            0x829C59B0 => {
    //   block [0x829C59B0..0x829C5A68)
	// 829C59B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C59B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C59B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C59BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C59C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C59C4: 80A60314  lwz r5, 0x314(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(788 as u32) ) } as u64;
	// 829C59C8: 4BFFFA21  bl 0x829c53e8
	ctx.lr = 0x829C59CC;
	sub_829C53E8(ctx, base);
	// 829C59CC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C59D0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 829C59D4: 3BEBB184  addi r31, r11, -0x4e7c
	ctx.r[31].s64 = ctx.r[11].s64 + -20092;
	// 829C59D8: 4198000C  blt cr6, 0x829c59e4
	if ctx.cr[6].lt {
	pc = 0x829C59E4; continue 'dispatch;
	}
	// 829C59DC: 419A001C  beq cr6, 0x829c59f8
	if ctx.cr[6].eq {
	pc = 0x829C59F8; continue 'dispatch;
	}
	// 829C59E0: 4800002C  b 0x829c5a0c
	pc = 0x829C5A0C; continue 'dispatch;
	// 829C59E4: 816602B0  lwz r11, 0x2b0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C59E8: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 829C59EC: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 829C59F0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C59F4: 7CAB2850  subf r5, r11, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 829C59F8: 816602B0  lwz r11, 0x2b0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C59FC: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 829C5A00: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 829C5A04: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C5A08: 7CAB2850  subf r5, r11, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 829C5A0C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 829C5A10: 4BFFF9D9  bl 0x829c53e8
	ctx.lr = 0x829C5A14;
	sub_829C53E8(ctx, base);
	// 829C5A14: 7CAA07B4  extsw r10, r5
	ctx.r[10].s64 = ctx.r[5].s32 as i64;
	// 829C5A18: 816602B0  lwz r11, 0x2b0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C5A1C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 829C5A20: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829C5A24: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829C5A28: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5A2C: 7D6BFAAA  lwax r11, r11, r31
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as i32) as i64;
	// 829C5A30: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C5A34: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829C5A38: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C5A3C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C5A40: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829C5A44: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829C5A48: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829C5A4C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829C5A50: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829C5A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C5A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5A60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5A64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5A68 size=20
    let mut pc: u32 = 0x829C5A68;
    'dispatch: loop {
        match pc {
            0x829C5A68 => {
    //   block [0x829C5A68..0x829C5A7C)
	// 829C5A68: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 829C5A6C: 808300FC  lwz r4, 0xfc(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) } as u64;
	// 829C5A70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5A74: 41820008  beq 0x829c5a7c
	if ctx.cr[0].eq {
		sub_829C5A7C(ctx, base);
		return;
	}
	// 829C5A78: 4BB4C248  b 0x82511cc0
	sub_82511CC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5A7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5A7C size=4
    let mut pc: u32 = 0x829C5A7C;
    'dispatch: loop {
        match pc {
            0x829C5A7C => {
    //   block [0x829C5A7C..0x829C5A80)
	// 829C5A7C: 4BB4C224  b 0x82511ca0
	sub_82511CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5A80 size=136
    let mut pc: u32 = 0x829C5A80;
    'dispatch: loop {
        match pc {
            0x829C5A80 => {
    //   block [0x829C5A80..0x829C5B08)
	// 829C5A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C5A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5A94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C5A98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C5A9C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829C5AA0: 409A0020  bne cr6, 0x829c5ac0
	if !ctx.cr[6].eq {
	pc = 0x829C5AC0; continue 'dispatch;
	}
	// 829C5AA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C5AA8: 419A0048  beq cr6, 0x829c5af0
	if ctx.cr[6].eq {
	pc = 0x829C5AF0; continue 'dispatch;
	}
	// 829C5AAC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829C5AB0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829C5AB4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829C5AB8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829C5ABC: 48000034  b 0x829c5af0
	pc = 0x829C5AF0; continue 'dispatch;
	// 829C5AC0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829C5AC4: 419A002C  beq cr6, 0x829c5af0
	if ctx.cr[6].eq {
	pc = 0x829C5AF0; continue 'dispatch;
	}
	// 829C5AC8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C5ACC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5AD0: 388BBC08  addi r4, r11, -0x43f8
	ctx.r[4].s64 = ctx.r[11].s64 + -17400;
	// 829C5AD4: 487E2625  bl 0x831a80f8
	ctx.lr = 0x829C5AD8;
	sub_831A80F8(ctx, base);
	// 829C5AD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5ADC: 4182000C  beq 0x829c5ae8
	if ctx.cr[0].eq {
	pc = 0x829C5AE8; continue 'dispatch;
	}
	// 829C5AE0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829C5AE4: 4800000C  b 0x829c5af0
	pc = 0x829C5AF0; continue 'dispatch;
	// 829C5AE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C5AEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C5AF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C5AF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5AF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5AFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C5B00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5B08 size=132
    let mut pc: u32 = 0x829C5B08;
    'dispatch: loop {
        match pc {
            0x829C5B08 => {
    //   block [0x829C5B08..0x829C5B8C)
	// 829C5B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5B10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5B14: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C5B18: 896602BA  lbz r11, 0x2ba(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(698 as u32) ) } as u64;
	// 829C5B1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5B20: 41820054  beq 0x829c5b74
	if ctx.cr[0].eq {
	pc = 0x829C5B74; continue 'dispatch;
	}
	// 829C5B24: 4BFFF8C5  bl 0x829c53e8
	ctx.lr = 0x829C5B28;
	sub_829C53E8(ctx, base);
	// 829C5B28: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C5B2C: 8946031C  lbz r10, 0x31c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(796 as u32) ) } as u64;
	// 829C5B30: 396B352C  addi r11, r11, 0x352c
	ctx.r[11].s64 = ctx.r[11].s64 + 13612;
	// 829C5B34: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C5B38: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829C5B3C: 40980038  bge cr6, 0x829c5b74
	if !ctx.cr[6].lt {
	pc = 0x829C5B74; continue 'dispatch;
	}
	// 829C5B40: 896601EC  lbz r11, 0x1ec(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(492 as u32) ) } as u64;
	// 829C5B44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5B48: 40820024  bne 0x829c5b6c
	if !ctx.cr[0].eq {
	pc = 0x829C5B6C; continue 'dispatch;
	}
	// 829C5B4C: 896601ED  lbz r11, 0x1ed(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(493 as u32) ) } as u64;
	// 829C5B50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5B54: 41820020  beq 0x829c5b74
	if ctx.cr[0].eq {
	pc = 0x829C5B74; continue 'dispatch;
	}
	// 829C5B58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C5B5C: C1A601F4  lfs f13, 0x1f4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(500 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5B60: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5B64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829C5B68: 4199000C  bgt cr6, 0x829c5b74
	if ctx.cr[6].gt {
	pc = 0x829C5B74; continue 'dispatch;
	}
	// 829C5B6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C5B70: 48000008  b 0x829c5b78
	pc = 0x829C5B78; continue 'dispatch;
	// 829C5B74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C5B78: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C5B7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5B80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5B84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C5B90 size=24
    let mut pc: u32 = 0x829C5B90;
    'dispatch: loop {
        match pc {
            0x829C5B90 => {
    //   block [0x829C5B90..0x829C5BA8)
	// 829C5B90: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5B94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C5B98: 41820010  beq 0x829c5ba8
	if ctx.cr[0].eq {
		sub_829C5BA8(ctx, base);
		return;
	}
	// 829C5B9C: 396B38F0  addi r11, r11, 0x38f0
	ctx.r[11].s64 = ctx.r[11].s64 + 14576;
	// 829C5BA0: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5BA4: 48000008  b 0x829c5bac
	sub_829C5BA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C5BA8 size=44
    let mut pc: u32 = 0x829C5BA8;
    'dispatch: loop {
        match pc {
            0x829C5BA8 => {
    //   block [0x829C5BA8..0x829C5BD4)
	// 829C5BA8: C00B38F0  lfs f0, 0x38f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14576 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5BAC: 39630288  addi r11, r3, 0x288
	ctx.r[11].s64 = ctx.r[3].s64 + 648;
	// 829C5BB0: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 829C5BB4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5BB8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829C5BBC: 419A0008  beq cr6, 0x829c5bc4
	if ctx.cr[6].eq {
	pc = 0x829C5BC4; continue 'dispatch;
	}
	// 829C5BC0: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829C5BC4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829C5BC8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829C5BCC: 4082FFE8  bne 0x829c5bb4
	if !ctx.cr[0].eq {
	pc = 0x829C5BB4; continue 'dispatch;
	}
	// 829C5BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5BD8 size=152
    let mut pc: u32 = 0x829C5BD8;
    'dispatch: loop {
        match pc {
            0x829C5BD8 => {
    //   block [0x829C5BD8..0x829C5C70)
	// 829C5BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C5BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5BEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C5BF0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829C5BF4: 4BFFF7F5  bl 0x829c53e8
	ctx.lr = 0x829C5BF8;
	sub_829C53E8(ctx, base);
	// 829C5BF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C5BFC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C5C00: 396B3510  addi r11, r11, 0x3510
	ctx.r[11].s64 = ctx.r[11].s64 + 13584;
	// 829C5C04: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 829C5C08: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829C5C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5C10: 7D8A5C2E  lfsx f12, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C5C14: C0096218  lfs f0, 0x6218(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5C18: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5C1C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 829C5C20: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829C5C24: 7C0027AE  stfiwx f0, 0, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32, tmp.u32) };
	// 829C5C28: 4BFFF7C1  bl 0x829c53e8
	ctx.lr = 0x829C5C2C;
	sub_829C53E8(ctx, base);
	// 829C5C2C: 817F02B0  lwz r11, 0x2b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(688 as u32) ) } as u64;
	// 829C5C30: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829C5C34: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829C5C38: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829C5C3C: 394AB184  addi r10, r10, -0x4e7c
	ctx.r[10].s64 = ctx.r[10].s64 + -20092;
	// 829C5C40: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5C48: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829C5C4C: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C5C50: 4BFFF9F9  bl 0x829c5648
	ctx.lr = 0x829C5C54;
	sub_829C5648(ctx, base);
	// 829C5C54: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 829C5C58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C5C5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5C60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5C64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C5C68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5C6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5C70 size=96
    let mut pc: u32 = 0x829C5C70;
    'dispatch: loop {
        match pc {
            0x829C5C70 => {
    //   block [0x829C5C70..0x829C5CD0)
	// 829C5C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5C78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5C7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829C5C80: 88A6031C  lbz r5, 0x31c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(796 as u32) ) } as u64;
	// 829C5C84: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5C88: 41820038  beq 0x829c5cc0
	if ctx.cr[0].eq {
	pc = 0x829C5CC0; continue 'dispatch;
	}
	// 829C5C8C: 4BFFF75D  bl 0x829c53e8
	ctx.lr = 0x829C5C90;
	sub_829C53E8(ctx, base);
	// 829C5C90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C5C94: 396B352C  addi r11, r11, 0x352c
	ctx.r[11].s64 = ctx.r[11].s64 + 13612;
	// 829C5C98: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C5C9C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829C5CA0: 40980020  bge cr6, 0x829c5cc0
	if !ctx.cr[6].lt {
	pc = 0x829C5CC0; continue 'dispatch;
	}
	// 829C5CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C5CA8: C0060320  lfs f0, 0x320(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5CAC: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C5CB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829C5CB4: 4099000C  ble cr6, 0x829c5cc0
	if !ctx.cr[6].gt {
	pc = 0x829C5CC0; continue 'dispatch;
	}
	// 829C5CB8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 829C5CBC: D0060320  stfs f0, 0x320(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(800 as u32), tmp.u32 ) };
	// 829C5CC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5CCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5CD0 size=160
    let mut pc: u32 = 0x829C5CD0;
    'dispatch: loop {
        match pc {
            0x829C5CD0 => {
    //   block [0x829C5CD0..0x829C5D70)
	// 829C5CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5CD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5CDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C5CE4: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 829C5CE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5CEC: 40820070  bne 0x829c5d5c
	if !ctx.cr[0].eq {
	pc = 0x829C5D5C; continue 'dispatch;
	}
	// 829C5CF0: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5CF4: 41820050  beq 0x829c5d44
	if ctx.cr[0].eq {
	pc = 0x829C5D44; continue 'dispatch;
	}
	// 829C5CF8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 829C5CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C5D00: 419A0044  beq cr6, 0x829c5d44
	if ctx.cr[6].eq {
	pc = 0x829C5D44; continue 'dispatch;
	}
	// 829C5D04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5D08: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829C5D0C: 409A0018  bne cr6, 0x829c5d24
	if !ctx.cr[6].eq {
	pc = 0x829C5D24; continue 'dispatch;
	}
	// 829C5D10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5D14: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829C5D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C5D1C: 4E800421  bctrl
	ctx.lr = 0x829C5D20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C5D20: 48000030  b 0x829c5d50
	pc = 0x829C5D50; continue 'dispatch;
	// 829C5D24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C5D28: 484BBA19  bl 0x82e81740
	ctx.lr = 0x829C5D2C;
	sub_82E81740(ctx, base);
	// 829C5D2C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829C5D30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5D34: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829C5D38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C5D3C: 4E800421  bctrl
	ctx.lr = 0x829C5D40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C5D40: 4800001C  b 0x829c5d5c
	pc = 0x829C5D5C; continue 'dispatch;
	// 829C5D44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C5D48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5D4C: 484BB9F5  bl 0x82e81740
	ctx.lr = 0x829C5D50;
	sub_82E81740(ctx, base);
	// 829C5D50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C5D54: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829C5D58: 484BB9E9  bl 0x82e81740
	ctx.lr = 0x829C5D5C;
	sub_82E81740(ctx, base);
	// 829C5D5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5D60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5D64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5D68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5D70 size=72
    let mut pc: u32 = 0x829C5D70;
    'dispatch: loop {
        match pc {
            0x829C5D70 => {
    //   block [0x829C5D70..0x829C5DB8)
	// 829C5D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5D78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C5D7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C5D84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C5D88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C5D8C: 997F0040  stb r11, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 829C5D90: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C5D94: 484BB9AD  bl 0x82e81740
	ctx.lr = 0x829C5D98;
	sub_82E81740(ctx, base);
	// 829C5D98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C5D9C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829C5DA0: 484BB9A1  bl 0x82e81740
	ctx.lr = 0x829C5DA4;
	sub_82E81740(ctx, base);
	// 829C5DA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C5DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C5DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C5DB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C5DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5DB8 size=108
    let mut pc: u32 = 0x829C5DB8;
    'dispatch: loop {
        match pc {
            0x829C5DB8 => {
    //   block [0x829C5DB8..0x829C5E24)
	// 829C5DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5DBC: 487E23B1  bl 0x831a816c
	ctx.lr = 0x829C5DC0;
	sub_831A8130(ctx, base);
	// 829C5DC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5DC4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829C5DC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C5DCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C5DD0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5DD4: 41820038  beq 0x829c5e0c
	if ctx.cr[0].eq {
	pc = 0x829C5E0C; continue 'dispatch;
	}
	// 829C5DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5DDC: 487E3BAD  bl 0x831a9988
	ctx.lr = 0x829C5DE0;
	sub_831A9988(ctx, base);
	// 829C5DE0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C5DE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C5DE8: 386BB378  addi r3, r11, -0x4c88
	ctx.r[3].s64 = ctx.r[11].s64 + -19592;
	// 829C5DEC: 487E230D  bl 0x831a80f8
	ctx.lr = 0x829C5DF0;
	sub_831A80F8(ctx, base);
	// 829C5DF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5DF4: 41820018  beq 0x829c5e0c
	if ctx.cr[0].eq {
	pc = 0x829C5E0C; continue 'dispatch;
	}
	// 829C5DF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5DFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C5E00: 48017319  bl 0x829dd118
	ctx.lr = 0x829C5E04;
	sub_829DD118(ctx, base);
	// 829C5E04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829C5E08: 48000014  b 0x829c5e1c
	pc = 0x829C5E1C; continue 'dispatch;
	// 829C5E0C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829C5E10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5E14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C5E18: 487B8671  bl 0x8317e488
	ctx.lr = 0x829C5E1C;
	sub_8317E488(ctx, base);
	// 829C5E1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C5E20: 487E239C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5E28 size=12
    let mut pc: u32 = 0x829C5E28;
    'dispatch: loop {
        match pc {
            0x829C5E28 => {
    //   block [0x829C5E28..0x829C5E34)
	// 829C5E28: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 829C5E2C: 41980028  blt cr6, 0x829c5e54
	if ctx.cr[6].lt {
		sub_829C5E54(ctx, base);
		return;
	}
	// 829C5E30: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5E34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C5E34 size=32
    let mut pc: u32 = 0x829C5E34;
    'dispatch: loop {
        match pc {
            0x829C5E34 => {
    //   block [0x829C5E34..0x829C5E54)
	// 829C5E34: 8163026C  lwz r11, 0x26c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(620 as u32) ) } as u64;
	// 829C5E38: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5E3C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 829C5E40: 816B024C  lwz r11, 0x24c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(588 as u32) ) } as u64;
	// 829C5E44: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829C5E48: C00B0028  lfs f0, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5E4C: D0030270  stfs f0, 0x270(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 829C5E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5E54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C5E54 size=12
    let mut pc: u32 = 0x829C5E54;
    'dispatch: loop {
        match pc {
            0x829C5E54 => {
    //   block [0x829C5E54..0x829C5E60)
	// 829C5E54: 8163026C  lwz r11, 0x26c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(620 as u32) ) } as u64;
	// 829C5E58: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829C5E5C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829C5E60 size=48
    let mut pc: u32 = 0x829C5E60;
    'dispatch: loop {
        match pc {
            0x829C5E60 => {
    //   block [0x829C5E60..0x829C5E90)
	// 829C5E60: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C5E64: 9083026C  stw r4, 0x26c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(620 as u32), ctx.r[4].u32 ) };
	// 829C5E68: 81430264  lwz r10, 0x264(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(612 as u32) ) } as u64;
	// 829C5E6C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 829C5E70: 816B024C  lwz r11, 0x24c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(588 as u32) ) } as u64;
	// 829C5E74: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829C5E78: C00B0028  lfs f0, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5E7C: D0030270  stfs f0, 0x270(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 829C5E80: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 829C5E84: C00B0028  lfs f0, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C5E88: D0030274  stfs f0, 0x274(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(628 as u32), tmp.u32 ) };
	// 829C5E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C5E90 size=128
    let mut pc: u32 = 0x829C5E90;
    'dispatch: loop {
        match pc {
            0x829C5E90 => {
    //   block [0x829C5E90..0x829C5F10)
	// 829C5E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5E94: 487E22D9  bl 0x831a816c
	ctx.lr = 0x829C5E98;
	sub_831A8130(ctx, base);
	// 829C5E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C5EA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C5EA4: 4BFFF96D  bl 0x829c5810
	ctx.lr = 0x829C5EA8;
	sub_829C5810(ctx, base);
	// 829C5EA8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829C5EAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C5EB0: 4182000C  beq 0x829c5ebc
	if ctx.cr[0].eq {
	pc = 0x829C5EBC; continue 'dispatch;
	}
	// 829C5EB4: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 829C5EB8: 4800000C  b 0x829c5ec4
	pc = 0x829C5EC4; continue 'dispatch;
	// 829C5EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C5EC0: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 829C5EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C5EC8: 4BB4BC21  bl 0x82511ae8
	ctx.lr = 0x829C5ECC;
	sub_82511AE8(ctx, base);
	// 829C5ECC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 829C5ED0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C5ED4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C5ED8: 396BB158  addi r11, r11, -0x4ea8
	ctx.r[11].s64 = ctx.r[11].s64 + -20136;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5F10 size=220
    let mut pc: u32 = 0x829C5F10;
    'dispatch: loop {
        match pc {
            0x829C5F10 => {
    //   block [0x829C5F10..0x829C5FEC)
	// 829C5F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5F14: 487E2255  bl 0x831a8168
	ctx.lr = 0x829C5F18;
	sub_831A8130(ctx, base);
	// 829C5F18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C5F1C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829C5F20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C5F24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C5F28: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829C5F2C: 41820038  beq 0x829c5f64
	if ctx.cr[0].eq {
	pc = 0x829C5F64; continue 'dispatch;
	}
	// 829C5F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5F34: 487E3A55  bl 0x831a9988
	ctx.lr = 0x829C5F38;
	sub_831A9988(ctx, base);
	// 829C5F38: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829C5F3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C5F40: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829C5F44: 487E21B5  bl 0x831a80f8
	ctx.lr = 0x829C5F48;
	sub_831A80F8(ctx, base);
	// 829C5F48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5F4C: 41820018  beq 0x829c5f64
	if ctx.cr[0].eq {
	pc = 0x829C5F64; continue 'dispatch;
	}
	// 829C5F50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5F54: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829C5F58: 4BC9B791  bl 0x826616e8
	ctx.lr = 0x829C5F5C;
	sub_826616E8(ctx, base);
	// 829C5F5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829C5F60: 48000084  b 0x829c5fe4
	pc = 0x829C5FE4; continue 'dispatch;
	// 829C5F64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C5F68: 419A006C  beq cr6, 0x829c5fd4
	if ctx.cr[6].eq {
	pc = 0x829C5FD4; continue 'dispatch;
	}
	// 829C5F6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5F70: 487E3A19  bl 0x831a9988
	ctx.lr = 0x829C5F74;
	sub_831A9988(ctx, base);
	// 829C5F74: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 829C5F78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C5F7C: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 829C5F80: 487E2179  bl 0x831a80f8
	ctx.lr = 0x829C5F84;
	sub_831A80F8(ctx, base);
	// 829C5F84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5F88: 41820014  beq 0x829c5f9c
	if ctx.cr[0].eq {
	pc = 0x829C5F9C; continue 'dispatch;
	}
	// 829C5F8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5F90: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829C5F94: 4BCDB3C5  bl 0x826a1358
	ctx.lr = 0x829C5F98;
	sub_826A1358(ctx, base);
	// 829C5F98: 4BFFFFC4  b 0x829c5f5c
	pc = 0x829C5F5C; continue 'dispatch;
	// 829C5F9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C5FA0: 419A0034  beq cr6, 0x829c5fd4
	if ctx.cr[6].eq {
	pc = 0x829C5FD4; continue 'dispatch;
	}
	// 829C5FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C5FA8: 487E39E1  bl 0x831a9988
	ctx.lr = 0x829C5FAC;
	sub_831A9988(ctx, base);
	// 829C5FAC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C5FB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C5FB4: 386BBD10  addi r3, r11, -0x42f0
	ctx.r[3].s64 = ctx.r[11].s64 + -17136;
	// 829C5FB8: 487E2141  bl 0x831a80f8
	ctx.lr = 0x829C5FBC;
	sub_831A80F8(ctx, base);
	// 829C5FBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C5FC0: 41820014  beq 0x829c5fd4
	if ctx.cr[0].eq {
	pc = 0x829C5FD4; continue 'dispatch;
	}
	// 829C5FC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5FC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829C5FCC: 4BFFFA9D  bl 0x829c5a68
	ctx.lr = 0x829C5FD0;
	sub_829C5A68(ctx, base);
	// 829C5FD0: 4BFFFF8C  b 0x829c5f5c
	pc = 0x829C5F5C; continue 'dispatch;
	// 829C5FD4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829C5FD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C5FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C5FE0: 4BB4C639  bl 0x82512618
	ctx.lr = 0x829C5FE4;
	sub_82512618(ctx, base);
	// 829C5FE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C5FE8: 487E21D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C5FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C5FF0 size=196
    let mut pc: u32 = 0x829C5FF0;
    'dispatch: loop {
        match pc {
            0x829C5FF0 => {
    //   block [0x829C5FF0..0x829C60B4)
	// 829C5FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C5FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C5FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C5FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C600C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6010: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6014: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6018: 4B8FA921  bl 0x822c0938
	ctx.lr = 0x829C601C;
	sub_822C0938(ctx, base);
	// 829C601C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6020: 41820028  beq 0x829c6048
	if ctx.cr[0].eq {
	pc = 0x829C6048; continue 'dispatch;
	}
	// 829C6024: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6028: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C602C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6030: 392B3D74  addi r9, r11, 0x3d74
	ctx.r[9].s64 = ctx.r[11].s64 + 15732;
	// 829C6034: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6038: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C603C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6040: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6044: 48000008  b 0x829c604c
	pc = 0x829C604C; continue 'dispatch;
	// 829C6048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C604C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6054: 409A0044  bne cr6, 0x829c6098
	if !ctx.cr[6].eq {
	pc = 0x829C6098; continue 'dispatch;
	}
	// 829C6058: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C605C: 419A001C  beq cr6, 0x829c6078
	if ctx.cr[6].eq {
	pc = 0x829C6078; continue 'dispatch;
	}
	// 829C6060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6064: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C606C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6074: 4E800421  bctrl
	ctx.lr = 0x829C6078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6078: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C607C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6084: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6088: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C608C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6094: 4B8F9F6D  bl 0x822c0000
	ctx.lr = 0x829C6098;
	sub_822C0000(ctx, base);
	// 829C6098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C609C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C60A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C60A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C60A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C60AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C60B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C60B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C60B8 size=196
    let mut pc: u32 = 0x829C60B8;
    'dispatch: loop {
        match pc {
            0x829C60B8 => {
    //   block [0x829C60B8..0x829C617C)
	// 829C60B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C60BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C60C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C60C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C60C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C60CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C60D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C60D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C60D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C60DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C60E0: 4B8FA859  bl 0x822c0938
	ctx.lr = 0x829C60E4;
	sub_822C0938(ctx, base);
	// 829C60E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C60E8: 41820028  beq 0x829c6110
	if ctx.cr[0].eq {
	pc = 0x829C6110; continue 'dispatch;
	}
	// 829C60EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C60F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C60F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C60F8: 392B3D88  addi r9, r11, 0x3d88
	ctx.r[9].s64 = ctx.r[11].s64 + 15752;
	// 829C60FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6100: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6104: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6108: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C610C: 48000008  b 0x829c6114
	pc = 0x829C6114; continue 'dispatch;
	// 829C6110: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6114: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C611C: 409A0044  bne cr6, 0x829c6160
	if !ctx.cr[6].eq {
	pc = 0x829C6160; continue 'dispatch;
	}
	// 829C6120: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6124: 419A001C  beq cr6, 0x829c6140
	if ctx.cr[6].eq {
	pc = 0x829C6140; continue 'dispatch;
	}
	// 829C6128: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C612C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6134: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C613C: 4E800421  bctrl
	ctx.lr = 0x829C6140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6140: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6144: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C614C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6150: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6154: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6158: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C615C: 4B8F9EA5  bl 0x822c0000
	ctx.lr = 0x829C6160;
	sub_822C0000(ctx, base);
	// 829C6160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6164: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C616C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6170: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6174: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6180 size=196
    let mut pc: u32 = 0x829C6180;
    'dispatch: loop {
        match pc {
            0x829C6180 => {
    //   block [0x829C6180..0x829C6244)
	// 829C6180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C618C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C619C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C61A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C61A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C61A8: 4B8FA791  bl 0x822c0938
	ctx.lr = 0x829C61AC;
	sub_822C0938(ctx, base);
	// 829C61AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C61B0: 41820028  beq 0x829c61d8
	if ctx.cr[0].eq {
	pc = 0x829C61D8; continue 'dispatch;
	}
	// 829C61B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C61B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C61BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C61C0: 392B3D9C  addi r9, r11, 0x3d9c
	ctx.r[9].s64 = ctx.r[11].s64 + 15772;
	// 829C61C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C61C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C61CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C61D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C61D4: 48000008  b 0x829c61dc
	pc = 0x829C61DC; continue 'dispatch;
	// 829C61D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C61DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C61E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C61E4: 409A0044  bne cr6, 0x829c6228
	if !ctx.cr[6].eq {
	pc = 0x829C6228; continue 'dispatch;
	}
	// 829C61E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C61EC: 419A001C  beq cr6, 0x829c6208
	if ctx.cr[6].eq {
	pc = 0x829C6208; continue 'dispatch;
	}
	// 829C61F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C61F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C61F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C61FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6204: 4E800421  bctrl
	ctx.lr = 0x829C6208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6208: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C620C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6214: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6218: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C621C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6220: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6224: 4B8F9DDD  bl 0x822c0000
	ctx.lr = 0x829C6228;
	sub_822C0000(ctx, base);
	// 829C6228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C622C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6230: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6234: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6238: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C623C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6248 size=196
    let mut pc: u32 = 0x829C6248;
    'dispatch: loop {
        match pc {
            0x829C6248 => {
    //   block [0x829C6248..0x829C630C)
	// 829C6248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C624C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C625C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6260: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6264: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6268: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C626C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6270: 4B8FA6C9  bl 0x822c0938
	ctx.lr = 0x829C6274;
	sub_822C0938(ctx, base);
	// 829C6274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6278: 41820028  beq 0x829c62a0
	if ctx.cr[0].eq {
	pc = 0x829C62A0; continue 'dispatch;
	}
	// 829C627C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6280: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6288: 392B3DB0  addi r9, r11, 0x3db0
	ctx.r[9].s64 = ctx.r[11].s64 + 15792;
	// 829C628C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6290: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6294: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6298: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C629C: 48000008  b 0x829c62a4
	pc = 0x829C62A4; continue 'dispatch;
	// 829C62A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C62A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C62A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C62AC: 409A0044  bne cr6, 0x829c62f0
	if !ctx.cr[6].eq {
	pc = 0x829C62F0; continue 'dispatch;
	}
	// 829C62B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C62B4: 419A001C  beq cr6, 0x829c62d0
	if ctx.cr[6].eq {
	pc = 0x829C62D0; continue 'dispatch;
	}
	// 829C62B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C62BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C62C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C62C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C62C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C62CC: 4E800421  bctrl
	ctx.lr = 0x829C62D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C62D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C62D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C62D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C62DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C62E0: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C62E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C62E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C62EC: 4B8F9D15  bl 0x822c0000
	ctx.lr = 0x829C62F0;
	sub_822C0000(ctx, base);
	// 829C62F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C62F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C62F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C62FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6310 size=196
    let mut pc: u32 = 0x829C6310;
    'dispatch: loop {
        match pc {
            0x829C6310 => {
    //   block [0x829C6310..0x829C63D4)
	// 829C6310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C631C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6328: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C632C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6334: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6338: 4B8FA601  bl 0x822c0938
	ctx.lr = 0x829C633C;
	sub_822C0938(ctx, base);
	// 829C633C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6340: 41820028  beq 0x829c6368
	if ctx.cr[0].eq {
	pc = 0x829C6368; continue 'dispatch;
	}
	// 829C6344: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6348: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C634C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6350: 392B3DD8  addi r9, r11, 0x3dd8
	ctx.r[9].s64 = ctx.r[11].s64 + 15832;
	// 829C6354: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6358: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C635C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6360: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6364: 48000008  b 0x829c636c
	pc = 0x829C636C; continue 'dispatch;
	// 829C6368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C636C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6374: 409A0044  bne cr6, 0x829c63b8
	if !ctx.cr[6].eq {
	pc = 0x829C63B8; continue 'dispatch;
	}
	// 829C6378: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C637C: 419A001C  beq cr6, 0x829c6398
	if ctx.cr[6].eq {
	pc = 0x829C6398; continue 'dispatch;
	}
	// 829C6380: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6384: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C638C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6394: 4E800421  bctrl
	ctx.lr = 0x829C6398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6398: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C639C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C63A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C63A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C63A8: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C63AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C63B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C63B4: 4B8F9C4D  bl 0x822c0000
	ctx.lr = 0x829C63B8;
	sub_822C0000(ctx, base);
	// 829C63B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C63BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C63C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C63C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C63C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C63CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C63D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C63D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C63D8 size=196
    let mut pc: u32 = 0x829C63D8;
    'dispatch: loop {
        match pc {
            0x829C63D8 => {
    //   block [0x829C63D8..0x829C649C)
	// 829C63D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C63DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C63E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C63E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C63E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C63EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C63F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C63F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C63F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C63FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6400: 4B8FA539  bl 0x822c0938
	ctx.lr = 0x829C6404;
	sub_822C0938(ctx, base);
	// 829C6404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6408: 41820028  beq 0x829c6430
	if ctx.cr[0].eq {
	pc = 0x829C6430; continue 'dispatch;
	}
	// 829C640C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6410: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6418: 392B3DEC  addi r9, r11, 0x3dec
	ctx.r[9].s64 = ctx.r[11].s64 + 15852;
	// 829C641C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6424: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6428: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C642C: 48000008  b 0x829c6434
	pc = 0x829C6434; continue 'dispatch;
	// 829C6430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6434: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C643C: 409A0044  bne cr6, 0x829c6480
	if !ctx.cr[6].eq {
	pc = 0x829C6480; continue 'dispatch;
	}
	// 829C6440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6444: 419A001C  beq cr6, 0x829c6460
	if ctx.cr[6].eq {
	pc = 0x829C6460; continue 'dispatch;
	}
	// 829C6448: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C644C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6454: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C645C: 4E800421  bctrl
	ctx.lr = 0x829C6460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6460: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6464: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C646C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6470: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6474: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6478: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C647C: 4B8F9B85  bl 0x822c0000
	ctx.lr = 0x829C6480;
	sub_822C0000(ctx, base);
	// 829C6480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C648C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C64A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C64A0 size=196
    let mut pc: u32 = 0x829C64A0;
    'dispatch: loop {
        match pc {
            0x829C64A0 => {
    //   block [0x829C64A0..0x829C6564)
	// 829C64A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C64A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C64A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C64AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C64B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C64B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C64B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C64BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C64C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C64C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C64C8: 4B8FA471  bl 0x822c0938
	ctx.lr = 0x829C64CC;
	sub_822C0938(ctx, base);
	// 829C64CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C64D0: 41820028  beq 0x829c64f8
	if ctx.cr[0].eq {
	pc = 0x829C64F8; continue 'dispatch;
	}
	// 829C64D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C64D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C64DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C64E0: 392B3E00  addi r9, r11, 0x3e00
	ctx.r[9].s64 = ctx.r[11].s64 + 15872;
	// 829C64E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C64E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C64EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C64F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C64F4: 48000008  b 0x829c64fc
	pc = 0x829C64FC; continue 'dispatch;
	// 829C64F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C64FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6504: 409A0044  bne cr6, 0x829c6548
	if !ctx.cr[6].eq {
	pc = 0x829C6548; continue 'dispatch;
	}
	// 829C6508: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C650C: 419A001C  beq cr6, 0x829c6528
	if ctx.cr[6].eq {
	pc = 0x829C6528; continue 'dispatch;
	}
	// 829C6510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6514: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C651C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6524: 4E800421  bctrl
	ctx.lr = 0x829C6528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6528: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C652C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6534: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6538: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C653C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6540: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6544: 4B8F9ABD  bl 0x822c0000
	ctx.lr = 0x829C6548;
	sub_822C0000(ctx, base);
	// 829C6548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C654C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6558: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C655C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6568 size=196
    let mut pc: u32 = 0x829C6568;
    'dispatch: loop {
        match pc {
            0x829C6568 => {
    //   block [0x829C6568..0x829C662C)
	// 829C6568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C656C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C657C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6580: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6584: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6588: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C658C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6590: 4B8FA3A9  bl 0x822c0938
	ctx.lr = 0x829C6594;
	sub_822C0938(ctx, base);
	// 829C6594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6598: 41820028  beq 0x829c65c0
	if ctx.cr[0].eq {
	pc = 0x829C65C0; continue 'dispatch;
	}
	// 829C659C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C65A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C65A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C65A8: 392B3E14  addi r9, r11, 0x3e14
	ctx.r[9].s64 = ctx.r[11].s64 + 15892;
	// 829C65AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C65B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C65B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C65B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C65BC: 48000008  b 0x829c65c4
	pc = 0x829C65C4; continue 'dispatch;
	// 829C65C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C65C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C65C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C65CC: 409A0044  bne cr6, 0x829c6610
	if !ctx.cr[6].eq {
	pc = 0x829C6610; continue 'dispatch;
	}
	// 829C65D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C65D4: 419A001C  beq cr6, 0x829c65f0
	if ctx.cr[6].eq {
	pc = 0x829C65F0; continue 'dispatch;
	}
	// 829C65D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C65DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C65E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C65E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C65E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C65EC: 4E800421  bctrl
	ctx.lr = 0x829C65F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C65F0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C65F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C65F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C65FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6600: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6604: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6608: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C660C: 4B8F99F5  bl 0x822c0000
	ctx.lr = 0x829C6610;
	sub_822C0000(ctx, base);
	// 829C6610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C661C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6630 size=196
    let mut pc: u32 = 0x829C6630;
    'dispatch: loop {
        match pc {
            0x829C6630 => {
    //   block [0x829C6630..0x829C66F4)
	// 829C6630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C663C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C664C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6650: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6654: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6658: 4B8FA2E1  bl 0x822c0938
	ctx.lr = 0x829C665C;
	sub_822C0938(ctx, base);
	// 829C665C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6660: 41820028  beq 0x829c6688
	if ctx.cr[0].eq {
	pc = 0x829C6688; continue 'dispatch;
	}
	// 829C6664: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6668: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C666C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6670: 392B3E28  addi r9, r11, 0x3e28
	ctx.r[9].s64 = ctx.r[11].s64 + 15912;
	// 829C6674: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6678: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C667C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6680: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6684: 48000008  b 0x829c668c
	pc = 0x829C668C; continue 'dispatch;
	// 829C6688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C668C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6694: 409A0044  bne cr6, 0x829c66d8
	if !ctx.cr[6].eq {
	pc = 0x829C66D8; continue 'dispatch;
	}
	// 829C6698: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C669C: 419A001C  beq cr6, 0x829c66b8
	if ctx.cr[6].eq {
	pc = 0x829C66B8; continue 'dispatch;
	}
	// 829C66A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C66A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C66A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C66AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C66B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C66B4: 4E800421  bctrl
	ctx.lr = 0x829C66B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C66B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C66BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C66C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C66C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C66C8: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C66CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C66D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C66D4: 4B8F992D  bl 0x822c0000
	ctx.lr = 0x829C66D8;
	sub_822C0000(ctx, base);
	// 829C66D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C66DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C66E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C66E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C66E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C66EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C66F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C66F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C66F8 size=196
    let mut pc: u32 = 0x829C66F8;
    'dispatch: loop {
        match pc {
            0x829C66F8 => {
    //   block [0x829C66F8..0x829C67BC)
	// 829C66F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C66FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C670C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6714: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6718: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C671C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6720: 4B8FA219  bl 0x822c0938
	ctx.lr = 0x829C6724;
	sub_822C0938(ctx, base);
	// 829C6724: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6728: 41820028  beq 0x829c6750
	if ctx.cr[0].eq {
	pc = 0x829C6750; continue 'dispatch;
	}
	// 829C672C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6730: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6734: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6738: 392B3E3C  addi r9, r11, 0x3e3c
	ctx.r[9].s64 = ctx.r[11].s64 + 15932;
	// 829C673C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6740: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6744: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6748: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C674C: 48000008  b 0x829c6754
	pc = 0x829C6754; continue 'dispatch;
	// 829C6750: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6754: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C675C: 409A0044  bne cr6, 0x829c67a0
	if !ctx.cr[6].eq {
	pc = 0x829C67A0; continue 'dispatch;
	}
	// 829C6760: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6764: 419A001C  beq cr6, 0x829c6780
	if ctx.cr[6].eq {
	pc = 0x829C6780; continue 'dispatch;
	}
	// 829C6768: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C676C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6774: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6778: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C677C: 4E800421  bctrl
	ctx.lr = 0x829C6780;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6780: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6784: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C678C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6790: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6794: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6798: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C679C: 4B8F9865  bl 0x822c0000
	ctx.lr = 0x829C67A0;
	sub_822C0000(ctx, base);
	// 829C67A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C67A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C67A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C67AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C67B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C67B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C67B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C67C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C67C0 size=196
    let mut pc: u32 = 0x829C67C0;
    'dispatch: loop {
        match pc {
            0x829C67C0 => {
    //   block [0x829C67C0..0x829C6884)
	// 829C67C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C67C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C67C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C67CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C67D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C67D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C67D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C67DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C67E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C67E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C67E8: 4B8FA151  bl 0x822c0938
	ctx.lr = 0x829C67EC;
	sub_822C0938(ctx, base);
	// 829C67EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C67F0: 41820028  beq 0x829c6818
	if ctx.cr[0].eq {
	pc = 0x829C6818; continue 'dispatch;
	}
	// 829C67F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C67F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C67FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6800: 392B3E50  addi r9, r11, 0x3e50
	ctx.r[9].s64 = ctx.r[11].s64 + 15952;
	// 829C6804: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6808: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C680C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6810: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6814: 48000008  b 0x829c681c
	pc = 0x829C681C; continue 'dispatch;
	// 829C6818: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C681C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6824: 409A0044  bne cr6, 0x829c6868
	if !ctx.cr[6].eq {
	pc = 0x829C6868; continue 'dispatch;
	}
	// 829C6828: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C682C: 419A001C  beq cr6, 0x829c6848
	if ctx.cr[6].eq {
	pc = 0x829C6848; continue 'dispatch;
	}
	// 829C6830: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6834: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C683C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6844: 4E800421  bctrl
	ctx.lr = 0x829C6848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6848: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C684C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6854: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6858: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C685C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6860: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6864: 4B8F979D  bl 0x822c0000
	ctx.lr = 0x829C6868;
	sub_822C0000(ctx, base);
	// 829C6868: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C686C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6878: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C687C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6888 size=196
    let mut pc: u32 = 0x829C6888;
    'dispatch: loop {
        match pc {
            0x829C6888 => {
    //   block [0x829C6888..0x829C694C)
	// 829C6888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C688C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C689C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C68A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C68A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C68A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C68AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C68B0: 4B8FA089  bl 0x822c0938
	ctx.lr = 0x829C68B4;
	sub_822C0938(ctx, base);
	// 829C68B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C68B8: 41820028  beq 0x829c68e0
	if ctx.cr[0].eq {
	pc = 0x829C68E0; continue 'dispatch;
	}
	// 829C68BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C68C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C68C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C68C8: 392B3E64  addi r9, r11, 0x3e64
	ctx.r[9].s64 = ctx.r[11].s64 + 15972;
	// 829C68CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C68D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C68D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C68D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C68DC: 48000008  b 0x829c68e4
	pc = 0x829C68E4; continue 'dispatch;
	// 829C68E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C68E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C68E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C68EC: 409A0044  bne cr6, 0x829c6930
	if !ctx.cr[6].eq {
	pc = 0x829C6930; continue 'dispatch;
	}
	// 829C68F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C68F4: 419A001C  beq cr6, 0x829c6910
	if ctx.cr[6].eq {
	pc = 0x829C6910; continue 'dispatch;
	}
	// 829C68F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C68FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6904: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C690C: 4E800421  bctrl
	ctx.lr = 0x829C6910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6910: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6914: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C691C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6920: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6924: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6928: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C692C: 4B8F96D5  bl 0x822c0000
	ctx.lr = 0x829C6930;
	sub_822C0000(ctx, base);
	// 829C6930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C693C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6940: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6950 size=196
    let mut pc: u32 = 0x829C6950;
    'dispatch: loop {
        match pc {
            0x829C6950 => {
    //   block [0x829C6950..0x829C6A14)
	// 829C6950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C695C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C696C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6970: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6978: 4B8F9FC1  bl 0x822c0938
	ctx.lr = 0x829C697C;
	sub_822C0938(ctx, base);
	// 829C697C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6980: 41820028  beq 0x829c69a8
	if ctx.cr[0].eq {
	pc = 0x829C69A8; continue 'dispatch;
	}
	// 829C6984: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6988: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C698C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6990: 392B3E78  addi r9, r11, 0x3e78
	ctx.r[9].s64 = ctx.r[11].s64 + 15992;
	// 829C6994: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C699C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C69A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C69A4: 48000008  b 0x829c69ac
	pc = 0x829C69AC; continue 'dispatch;
	// 829C69A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C69AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C69B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C69B4: 409A0044  bne cr6, 0x829c69f8
	if !ctx.cr[6].eq {
	pc = 0x829C69F8; continue 'dispatch;
	}
	// 829C69B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C69BC: 419A001C  beq cr6, 0x829c69d8
	if ctx.cr[6].eq {
	pc = 0x829C69D8; continue 'dispatch;
	}
	// 829C69C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C69C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C69C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C69CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C69D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C69D4: 4E800421  bctrl
	ctx.lr = 0x829C69D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C69D8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C69DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C69E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C69E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C69E8: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C69EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C69F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C69F4: 4B8F960D  bl 0x822c0000
	ctx.lr = 0x829C69F8;
	sub_822C0000(ctx, base);
	// 829C69F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C69FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6A08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6A18 size=196
    let mut pc: u32 = 0x829C6A18;
    'dispatch: loop {
        match pc {
            0x829C6A18 => {
    //   block [0x829C6A18..0x829C6ADC)
	// 829C6A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6A2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6A34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6A38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6A3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6A40: 4B8F9EF9  bl 0x822c0938
	ctx.lr = 0x829C6A44;
	sub_822C0938(ctx, base);
	// 829C6A44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6A48: 41820028  beq 0x829c6a70
	if ctx.cr[0].eq {
	pc = 0x829C6A70; continue 'dispatch;
	}
	// 829C6A4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6A50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6A54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6A58: 392B3E8C  addi r9, r11, 0x3e8c
	ctx.r[9].s64 = ctx.r[11].s64 + 16012;
	// 829C6A5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6A60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6A64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6A68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6A6C: 48000008  b 0x829c6a74
	pc = 0x829C6A74; continue 'dispatch;
	// 829C6A70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6A74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6A7C: 409A0044  bne cr6, 0x829c6ac0
	if !ctx.cr[6].eq {
	pc = 0x829C6AC0; continue 'dispatch;
	}
	// 829C6A80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6A84: 419A001C  beq cr6, 0x829c6aa0
	if ctx.cr[6].eq {
	pc = 0x829C6AA0; continue 'dispatch;
	}
	// 829C6A88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6A8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6A94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C6A98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6A9C: 4E800421  bctrl
	ctx.lr = 0x829C6AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6AA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6AA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6AAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6AB0: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6AB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6AB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6ABC: 4B8F9545  bl 0x822c0000
	ctx.lr = 0x829C6AC0;
	sub_822C0000(ctx, base);
	// 829C6AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6AC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6AC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6ACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6AD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6AD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6AD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6AE0 size=196
    let mut pc: u32 = 0x829C6AE0;
    'dispatch: loop {
        match pc {
            0x829C6AE0 => {
    //   block [0x829C6AE0..0x829C6BA4)
	// 829C6AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6AE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6AEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6AF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6AFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6B00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6B04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6B08: 4B8F9E31  bl 0x822c0938
	ctx.lr = 0x829C6B0C;
	sub_822C0938(ctx, base);
	// 829C6B0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6B10: 41820028  beq 0x829c6b38
	if ctx.cr[0].eq {
	pc = 0x829C6B38; continue 'dispatch;
	}
	// 829C6B14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6B18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6B1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6B20: 392B3EA0  addi r9, r11, 0x3ea0
	ctx.r[9].s64 = ctx.r[11].s64 + 16032;
	// 829C6B24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6B28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6B2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6B30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6B34: 48000008  b 0x829c6b3c
	pc = 0x829C6B3C; continue 'dispatch;
	// 829C6B38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6B3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6B44: 409A0044  bne cr6, 0x829c6b88
	if !ctx.cr[6].eq {
	pc = 0x829C6B88; continue 'dispatch;
	}
	// 829C6B48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6B4C: 419A001C  beq cr6, 0x829c6b68
	if ctx.cr[6].eq {
	pc = 0x829C6B68; continue 'dispatch;
	}
	// 829C6B50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6B54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6B5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6B60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6B64: 4E800421  bctrl
	ctx.lr = 0x829C6B68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6B68: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6B6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6B70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6B74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6B78: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6B7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6B80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6B84: 4B8F947D  bl 0x822c0000
	ctx.lr = 0x829C6B88;
	sub_822C0000(ctx, base);
	// 829C6B88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6B8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6B98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6BA8 size=196
    let mut pc: u32 = 0x829C6BA8;
    'dispatch: loop {
        match pc {
            0x829C6BA8 => {
    //   block [0x829C6BA8..0x829C6C6C)
	// 829C6BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6BB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6BB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6BB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6BBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6BC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6BC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6BCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6BD0: 4B8F9D69  bl 0x822c0938
	ctx.lr = 0x829C6BD4;
	sub_822C0938(ctx, base);
	// 829C6BD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6BD8: 41820028  beq 0x829c6c00
	if ctx.cr[0].eq {
	pc = 0x829C6C00; continue 'dispatch;
	}
	// 829C6BDC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6BE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6BE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6BE8: 392B3EB4  addi r9, r11, 0x3eb4
	ctx.r[9].s64 = ctx.r[11].s64 + 16052;
	// 829C6BEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6BF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6BF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6BF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6BFC: 48000008  b 0x829c6c04
	pc = 0x829C6C04; continue 'dispatch;
	// 829C6C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6C04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6C0C: 409A0044  bne cr6, 0x829c6c50
	if !ctx.cr[6].eq {
	pc = 0x829C6C50; continue 'dispatch;
	}
	// 829C6C10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6C14: 419A001C  beq cr6, 0x829c6c30
	if ctx.cr[6].eq {
	pc = 0x829C6C30; continue 'dispatch;
	}
	// 829C6C18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6C1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6C24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6C28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6C2C: 4E800421  bctrl
	ctx.lr = 0x829C6C30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6C30: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6C34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6C38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6C3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6C40: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6C44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6C48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6C4C: 4B8F93B5  bl 0x822c0000
	ctx.lr = 0x829C6C50;
	sub_822C0000(ctx, base);
	// 829C6C50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6C54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6C58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6C5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6C60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6C64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6C68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6C70 size=196
    let mut pc: u32 = 0x829C6C70;
    'dispatch: loop {
        match pc {
            0x829C6C70 => {
    //   block [0x829C6C70..0x829C6D34)
	// 829C6C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6C80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6C84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6C8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6C90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6C94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6C98: 4B8F9CA1  bl 0x822c0938
	ctx.lr = 0x829C6C9C;
	sub_822C0938(ctx, base);
	// 829C6C9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6CA0: 41820028  beq 0x829c6cc8
	if ctx.cr[0].eq {
	pc = 0x829C6CC8; continue 'dispatch;
	}
	// 829C6CA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6CA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6CAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6CB0: 392B3EC8  addi r9, r11, 0x3ec8
	ctx.r[9].s64 = ctx.r[11].s64 + 16072;
	// 829C6CB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6CB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6CBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6CC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6CC4: 48000008  b 0x829c6ccc
	pc = 0x829C6CCC; continue 'dispatch;
	// 829C6CC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6CCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6CD4: 409A0044  bne cr6, 0x829c6d18
	if !ctx.cr[6].eq {
	pc = 0x829C6D18; continue 'dispatch;
	}
	// 829C6CD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6CDC: 419A001C  beq cr6, 0x829c6cf8
	if ctx.cr[6].eq {
	pc = 0x829C6CF8; continue 'dispatch;
	}
	// 829C6CE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6CE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6CEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6CF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6CF4: 4E800421  bctrl
	ctx.lr = 0x829C6CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6CF8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6CFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6D00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6D04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6D08: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6D0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6D10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6D14: 4B8F92ED  bl 0x822c0000
	ctx.lr = 0x829C6D18;
	sub_822C0000(ctx, base);
	// 829C6D18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6D1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6D28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6D2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6D30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6D38 size=196
    let mut pc: u32 = 0x829C6D38;
    'dispatch: loop {
        match pc {
            0x829C6D38 => {
    //   block [0x829C6D38..0x829C6DFC)
	// 829C6D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6D3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6D40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6D44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6D48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6D4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6D54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6D58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6D5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6D60: 4B8F9BD9  bl 0x822c0938
	ctx.lr = 0x829C6D64;
	sub_822C0938(ctx, base);
	// 829C6D64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6D68: 41820028  beq 0x829c6d90
	if ctx.cr[0].eq {
	pc = 0x829C6D90; continue 'dispatch;
	}
	// 829C6D6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6D70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6D74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6D78: 392B3F04  addi r9, r11, 0x3f04
	ctx.r[9].s64 = ctx.r[11].s64 + 16132;
	// 829C6D7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6D80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6D84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6D88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6D8C: 48000008  b 0x829c6d94
	pc = 0x829C6D94; continue 'dispatch;
	// 829C6D90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6D94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6D9C: 409A0044  bne cr6, 0x829c6de0
	if !ctx.cr[6].eq {
	pc = 0x829C6DE0; continue 'dispatch;
	}
	// 829C6DA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6DA4: 419A001C  beq cr6, 0x829c6dc0
	if ctx.cr[6].eq {
	pc = 0x829C6DC0; continue 'dispatch;
	}
	// 829C6DA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6DAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6DB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6DBC: 4E800421  bctrl
	ctx.lr = 0x829C6DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6DC0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6DC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6DC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6DCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6DD0: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6DD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6DD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6DDC: 4B8F9225  bl 0x822c0000
	ctx.lr = 0x829C6DE0;
	sub_822C0000(ctx, base);
	// 829C6DE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6DE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6DE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6DEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6DF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6DF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6DF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6E00 size=196
    let mut pc: u32 = 0x829C6E00;
    'dispatch: loop {
        match pc {
            0x829C6E00 => {
    //   block [0x829C6E00..0x829C6EC4)
	// 829C6E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6E10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6E1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6E20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6E24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6E28: 4B8F9B11  bl 0x822c0938
	ctx.lr = 0x829C6E2C;
	sub_822C0938(ctx, base);
	// 829C6E2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6E30: 41820028  beq 0x829c6e58
	if ctx.cr[0].eq {
	pc = 0x829C6E58; continue 'dispatch;
	}
	// 829C6E34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6E38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6E3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6E40: 392B3F18  addi r9, r11, 0x3f18
	ctx.r[9].s64 = ctx.r[11].s64 + 16152;
	// 829C6E44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6E48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6E4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6E50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6E54: 48000008  b 0x829c6e5c
	pc = 0x829C6E5C; continue 'dispatch;
	// 829C6E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6E5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6E64: 409A0044  bne cr6, 0x829c6ea8
	if !ctx.cr[6].eq {
	pc = 0x829C6EA8; continue 'dispatch;
	}
	// 829C6E68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6E6C: 419A001C  beq cr6, 0x829c6e88
	if ctx.cr[6].eq {
	pc = 0x829C6E88; continue 'dispatch;
	}
	// 829C6E70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6E74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6E7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6E80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6E84: 4E800421  bctrl
	ctx.lr = 0x829C6E88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6E88: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6E8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6E90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6E94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6E98: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6E9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6EA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6EA4: 4B8F915D  bl 0x822c0000
	ctx.lr = 0x829C6EA8;
	sub_822C0000(ctx, base);
	// 829C6EA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6EB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C6EC8 size=196
    let mut pc: u32 = 0x829C6EC8;
    'dispatch: loop {
        match pc {
            0x829C6EC8 => {
    //   block [0x829C6EC8..0x829C6F8C)
	// 829C6EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6ED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6ED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6EDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C6EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6EE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C6EE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C6EEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6EF0: 4B8F9A49  bl 0x822c0938
	ctx.lr = 0x829C6EF4;
	sub_822C0938(ctx, base);
	// 829C6EF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C6EF8: 41820028  beq 0x829c6f20
	if ctx.cr[0].eq {
	pc = 0x829C6F20; continue 'dispatch;
	}
	// 829C6EFC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C6F00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C6F04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C6F08: 392B3F2C  addi r9, r11, 0x3f2c
	ctx.r[9].s64 = ctx.r[11].s64 + 16172;
	// 829C6F0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C6F10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C6F14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C6F18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C6F1C: 48000008  b 0x829c6f24
	pc = 0x829C6F24; continue 'dispatch;
	// 829C6F20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C6F24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C6F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C6F2C: 409A0044  bne cr6, 0x829c6f70
	if !ctx.cr[6].eq {
	pc = 0x829C6F70; continue 'dispatch;
	}
	// 829C6F30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C6F34: 419A001C  beq cr6, 0x829c6f50
	if ctx.cr[6].eq {
	pc = 0x829C6F50; continue 'dispatch;
	}
	// 829C6F38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6F3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829C6F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C6F44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C6F48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C6F4C: 4E800421  bctrl
	ctx.lr = 0x829C6F50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C6F50: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C6F54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6F58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C6F5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C6F60: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C6F64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C6F68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C6F6C: 4B8F9095  bl 0x822c0000
	ctx.lr = 0x829C6F70;
	sub_822C0000(ctx, base);
	// 829C6F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C6F74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C6F78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C6F7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C6F80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C6F84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C6F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C6F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C6F90 size=428
    let mut pc: u32 = 0x829C6F90;
    'dispatch: loop {
        match pc {
            0x829C6F90 => {
    //   block [0x829C6F90..0x829C713C)
	// 829C6F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C6F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C6F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C6F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C6FA0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 829C6FA4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829C6FA8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C6FAC: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C6FB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829C6FB4: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 829C6FB8: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 829C6FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C6FC0: 4BB4ADD9  bl 0x82511d98
	ctx.lr = 0x829C6FC4;
	sub_82511D98(ctx, base);
	// 829C6FC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C6FC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C6FCC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829C6FD0: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 829C6FD4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829C6FD8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C6FDC: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829C6FE0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829C6FE4: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C6FE8: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C6FEC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C6FF0: 484B4D59  bl 0x82e7bd48
	ctx.lr = 0x829C6FF4;
	sub_82E7BD48(ctx, base);
	// 829C6FF4: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 829C6FF8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C6FFC: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 829C7000: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829C7004: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 829C7008: D3C100A4  stfs f30, 0xa4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829C700C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 829C7010: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829C7014: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829C7018: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 829C701C: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 829C7020: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829C7024: D3C100B8  stfs f30, 0xb8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829C7028: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C7140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C7140 size=736
    let mut pc: u32 = 0x829C7140;
    'dispatch: loop {
        match pc {
            0x829C7140 => {
    //   block [0x829C7140..0x829C7420)
	// 829C7140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C7144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C7148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C714C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C7150: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 829C7154: 487E1925  bl 0x831a8a78
	ctx.lr = 0x829C7158;
	sub_831A8A40(ctx, base);
	// 829C7158: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C715C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829C7160: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829C7164: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 829C7168: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C716C: 4BB4AC2D  bl 0x82511d98
	ctx.lr = 0x829C7170;
	sub_82511D98(ctx, base);
	// 829C7170: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829C7174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C7178: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829C717C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 829C7180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C7184: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C7188: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829C718C: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 829C7190: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829C7194: D3A100B8  stfs f29, 0xb8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829C7198: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 829C719C: 484B4BAD  bl 0x82e7bd48
	ctx.lr = 0x829C71A0;
	sub_82E7BD48(ctx, base);
	// 829C71A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C71A4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 829C71A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C71AC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C7420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C7420 size=288
    let mut pc: u32 = 0x829C7420;
    'dispatch: loop {
        match pc {
            0x829C7420 => {
    //   block [0x829C7420..0x829C7540)
	// 829C7420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C7424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C7428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C742C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C7430: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C7434: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C7438: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C743C: 13C028C7  vcmpequd (lvx128) v30, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C7440: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829C7444: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 829C7448: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 829C744C: D3E1011C  stfs f31, 0x11c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 829C7450: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C7454: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C7540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C7540 size=196
    let mut pc: u32 = 0x829C7540;
    'dispatch: loop {
        match pc {
            0x829C7540 => {
    //   block [0x829C7540..0x829C7604)
	// 829C7540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C7544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C7548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C754C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C7550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C7554: 13C028C7  vcmpequd (lvx128) v30, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C7608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C7608 size=464
    let mut pc: u32 = 0x829C7608;
    'dispatch: loop {
        match pc {
            0x829C7608 => {
    //   block [0x829C7608..0x829C77D8)
	// 829C7608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C760C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C7610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C7614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C7618: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829C761C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829C7620: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C7624: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829C7628: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829C762C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829C7630: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C7634: 3BEBD1A0  addi r31, r11, -0x2e60
	ctx.r[31].s64 = ctx.r[11].s64 + -11872;
	// 829C7638: 816AD1B0  lwz r11, -0x2e50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11856 as u32) ) } as u64;
	// 829C763C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829C7640: 4082001C  bne 0x829c765c
	if !ctx.cr[0].eq {
	pc = 0x829C765C; continue 'dispatch;
	}
	// 829C7644: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C7648: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829C764C: 3929A2F0  addi r9, r9, -0x5d10
	ctx.r[9].s64 = ctx.r[9].s64 + -23824;
	// 829C7650: 916AD1B0  stw r11, -0x2e50(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-11856 as u32), ctx.r[11].u32 ) };
	// 829C7654: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C77D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C77D8 size=160
    let mut pc: u32 = 0x829C77D8;
    'dispatch: loop {
        match pc {
            0x829C77D8 => {
    //   block [0x829C77D8..0x829C7878)
	// 829C77D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C77DC: 487E098D  bl 0x831a8168
	ctx.lr = 0x829C77E0;
	sub_831A8130(ctx, base);
	// 829C77E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C77E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829C77E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C77EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C77F0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829C77F4: 41820034  beq 0x829c7828
	if ctx.cr[0].eq {
	pc = 0x829C7828; continue 'dispatch;
	}
	// 829C77F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C77FC: 487E218D  bl 0x831a9988
	ctx.lr = 0x829C7800;
	sub_831A9988(ctx, base);
	// 829C7800: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829C7804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C7808: 386B6584  addi r3, r11, 0x6584
	ctx.r[3].s64 = ctx.r[11].s64 + 25988;
	// 829C780C: 487E08ED  bl 0x831a80f8
	ctx.lr = 0x829C7810;
	sub_831A80F8(ctx, base);
	// 829C7810: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C7814: 41820014  beq 0x829c7828
	if ctx.cr[0].eq {
	pc = 0x829C7828; continue 'dispatch;
	}
	// 829C7818: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C781C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C7820: 48017269  bl 0x829dea88
	ctx.lr = 0x829C7824;
	sub_829DEA88(ctx, base);
	// 829C7824: 4800004C  b 0x829c7870
	pc = 0x829C7870; continue 'dispatch;
	// 829C7828: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829C782C: 419A0034  beq cr6, 0x829c7860
	if ctx.cr[6].eq {
	pc = 0x829C7860; continue 'dispatch;
	}
	// 829C7830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C7834: 487E2155  bl 0x831a9988
	ctx.lr = 0x829C7838;
	sub_831A9988(ctx, base);
	// 829C7838: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829C783C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C7840: 386B63C0  addi r3, r11, 0x63c0
	ctx.r[3].s64 = ctx.r[11].s64 + 25536;
	// 829C7844: 487E08B5  bl 0x831a80f8
	ctx.lr = 0x829C7848;
	sub_831A80F8(ctx, base);
	// 829C7848: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C784C: 41820014  beq 0x829c7860
	if ctx.cr[0].eq {
	pc = 0x829C7860; continue 'dispatch;
	}
	// 829C7850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C7854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C7858: 480173E9  bl 0x829dec40
	ctx.lr = 0x829C785C;
	sub_829DEC40(ctx, base);
	// 829C785C: 48000014  b 0x829c7870
	pc = 0x829C7870; continue 'dispatch;
	// 829C7860: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829C7864: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C7868: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C786C: 487B6C1D  bl 0x8317e488
	ctx.lr = 0x829C7870;
	sub_8317E488(ctx, base);
	// 829C7870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C7874: 487E0944  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C7878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C7878 size=332
    let mut pc: u32 = 0x829C7878;
    'dispatch: loop {
        match pc {
            0x829C7878 => {
    //   block [0x829C7878..0x829C79C4)
	// 829C7878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C787C: 487E08E9  bl 0x831a8164
	ctx.lr = 0x829C7880;
	sub_831A8130(ctx, base);
	// 829C7880: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829C7884: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C7888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C788C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829C7890: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829C7894: 897F0444  lbz r11, 0x444(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 829C7898: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C789C: 4082011C  bne 0x829c79b8
	if !ctx.cr[0].eq {
	pc = 0x829C79B8; continue 'dispatch;
	}
	// 829C78A0: 897F0310  lbz r11, 0x310(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) } as u64;
	// 829C78A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C78A8: 41820078  beq 0x829c7920
	if ctx.cr[0].eq {
	pc = 0x829C7920; continue 'dispatch;
	}
	// 829C78AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C78B0: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829C78B4: 396B3F90  addi r11, r11, 0x3f90
	ctx.r[11].s64 = ctx.r[11].s64 + 16272;
	// 829C78B8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 829C78BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C78C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C78C4: 13FF50C7  vcmpequd (lvx128) v31, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C78C8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C79C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C79C8 size=972
    let mut pc: u32 = 0x829C79C8;
    'dispatch: loop {
        match pc {
            0x829C79C8 => {
    //   block [0x829C79C8..0x829C7D94)
	// 829C79C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C79CC: 487E0799  bl 0x831a8164
	ctx.lr = 0x829C79D0;
	sub_831A8130(ctx, base);
	// 829C79D0: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 829C79D4: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829C79D8: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829C79DC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C79E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C79E4: 897F0444  lbz r11, 0x444(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 829C79E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C79EC: 41820010  beq 0x829c79fc
	if ctx.cr[0].eq {
	pc = 0x829C79FC; continue 'dispatch;
	}
	// 829C79F0: 897F02BA  lbz r11, 0x2ba(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(698 as u32) ) } as u64;
	// 829C79F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C79F8: 41820388  beq 0x829c7d80
	if ctx.cr[0].eq {
	pc = 0x829C7D80; continue 'dispatch;
	}
	// 829C79FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C7A00: 83DF0208  lwz r30, 0x208(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 829C7A04: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829C7A08: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829C7A0C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829C7A10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C7A14: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 829C7A18: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829C7A1C: C0099534  lfs f0, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C7A20: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 829C7A24: C1A808A8  lfs f13, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829C7A28: 3B8B4020  addi r28, r11, 0x4020
	ctx.r[28].s64 = ctx.r[11].s64 + 16416;
	// 829C7A2C: C187D1B8  lfs f12, -0x2e48(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829C7A30: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C7A34: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829C7A38: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829C7A3C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829C7A40: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829C7A44: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829C7A48: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829C7A4C: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 829C7A50: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829C7A54: 39664018  addi r11, r6, 0x4018
	ctx.r[11].s64 = ctx.r[6].s64 + 16408;
	// 829C7A58: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829C7A5C: 38C54008  addi r6, r5, 0x4008
	ctx.r[6].s64 = ctx.r[5].s64 + 16392;
	// 829C7A60: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829C7A64: 394A3FFC  addi r10, r10, 0x3ffc
	ctx.r[10].s64 = ctx.r[10].s64 + 16380;
	// 829C7A68: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829C7A6C: 39293FF0  addi r9, r9, 0x3ff0
	ctx.r[9].s64 = ctx.r[9].s64 + 16368;
	// 829C7A70: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829C7A74: 39083FE4  addi r8, r8, 0x3fe4
	ctx.r[8].s64 = ctx.r[8].s64 + 16356;
	// 829C7A78: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829C7A7C: 38E73FD4  addi r7, r7, 0x3fd4
	ctx.r[7].s64 = ctx.r[7].s64 + 16340;
	// 829C7A80: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829C7A84: 38A49D20  addi r5, r4, -0x62e0
	ctx.r[5].s64 = ctx.r[4].s64 + -25312;
	// 829C7A88: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829C7A8C: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829C7A90: 3B7F0208  addi r27, r31, 0x208
	ctx.r[27].s64 = ctx.r[31].s64 + 520;
	// 829C7A94: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829C7A98: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 829C7A9C: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829C7AA0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829C7AA4: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 829C7AA8: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 829C7AAC: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829C7AB0: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 829C7AB4: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829C7AB8: 910100A0  stw r8, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 829C7ABC: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 829C7AC0: 90E100B0  stw r7, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[7].u32 ) };
	// 829C7AC4: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 829C7AC8: 90C100C0  stw r6, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[6].u32 ) };
	// 829C7ACC: D18100C8  stfs f12, 0xc8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 829C7AD0: 90A100D0  stw r5, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u32 ) };
	// 829C7AD4: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 829C7AD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829C7ADC: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 829C7AE0: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 829C7AE4: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 829C7AE8: 419A001C  beq cr6, 0x829c7b04
	if ctx.cr[6].eq {
	pc = 0x829C7B04; continue 'dispatch;
	}
	// 829C7AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C7AF0: 4BB49FF9  bl 0x82511ae8
	ctx.lr = 0x829C7AF4;
	sub_82511AE8(ctx, base);
	// 829C7AF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C7AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C7AFC: 4817F0AD  bl 0x82b46ba8
	ctx.lr = 0x829C7B00;
	sub_82B46BA8(ctx, base);
	// 829C7B00: 48000068  b 0x829c7b68
	pc = 0x829C7B68; continue 'dispatch;
	// 829C7B04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C7B08: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829C7B0C: 4BB479BD  bl 0x8250f4c8
	ctx.lr = 0x829C7B10;
	sub_8250F4C8(ctx, base);
	// 829C7B10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C7B18: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829C7B1C: 409A0008  bne cr6, 0x829c7b24
	if !ctx.cr[6].eq {
	pc = 0x829C7B24; continue 'dispatch;
	}
	// 829C7B20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C7B24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829C7B28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829C7B2C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829C7B30: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829C7B34: 4817F36D  bl 0x82b46ea0
	ctx.lr = 0x829C7B38;
	sub_82B46EA0(ctx, base);
	// 829C7B38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C7B3C: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 829C7B40: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829C7B44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7B48: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C7B4C: 4B8FC915  bl 0x822c4460
	ctx.lr = 0x829C7B50;
	sub_822C4460(ctx, base);
	// 829C7B50: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 829C7B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C7B58: 419A0008  beq cr6, 0x829c7b60
	if ctx.cr[6].eq {
	pc = 0x829C7B60; continue 'dispatch;
	}
	// 829C7B5C: 4B8F8D35  bl 0x822c0890
	ctx.lr = 0x829C7B60;
	sub_822C0890(ctx, base);
	// 829C7B60: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829C7B64: 4842A12D  bl 0x82df1c90
	ctx.lr = 0x829C7B68;
	sub_82DF1C90(ctx, base);
	// 829C7B68: 83BF0210  lwz r29, 0x210(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 829C7B6C: 3BDF0210  addi r30, r31, 0x210
	ctx.r[30].s64 = ctx.r[31].s64 + 528;
	// 829C7B70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C7B74: 419A001C  beq cr6, 0x829c7b90
	if ctx.cr[6].eq {
	pc = 0x829C7B90; continue 'dispatch;
	}
	// 829C7B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C7B7C: 4BB49F6D  bl 0x82511ae8
	ctx.lr = 0x829C7B80;
	sub_82511AE8(ctx, base);
	// 829C7B80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C7B84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C7B88: 4817F021  bl 0x82b46ba8
	ctx.lr = 0x829C7B8C;
	sub_82B46BA8(ctx, base);
	// 829C7B8C: 480000A8  b 0x829c7c34
	pc = 0x829C7C34; continue 'dispatch;
	// 829C7B90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C7B94: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829C7B98: 4BB47931  bl 0x8250f4c8
	ctx.lr = 0x829C7B9C;
	sub_8250F4C8(ctx, base);
	// 829C7B9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C7BA4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829C7BA8: 409A0008  bne cr6, 0x829c7bb0
	if !ctx.cr[6].eq {
	pc = 0x829C7BB0; continue 'dispatch;
	}
	// 829C7BAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829C7BB0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829C7BB4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829C7BB8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829C7BBC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829C7BC0: 4817F2E1  bl 0x82b46ea0
	ctx.lr = 0x829C7BC4;
	sub_82B46EA0(ctx, base);
	// 829C7BC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C7BC8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829C7BCC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829C7BD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7BD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C7BD8: 4B8FC889  bl 0x822c4460
	ctx.lr = 0x829C7BDC;
	sub_822C4460(ctx, base);
	// 829C7BDC: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 829C7BE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C7BE4: 419A0008  beq cr6, 0x829c7bec
	if ctx.cr[6].eq {
	pc = 0x829C7BEC; continue 'dispatch;
	}
	// 829C7BE8: 4B8F8CA9  bl 0x822c0890
	ctx.lr = 0x829C7BEC;
	sub_822C0890(ctx, base);
	// 829C7BEC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829C7BF0: 4842A0A1  bl 0x82df1c90
	ctx.lr = 0x829C7BF4;
	sub_82DF1C90(ctx, base);
	// 829C7BF4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7BF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C7BFC: 419A0038  beq cr6, 0x829c7c34
	if ctx.cr[6].eq {
	pc = 0x829C7C34; continue 'dispatch;
	}
	// 829C7C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C7C04: 4BB49EE5  bl 0x82511ae8
	ctx.lr = 0x829C7C08;
	sub_82511AE8(ctx, base);
	// 829C7C08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C7C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C7C10: 4817EF99  bl 0x82b46ba8
	ctx.lr = 0x829C7C14;
	sub_82B46BA8(ctx, base);
	// 829C7C14: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7C18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C7C1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829C7C20: 388B3FC0  addi r4, r11, 0x3fc0
	ctx.r[4].s64 = ctx.r[11].s64 + 16320;
	// 829C7C24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7C28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C7C2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C7C30: 4E800421  bctrl
	ctx.lr = 0x829C7C34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C7C34: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C7C3C: 419A0144  beq cr6, 0x829c7d80
	if ctx.cr[6].eq {
	pc = 0x829C7D80; continue 'dispatch;
	}
	// 829C7C40: 897F02BB  lbz r11, 0x2bb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(699 as u32) ) } as u64;
	// 829C7C44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C7C48: 41820138  beq 0x829c7d80
	if ctx.cr[0].eq {
	pc = 0x829C7D80; continue 'dispatch;
	}
	// 829C7C4C: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7C50: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829C7C54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C7C58: 41820128  beq 0x829c7d80
	if ctx.cr[0].eq {
	pc = 0x829C7D80; continue 'dispatch;
	}
	// 829C7C5C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829C7C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C7C64: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7C68: 4842BDA1  bl 0x82df3a08
	ctx.lr = 0x829C7C6C;
	sub_82DF3A08(ctx, base);
	// 829C7C6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829C7C70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C7C74: 809F0300  lwz r4, 0x300(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 829C7C78: 481EAF51  bl 0x82bb2bc8
	ctx.lr = 0x829C7C7C;
	sub_82BB2BC8(ctx, base);
	// 829C7C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C7C80: 4842B7A9  bl 0x82df3428
	ctx.lr = 0x829C7C84;
	sub_82DF3428(ctx, base);
	// 829C7C84: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829C7C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C7C8C: 419A0010  beq cr6, 0x829c7c9c
	if ctx.cr[6].eq {
	pc = 0x829C7C9C; continue 'dispatch;
	}
	// 829C7C90: 4BAC7469  bl 0x8248f0f8
	ctx.lr = 0x829C7C94;
	sub_8248F0F8(ctx, base);
	// 829C7C94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C7C98: 40820030  bne 0x829c7cc8
	if !ctx.cr[0].eq {
	pc = 0x829C7CC8; continue 'dispatch;
	}
	// 829C7C9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C7CA0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 829C7CA4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 829C7CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C7CAC: 419A0008  beq cr6, 0x829c7cb4
	if ctx.cr[6].eq {
	pc = 0x829C7CB4; continue 'dispatch;
	}
	// 829C7CB0: 4B8F8BE1  bl 0x822c0890
	ctx.lr = 0x829C7CB4;
	sub_822C0890(ctx, base);
	// 829C7CB4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7CB8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C7CC0: 409AFFA0  bne cr6, 0x829c7c60
	if !ctx.cr[6].eq {
	pc = 0x829C7C60; continue 'dispatch;
	}
	// 829C7CC4: 480000BC  b 0x829c7d80
	pc = 0x829C7D80; continue 'dispatch;
	// 829C7CC8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829C7CCC: 481EE835  bl 0x82bb6500
	ctx.lr = 0x829C7CD0;
	sub_82BB6500(ctx, base);
	// 829C7CD0: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 829C7CD4: C01F02BC  lfs f0, 0x2bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829C7CD8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 829C7CDC: 4099000C  ble cr6, 0x829c7ce8
	if !ctx.cr[6].gt {
	pc = 0x829C7CE8; continue 'dispatch;
	}
	// 829C7CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C7CE4: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 829C7CE8: 817F02C4  lwz r11, 0x2c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(708 as u32) ) } as u64;
	// 829C7CEC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829C7CF0: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 829C7CF4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829C7CF8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829C7CFC: D3BF02BC  stfs f29, 0x2bc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 829C7D00: 93DF02C0  stw r30, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[30].u32 ) };
	// 829C7D04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C7D08: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829C7D0C: 7FCB4C2E  lfsx f30, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829C7D10: 419A0008  beq cr6, 0x829c7d18
	if ctx.cr[6].eq {
	pc = 0x829C7D18; continue 'dispatch;
	}
	// 829C7D14: 4B8F8B7D  bl 0x822c0890
	ctx.lr = 0x829C7D18;
	sub_822C0890(ctx, base);
	// 829C7D18: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 829C7D1C: 41980064  blt cr6, 0x829c7d80
	if ctx.cr[6].lt {
	pc = 0x829C7D80; continue 'dispatch;
	}
	// 829C7D20: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 829C7D24: 4198005C  blt cr6, 0x829c7d80
	if ctx.cr[6].lt {
	pc = 0x829C7D80; continue 'dispatch;
	}
	// 829C7D28: 817F02C4  lwz r11, 0x2c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(708 as u32) ) } as u64;
	// 829C7D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C7D30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829C7D34: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 829C7D38: 4BFFD6B1  bl 0x829c53e8
	ctx.lr = 0x829C7D3C;
	sub_829C53E8(ctx, base);
	// 829C7D3C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C7D40: 895F031C  lbz r10, 0x31c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(796 as u32) ) } as u64;
	// 829C7D44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829C7D48: 396B352C  addi r11, r11, 0x352c
	ctx.r[11].s64 = ctx.r[11].s64 + 13612;
	// 829C7D4C: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829C7D50: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7D54: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829C7D58: 41980010  blt cr6, 0x829c7d68
	if ctx.cr[6].lt {
	pc = 0x829C7D68; continue 'dispatch;
	}
	// 829C7D5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C7D60: 388B3FB0  addi r4, r11, 0x3fb0
	ctx.r[4].s64 = ctx.r[11].s64 + 16304;
	// 829C7D64: 4800000C  b 0x829c7d70
	pc = 0x829C7D70; continue 'dispatch;
	// 829C7D68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C7D6C: 388B3FA0  addi r4, r11, 0x3fa0
	ctx.r[4].s64 = ctx.r[11].s64 + 16288;
	// 829C7D70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7D74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C7D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C7D7C: 4E800421  bctrl
	ctx.lr = 0x829C7D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C7D80: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 829C7D84: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 829C7D88: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829C7D8C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829C7D90: 487E0424  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C7D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C7D98 size=784
    let mut pc: u32 = 0x829C7D98;
    'dispatch: loop {
        match pc {
            0x829C7D98 => {
    //   block [0x829C7D98..0x829C80A8)
	// 829C7D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C7D9C: 487E03C9  bl 0x831a8164
	ctx.lr = 0x829C7DA0;
	sub_831A8130(ctx, base);
	// 829C7DA0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829C7DA4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829C7DA8: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C7DAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C7DB0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829C7DB4: 817F0248  lwz r11, 0x248(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 829C7DB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C7DBC: 41980120  blt cr6, 0x829c7edc
	if ctx.cr[6].lt {
	pc = 0x829C7EDC; continue 'dispatch;
	}
	// 829C7DC0: 807F0300  lwz r3, 0x300(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 829C7DC4: 557E003E  slwi r30, r11, 0
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 829C7DC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829C7DCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C7DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829C7DD4: 4E800421  bctrl
	ctx.lr = 0x829C7DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829C7DD8: 7F1E1800  cmpw cr6, r30, r3
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[3].s32, &mut ctx.xer);
	// 829C7DDC: 40980100  bge cr6, 0x829c7edc
	if !ctx.cr[6].lt {
	pc = 0x829C7EDC; continue 'dispatch;
	}
	// 829C7DE0: 807F0300  lwz r3, 0x300(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 829C7DE4: 4811BAAD  bl 0x82ae3890
	ctx.lr = 0x829C7DE8;
	sub_82AE3890(ctx, base);
	// 829C7DE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829C7DEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829C7DF0: 485E7899  bl 0x82faf688
	ctx.lr = 0x829C7DF4;
	sub_82FAF688(ctx, base);
	// 829C7DF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C7DF8: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 829C7DFC: 807F0300  lwz r3, 0x300(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 829C7E00: 83DF0248  lwz r30, 0x248(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 829C7E04: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C80A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829C80A8 size=140
    let mut pc: u32 = 0x829C80A8;
    'dispatch: loop {
        match pc {
            0x829C80A8 => {
    //   block [0x829C80A8..0x829C8134)
	// 829C80A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C80AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C80B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C80B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C80B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C80BC: 4BB49A2D  bl 0x82511ae8
	ctx.lr = 0x829C80C0;
	sub_82511AE8(ctx, base);
	// 829C80C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C80C4: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829C80C8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829C80CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C80D0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829C80D4: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8138 size=276
    let mut pc: u32 = 0x829C8138;
    'dispatch: loop {
        match pc {
            0x829C8138 => {
    //   block [0x829C8138..0x829C824C)
	// 829C8138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C813C: 487E002D  bl 0x831a8168
	ctx.lr = 0x829C8140;
	sub_831A8130(ctx, base);
	// 829C8140: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8144: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829C8148: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C814C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C8150: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829C8154: 41820038  beq 0x829c818c
	if ctx.cr[0].eq {
	pc = 0x829C818C; continue 'dispatch;
	}
	// 829C8158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C815C: 487E182D  bl 0x831a9988
	ctx.lr = 0x829C8160;
	sub_831A9988(ctx, base);
	// 829C8160: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829C8164: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C8168: 386BE1AC  addi r3, r11, -0x1e54
	ctx.r[3].s64 = ctx.r[11].s64 + -7764;
	// 829C816C: 487DFF8D  bl 0x831a80f8
	ctx.lr = 0x829C8170;
	sub_831A80F8(ctx, base);
	// 829C8170: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8174: 41820018  beq 0x829c818c
	if ctx.cr[0].eq {
	pc = 0x829C818C; continue 'dispatch;
	}
	// 829C8178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C817C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C8180: 4B8F7E81  bl 0x822c0000
	ctx.lr = 0x829C8184;
	sub_822C0000(ctx, base);
	// 829C8184: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829C8188: 480000BC  b 0x829c8244
	pc = 0x829C8244; continue 'dispatch;
	// 829C818C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C8190: 419A00A4  beq cr6, 0x829c8234
	if ctx.cr[6].eq {
	pc = 0x829C8234; continue 'dispatch;
	}
	// 829C8194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8198: 487E17F1  bl 0x831a9988
	ctx.lr = 0x829C819C;
	sub_831A9988(ctx, base);
	// 829C819C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829C81A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C81A4: 386B3A14  addi r3, r11, 0x3a14
	ctx.r[3].s64 = ctx.r[11].s64 + 14868;
	// 829C81A8: 487DFF51  bl 0x831a80f8
	ctx.lr = 0x829C81AC;
	sub_831A80F8(ctx, base);
	// 829C81AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C81B0: 41820014  beq 0x829c81c4
	if ctx.cr[0].eq {
	pc = 0x829C81C4; continue 'dispatch;
	}
	// 829C81B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C81B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C81BC: 4BE0D915  bl 0x827d5ad0
	ctx.lr = 0x829C81C0;
	sub_827D5AD0(ctx, base);
	// 829C81C0: 48000084  b 0x829c8244
	pc = 0x829C8244; continue 'dispatch;
	// 829C81C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C81C8: 419A006C  beq cr6, 0x829c8234
	if ctx.cr[6].eq {
	pc = 0x829C8234; continue 'dispatch;
	}
	// 829C81CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C81D0: 487E17B9  bl 0x831a9988
	ctx.lr = 0x829C81D4;
	sub_831A9988(ctx, base);
	// 829C81D4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C81D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C81DC: 386BB378  addi r3, r11, -0x4c88
	ctx.r[3].s64 = ctx.r[11].s64 + -19592;
	// 829C81E0: 487DFF19  bl 0x831a80f8
	ctx.lr = 0x829C81E4;
	sub_831A80F8(ctx, base);
	// 829C81E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C81E8: 41820014  beq 0x829c81fc
	if ctx.cr[0].eq {
	pc = 0x829C81FC; continue 'dispatch;
	}
	// 829C81EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C81F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C81F4: 4B8F7E0D  bl 0x822c0000
	ctx.lr = 0x829C81F8;
	sub_822C0000(ctx, base);
	// 829C81F8: 4BFFFF8C  b 0x829c8184
	pc = 0x829C8184; continue 'dispatch;
	// 829C81FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829C8200: 419A0034  beq cr6, 0x829c8234
	if ctx.cr[6].eq {
	pc = 0x829C8234; continue 'dispatch;
	}
	// 829C8204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8208: 487E1781  bl 0x831a9988
	ctx.lr = 0x829C820C;
	sub_831A9988(ctx, base);
	// 829C820C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829C8210: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C8214: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829C8218: 487DFEE1  bl 0x831a80f8
	ctx.lr = 0x829C821C;
	sub_831A80F8(ctx, base);
	// 829C821C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8220: 41820014  beq 0x829c8234
	if ctx.cr[0].eq {
	pc = 0x829C8234; continue 'dispatch;
	}
	// 829C8224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C8228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C822C: 4800D29D  bl 0x829d54c8
	ctx.lr = 0x829C8230;
	sub_829D54C8(ctx, base);
	// 829C8230: 4BFFFF54  b 0x829c8184
	pc = 0x829C8184; continue 'dispatch;
	// 829C8234: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829C8238: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C823C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C8240: 487B6249  bl 0x8317e488
	ctx.lr = 0x829C8244;
	sub_8317E488(ctx, base);
	// 829C8244: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C8248: 487DFF70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8250 size=88
    let mut pc: u32 = 0x829C8250;
    'dispatch: loop {
        match pc {
            0x829C8250 => {
    //   block [0x829C8250..0x829C82A8)
	// 829C8250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C825C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C8264: 484946C5  bl 0x82e5c928
	ctx.lr = 0x829C8268;
	sub_82E5C928(ctx, base);
	// 829C8268: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829C826C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C8270: 394A407C  addi r10, r10, 0x407c
	ctx.r[10].s64 = ctx.r[10].s64 + 16508;
	// 829C8274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8278: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829C827C: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 829C8280: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829C8284: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 829C8288: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 829C828C: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 829C8290: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 829C8294: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C829C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C82A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C82A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C82A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C82A8 size=164
    let mut pc: u32 = 0x829C82A8;
    'dispatch: loop {
        match pc {
            0x829C82A8 => {
    //   block [0x829C82A8..0x829C834C)
	// 829C82A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C82AC: 487DFEBD  bl 0x831a8168
	ctx.lr = 0x829C82B0;
	sub_831A8130(ctx, base);
	// 829C82B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C82B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829C82B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C82BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C82C0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829C82C4: 41820038  beq 0x829c82fc
	if ctx.cr[0].eq {
	pc = 0x829C82FC; continue 'dispatch;
	}
	// 829C82C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C82CC: 487E16BD  bl 0x831a9988
	ctx.lr = 0x829C82D0;
	sub_831A9988(ctx, base);
	// 829C82D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C82D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C82D8: 386BB378  addi r3, r11, -0x4c88
	ctx.r[3].s64 = ctx.r[11].s64 + -19592;
	// 829C82DC: 487DFE1D  bl 0x831a80f8
	ctx.lr = 0x829C82E0;
	sub_831A80F8(ctx, base);
	// 829C82E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C82E4: 41820018  beq 0x829c82fc
	if ctx.cr[0].eq {
	pc = 0x829C82FC; continue 'dispatch;
	}
	// 829C82E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C82EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C82F0: 48012D21  bl 0x829db010
	ctx.lr = 0x829C82F4;
	sub_829DB010(ctx, base);
	// 829C82F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829C82F8: 4800004C  b 0x829c8344
	pc = 0x829C8344; continue 'dispatch;
	// 829C82FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829C8300: 419A0034  beq cr6, 0x829c8334
	if ctx.cr[6].eq {
	pc = 0x829C8334; continue 'dispatch;
	}
	// 829C8304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8308: 487E1681  bl 0x831a9988
	ctx.lr = 0x829C830C;
	sub_831A9988(ctx, base);
	// 829C830C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829C8310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829C8314: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829C8318: 487DFDE1  bl 0x831a80f8
	ctx.lr = 0x829C831C;
	sub_831A80F8(ctx, base);
	// 829C831C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8320: 41820014  beq 0x829c8334
	if ctx.cr[0].eq {
	pc = 0x829C8334; continue 'dispatch;
	}
	// 829C8324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C8328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C832C: 4B8F7CD5  bl 0x822c0000
	ctx.lr = 0x829C8330;
	sub_822C0000(ctx, base);
	// 829C8330: 4BFFFFC4  b 0x829c82f4
	pc = 0x829C82F4; continue 'dispatch;
	// 829C8334: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829C8338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829C833C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C8340: 487B6149  bl 0x8317e488
	ctx.lr = 0x829C8344;
	sub_8317E488(ctx, base);
	// 829C8344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829C8348: 487DFE70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8350 size=96
    let mut pc: u32 = 0x829C8350;
    'dispatch: loop {
        match pc {
            0x829C8350 => {
    //   block [0x829C8350..0x829C83B0)
	// 829C8350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8358: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C835C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8360: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C8364: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 829C8368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C836C: 419A0008  beq cr6, 0x829c8374
	if ctx.cr[6].eq {
	pc = 0x829C8374; continue 'dispatch;
	}
	// 829C8370: 4B8F8521  bl 0x822c0890
	ctx.lr = 0x829C8374;
	sub_822C0890(ctx, base);
	// 829C8374: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829C8378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C837C: 419A0008  beq cr6, 0x829c8384
	if ctx.cr[6].eq {
	pc = 0x829C8384; continue 'dispatch;
	}
	// 829C8380: 4B8F8511  bl 0x822c0890
	ctx.lr = 0x829C8384;
	sub_822C0890(ctx, base);
	// 829C8384: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 829C8388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C838C: 419A0008  beq cr6, 0x829c8394
	if ctx.cr[6].eq {
	pc = 0x829C8394; continue 'dispatch;
	}
	// 829C8390: 4B8F8501  bl 0x822c0890
	ctx.lr = 0x829C8394;
	sub_822C0890(ctx, base);
	// 829C8394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8398: 484941F1  bl 0x82e5c588
	ctx.lr = 0x829C839C;
	sub_82E5C588(ctx, base);
	// 829C839C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C83A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C83A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C83A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C83AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C83B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C83B0 size=20
    let mut pc: u32 = 0x829C83B0;
    'dispatch: loop {
        match pc {
            0x829C83B0 => {
    //   block [0x829C83B0..0x829C83C4)
	// 829C83B0: 8163020C  lwz r11, 0x20c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(524 as u32) ) } as u64;
	// 829C83B4: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829C83B8: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 829C83BC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 829C83C0: 4BB499D8  b 0x82511d98
	sub_82511D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C83C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C83C8 size=96
    let mut pc: u32 = 0x829C83C8;
    'dispatch: loop {
        match pc {
            0x829C83C8 => {
    //   block [0x829C83C8..0x829C8428)
	// 829C83C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C83CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C83D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C83D4: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8428 size=808
    let mut pc: u32 = 0x829C8428;
    'dispatch: loop {
        match pc {
            0x829C8428 => {
    //   block [0x829C8428..0x829C8750)
	// 829C8428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C842C: 487DFD35  bl 0x831a8160
	ctx.lr = 0x829C8430;
	sub_831A8130(ctx, base);
	// 829C8430: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8434: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829C8438: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829C843C: 387C00E8  addi r3, r28, 0xe8
	ctx.r[3].s64 = ctx.r[28].s64 + 232;
	// 829C8440: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829C8444: 4849228D  bl 0x82e5a6d0
	ctx.lr = 0x829C8448;
	sub_82E5A6D0(ctx, base);
	// 829C8448: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C844C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829C8450: 388B4108  addi r4, r11, 0x4108
	ctx.r[4].s64 = ctx.r[11].s64 + 16648;
	// 829C8454: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C8458: 4842B5B1  bl 0x82df3a08
	ctx.lr = 0x829C845C;
	sub_82DF3A08(ctx, base);
	// 829C845C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829C8460: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8464: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829C8468: 4842AEA1  bl 0x82df3308
	ctx.lr = 0x829C846C;
	sub_82DF3308(ctx, base);
	// 829C846C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8470: 40820030  bne 0x829c84a0
	if !ctx.cr[0].eq {
	pc = 0x829C84A0; continue 'dispatch;
	}
	// 829C8474: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C8478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C847C: 388B40FC  addi r4, r11, 0x40fc
	ctx.r[4].s64 = ctx.r[11].s64 + 16636;
	// 829C8480: 4842B589  bl 0x82df3a08
	ctx.lr = 0x829C8484;
	sub_82DF3A08(ctx, base);
	// 829C8484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C8488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C848C: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 829C8490: 4842AE79  bl 0x82df3308
	ctx.lr = 0x829C8494;
	sub_82DF3308(ctx, base);
	// 829C8494: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8498: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829C849C: 41820008  beq 0x829c84a4
	if ctx.cr[0].eq {
	pc = 0x829C84A4; continue 'dispatch;
	}
	// 829C84A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C84A4: 57EA07BD  rlwinm. r10, r31, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829C84A8: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C84AC: 41820010  beq 0x829c84bc
	if ctx.cr[0].eq {
	pc = 0x829C84BC; continue 'dispatch;
	}
	// 829C84B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C84B4: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 829C84B8: 4842AF71  bl 0x82df3428
	ctx.lr = 0x829C84BC;
	sub_82DF3428(ctx, base);
	// 829C84BC: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C84C0: 41820010  beq 0x829c84d0
	if ctx.cr[0].eq {
	pc = 0x829C84D0; continue 'dispatch;
	}
	// 829C84C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C84C8: 57FF003C  rlwinm r31, r31, 0, 0, 0x1e
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 829C84CC: 4842AF5D  bl 0x82df3428
	ctx.lr = 0x829C84D0;
	sub_82DF3428(ctx, base);
	// 829C84D0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C84D4: 4182000C  beq 0x829c84e0
	if ctx.cr[0].eq {
	pc = 0x829C84E0; continue 'dispatch;
	}
	// 829C84D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C84DC: 48000260  b 0x829c873c
	pc = 0x829C873C; continue 'dispatch;
	// 829C84E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C84E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C84E8: 388B40F0  addi r4, r11, 0x40f0
	ctx.r[4].s64 = ctx.r[11].s64 + 16624;
	// 829C84EC: 4842B51D  bl 0x82df3a08
	ctx.lr = 0x829C84F0;
	sub_82DF3A08(ctx, base);
	// 829C84F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829C84F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C84F8: 4842AE11  bl 0x82df3308
	ctx.lr = 0x829C84FC;
	sub_82DF3308(ctx, base);
	// 829C84FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C8500: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C8504: 4842AF25  bl 0x82df3428
	ctx.lr = 0x829C8508;
	sub_82DF3428(ctx, base);
	// 829C8508: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C850C: 4182001C  beq 0x829c8528
	if ctx.cr[0].eq {
	pc = 0x829C8528; continue 'dispatch;
	}
	// 829C8510: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829C8514: 4BFFFB95  bl 0x829c80a8
	ctx.lr = 0x829C8518;
	sub_829C80A8(ctx, base);
	// 829C8518: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C851C: 408201E4  bne 0x829c8700
	if !ctx.cr[0].eq {
	pc = 0x829C8700; continue 'dispatch;
	}
	// 829C8520: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829C8524: 48000218  b 0x829c873c
	pc = 0x829C873C; continue 'dispatch;
	// 829C8528: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C852C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C8530: 388B40E8  addi r4, r11, 0x40e8
	ctx.r[4].s64 = ctx.r[11].s64 + 16616;
	// 829C8534: 4842B4D5  bl 0x82df3a08
	ctx.lr = 0x829C8538;
	sub_82DF3A08(ctx, base);
	// 829C8538: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C853C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8540: 63FF0004  ori r31, r31, 4
	ctx.r[31].u64 = ctx.r[31].u64 | 4;
	// 829C8544: 4842ADC5  bl 0x82df3308
	ctx.lr = 0x829C8548;
	sub_82DF3308(ctx, base);
	// 829C8548: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C854C: 40820058  bne 0x829c85a4
	if !ctx.cr[0].eq {
	pc = 0x829C85A4; continue 'dispatch;
	}
	// 829C8550: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C8554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C8558: 388B40DC  addi r4, r11, 0x40dc
	ctx.r[4].s64 = ctx.r[11].s64 + 16604;
	// 829C855C: 4842B4AD  bl 0x82df3a08
	ctx.lr = 0x829C8560;
	sub_82DF3A08(ctx, base);
	// 829C8560: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829C8564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8568: 63FF0008  ori r31, r31, 8
	ctx.r[31].u64 = ctx.r[31].u64 | 8;
	// 829C856C: 4842AD9D  bl 0x82df3308
	ctx.lr = 0x829C8570;
	sub_82DF3308(ctx, base);
	// 829C8570: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8574: 40820030  bne 0x829c85a4
	if !ctx.cr[0].eq {
	pc = 0x829C85A4; continue 'dispatch;
	}
	// 829C8578: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C857C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C8580: 388B40CC  addi r4, r11, 0x40cc
	ctx.r[4].s64 = ctx.r[11].s64 + 16588;
	// 829C8584: 4842B485  bl 0x82df3a08
	ctx.lr = 0x829C8588;
	sub_82DF3A08(ctx, base);
	// 829C8588: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829C858C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8590: 63FF0010  ori r31, r31, 0x10
	ctx.r[31].u64 = ctx.r[31].u64 | 16;
	// 829C8594: 4842AD75  bl 0x82df3308
	ctx.lr = 0x829C8598;
	sub_82DF3308(ctx, base);
	// 829C8598: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C859C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829C85A0: 41820008  beq 0x829c85a8
	if ctx.cr[0].eq {
	pc = 0x829C85A8; continue 'dispatch;
	}
	// 829C85A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C85A8: 57EA06F7  rlwinm. r10, r31, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829C85AC: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C85B0: 41820010  beq 0x829c85c0
	if ctx.cr[0].eq {
	pc = 0x829C85C0; continue 'dispatch;
	}
	// 829C85B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C85B8: 57FF0734  rlwinm r31, r31, 0, 0x1c, 0x1a
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 829C85BC: 4842AE6D  bl 0x82df3428
	ctx.lr = 0x829C85C0;
	sub_82DF3428(ctx, base);
	// 829C85C0: 57EB0739  rlwinm. r11, r31, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C85C4: 41820010  beq 0x829c85d4
	if ctx.cr[0].eq {
	pc = 0x829C85D4; continue 'dispatch;
	}
	// 829C85C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C85CC: 57FF0776  rlwinm r31, r31, 0, 0x1d, 0x1b
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 829C85D0: 4842AE59  bl 0x82df3428
	ctx.lr = 0x829C85D4;
	sub_82DF3428(ctx, base);
	// 829C85D4: 57EB077B  rlwinm. r11, r31, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C85D8: 41820010  beq 0x829c85e8
	if ctx.cr[0].eq {
	pc = 0x829C85E8; continue 'dispatch;
	}
	// 829C85DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C85E0: 57FF07B8  rlwinm r31, r31, 0, 0x1e, 0x1c
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 829C85E4: 4842AE45  bl 0x82df3428
	ctx.lr = 0x829C85E8;
	sub_82DF3428(ctx, base);
	// 829C85E8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C85EC: 4182001C  beq 0x829c8608
	if ctx.cr[0].eq {
	pc = 0x829C8608; continue 'dispatch;
	}
	// 829C85F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829C85F4: 4BFFFAB5  bl 0x829c80a8
	ctx.lr = 0x829C85F8;
	sub_829C80A8(ctx, base);
	// 829C85F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C85FC: 40820104  bne 0x829c8700
	if !ctx.cr[0].eq {
	pc = 0x829C8700; continue 'dispatch;
	}
	// 829C8600: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829C8604: 48000138  b 0x829c873c
	pc = 0x829C873C; continue 'dispatch;
	// 829C8608: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C860C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C8610: 388B40C4  addi r4, r11, 0x40c4
	ctx.r[4].s64 = ctx.r[11].s64 + 16580;
	// 829C8614: 4842B3F5  bl 0x82df3a08
	ctx.lr = 0x829C8618;
	sub_82DF3A08(ctx, base);
	// 829C8618: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C861C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8620: 4842ACE9  bl 0x82df3308
	ctx.lr = 0x829C8624;
	sub_82DF3308(ctx, base);
	// 829C8624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C8628: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C862C: 4842ADFD  bl 0x82df3428
	ctx.lr = 0x829C8630;
	sub_82DF3428(ctx, base);
	// 829C8630: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8634: 4182000C  beq 0x829c8640
	if ctx.cr[0].eq {
	pc = 0x829C8640; continue 'dispatch;
	}
	// 829C8638: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 829C863C: 48000100  b 0x829c873c
	pc = 0x829C873C; continue 'dispatch;
	// 829C8640: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C8644: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C8648: 388B40B4  addi r4, r11, 0x40b4
	ctx.r[4].s64 = ctx.r[11].s64 + 16564;
	// 829C864C: 4842B3BD  bl 0x82df3a08
	ctx.lr = 0x829C8650;
	sub_82DF3A08(ctx, base);
	// 829C8650: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C8654: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8658: 4842ACB1  bl 0x82df3308
	ctx.lr = 0x829C865C;
	sub_82DF3308(ctx, base);
	// 829C865C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C8660: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C8664: 4842ADC5  bl 0x82df3428
	ctx.lr = 0x829C8668;
	sub_82DF3428(ctx, base);
	// 829C8668: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C866C: 4182000C  beq 0x829c8678
	if ctx.cr[0].eq {
	pc = 0x829C8678; continue 'dispatch;
	}
	// 829C8670: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829C8674: 480000C8  b 0x829c873c
	pc = 0x829C873C; continue 'dispatch;
	// 829C8678: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C867C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C8680: 388B40A8  addi r4, r11, 0x40a8
	ctx.r[4].s64 = ctx.r[11].s64 + 16552;
	// 829C8684: 4842B385  bl 0x82df3a08
	ctx.lr = 0x829C8688;
	sub_82DF3A08(ctx, base);
	// 829C8688: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829C868C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8690: 63FF0020  ori r31, r31, 0x20
	ctx.r[31].u64 = ctx.r[31].u64 | 32;
	// 829C8694: 4842AC75  bl 0x82df3308
	ctx.lr = 0x829C8698;
	sub_82DF3308(ctx, base);
	// 829C8698: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C869C: 40820030  bne 0x829c86cc
	if !ctx.cr[0].eq {
	pc = 0x829C86CC; continue 'dispatch;
	}
	// 829C86A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C86A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C86A8: 388B40A0  addi r4, r11, 0x40a0
	ctx.r[4].s64 = ctx.r[11].s64 + 16544;
	// 829C86AC: 4842B35D  bl 0x82df3a08
	ctx.lr = 0x829C86B0;
	sub_82DF3A08(ctx, base);
	// 829C86B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C86B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C86B8: 63FF0040  ori r31, r31, 0x40
	ctx.r[31].u64 = ctx.r[31].u64 | 64;
	// 829C86BC: 4842AC4D  bl 0x82df3308
	ctx.lr = 0x829C86C0;
	sub_82DF3308(ctx, base);
	// 829C86C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C86C4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829C86C8: 41820008  beq 0x829c86d0
	if ctx.cr[0].eq {
	pc = 0x829C86D0; continue 'dispatch;
	}
	// 829C86CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829C86D0: 57EA0673  rlwinm. r10, r31, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829C86D4: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829C86D8: 41820010  beq 0x829c86e8
	if ctx.cr[0].eq {
	pc = 0x829C86E8; continue 'dispatch;
	}
	// 829C86DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C86E0: 57FF06B0  rlwinm r31, r31, 0, 0x1a, 0x18
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 829C86E4: 4842AD45  bl 0x82df3428
	ctx.lr = 0x829C86E8;
	sub_82DF3428(ctx, base);
	// 829C86E8: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C86EC: 4182000C  beq 0x829c86f8
	if ctx.cr[0].eq {
	pc = 0x829C86F8; continue 'dispatch;
	}
	// 829C86F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829C86F4: 4842AD35  bl 0x82df3428
	ctx.lr = 0x829C86F8;
	sub_82DF3428(ctx, base);
	// 829C86F8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C86FC: 4182000C  beq 0x829c8708
	if ctx.cr[0].eq {
	pc = 0x829C8708; continue 'dispatch;
	}
	// 829C8700: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 829C8704: 48000038  b 0x829c873c
	pc = 0x829C873C; continue 'dispatch;
	// 829C8708: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C870C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C8710: 388B1CEC  addi r4, r11, 0x1cec
	ctx.r[4].s64 = ctx.r[11].s64 + 7404;
	// 829C8714: 4842B2F5  bl 0x82df3a08
	ctx.lr = 0x829C8718;
	sub_82DF3A08(ctx, base);
	// 829C8718: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829C871C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829C8720: 4842ABE9  bl 0x82df3308
	ctx.lr = 0x829C8724;
	sub_82DF3308(ctx, base);
	// 829C8724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C8728: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829C872C: 4842ACFD  bl 0x82df3428
	ctx.lr = 0x829C8730;
	sub_82DF3428(ctx, base);
	// 829C8730: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829C8734: 41820010  beq 0x829c8744
	if ctx.cr[0].eq {
	pc = 0x829C8744; continue 'dispatch;
	}
	// 829C8738: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 829C873C: 917B0018  stw r11, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829C8740: 48000008  b 0x829c8748
	pc = 0x829C8748; continue 'dispatch;
	// 829C8744: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 829C8748: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829C874C: 487DFA64  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C8750 size=8
    let mut pc: u32 = 0x829C8750;
    'dispatch: loop {
        match pc {
            0x829C8750 => {
    //   block [0x829C8750..0x829C8758)
	// 829C8750: 831A93F0  lwz r24, -0x6c10(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-27664 as u32) ) } as u64;
	// 829C8754: 820A4144  lwz r16, 0x4144(r10)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16708 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8758 size=156
    let mut pc: u32 = 0x829C8758;
    'dispatch: loop {
        match pc {
            0x829C8758 => {
    //   block [0x829C8758..0x829C87F4)
	// 829C8758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C875C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8760: 38000000  li r0, 0
	ctx.r[0].s64 = 0;
	// 829C8764: 90010004  stw r0, 4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(4 as u32), ctx.r[0].u32 ) };
	// 829C8768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C876C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C8770: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 829C8774: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8778: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C877C: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 829C8780: 39440004  addi r10, r4, 4
	ctx.r[10].s64 = ctx.r[4].s64 + 4;
	// 829C8784: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C8788: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C878C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C8790: 419A0010  beq cr6, 0x829c87a0
	if ctx.cr[6].eq {
	pc = 0x829C87A0; continue 'dispatch;
	}
	// 829C8794: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C8798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C879C: 4800000C  b 0x829c87a8
	pc = 0x829C87A8; continue 'dispatch;
	// 829C87A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C87A4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829C87A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829C87AC: 409A0014  bne cr6, 0x829c87c0
	if !ctx.cr[6].eq {
	pc = 0x829C87C0; continue 'dispatch;
	}
	// 829C87B0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C87B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C87B8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829C87BC: 48000020  b 0x829c87dc
	pc = 0x829C87DC; continue 'dispatch;
	// 829C87C0: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 829C87C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C87C8: 4BE21E39  bl 0x827ea600
	ctx.lr = 0x829C87CC;
	sub_827EA600(ctx, base);
	// 829C87CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C87D0: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 829C87D4: 48000008  b 0x829c87dc
	pc = 0x829C87DC; continue 'dispatch;
	// 829C87D8: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 829C87DC: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 829C87E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C87E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C87E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C87EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C87F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C87F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829C87F4 size=8
    let mut pc: u32 = 0x829C87F4;
    'dispatch: loop {
        match pc {
            0x829C87F4 => {
    //   block [0x829C87F4..0x829C87FC)
	// 829C87F4: 831A93F0  lwz r24, -0x6c10(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-27664 as u32) ) } as u64;
	// 829C87F8: 820A4144  lwz r16, 0x4144(r10)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16708 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C87FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C87FC size=48
    let mut pc: u32 = 0x829C87FC;
    'dispatch: loop {
        match pc {
            0x829C87FC => {
    //   block [0x829C87FC..0x829C882C)
	// 829C87FC: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 829C8800: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8804: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 829C8808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C880C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 829C8810: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 829C8814: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C8818: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829C881C: 3C60829D  lis r3, -0x7d63
	ctx.r[3].s64 = -2103640064;
	// 829C8820: 386387D8  addi r3, r3, -0x7828
	ctx.r[3].s64 = ctx.r[3].s64 + -30760;
	// 829C8824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8830 size=188
    let mut pc: u32 = 0x829C8830;
    'dispatch: loop {
        match pc {
            0x829C8830 => {
    //   block [0x829C8830..0x829C88EC)
	// 829C8830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C883C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C8840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C8848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C884C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C8850: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C8854: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C8858: 4B8F80E1  bl 0x822c0938
	ctx.lr = 0x829C885C;
	sub_822C0938(ctx, base);
	// 829C885C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C8860: 41820028  beq 0x829c8888
	if ctx.cr[0].eq {
	pc = 0x829C8888; continue 'dispatch;
	}
	// 829C8864: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C8868: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C886C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C8870: 392B3EDC  addi r9, r11, 0x3edc
	ctx.r[9].s64 = ctx.r[11].s64 + 16092;
	// 829C8874: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C8878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C887C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C8880: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C8884: 48000008  b 0x829c888c
	pc = 0x829C888C; continue 'dispatch;
	// 829C8888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C888C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C8890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C8894: 409A003C  bne cr6, 0x829c88d0
	if !ctx.cr[6].eq {
	pc = 0x829C88D0; continue 'dispatch;
	}
	// 829C8898: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C889C: 419A0014  beq cr6, 0x829c88b0
	if ctx.cr[6].eq {
	pc = 0x829C88B0; continue 'dispatch;
	}
	// 829C88A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C88A4: 48008D15  bl 0x829d15b8
	ctx.lr = 0x829C88A8;
	sub_829D15B8(ctx, base);
	// 829C88A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C88AC: 4B8F79BD  bl 0x822c0268
	ctx.lr = 0x829C88B0;
	sub_822C0268(ctx, base);
	// 829C88B0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C88B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C88B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C88BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C88C0: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C88C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C88C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C88CC: 4B8F7735  bl 0x822c0000
	ctx.lr = 0x829C88D0;
	sub_822C0000(ctx, base);
	// 829C88D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C88D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C88D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C88DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C88E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C88E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C88E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C88F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C88F0 size=188
    let mut pc: u32 = 0x829C88F0;
    'dispatch: loop {
        match pc {
            0x829C88F0 => {
    //   block [0x829C88F0..0x829C89AC)
	// 829C88F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C88F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C88F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829C88FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C8900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8904: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829C8908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C890C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829C8910: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829C8914: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C8918: 4B8F8021  bl 0x822c0938
	ctx.lr = 0x829C891C;
	sub_822C0938(ctx, base);
	// 829C891C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829C8920: 41820028  beq 0x829c8948
	if ctx.cr[0].eq {
	pc = 0x829C8948; continue 'dispatch;
	}
	// 829C8924: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829C8928: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829C892C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829C8930: 392B3EF0  addi r9, r11, 0x3ef0
	ctx.r[9].s64 = ctx.r[11].s64 + 16112;
	// 829C8934: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829C8938: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829C893C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829C8940: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829C8944: 48000008  b 0x829c894c
	pc = 0x829C894C; continue 'dispatch;
	// 829C8948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829C894C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C8950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829C8954: 409A003C  bne cr6, 0x829c8990
	if !ctx.cr[6].eq {
	pc = 0x829C8990; continue 'dispatch;
	}
	// 829C8958: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C895C: 419A0014  beq cr6, 0x829c8970
	if ctx.cr[6].eq {
	pc = 0x829C8970; continue 'dispatch;
	}
	// 829C8960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8964: 4802467D  bl 0x829ecfe0
	ctx.lr = 0x829C8968;
	sub_829ECFE0(ctx, base);
	// 829C8968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C896C: 4B8F78FD  bl 0x822c0268
	ctx.lr = 0x829C8970;
	sub_822C0268(ctx, base);
	// 829C8970: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C8974: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829C8978: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829C897C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829C8980: 816BB164  lwz r11, -0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20124 as u32) ) } as u64;
	// 829C8984: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829C8988: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829C898C: 4B8F7675  bl 0x822c0000
	ctx.lr = 0x829C8990;
	sub_822C0000(ctx, base);
	// 829C8990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829C8994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829C8998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C899C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C89A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829C89A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C89A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C89B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C89B0 size=104
    let mut pc: u32 = 0x829C89B0;
    'dispatch: loop {
        match pc {
            0x829C89B0 => {
    //   block [0x829C89B0..0x829C8A18)
	// 829C89B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C89B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C89B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C89BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C89C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C89C4: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 829C89C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C89CC: 419A0008  beq cr6, 0x829c89d4
	if ctx.cr[6].eq {
	pc = 0x829C89D4; continue 'dispatch;
	}
	// 829C89D0: 4B8F7EC1  bl 0x822c0890
	ctx.lr = 0x829C89D4;
	sub_822C0890(ctx, base);
	// 829C89D4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 829C89D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C89DC: 419A0008  beq cr6, 0x829c89e4
	if ctx.cr[6].eq {
	pc = 0x829C89E4; continue 'dispatch;
	}
	// 829C89E0: 4B8F7EB1  bl 0x822c0890
	ctx.lr = 0x829C89E4;
	sub_822C0890(ctx, base);
	// 829C89E4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829C89E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C89EC: 419A0008  beq cr6, 0x829c89f4
	if ctx.cr[6].eq {
	pc = 0x829C89F4; continue 'dispatch;
	}
	// 829C89F0: 4B8F7EA1  bl 0x822c0890
	ctx.lr = 0x829C89F4;
	sub_822C0890(ctx, base);
	// 829C89F4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829C89F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829C89FC: 419A0008  beq cr6, 0x829c8a04
	if ctx.cr[6].eq {
	pc = 0x829C8A04; continue 'dispatch;
	}
	// 829C8A00: 4B8F7E91  bl 0x822c0890
	ctx.lr = 0x829C8A04;
	sub_822C0890(ctx, base);
	// 829C8A04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C8A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C8A10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C8A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8A18 size=64
    let mut pc: u32 = 0x829C8A18;
    'dispatch: loop {
        match pc {
            0x829C8A18 => {
    //   block [0x829C8A18..0x829C8A58)
	// 829C8A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C8A24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8A28: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 829C8A2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C8A30: 419A0014  beq cr6, 0x829c8a44
	if ctx.cr[6].eq {
	pc = 0x829C8A44; continue 'dispatch;
	}
	// 829C8A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8A38: 48008B81  bl 0x829d15b8
	ctx.lr = 0x829C8A3C;
	sub_829D15B8(ctx, base);
	// 829C8A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8A40: 4B8F7829  bl 0x822c0268
	ctx.lr = 0x829C8A44;
	sub_822C0268(ctx, base);
	// 829C8A44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8A48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C8A4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C8A50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C8A54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8A58 size=64
    let mut pc: u32 = 0x829C8A58;
    'dispatch: loop {
        match pc {
            0x829C8A58 => {
    //   block [0x829C8A58..0x829C8A98)
	// 829C8A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C8A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8A68: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 829C8A6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829C8A70: 419A0014  beq cr6, 0x829c8a84
	if ctx.cr[6].eq {
	pc = 0x829C8A84; continue 'dispatch;
	}
	// 829C8A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8A78: 48024569  bl 0x829ecfe0
	ctx.lr = 0x829C8A7C;
	sub_829ECFE0(ctx, base);
	// 829C8A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8A80: 4B8F77E9  bl 0x822c0268
	ctx.lr = 0x829C8A84;
	sub_822C0268(ctx, base);
	// 829C8A84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C8A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C8A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C8A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8A98 size=72
    let mut pc: u32 = 0x829C8A98;
    'dispatch: loop {
        match pc {
            0x829C8A98 => {
    //   block [0x829C8A98..0x829C8AE0)
	// 829C8A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8AA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8AA4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829C8AA8: 419A001C  beq cr6, 0x829c8ac4
	if ctx.cr[6].eq {
	pc = 0x829C8AC4; continue 'dispatch;
	}
	// 829C8AAC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829C8AB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829C8AB4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829C8AB8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829C8ABC: 4BFFCFC5  bl 0x829c5a80
	ctx.lr = 0x829C8AC0;
	sub_829C5A80(ctx, base);
	// 829C8AC0: 48000010  b 0x829c8ad0
	pc = 0x829C8AD0; continue 'dispatch;
	// 829C8AC4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829C8AC8: 396BBC08  addi r11, r11, -0x43f8
	ctx.r[11].s64 = ctx.r[11].s64 + -17400;
	// 829C8ACC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829C8AD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8AD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C8AD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C8ADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829C8AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829C8AE0 size=56
    let mut pc: u32 = 0x829C8AE0;
    'dispatch: loop {
        match pc {
            0x829C8AE0 => {
    //   block [0x829C8AE0..0x829C8B18)
	// 829C8AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829C8AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829C8AE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829C8AEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829C8AF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829C8AF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829C8AF8: 388BD194  addi r4, r11, -0x2e6c
	ctx.r[4].s64 = ctx.r[11].s64 + -11884;
	// 829C8AFC: 4BFFFC5D  bl 0x829c8758
	ctx.lr = 0x829C8B00;
	sub_829C8758(ctx, base);
	// 829C8B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829C8B04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829C8B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829C8B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829C8B10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829C8B14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


