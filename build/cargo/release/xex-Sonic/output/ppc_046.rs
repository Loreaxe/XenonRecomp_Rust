pub fn sub_82597950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597950 size=196
    let mut pc: u32 = 0x82597950;
    'dispatch: loop {
        match pc {
            0x82597950 => {
    //   block [0x82597950..0x82597A14)
	// 82597950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259795C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82597960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82597968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259796C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82597970: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82597974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82597978: 4BD28FC1  bl 0x822c0938
	ctx.lr = 0x8259797C;
	sub_822C0938(ctx, base);
	// 8259797C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82597980: 41820028  beq 0x825979a8
	if ctx.cr[0].eq {
	pc = 0x825979A8; continue 'dispatch;
	}
	// 82597984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82597988: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259798C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82597990: 392BA2A8  addi r9, r11, -0x5d58
	ctx.r[9].s64 = ctx.r[11].s64 + -23896;
	// 82597994: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82597998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259799C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825979A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825979A4: 48000008  b 0x825979ac
	pc = 0x825979AC; continue 'dispatch;
	// 825979A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825979AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825979B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825979B4: 409A0044  bne cr6, 0x825979f8
	if !ctx.cr[6].eq {
	pc = 0x825979F8; continue 'dispatch;
	}
	// 825979B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825979BC: 419A001C  beq cr6, 0x825979d8
	if ctx.cr[6].eq {
	pc = 0x825979D8; continue 'dispatch;
	}
	// 825979C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825979C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825979C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825979CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825979D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825979D4: 4E800421  bctrl
	ctx.lr = 0x825979D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825979D8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825979DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825979E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825979E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825979E8: 816B6AAC  lwz r11, 0x6aac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27308 as u32) ) } as u64;
	// 825979EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825979F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825979F4: 4BD2860D  bl 0x822c0000
	ctx.lr = 0x825979F8;
	sub_822C0000(ctx, base);
	// 825979F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825979FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82597A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82597A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82597A08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82597A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82597A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597A18 size=96
    let mut pc: u32 = 0x82597A18;
    'dispatch: loop {
        match pc {
            0x82597A18 => {
    //   block [0x82597A18..0x82597A78)
	// 82597A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82597A24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82597A2C: 4BF7A905  bl 0x82512330
	ctx.lr = 0x82597A30;
	sub_82512330(ctx, base);
	// 82597A30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82597A34: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82597A38: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82597A3C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82597A40: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82597A44: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82597A48: 394AA31C  addi r10, r10, -0x5ce4
	ctx.r[10].s64 = ctx.r[10].s64 + -23780;
	// 82597A4C: 3929A308  addi r9, r9, -0x5cf8
	ctx.r[9].s64 = ctx.r[9].s64 + -23800;
	// 82597A50: 3968A2BC  addi r11, r8, -0x5d44
	ctx.r[11].s64 = ctx.r[8].s64 + -23876;
	// 82597A54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82597A58: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82597A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597A60: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82597A64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82597A68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82597A6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82597A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82597A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597A78 size=124
    let mut pc: u32 = 0x82597A78;
    'dispatch: loop {
        match pc {
            0x82597A78 => {
    //   block [0x82597A78..0x82597AF4)
	// 82597A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597A7C: 48C106F1  bl 0x831a816c
	ctx.lr = 0x82597A80;
	sub_831A8130(ctx, base);
	// 82597A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597A84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82597A88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82597A8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82597A90: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82597A94: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82597A98: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82597A9C: 4885A94D  bl 0x82df23e8
	ctx.lr = 0x82597AA0;
	sub_82DF23E8(ctx, base);
	// 82597AA0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82597AA4: 4182001C  beq 0x82597ac0
	if ctx.cr[0].eq {
	pc = 0x82597AC0; continue 'dispatch;
	}
	// 82597AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597AAC: 488C1BD5  bl 0x82e59680
	ctx.lr = 0x82597AB0;
	sub_82E59680(ctx, base);
	// 82597AB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82597AB4: 396BA278  addi r11, r11, -0x5d88
	ctx.r[11].s64 = ctx.r[11].s64 + -23944;
	// 82597AB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82597ABC: 48000008  b 0x82597ac4
	pc = 0x82597AC4; continue 'dispatch;
	// 82597AC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82597AC4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82597AC8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82597ACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597AD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82597AD4: 4BFFFE7D  bl 0x82597950
	ctx.lr = 0x82597AD8;
	sub_82597950(ctx, base);
	// 82597AD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82597ADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82597AE4: 4BD2851D  bl 0x822c0000
	ctx.lr = 0x82597AE8;
	sub_822C0000(ctx, base);
	// 82597AE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82597AEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82597AF0: 48C106CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597AF8 size=96
    let mut pc: u32 = 0x82597AF8;
    'dispatch: loop {
        match pc {
            0x82597AF8 => {
    //   block [0x82597AF8..0x82597B58)
	// 82597AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597B00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82597B04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82597B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597B0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82597B10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82597B14: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82597B18: 4885B911  bl 0x82df3428
	ctx.lr = 0x82597B1C;
	sub_82DF3428(ctx, base);
	// 82597B1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82597B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82597B24: 419A0008  beq cr6, 0x82597b2c
	if ctx.cr[6].eq {
	pc = 0x82597B2C; continue 'dispatch;
	}
	// 82597B28: 4BD28D69  bl 0x822c0890
	ctx.lr = 0x82597B2C;
	sub_822C0890(ctx, base);
	// 82597B2C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82597B30: 4182000C  beq 0x82597b3c
	if ctx.cr[0].eq {
	pc = 0x82597B3C; continue 'dispatch;
	}
	// 82597B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597B38: 4BD28731  bl 0x822c0268
	ctx.lr = 0x82597B3C;
	sub_822C0268(ctx, base);
	// 82597B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597B40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82597B44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82597B48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82597B4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82597B50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82597B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82597B58 size=248
    let mut pc: u32 = 0x82597B58;
    'dispatch: loop {
        match pc {
            0x82597B58 => {
    //   block [0x82597B58..0x82597C50)
	// 82597B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82597B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82597B68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597B6C: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82597B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82597B74: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82597B78: 409A00C0  bne cr6, 0x82597c38
	if !ctx.cr[6].eq {
	pc = 0x82597C38; continue 'dispatch;
	}
	// 82597B7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82597B80: 4BFFFEF9  bl 0x82597a78
	ctx.lr = 0x82597B84;
	sub_82597A78(ctx, base);
	// 82597B84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82597B88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82597B8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82597B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82597B94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82597B98: 419A0024  beq cr6, 0x82597bbc
	if ctx.cr[6].eq {
	pc = 0x82597BBC; continue 'dispatch;
	}
	// 82597B9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82597BA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82597BA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82597BA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82597BAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82597BB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82597BB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82597BB8: 4082FFE8  bne 0x82597ba0
	if !ctx.cr[0].eq {
	pc = 0x82597BA0; continue 'dispatch;
	}
	// 82597BBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597BC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82597BC4: 4BF77905  bl 0x8250f4c8
	ctx.lr = 0x82597BC8;
	sub_8250F4C8(ctx, base);
	// 82597BC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82597BCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82597BD0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82597BD4: 409A0008  bne cr6, 0x82597bdc
	if !ctx.cr[6].eq {
	pc = 0x82597BDC; continue 'dispatch;
	}
	// 82597BD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82597BDC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82597BE0: 4BF71281  bl 0x82508e60
	ctx.lr = 0x82597BE4;
	sub_82508E60(ctx, base);
	// 82597BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82597BE8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82597BEC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82597BF0: 388AA358  addi r4, r10, -0x5ca8
	ctx.r[4].s64 = ctx.r[10].s64 + -23720;
	// 82597BF4: 38A00039  li r5, 0x39
	ctx.r[5].s64 = 57;
	// 82597BF8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82597BFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82597C00: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82597C04: 488C0E3D  bl 0x82e58a40
	ctx.lr = 0x82597C08;
	sub_82E58A40(ctx, base);
	// 82597C08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82597C0C: 4885A085  bl 0x82df1c90
	ctx.lr = 0x82597C10;
	sub_82DF1C90(ctx, base);
	// 82597C10: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82597C14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82597C18: 419A0008  beq cr6, 0x82597c20
	if ctx.cr[6].eq {
	pc = 0x82597C20; continue 'dispatch;
	}
	// 82597C1C: 4BD28C75  bl 0x822c0890
	ctx.lr = 0x82597C20;
	sub_822C0890(ctx, base);
	// 82597C20: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82597C24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82597C28: 419A0008  beq cr6, 0x82597c30
	if ctx.cr[6].eq {
	pc = 0x82597C30; continue 'dispatch;
	}
	// 82597C2C: 4BD28C65  bl 0x822c0890
	ctx.lr = 0x82597C30;
	sub_822C0890(ctx, base);
	// 82597C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597C34: 4BF7899D  bl 0x825105d0
	ctx.lr = 0x82597C38;
	sub_825105D0(ctx, base);
	// 82597C38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82597C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82597C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82597C44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82597C48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82597C4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597C50 size=184
    let mut pc: u32 = 0x82597C50;
    'dispatch: loop {
        match pc {
            0x82597C50 => {
    //   block [0x82597C50..0x82597D08)
	// 82597C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597C58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82597C5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82597C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597C64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82597C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82597C6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82597C70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82597C74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82597C78: 4BD28CC1  bl 0x822c0938
	ctx.lr = 0x82597C7C;
	sub_822C0938(ctx, base);
	// 82597C7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82597C80: 41820028  beq 0x82597ca8
	if ctx.cr[0].eq {
	pc = 0x82597CA8; continue 'dispatch;
	}
	// 82597C84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82597C88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82597C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82597C90: 392BA294  addi r9, r11, -0x5d6c
	ctx.r[9].s64 = ctx.r[11].s64 + -23916;
	// 82597C94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82597C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82597C9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82597CA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82597CA4: 48000008  b 0x82597cac
	pc = 0x82597CAC; continue 'dispatch;
	// 82597CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82597CAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82597CB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82597CB4: 409A0038  bne cr6, 0x82597cec
	if !ctx.cr[6].eq {
	pc = 0x82597CEC; continue 'dispatch;
	}
	// 82597CB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82597CBC: 419A0010  beq cr6, 0x82597ccc
	if ctx.cr[6].eq {
	pc = 0x82597CCC; continue 'dispatch;
	}
	// 82597CC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82597CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597CC8: 4BFFFE31  bl 0x82597af8
	ctx.lr = 0x82597CCC;
	sub_82597AF8(ctx, base);
	// 82597CCC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82597CD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82597CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82597CD8: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82597CDC: 816B6AAC  lwz r11, 0x6aac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27308 as u32) ) } as u64;
	// 82597CE0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82597CE4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82597CE8: 4BD28319  bl 0x822c0000
	ctx.lr = 0x82597CEC;
	sub_822C0000(ctx, base);
	// 82597CEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82597CF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82597CF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82597CF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82597CFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82597D00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82597D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82597D08 size=12
    let mut pc: u32 = 0x82597D08;
    'dispatch: loop {
        match pc {
            0x82597D08 => {
    //   block [0x82597D08..0x82597D14)
	// 82597D08: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82597D0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82597D10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597D14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82597D14 size=8
    let mut pc: u32 = 0x82597D14;
    'dispatch: loop {
        match pc {
            0x82597D14 => {
    //   block [0x82597D14..0x82597D1C)
	// 82597D14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82597D18: 4BFFFDE0  b 0x82597af8
	sub_82597AF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597D1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82597D1C size=4
    let mut pc: u32 = 0x82597D1C;
    'dispatch: loop {
        match pc {
            0x82597D1C => {
    //   block [0x82597D1C..0x82597D20)
	// 82597D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82597D20 size=424
    let mut pc: u32 = 0x82597D20;
    'dispatch: loop {
        match pc {
            0x82597D20 => {
    //   block [0x82597D20..0x82597EC8)
	// 82597D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597D24: 48C10441  bl 0x831a8164
	ctx.lr = 0x82597D28;
	sub_831A8130(ctx, base);
	// 82597D28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597D2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82597D30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82597D34: 3BCBA358  addi r30, r11, -0x5ca8
	ctx.r[30].s64 = ctx.r[11].s64 + -23720;
	// 82597D38: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82597D3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82597D40: 38A0001B  li r5, 0x1b
	ctx.r[5].s64 = 27;
	// 82597D44: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82597D48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82597D4C: 386000EC  li r3, 0xec
	ctx.r[3].s64 = 236;
	// 82597D50: 4885A699  bl 0x82df23e8
	ctx.lr = 0x82597D54;
	sub_82DF23E8(ctx, base);
	// 82597D54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82597D58: 41820010  beq 0x82597d68
	if ctx.cr[0].eq {
	pc = 0x82597D68; continue 'dispatch;
	}
	// 82597D5C: 4BFFFCBD  bl 0x82597a18
	ctx.lr = 0x82597D60;
	sub_82597A18(ctx, base);
	// 82597D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82597D64: 48000008  b 0x82597d6c
	pc = 0x82597D6C; continue 'dispatch;
	// 82597D68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82597D6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82597D70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597D74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82597D78: 4BFFFB11  bl 0x82597888
	ctx.lr = 0x82597D7C;
	sub_82597888(ctx, base);
	// 82597D7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82597D80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597D84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82597D88: 4BD28279  bl 0x822c0000
	ctx.lr = 0x82597D8C;
	sub_822C0000(ctx, base);
	// 82597D8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82597D90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82597D94: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 82597D98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82597D9C: 4BD2863D  bl 0x822c03d8
	ctx.lr = 0x82597DA0;
	sub_822C03D8(ctx, base);
	// 82597DA0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82597DA4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82597DA8: 418200B4  beq 0x82597e5c
	if ctx.cr[0].eq {
	pc = 0x82597E5C; continue 'dispatch;
	}
	// 82597DAC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82597DB0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82597DB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82597DB8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82597DBC: 409A0008  bne cr6, 0x82597dc4
	if !ctx.cr[6].eq {
	pc = 0x82597DC4; continue 'dispatch;
	}
	// 82597DC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82597DC4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82597DC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82597DCC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82597DD0: 419A0024  beq cr6, 0x82597df4
	if ctx.cr[6].eq {
	pc = 0x82597DF4; continue 'dispatch;
	}
	// 82597DD4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82597DD8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82597DDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82597DE0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82597DE4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82597DE8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82597DEC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82597DF0: 4082FFE8  bne 0x82597dd8
	if !ctx.cr[0].eq {
	pc = 0x82597DD8; continue 'dispatch;
	}
	// 82597DF4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82597DF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82597DFC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82597E00: 419A0024  beq cr6, 0x82597e24
	if ctx.cr[6].eq {
	pc = 0x82597E24; continue 'dispatch;
	}
	// 82597E04: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82597E08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82597E0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82597E10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82597E14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82597E18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82597E1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82597E20: 4082FFE8  bne 0x82597e08
	if !ctx.cr[0].eq {
	pc = 0x82597E08; continue 'dispatch;
	}
	// 82597E24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82597E28: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82597E2C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82597E30: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82597E34: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82597E38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82597E3C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82597E40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82597E44: 482010ED  bl 0x82798f30
	ctx.lr = 0x82597E48;
	sub_82798F30(ctx, base);
	// 82597E48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82597E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597E50: 48203819  bl 0x8279b668
	ctx.lr = 0x82597E54;
	sub_8279B668(ctx, base);
	// 82597E54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82597E58: 48000008  b 0x82597e60
	pc = 0x82597E60; continue 'dispatch;
	// 82597E5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82597E60: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82597E64: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82597E68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82597E70: 4BFFFDE1  bl 0x82597c50
	ctx.lr = 0x82597E74;
	sub_82597C50(ctx, base);
	// 82597E74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82597E78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597E7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82597E80: 4BD28181  bl 0x822c0000
	ctx.lr = 0x82597E84;
	sub_822C0000(ctx, base);
	// 82597E84: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82597E88: 41820024  beq 0x82597eac
	if ctx.cr[0].eq {
	pc = 0x82597EAC; continue 'dispatch;
	}
	// 82597E8C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82597E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82597E94: 419A0008  beq cr6, 0x82597e9c
	if ctx.cr[6].eq {
	pc = 0x82597E9C; continue 'dispatch;
	}
	// 82597E98: 4BD289F9  bl 0x822c0890
	ctx.lr = 0x82597E9C;
	sub_822C0890(ctx, base);
	// 82597E9C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82597EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82597EA4: 419A0008  beq cr6, 0x82597eac
	if ctx.cr[6].eq {
	pc = 0x82597EAC; continue 'dispatch;
	}
	// 82597EA8: 4BD289E9  bl 0x822c0890
	ctx.lr = 0x82597EAC;
	sub_822C0890(ctx, base);
	// 82597EAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82597EB0: 419A000C  beq cr6, 0x82597ebc
	if ctx.cr[6].eq {
	pc = 0x82597EBC; continue 'dispatch;
	}
	// 82597EB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82597EB8: 4BD289D9  bl 0x822c0890
	ctx.lr = 0x82597EBC;
	sub_822C0890(ctx, base);
	// 82597EBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82597EC0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82597EC4: 48C102F0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597EC8 size=48
    let mut pc: u32 = 0x82597EC8;
    'dispatch: loop {
        match pc {
            0x82597EC8 => {
    //   block [0x82597EC8..0x82597EF8)
	// 82597EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597ED0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597ED4: 39600013  li r11, 0x13
	ctx.r[11].s64 = 19;
	// 82597ED8: 80640018  lwz r3, 0x18(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82597EDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82597EE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82597EE4: 4BF1D2F5  bl 0x824b51d8
	ctx.lr = 0x82597EE8;
	sub_824B51D8(ctx, base);
	// 82597EE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82597EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82597EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82597EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597EF8 size=164
    let mut pc: u32 = 0x82597EF8;
    'dispatch: loop {
        match pc {
            0x82597EF8 => {
    //   block [0x82597EF8..0x82597F9C)
	// 82597EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597EFC: 48C1026D  bl 0x831a8168
	ctx.lr = 0x82597F00;
	sub_831A8130(ctx, base);
	// 82597F00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597F04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82597F08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82597F0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82597F10: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82597F14: 41820038  beq 0x82597f4c
	if ctx.cr[0].eq {
	pc = 0x82597F4C; continue 'dispatch;
	}
	// 82597F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597F1C: 48C11A6D  bl 0x831a9988
	ctx.lr = 0x82597F20;
	sub_831A9988(ctx, base);
	// 82597F20: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82597F24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82597F28: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 82597F2C: 48C101CD  bl 0x831a80f8
	ctx.lr = 0x82597F30;
	sub_831A80F8(ctx, base);
	// 82597F30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82597F34: 41820018  beq 0x82597f4c
	if ctx.cr[0].eq {
	pc = 0x82597F4C; continue 'dispatch;
	}
	// 82597F38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597F3C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82597F40: 4BFFFF89  bl 0x82597ec8
	ctx.lr = 0x82597F44;
	sub_82597EC8(ctx, base);
	// 82597F44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82597F48: 4800004C  b 0x82597f94
	pc = 0x82597F94; continue 'dispatch;
	// 82597F4C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82597F50: 419A0034  beq cr6, 0x82597f84
	if ctx.cr[6].eq {
	pc = 0x82597F84; continue 'dispatch;
	}
	// 82597F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82597F58: 48C11A31  bl 0x831a9988
	ctx.lr = 0x82597F5C;
	sub_831A9988(ctx, base);
	// 82597F5C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82597F60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82597F64: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 82597F68: 48C10191  bl 0x831a80f8
	ctx.lr = 0x82597F6C;
	sub_831A80F8(ctx, base);
	// 82597F6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82597F70: 41820014  beq 0x82597f84
	if ctx.cr[0].eq {
	pc = 0x82597F84; continue 'dispatch;
	}
	// 82597F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597F78: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82597F7C: 4BFFFBDD  bl 0x82597b58
	ctx.lr = 0x82597F80;
	sub_82597B58(ctx, base);
	// 82597F80: 4BFFFFC4  b 0x82597f44
	pc = 0x82597F44; continue 'dispatch;
	// 82597F84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82597F88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82597F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82597F90: 4BF7A689  bl 0x82512618
	ctx.lr = 0x82597F94;
	sub_82512618(ctx, base);
	// 82597F94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82597F98: 48C10220  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82597FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82597FA0 size=196
    let mut pc: u32 = 0x82597FA0;
    'dispatch: loop {
        match pc {
            0x82597FA0 => {
    //   block [0x82597FA0..0x82598064)
	// 82597FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82597FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82597FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82597FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82597FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82597FB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82597FB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82597FBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82597FC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82597FC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82597FC8: 4BD28971  bl 0x822c0938
	ctx.lr = 0x82597FCC;
	sub_822C0938(ctx, base);
	// 82597FCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82597FD0: 41820028  beq 0x82597ff8
	if ctx.cr[0].eq {
	pc = 0x82597FF8; continue 'dispatch;
	}
	// 82597FD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82597FD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82597FDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82597FE0: 392BA3A4  addi r9, r11, -0x5c5c
	ctx.r[9].s64 = ctx.r[11].s64 + -23644;
	// 82597FE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82597FE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82597FEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82597FF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82597FF4: 48000008  b 0x82597ffc
	pc = 0x82597FFC; continue 'dispatch;
	// 82597FF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82597FFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82598000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598004: 409A0044  bne cr6, 0x82598048
	if !ctx.cr[6].eq {
	pc = 0x82598048; continue 'dispatch;
	}
	// 82598008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259800C: 419A001C  beq cr6, 0x82598028
	if ctx.cr[6].eq {
	pc = 0x82598028; continue 'dispatch;
	}
	// 82598010: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598014: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82598018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259801C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82598024: 4E800421  bctrl
	ctx.lr = 0x82598028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82598028: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259802C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82598030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598034: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82598038: 816B6C3C  lwz r11, 0x6c3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27708 as u32) ) } as u64;
	// 8259803C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82598040: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82598044: 4BD27FBD  bl 0x822c0000
	ctx.lr = 0x82598048;
	sub_822C0000(ctx, base);
	// 82598048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259804C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82598050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82598054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82598058: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259805C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82598060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82598068 size=196
    let mut pc: u32 = 0x82598068;
    'dispatch: loop {
        match pc {
            0x82598068 => {
    //   block [0x82598068..0x8259812C)
	// 82598068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259806C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82598070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82598074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82598078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259807C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82598080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82598084: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82598088: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259808C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82598090: 4BD288A9  bl 0x822c0938
	ctx.lr = 0x82598094;
	sub_822C0938(ctx, base);
	// 82598094: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598098: 41820028  beq 0x825980c0
	if ctx.cr[0].eq {
	pc = 0x825980C0; continue 'dispatch;
	}
	// 8259809C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825980A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825980A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825980A8: 392BA3B8  addi r9, r11, -0x5c48
	ctx.r[9].s64 = ctx.r[11].s64 + -23624;
	// 825980AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825980B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825980B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825980B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825980BC: 48000008  b 0x825980c4
	pc = 0x825980C4; continue 'dispatch;
	// 825980C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825980C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825980C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825980CC: 409A0044  bne cr6, 0x82598110
	if !ctx.cr[6].eq {
	pc = 0x82598110; continue 'dispatch;
	}
	// 825980D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825980D4: 419A001C  beq cr6, 0x825980f0
	if ctx.cr[6].eq {
	pc = 0x825980F0; continue 'dispatch;
	}
	// 825980D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825980DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825980E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825980E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825980E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825980EC: 4E800421  bctrl
	ctx.lr = 0x825980F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825980F0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825980F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825980F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825980FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82598100: 816B6C3C  lwz r11, 0x6c3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27708 as u32) ) } as u64;
	// 82598104: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82598108: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259810C: 4BD27EF5  bl 0x822c0000
	ctx.lr = 0x82598110;
	sub_822C0000(ctx, base);
	// 82598110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82598118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259811C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82598120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82598124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82598128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82598130 size=196
    let mut pc: u32 = 0x82598130;
    'dispatch: loop {
        match pc {
            0x82598130 => {
    //   block [0x82598130..0x825981F4)
	// 82598130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82598134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82598138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259813C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82598140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82598144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82598148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259814C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82598150: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82598154: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82598158: 4BD287E1  bl 0x822c0938
	ctx.lr = 0x8259815C;
	sub_822C0938(ctx, base);
	// 8259815C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598160: 41820028  beq 0x82598188
	if ctx.cr[0].eq {
	pc = 0x82598188; continue 'dispatch;
	}
	// 82598164: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598168: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259816C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82598170: 392BA3CC  addi r9, r11, -0x5c34
	ctx.r[9].s64 = ctx.r[11].s64 + -23604;
	// 82598174: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82598178: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259817C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82598180: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82598184: 48000008  b 0x8259818c
	pc = 0x8259818C; continue 'dispatch;
	// 82598188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259818C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82598190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598194: 409A0044  bne cr6, 0x825981d8
	if !ctx.cr[6].eq {
	pc = 0x825981D8; continue 'dispatch;
	}
	// 82598198: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259819C: 419A001C  beq cr6, 0x825981b8
	if ctx.cr[6].eq {
	pc = 0x825981B8; continue 'dispatch;
	}
	// 825981A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825981A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825981A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825981AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825981B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825981B4: 4E800421  bctrl
	ctx.lr = 0x825981B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825981B8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825981BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825981C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825981C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825981C8: 816B6C3C  lwz r11, 0x6c3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27708 as u32) ) } as u64;
	// 825981CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825981D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825981D4: 4BD27E2D  bl 0x822c0000
	ctx.lr = 0x825981D8;
	sub_822C0000(ctx, base);
	// 825981D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825981DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825981E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825981E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825981E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825981EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825981F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825981F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825981F8 size=196
    let mut pc: u32 = 0x825981F8;
    'dispatch: loop {
        match pc {
            0x825981F8 => {
    //   block [0x825981F8..0x825982BC)
	// 825981F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825981FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82598200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82598204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82598208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259820C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82598210: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82598214: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82598218: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259821C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82598220: 4BD28719  bl 0x822c0938
	ctx.lr = 0x82598224;
	sub_822C0938(ctx, base);
	// 82598224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598228: 41820028  beq 0x82598250
	if ctx.cr[0].eq {
	pc = 0x82598250; continue 'dispatch;
	}
	// 8259822C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598230: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82598234: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82598238: 392BA3E0  addi r9, r11, -0x5c20
	ctx.r[9].s64 = ctx.r[11].s64 + -23584;
	// 8259823C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82598240: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82598244: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82598248: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259824C: 48000008  b 0x82598254
	pc = 0x82598254; continue 'dispatch;
	// 82598250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82598254: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82598258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259825C: 409A0044  bne cr6, 0x825982a0
	if !ctx.cr[6].eq {
	pc = 0x825982A0; continue 'dispatch;
	}
	// 82598260: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82598264: 419A001C  beq cr6, 0x82598280
	if ctx.cr[6].eq {
	pc = 0x82598280; continue 'dispatch;
	}
	// 82598268: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259826C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82598270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598274: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259827C: 4E800421  bctrl
	ctx.lr = 0x82598280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82598280: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82598284: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82598288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259828C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82598290: 816B6C3C  lwz r11, 0x6c3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27708 as u32) ) } as u64;
	// 82598294: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82598298: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259829C: 4BD27D65  bl 0x822c0000
	ctx.lr = 0x825982A0;
	sub_822C0000(ctx, base);
	// 825982A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825982A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825982A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825982AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825982B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825982B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825982B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825982C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825982C0 size=136
    let mut pc: u32 = 0x825982C0;
    'dispatch: loop {
        match pc {
            0x825982C0 => {
    //   block [0x825982C0..0x82598348)
	// 825982C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825982C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825982C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825982CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825982D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825982D4: 4BF7A05D  bl 0x82512330
	ctx.lr = 0x825982D8;
	sub_82512330(ctx, base);
	// 825982D8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825982DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825982E0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825982E4: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825982E8: 38CBA214  addi r6, r11, -0x5dec
	ctx.r[6].s64 = ctx.r[11].s64 + -24044;
	// 825982EC: C00AD0F8  lfs f0, -0x2f08(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825982F0: 3949A454  addi r10, r9, -0x5bac
	ctx.r[10].s64 = ctx.r[9].s64 + -23468;
	// 825982F4: 3928A440  addi r9, r8, -0x5bc0
	ctx.r[9].s64 = ctx.r[8].s64 + -23488;
	// 825982F8: 90DF00E4  stw r6, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[6].u32 ) };
	// 825982FC: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82598300: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82598304: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82598308: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259830C: 3907A3F4  addi r8, r7, -0x5c0c
	ctx.r[8].s64 = ctx.r[7].s64 + -23564;
	// 82598310: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82598314: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82598318: 997F00E8  stb r11, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 8259831C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82598320: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82598324: 915F00EC  stw r10, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 82598328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259832C: 913F00F0  stw r9, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[9].u32 ) };
	// 82598330: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82598334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82598338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259833C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82598340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82598344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82598348 size=1196
    let mut pc: u32 = 0x82598348;
    'dispatch: loop {
        match pc {
            0x82598348 => {
    //   block [0x82598348..0x825987F4)
	// 82598348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259834C: 48C0FE15  bl 0x831a8160
	ctx.lr = 0x82598350;
	sub_831A8130(ctx, base);
	// 82598350: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82598354: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598358: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259835C: 3B8BA590  addi r28, r11, -0x5a70
	ctx.r[28].s64 = ctx.r[11].s64 + -23152;
	// 82598360: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82598364: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82598368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259836C: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 82598370: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82598374: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82598378: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8259837C: 4BD2805D  bl 0x822c03d8
	ctx.lr = 0x82598380;
	sub_822C03D8(ctx, base);
	// 82598380: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82598384: 41820034  beq 0x825983b8
	if ctx.cr[0].eq {
	pc = 0x825983B8; continue 'dispatch;
	}
	// 82598388: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259838C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598390: 388BA580  addi r4, r11, -0x5a80
	ctx.r[4].s64 = ctx.r[11].s64 + -23168;
	// 82598394: 4885B675  bl 0x82df3a08
	ctx.lr = 0x82598398;
	sub_82DF3A08(ctx, base);
	// 82598398: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259839C: 38BD0008  addi r5, r29, 8
	ctx.r[5].s64 = ctx.r[29].s64 + 8;
	// 825983A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825983A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825983A8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825983AC: 48014065  bl 0x825ac410
	ctx.lr = 0x825983B0;
	sub_825AC410(ctx, base);
	// 825983B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825983B4: 48000008  b 0x825983bc
	pc = 0x825983BC; continue 'dispatch;
	// 825983B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825983BC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825983C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825983C4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825983C8: 4BF5AFF1  bl 0x824f33b8
	ctx.lr = 0x825983CC;
	sub_824F33B8(ctx, base);
	// 825983CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825983D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825983D4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825983D8: 4BD27C29  bl 0x822c0000
	ctx.lr = 0x825983DC;
	sub_822C0000(ctx, base);
	// 825983DC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825983E0: 41820010  beq 0x825983f0
	if ctx.cr[0].eq {
	pc = 0x825983F0; continue 'dispatch;
	}
	// 825983E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825983E8: 57DE003C  rlwinm r30, r30, 0, 0, 0x1e
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 825983EC: 4885B03D  bl 0x82df3428
	ctx.lr = 0x825983F0;
	sub_82DF3428(ctx, base);
	// 825983F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825983F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825983F8: 388BA568  addi r4, r11, -0x5a98
	ctx.r[4].s64 = ctx.r[11].s64 + -23192;
	// 825983FC: 4885B60D  bl 0x82df3a08
	ctx.lr = 0x82598400;
	sub_82DF3A08(ctx, base);
	// 82598400: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82598404: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598408: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259840C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598410: 480139B1  bl 0x825abdc0
	ctx.lr = 0x82598414;
	sub_825ABDC0(ctx, base);
	// 82598414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598418: 4885B011  bl 0x82df3428
	ctx.lr = 0x8259841C;
	sub_82DF3428(ctx, base);
	// 8259841C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598424: 388BA54C  addi r4, r11, -0x5ab4
	ctx.r[4].s64 = ctx.r[11].s64 + -23220;
	// 82598428: 4885B5E1  bl 0x82df3a08
	ctx.lr = 0x8259842C;
	sub_82DF3A08(ctx, base);
	// 8259842C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598430: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82598434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598438: 48013989  bl 0x825abdc0
	ctx.lr = 0x8259843C;
	sub_825ABDC0(ctx, base);
	// 8259843C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598440: 4885AFE9  bl 0x82df3428
	ctx.lr = 0x82598444;
	sub_82DF3428(ctx, base);
	// 82598444: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259844C: 388BA534  addi r4, r11, -0x5acc
	ctx.r[4].s64 = ctx.r[11].s64 + -23244;
	// 82598450: 4885B5B9  bl 0x82df3a08
	ctx.lr = 0x82598454;
	sub_82DF3A08(ctx, base);
	// 82598454: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598458: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8259845C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598460: 48013961  bl 0x825abdc0
	ctx.lr = 0x82598464;
	sub_825ABDC0(ctx, base);
	// 82598464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598468: 4885AFC1  bl 0x82df3428
	ctx.lr = 0x8259846C;
	sub_82DF3428(ctx, base);
	// 8259846C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598474: 388BA514  addi r4, r11, -0x5aec
	ctx.r[4].s64 = ctx.r[11].s64 + -23276;
	// 82598478: 4885B591  bl 0x82df3a08
	ctx.lr = 0x8259847C;
	sub_82DF3A08(ctx, base);
	// 8259847C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598480: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82598484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598488: 48013939  bl 0x825abdc0
	ctx.lr = 0x8259848C;
	sub_825ABDC0(ctx, base);
	// 8259848C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598490: 4885AF99  bl 0x82df3428
	ctx.lr = 0x82598494;
	sub_82DF3428(ctx, base);
	// 82598494: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259849C: 388BA508  addi r4, r11, -0x5af8
	ctx.r[4].s64 = ctx.r[11].s64 + -23288;
	// 825984A0: 4885B569  bl 0x82df3a08
	ctx.lr = 0x825984A4;
	sub_82DF3A08(ctx, base);
	// 825984A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825984A8: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825984AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825984B0: 48013911  bl 0x825abdc0
	ctx.lr = 0x825984B4;
	sub_825ABDC0(ctx, base);
	// 825984B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825984B8: 4885AF71  bl 0x82df3428
	ctx.lr = 0x825984BC;
	sub_82DF3428(ctx, base);
	// 825984BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825984C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825984C4: 388BA4F4  addi r4, r11, -0x5b0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23308;
	// 825984C8: 4885B541  bl 0x82df3a08
	ctx.lr = 0x825984CC;
	sub_82DF3A08(ctx, base);
	// 825984CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825984D0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 825984D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825984D8: 480138E9  bl 0x825abdc0
	ctx.lr = 0x825984DC;
	sub_825ABDC0(ctx, base);
	// 825984DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825984E0: 4885AF49  bl 0x82df3428
	ctx.lr = 0x825984E4;
	sub_82DF3428(ctx, base);
	// 825984E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825984E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825984EC: 388BA4E4  addi r4, r11, -0x5b1c
	ctx.r[4].s64 = ctx.r[11].s64 + -23324;
	// 825984F0: 4885B519  bl 0x82df3a08
	ctx.lr = 0x825984F4;
	sub_82DF3A08(ctx, base);
	// 825984F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825984F8: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 825984FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598500: 480138C1  bl 0x825abdc0
	ctx.lr = 0x82598504;
	sub_825ABDC0(ctx, base);
	// 82598504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598508: 4885AF21  bl 0x82df3428
	ctx.lr = 0x8259850C;
	sub_82DF3428(ctx, base);
	// 8259850C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598514: 388BA4D8  addi r4, r11, -0x5b28
	ctx.r[4].s64 = ctx.r[11].s64 + -23336;
	// 82598518: 4885B4F1  bl 0x82df3a08
	ctx.lr = 0x8259851C;
	sub_82DF3A08(ctx, base);
	// 8259851C: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82598520: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82598524: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82598528: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 8259852C: 419A0024  beq cr6, 0x82598550
	if ctx.cr[6].eq {
	pc = 0x82598550; continue 'dispatch;
	}
	// 82598530: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82598534: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259853C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598544: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598548: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259854C: 4082FFE8  bne 0x82598534
	if !ctx.cr[0].eq {
	pc = 0x82598534; continue 'dispatch;
	}
	// 82598550: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82598554: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82598558: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259855C: 48009BB5  bl 0x825a2110
	ctx.lr = 0x82598560;
	sub_825A2110(ctx, base);
	// 82598560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598564: 4885AEC5  bl 0x82df3428
	ctx.lr = 0x82598568;
	sub_82DF3428(ctx, base);
	// 82598568: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259856C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82598570: 3BEB7C1C  addi r31, r11, 0x7c1c
	ctx.r[31].s64 = ctx.r[11].s64 + 31772;
	// 82598574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82598578: 4885B491  bl 0x82df3a08
	ctx.lr = 0x8259857C;
	sub_82DF3A08(ctx, base);
	// 8259857C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82598580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82598584: 4885B485  bl 0x82df3a08
	ctx.lr = 0x82598588;
	sub_82DF3A08(ctx, base);
	// 82598588: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8259858C: 38E02710  li r7, 0x2710
	ctx.r[7].s64 = 10000;
	// 82598590: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82598594: 38BD000C  addi r5, r29, 0xc
	ctx.r[5].s64 = ctx.r[29].s64 + 12;
	// 82598598: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259859C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825985A0: 4800AE79  bl 0x825a3418
	ctx.lr = 0x825985A4;
	sub_825A3418(ctx, base);
	// 825985A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825985A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825985AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825985B0: 48009929  bl 0x825a1ed8
	ctx.lr = 0x825985B4;
	sub_825A1ED8(ctx, base);
	// 825985B4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825985B8: 4885AE71  bl 0x82df3428
	ctx.lr = 0x825985BC;
	sub_82DF3428(ctx, base);
	// 825985BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825985C0: 4BD306F9  bl 0x822c8cb8
	ctx.lr = 0x825985C4;
	sub_822C8CB8(ctx, base);
	// 825985C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825985C8: 4885AE61  bl 0x82df3428
	ctx.lr = 0x825985CC;
	sub_82DF3428(ctx, base);
	// 825985CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825985D0: 4885AE59  bl 0x82df3428
	ctx.lr = 0x825985D4;
	sub_82DF3428(ctx, base);
	// 825985D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825985D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825985DC: 38A0008B  li r5, 0x8b
	ctx.r[5].s64 = 139;
	// 825985E0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825985E4: 4BD27DF5  bl 0x822c03d8
	ctx.lr = 0x825985E8;
	sub_822C03D8(ctx, base);
	// 825985E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825985EC: 41820034  beq 0x82598620
	if ctx.cr[0].eq {
	pc = 0x82598620; continue 'dispatch;
	}
	// 825985F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825985F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825985F8: 388BA4C8  addi r4, r11, -0x5b38
	ctx.r[4].s64 = ctx.r[11].s64 + -23352;
	// 825985FC: 4885B40D  bl 0x82df3a08
	ctx.lr = 0x82598600;
	sub_82DF3A08(ctx, base);
	// 82598600: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82598604: 38BD0010  addi r5, r29, 0x10
	ctx.r[5].s64 = ctx.r[29].s64 + 16;
	// 82598608: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259860C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598610: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	// 82598614: 48013DFD  bl 0x825ac410
	ctx.lr = 0x82598618;
	sub_825AC410(ctx, base);
	// 82598618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259861C: 48000008  b 0x82598624
	pc = 0x82598624; continue 'dispatch;
	// 82598620: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82598624: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82598628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259862C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82598630: 4BF5AD89  bl 0x824f33b8
	ctx.lr = 0x82598634;
	sub_824F33B8(ctx, base);
	// 82598634: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82598638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259863C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82598640: 4BD279C1  bl 0x822c0000
	ctx.lr = 0x82598644;
	sub_822C0000(ctx, base);
	// 82598644: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82598648: 4182000C  beq 0x82598654
	if ctx.cr[0].eq {
	pc = 0x82598654; continue 'dispatch;
	}
	// 8259864C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82598650: 4885ADD9  bl 0x82df3428
	ctx.lr = 0x82598654;
	sub_82DF3428(ctx, base);
	// 82598654: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598658: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259865C: 388BA4C0  addi r4, r11, -0x5b40
	ctx.r[4].s64 = ctx.r[11].s64 + -23360;
	// 82598660: 4885B3A9  bl 0x82df3a08
	ctx.lr = 0x82598664;
	sub_82DF3A08(ctx, base);
	// 82598664: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82598668: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8259866C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82598670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82598674: 4801374D  bl 0x825abdc0
	ctx.lr = 0x82598678;
	sub_825ABDC0(ctx, base);
	// 82598678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259867C: 4885ADAD  bl 0x82df3428
	ctx.lr = 0x82598680;
	sub_82DF3428(ctx, base);
	// 82598680: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598684: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82598688: 388BA4B8  addi r4, r11, -0x5b48
	ctx.r[4].s64 = ctx.r[11].s64 + -23368;
	// 8259868C: 4885B37D  bl 0x82df3a08
	ctx.lr = 0x82598690;
	sub_82DF3A08(ctx, base);
	// 82598690: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82598694: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82598698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259869C: 48013725  bl 0x825abdc0
	ctx.lr = 0x825986A0;
	sub_825ABDC0(ctx, base);
	// 825986A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825986A4: 4885AD85  bl 0x82df3428
	ctx.lr = 0x825986A8;
	sub_82DF3428(ctx, base);
	// 825986A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825986AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825986B0: 388BA4B0  addi r4, r11, -0x5b50
	ctx.r[4].s64 = ctx.r[11].s64 + -23376;
	// 825986B4: 4885B355  bl 0x82df3a08
	ctx.lr = 0x825986B8;
	sub_82DF3A08(ctx, base);
	// 825986B8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825986BC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825986C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825986C4: 480136FD  bl 0x825abdc0
	ctx.lr = 0x825986C8;
	sub_825ABDC0(ctx, base);
	// 825986C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825986CC: 4885AD5D  bl 0x82df3428
	ctx.lr = 0x825986D0;
	sub_82DF3428(ctx, base);
	// 825986D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825986D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825986D8: 388BA4A8  addi r4, r11, -0x5b58
	ctx.r[4].s64 = ctx.r[11].s64 + -23384;
	// 825986DC: 4885B32D  bl 0x82df3a08
	ctx.lr = 0x825986E0;
	sub_82DF3A08(ctx, base);
	// 825986E0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825986E4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825986E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825986EC: 480136D5  bl 0x825abdc0
	ctx.lr = 0x825986F0;
	sub_825ABDC0(ctx, base);
	// 825986F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825986F4: 4885AD35  bl 0x82df3428
	ctx.lr = 0x825986F8;
	sub_82DF3428(ctx, base);
	// 825986F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825986FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82598700: 388BA49C  addi r4, r11, -0x5b64
	ctx.r[4].s64 = ctx.r[11].s64 + -23396;
	// 82598704: 4885B305  bl 0x82df3a08
	ctx.lr = 0x82598708;
	sub_82DF3A08(ctx, base);
	// 82598708: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259870C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82598710: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82598714: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82598718: 419A0024  beq cr6, 0x8259873c
	if ctx.cr[6].eq {
	pc = 0x8259873C; continue 'dispatch;
	}
	// 8259871C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82598720: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598724: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598728: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259872C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598730: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598734: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598738: 4082FFE8  bne 0x82598720
	if !ctx.cr[0].eq {
	pc = 0x82598720; continue 'dispatch;
	}
	// 8259873C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82598740: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82598744: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82598748: 480099C9  bl 0x825a2110
	ctx.lr = 0x8259874C;
	sub_825A2110(ctx, base);
	// 8259874C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82598750: 4885ACD9  bl 0x82df3428
	ctx.lr = 0x82598754;
	sub_82DF3428(ctx, base);
	// 82598754: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259875C: 388BA490  addi r4, r11, -0x5b70
	ctx.r[4].s64 = ctx.r[11].s64 + -23408;
	// 82598760: 4885B2A9  bl 0x82df3a08
	ctx.lr = 0x82598764;
	sub_82DF3A08(ctx, base);
	// 82598764: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82598768: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259876C: 388BCAB4  addi r4, r11, -0x354c
	ctx.r[4].s64 = ctx.r[11].s64 + -13644;
	// 82598770: 4885B299  bl 0x82df3a08
	ctx.lr = 0x82598774;
	sub_82DF3A08(ctx, base);
	// 82598774: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82598778: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 8259877C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82598780: 38BD0014  addi r5, r29, 0x14
	ctx.r[5].s64 = ctx.r[29].s64 + 20;
	// 82598784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82598788: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8259878C: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82598790: C04AC350  lfs f2, -0x3cb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82598794: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82598798: 4800AB11  bl 0x825a32a8
	ctx.lr = 0x8259879C;
	sub_825A32A8(ctx, base);
	// 8259879C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825987A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825987A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825987A8: 48008FC9  bl 0x825a1770
	ctx.lr = 0x825987AC;
	sub_825A1770(ctx, base);
	// 825987AC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825987B0: 4885AC79  bl 0x82df3428
	ctx.lr = 0x825987B4;
	sub_82DF3428(ctx, base);
	// 825987B4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825987B8: 4BD30501  bl 0x822c8cb8
	ctx.lr = 0x825987BC;
	sub_822C8CB8(ctx, base);
	// 825987BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825987C0: 4885AC69  bl 0x82df3428
	ctx.lr = 0x825987C4;
	sub_82DF3428(ctx, base);
	// 825987C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825987C8: 4885AC61  bl 0x82df3428
	ctx.lr = 0x825987CC;
	sub_82DF3428(ctx, base);
	// 825987CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825987D0: 419A000C  beq cr6, 0x825987dc
	if ctx.cr[6].eq {
	pc = 0x825987DC; continue 'dispatch;
	}
	// 825987D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825987D8: 4BD280B9  bl 0x822c0890
	ctx.lr = 0x825987DC;
	sub_822C0890(ctx, base);
	// 825987DC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825987E0: 419A000C  beq cr6, 0x825987ec
	if ctx.cr[6].eq {
	pc = 0x825987EC; continue 'dispatch;
	}
	// 825987E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825987E8: 4BD280A9  bl 0x822c0890
	ctx.lr = 0x825987EC;
	sub_822C0890(ctx, base);
	// 825987EC: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 825987F0: 48C0F9C0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825987F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825987F8 size=144
    let mut pc: u32 = 0x825987F8;
    'dispatch: loop {
        match pc {
            0x825987F8 => {
    //   block [0x825987F8..0x82598888)
	// 825987F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825987FC: 48C0F969  bl 0x831a8164
	ctx.lr = 0x82598800;
	sub_831A8130(ctx, base);
	// 82598800: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82598804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82598808: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8259880C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82598810: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82598814: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82598818: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259881C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82598820: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82598824: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82598828: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8259882C: 48859BBD  bl 0x82df23e8
	ctx.lr = 0x82598830;
	sub_82DF23E8(ctx, base);
	// 82598830: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598834: 41820020  beq 0x82598854
	if ctx.cr[0].eq {
	pc = 0x82598854; continue 'dispatch;
	}
	// 82598838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259883C: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82598840: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598844: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598848: 485BCAA1  bl 0x82b552e8
	ctx.lr = 0x8259884C;
	sub_82B552E8(ctx, base);
	// 8259884C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82598850: 48000008  b 0x82598858
	pc = 0x82598858; continue 'dispatch;
	// 82598854: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82598858: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259885C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82598860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82598864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598868: 4BFFF801  bl 0x82598068
	ctx.lr = 0x8259886C;
	sub_82598068(ctx, base);
	// 8259886C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82598870: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82598874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598878: 4BD27789  bl 0x822c0000
	ctx.lr = 0x8259887C;
	sub_822C0000(ctx, base);
	// 8259887C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82598880: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82598884: 48C0F930  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82598888 size=120
    let mut pc: u32 = 0x82598888;
    'dispatch: loop {
        match pc {
            0x82598888 => {
    //   block [0x82598888..0x82598900)
	// 82598888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259888C: 48C0F8E1  bl 0x831a816c
	ctx.lr = 0x82598890;
	sub_831A8130(ctx, base);
	// 82598890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82598894: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82598898: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259889C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825988A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825988A4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825988A8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825988AC: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 825988B0: 48859B39  bl 0x82df23e8
	ctx.lr = 0x825988B4;
	sub_82DF23E8(ctx, base);
	// 825988B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825988B8: 41820014  beq 0x825988cc
	if ctx.cr[0].eq {
	pc = 0x825988CC; continue 'dispatch;
	}
	// 825988BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825988C0: 485BC781  bl 0x82b55040
	ctx.lr = 0x825988C4;
	sub_82B55040(ctx, base);
	// 825988C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825988C8: 48000008  b 0x825988d0
	pc = 0x825988D0; continue 'dispatch;
	// 825988CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825988D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825988D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825988D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825988DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825988E0: 4BFFF851  bl 0x82598130
	ctx.lr = 0x825988E4;
	sub_82598130(ctx, base);
	// 825988E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825988E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825988EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825988F0: 4BD27711  bl 0x822c0000
	ctx.lr = 0x825988F4;
	sub_822C0000(ctx, base);
	// 825988F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825988F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825988FC: 48C0F8C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82598900 size=128
    let mut pc: u32 = 0x82598900;
    'dispatch: loop {
        match pc {
            0x82598900 => {
    //   block [0x82598900..0x82598980)
	// 82598900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82598904: 48C0F869  bl 0x831a816c
	ctx.lr = 0x82598908;
	sub_831A8130(ctx, base);
	// 82598908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259890C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82598910: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82598914: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82598918: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259891C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82598920: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82598924: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82598928: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 8259892C: 48859ABD  bl 0x82df23e8
	ctx.lr = 0x82598930;
	sub_82DF23E8(ctx, base);
	// 82598930: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598934: 41820018  beq 0x8259894c
	if ctx.cr[0].eq {
	pc = 0x8259894C; continue 'dispatch;
	}
	// 82598938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259893C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598940: 485BC769  bl 0x82b550a8
	ctx.lr = 0x82598944;
	sub_82B550A8(ctx, base);
	// 82598944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82598948: 48000008  b 0x82598950
	pc = 0x82598950; continue 'dispatch;
	// 8259894C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82598950: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82598954: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82598958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259895C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598960: 4BFFF899  bl 0x825981f8
	ctx.lr = 0x82598964;
	sub_825981F8(ctx, base);
	// 82598964: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82598968: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259896C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598970: 4BD27691  bl 0x822c0000
	ctx.lr = 0x82598974;
	sub_822C0000(ctx, base);
	// 82598974: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82598978: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259897C: 48C0F840  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82598980 size=1596
    let mut pc: u32 = 0x82598980;
    'dispatch: loop {
        match pc {
            0x82598980 => {
    //   block [0x82598980..0x82598FBC)
	// 82598980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82598984: 48C0F7D5  bl 0x831a8158
	ctx.lr = 0x82598988;
	sub_831A8130(ctx, base);
	// 82598988: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8259898C: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82598990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82598994: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82598998: 4BF79041  bl 0x825119d8
	ctx.lr = 0x8259899C;
	sub_825119D8(ctx, base);
	// 8259899C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825989A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825989A4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825989A8: 4885B061  bl 0x82df3a08
	ctx.lr = 0x825989AC;
	sub_82DF3A08(ctx, base);
	// 825989AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825989B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825989B4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825989B8: 4BF6FDC9  bl 0x82508780
	ctx.lr = 0x825989BC;
	sub_82508780(ctx, base);
	// 825989BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825989C0: 4885AA69  bl 0x82df3428
	ctx.lr = 0x825989C4;
	sub_82DF3428(ctx, base);
	// 825989C4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825989C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825989CC: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 825989D0: 4885B039  bl 0x82df3a08
	ctx.lr = 0x825989D4;
	sub_82DF3A08(ctx, base);
	// 825989D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825989D8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825989DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825989E0: 4BF6FDA1  bl 0x82508780
	ctx.lr = 0x825989E4;
	sub_82508780(ctx, base);
	// 825989E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825989E8: 4885AA41  bl 0x82df3428
	ctx.lr = 0x825989EC;
	sub_82DF3428(ctx, base);
	// 825989EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825989F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825989F4: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825989F8: 409A0008  bne cr6, 0x82598a00
	if !ctx.cr[6].eq {
	pc = 0x82598A00; continue 'dispatch;
	}
	// 825989FC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82598A00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598A04: 4BF6FD9D  bl 0x825087a0
	ctx.lr = 0x82598A08;
	sub_825087A0(ctx, base);
	// 82598A08: 897F00E8  lbz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82598A0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598A10: 408205A0  bne 0x82598fb0
	if !ctx.cr[0].eq {
	pc = 0x82598FB0; continue 'dispatch;
	}
	// 82598A14: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82598A18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82598A1C: 3B200007  li r25, 7
	ctx.r[25].s64 = 7;
	// 82598A20: 3B6B9BC9  addi r27, r11, -0x6437
	ctx.r[27].s64 = ctx.r[11].s64 + -25655;
	// 82598A24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82598A28: 409A00EC  bne cr6, 0x82598b14
	if !ctx.cr[6].eq {
	pc = 0x82598B14; continue 'dispatch;
	}
	// 82598A2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82598A30: 485BC5C9  bl 0x82b54ff8
	ctx.lr = 0x82598A34;
	sub_82B54FF8(ctx, base);
	// 82598A34: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82598A38: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82598A3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82598A40: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82598A44: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82598A48: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82598A4C: 4885AE2D  bl 0x82df3878
	ctx.lr = 0x82598A50;
	sub_82DF3878(ctx, base);
	// 82598A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82598A54: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82598A58: 38FF00F8  addi r7, r31, 0xf8
	ctx.r[7].s64 = ctx.r[31].s64 + 248;
	// 82598A5C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82598A60: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82598A64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598A68: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82598A6C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82598A70: 4BFFFD89  bl 0x825987f8
	ctx.lr = 0x82598A74;
	sub_825987F8(ctx, base);
	// 82598A74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598A78: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82598A7C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598A84: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82598A88: 419A0024  beq cr6, 0x82598aac
	if ctx.cr[6].eq {
	pc = 0x82598AAC; continue 'dispatch;
	}
	// 82598A8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598A90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598A94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598A98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598A9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598AA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598AA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598AA8: 4082FFE8  bne 0x82598a90
	if !ctx.cr[0].eq {
	pc = 0x82598A90; continue 'dispatch;
	}
	// 82598AAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598AB0: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82598AB4: 3B010070  addi r24, r1, 0x70
	ctx.r[24].s64 = ctx.r[1].s64 + 112;
	// 82598AB8: 4BF703A9  bl 0x82508e60
	ctx.lr = 0x82598ABC;
	sub_82508E60(ctx, base);
	// 82598ABC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82598AC0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82598AC4: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 82598AC8: 3BAAA590  addi r29, r10, -0x5a70
	ctx.r[29].s64 = ctx.r[10].s64 + -23152;
	// 82598ACC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598AD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598AD4: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 82598AD8: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82598ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598AE0: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82598AE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598AE8: 488BFF59  bl 0x82e58a40
	ctx.lr = 0x82598AEC;
	sub_82E58A40(ctx, base);
	// 82598AEC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82598AF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598AF4: 419A0008  beq cr6, 0x82598afc
	if ctx.cr[6].eq {
	pc = 0x82598AFC; continue 'dispatch;
	}
	// 82598AF8: 4BD27D99  bl 0x822c0890
	ctx.lr = 0x82598AFC;
	sub_822C0890(ctx, base);
	// 82598AFC: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82598B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598B04: 419A0008  beq cr6, 0x82598b0c
	if ctx.cr[6].eq {
	pc = 0x82598B0C; continue 'dispatch;
	}
	// 82598B08: 4BD27D89  bl 0x822c0890
	ctx.lr = 0x82598B0C;
	sub_822C0890(ctx, base);
	// 82598B0C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82598B10: 4800017C  b 0x82598c8c
	pc = 0x82598C8C; continue 'dispatch;
	// 82598B14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82598B18: 485BC4E1  bl 0x82b54ff8
	ctx.lr = 0x82598B1C;
	sub_82B54FF8(ctx, base);
	// 82598B1C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82598B20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82598B24: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82598B28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82598B2C: 38FF00F8  addi r7, r31, 0xf8
	ctx.r[7].s64 = ctx.r[31].s64 + 248;
	// 82598B30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82598B34: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82598B38: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82598B3C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82598B40: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82598B44: 4BFFFCB5  bl 0x825987f8
	ctx.lr = 0x82598B48;
	sub_825987F8(ctx, base);
	// 82598B48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598B4C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82598B50: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598B58: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82598B5C: 419A0024  beq cr6, 0x82598b80
	if ctx.cr[6].eq {
	pc = 0x82598B80; continue 'dispatch;
	}
	// 82598B60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598B64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598B68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598B6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598B70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598B74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598B78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598B7C: 4082FFE8  bne 0x82598b64
	if !ctx.cr[0].eq {
	pc = 0x82598B64; continue 'dispatch;
	}
	// 82598B80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598B84: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82598B88: 3B010080  addi r24, r1, 0x80
	ctx.r[24].s64 = ctx.r[1].s64 + 128;
	// 82598B8C: 4BF702D5  bl 0x82508e60
	ctx.lr = 0x82598B90;
	sub_82508E60(ctx, base);
	// 82598B90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82598B94: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82598B98: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 82598B9C: 3BAAA590  addi r29, r10, -0x5a70
	ctx.r[29].s64 = ctx.r[10].s64 + -23152;
	// 82598BA0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598BA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598BA8: 38A00047  li r5, 0x47
	ctx.r[5].s64 = 71;
	// 82598BAC: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82598BB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598BB4: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82598BB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598BBC: 488BFE85  bl 0x82e58a40
	ctx.lr = 0x82598BC0;
	sub_82E58A40(ctx, base);
	// 82598BC0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82598BC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598BC8: 419A0008  beq cr6, 0x82598bd0
	if ctx.cr[6].eq {
	pc = 0x82598BD0; continue 'dispatch;
	}
	// 82598BCC: 4BD27CC5  bl 0x822c0890
	ctx.lr = 0x82598BD0;
	sub_822C0890(ctx, base);
	// 82598BD0: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82598BD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598BD8: 419A0008  beq cr6, 0x82598be0
	if ctx.cr[6].eq {
	pc = 0x82598BE0; continue 'dispatch;
	}
	// 82598BDC: 4BD27CB5  bl 0x822c0890
	ctx.lr = 0x82598BE0;
	sub_822C0890(ctx, base);
	// 82598BE0: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82598BE4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82598BE8: 419A00A0  beq cr6, 0x82598c88
	if ctx.cr[6].eq {
	pc = 0x82598C88; continue 'dispatch;
	}
	// 82598BEC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82598BF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82598BF4: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82598BF8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82598BFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82598C00: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82598C04: 4BFFFC85  bl 0x82598888
	ctx.lr = 0x82598C08;
	sub_82598888(ctx, base);
	// 82598C08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598C0C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82598C10: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598C18: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82598C1C: 419A0024  beq cr6, 0x82598c40
	if ctx.cr[6].eq {
	pc = 0x82598C40; continue 'dispatch;
	}
	// 82598C20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598C24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598C28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598C2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598C30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598C34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598C38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598C3C: 4082FFE8  bne 0x82598c24
	if !ctx.cr[0].eq {
	pc = 0x82598C24; continue 'dispatch;
	}
	// 82598C40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598C44: 3B010078  addi r24, r1, 0x78
	ctx.r[24].s64 = ctx.r[1].s64 + 120;
	// 82598C48: 4BF70219  bl 0x82508e60
	ctx.lr = 0x82598C4C;
	sub_82508E60(ctx, base);
	// 82598C4C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598C50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598C54: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598C58: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 82598C5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598C60: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82598C64: 488BFDDD  bl 0x82e58a40
	ctx.lr = 0x82598C68;
	sub_82E58A40(ctx, base);
	// 82598C68: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82598C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598C70: 419A0008  beq cr6, 0x82598c78
	if ctx.cr[6].eq {
	pc = 0x82598C78; continue 'dispatch;
	}
	// 82598C74: 4BD27C1D  bl 0x822c0890
	ctx.lr = 0x82598C78;
	sub_822C0890(ctx, base);
	// 82598C78: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82598C7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598C80: 419A0008  beq cr6, 0x82598c88
	if ctx.cr[6].eq {
	pc = 0x82598C88; continue 'dispatch;
	}
	// 82598C84: 4BD27C0D  bl 0x822c0890
	ctx.lr = 0x82598C88;
	sub_822C0890(ctx, base);
	// 82598C88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82598C8C: 4885A79D  bl 0x82df3428
	ctx.lr = 0x82598C90;
	sub_82DF3428(ctx, base);
	// 82598C90: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82598C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598C98: 409A00C4  bne cr6, 0x82598d5c
	if !ctx.cr[6].eq {
	pc = 0x82598D5C; continue 'dispatch;
	}
	// 82598C9C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82598CA0: 485BC359  bl 0x82b54ff8
	ctx.lr = 0x82598CA4;
	sub_82B54FF8(ctx, base);
	// 82598CA4: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82598CA8: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82598CAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82598CB0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82598CB4: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82598CB8: 914100AC  stw r10, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 82598CBC: 4885ABBD  bl 0x82df3878
	ctx.lr = 0x82598CC0;
	sub_82DF3878(ctx, base);
	// 82598CC0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82598CC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598CC8: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 82598CCC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82598CD0: 4BFFFC31  bl 0x82598900
	ctx.lr = 0x82598CD4;
	sub_82598900(ctx, base);
	// 82598CD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598CD8: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82598CDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598CE4: 916100DC  stw r11, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82598CE8: 419A0024  beq cr6, 0x82598d0c
	if ctx.cr[6].eq {
	pc = 0x82598D0C; continue 'dispatch;
	}
	// 82598CEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598CF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598CF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598CF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598CFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598D00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598D04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598D08: 4082FFE8  bne 0x82598cf0
	if !ctx.cr[0].eq {
	pc = 0x82598CF0; continue 'dispatch;
	}
	// 82598D0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598D10: 3BE100D8  addi r31, r1, 0xd8
	ctx.r[31].s64 = ctx.r[1].s64 + 216;
	// 82598D14: 4BF7014D  bl 0x82508e60
	ctx.lr = 0x82598D18;
	sub_82508E60(ctx, base);
	// 82598D18: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598D1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598D20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598D24: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 82598D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598D2C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82598D30: 488BFD11  bl 0x82e58a40
	ctx.lr = 0x82598D34;
	sub_82E58A40(ctx, base);
	// 82598D34: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82598D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598D3C: 419A0008  beq cr6, 0x82598d44
	if ctx.cr[6].eq {
	pc = 0x82598D44; continue 'dispatch;
	}
	// 82598D40: 4BD27B51  bl 0x822c0890
	ctx.lr = 0x82598D44;
	sub_822C0890(ctx, base);
	// 82598D44: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82598D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598D4C: 419A0008  beq cr6, 0x82598d54
	if ctx.cr[6].eq {
	pc = 0x82598D54; continue 'dispatch;
	}
	// 82598D50: 4BD27B41  bl 0x822c0890
	ctx.lr = 0x82598D54;
	sub_822C0890(ctx, base);
	// 82598D54: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82598D58: 48000254  b 0x82598fac
	pc = 0x82598FAC; continue 'dispatch;
	// 82598D5C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82598D60: 409A00C0  bne cr6, 0x82598e20
	if !ctx.cr[6].eq {
	pc = 0x82598E20; continue 'dispatch;
	}
	// 82598D64: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82598D68: 485BC291  bl 0x82b54ff8
	ctx.lr = 0x82598D6C;
	sub_82B54FF8(ctx, base);
	// 82598D6C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82598D70: 932100C8  stw r25, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[25].u32 ) };
	// 82598D74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82598D78: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82598D7C: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82598D80: 4885AAF9  bl 0x82df3878
	ctx.lr = 0x82598D84;
	sub_82DF3878(ctx, base);
	// 82598D84: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82598D88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598D8C: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 82598D90: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82598D94: 4BFFFB6D  bl 0x82598900
	ctx.lr = 0x82598D98;
	sub_82598900(ctx, base);
	// 82598D98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598D9C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82598DA0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598DA8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82598DAC: 419A0024  beq cr6, 0x82598dd0
	if ctx.cr[6].eq {
	pc = 0x82598DD0; continue 'dispatch;
	}
	// 82598DB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598DB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598DB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598DBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598DC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598DC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598DC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598DCC: 4082FFE8  bne 0x82598db4
	if !ctx.cr[0].eq {
	pc = 0x82598DB4; continue 'dispatch;
	}
	// 82598DD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598DD4: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	// 82598DD8: 4BF70089  bl 0x82508e60
	ctx.lr = 0x82598DDC;
	sub_82508E60(ctx, base);
	// 82598DDC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598DE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598DE4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598DE8: 38A0005D  li r5, 0x5d
	ctx.r[5].s64 = 93;
	// 82598DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598DF0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82598DF4: 488BFC4D  bl 0x82e58a40
	ctx.lr = 0x82598DF8;
	sub_82E58A40(ctx, base);
	// 82598DF8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82598DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598E00: 419A0008  beq cr6, 0x82598e08
	if ctx.cr[6].eq {
	pc = 0x82598E08; continue 'dispatch;
	}
	// 82598E04: 4BD27A8D  bl 0x822c0890
	ctx.lr = 0x82598E08;
	sub_822C0890(ctx, base);
	// 82598E08: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82598E0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598E10: 419A0008  beq cr6, 0x82598e18
	if ctx.cr[6].eq {
	pc = 0x82598E18; continue 'dispatch;
	}
	// 82598E14: 4BD27A7D  bl 0x822c0890
	ctx.lr = 0x82598E18;
	sub_822C0890(ctx, base);
	// 82598E18: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82598E1C: 48000190  b 0x82598fac
	pc = 0x82598FAC; continue 'dispatch;
	// 82598E20: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82598E24: 409A00C4  bne cr6, 0x82598ee8
	if !ctx.cr[6].eq {
	pc = 0x82598EE8; continue 'dispatch;
	}
	// 82598E28: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82598E2C: 485BC1CD  bl 0x82b54ff8
	ctx.lr = 0x82598E30;
	sub_82B54FF8(ctx, base);
	// 82598E30: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82598E34: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82598E38: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82598E3C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82598E40: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82598E44: 914100E4  stw r10, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 82598E48: 4885AA31  bl 0x82df3878
	ctx.lr = 0x82598E4C;
	sub_82DF3878(ctx, base);
	// 82598E4C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82598E50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598E54: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82598E58: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82598E5C: 4BFFFAA5  bl 0x82598900
	ctx.lr = 0x82598E60;
	sub_82598900(ctx, base);
	// 82598E60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598E64: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82598E68: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598E70: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82598E74: 419A0024  beq cr6, 0x82598e98
	if ctx.cr[6].eq {
	pc = 0x82598E98; continue 'dispatch;
	}
	// 82598E78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598E7C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598E80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598E84: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598E88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598E8C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598E90: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598E94: 4082FFE8  bne 0x82598e7c
	if !ctx.cr[0].eq {
	pc = 0x82598E7C; continue 'dispatch;
	}
	// 82598E98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598E9C: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82598EA0: 4BF6FFC1  bl 0x82508e60
	ctx.lr = 0x82598EA4;
	sub_82508E60(ctx, base);
	// 82598EA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598EA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598EAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598EB0: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 82598EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598EB8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82598EBC: 488BFB85  bl 0x82e58a40
	ctx.lr = 0x82598EC0;
	sub_82E58A40(ctx, base);
	// 82598EC0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82598EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598EC8: 419A0008  beq cr6, 0x82598ed0
	if ctx.cr[6].eq {
	pc = 0x82598ED0; continue 'dispatch;
	}
	// 82598ECC: 4BD279C5  bl 0x822c0890
	ctx.lr = 0x82598ED0;
	sub_822C0890(ctx, base);
	// 82598ED0: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82598ED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598ED8: 419A0008  beq cr6, 0x82598ee0
	if ctx.cr[6].eq {
	pc = 0x82598EE0; continue 'dispatch;
	}
	// 82598EDC: 4BD279B5  bl 0x822c0890
	ctx.lr = 0x82598EE0;
	sub_822C0890(ctx, base);
	// 82598EE0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82598EE4: 480000C8  b 0x82598fac
	pc = 0x82598FAC; continue 'dispatch;
	// 82598EE8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82598EEC: 409A00C4  bne cr6, 0x82598fb0
	if !ctx.cr[6].eq {
	pc = 0x82598FB0; continue 'dispatch;
	}
	// 82598EF0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82598EF4: 485BC105  bl 0x82b54ff8
	ctx.lr = 0x82598EF8;
	sub_82B54FF8(ctx, base);
	// 82598EF8: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82598EFC: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82598F00: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82598F04: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82598F08: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82598F0C: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 82598F10: 4885A969  bl 0x82df3878
	ctx.lr = 0x82598F14;
	sub_82DF3878(ctx, base);
	// 82598F14: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82598F18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82598F1C: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 82598F20: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82598F24: 4BFFF9DD  bl 0x82598900
	ctx.lr = 0x82598F28;
	sub_82598900(ctx, base);
	// 82598F28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82598F2C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82598F30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82598F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82598F38: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82598F3C: 419A0024  beq cr6, 0x82598f60
	if ctx.cr[6].eq {
	pc = 0x82598F60; continue 'dispatch;
	}
	// 82598F40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82598F44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82598F48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598F4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82598F50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82598F54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82598F58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82598F5C: 4082FFE8  bne 0x82598f44
	if !ctx.cr[0].eq {
	pc = 0x82598F44; continue 'dispatch;
	}
	// 82598F60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82598F64: 3BE100A0  addi r31, r1, 0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + 160;
	// 82598F68: 4BF6FEF9  bl 0x82508e60
	ctx.lr = 0x82598F6C;
	sub_82508E60(ctx, base);
	// 82598F6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82598F70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82598F74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82598F78: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 82598F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82598F80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82598F84: 488BFABD  bl 0x82e58a40
	ctx.lr = 0x82598F88;
	sub_82E58A40(ctx, base);
	// 82598F88: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82598F8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598F90: 419A0008  beq cr6, 0x82598f98
	if ctx.cr[6].eq {
	pc = 0x82598F98; continue 'dispatch;
	}
	// 82598F94: 4BD278FD  bl 0x822c0890
	ctx.lr = 0x82598F98;
	sub_822C0890(ctx, base);
	// 82598F98: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82598F9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82598FA0: 419A0008  beq cr6, 0x82598fa8
	if ctx.cr[6].eq {
	pc = 0x82598FA8; continue 'dispatch;
	}
	// 82598FA4: 4BD278ED  bl 0x822c0890
	ctx.lr = 0x82598FA8;
	sub_822C0890(ctx, base);
	// 82598FA8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82598FAC: 4885A47D  bl 0x82df3428
	ctx.lr = 0x82598FB0;
	sub_82DF3428(ctx, base);
	// 82598FB0: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82598FB4: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82598FB8: 48C0F1F0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82598FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82598FC0 size=432
    let mut pc: u32 = 0x82598FC0;
    'dispatch: loop {
        match pc {
            0x82598FC0 => {
    //   block [0x82598FC0..0x82599170)
	// 82598FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82598FC4: 48C0F1A5  bl 0x831a8168
	ctx.lr = 0x82598FC8;
	sub_831A8130(ctx, base);
	// 82598FC8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82598FCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82598FD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82598FD4: 3BCBA590  addi r30, r11, -0x5a70
	ctx.r[30].s64 = ctx.r[11].s64 + -23152;
	// 82598FD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82598FDC: 38A0001D  li r5, 0x1d
	ctx.r[5].s64 = 29;
	// 82598FE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82598FE4: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82598FE8: 48859401  bl 0x82df23e8
	ctx.lr = 0x82598FEC;
	sub_82DF23E8(ctx, base);
	// 82598FEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82598FF0: 41820010  beq 0x82599000
	if ctx.cr[0].eq {
	pc = 0x82599000; continue 'dispatch;
	}
	// 82598FF4: 4BFFF2CD  bl 0x825982c0
	ctx.lr = 0x82598FF8;
	sub_825982C0(ctx, base);
	// 82598FF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82598FFC: 48000008  b 0x82599004
	pc = 0x82599004; continue 'dispatch;
	// 82599000: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82599004: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82599008: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259900C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82599010: 4BFFEF91  bl 0x82597fa0
	ctx.lr = 0x82599014;
	sub_82597FA0(ctx, base);
	// 82599014: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82599018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259901C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82599020: 4BD26FE1  bl 0x822c0000
	ctx.lr = 0x82599024;
	sub_822C0000(ctx, base);
	// 82599024: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82599028: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259902C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82599030: 409A0008  bne cr6, 0x82599038
	if !ctx.cr[6].eq {
	pc = 0x82599038; continue 'dispatch;
	}
	// 82599034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82599038: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259903C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82599040: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82599044: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82599048: 419A0024  beq cr6, 0x8259906c
	if ctx.cr[6].eq {
	pc = 0x8259906C; continue 'dispatch;
	}
	// 8259904C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82599050: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82599054: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82599058: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8259905C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82599060: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82599064: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82599068: 4082FFE8  bne 0x82599050
	if !ctx.cr[0].eq {
	pc = 0x82599050; continue 'dispatch;
	}
	// 8259906C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82599070: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82599074: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82599078: 419A0024  beq cr6, 0x8259909c
	if ctx.cr[6].eq {
	pc = 0x8259909C; continue 'dispatch;
	}
	// 8259907C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82599080: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82599084: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82599088: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259908C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82599090: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82599094: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82599098: 4082FFE8  bne 0x82599080
	if !ctx.cr[0].eq {
	pc = 0x82599080; continue 'dispatch;
	}
	// 8259909C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825990A0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825990A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825990A8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825990AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825990B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825990B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825990B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825990BC: 481FFE75  bl 0x82798f30
	ctx.lr = 0x825990C0;
	sub_82798F30(ctx, base);
	// 825990C0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825990C4: C1A10090  lfs f13, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825990C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825990CC: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825990D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825990D4: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 825990D8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825990DC: C00BC350  lfs f0, -0x3cb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825990E0: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825990E4: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825990E8: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825990EC: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825990F0: 4BD272E9  bl 0x822c03d8
	ctx.lr = 0x825990F4;
	sub_822C03D8(ctx, base);
	// 825990F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825990F8: 41820014  beq 0x8259910c
	if ctx.cr[0].eq {
	pc = 0x8259910C; continue 'dispatch;
	}
	// 825990FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82599100: 48202569  bl 0x8279b668
	ctx.lr = 0x82599104;
	sub_8279B668(ctx, base);
	// 82599104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599108: 48000008  b 0x82599110
	pc = 0x82599110; continue 'dispatch;
	// 8259910C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82599110: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82599114: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82599118: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259911C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599120: 4BFFEB31  bl 0x82597c50
	ctx.lr = 0x82599124;
	sub_82597C50(ctx, base);
	// 82599124: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82599128: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259912C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599130: 4BD26ED1  bl 0x822c0000
	ctx.lr = 0x82599134;
	sub_822C0000(ctx, base);
	// 82599134: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82599138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259913C: 419A0008  beq cr6, 0x82599144
	if ctx.cr[6].eq {
	pc = 0x82599144; continue 'dispatch;
	}
	// 82599140: 4BD27751  bl 0x822c0890
	ctx.lr = 0x82599144;
	sub_822C0890(ctx, base);
	// 82599144: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82599148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259914C: 419A0008  beq cr6, 0x82599154
	if ctx.cr[6].eq {
	pc = 0x82599154; continue 'dispatch;
	}
	// 82599150: 4BD27741  bl 0x822c0890
	ctx.lr = 0x82599154;
	sub_822C0890(ctx, base);
	// 82599154: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82599158: 419A000C  beq cr6, 0x82599164
	if ctx.cr[6].eq {
	pc = 0x82599164; continue 'dispatch;
	}
	// 8259915C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82599160: 4BD27731  bl 0x822c0890
	ctx.lr = 0x82599164;
	sub_822C0890(ctx, base);
	// 82599164: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82599168: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8259916C: 48C0F04C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599170 size=244
    let mut pc: u32 = 0x82599170;
    'dispatch: loop {
        match pc {
            0x82599170 => {
    //   block [0x82599170..0x82599264)
	// 82599170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599174: 48C0EFF1  bl 0x831a8164
	ctx.lr = 0x82599178;
	sub_831A8130(ctx, base);
	// 82599178: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259917C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82599180: 897E00E8  lbz r11, 0xe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82599184: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82599188: 418200CC  beq 0x82599254
	if ctx.cr[0].eq {
	pc = 0x82599254; continue 'dispatch;
	}
	// 8259918C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82599190: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82599194: 388BA5D8  addi r4, r11, -0x5a28
	ctx.r[4].s64 = ctx.r[11].s64 + -23080;
	// 82599198: 4BD30159  bl 0x822c92f0
	ctx.lr = 0x8259919C;
	sub_822C92F0(ctx, base);
	// 8259919C: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825991A0: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825991A4: 83A10074  lwz r29, 0x74(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825991A8: 40980008  bge cr6, 0x825991b0
	if !ctx.cr[6].lt {
	pc = 0x825991B0; continue 'dispatch;
	}
	// 825991AC: 3BA10074  addi r29, r1, 0x74
	ctx.r[29].s64 = ctx.r[1].s64 + 116;
	// 825991B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825991B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825991B8: 4BF76311  bl 0x8250f4c8
	ctx.lr = 0x825991BC;
	sub_8250F4C8(ctx, base);
	// 825991BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825991C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825991C4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825991C8: 409A0008  bne cr6, 0x825991d0
	if !ctx.cr[6].eq {
	pc = 0x825991D0; continue 'dispatch;
	}
	// 825991CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825991D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825991D4: 4BF6F7DD  bl 0x825089b0
	ctx.lr = 0x825991D8;
	sub_825089B0(ctx, base);
	// 825991D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825991DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825991E0: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 825991E4: 409A0008  bne cr6, 0x825991ec
	if !ctx.cr[6].eq {
	pc = 0x825991EC; continue 'dispatch;
	}
	// 825991E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825991EC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825991F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825991F4: 3B8B9FB8  addi r28, r11, -0x6048
	ctx.r[28].s64 = ctx.r[11].s64 + -24648;
	// 825991F8: 4BF788F1  bl 0x82511ae8
	ctx.lr = 0x825991FC;
	sub_82511AE8(ctx, base);
	// 825991FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82599200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82599204: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82599208: 4BF76311  bl 0x8250f518
	ctx.lr = 0x8259920C;
	sub_8250F518(ctx, base);
	// 8259920C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82599210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599214: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82599218: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8259921C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82599220: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82599224: 4BD2BCBD  bl 0x822c4ee0
	ctx.lr = 0x82599228;
	sub_822C4EE0(ctx, base);
	// 82599228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259922C: 48858A65  bl 0x82df1c90
	ctx.lr = 0x82599230;
	sub_82DF1C90(ctx, base);
	// 82599230: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82599234: 48858A5D  bl 0x82df1c90
	ctx.lr = 0x82599238;
	sub_82DF1C90(ctx, base);
	// 82599238: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259923C: 48858A55  bl 0x82df1c90
	ctx.lr = 0x82599240;
	sub_82DF1C90(ctx, base);
	// 82599240: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599244: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82599248: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259924C: 4BD2FBE5  bl 0x822c8e30
	ctx.lr = 0x82599250;
	sub_822C8E30(ctx, base);
	// 82599250: 4800000C  b 0x8259925c
	pc = 0x8259925C; continue 'dispatch;
	// 82599254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599258: 4BF77379  bl 0x825105d0
	ctx.lr = 0x8259925C;
	sub_825105D0(ctx, base);
	// 8259925C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82599260: 48C0EF54  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82599268 size=16
    let mut pc: u32 = 0x82599268;
    'dispatch: loop {
        match pc {
            0x82599268 => {
    //   block [0x82599268..0x82599278)
	// 82599268: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259926C: 894B002D  lbz r10, 0x2d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599270: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82599274: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82599278 size=24
    let mut pc: u32 = 0x82599278;
    'dispatch: loop {
        match pc {
            0x82599278 => {
    //   block [0x82599278..0x82599290)
	// 82599278: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259927C: 892A002D  lbz r9, 0x2d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599280: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82599284: 409A0040  bne cr6, 0x825992c4
	if !ctx.cr[6].eq {
		sub_825992AC(ctx, base);
		return;
	}
	// 82599288: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259928C: 4800000C  b 0x82599298
	sub_82599290(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82599290 size=28
    let mut pc: u32 = 0x82599290;
    'dispatch: loop {
        match pc {
            0x82599290 => {
    //   block [0x82599290..0x825992AC)
	// 82599290: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82599294: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599298: 892B002D  lbz r9, 0x2d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 8259929C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825992A0: 419AFFF0  beq cr6, 0x82599290
	if ctx.cr[6].eq {
	pc = 0x82599290; continue 'dispatch;
	}
	// 825992A4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825992A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825992AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825992AC size=48
    let mut pc: u32 = 0x825992AC;
    'dispatch: loop {
        match pc {
            0x825992AC => {
    //   block [0x825992AC..0x825992DC)
	// 825992AC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825992B0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825992B4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825992B8: 409A001C  bne cr6, 0x825992d4
	if !ctx.cr[6].eq {
	pc = 0x825992D4; continue 'dispatch;
	}
	// 825992BC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825992C0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825992C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825992C8: 894B002D  lbz r10, 0x2d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 825992CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825992D0: 419AFFDC  beq cr6, 0x825992ac
	if ctx.cr[6].eq {
	pc = 0x825992AC; continue 'dispatch;
	}
	// 825992D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825992D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825992E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825992E0 size=88
    let mut pc: u32 = 0x825992E0;
    'dispatch: loop {
        match pc {
            0x825992E0 => {
    //   block [0x825992E0..0x82599338)
	// 825992E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825992E4: 48C0EE89  bl 0x831a816c
	ctx.lr = 0x825992E8;
	sub_831A8130(ctx, base);
	// 825992E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825992EC: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825992F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825992F4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825992F8: 48000028  b 0x82599320
	pc = 0x82599320; continue 'dispatch;
	// 825992FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82599300: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82599304: 4BD3ABE5  bl 0x822d3ee8
	ctx.lr = 0x82599308;
	sub_822D3EE8(ctx, base);
	// 82599308: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259930C: 4182000C  beq 0x82599318
	if ctx.cr[0].eq {
	pc = 0x82599318; continue 'dispatch;
	}
	// 82599310: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599314: 4800000C  b 0x82599320
	pc = 0x82599320; continue 'dispatch;
	// 82599318: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 8259931C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599320: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599328: 419AFFD4  beq cr6, 0x825992fc
	if ctx.cr[6].eq {
	pc = 0x825992FC; continue 'dispatch;
	}
	// 8259932C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82599334: 48C0EE88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599338 size=120
    let mut pc: u32 = 0x82599338;
    'dispatch: loop {
        match pc {
            0x82599338 => {
    //   block [0x82599338..0x825993B0)
	// 82599338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259933C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82599340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82599344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82599348: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259934C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82599350: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82599354: 4BD2C575  bl 0x822c58c8
	ctx.lr = 0x82599358;
	sub_822C58C8(ctx, base);
	// 82599358: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259935C: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82599360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599364: 4BD3ABD5  bl 0x822d3f38
	ctx.lr = 0x82599368;
	sub_822D3F38(ctx, base);
	// 82599368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259936C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599370: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82599374: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82599378: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259937C: 4BD2B965  bl 0x822c4ce0
	ctx.lr = 0x82599380;
	sub_822C4CE0(ctx, base);
	// 82599380: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82599384: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259938C: 419A0008  beq cr6, 0x82599394
	if ctx.cr[6].eq {
	pc = 0x82599394; continue 'dispatch;
	}
	// 82599390: 897F0028  lbz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82599394: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82599398: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259939C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825993A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825993A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825993A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825993AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825993B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825993B0 size=1024
    let mut pc: u32 = 0x825993B0;
    'dispatch: loop {
        match pc {
            0x825993B0 => {
    //   block [0x825993B0..0x825997B0)
	// 825993B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825993B4: 48C0EDA5  bl 0x831a8158
	ctx.lr = 0x825993B8;
	sub_831A8130(ctx, base);
	// 825993B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825993BC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825993C0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825993C4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825993C8: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 825993CC: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 825993D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825993D4: 419A0048  beq cr6, 0x8259941c
	if ctx.cr[6].eq {
	pc = 0x8259941C; continue 'dispatch;
	}
	// 825993D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825993DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825993E0: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 825993E4: 4BD2C4E5  bl 0x822c58c8
	ctx.lr = 0x825993E8;
	sub_822C58C8(ctx, base);
	// 825993E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825993EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825993F0: 4BD30AC1  bl 0x822c9eb0
	ctx.lr = 0x825993F4;
	sub_822C9EB0(ctx, base);
	// 825993F4: 4BD2AEBD  bl 0x822c42b0
	ctx.lr = 0x825993F8;
	sub_822C42B0(ctx, base);
	// 825993F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825993FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82599400: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 82599404: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82599408: 4BD2C069  bl 0x822c5470
	ctx.lr = 0x8259940C;
	sub_822C5470(ctx, base);
	// 8259940C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599410: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82599414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599418: 4BD2B8C9  bl 0x822c4ce0
	ctx.lr = 0x8259941C;
	sub_822C4CE0(ctx, base);
	// 8259941C: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 82599420: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82599424: 4BFFFE45  bl 0x82599268
	ctx.lr = 0x82599428;
	sub_82599268(ctx, base);
	// 82599428: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259942C: 894B002D  lbz r10, 0x2d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599430: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82599434: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82599438: 419A000C  beq cr6, 0x82599444
	if ctx.cr[6].eq {
	pc = 0x82599444; continue 'dispatch;
	}
	// 8259943C: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599440: 48000028  b 0x82599468
	pc = 0x82599468; continue 'dispatch;
	// 82599444: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599448: 894A002D  lbz r10, 0x2d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(45 as u32) ) } as u64;
	// 8259944C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82599450: 419A000C  beq cr6, 0x8259945c
	if ctx.cr[6].eq {
	pc = 0x8259945C; continue 'dispatch;
	}
	// 82599454: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82599458: 48000010  b 0x82599468
	pc = 0x82599468; continue 'dispatch;
	// 8259945C: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599460: 7F19D040  cmplw cr6, r25, r26
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82599464: 409A00DC  bne cr6, 0x82599540
	if !ctx.cr[6].eq {
	pc = 0x82599540; continue 'dispatch;
	}
	// 82599468: 897C002D  lbz r11, 0x2d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(45 as u32) ) } as u64;
	// 8259946C: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599474: 409A0008  bne cr6, 0x8259947c
	if !ctx.cr[6].eq {
	pc = 0x8259947C; continue 'dispatch;
	}
	// 82599478: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8259947C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599480: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599484: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82599488: 409A000C  bne cr6, 0x82599494
	if !ctx.cr[6].eq {
	pc = 0x82599494; continue 'dispatch;
	}
	// 8259948C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82599490: 4800001C  b 0x825994ac
	pc = 0x825994AC; continue 'dispatch;
	// 82599494: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599498: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8259949C: 409A000C  bne cr6, 0x825994a8
	if !ctx.cr[6].eq {
	pc = 0x825994A8; continue 'dispatch;
	}
	// 825994A0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825994A4: 48000008  b 0x825994ac
	pc = 0x825994AC; continue 'dispatch;
	// 825994A8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825994AC: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825994B0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825994B4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825994B8: 409A003C  bne cr6, 0x825994f4
	if !ctx.cr[6].eq {
	pc = 0x825994F4; continue 'dispatch;
	}
	// 825994BC: 897C002D  lbz r11, 0x2d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(45 as u32) ) } as u64;
	// 825994C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825994C4: 419A000C  beq cr6, 0x825994d0
	if ctx.cr[6].eq {
	pc = 0x825994D0; continue 'dispatch;
	}
	// 825994C8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 825994CC: 48000024  b 0x825994f0
	pc = 0x825994F0; continue 'dispatch;
	// 825994D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825994D4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825994D8: 4800000C  b 0x825994e4
	pc = 0x825994E4; continue 'dispatch;
	// 825994DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825994E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825994E4: 890B002D  lbz r8, 0x2d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 825994E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825994EC: 419AFFF0  beq cr6, 0x825994dc
	if ctx.cr[6].eq {
	pc = 0x825994DC; continue 'dispatch;
	}
	// 825994F0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825994F4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825994F8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825994FC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82599500: 409A00D4  bne cr6, 0x825995d4
	if !ctx.cr[6].eq {
	pc = 0x825995D4; continue 'dispatch;
	}
	// 82599504: 897C002D  lbz r11, 0x2d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259950C: 419A000C  beq cr6, 0x82599518
	if ctx.cr[6].eq {
	pc = 0x82599518; continue 'dispatch;
	}
	// 82599510: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82599514: 48000024  b 0x82599538
	pc = 0x82599538; continue 'dispatch;
	// 82599518: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259951C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82599520: 4800000C  b 0x8259952c
	pc = 0x8259952C; continue 'dispatch;
	// 82599524: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82599528: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259952C: 890B002D  lbz r8, 0x2d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599530: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82599534: 419AFFF0  beq cr6, 0x82599524
	if ctx.cr[6].eq {
	pc = 0x82599524; continue 'dispatch;
	}
	// 82599538: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259953C: 48000098  b 0x825995d4
	pc = 0x825995D4; continue 'dispatch;
	// 82599540: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82599544: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599548: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259954C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599550: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599554: 409A000C  bne cr6, 0x82599560
	if !ctx.cr[6].eq {
	pc = 0x82599560; continue 'dispatch;
	}
	// 82599558: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 8259955C: 4800002C  b 0x82599588
	pc = 0x82599588; continue 'dispatch;
	// 82599560: 897C002D  lbz r11, 0x2d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599564: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259956C: 409A0008  bne cr6, 0x82599574
	if !ctx.cr[6].eq {
	pc = 0x82599574; continue 'dispatch;
	}
	// 82599570: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82599574: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82599578: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259957C: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82599580: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599584: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82599588: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259958C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599590: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82599594: 409A000C  bne cr6, 0x825995a0
	if !ctx.cr[6].eq {
	pc = 0x825995A0; continue 'dispatch;
	}
	// 82599598: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 8259959C: 48000020  b 0x825995bc
	pc = 0x825995BC; continue 'dispatch;
	// 825995A0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825995A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825995A8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825995AC: 409A000C  bne cr6, 0x825995b8
	if !ctx.cr[6].eq {
	pc = 0x825995B8; continue 'dispatch;
	}
	// 825995B0: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825995B4: 48000008  b 0x825995bc
	pc = 0x825995BC; continue 'dispatch;
	// 825995B8: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825995BC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825995C0: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825995C4: 897A002C  lbz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 825995C8: 8959002C  lbz r10, 0x2c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 825995CC: 9979002C  stb r11, 0x2c(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 825995D0: 995A002C  stb r10, 0x2c(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 825995D4: 897A002C  lbz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 825995D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825995DC: 409A0198  bne cr6, 0x82599774
	if !ctx.cr[6].eq {
	pc = 0x82599774; continue 'dispatch;
	}
	// 825995E0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825995E4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825995E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825995EC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825995F0: 419A0180  beq cr6, 0x82599770
	if ctx.cr[6].eq {
	pc = 0x82599770; continue 'dispatch;
	}
	// 825995F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825995F8: 897C002C  lbz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825995FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82599600: 409A0170  bne cr6, 0x82599770
	if !ctx.cr[6].eq {
	pc = 0x82599770; continue 'dispatch;
	}
	// 82599604: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599608: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259960C: 409A00A8  bne cr6, 0x825996b4
	if !ctx.cr[6].eq {
	pc = 0x825996B4; continue 'dispatch;
	}
	// 82599610: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599614: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82599618: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259961C: 409A001C  bne cr6, 0x82599638
	if !ctx.cr[6].eq {
	pc = 0x82599638; continue 'dispatch;
	}
	// 82599620: 9BCB002C  stb r30, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82599624: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599628: 9BBF002C  stb r29, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 8259962C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82599630: 4BD35DC1  bl 0x822cf3f0
	ctx.lr = 0x82599634;
	sub_822CF3F0(ctx, base);
	// 82599634: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599638: 894B002D  lbz r10, 0x2d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 8259963C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82599640: 409A00C8  bne cr6, 0x82599708
	if !ctx.cr[6].eq {
	pc = 0x82599708; continue 'dispatch;
	}
	// 82599644: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599648: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8259964C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82599650: 409A0014  bne cr6, 0x82599664
	if !ctx.cr[6].eq {
	pc = 0x82599664; continue 'dispatch;
	}
	// 82599654: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599658: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8259965C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82599660: 419A00A4  beq cr6, 0x82599704
	if ctx.cr[6].eq {
	pc = 0x82599704; continue 'dispatch;
	}
	// 82599664: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599668: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8259966C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82599670: 409A0020  bne cr6, 0x82599690
	if !ctx.cr[6].eq {
	pc = 0x82599690; continue 'dispatch;
	}
	// 82599674: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599678: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8259967C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82599680: 9BCA002C  stb r30, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82599684: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599688: 4BD35CB1  bl 0x822cf338
	ctx.lr = 0x8259968C;
	sub_822CF338(ctx, base);
	// 8259968C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599690: 895F002C  lbz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82599694: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599698: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259969C: 994B002C  stb r10, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 825996A0: 9BDF002C  stb r30, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 825996A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825996A8: 9BCB002C  stb r30, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 825996AC: 4BD35D45  bl 0x822cf3f0
	ctx.lr = 0x825996B0;
	sub_822CF3F0(ctx, base);
	// 825996B0: 480000C0  b 0x82599770
	pc = 0x82599770; continue 'dispatch;
	// 825996B4: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825996B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825996BC: 409A001C  bne cr6, 0x825996d8
	if !ctx.cr[6].eq {
	pc = 0x825996D8; continue 'dispatch;
	}
	// 825996C0: 9BCB002C  stb r30, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 825996C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825996C8: 9BBF002C  stb r29, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 825996CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825996D0: 4BD35C69  bl 0x822cf338
	ctx.lr = 0x825996D4;
	sub_822CF338(ctx, base);
	// 825996D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825996D8: 894B002D  lbz r10, 0x2d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 825996DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825996E0: 409A0028  bne cr6, 0x82599708
	if !ctx.cr[6].eq {
	pc = 0x82599708; continue 'dispatch;
	}
	// 825996E4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825996E8: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 825996EC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825996F0: 409A0034  bne cr6, 0x82599724
	if !ctx.cr[6].eq {
	pc = 0x82599724; continue 'dispatch;
	}
	// 825996F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825996F8: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 825996FC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82599700: 409A0024  bne cr6, 0x82599724
	if !ctx.cr[6].eq {
	pc = 0x82599724; continue 'dispatch;
	}
	// 82599704: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599708: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259970C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82599710: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599714: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599718: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259971C: 409AFEDC  bne cr6, 0x825995f8
	if !ctx.cr[6].eq {
	pc = 0x825995F8; continue 'dispatch;
	}
	// 82599720: 48000050  b 0x82599770
	pc = 0x82599770; continue 'dispatch;
	// 82599724: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599728: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8259972C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82599730: 409A0020  bne cr6, 0x82599750
	if !ctx.cr[6].eq {
	pc = 0x82599750; continue 'dispatch;
	}
	// 82599734: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599738: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8259973C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82599740: 9BCA002C  stb r30, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82599744: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599748: 4BD35CA9  bl 0x822cf3f0
	ctx.lr = 0x8259974C;
	sub_822CF3F0(ctx, base);
	// 8259974C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599750: 895F002C  lbz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82599754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599758: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259975C: 994B002C  stb r10, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82599760: 9BDF002C  stb r30, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82599764: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599768: 9BCB002C  stb r30, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 8259976C: 4BD35BCD  bl 0x822cf338
	ctx.lr = 0x82599770;
	sub_822CF338(ctx, base);
	// 82599770: 9BDC002C  stb r30, 0x2c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82599774: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599778: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259977C: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 82599780: 4BD2B561  bl 0x822c4ce0
	ctx.lr = 0x82599784;
	sub_822C4CE0(ctx, base);
	// 82599784: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82599788: 4BD26AE1  bl 0x822c0268
	ctx.lr = 0x8259978C;
	sub_822C0268(ctx, base);
	// 8259978C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599794: 419A000C  beq cr6, 0x825997a0
	if ctx.cr[6].eq {
	pc = 0x825997A0; continue 'dispatch;
	}
	// 82599798: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259979C: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825997A0: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825997A4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825997A8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825997AC: 48C0E9FC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825997B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825997B0 size=108
    let mut pc: u32 = 0x825997B0;
    'dispatch: loop {
        match pc {
            0x825997B0 => {
    //   block [0x825997B0..0x8259981C)
	// 825997B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825997B4: 48C0E9AD  bl 0x831a8160
	ctx.lr = 0x825997B8;
	sub_831A8130(ctx, base);
	// 825997B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825997BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825997C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825997C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825997C8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825997CC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825997D0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825997D4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 825997D8: 4BD421F9  bl 0x822db9d0
	ctx.lr = 0x825997DC;
	sub_822DB9D0(ctx, base);
	// 825997DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825997E0: 41820030  beq 0x82599810
	if ctx.cr[0].eq {
	pc = 0x82599810; continue 'dispatch;
	}
	// 825997E4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825997E8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825997EC: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825997F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825997F4: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825997F8: 4BD2BF79  bl 0x822c5770
	ctx.lr = 0x825997FC;
	sub_822C5770(ctx, base);
	// 825997FC: 895E001C  lbz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82599800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82599804: 995F0028  stb r10, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 82599808: 9B5F002C  stb r26, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u8 ) };
	// 8259980C: 997F002D  stb r11, 0x2d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(45 as u32), ctx.r[11].u8 ) };
	// 82599810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599814: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82599818: 48C0E998  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599820 size=132
    let mut pc: u32 = 0x82599820;
    'dispatch: loop {
        match pc {
            0x82599820 => {
    //   block [0x82599820..0x825998A4)
	// 82599820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599824: 48C0E945  bl 0x831a8168
	ctx.lr = 0x82599828;
	sub_831A8130(ctx, base);
	// 82599828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259982C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82599830: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82599834: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82599838: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8259983C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599840: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599844: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82599848: 409A0044  bne cr6, 0x8259988c
	if !ctx.cr[6].eq {
	pc = 0x8259988C; continue 'dispatch;
	}
	// 8259984C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599850: 409A003C  bne cr6, 0x8259988c
	if !ctx.cr[6].eq {
	pc = 0x8259988C; continue 'dispatch;
	}
	// 82599854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599858: 4BD362F1  bl 0x822cfb48
	ctx.lr = 0x8259985C;
	sub_822CFB48(ctx, base);
	// 8259985C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599860: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599864: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599868: 48000030  b 0x82599898
	pc = 0x82599898; continue 'dispatch;
	// 8259986C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82599870: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82599874: 4BFFF9F5  bl 0x82599268
	ctx.lr = 0x82599878;
	sub_82599268(ctx, base);
	// 82599878: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8259987C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599884: 4BFFFB2D  bl 0x825993b0
	ctx.lr = 0x82599888;
	sub_825993B0(ctx, base);
	// 82599888: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8259988C: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82599890: 409AFFDC  bne cr6, 0x8259986c
	if !ctx.cr[6].eq {
	pc = 0x8259986C; continue 'dispatch;
	}
	// 82599894: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82599898: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259989C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825998A0: 48C0E918  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825998A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825998A8 size=548
    let mut pc: u32 = 0x825998A8;
    'dispatch: loop {
        match pc {
            0x825998A8 => {
    //   block [0x825998A8..0x82599ACC)
	// 825998A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825998AC: 48C0E8B5  bl 0x831a8160
	ctx.lr = 0x825998B0;
	sub_831A8130(ctx, base);
	// 825998B0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825998B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825998B8: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 825998BC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825998C0: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 825998C4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825998C8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825998CC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825998D0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825998D4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825998D8: 41980048  blt cr6, 0x82599920
	if ctx.cr[6].lt {
	pc = 0x82599920; continue 'dispatch;
	}
	// 825998DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825998E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825998E4: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 825998E8: 4BD2BFE1  bl 0x822c58c8
	ctx.lr = 0x825998EC;
	sub_822C58C8(ctx, base);
	// 825998EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825998F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825998F4: 4BD2BF25  bl 0x822c5818
	ctx.lr = 0x825998F8;
	sub_822C5818(ctx, base);
	// 825998F8: 4BD2A9B9  bl 0x822c42b0
	ctx.lr = 0x825998FC;
	sub_822C42B0(ctx, base);
	// 825998FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82599900: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82599904: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 82599908: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8259990C: 4BD2BB65  bl 0x822c5470
	ctx.lr = 0x82599910;
	sub_822C5470(ctx, base);
	// 82599910: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599914: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82599918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259991C: 4BD2B3C5  bl 0x822c4ce0
	ctx.lr = 0x82599920;
	sub_822C4CE0(ctx, base);
	// 82599920: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599924: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82599928: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8259992C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82599930: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82599934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599938: 4BFFFE79  bl 0x825997b0
	ctx.lr = 0x8259993C;
	sub_825997B0(ctx, base);
	// 8259993C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599940: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599944: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82599948: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259994C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599950: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82599954: 409A0018  bne cr6, 0x8259996c
	if !ctx.cr[6].eq {
	pc = 0x8259996C; continue 'dispatch;
	}
	// 82599958: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8259995C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599960: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82599964: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599968: 4800003C  b 0x825999a4
	pc = 0x825999A4; continue 'dispatch;
	// 8259996C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599970: 41820020  beq 0x82599990
	if ctx.cr[0].eq {
	pc = 0x82599990; continue 'dispatch;
	}
	// 82599974: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82599978: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259997C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599980: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82599984: 409A0024  bne cr6, 0x825999a8
	if !ctx.cr[6].eq {
	pc = 0x825999A8; continue 'dispatch;
	}
	// 82599988: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8259998C: 4800001C  b 0x825999a8
	pc = 0x825999A8; continue 'dispatch;
	// 82599990: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82599994: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599998: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259999C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825999A0: 409A0008  bne cr6, 0x825999a8
	if !ctx.cr[6].eq {
	pc = 0x825999A8; continue 'dispatch;
	}
	// 825999A4: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825999A8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825999AC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825999B0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825999B4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825999B8: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 825999BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825999C0: 409A00F0  bne cr6, 0x82599ab0
	if !ctx.cr[6].eq {
	pc = 0x82599AB0; continue 'dispatch;
	}
	// 825999C4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825999C8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825999CC: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825999D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825999D4: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825999D8: 409A0054  bne cr6, 0x82599a2c
	if !ctx.cr[6].eq {
	pc = 0x82599A2C; continue 'dispatch;
	}
	// 825999DC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825999E0: 892A002C  lbz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 825999E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825999E8: 419A0054  beq cr6, 0x82599a3c
	if ctx.cr[6].eq {
	pc = 0x82599A3C; continue 'dispatch;
	}
	// 825999EC: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825999F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825999F4: 409A0010  bne cr6, 0x82599a04
	if !ctx.cr[6].eq {
	pc = 0x82599A04; continue 'dispatch;
	}
	// 825999F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825999FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82599A00: 4BD359F1  bl 0x822cf3f0
	ctx.lr = 0x82599A04;
	sub_822CF3F0(ctx, base);
	// 82599A04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599A0C: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599A10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A18: 9B6B002C  stb r27, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[27].u8 ) };
	// 82599A1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A20: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A24: 4BD35915  bl 0x822cf338
	ctx.lr = 0x82599A28;
	sub_822CF338(ctx, base);
	// 82599A28: 48000074  b 0x82599a9c
	pc = 0x82599A9C; continue 'dispatch;
	// 82599A2C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599A30: 892A002C  lbz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82599A34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82599A38: 409A0028  bne cr6, 0x82599a60
	if !ctx.cr[6].eq {
	pc = 0x82599A60; continue 'dispatch;
	}
	// 82599A3C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599A40: 9BA9002C  stb r29, 0x2c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599A44: 9BAA002C  stb r29, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599A48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599A4C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A50: 9B6A002C  stb r27, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[27].u8 ) };
	// 82599A54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599A58: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A5C: 48000040  b 0x82599a9c
	pc = 0x82599A9C; continue 'dispatch;
	// 82599A60: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599A64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599A68: 409A0010  bne cr6, 0x82599a78
	if !ctx.cr[6].eq {
	pc = 0x82599A78; continue 'dispatch;
	}
	// 82599A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599A70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82599A74: 4BD358C5  bl 0x822cf338
	ctx.lr = 0x82599A78;
	sub_822CF338(ctx, base);
	// 82599A78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599A80: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599A84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A8C: 9B6B002C  stb r27, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[27].u8 ) };
	// 82599A90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A94: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599A98: 4BD35959  bl 0x822cf3f0
	ctx.lr = 0x82599A9C;
	sub_822CF3F0(ctx, base);
	// 82599A9C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599AA0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82599AA4: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82599AA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82599AAC: 419AFF1C  beq cr6, 0x825999c8
	if ctx.cr[6].eq {
	pc = 0x825999C8; continue 'dispatch;
	}
	// 82599AB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599AB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82599AB8: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82599ABC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599AC0: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 82599AC4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82599AC8: 48C0E6E8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599AD0 size=80
    let mut pc: u32 = 0x82599AD0;
    'dispatch: loop {
        match pc {
            0x82599AD0 => {
    //   block [0x82599AD0..0x82599B20)
	// 82599AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82599AD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82599ADC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599AE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599AE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599AEC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599AF0: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599AF4: 4BFFFD2D  bl 0x82599820
	ctx.lr = 0x82599AF8;
	sub_82599820(ctx, base);
	// 82599AF8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599AFC: 4BD2676D  bl 0x822c0268
	ctx.lr = 0x82599B00;
	sub_822C0268(ctx, base);
	// 82599B00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82599B04: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82599B08: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82599B0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82599B10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82599B14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82599B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82599B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599B20 size=236
    let mut pc: u32 = 0x82599B20;
    'dispatch: loop {
        match pc {
            0x82599B20 => {
    //   block [0x82599B20..0x82599C0C)
	// 82599B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599B24: 48C0E639  bl 0x831a815c
	ctx.lr = 0x82599B28;
	sub_831A8130(ctx, base);
	// 82599B28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599B2C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82599B30: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82599B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599B38: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82599B3C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82599B40: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599B44: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599B48: 4800002C  b 0x82599b74
	pc = 0x82599B74; continue 'dispatch;
	// 82599B4C: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82599B50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82599B54: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82599B58: 4BD3A391  bl 0x822d3ee8
	ctx.lr = 0x82599B5C;
	sub_822D3EE8(ctx, base);
	// 82599B5C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82599B60: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599B64: 4182000C  beq 0x82599b70
	if ctx.cr[0].eq {
	pc = 0x82599B70; continue 'dispatch;
	}
	// 82599B68: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599B6C: 48000008  b 0x82599b74
	pc = 0x82599B74; continue 'dispatch;
	// 82599B70: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599B74: 897D002D  lbz r11, 0x2d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599B7C: 419AFFD0  beq cr6, 0x82599b4c
	if ctx.cr[6].eq {
	pc = 0x82599B4C; continue 'dispatch;
	}
	// 82599B80: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82599B84: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599B88: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82599B8C: 41820048  beq 0x82599bd4
	if ctx.cr[0].eq {
	pc = 0x82599BD4; continue 'dispatch;
	}
	// 82599B90: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599B94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599B98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599B9C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599BA0: 409A002C  bne cr6, 0x82599bcc
	if !ctx.cr[6].eq {
	pc = 0x82599BCC; continue 'dispatch;
	}
	// 82599BA4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82599BA8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82599BAC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82599BB0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82599BB4: 4BFFFCF5  bl 0x825998a8
	ctx.lr = 0x82599BB8;
	sub_825998A8(ctx, base);
	// 82599BB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82599BBC: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 82599BC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599BC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599BC8: 48000038  b 0x82599c00
	pc = 0x82599C00; continue 'dispatch;
	// 82599BCC: 4BFB54E5  bl 0x8254f0b0
	ctx.lr = 0x82599BD0;
	sub_8254F0B0(ctx, base);
	// 82599BD0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82599BD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82599BD8: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 82599BDC: 4BD3A30D  bl 0x822d3ee8
	ctx.lr = 0x82599BE0;
	sub_822D3EE8(ctx, base);
	// 82599BE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599BE4: 41820010  beq 0x82599bf4
	if ctx.cr[0].eq {
	pc = 0x82599BF4; continue 'dispatch;
	}
	// 82599BE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82599BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599BF0: 4BFFFFB8  b 0x82599ba8
	pc = 0x82599BA8; continue 'dispatch;
	// 82599BF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82599BF8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82599BFC: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82599C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599C04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82599C08: 48C0E5A4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599C10 size=424
    let mut pc: u32 = 0x82599C10;
    'dispatch: loop {
        match pc {
            0x82599C10 => {
    //   block [0x82599C10..0x82599DB8)
	// 82599C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599C14: 48C0E54D  bl 0x831a8160
	ctx.lr = 0x82599C18;
	sub_831A8130(ctx, base);
	// 82599C18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599C1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82599C20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82599C24: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82599C28: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82599C2C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599C34: 409A0020  bne cr6, 0x82599c54
	if !ctx.cr[6].eq {
	pc = 0x82599C54; continue 'dispatch;
	}
	// 82599C38: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599C3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82599C40: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82599C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599C48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82599C4C: 4BFFFC5D  bl 0x825998a8
	ctx.lr = 0x82599C50;
	sub_825998A8(ctx, base);
	// 82599C50: 4800015C  b 0x82599dac
	pc = 0x82599DAC; continue 'dispatch;
	// 82599C54: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599C58: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599C5C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82599C60: 409A0020  bne cr6, 0x82599c80
	if !ctx.cr[6].eq {
	pc = 0x82599C80; continue 'dispatch;
	}
	// 82599C64: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 82599C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599C6C: 4BD3A27D  bl 0x822d3ee8
	ctx.lr = 0x82599C70;
	sub_822D3EE8(ctx, base);
	// 82599C70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599C74: 4182011C  beq 0x82599d90
	if ctx.cr[0].eq {
	pc = 0x82599D90; continue 'dispatch;
	}
	// 82599C78: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82599C7C: 4BFFFFC0  b 0x82599c3c
	pc = 0x82599C3C; continue 'dispatch;
	// 82599C80: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599C84: 409A002C  bne cr6, 0x82599cb0
	if !ctx.cr[6].eq {
	pc = 0x82599CB0; continue 'dispatch;
	}
	// 82599C88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599C90: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82599C94: 4BD3A255  bl 0x822d3ee8
	ctx.lr = 0x82599C98;
	sub_822D3EE8(ctx, base);
	// 82599C98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599C9C: 418200F4  beq 0x82599d90
	if ctx.cr[0].eq {
	pc = 0x82599D90; continue 'dispatch;
	}
	// 82599CA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599CA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599CA8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599CAC: 4BFFFF94  b 0x82599c40
	pc = 0x82599C40; continue 'dispatch;
	// 82599CB0: 3B5C000C  addi r26, r28, 0xc
	ctx.r[26].s64 = ctx.r[28].s64 + 12;
	// 82599CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599CB8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82599CBC: 4BD3A22D  bl 0x822d3ee8
	ctx.lr = 0x82599CC0;
	sub_822D3EE8(ctx, base);
	// 82599CC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599CC4: 4182005C  beq 0x82599d20
	if ctx.cr[0].eq {
	pc = 0x82599D20; continue 'dispatch;
	}
	// 82599CC8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82599CCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599CD0: 4BFB53E1  bl 0x8254f0b0
	ctx.lr = 0x82599CD4;
	sub_8254F0B0(ctx, base);
	// 82599CD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599CD8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82599CDC: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 82599CE0: 4BD3A209  bl 0x822d3ee8
	ctx.lr = 0x82599CE4;
	sub_822D3EE8(ctx, base);
	// 82599CE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599CE8: 41820038  beq 0x82599d20
	if ctx.cr[0].eq {
	pc = 0x82599D20; continue 'dispatch;
	}
	// 82599CEC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599CF0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82599CF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82599CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599CFC: 896B002D  lbz r11, 0x2d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599D04: 419A0010  beq cr6, 0x82599d14
	if ctx.cr[6].eq {
	pc = 0x82599D14; continue 'dispatch;
	}
	// 82599D08: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82599D0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599D10: 4BFFFF3C  b 0x82599c4c
	pc = 0x82599C4C; continue 'dispatch;
	// 82599D14: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82599D18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82599D1C: 4BFFFF30  b 0x82599c4c
	pc = 0x82599C4C; continue 'dispatch;
	// 82599D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82599D24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82599D28: 4BD3A1C1  bl 0x822d3ee8
	ctx.lr = 0x82599D2C;
	sub_822D3EE8(ctx, base);
	// 82599D2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599D30: 41820060  beq 0x82599d90
	if ctx.cr[0].eq {
	pc = 0x82599D90; continue 'dispatch;
	}
	// 82599D34: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82599D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599D3C: 4BFFF52D  bl 0x82599268
	ctx.lr = 0x82599D40;
	sub_82599268(ctx, base);
	// 82599D40: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599D44: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82599D48: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599D4C: 419A0018  beq cr6, 0x82599d64
	if ctx.cr[6].eq {
	pc = 0x82599D64; continue 'dispatch;
	}
	// 82599D50: 389B000C  addi r4, r27, 0xc
	ctx.r[4].s64 = ctx.r[27].s64 + 12;
	// 82599D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599D58: 4BD3A191  bl 0x822d3ee8
	ctx.lr = 0x82599D5C;
	sub_822D3EE8(ctx, base);
	// 82599D5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599D60: 41820030  beq 0x82599d90
	if ctx.cr[0].eq {
	pc = 0x82599D90; continue 'dispatch;
	}
	// 82599D64: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599D68: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82599D6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82599D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599D74: 896B002D  lbz r11, 0x2d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82599D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82599D7C: 419A000C  beq cr6, 0x82599d88
	if ctx.cr[6].eq {
	pc = 0x82599D88; continue 'dispatch;
	}
	// 82599D80: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82599D84: 4BFFFF88  b 0x82599d0c
	pc = 0x82599D0C; continue 'dispatch;
	// 82599D88: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82599D8C: 4BFFFF8C  b 0x82599d18
	pc = 0x82599D18; continue 'dispatch;
	// 82599D90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82599D94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82599D98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599D9C: 4BFFFD85  bl 0x82599b20
	ctx.lr = 0x82599DA0;
	sub_82599B20(ctx, base);
	// 82599DA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82599DA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599DA8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599DAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599DB0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82599DB4: 48C0E3FC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599DB8 size=80
    let mut pc: u32 = 0x82599DB8;
    'dispatch: loop {
        match pc {
            0x82599DB8 => {
    //   block [0x82599DB8..0x82599E08)
	// 82599DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82599DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82599DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599DCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82599DD0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82599DD4: 396BA5F4  addi r11, r11, -0x5a0c
	ctx.r[11].s64 = ctx.r[11].s64 + -23052;
	// 82599DD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599DDC: 4BFFFCF5  bl 0x82599ad0
	ctx.lr = 0x82599DE0;
	sub_82599AD0(ctx, base);
	// 82599DE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82599DE4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82599DE8: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 82599DEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599DF0: 48859639  bl 0x82df3428
	ctx.lr = 0x82599DF4;
	sub_82DF3428(ctx, base);
	// 82599DF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82599DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82599DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82599E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82599E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599E08 size=136
    let mut pc: u32 = 0x82599E08;
    'dispatch: loop {
        match pc {
            0x82599E08 => {
    //   block [0x82599E08..0x82599E90)
	// 82599E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599E0C: 48C0E361  bl 0x831a816c
	ctx.lr = 0x82599E10;
	sub_831A8130(ctx, base);
	// 82599E10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599E14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82599E18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82599E1C: 4BFFF4C5  bl 0x825992e0
	ctx.lr = 0x82599E20;
	sub_825992E0(ctx, base);
	// 82599E20: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599E28: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82599E2C: 419A0018  beq cr6, 0x82599e44
	if ctx.cr[6].eq {
	pc = 0x82599E44; continue 'dispatch;
	}
	// 82599E30: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82599E34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599E38: 4BD3A0B1  bl 0x822d3ee8
	ctx.lr = 0x82599E3C;
	sub_822D3EE8(ctx, base);
	// 82599E3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599E40: 41820044  beq 0x82599e84
	if ctx.cr[0].eq {
	pc = 0x82599E84; continue 'dispatch;
	}
	// 82599E44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82599E48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82599E4C: 4BD2B925  bl 0x822c5770
	ctx.lr = 0x82599E50;
	sub_822C5770(ctx, base);
	// 82599E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82599E54: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82599E58: 9961007C  stb r11, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82599E5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82599E60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82599E64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599E68: 4BFFFDA9  bl 0x82599c10
	ctx.lr = 0x82599E6C;
	sub_82599C10(ctx, base);
	// 82599E6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82599E70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599E74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82599E78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82599E7C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599E80: 4BD2AE61  bl 0x822c4ce0
	ctx.lr = 0x82599E84;
	sub_822C4CE0(ctx, base);
	// 82599E84: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82599E88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82599E8C: 48C0E330  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599E90 size=68
    let mut pc: u32 = 0x82599E90;
    'dispatch: loop {
        match pc {
            0x82599E90 => {
    //   block [0x82599E90..0x82599ED4)
	// 82599E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82599E98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82599E9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599EA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599EA4: 488648F5  bl 0x82dfe798
	ctx.lr = 0x82599EA8;
	sub_82DFE798(ctx, base);
	// 82599EA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82599EAC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82599EB0: 396BA5F4  addi r11, r11, -0x5a0c
	ctx.r[11].s64 = ctx.r[11].s64 + -23052;
	// 82599EB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599EB8: 4BD39FD9  bl 0x822d3e90
	ctx.lr = 0x82599EBC;
	sub_822D3E90(ctx, base);
	// 82599EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599EC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82599EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82599EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82599ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82599ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599ED8 size=76
    let mut pc: u32 = 0x82599ED8;
    'dispatch: loop {
        match pc {
            0x82599ED8 => {
    //   block [0x82599ED8..0x82599F24)
	// 82599ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82599EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82599EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82599EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82599EF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82599EF4: 4BFFFEC5  bl 0x82599db8
	ctx.lr = 0x82599EF8;
	sub_82599DB8(ctx, base);
	// 82599EF8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82599EFC: 4182000C  beq 0x82599f08
	if ctx.cr[0].eq {
	pc = 0x82599F08; continue 'dispatch;
	}
	// 82599F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599F04: 488584D5  bl 0x82df23d8
	ctx.lr = 0x82599F08;
	sub_82DF23D8(ctx, base);
	// 82599F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599F0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82599F10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82599F14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82599F18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82599F1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82599F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599F28 size=156
    let mut pc: u32 = 0x82599F28;
    'dispatch: loop {
        match pc {
            0x82599F28 => {
    //   block [0x82599F28..0x82599FC4)
	// 82599F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599F2C: 48C0E239  bl 0x831a8164
	ctx.lr = 0x82599F30;
	sub_831A8130(ctx, base);
	// 82599F30: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82599F34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82599F38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82599F3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82599F40: 419A007C  beq cr6, 0x82599fbc
	if ctx.cr[6].eq {
	pc = 0x82599FBC; continue 'dispatch;
	}
	// 82599F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82599F48: 48874561  bl 0x82e0e4a8
	ctx.lr = 0x82599F4C;
	sub_82E0E4A8(ctx, base);
	// 82599F4C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82599F50: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82599F54: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82599F58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599F5C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599F60: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82599F64: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82599F68: 4BD35BE1  bl 0x822cfb48
	ctx.lr = 0x82599F6C;
	sub_822CFB48(ctx, base);
	// 82599F6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82599F70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82599F74: 419A0048  beq cr6, 0x82599fbc
	if ctx.cr[6].eq {
	pc = 0x82599FBC; continue 'dispatch;
	}
	// 82599F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599F7C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82599F80: 4BD2B949  bl 0x822c58c8
	ctx.lr = 0x82599F84;
	sub_822C58C8(ctx, base);
	// 82599F84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82599F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82599F8C: 4BFFFE7D  bl 0x82599e08
	ctx.lr = 0x82599F90;
	sub_82599E08(ctx, base);
	// 82599F90: 7D7FD8AE  lbzx r11, r31, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82599F94: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82599F98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82599F9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82599FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82599FA4: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82599FA8: 4BD2AD39  bl 0x822c4ce0
	ctx.lr = 0x82599FAC;
	sub_822C4CE0(ctx, base);
	// 82599FAC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82599FB0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82599FB4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82599FB8: 4198FFC0  blt cr6, 0x82599f78
	if ctx.cr[6].lt {
	pc = 0x82599F78; continue 'dispatch;
	}
	// 82599FBC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82599FC0: 48C0E1F4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82599FC8 size=20
    let mut pc: u32 = 0x82599FC8;
    'dispatch: loop {
        match pc {
            0x82599FC8 => {
    //   block [0x82599FC8..0x82599FDC)
	// 82599FC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82599FCC: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82599FD0: 396BA600  addi r11, r11, -0x5a00
	ctx.r[11].s64 = ctx.r[11].s64 + -23040;
	// 82599FD4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82599FE0 size=16
    let mut pc: u32 = 0x82599FE0;
    'dispatch: loop {
        match pc {
            0x82599FE0 => {
    //   block [0x82599FE0..0x82599FF0)
	// 82599FE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82599FE4: 396BA600  addi r11, r11, -0x5a00
	ctx.r[11].s64 = ctx.r[11].s64 + -23040;
	// 82599FE8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82599FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82599FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82599FF0 size=68
    let mut pc: u32 = 0x82599FF0;
    'dispatch: loop {
        match pc {
            0x82599FF0 => {
    //   block [0x82599FF0..0x8259A034)
	// 82599FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82599FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82599FF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82599FFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A004: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A008: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8259A00C: 396BA600  addi r11, r11, -0x5a00
	ctx.r[11].s64 = ctx.r[11].s64 + -23040;
	// 8259A010: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A014: 41820008  beq 0x8259a01c
	if ctx.cr[0].eq {
	pc = 0x8259A01C; continue 'dispatch;
	}
	// 8259A018: 4BD26251  bl 0x822c0268
	ctx.lr = 0x8259A01C;
	sub_822C0268(ctx, base);
	// 8259A01C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A020: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A02C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A038 size=112
    let mut pc: u32 = 0x8259A038;
    'dispatch: loop {
        match pc {
            0x8259A038 => {
    //   block [0x8259A038..0x8259A0A8)
	// 8259A038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A04C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259A050: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A054: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259A058: 388B9B98  addi r4, r11, -0x6468
	ctx.r[4].s64 = ctx.r[11].s64 + -25704;
	// 8259A05C: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 8259A060: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8259A064: 48858385  bl 0x82df23e8
	ctx.lr = 0x8259A068;
	sub_82DF23E8(ctx, base);
	// 8259A068: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259A06C: 41820010  beq 0x8259a07c
	if ctx.cr[0].eq {
	pc = 0x8259A07C; continue 'dispatch;
	}
	// 8259A070: 4BFFFE21  bl 0x82599e90
	ctx.lr = 0x8259A074;
	sub_82599E90(ctx, base);
	// 8259A074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A078: 48000008  b 0x8259a080
	pc = 0x8259A080; continue 'dispatch;
	// 8259A07C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259A080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A084: 889E0068  lbz r4, 0x68(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 8259A088: 488647F1  bl 0x82dfe878
	ctx.lr = 0x8259A08C;
	sub_82DFE878(ctx, base);
	// 8259A08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A09C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A0A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A0A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A0A8 size=164
    let mut pc: u32 = 0x8259A0A8;
    'dispatch: loop {
        match pc {
            0x8259A0A8 => {
    //   block [0x8259A0A8..0x8259A14C)
	// 8259A0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A0AC: 48C0E0C1  bl 0x831a816c
	ctx.lr = 0x8259A0B0;
	sub_831A8130(ctx, base);
	// 8259A0B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A0B4: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259A0B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A0BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8259A0C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259A0C4: 396BA038  addi r11, r11, -0x5fc8
	ctx.r[11].s64 = ctx.r[11].s64 + -24520;
	// 8259A0C8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259A0CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259A0D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259A0D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259A0D8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8259A0DC: 4886481D  bl 0x82dfe8f8
	ctx.lr = 0x8259A0E0;
	sub_82DFE8F8(ctx, base);
	// 8259A0E0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259A0E4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259A0E8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259A0EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259A0F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259A0F4: 488677A5  bl 0x82e01898
	ctx.lr = 0x8259A0F8;
	sub_82E01898(ctx, base);
	// 8259A0F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A0FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A100: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259A108: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8259A10C: 419A0024  beq cr6, 0x8259a130
	if ctx.cr[6].eq {
	pc = 0x8259A130; continue 'dispatch;
	}
	// 8259A110: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259A114: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259A118: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259A11C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259A120: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259A124: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259A128: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259A12C: 4082FFE8  bne 0x8259a114
	if !ctx.cr[0].eq {
	pc = 0x8259A114; continue 'dispatch;
	}
	// 8259A130: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259A134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259A138: 419A0008  beq cr6, 0x8259a140
	if ctx.cr[6].eq {
	pc = 0x8259A140; continue 'dispatch;
	}
	// 8259A13C: 4BD26755  bl 0x822c0890
	ctx.lr = 0x8259A140;
	sub_822C0890(ctx, base);
	// 8259A140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A144: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259A148: 48C0E074  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A150 size=108
    let mut pc: u32 = 0x8259A150;
    'dispatch: loop {
        match pc {
            0x8259A150 => {
    //   block [0x8259A150..0x8259A1BC)
	// 8259A150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A154: 48C0E015  bl 0x831a8168
	ctx.lr = 0x8259A158;
	sub_831A8130(ctx, base);
	// 8259A158: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A15C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259A168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A16C: 388B6E80  addi r4, r11, 0x6e80
	ctx.r[4].s64 = ctx.r[11].s64 + 28288;
	// 8259A170: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8259A174: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8259A178: 48859891  bl 0x82df3a08
	ctx.lr = 0x8259A17C;
	sub_82DF3A08(ctx, base);
	// 8259A17C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259A180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259A184: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259A188: 48000391  bl 0x8259a518
	ctx.lr = 0x8259A18C;
	sub_8259A518(ctx, base);
	// 8259A18C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259A190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A194: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A198: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8259A19C: 4BFFFF0D  bl 0x8259a0a8
	ctx.lr = 0x8259A1A0;
	sub_8259A0A8(ctx, base);
	// 8259A1A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259A1A4: 48859285  bl 0x82df3428
	ctx.lr = 0x8259A1A8;
	sub_82DF3428(ctx, base);
	// 8259A1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A1AC: 4885927D  bl 0x82df3428
	ctx.lr = 0x8259A1B0;
	sub_82DF3428(ctx, base);
	// 8259A1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A1B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259A1B8: 48C0E000  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A1C0 size=112
    let mut pc: u32 = 0x8259A1C0;
    'dispatch: loop {
        match pc {
            0x8259A1C0 => {
    //   block [0x8259A1C0..0x8259A230)
	// 8259A1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A1D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A1D4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A1D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A1DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259A1E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A1E4: 388B6E80  addi r4, r11, 0x6e80
	ctx.r[4].s64 = ctx.r[11].s64 + 28288;
	// 8259A1E8: 48859821  bl 0x82df3a08
	ctx.lr = 0x8259A1EC;
	sub_82DF3A08(ctx, base);
	// 8259A1EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259A1F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259A1F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259A1F8: 48000321  bl 0x8259a518
	ctx.lr = 0x8259A1FC;
	sub_8259A518(ctx, base);
	// 8259A1FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259A200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A204: 48868235  bl 0x82e02438
	ctx.lr = 0x8259A208;
	sub_82E02438(ctx, base);
	// 8259A208: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259A20C: 4885921D  bl 0x82df3428
	ctx.lr = 0x8259A210;
	sub_82DF3428(ctx, base);
	// 8259A210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A214: 48859215  bl 0x82df3428
	ctx.lr = 0x8259A218;
	sub_82DF3428(ctx, base);
	// 8259A218: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A21C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A220: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A224: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A22C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A230 size=116
    let mut pc: u32 = 0x8259A230;
    'dispatch: loop {
        match pc {
            0x8259A230 => {
    //   block [0x8259A230..0x8259A2A4)
	// 8259A230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A23C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A248: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259A24C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8259A250: 409A000C  bne cr6, 0x8259a25c
	if !ctx.cr[6].eq {
	pc = 0x8259A25C; continue 'dispatch;
	}
	// 8259A254: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A258: 48000030  b 0x8259a288
	pc = 0x8259A288; continue 'dispatch;
	// 8259A25C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8259A260: 419A0024  beq cr6, 0x8259a284
	if ctx.cr[6].eq {
	pc = 0x8259A284; continue 'dispatch;
	}
	// 8259A264: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A268: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A26C: 388B6E18  addi r4, r11, 0x6e18
	ctx.r[4].s64 = ctx.r[11].s64 + 28184;
	// 8259A270: 48C0DE89  bl 0x831a80f8
	ctx.lr = 0x8259A274;
	sub_831A80F8(ctx, base);
	// 8259A274: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259A278: 4182000C  beq 0x8259a284
	if ctx.cr[0].eq {
	pc = 0x8259A284; continue 'dispatch;
	}
	// 8259A27C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8259A280: 4800000C  b 0x8259a28c
	pc = 0x8259A28C; continue 'dispatch;
	// 8259A284: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A288: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A28C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A290: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A294: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A298: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A29C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A2A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A2A8 size=72
    let mut pc: u32 = 0x8259A2A8;
    'dispatch: loop {
        match pc {
            0x8259A2A8 => {
    //   block [0x8259A2A8..0x8259A2F0)
	// 8259A2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A2B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A2B4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8259A2B8: 419A001C  beq cr6, 0x8259a2d4
	if ctx.cr[6].eq {
	pc = 0x8259A2D4; continue 'dispatch;
	}
	// 8259A2BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8259A2C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259A2C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8259A2C8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259A2CC: 4BFFFF65  bl 0x8259a230
	ctx.lr = 0x8259A2D0;
	sub_8259A230(ctx, base);
	// 8259A2D0: 48000010  b 0x8259a2e0
	pc = 0x8259A2E0; continue 'dispatch;
	// 8259A2D4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A2D8: 396B6E18  addi r11, r11, 0x6e18
	ctx.r[11].s64 = ctx.r[11].s64 + 28184;
	// 8259A2DC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A2E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A2E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A2E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A2F0 size=116
    let mut pc: u32 = 0x8259A2F0;
    'dispatch: loop {
        match pc {
            0x8259A2F0 => {
    //   block [0x8259A2F0..0x8259A364)
	// 8259A2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A2F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A2FC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A300: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8259A304: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A308: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259A30C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A310: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 8259A314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259A318: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259A31C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8259A320: 419A0024  beq cr6, 0x8259a344
	if ctx.cr[6].eq {
	pc = 0x8259A344; continue 'dispatch;
	}
	// 8259A324: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259A328: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 8259A32C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259A330: 7D005828  lwarx r8, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 8259A334: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 8259A338: 7D00592D  stwcx. r8, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259A33C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259A340: 4082FFE8  bne 0x8259a328
	if !ctx.cr[0].eq {
	pc = 0x8259A328; continue 'dispatch;
	}
	// 8259A344: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8259A348: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 8259A34C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8259A350: 4E800421  bctrl
	ctx.lr = 0x8259A354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259A354: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A35C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A368 size=156
    let mut pc: u32 = 0x8259A368;
    'dispatch: loop {
        match pc {
            0x8259A368 => {
    //   block [0x8259A368..0x8259A404)
	// 8259A368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A36C: 48C0DDFD  bl 0x831a8168
	ctx.lr = 0x8259A370;
	sub_831A8130(ctx, base);
	// 8259A370: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A374: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8259A378: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259A37C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259A380: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259A384: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8259A388: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A38C: 4BFFFC3D  bl 0x82599fc8
	ctx.lr = 0x8259A390;
	sub_82599FC8(ctx, base);
	// 8259A390: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259A394: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8259A398: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259A39C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A3A0: 4BFFFDB1  bl 0x8259a150
	ctx.lr = 0x8259A3A4;
	sub_8259A150(ctx, base);
	// 8259A3A4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259A3A8: 488644C1  bl 0x82dfe868
	ctx.lr = 0x8259A3AC;
	sub_82DFE868(ctx, base);
	// 8259A3AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259A3B0: 40820024  bne 0x8259a3d4
	if !ctx.cr[0].eq {
	pc = 0x8259A3D4; continue 'dispatch;
	}
	// 8259A3B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8259A3B8: 419A001C  beq cr6, 0x8259a3d4
	if ctx.cr[6].eq {
	pc = 0x8259A3D4; continue 'dispatch;
	}
	// 8259A3BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259A3C0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259A3C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259A3C8: 4BFFFB61  bl 0x82599f28
	ctx.lr = 0x8259A3CC;
	sub_82599F28(ctx, base);
	// 8259A3CC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259A3D0: 48864489  bl 0x82dfe858
	ctx.lr = 0x8259A3D4;
	sub_82DFE858(ctx, base);
	// 8259A3D4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259A3D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259A3DC: 419A0008  beq cr6, 0x8259a3e4
	if ctx.cr[6].eq {
	pc = 0x8259A3E4; continue 'dispatch;
	}
	// 8259A3E0: 4BD264B1  bl 0x822c0890
	ctx.lr = 0x8259A3E4;
	sub_822C0890(ctx, base);
	// 8259A3E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259A3E8: 4BFFFBF9  bl 0x82599fe0
	ctx.lr = 0x8259A3EC;
	sub_82599FE0(ctx, base);
	// 8259A3EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259A3F4: 419A0008  beq cr6, 0x8259a3fc
	if ctx.cr[6].eq {
	pc = 0x8259A3FC; continue 'dispatch;
	}
	// 8259A3F8: 4BD26499  bl 0x822c0890
	ctx.lr = 0x8259A3FC;
	sub_822C0890(ctx, base);
	// 8259A3FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259A400: 48C0DDB8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A408 size=128
    let mut pc: u32 = 0x8259A408;
    'dispatch: loop {
        match pc {
            0x8259A408 => {
    //   block [0x8259A408..0x8259A488)
	// 8259A408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A40C: 48C0DD61  bl 0x831a816c
	ctx.lr = 0x8259A410;
	sub_831A8130(ctx, base);
	// 8259A410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A414: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8259A418: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8259A41C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A420: 3BEB7B58  addi r31, r11, 0x7b58
	ctx.r[31].s64 = ctx.r[11].s64 + 31576;
	// 8259A424: 816A7B60  lwz r11, 0x7b60(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31584 as u32) ) } as u64;
	// 8259A428: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8259A42C: 40820024  bne 0x8259a450
	if !ctx.cr[0].eq {
	pc = 0x8259A450; continue 'dispatch;
	}
	// 8259A430: 3D20825A  lis r9, -0x7da6
	ctx.r[9].s64 = -2108030976;
	// 8259A434: 3D00825A  lis r8, -0x7da6
	ctx.r[8].s64 = -2108030976;
	// 8259A438: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8259A43C: 3929A2F0  addi r9, r9, -0x5d10
	ctx.r[9].s64 = ctx.r[9].s64 + -23824;
	// 8259A440: 3908A2A8  addi r8, r8, -0x5d58
	ctx.r[8].s64 = ctx.r[8].s64 + -23896;
	// 8259A444: 916A7B60  stw r11, 0x7b60(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(31584 as u32), ctx.r[11].u32 ) };
	// 8259A448: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8259A44C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8259A450: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8259A454: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259A458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A45C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 8259A460: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8259A464: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259A468: 4832D471  bl 0x828c78d8
	ctx.lr = 0x8259A46C;
	sub_828C78D8(ctx, base);
	// 8259A46C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259A470: 4182000C  beq 0x8259a47c
	if ctx.cr[0].eq {
	pc = 0x8259A47C; continue 'dispatch;
	}
	// 8259A474: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259A478: 48000008  b 0x8259a480
	pc = 0x8259A480; continue 'dispatch;
	// 8259A47C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8259A480: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259A484: 48C0DD38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A488 size=140
    let mut pc: u32 = 0x8259A488;
    'dispatch: loop {
        match pc {
            0x8259A488 => {
    //   block [0x8259A488..0x8259A514)
	// 8259A488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A498: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A49C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A4A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A4A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A4A8: 388BA604  addi r4, r11, -0x59fc
	ctx.r[4].s64 = ctx.r[11].s64 + -23036;
	// 8259A4AC: 4885955D  bl 0x82df3a08
	ctx.lr = 0x8259A4B0;
	sub_82DF3A08(ctx, base);
	// 8259A4B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259A4B4: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259A4B8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 8259A4BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259A4C0: 388BA1C0  addi r4, r11, -0x5e40
	ctx.r[4].s64 = ctx.r[11].s64 + -24128;
	// 8259A4C4: 4BD37C5D  bl 0x822d2120
	ctx.lr = 0x8259A4C8;
	sub_822D2120(ctx, base);
	// 8259A4C8: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8259A4CC: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259A4D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259A4D4: 388BA368  addi r4, r11, -0x5c98
	ctx.r[4].s64 = ctx.r[11].s64 + -23704;
	// 8259A4D8: 4BFFFF31  bl 0x8259a408
	ctx.lr = 0x8259A4DC;
	sub_8259A408(ctx, base);
	// 8259A4DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259A4E0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8259A4E4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8259A4E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259A4EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259A4F0: 48868D19  bl 0x82e03208
	ctx.lr = 0x8259A4F4;
	sub_82E03208(ctx, base);
	// 8259A4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A4F8: 48858F31  bl 0x82df3428
	ctx.lr = 0x8259A4FC;
	sub_82DF3428(ctx, base);
	// 8259A4FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8259A500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A508: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A50C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A518 size=132
    let mut pc: u32 = 0x8259A518;
    'dispatch: loop {
        match pc {
            0x8259A518 => {
    //   block [0x8259A518..0x8259A59C)
	// 8259A518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A51C: 48C0DC4D  bl 0x831a8168
	ctx.lr = 0x8259A520;
	sub_831A8130(ctx, base);
	// 8259A520: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A528: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259A52C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8259A530: 48858BC1  bl 0x82df30f0
	ctx.lr = 0x8259A534;
	sub_82DF30F0(ctx, base);
	// 8259A534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259A538: 48858EF9  bl 0x82df3430
	ctx.lr = 0x8259A53C;
	sub_82DF3430(ctx, base);
	// 8259A53C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259A540: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259A544: 48858EED  bl 0x82df3430
	ctx.lr = 0x8259A548;
	sub_82DF3430(ctx, base);
	// 8259A548: 7D7C1A14  add r11, r28, r3
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 8259A54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A550: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 8259A554: 48B2D58D  bl 0x830c7ae0
	ctx.lr = 0x8259A558;
	sub_830C7AE0(ctx, base);
	// 8259A558: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A560: 388BA60C  addi r4, r11, -0x59f4
	ctx.r[4].s64 = ctx.r[11].s64 + -23028;
	// 8259A564: 48859015  bl 0x82df3578
	ctx.lr = 0x8259A568;
	sub_82DF3578(ctx, base);
	// 8259A568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A56C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259A570: 48859169  bl 0x82df36d8
	ctx.lr = 0x8259A574;
	sub_82DF36D8(ctx, base);
	// 8259A574: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259A578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A57C: 388B9FD8  addi r4, r11, -0x6028
	ctx.r[4].s64 = ctx.r[11].s64 + -24616;
	// 8259A580: 48858FF9  bl 0x82df3578
	ctx.lr = 0x8259A584;
	sub_82DF3578(ctx, base);
	// 8259A584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A588: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259A58C: 4885914D  bl 0x82df36d8
	ctx.lr = 0x8259A590;
	sub_82DF36D8(ctx, base);
	// 8259A590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A594: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259A598: 48C0DC20  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A5A0 size=76
    let mut pc: u32 = 0x8259A5A0;
    'dispatch: loop {
        match pc {
            0x8259A5A0 => {
    //   block [0x8259A5A0..0x8259A5EC)
	// 8259A5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A5A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A5AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A5B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A5B4: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259A5B8: 481FEE81  bl 0x82799438
	ctx.lr = 0x8259A5BC;
	sub_82799438(ctx, base);
	// 8259A5BC: 4800652D  bl 0x825a0ae8
	ctx.lr = 0x8259A5C0;
	sub_825A0AE8(ctx, base);
	// 8259A5C0: 815F0158  lwz r10, 0x158(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 8259A5C4: 39630007  addi r11, r3, 7
	ctx.r[11].s64 = ctx.r[3].s64 + 7;
	// 8259A5C8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8259A5CC: 40980008  bge cr6, 0x8259a5d4
	if !ctx.cr[6].lt {
	pc = 0x8259A5D4; continue 'dispatch;
	}
	// 8259A5D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8259A5D4: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8259A5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A5F0 size=84
    let mut pc: u32 = 0x8259A5F0;
    'dispatch: loop {
        match pc {
            0x8259A5F0 => {
    //   block [0x8259A5F0..0x8259A644)
	// 8259A5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A5F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A5FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A604: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259A608: 481FEE31  bl 0x82799438
	ctx.lr = 0x8259A60C;
	sub_82799438(ctx, base);
	// 8259A60C: 480064DD  bl 0x825a0ae8
	ctx.lr = 0x8259A610;
	sub_825A0AE8(ctx, base);
	// 8259A610: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 8259A614: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 8259A618: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8259A61C: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8259A620: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8259A624: 4198000C  blt cr6, 0x8259a630
	if ctx.cr[6].lt {
	pc = 0x8259A630; continue 'dispatch;
	}
	// 8259A628: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A62C: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8259A630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A63C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A648 size=80
    let mut pc: u32 = 0x8259A648;
    'dispatch: loop {
        match pc {
            0x8259A648 => {
    //   block [0x8259A648..0x8259A698)
	// 8259A648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259A65C: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259A660: 481FEDD9  bl 0x82799438
	ctx.lr = 0x8259A664;
	sub_82799438(ctx, base);
	// 8259A664: 48006485  bl 0x825a0ae8
	ctx.lr = 0x8259A668;
	sub_825A0AE8(ctx, base);
	// 8259A668: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 8259A66C: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 8259A670: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259A674: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8259A678: 4080000C  bge 0x8259a684
	if !ctx.cr[0].lt {
	pc = 0x8259A684; continue 'dispatch;
	}
	// 8259A67C: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 8259A680: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8259A684: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A68C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A698 size=40
    let mut pc: u32 = 0x8259A698;
    'dispatch: loop {
        match pc {
            0x8259A698 => {
    //   block [0x8259A698..0x8259A6C0)
	// 8259A698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A6A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A6A4: 48BB9F5D  bl 0x83154600
	ctx.lr = 0x8259A6A8;
	sub_83154600(ctx, base);
	// 8259A6A8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8259A6AC: 91630150  stw r11, 0x150(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 8259A6B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259A6B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A6B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A6C0 size=196
    let mut pc: u32 = 0x8259A6C0;
    'dispatch: loop {
        match pc {
            0x8259A6C0 => {
    //   block [0x8259A6C0..0x8259A784)
	// 8259A6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A6D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A6D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A6DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259A6E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259A6E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A6E8: 4BD26251  bl 0x822c0938
	ctx.lr = 0x8259A6EC;
	sub_822C0938(ctx, base);
	// 8259A6EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259A6F0: 41820028  beq 0x8259a718
	if ctx.cr[0].eq {
	pc = 0x8259A718; continue 'dispatch;
	}
	// 8259A6F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A6F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259A6FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259A700: 392BA644  addi r9, r11, -0x59bc
	ctx.r[9].s64 = ctx.r[11].s64 + -22972;
	// 8259A704: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259A708: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259A70C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259A710: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259A714: 48000008  b 0x8259a71c
	pc = 0x8259A71C; continue 'dispatch;
	// 8259A718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A71C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259A724: 409A0044  bne cr6, 0x8259a768
	if !ctx.cr[6].eq {
	pc = 0x8259A768; continue 'dispatch;
	}
	// 8259A728: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259A72C: 419A001C  beq cr6, 0x8259a748
	if ctx.cr[6].eq {
	pc = 0x8259A748; continue 'dispatch;
	}
	// 8259A730: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A734: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259A738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A73C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259A744: 4E800421  bctrl
	ctx.lr = 0x8259A748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259A748: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A74C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259A750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A754: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259A758: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259A75C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259A760: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259A764: 4BD2589D  bl 0x822c0000
	ctx.lr = 0x8259A768;
	sub_822C0000(ctx, base);
	// 8259A768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259A76C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A778: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A77C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A788 size=196
    let mut pc: u32 = 0x8259A788;
    'dispatch: loop {
        match pc {
            0x8259A788 => {
    //   block [0x8259A788..0x8259A84C)
	// 8259A788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A798: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A79C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A7A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A7A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259A7A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259A7AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A7B0: 4BD26189  bl 0x822c0938
	ctx.lr = 0x8259A7B4;
	sub_822C0938(ctx, base);
	// 8259A7B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259A7B8: 41820028  beq 0x8259a7e0
	if ctx.cr[0].eq {
	pc = 0x8259A7E0; continue 'dispatch;
	}
	// 8259A7BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A7C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259A7C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259A7C8: 392BA658  addi r9, r11, -0x59a8
	ctx.r[9].s64 = ctx.r[11].s64 + -22952;
	// 8259A7CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259A7D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259A7D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259A7D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259A7DC: 48000008  b 0x8259a7e4
	pc = 0x8259A7E4; continue 'dispatch;
	// 8259A7E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A7E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259A7EC: 409A0044  bne cr6, 0x8259a830
	if !ctx.cr[6].eq {
	pc = 0x8259A830; continue 'dispatch;
	}
	// 8259A7F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259A7F4: 419A001C  beq cr6, 0x8259a810
	if ctx.cr[6].eq {
	pc = 0x8259A810; continue 'dispatch;
	}
	// 8259A7F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A7FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259A800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A804: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A808: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259A80C: 4E800421  bctrl
	ctx.lr = 0x8259A810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259A810: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A814: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259A818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A81C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259A820: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259A824: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259A828: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259A82C: 4BD257D5  bl 0x822c0000
	ctx.lr = 0x8259A830;
	sub_822C0000(ctx, base);
	// 8259A830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259A834: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A83C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A840: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A850 size=196
    let mut pc: u32 = 0x8259A850;
    'dispatch: loop {
        match pc {
            0x8259A850 => {
    //   block [0x8259A850..0x8259A914)
	// 8259A850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A85C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A864: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A86C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259A870: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259A874: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A878: 4BD260C1  bl 0x822c0938
	ctx.lr = 0x8259A87C;
	sub_822C0938(ctx, base);
	// 8259A87C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259A880: 41820028  beq 0x8259a8a8
	if ctx.cr[0].eq {
	pc = 0x8259A8A8; continue 'dispatch;
	}
	// 8259A884: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A888: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259A88C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259A890: 392BA66C  addi r9, r11, -0x5994
	ctx.r[9].s64 = ctx.r[11].s64 + -22932;
	// 8259A894: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259A898: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259A89C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259A8A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259A8A4: 48000008  b 0x8259a8ac
	pc = 0x8259A8AC; continue 'dispatch;
	// 8259A8A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A8AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259A8B4: 409A0044  bne cr6, 0x8259a8f8
	if !ctx.cr[6].eq {
	pc = 0x8259A8F8; continue 'dispatch;
	}
	// 8259A8B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259A8BC: 419A001C  beq cr6, 0x8259a8d8
	if ctx.cr[6].eq {
	pc = 0x8259A8D8; continue 'dispatch;
	}
	// 8259A8C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A8C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259A8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A8CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259A8D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259A8D4: 4E800421  bctrl
	ctx.lr = 0x8259A8D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259A8D8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A8DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259A8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A8E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259A8E8: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259A8EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259A8F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259A8F4: 4BD2570D  bl 0x822c0000
	ctx.lr = 0x8259A8F8;
	sub_822C0000(ctx, base);
	// 8259A8F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259A8FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A90C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A918 size=196
    let mut pc: u32 = 0x8259A918;
    'dispatch: loop {
        match pc {
            0x8259A918 => {
    //   block [0x8259A918..0x8259A9DC)
	// 8259A918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A92C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A930: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A934: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259A938: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259A93C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A940: 4BD25FF9  bl 0x822c0938
	ctx.lr = 0x8259A944;
	sub_822C0938(ctx, base);
	// 8259A944: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259A948: 41820028  beq 0x8259a970
	if ctx.cr[0].eq {
	pc = 0x8259A970; continue 'dispatch;
	}
	// 8259A94C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259A950: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259A954: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259A958: 392BA680  addi r9, r11, -0x5980
	ctx.r[9].s64 = ctx.r[11].s64 + -22912;
	// 8259A95C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259A960: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259A964: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259A968: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259A96C: 48000008  b 0x8259a974
	pc = 0x8259A974; continue 'dispatch;
	// 8259A970: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259A978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259A97C: 409A0044  bne cr6, 0x8259a9c0
	if !ctx.cr[6].eq {
	pc = 0x8259A9C0; continue 'dispatch;
	}
	// 8259A980: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259A984: 419A001C  beq cr6, 0x8259a9a0
	if ctx.cr[6].eq {
	pc = 0x8259A9A0; continue 'dispatch;
	}
	// 8259A988: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A98C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259A990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259A994: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259A998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259A99C: 4E800421  bctrl
	ctx.lr = 0x8259A9A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259A9A0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259A9A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259A9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259A9AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259A9B0: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259A9B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259A9B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259A9BC: 4BD25645  bl 0x822c0000
	ctx.lr = 0x8259A9C0;
	sub_822C0000(ctx, base);
	// 8259A9C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259A9C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259A9C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259A9CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259A9D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259A9D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259A9D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259A9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259A9E0 size=196
    let mut pc: u32 = 0x8259A9E0;
    'dispatch: loop {
        match pc {
            0x8259A9E0 => {
    //   block [0x8259A9E0..0x8259AAA4)
	// 8259A9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259A9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259A9E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259A9EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259A9F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259A9F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259A9F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259A9FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AA00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AA04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AA08: 4BD25F31  bl 0x822c0938
	ctx.lr = 0x8259AA0C;
	sub_822C0938(ctx, base);
	// 8259AA0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259AA10: 41820028  beq 0x8259aa38
	if ctx.cr[0].eq {
	pc = 0x8259AA38; continue 'dispatch;
	}
	// 8259AA14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AA18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AA1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AA20: 392BA694  addi r9, r11, -0x596c
	ctx.r[9].s64 = ctx.r[11].s64 + -22892;
	// 8259AA24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AA28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AA2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AA30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AA34: 48000008  b 0x8259aa3c
	pc = 0x8259AA3C; continue 'dispatch;
	// 8259AA38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AA3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AA40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AA44: 409A0044  bne cr6, 0x8259aa88
	if !ctx.cr[6].eq {
	pc = 0x8259AA88; continue 'dispatch;
	}
	// 8259AA48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259AA4C: 419A001C  beq cr6, 0x8259aa68
	if ctx.cr[6].eq {
	pc = 0x8259AA68; continue 'dispatch;
	}
	// 8259AA50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AA54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259AA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259AA5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AA60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259AA64: 4E800421  bctrl
	ctx.lr = 0x8259AA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259AA68: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259AA6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AA74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AA78: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AA7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259AA80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259AA84: 4BD2557D  bl 0x822c0000
	ctx.lr = 0x8259AA88;
	sub_822C0000(ctx, base);
	// 8259AA88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259AA8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259AA90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259AA94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259AA98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259AA9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259AAA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259AAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259AAA8 size=196
    let mut pc: u32 = 0x8259AAA8;
    'dispatch: loop {
        match pc {
            0x8259AAA8 => {
    //   block [0x8259AAA8..0x8259AB6C)
	// 8259AAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259AAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259AAB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259AAB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259AAB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259AABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259AAC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AAC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AAC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AACC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AAD0: 4BD25E69  bl 0x822c0938
	ctx.lr = 0x8259AAD4;
	sub_822C0938(ctx, base);
	// 8259AAD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259AAD8: 41820028  beq 0x8259ab00
	if ctx.cr[0].eq {
	pc = 0x8259AB00; continue 'dispatch;
	}
	// 8259AADC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AAE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AAE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AAE8: 392BA6A8  addi r9, r11, -0x5958
	ctx.r[9].s64 = ctx.r[11].s64 + -22872;
	// 8259AAEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AAF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AAF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AAF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AAFC: 48000008  b 0x8259ab04
	pc = 0x8259AB04; continue 'dispatch;
	// 8259AB00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AB04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AB0C: 409A0044  bne cr6, 0x8259ab50
	if !ctx.cr[6].eq {
	pc = 0x8259AB50; continue 'dispatch;
	}
	// 8259AB10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259AB14: 419A001C  beq cr6, 0x8259ab30
	if ctx.cr[6].eq {
	pc = 0x8259AB30; continue 'dispatch;
	}
	// 8259AB18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AB1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259AB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259AB24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AB28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259AB2C: 4E800421  bctrl
	ctx.lr = 0x8259AB30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259AB30: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259AB34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AB38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AB3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AB40: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AB44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259AB48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259AB4C: 4BD254B5  bl 0x822c0000
	ctx.lr = 0x8259AB50;
	sub_822C0000(ctx, base);
	// 8259AB50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259AB54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259AB58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259AB5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259AB60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259AB64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259AB68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259AB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259AB70 size=196
    let mut pc: u32 = 0x8259AB70;
    'dispatch: loop {
        match pc {
            0x8259AB70 => {
    //   block [0x8259AB70..0x8259AC34)
	// 8259AB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259AB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259AB78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259AB7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259AB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259AB84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259AB88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AB8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AB90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AB94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AB98: 4BD25DA1  bl 0x822c0938
	ctx.lr = 0x8259AB9C;
	sub_822C0938(ctx, base);
	// 8259AB9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259ABA0: 41820028  beq 0x8259abc8
	if ctx.cr[0].eq {
	pc = 0x8259ABC8; continue 'dispatch;
	}
	// 8259ABA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259ABA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259ABAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259ABB0: 392BA6BC  addi r9, r11, -0x5944
	ctx.r[9].s64 = ctx.r[11].s64 + -22852;
	// 8259ABB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259ABB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259ABBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259ABC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259ABC4: 48000008  b 0x8259abcc
	pc = 0x8259ABCC; continue 'dispatch;
	// 8259ABC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259ABCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259ABD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259ABD4: 409A0044  bne cr6, 0x8259ac18
	if !ctx.cr[6].eq {
	pc = 0x8259AC18; continue 'dispatch;
	}
	// 8259ABD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259ABDC: 419A001C  beq cr6, 0x8259abf8
	if ctx.cr[6].eq {
	pc = 0x8259ABF8; continue 'dispatch;
	}
	// 8259ABE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259ABE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259ABE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259ABEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259ABF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259ABF4: 4E800421  bctrl
	ctx.lr = 0x8259ABF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259ABF8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259ABFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AC00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AC04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AC08: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AC0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259AC10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259AC14: 4BD253ED  bl 0x822c0000
	ctx.lr = 0x8259AC18;
	sub_822C0000(ctx, base);
	// 8259AC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259AC1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259AC20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259AC24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259AC28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259AC2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259AC30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259AC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259AC38 size=196
    let mut pc: u32 = 0x8259AC38;
    'dispatch: loop {
        match pc {
            0x8259AC38 => {
    //   block [0x8259AC38..0x8259ACFC)
	// 8259AC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259AC3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259AC40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259AC44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259AC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259AC4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259AC50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AC54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AC58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AC5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AC60: 4BD25CD9  bl 0x822c0938
	ctx.lr = 0x8259AC64;
	sub_822C0938(ctx, base);
	// 8259AC64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259AC68: 41820028  beq 0x8259ac90
	if ctx.cr[0].eq {
	pc = 0x8259AC90; continue 'dispatch;
	}
	// 8259AC6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AC70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AC74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AC78: 392BA6D0  addi r9, r11, -0x5930
	ctx.r[9].s64 = ctx.r[11].s64 + -22832;
	// 8259AC7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AC80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AC84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AC88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AC8C: 48000008  b 0x8259ac94
	pc = 0x8259AC94; continue 'dispatch;
	// 8259AC90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AC94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AC9C: 409A0044  bne cr6, 0x8259ace0
	if !ctx.cr[6].eq {
	pc = 0x8259ACE0; continue 'dispatch;
	}
	// 8259ACA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259ACA4: 419A001C  beq cr6, 0x8259acc0
	if ctx.cr[6].eq {
	pc = 0x8259ACC0; continue 'dispatch;
	}
	// 8259ACA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259ACAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259ACB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259ACB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259ACB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259ACBC: 4E800421  bctrl
	ctx.lr = 0x8259ACC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259ACC0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259ACC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259ACC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ACCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259ACD0: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259ACD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259ACD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259ACDC: 4BD25325  bl 0x822c0000
	ctx.lr = 0x8259ACE0;
	sub_822C0000(ctx, base);
	// 8259ACE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259ACE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259ACE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259ACEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259ACF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259ACF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259ACF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259AD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259AD00 size=196
    let mut pc: u32 = 0x8259AD00;
    'dispatch: loop {
        match pc {
            0x8259AD00 => {
    //   block [0x8259AD00..0x8259ADC4)
	// 8259AD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259AD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259AD08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259AD0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259AD10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259AD14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259AD18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AD1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AD20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AD24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AD28: 4BD25C11  bl 0x822c0938
	ctx.lr = 0x8259AD2C;
	sub_822C0938(ctx, base);
	// 8259AD2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259AD30: 41820028  beq 0x8259ad58
	if ctx.cr[0].eq {
	pc = 0x8259AD58; continue 'dispatch;
	}
	// 8259AD34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AD38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AD3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AD40: 392BA6E4  addi r9, r11, -0x591c
	ctx.r[9].s64 = ctx.r[11].s64 + -22812;
	// 8259AD44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AD48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AD4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AD50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AD54: 48000008  b 0x8259ad5c
	pc = 0x8259AD5C; continue 'dispatch;
	// 8259AD58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AD5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AD60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AD64: 409A0044  bne cr6, 0x8259ada8
	if !ctx.cr[6].eq {
	pc = 0x8259ADA8; continue 'dispatch;
	}
	// 8259AD68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259AD6C: 419A001C  beq cr6, 0x8259ad88
	if ctx.cr[6].eq {
	pc = 0x8259AD88; continue 'dispatch;
	}
	// 8259AD70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AD74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259AD78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259AD7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AD80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259AD84: 4E800421  bctrl
	ctx.lr = 0x8259AD88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259AD88: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259AD8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AD90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AD94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AD98: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AD9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259ADA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259ADA4: 4BD2525D  bl 0x822c0000
	ctx.lr = 0x8259ADA8;
	sub_822C0000(ctx, base);
	// 8259ADA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259ADAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259ADB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259ADB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259ADB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259ADBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259ADC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259ADC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259ADC8 size=196
    let mut pc: u32 = 0x8259ADC8;
    'dispatch: loop {
        match pc {
            0x8259ADC8 => {
    //   block [0x8259ADC8..0x8259AE8C)
	// 8259ADC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259ADCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259ADD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259ADD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259ADD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259ADDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259ADE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259ADE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259ADE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259ADEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259ADF0: 4BD25B49  bl 0x822c0938
	ctx.lr = 0x8259ADF4;
	sub_822C0938(ctx, base);
	// 8259ADF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259ADF8: 41820028  beq 0x8259ae20
	if ctx.cr[0].eq {
	pc = 0x8259AE20; continue 'dispatch;
	}
	// 8259ADFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AE00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AE04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AE08: 392BA6F8  addi r9, r11, -0x5908
	ctx.r[9].s64 = ctx.r[11].s64 + -22792;
	// 8259AE0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AE10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AE14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AE18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AE1C: 48000008  b 0x8259ae24
	pc = 0x8259AE24; continue 'dispatch;
	// 8259AE20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AE24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AE28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AE2C: 409A0044  bne cr6, 0x8259ae70
	if !ctx.cr[6].eq {
	pc = 0x8259AE70; continue 'dispatch;
	}
	// 8259AE30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259AE34: 419A001C  beq cr6, 0x8259ae50
	if ctx.cr[6].eq {
	pc = 0x8259AE50; continue 'dispatch;
	}
	// 8259AE38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AE3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259AE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259AE44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AE48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259AE4C: 4E800421  bctrl
	ctx.lr = 0x8259AE50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259AE50: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259AE54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AE58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AE5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AE60: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AE64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259AE68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259AE6C: 4BD25195  bl 0x822c0000
	ctx.lr = 0x8259AE70;
	sub_822C0000(ctx, base);
	// 8259AE70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259AE74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259AE78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259AE7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259AE80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259AE84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259AE88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259AE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259AE90 size=196
    let mut pc: u32 = 0x8259AE90;
    'dispatch: loop {
        match pc {
            0x8259AE90 => {
    //   block [0x8259AE90..0x8259AF54)
	// 8259AE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259AE94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259AE98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259AE9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259AEA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259AEA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259AEA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AEAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AEB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AEB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AEB8: 4BD25A81  bl 0x822c0938
	ctx.lr = 0x8259AEBC;
	sub_822C0938(ctx, base);
	// 8259AEBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259AEC0: 41820028  beq 0x8259aee8
	if ctx.cr[0].eq {
	pc = 0x8259AEE8; continue 'dispatch;
	}
	// 8259AEC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AEC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AECC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AED0: 392BA70C  addi r9, r11, -0x58f4
	ctx.r[9].s64 = ctx.r[11].s64 + -22772;
	// 8259AED4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AED8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AEDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AEE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AEE4: 48000008  b 0x8259aeec
	pc = 0x8259AEEC; continue 'dispatch;
	// 8259AEE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AEEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AEF4: 409A0044  bne cr6, 0x8259af38
	if !ctx.cr[6].eq {
	pc = 0x8259AF38; continue 'dispatch;
	}
	// 8259AEF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259AEFC: 419A001C  beq cr6, 0x8259af18
	if ctx.cr[6].eq {
	pc = 0x8259AF18; continue 'dispatch;
	}
	// 8259AF00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AF04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259AF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259AF0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AF10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259AF14: 4E800421  bctrl
	ctx.lr = 0x8259AF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259AF18: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259AF1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AF20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AF24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AF28: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AF2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259AF30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259AF34: 4BD250CD  bl 0x822c0000
	ctx.lr = 0x8259AF38;
	sub_822C0000(ctx, base);
	// 8259AF38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259AF3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259AF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259AF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259AF48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259AF4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259AF50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259AF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259AF58 size=196
    let mut pc: u32 = 0x8259AF58;
    'dispatch: loop {
        match pc {
            0x8259AF58 => {
    //   block [0x8259AF58..0x8259B01C)
	// 8259AF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259AF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259AF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259AF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259AF68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259AF6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259AF70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AF74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259AF78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259AF7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AF80: 4BD259B9  bl 0x822c0938
	ctx.lr = 0x8259AF84;
	sub_822C0938(ctx, base);
	// 8259AF84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259AF88: 41820028  beq 0x8259afb0
	if ctx.cr[0].eq {
	pc = 0x8259AFB0; continue 'dispatch;
	}
	// 8259AF8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259AF90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259AF94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259AF98: 392BA720  addi r9, r11, -0x58e0
	ctx.r[9].s64 = ctx.r[11].s64 + -22752;
	// 8259AF9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259AFA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259AFA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259AFA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259AFAC: 48000008  b 0x8259afb4
	pc = 0x8259AFB4; continue 'dispatch;
	// 8259AFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259AFB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259AFB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259AFBC: 409A0044  bne cr6, 0x8259b000
	if !ctx.cr[6].eq {
	pc = 0x8259B000; continue 'dispatch;
	}
	// 8259AFC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259AFC4: 419A001C  beq cr6, 0x8259afe0
	if ctx.cr[6].eq {
	pc = 0x8259AFE0; continue 'dispatch;
	}
	// 8259AFC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AFCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259AFD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259AFD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259AFD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259AFDC: 4E800421  bctrl
	ctx.lr = 0x8259AFE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259AFE0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259AFE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259AFE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259AFEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259AFF0: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259AFF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259AFF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259AFFC: 4BD25005  bl 0x822c0000
	ctx.lr = 0x8259B000;
	sub_822C0000(ctx, base);
	// 8259B000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B010: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B020 size=196
    let mut pc: u32 = 0x8259B020;
    'dispatch: loop {
        match pc {
            0x8259B020 => {
    //   block [0x8259B020..0x8259B0E4)
	// 8259B020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B02C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B03C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B040: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B048: 4BD258F1  bl 0x822c0938
	ctx.lr = 0x8259B04C;
	sub_822C0938(ctx, base);
	// 8259B04C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B050: 41820028  beq 0x8259b078
	if ctx.cr[0].eq {
	pc = 0x8259B078; continue 'dispatch;
	}
	// 8259B054: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B058: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B05C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B060: 392BA734  addi r9, r11, -0x58cc
	ctx.r[9].s64 = ctx.r[11].s64 + -22732;
	// 8259B064: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B068: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B06C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B070: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B074: 48000008  b 0x8259b07c
	pc = 0x8259B07C; continue 'dispatch;
	// 8259B078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B07C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B084: 409A0044  bne cr6, 0x8259b0c8
	if !ctx.cr[6].eq {
	pc = 0x8259B0C8; continue 'dispatch;
	}
	// 8259B088: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B08C: 419A001C  beq cr6, 0x8259b0a8
	if ctx.cr[6].eq {
	pc = 0x8259B0A8; continue 'dispatch;
	}
	// 8259B090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B094: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B09C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B0A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B0A4: 4E800421  bctrl
	ctx.lr = 0x8259B0A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B0A8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B0AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B0B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B0B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B0B8: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B0BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B0C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B0C4: 4BD24F3D  bl 0x822c0000
	ctx.lr = 0x8259B0C8;
	sub_822C0000(ctx, base);
	// 8259B0C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B0CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B0D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B0D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B0D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B0DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B0E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B0E8 size=196
    let mut pc: u32 = 0x8259B0E8;
    'dispatch: loop {
        match pc {
            0x8259B0E8 => {
    //   block [0x8259B0E8..0x8259B1AC)
	// 8259B0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B0F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B0F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B0F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B0FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B104: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B108: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B10C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B110: 4BD25829  bl 0x822c0938
	ctx.lr = 0x8259B114;
	sub_822C0938(ctx, base);
	// 8259B114: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B118: 41820028  beq 0x8259b140
	if ctx.cr[0].eq {
	pc = 0x8259B140; continue 'dispatch;
	}
	// 8259B11C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B120: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B124: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B128: 392BA748  addi r9, r11, -0x58b8
	ctx.r[9].s64 = ctx.r[11].s64 + -22712;
	// 8259B12C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B130: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B134: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B138: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B13C: 48000008  b 0x8259b144
	pc = 0x8259B144; continue 'dispatch;
	// 8259B140: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B144: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B14C: 409A0044  bne cr6, 0x8259b190
	if !ctx.cr[6].eq {
	pc = 0x8259B190; continue 'dispatch;
	}
	// 8259B150: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B154: 419A001C  beq cr6, 0x8259b170
	if ctx.cr[6].eq {
	pc = 0x8259B170; continue 'dispatch;
	}
	// 8259B158: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B15C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B164: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B16C: 4E800421  bctrl
	ctx.lr = 0x8259B170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B170: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B17C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B180: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B184: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B188: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B18C: 4BD24E75  bl 0x822c0000
	ctx.lr = 0x8259B190;
	sub_822C0000(ctx, base);
	// 8259B190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B19C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B1A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B1A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B1A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B1B0 size=196
    let mut pc: u32 = 0x8259B1B0;
    'dispatch: loop {
        match pc {
            0x8259B1B0 => {
    //   block [0x8259B1B0..0x8259B274)
	// 8259B1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B1B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B1B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B1BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B1C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B1C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B1C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B1CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B1D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B1D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B1D8: 4BD25761  bl 0x822c0938
	ctx.lr = 0x8259B1DC;
	sub_822C0938(ctx, base);
	// 8259B1DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B1E0: 41820028  beq 0x8259b208
	if ctx.cr[0].eq {
	pc = 0x8259B208; continue 'dispatch;
	}
	// 8259B1E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B1E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B1EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B1F0: 392BA75C  addi r9, r11, -0x58a4
	ctx.r[9].s64 = ctx.r[11].s64 + -22692;
	// 8259B1F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B1F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B1FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B200: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B204: 48000008  b 0x8259b20c
	pc = 0x8259B20C; continue 'dispatch;
	// 8259B208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B20C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B214: 409A0044  bne cr6, 0x8259b258
	if !ctx.cr[6].eq {
	pc = 0x8259B258; continue 'dispatch;
	}
	// 8259B218: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B21C: 419A001C  beq cr6, 0x8259b238
	if ctx.cr[6].eq {
	pc = 0x8259B238; continue 'dispatch;
	}
	// 8259B220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B224: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B22C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B234: 4E800421  bctrl
	ctx.lr = 0x8259B238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B238: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B23C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B244: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B248: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B24C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B250: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B254: 4BD24DAD  bl 0x822c0000
	ctx.lr = 0x8259B258;
	sub_822C0000(ctx, base);
	// 8259B258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B25C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B268: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B26C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B278 size=196
    let mut pc: u32 = 0x8259B278;
    'dispatch: loop {
        match pc {
            0x8259B278 => {
    //   block [0x8259B278..0x8259B33C)
	// 8259B278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B28C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B294: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B298: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B29C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B2A0: 4BD25699  bl 0x822c0938
	ctx.lr = 0x8259B2A4;
	sub_822C0938(ctx, base);
	// 8259B2A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B2A8: 41820028  beq 0x8259b2d0
	if ctx.cr[0].eq {
	pc = 0x8259B2D0; continue 'dispatch;
	}
	// 8259B2AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B2B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B2B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B2B8: 392BA770  addi r9, r11, -0x5890
	ctx.r[9].s64 = ctx.r[11].s64 + -22672;
	// 8259B2BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B2C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B2C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B2C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B2CC: 48000008  b 0x8259b2d4
	pc = 0x8259B2D4; continue 'dispatch;
	// 8259B2D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B2D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B2D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B2DC: 409A0044  bne cr6, 0x8259b320
	if !ctx.cr[6].eq {
	pc = 0x8259B320; continue 'dispatch;
	}
	// 8259B2E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B2E4: 419A001C  beq cr6, 0x8259b300
	if ctx.cr[6].eq {
	pc = 0x8259B300; continue 'dispatch;
	}
	// 8259B2E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B2EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B2F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B2FC: 4E800421  bctrl
	ctx.lr = 0x8259B300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B300: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B304: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B30C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B310: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B314: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B318: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B31C: 4BD24CE5  bl 0x822c0000
	ctx.lr = 0x8259B320;
	sub_822C0000(ctx, base);
	// 8259B320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B324: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B330: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B340 size=196
    let mut pc: u32 = 0x8259B340;
    'dispatch: loop {
        match pc {
            0x8259B340 => {
    //   block [0x8259B340..0x8259B404)
	// 8259B340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B34C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B35C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B360: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B364: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B368: 4BD255D1  bl 0x822c0938
	ctx.lr = 0x8259B36C;
	sub_822C0938(ctx, base);
	// 8259B36C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B370: 41820028  beq 0x8259b398
	if ctx.cr[0].eq {
	pc = 0x8259B398; continue 'dispatch;
	}
	// 8259B374: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B378: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B37C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B380: 392BA784  addi r9, r11, -0x587c
	ctx.r[9].s64 = ctx.r[11].s64 + -22652;
	// 8259B384: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B38C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B390: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B394: 48000008  b 0x8259b39c
	pc = 0x8259B39C; continue 'dispatch;
	// 8259B398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B39C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B3A4: 409A0044  bne cr6, 0x8259b3e8
	if !ctx.cr[6].eq {
	pc = 0x8259B3E8; continue 'dispatch;
	}
	// 8259B3A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B3AC: 419A001C  beq cr6, 0x8259b3c8
	if ctx.cr[6].eq {
	pc = 0x8259B3C8; continue 'dispatch;
	}
	// 8259B3B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B3B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B3BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B3C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B3C4: 4E800421  bctrl
	ctx.lr = 0x8259B3C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B3C8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B3CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B3D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B3D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B3D8: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B3DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B3E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B3E4: 4BD24C1D  bl 0x822c0000
	ctx.lr = 0x8259B3E8;
	sub_822C0000(ctx, base);
	// 8259B3E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B3EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B3F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B3FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B408 size=196
    let mut pc: u32 = 0x8259B408;
    'dispatch: loop {
        match pc {
            0x8259B408 => {
    //   block [0x8259B408..0x8259B4CC)
	// 8259B408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B40C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B41C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B424: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B428: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B42C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B430: 4BD25509  bl 0x822c0938
	ctx.lr = 0x8259B434;
	sub_822C0938(ctx, base);
	// 8259B434: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B438: 41820028  beq 0x8259b460
	if ctx.cr[0].eq {
	pc = 0x8259B460; continue 'dispatch;
	}
	// 8259B43C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B440: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B444: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B448: 392BA798  addi r9, r11, -0x5868
	ctx.r[9].s64 = ctx.r[11].s64 + -22632;
	// 8259B44C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B450: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B454: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B458: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B45C: 48000008  b 0x8259b464
	pc = 0x8259B464; continue 'dispatch;
	// 8259B460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B464: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B46C: 409A0044  bne cr6, 0x8259b4b0
	if !ctx.cr[6].eq {
	pc = 0x8259B4B0; continue 'dispatch;
	}
	// 8259B470: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B474: 419A001C  beq cr6, 0x8259b490
	if ctx.cr[6].eq {
	pc = 0x8259B490; continue 'dispatch;
	}
	// 8259B478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B47C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B484: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B48C: 4E800421  bctrl
	ctx.lr = 0x8259B490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B490: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B494: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B49C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B4A0: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B4A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B4A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B4AC: 4BD24B55  bl 0x822c0000
	ctx.lr = 0x8259B4B0;
	sub_822C0000(ctx, base);
	// 8259B4B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B4B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B4B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B4BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B4C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B4C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B4D0 size=196
    let mut pc: u32 = 0x8259B4D0;
    'dispatch: loop {
        match pc {
            0x8259B4D0 => {
    //   block [0x8259B4D0..0x8259B594)
	// 8259B4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B4D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B4DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B4E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B4E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B4E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B4EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B4F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B4F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B4F8: 4BD25441  bl 0x822c0938
	ctx.lr = 0x8259B4FC;
	sub_822C0938(ctx, base);
	// 8259B4FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B500: 41820028  beq 0x8259b528
	if ctx.cr[0].eq {
	pc = 0x8259B528; continue 'dispatch;
	}
	// 8259B504: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B508: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B50C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B510: 392BA7AC  addi r9, r11, -0x5854
	ctx.r[9].s64 = ctx.r[11].s64 + -22612;
	// 8259B514: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B51C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B520: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B524: 48000008  b 0x8259b52c
	pc = 0x8259B52C; continue 'dispatch;
	// 8259B528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B52C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B534: 409A0044  bne cr6, 0x8259b578
	if !ctx.cr[6].eq {
	pc = 0x8259B578; continue 'dispatch;
	}
	// 8259B538: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B53C: 419A001C  beq cr6, 0x8259b558
	if ctx.cr[6].eq {
	pc = 0x8259B558; continue 'dispatch;
	}
	// 8259B540: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B544: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B54C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B554: 4E800421  bctrl
	ctx.lr = 0x8259B558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B558: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B55C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B564: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B568: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B56C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B570: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B574: 4BD24A8D  bl 0x822c0000
	ctx.lr = 0x8259B578;
	sub_822C0000(ctx, base);
	// 8259B578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B57C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B588: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B58C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B598 size=196
    let mut pc: u32 = 0x8259B598;
    'dispatch: loop {
        match pc {
            0x8259B598 => {
    //   block [0x8259B598..0x8259B65C)
	// 8259B598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B5A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B5A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B5A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B5AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B5B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259B5B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B5BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B5C0: 4BD25379  bl 0x822c0938
	ctx.lr = 0x8259B5C4;
	sub_822C0938(ctx, base);
	// 8259B5C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B5C8: 41820028  beq 0x8259b5f0
	if ctx.cr[0].eq {
	pc = 0x8259B5F0; continue 'dispatch;
	}
	// 8259B5CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259B5D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259B5D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259B5D8: 392BA7C0  addi r9, r11, -0x5840
	ctx.r[9].s64 = ctx.r[11].s64 + -22592;
	// 8259B5DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259B5E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259B5E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259B5E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259B5EC: 48000008  b 0x8259b5f4
	pc = 0x8259B5F4; continue 'dispatch;
	// 8259B5F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B5F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259B5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259B5FC: 409A0044  bne cr6, 0x8259b640
	if !ctx.cr[6].eq {
	pc = 0x8259B640; continue 'dispatch;
	}
	// 8259B600: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259B604: 419A001C  beq cr6, 0x8259b620
	if ctx.cr[6].eq {
	pc = 0x8259B620; continue 'dispatch;
	}
	// 8259B608: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B60C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259B614: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259B61C: 4E800421  bctrl
	ctx.lr = 0x8259B620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259B620: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259B624: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B62C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259B630: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259B634: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259B638: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259B63C: 4BD249C5  bl 0x822c0000
	ctx.lr = 0x8259B640;
	sub_822C0000(ctx, base);
	// 8259B640: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B64C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B650: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259B660 size=548
    let mut pc: u32 = 0x8259B660;
    'dispatch: loop {
        match pc {
            0x8259B660 => {
    //   block [0x8259B660..0x8259B884)
	// 8259B660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B668: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B66C: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259B674: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259B678: 4BD33001  bl 0x822ce678
	ctx.lr = 0x8259B67C;
	sub_822CE678(ctx, base);
	// 8259B67C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259B680: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259B684: 48B2DBE5  bl 0x830c9268
	ctx.lr = 0x8259B688;
	sub_830C9268(ctx, base);
	// 8259B688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259B68C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259B690: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8259B694: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259B698: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259B69C: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259B6A0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8259B6A4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8259B6A8: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8259B6AC: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8259B6B0: 48B2DB51  bl 0x830c9200
	ctx.lr = 0x8259B6B4;
	sub_830C9200(ctx, base);
	// 8259B6B4: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 8259B6B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8259B6BC: 4198011C  blt cr6, 0x8259b7d8
	if ctx.cr[6].lt {
	pc = 0x8259B7D8; continue 'dispatch;
	}
	// 8259B6C0: 419A00C0  beq cr6, 0x8259b780
	if ctx.cr[6].eq {
	pc = 0x8259B780; continue 'dispatch;
	}
	// 8259B6C4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8259B6C8: 41980060  blt cr6, 0x8259b728
	if ctx.cr[6].lt {
	pc = 0x8259B728; continue 'dispatch;
	}
	// 8259B6CC: 409A016C  bne cr6, 0x8259b838
	if !ctx.cr[6].eq {
	pc = 0x8259B838; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B888 size=108
    let mut pc: u32 = 0x8259B888;
    'dispatch: loop {
        match pc {
            0x8259B888 => {
    //   block [0x8259B888..0x8259B8F4)
	// 8259B888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259B894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B89C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8259B8A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259B8A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B8A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B8AC: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 8259B8B0: 48856349  bl 0x82df1bf8
	ctx.lr = 0x8259B8B4;
	sub_82DF1BF8(ctx, base);
	// 8259B8B4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259B8B8: 485AB989  bl 0x82b47240
	ctx.lr = 0x8259B8BC;
	sub_82B47240(ctx, base);
	// 8259B8BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259B8C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259B8C4: 488563CD  bl 0x82df1c90
	ctx.lr = 0x8259B8C8;
	sub_82DF1C90(ctx, base);
	// 8259B8C8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259B8CC: 7D6BF838  and r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[31].u64;
	// 8259B8D0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8259B8D4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8259B8D8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 8259B8DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B8E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B8E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B8E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259B8EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B8F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B8F8 size=96
    let mut pc: u32 = 0x8259B8F8;
    'dispatch: loop {
        match pc {
            0x8259B8F8 => {
    //   block [0x8259B8F8..0x8259B958)
	// 8259B8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259B900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259B904: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259B90C: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259B910: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8259B914: 419A0030  beq cr6, 0x8259b944
	if ctx.cr[6].eq {
	pc = 0x8259B944; continue 'dispatch;
	}
	// 8259B918: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259B91C: 481FE7CD  bl 0x8279a0e8
	ctx.lr = 0x8259B920;
	sub_8279A0E8(ctx, base);
	// 8259B920: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259B924: 481FE99D  bl 0x8279a2c0
	ctx.lr = 0x8259B928;
	sub_8279A2C0(ctx, base);
	// 8259B928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259B92C: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 8259B930: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 8259B934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259B938: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 8259B93C: 419A0008  beq cr6, 0x8259b944
	if ctx.cr[6].eq {
	pc = 0x8259B944; continue 'dispatch;
	}
	// 8259B940: 4BD24F51  bl 0x822c0890
	ctx.lr = 0x8259B944;
	sub_822C0890(ctx, base);
	// 8259B944: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259B948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259B94C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259B950: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259B954: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B958 size=120
    let mut pc: u32 = 0x8259B958;
    'dispatch: loop {
        match pc {
            0x8259B958 => {
    //   block [0x8259B958..0x8259B9D0)
	// 8259B958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B95C: 48C0C811  bl 0x831a816c
	ctx.lr = 0x8259B960;
	sub_831A8130(ctx, base);
	// 8259B960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B964: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259B968: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259B96C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259B970: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259B974: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259B978: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259B97C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259B980: 48856A69  bl 0x82df23e8
	ctx.lr = 0x8259B984;
	sub_82DF23E8(ctx, base);
	// 8259B984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259B988: 41820014  beq 0x8259b99c
	if ctx.cr[0].eq {
	pc = 0x8259B99C; continue 'dispatch;
	}
	// 8259B98C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259B990: 485BE011  bl 0x82b599a0
	ctx.lr = 0x8259B994;
	sub_82B599A0(ctx, base);
	// 8259B994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259B998: 48000008  b 0x8259b9a0
	pc = 0x8259B9A0; continue 'dispatch;
	// 8259B99C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259B9A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259B9A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259B9A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259B9AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B9B0: 4BFFF031  bl 0x8259a9e0
	ctx.lr = 0x8259B9B4;
	sub_8259A9E0(ctx, base);
	// 8259B9B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259B9B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259B9BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259B9C0: 4BD24641  bl 0x822c0000
	ctx.lr = 0x8259B9C4;
	sub_822C0000(ctx, base);
	// 8259B9C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259B9C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259B9CC: 48C0C7F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259B9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259B9D0 size=124
    let mut pc: u32 = 0x8259B9D0;
    'dispatch: loop {
        match pc {
            0x8259B9D0 => {
    //   block [0x8259B9D0..0x8259BA4C)
	// 8259B9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259B9D4: 48C0C799  bl 0x831a816c
	ctx.lr = 0x8259B9D8;
	sub_831A8130(ctx, base);
	// 8259B9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259B9DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259B9E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259B9E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259B9E8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259B9EC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8259B9F0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8259B9F4: 488569F5  bl 0x82df23e8
	ctx.lr = 0x8259B9F8;
	sub_82DF23E8(ctx, base);
	// 8259B9F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259B9FC: 4182001C  beq 0x8259ba18
	if ctx.cr[0].eq {
	pc = 0x8259BA18; continue 'dispatch;
	}
	// 8259BA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259BA04: 488BDC7D  bl 0x82e59680
	ctx.lr = 0x8259BA08;
	sub_82E59680(ctx, base);
	// 8259BA08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259BA0C: 396BA824  addi r11, r11, -0x57dc
	ctx.r[11].s64 = ctx.r[11].s64 + -22492;
	// 8259BA10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259BA14: 48000008  b 0x8259ba1c
	pc = 0x8259BA1C; continue 'dispatch;
	// 8259BA18: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BA1C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BA20: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BA24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BA28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BA2C: 4BFFF07D  bl 0x8259aaa8
	ctx.lr = 0x8259BA30;
	sub_8259AAA8(ctx, base);
	// 8259BA30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BA34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BA38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BA3C: 4BD245C5  bl 0x822c0000
	ctx.lr = 0x8259BA40;
	sub_822C0000(ctx, base);
	// 8259BA40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BA44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BA48: 48C0C774  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BA50 size=128
    let mut pc: u32 = 0x8259BA50;
    'dispatch: loop {
        match pc {
            0x8259BA50 => {
    //   block [0x8259BA50..0x8259BAD0)
	// 8259BA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BA54: 48C0C719  bl 0x831a816c
	ctx.lr = 0x8259BA58;
	sub_831A8130(ctx, base);
	// 8259BA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BA5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BA60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BA64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BA68: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259BA6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BA70: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BA74: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BA78: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8259BA7C: 4885696D  bl 0x82df23e8
	ctx.lr = 0x8259BA80;
	sub_82DF23E8(ctx, base);
	// 8259BA80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BA84: 41820018  beq 0x8259ba9c
	if ctx.cr[0].eq {
	pc = 0x8259BA9C; continue 'dispatch;
	}
	// 8259BA88: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BA8C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BA90: 485BE3F9  bl 0x82b59e88
	ctx.lr = 0x8259BA94;
	sub_82B59E88(ctx, base);
	// 8259BA94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BA98: 48000008  b 0x8259baa0
	pc = 0x8259BAA0; continue 'dispatch;
	// 8259BA9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BAA0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BAA4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BAA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BAAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BAB0: 4BFFF0C1  bl 0x8259ab70
	ctx.lr = 0x8259BAB4;
	sub_8259AB70(ctx, base);
	// 8259BAB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BAB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BAC0: 4BD24541  bl 0x822c0000
	ctx.lr = 0x8259BAC4;
	sub_822C0000(ctx, base);
	// 8259BAC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BAC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BACC: 48C0C6F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BAD0 size=112
    let mut pc: u32 = 0x8259BAD0;
    'dispatch: loop {
        match pc {
            0x8259BAD0 => {
    //   block [0x8259BAD0..0x8259BB40)
	// 8259BAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259BAD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259BADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259BAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BAE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259BAE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BAEC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259BAF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259BAF4: 4BFFF145  bl 0x8259ac38
	ctx.lr = 0x8259BAF8;
	sub_8259AC38(ctx, base);
	// 8259BAF8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259BAFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259BB00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259BB04: 4BD244FD  bl 0x822c0000
	ctx.lr = 0x8259BB08;
	sub_822C0000(ctx, base);
	// 8259BB08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259BB0C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259BB10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259BB14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259BB18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259BB1C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259BB20: 419A0008  beq cr6, 0x8259bb28
	if ctx.cr[6].eq {
	pc = 0x8259BB28; continue 'dispatch;
	}
	// 8259BB24: 4BD24D6D  bl 0x822c0890
	ctx.lr = 0x8259BB28;
	sub_822C0890(ctx, base);
	// 8259BB28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BB2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259BB30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259BB34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259BB38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259BB3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BB40 size=124
    let mut pc: u32 = 0x8259BB40;
    'dispatch: loop {
        match pc {
            0x8259BB40 => {
    //   block [0x8259BB40..0x8259BBBC)
	// 8259BB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BB44: 48C0C629  bl 0x831a816c
	ctx.lr = 0x8259BB48;
	sub_831A8130(ctx, base);
	// 8259BB48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BB4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BB50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BB54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BB58: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BB5C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8259BB60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8259BB64: 48856885  bl 0x82df23e8
	ctx.lr = 0x8259BB68;
	sub_82DF23E8(ctx, base);
	// 8259BB68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259BB6C: 4182001C  beq 0x8259bb88
	if ctx.cr[0].eq {
	pc = 0x8259BB88; continue 'dispatch;
	}
	// 8259BB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259BB74: 488BDB0D  bl 0x82e59680
	ctx.lr = 0x8259BB78;
	sub_82E59680(ctx, base);
	// 8259BB78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259BB7C: 396BA82C  addi r11, r11, -0x57d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22484;
	// 8259BB80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259BB84: 48000008  b 0x8259bb8c
	pc = 0x8259BB8C; continue 'dispatch;
	// 8259BB88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BB8C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BB90: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BB94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BB98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BB9C: 4BFFF165  bl 0x8259ad00
	ctx.lr = 0x8259BBA0;
	sub_8259AD00(ctx, base);
	// 8259BBA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BBA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BBA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BBAC: 4BD24455  bl 0x822c0000
	ctx.lr = 0x8259BBB0;
	sub_822C0000(ctx, base);
	// 8259BBB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BBB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BBB8: 48C0C604  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BBC0 size=124
    let mut pc: u32 = 0x8259BBC0;
    'dispatch: loop {
        match pc {
            0x8259BBC0 => {
    //   block [0x8259BBC0..0x8259BC3C)
	// 8259BBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BBC4: 48C0C5A9  bl 0x831a816c
	ctx.lr = 0x8259BBC8;
	sub_831A8130(ctx, base);
	// 8259BBC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BBCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BBD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BBD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BBD8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BBDC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8259BBE0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8259BBE4: 48856805  bl 0x82df23e8
	ctx.lr = 0x8259BBE8;
	sub_82DF23E8(ctx, base);
	// 8259BBE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259BBEC: 4182001C  beq 0x8259bc08
	if ctx.cr[0].eq {
	pc = 0x8259BC08; continue 'dispatch;
	}
	// 8259BBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259BBF4: 488BDA8D  bl 0x82e59680
	ctx.lr = 0x8259BBF8;
	sub_82E59680(ctx, base);
	// 8259BBF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259BBFC: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 8259BC00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259BC04: 48000008  b 0x8259bc0c
	pc = 0x8259BC0C; continue 'dispatch;
	// 8259BC08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BC0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BC10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BC14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BC1C: 4BFFF1AD  bl 0x8259adc8
	ctx.lr = 0x8259BC20;
	sub_8259ADC8(ctx, base);
	// 8259BC20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BC24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BC28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BC2C: 4BD243D5  bl 0x822c0000
	ctx.lr = 0x8259BC30;
	sub_822C0000(ctx, base);
	// 8259BC30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BC34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BC38: 48C0C584  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BC40 size=112
    let mut pc: u32 = 0x8259BC40;
    'dispatch: loop {
        match pc {
            0x8259BC40 => {
    //   block [0x8259BC40..0x8259BCB0)
	// 8259BC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259BC48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259BC4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259BC50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BC54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259BC58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BC5C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259BC60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259BC64: 4BFFECB5  bl 0x8259a918
	ctx.lr = 0x8259BC68;
	sub_8259A918(ctx, base);
	// 8259BC68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259BC6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259BC70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259BC74: 4BD2438D  bl 0x822c0000
	ctx.lr = 0x8259BC78;
	sub_822C0000(ctx, base);
	// 8259BC78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259BC7C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259BC80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259BC84: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259BC88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259BC8C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259BC90: 419A0008  beq cr6, 0x8259bc98
	if ctx.cr[6].eq {
	pc = 0x8259BC98; continue 'dispatch;
	}
	// 8259BC94: 4BD24BFD  bl 0x822c0890
	ctx.lr = 0x8259BC98;
	sub_822C0890(ctx, base);
	// 8259BC98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BC9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259BCA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259BCA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259BCA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259BCAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BCB0 size=120
    let mut pc: u32 = 0x8259BCB0;
    'dispatch: loop {
        match pc {
            0x8259BCB0 => {
    //   block [0x8259BCB0..0x8259BD28)
	// 8259BCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BCB4: 48C0C4B9  bl 0x831a816c
	ctx.lr = 0x8259BCB8;
	sub_831A8130(ctx, base);
	// 8259BCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BCBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BCC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BCC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BCC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BCCC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BCD0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BCD4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8259BCD8: 48856711  bl 0x82df23e8
	ctx.lr = 0x8259BCDC;
	sub_82DF23E8(ctx, base);
	// 8259BCDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BCE0: 41820014  beq 0x8259bcf4
	if ctx.cr[0].eq {
	pc = 0x8259BCF4; continue 'dispatch;
	}
	// 8259BCE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BCE8: 485BE3A1  bl 0x82b5a088
	ctx.lr = 0x8259BCEC;
	sub_82B5A088(ctx, base);
	// 8259BCEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BCF0: 48000008  b 0x8259bcf8
	pc = 0x8259BCF8; continue 'dispatch;
	// 8259BCF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BCF8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BCFC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BD00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BD04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BD08: 4BFFF189  bl 0x8259ae90
	ctx.lr = 0x8259BD0C;
	sub_8259AE90(ctx, base);
	// 8259BD0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BD10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BD14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BD18: 4BD242E9  bl 0x822c0000
	ctx.lr = 0x8259BD1C;
	sub_822C0000(ctx, base);
	// 8259BD1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BD20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BD24: 48C0C498  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BD28 size=128
    let mut pc: u32 = 0x8259BD28;
    'dispatch: loop {
        match pc {
            0x8259BD28 => {
    //   block [0x8259BD28..0x8259BDA8)
	// 8259BD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BD2C: 48C0C441  bl 0x831a816c
	ctx.lr = 0x8259BD30;
	sub_831A8130(ctx, base);
	// 8259BD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BD34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BD38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BD3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BD40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259BD44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BD48: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BD4C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BD50: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8259BD54: 48856695  bl 0x82df23e8
	ctx.lr = 0x8259BD58;
	sub_82DF23E8(ctx, base);
	// 8259BD58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BD5C: 41820018  beq 0x8259bd74
	if ctx.cr[0].eq {
	pc = 0x8259BD74; continue 'dispatch;
	}
	// 8259BD60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BD64: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BD68: 485BE161  bl 0x82b59ec8
	ctx.lr = 0x8259BD6C;
	sub_82B59EC8(ctx, base);
	// 8259BD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BD70: 48000008  b 0x8259bd78
	pc = 0x8259BD78; continue 'dispatch;
	// 8259BD74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BD78: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BD7C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BD80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BD84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BD88: 4BFFF1D1  bl 0x8259af58
	ctx.lr = 0x8259BD8C;
	sub_8259AF58(ctx, base);
	// 8259BD8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BD90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BD94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BD98: 4BD24269  bl 0x822c0000
	ctx.lr = 0x8259BD9C;
	sub_822C0000(ctx, base);
	// 8259BD9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BDA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BDA4: 48C0C418  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BDA8 size=120
    let mut pc: u32 = 0x8259BDA8;
    'dispatch: loop {
        match pc {
            0x8259BDA8 => {
    //   block [0x8259BDA8..0x8259BE20)
	// 8259BDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BDAC: 48C0C3C1  bl 0x831a816c
	ctx.lr = 0x8259BDB0;
	sub_831A8130(ctx, base);
	// 8259BDB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BDB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BDB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BDBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BDC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BDC4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BDC8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BDCC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259BDD0: 48856619  bl 0x82df23e8
	ctx.lr = 0x8259BDD4;
	sub_82DF23E8(ctx, base);
	// 8259BDD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BDD8: 41820014  beq 0x8259bdec
	if ctx.cr[0].eq {
	pc = 0x8259BDEC; continue 'dispatch;
	}
	// 8259BDDC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BDE0: 485BDC11  bl 0x82b599f0
	ctx.lr = 0x8259BDE4;
	sub_82B599F0(ctx, base);
	// 8259BDE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BDE8: 48000008  b 0x8259bdf0
	pc = 0x8259BDF0; continue 'dispatch;
	// 8259BDEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BDF0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BDF4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BDF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BDFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BE00: 4BFFF221  bl 0x8259b020
	ctx.lr = 0x8259BE04;
	sub_8259B020(ctx, base);
	// 8259BE04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BE08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BE0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BE10: 4BD241F1  bl 0x822c0000
	ctx.lr = 0x8259BE14;
	sub_822C0000(ctx, base);
	// 8259BE14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BE18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BE1C: 48C0C3A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BE20 size=124
    let mut pc: u32 = 0x8259BE20;
    'dispatch: loop {
        match pc {
            0x8259BE20 => {
    //   block [0x8259BE20..0x8259BE9C)
	// 8259BE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BE24: 48C0C349  bl 0x831a816c
	ctx.lr = 0x8259BE28;
	sub_831A8130(ctx, base);
	// 8259BE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BE2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BE30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BE34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BE38: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BE3C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8259BE40: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8259BE44: 488565A5  bl 0x82df23e8
	ctx.lr = 0x8259BE48;
	sub_82DF23E8(ctx, base);
	// 8259BE48: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259BE4C: 4182001C  beq 0x8259be68
	if ctx.cr[0].eq {
	pc = 0x8259BE68; continue 'dispatch;
	}
	// 8259BE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259BE54: 488BD82D  bl 0x82e59680
	ctx.lr = 0x8259BE58;
	sub_82E59680(ctx, base);
	// 8259BE58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259BE5C: 396BA83C  addi r11, r11, -0x57c4
	ctx.r[11].s64 = ctx.r[11].s64 + -22468;
	// 8259BE60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259BE64: 48000008  b 0x8259be6c
	pc = 0x8259BE6C; continue 'dispatch;
	// 8259BE68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BE6C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BE70: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BE74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BE78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BE7C: 4BFFF26D  bl 0x8259b0e8
	ctx.lr = 0x8259BE80;
	sub_8259B0E8(ctx, base);
	// 8259BE80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BE84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BE88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BE8C: 4BD24175  bl 0x822c0000
	ctx.lr = 0x8259BE90;
	sub_822C0000(ctx, base);
	// 8259BE90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BE94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BE98: 48C0C324  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BEA0 size=120
    let mut pc: u32 = 0x8259BEA0;
    'dispatch: loop {
        match pc {
            0x8259BEA0 => {
    //   block [0x8259BEA0..0x8259BF18)
	// 8259BEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BEA4: 48C0C2C9  bl 0x831a816c
	ctx.lr = 0x8259BEA8;
	sub_831A8130(ctx, base);
	// 8259BEA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BEAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BEB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BEB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BEB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BEBC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BEC0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BEC4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259BEC8: 48856521  bl 0x82df23e8
	ctx.lr = 0x8259BECC;
	sub_82DF23E8(ctx, base);
	// 8259BECC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BED0: 41820014  beq 0x8259bee4
	if ctx.cr[0].eq {
	pc = 0x8259BEE4; continue 'dispatch;
	}
	// 8259BED4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BED8: 485BDA29  bl 0x82b59900
	ctx.lr = 0x8259BEDC;
	sub_82B59900(ctx, base);
	// 8259BEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BEE0: 48000008  b 0x8259bee8
	pc = 0x8259BEE8; continue 'dispatch;
	// 8259BEE4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BEE8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BEEC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BEF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BEF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BEF8: 4BFFF2B9  bl 0x8259b1b0
	ctx.lr = 0x8259BEFC;
	sub_8259B1B0(ctx, base);
	// 8259BEFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BF00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BF04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BF08: 4BD240F9  bl 0x822c0000
	ctx.lr = 0x8259BF0C;
	sub_822C0000(ctx, base);
	// 8259BF0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BF10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BF14: 48C0C2A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BF18 size=120
    let mut pc: u32 = 0x8259BF18;
    'dispatch: loop {
        match pc {
            0x8259BF18 => {
    //   block [0x8259BF18..0x8259BF90)
	// 8259BF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BF1C: 48C0C251  bl 0x831a816c
	ctx.lr = 0x8259BF20;
	sub_831A8130(ctx, base);
	// 8259BF20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BF24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BF28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BF2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BF30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BF34: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BF38: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BF3C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259BF40: 488564A9  bl 0x82df23e8
	ctx.lr = 0x8259BF44;
	sub_82DF23E8(ctx, base);
	// 8259BF44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BF48: 41820014  beq 0x8259bf5c
	if ctx.cr[0].eq {
	pc = 0x8259BF5C; continue 'dispatch;
	}
	// 8259BF4C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BF50: 485BDA01  bl 0x82b59950
	ctx.lr = 0x8259BF54;
	sub_82B59950(ctx, base);
	// 8259BF54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BF58: 48000008  b 0x8259bf60
	pc = 0x8259BF60; continue 'dispatch;
	// 8259BF5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BF60: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BF64: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BF68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BF70: 4BFFF309  bl 0x8259b278
	ctx.lr = 0x8259BF74;
	sub_8259B278(ctx, base);
	// 8259BF74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BF78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BF7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BF80: 4BD24081  bl 0x822c0000
	ctx.lr = 0x8259BF84;
	sub_822C0000(ctx, base);
	// 8259BF84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259BF88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259BF8C: 48C0C230  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259BF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259BF90 size=128
    let mut pc: u32 = 0x8259BF90;
    'dispatch: loop {
        match pc {
            0x8259BF90 => {
    //   block [0x8259BF90..0x8259C010)
	// 8259BF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259BF94: 48C0C1D9  bl 0x831a816c
	ctx.lr = 0x8259BF98;
	sub_831A8130(ctx, base);
	// 8259BF98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259BF9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259BFA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259BFA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259BFA8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259BFAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259BFB0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259BFB4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259BFB8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8259BFBC: 4885642D  bl 0x82df23e8
	ctx.lr = 0x8259BFC0;
	sub_82DF23E8(ctx, base);
	// 8259BFC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259BFC4: 41820018  beq 0x8259bfdc
	if ctx.cr[0].eq {
	pc = 0x8259BFDC; continue 'dispatch;
	}
	// 8259BFC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BFCC: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259BFD0: 485B8621  bl 0x82b545f0
	ctx.lr = 0x8259BFD4;
	sub_82B545F0(ctx, base);
	// 8259BFD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259BFD8: 48000008  b 0x8259bfe0
	pc = 0x8259BFE0; continue 'dispatch;
	// 8259BFDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259BFE0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259BFE4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259BFE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BFEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259BFF0: 4BFFF351  bl 0x8259b340
	ctx.lr = 0x8259BFF4;
	sub_8259B340(ctx, base);
	// 8259BFF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259BFF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259BFFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C000: 4BD24001  bl 0x822c0000
	ctx.lr = 0x8259C004;
	sub_822C0000(ctx, base);
	// 8259C004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259C008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259C00C: 48C0C1B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259C010 size=120
    let mut pc: u32 = 0x8259C010;
    'dispatch: loop {
        match pc {
            0x8259C010 => {
    //   block [0x8259C010..0x8259C088)
	// 8259C010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C014: 48C0C159  bl 0x831a816c
	ctx.lr = 0x8259C018;
	sub_831A8130(ctx, base);
	// 8259C018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C01C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259C020: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259C024: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259C028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259C02C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259C030: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259C034: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259C038: 488563B1  bl 0x82df23e8
	ctx.lr = 0x8259C03C;
	sub_82DF23E8(ctx, base);
	// 8259C03C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259C040: 41820014  beq 0x8259c054
	if ctx.cr[0].eq {
	pc = 0x8259C054; continue 'dispatch;
	}
	// 8259C044: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C048: 485BDAD1  bl 0x82b59b18
	ctx.lr = 0x8259C04C;
	sub_82B59B18(ctx, base);
	// 8259C04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259C050: 48000008  b 0x8259c058
	pc = 0x8259C058; continue 'dispatch;
	// 8259C054: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259C058: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259C05C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259C060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C068: 4BFFF3A1  bl 0x8259b408
	ctx.lr = 0x8259C06C;
	sub_8259B408(ctx, base);
	// 8259C06C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259C070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C078: 4BD23F89  bl 0x822c0000
	ctx.lr = 0x8259C07C;
	sub_822C0000(ctx, base);
	// 8259C07C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259C080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259C084: 48C0C138  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259C088 size=120
    let mut pc: u32 = 0x8259C088;
    'dispatch: loop {
        match pc {
            0x8259C088 => {
    //   block [0x8259C088..0x8259C100)
	// 8259C088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C08C: 48C0C0E1  bl 0x831a816c
	ctx.lr = 0x8259C090;
	sub_831A8130(ctx, base);
	// 8259C090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C094: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259C098: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259C09C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259C0A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259C0A4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259C0A8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259C0AC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259C0B0: 48856339  bl 0x82df23e8
	ctx.lr = 0x8259C0B4;
	sub_82DF23E8(ctx, base);
	// 8259C0B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259C0B8: 41820014  beq 0x8259c0cc
	if ctx.cr[0].eq {
	pc = 0x8259C0CC; continue 'dispatch;
	}
	// 8259C0BC: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259C0C0: 485BDAA9  bl 0x82b59b68
	ctx.lr = 0x8259C0C4;
	sub_82B59B68(ctx, base);
	// 8259C0C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259C0C8: 48000008  b 0x8259c0d0
	pc = 0x8259C0D0; continue 'dispatch;
	// 8259C0CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259C0D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259C0D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259C0D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C0DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C0E0: 4BFFF3F1  bl 0x8259b4d0
	ctx.lr = 0x8259C0E4;
	sub_8259B4D0(ctx, base);
	// 8259C0E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259C0E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C0EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C0F0: 4BD23F11  bl 0x822c0000
	ctx.lr = 0x8259C0F4;
	sub_822C0000(ctx, base);
	// 8259C0F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259C0F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259C0FC: 48C0C0C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259C100 size=120
    let mut pc: u32 = 0x8259C100;
    'dispatch: loop {
        match pc {
            0x8259C100 => {
    //   block [0x8259C100..0x8259C178)
	// 8259C100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C104: 48C0C069  bl 0x831a816c
	ctx.lr = 0x8259C108;
	sub_831A8130(ctx, base);
	// 8259C108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C10C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259C110: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259C114: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259C118: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259C11C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8259C120: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8259C124: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8259C128: 488562C1  bl 0x82df23e8
	ctx.lr = 0x8259C12C;
	sub_82DF23E8(ctx, base);
	// 8259C12C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259C130: 41820014  beq 0x8259c144
	if ctx.cr[0].eq {
	pc = 0x8259C144; continue 'dispatch;
	}
	// 8259C134: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259C138: 485BD991  bl 0x82b59ac8
	ctx.lr = 0x8259C13C;
	sub_82B59AC8(ctx, base);
	// 8259C13C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259C140: 48000008  b 0x8259c148
	pc = 0x8259C148; continue 'dispatch;
	// 8259C144: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259C148: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8259C14C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8259C150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C158: 4BFFF441  bl 0x8259b598
	ctx.lr = 0x8259C15C;
	sub_8259B598(ctx, base);
	// 8259C15C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259C160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C168: 4BD23E99  bl 0x822c0000
	ctx.lr = 0x8259C16C;
	sub_822C0000(ctx, base);
	// 8259C16C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259C170: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259C174: 48C0C048  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259C178 size=788
    let mut pc: u32 = 0x8259C178;
    'dispatch: loop {
        match pc {
            0x8259C178 => {
    //   block [0x8259C178..0x8259C48C)
	// 8259C178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C17C: 48C0BFE1  bl 0x831a815c
	ctx.lr = 0x8259C180;
	sub_831A8130(ctx, base);
	// 8259C180: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8259C184: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C188: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259C18C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259C190: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259C194: 4BF73335  bl 0x8250f4c8
	ctx.lr = 0x8259C198;
	sub_8250F4C8(ctx, base);
	// 8259C198: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C1A0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8259C1A4: 409A0008  bne cr6, 0x8259c1ac
	if !ctx.cr[6].eq {
	pc = 0x8259C1AC; continue 'dispatch;
	}
	// 8259C1A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259C1AC: 4BF6C8AD  bl 0x82508a58
	ctx.lr = 0x8259C1B0;
	sub_82508A58(ctx, base);
	// 8259C1B0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8259C1B4: 7D7A1810  subfc r11, r26, r3
	ctx.xer.ca = ctx.r[3].u32 >= ctx.r[26].u32;
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[26].s64;
	// 8259C1B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259C1BC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8259C1C0: 557F07FE  clrlwi r31, r11, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8259C1C4: 48855ACD  bl 0x82df1c90
	ctx.lr = 0x8259C1C8;
	sub_82DF1C90(ctx, base);
	// 8259C1C8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259C1CC: 408202B4  bne 0x8259c480
	if !ctx.cr[0].eq {
	pc = 0x8259C480; continue 'dispatch;
	}
	// 8259C1D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259C1D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259C1D8: 4BF732F1  bl 0x8250f4c8
	ctx.lr = 0x8259C1DC;
	sub_8250F4C8(ctx, base);
	// 8259C1DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C1E4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8259C1E8: 409A0008  bne cr6, 0x8259c1f0
	if !ctx.cr[6].eq {
	pc = 0x8259C1F0; continue 'dispatch;
	}
	// 8259C1EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259C1F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259C1F4: 4BF6C825  bl 0x82508a18
	ctx.lr = 0x8259C1F8;
	sub_82508A18(ctx, base);
	// 8259C1F8: 907C0134  stw r3, 0x134(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(308 as u32), ctx.r[3].u32 ) };
	// 8259C1FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259C200: 48855A91  bl 0x82df1c90
	ctx.lr = 0x8259C204;
	sub_82DF1C90(ctx, base);
	// 8259C204: 3B7C0140  addi r27, r28, 0x140
	ctx.r[27].s64 = ctx.r[28].s64 + 320;
	// 8259C208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259C20C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8259C210: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8259C214: 4BD80FBD  bl 0x8231d1d0
	ctx.lr = 0x8259C218;
	sub_8231D1D0(ctx, base);
	// 8259C218: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C21C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8259C220: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C228: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8259C22C: 419A0024  beq cr6, 0x8259c250
	if ctx.cr[6].eq {
	pc = 0x8259C250; continue 'dispatch;
	}
	// 8259C230: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C234: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C238: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C23C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C240: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C244: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C248: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C24C: 4082FFE8  bne 0x8259c234
	if !ctx.cr[0].eq {
	pc = 0x8259C234; continue 'dispatch;
	}
	// 8259C250: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259C254: 80DC0134  lwz r6, 0x134(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(308 as u32) ) } as u64;
	// 8259C258: 3BBC0028  addi r29, r28, 0x28
	ctx.r[29].s64 = ctx.r[28].s64 + 40;
	// 8259C25C: 3BCBA8A0  addi r30, r11, -0x5760
	ctx.r[30].s64 = ctx.r[11].s64 + -22368;
	// 8259C260: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8259C264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259C268: 38A000F8  li r5, 0xf8
	ctx.r[5].s64 = 248;
	// 8259C26C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259C270: 488BAD79  bl 0x82e56fe8
	ctx.lr = 0x8259C274;
	sub_82E56FE8(ctx, base);
	// 8259C274: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259C278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C27C: 419A0008  beq cr6, 0x8259c284
	if ctx.cr[6].eq {
	pc = 0x8259C284; continue 'dispatch;
	}
	// 8259C280: 4BD24611  bl 0x822c0890
	ctx.lr = 0x8259C284;
	sub_822C0890(ctx, base);
	// 8259C284: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259C288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C28C: 419A0008  beq cr6, 0x8259c294
	if ctx.cr[6].eq {
	pc = 0x8259C294; continue 'dispatch;
	}
	// 8259C290: 4BD24601  bl 0x822c0890
	ctx.lr = 0x8259C294;
	sub_822C0890(ctx, base);
	// 8259C294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259C298: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259C29C: 38A000FB  li r5, 0xfb
	ctx.r[5].s64 = 251;
	// 8259C2A0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8259C2A4: 48856145  bl 0x82df23e8
	ctx.lr = 0x8259C2A8;
	sub_82DF23E8(ctx, base);
	// 8259C2A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259C2AC: 41820010  beq 0x8259c2bc
	if ctx.cr[0].eq {
	pc = 0x8259C2BC; continue 'dispatch;
	}
	// 8259C2B0: 480038E1  bl 0x8259fb90
	ctx.lr = 0x8259C2B4;
	sub_8259FB90(ctx, base);
	// 8259C2B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259C2B8: 48000008  b 0x8259c2c0
	pc = 0x8259C2C0; continue 'dispatch;
	// 8259C2BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259C2C0: 3BFC012C  addi r31, r28, 0x12c
	ctx.r[31].s64 = ctx.r[28].s64 + 300;
	// 8259C2C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C2C8: 4BFFF809  bl 0x8259bad0
	ctx.lr = 0x8259C2CC;
	sub_8259BAD0(ctx, base);
	// 8259C2CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259C2D0: 39400BBA  li r10, 0xbba
	ctx.r[10].s64 = 3002;
	// 8259C2D4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8259C2D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259C2DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8259C2E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C2E4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259C2E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8259C2EC: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8259C2F0: 485D0189  bl 0x82b6c478
	ctx.lr = 0x8259C2F4;
	sub_82B6C478(ctx, base);
	// 8259C2F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C2F8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8259C2FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C304: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8259C308: 419A0024  beq cr6, 0x8259c32c
	if ctx.cr[6].eq {
	pc = 0x8259C32C; continue 'dispatch;
	}
	// 8259C30C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C318: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C31C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C320: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C328: 4082FFE8  bne 0x8259c310
	if !ctx.cr[0].eq {
	pc = 0x8259C310; continue 'dispatch;
	}
	// 8259C32C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259C330: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259C334: 4BF731E5  bl 0x8250f518
	ctx.lr = 0x8259C338;
	sub_8250F518(ctx, base);
	// 8259C338: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C340: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 8259C344: 409A0008  bne cr6, 0x8259c34c
	if !ctx.cr[6].eq {
	pc = 0x8259C34C; continue 'dispatch;
	}
	// 8259C348: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259C34C: 3B210068  addi r25, r1, 0x68
	ctx.r[25].s64 = ctx.r[1].s64 + 104;
	// 8259C350: 4BF8BD01  bl 0x82528050
	ctx.lr = 0x8259C354;
	sub_82528050(ctx, base);
	// 8259C354: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259C358: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259C35C: 38A000FC  li r5, 0xfc
	ctx.r[5].s64 = 252;
	// 8259C360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259C364: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 8259C368: 488BAC81  bl 0x82e56fe8
	ctx.lr = 0x8259C36C;
	sub_82E56FE8(ctx, base);
	// 8259C36C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259C370: 48855921  bl 0x82df1c90
	ctx.lr = 0x8259C374;
	sub_82DF1C90(ctx, base);
	// 8259C374: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8259C378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C37C: 419A0008  beq cr6, 0x8259c384
	if ctx.cr[6].eq {
	pc = 0x8259C384; continue 'dispatch;
	}
	// 8259C380: 4BD24511  bl 0x822c0890
	ctx.lr = 0x8259C384;
	sub_822C0890(ctx, base);
	// 8259C384: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8259C388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C38C: 419A0008  beq cr6, 0x8259c394
	if ctx.cr[6].eq {
	pc = 0x8259C394; continue 'dispatch;
	}
	// 8259C390: 4BD24501  bl 0x822c0890
	ctx.lr = 0x8259C394;
	sub_822C0890(ctx, base);
	// 8259C394: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8259C398: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C39C: 48016775  bl 0x825b2b10
	ctx.lr = 0x8259C3A0;
	sub_825B2B10(ctx, base);
	// 8259C3A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259C3A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259C3A8: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 8259C3AC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8259C3B0: 48856039  bl 0x82df23e8
	ctx.lr = 0x8259C3B4;
	sub_82DF23E8(ctx, base);
	// 8259C3B4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259C3B8: 4182001C  beq 0x8259c3d4
	if ctx.cr[0].eq {
	pc = 0x8259C3D4; continue 'dispatch;
	}
	// 8259C3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C3C0: 488C0569  bl 0x82e5c928
	ctx.lr = 0x8259C3C4;
	sub_82E5C928(ctx, base);
	// 8259C3C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259C3C8: 396BA844  addi r11, r11, -0x57bc
	ctx.r[11].s64 = ctx.r[11].s64 + -22460;
	// 8259C3CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259C3D0: 48000008  b 0x8259c3d8
	pc = 0x8259C3D8; continue 'dispatch;
	// 8259C3D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259C3D8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8259C3DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C3E0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8259C3E4: 4BFFE2DD  bl 0x8259a6c0
	ctx.lr = 0x8259C3E8;
	sub_8259A6C0(ctx, base);
	// 8259C3E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259C3EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C3F0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8259C3F4: 4BD23C0D  bl 0x822c0000
	ctx.lr = 0x8259C3F8;
	sub_822C0000(ctx, base);
	// 8259C3F8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259C3FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259C400: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259C404: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 8259C408: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8259C40C: 419A0024  beq cr6, 0x8259c430
	if ctx.cr[6].eq {
	pc = 0x8259C430; continue 'dispatch;
	}
	// 8259C410: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8259C414: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C418: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C41C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C420: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C424: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C428: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C42C: 4082FFE8  bne 0x8259c414
	if !ctx.cr[0].eq {
	pc = 0x8259C414; continue 'dispatch;
	}
	// 8259C430: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8259C434: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259C438: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259C43C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8259C440: 389C00CC  addi r4, r28, 0xcc
	ctx.r[4].s64 = ctx.r[28].s64 + 204;
	// 8259C444: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259C448: 488C2261  bl 0x82e5e6a8
	ctx.lr = 0x8259C44C;
	sub_82E5E6A8(ctx, base);
	// 8259C44C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8259C450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C454: 419A0008  beq cr6, 0x8259c45c
	if ctx.cr[6].eq {
	pc = 0x8259C45C; continue 'dispatch;
	}
	// 8259C458: 4BD24439  bl 0x822c0890
	ctx.lr = 0x8259C45C;
	sub_822C0890(ctx, base);
	// 8259C45C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259C460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C464: 419A0008  beq cr6, 0x8259c46c
	if ctx.cr[6].eq {
	pc = 0x8259C46C; continue 'dispatch;
	}
	// 8259C468: 4BD24429  bl 0x822c0890
	ctx.lr = 0x8259C46C;
	sub_822C0890(ctx, base);
	// 8259C46C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259C470: 419A000C  beq cr6, 0x8259c47c
	if ctx.cr[6].eq {
	pc = 0x8259C47C; continue 'dispatch;
	}
	// 8259C474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C478: 4BD24419  bl 0x822c0890
	ctx.lr = 0x8259C47C;
	sub_822C0890(ctx, base);
	// 8259C47C: 9B5C0198  stb r26, 0x198(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(408 as u32), ctx.r[26].u8 ) };
	// 8259C480: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8259C484: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8259C488: 48C0BD24  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259C490 size=712
    let mut pc: u32 = 0x8259C490;
    'dispatch: loop {
        match pc {
            0x8259C490 => {
    //   block [0x8259C490..0x8259C758)
	// 8259C490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C494: 48C0BCD5  bl 0x831a8168
	ctx.lr = 0x8259C498;
	sub_831A8130(ctx, base);
	// 8259C498: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8259C49C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C4A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259C4A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259C4A8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8259C4AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8259C4B0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8259C4B4: 815F012C  lwz r10, 0x12c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259C4B8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259C4BC: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8259C4C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259C4C4: 482AA14D  bl 0x82846610
	ctx.lr = 0x8259C4C8;
	sub_82846610(ctx, base);
	// 8259C4C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C4CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8259C4D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C4D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C4D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8259C4DC: 419A0024  beq cr6, 0x8259c500
	if ctx.cr[6].eq {
	pc = 0x8259C500; continue 'dispatch;
	}
	// 8259C4E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C4E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C4E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C4EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C4F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C4F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C4F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C4FC: 4082FFE8  bne 0x8259c4e4
	if !ctx.cr[0].eq {
	pc = 0x8259C4E4; continue 'dispatch;
	}
	// 8259C500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C504: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259C508: 4BF73011  bl 0x8250f518
	ctx.lr = 0x8259C50C;
	sub_8250F518(ctx, base);
	// 8259C50C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C514: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 8259C518: 409A0008  bne cr6, 0x8259c520
	if !ctx.cr[6].eq {
	pc = 0x8259C520; continue 'dispatch;
	}
	// 8259C51C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259C520: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 8259C524: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 8259C528: 4BF8BB29  bl 0x82528050
	ctx.lr = 0x8259C52C;
	sub_82528050(ctx, base);
	// 8259C52C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259C530: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259C534: 3BABA8A0  addi r29, r11, -0x5760
	ctx.r[29].s64 = ctx.r[11].s64 + -22368;
	// 8259C538: 38A00112  li r5, 0x112
	ctx.r[5].s64 = 274;
	// 8259C53C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C544: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8259C548: 488BAAA1  bl 0x82e56fe8
	ctx.lr = 0x8259C54C;
	sub_82E56FE8(ctx, base);
	// 8259C54C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259C550: 48855741  bl 0x82df1c90
	ctx.lr = 0x8259C554;
	sub_82DF1C90(ctx, base);
	// 8259C554: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259C558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C55C: 419A0008  beq cr6, 0x8259c564
	if ctx.cr[6].eq {
	pc = 0x8259C564; continue 'dispatch;
	}
	// 8259C560: 4BD24331  bl 0x822c0890
	ctx.lr = 0x8259C564;
	sub_822C0890(ctx, base);
	// 8259C564: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259C568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C56C: 419A0008  beq cr6, 0x8259c574
	if ctx.cr[6].eq {
	pc = 0x8259C574; continue 'dispatch;
	}
	// 8259C570: 4BD24321  bl 0x822c0890
	ctx.lr = 0x8259C574;
	sub_822C0890(ctx, base);
	// 8259C574: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259C578: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8259C57C: 419A0008  beq cr6, 0x8259c584
	if ctx.cr[6].eq {
	pc = 0x8259C584; continue 'dispatch;
	}
	// 8259C580: 481FD279  bl 0x827997f8
	ctx.lr = 0x8259C584;
	sub_827997F8(ctx, base);
	// 8259C584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C588: 4BFFF371  bl 0x8259b8f8
	ctx.lr = 0x8259C58C;
	sub_8259B8F8(ctx, base);
	// 8259C58C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259C590: 4BFFF5B1  bl 0x8259bb40
	ctx.lr = 0x8259C594;
	sub_8259BB40(ctx, base);
	// 8259C594: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C598: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8259C59C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C5A4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8259C5A8: 419A0024  beq cr6, 0x8259c5cc
	if ctx.cr[6].eq {
	pc = 0x8259C5CC; continue 'dispatch;
	}
	// 8259C5AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C5B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C5B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C5B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C5BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C5C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C5C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C5C8: 4082FFE8  bne 0x8259c5b0
	if !ctx.cr[0].eq {
	pc = 0x8259C5B0; continue 'dispatch;
	}
	// 8259C5CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C5D0: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259C5D4: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 8259C5D8: 38A0011B  li r5, 0x11b
	ctx.r[5].s64 = 283;
	// 8259C5DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C5E0: 488BAA09  bl 0x82e56fe8
	ctx.lr = 0x8259C5E4;
	sub_82E56FE8(ctx, base);
	// 8259C5E4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8259C5E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C5EC: 419A0008  beq cr6, 0x8259c5f4
	if ctx.cr[6].eq {
	pc = 0x8259C5F4; continue 'dispatch;
	}
	// 8259C5F0: 4BD242A1  bl 0x822c0890
	ctx.lr = 0x8259C5F4;
	sub_822C0890(ctx, base);
	// 8259C5F4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8259C5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C5FC: 419A0008  beq cr6, 0x8259c604
	if ctx.cr[6].eq {
	pc = 0x8259C604; continue 'dispatch;
	}
	// 8259C600: 4BD24291  bl 0x822c0890
	ctx.lr = 0x8259C604;
	sub_822C0890(ctx, base);
	// 8259C604: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259C608: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8259C60C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259C610: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8259C614: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8259C618: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8259C61C: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 8259C620: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 8259C624: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259C628: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8259C62C: 4BF98205  bl 0x82534830
	ctx.lr = 0x8259C630;
	sub_82534830(ctx, base);
	// 8259C630: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C634: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8259C638: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C63C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C640: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8259C644: 419A0024  beq cr6, 0x8259c668
	if ctx.cr[6].eq {
	pc = 0x8259C668; continue 'dispatch;
	}
	// 8259C648: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C64C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C650: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C654: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C658: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C65C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C660: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C664: 4082FFE8  bne 0x8259c64c
	if !ctx.cr[0].eq {
	pc = 0x8259C64C; continue 'dispatch;
	}
	// 8259C668: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C66C: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259C670: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8259C674: 38A0011D  li r5, 0x11d
	ctx.r[5].s64 = 285;
	// 8259C678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C67C: 488BA96D  bl 0x82e56fe8
	ctx.lr = 0x8259C680;
	sub_82E56FE8(ctx, base);
	// 8259C680: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259C684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C688: 419A0008  beq cr6, 0x8259c690
	if ctx.cr[6].eq {
	pc = 0x8259C690; continue 'dispatch;
	}
	// 8259C68C: 4BD24205  bl 0x822c0890
	ctx.lr = 0x8259C690;
	sub_822C0890(ctx, base);
	// 8259C690: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8259C694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C698: 419A0008  beq cr6, 0x8259c6a0
	if ctx.cr[6].eq {
	pc = 0x8259C6A0; continue 'dispatch;
	}
	// 8259C69C: 4BD241F5  bl 0x822c0890
	ctx.lr = 0x8259C6A0;
	sub_822C0890(ctx, base);
	// 8259C6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C6A4: 4BFFF255  bl 0x8259b8f8
	ctx.lr = 0x8259C6A8;
	sub_8259B8F8(ctx, base);
	// 8259C6A8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8259C6AC: 4BFFF515  bl 0x8259bbc0
	ctx.lr = 0x8259C6B0;
	sub_8259BBC0(ctx, base);
	// 8259C6B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C6B4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8259C6B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C6BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C6C0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 8259C6C4: 419A0024  beq cr6, 0x8259c6e8
	if ctx.cr[6].eq {
	pc = 0x8259C6E8; continue 'dispatch;
	}
	// 8259C6C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C6CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C6D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C6D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C6D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C6DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C6E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C6E4: 4082FFE8  bne 0x8259c6cc
	if !ctx.cr[0].eq {
	pc = 0x8259C6CC; continue 'dispatch;
	}
	// 8259C6E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259C6EC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259C6F0: 4BF72C41  bl 0x8250f330
	ctx.lr = 0x8259C6F4;
	sub_8250F330(ctx, base);
	// 8259C6F4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C6F8: 3B810078  addi r28, r1, 0x78
	ctx.r[28].s64 = ctx.r[1].s64 + 120;
	// 8259C6FC: 4BF4D165  bl 0x824e9860
	ctx.lr = 0x8259C700;
	sub_824E9860(ctx, base);
	// 8259C700: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259C704: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259C708: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C70C: 38A00122  li r5, 0x122
	ctx.r[5].s64 = 290;
	// 8259C710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C714: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8259C718: 488BC329  bl 0x82e58a40
	ctx.lr = 0x8259C71C;
	sub_82E58A40(ctx, base);
	// 8259C71C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259C720: 48855571  bl 0x82df1c90
	ctx.lr = 0x8259C724;
	sub_82DF1C90(ctx, base);
	// 8259C724: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8259C728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C72C: 419A0008  beq cr6, 0x8259c734
	if ctx.cr[6].eq {
	pc = 0x8259C734; continue 'dispatch;
	}
	// 8259C730: 4BD24161  bl 0x822c0890
	ctx.lr = 0x8259C734;
	sub_822C0890(ctx, base);
	// 8259C734: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8259C738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C73C: 419A0008  beq cr6, 0x8259c744
	if ctx.cr[6].eq {
	pc = 0x8259C744; continue 'dispatch;
	}
	// 8259C740: 4BD24151  bl 0x822c0890
	ctx.lr = 0x8259C744;
	sub_822C0890(ctx, base);
	// 8259C744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C748: 4BF73E89  bl 0x825105d0
	ctx.lr = 0x8259C74C;
	sub_825105D0(ctx, base);
	// 8259C74C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8259C750: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8259C754: 48C0BA64  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259C758 size=280
    let mut pc: u32 = 0x8259C758;
    'dispatch: loop {
        match pc {
            0x8259C758 => {
    //   block [0x8259C758..0x8259C870)
	// 8259C758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C75C: 48C0BA11  bl 0x831a816c
	ctx.lr = 0x8259C760;
	sub_831A8130(ctx, base);
	// 8259C760: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259C768: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259C76C: 389F0140  addi r4, r31, 0x140
	ctx.r[4].s64 = ctx.r[31].s64 + 320;
	// 8259C770: 4BDD8369  bl 0x82374ad8
	ctx.lr = 0x8259C774;
	sub_82374AD8(ctx, base);
	// 8259C774: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C778: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259C77C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C784: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259C788: 419A0024  beq cr6, 0x8259c7ac
	if ctx.cr[6].eq {
	pc = 0x8259C7AC; continue 'dispatch;
	}
	// 8259C78C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C790: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C794: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C798: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C79C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C7A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C7A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C7A8: 4082FFE8  bne 0x8259c790
	if !ctx.cr[0].eq {
	pc = 0x8259C790; continue 'dispatch;
	}
	// 8259C7AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259C7B0: 80DF0134  lwz r6, 0x134(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 8259C7B4: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 8259C7B8: 3BABA8A0  addi r29, r11, -0x5760
	ctx.r[29].s64 = ctx.r[11].s64 + -22368;
	// 8259C7BC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8259C7C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C7C4: 38A00451  li r5, 0x451
	ctx.r[5].s64 = 1105;
	// 8259C7C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C7CC: 488BA81D  bl 0x82e56fe8
	ctx.lr = 0x8259C7D0;
	sub_82E56FE8(ctx, base);
	// 8259C7D0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259C7D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C7D8: 419A0008  beq cr6, 0x8259c7e0
	if ctx.cr[6].eq {
	pc = 0x8259C7E0; continue 'dispatch;
	}
	// 8259C7DC: 4BD240B5  bl 0x822c0890
	ctx.lr = 0x8259C7E0;
	sub_822C0890(ctx, base);
	// 8259C7E0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259C7E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C7E8: 419A0008  beq cr6, 0x8259c7f0
	if ctx.cr[6].eq {
	pc = 0x8259C7F0; continue 'dispatch;
	}
	// 8259C7EC: 4BD240A5  bl 0x822c0890
	ctx.lr = 0x8259C7F0;
	sub_822C0890(ctx, base);
	// 8259C7F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8259C7F4: 4BFFF62D  bl 0x8259be20
	ctx.lr = 0x8259C7F8;
	sub_8259BE20(ctx, base);
	// 8259C7F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C7FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259C800: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C808: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8259C80C: 419A0024  beq cr6, 0x8259c830
	if ctx.cr[6].eq {
	pc = 0x8259C830; continue 'dispatch;
	}
	// 8259C810: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C814: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C818: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C81C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C820: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C824: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C828: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C82C: 4082FFE8  bne 0x8259c814
	if !ctx.cr[0].eq {
	pc = 0x8259C814; continue 'dispatch;
	}
	// 8259C830: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C834: 80DF0134  lwz r6, 0x134(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 8259C838: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8259C83C: 38A00452  li r5, 0x452
	ctx.r[5].s64 = 1106;
	// 8259C840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C844: 488BA7A5  bl 0x82e56fe8
	ctx.lr = 0x8259C848;
	sub_82E56FE8(ctx, base);
	// 8259C848: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259C84C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C850: 419A0008  beq cr6, 0x8259c858
	if ctx.cr[6].eq {
	pc = 0x8259C858; continue 'dispatch;
	}
	// 8259C854: 4BD2403D  bl 0x822c0890
	ctx.lr = 0x8259C858;
	sub_822C0890(ctx, base);
	// 8259C858: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8259C85C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259C860: 419A0008  beq cr6, 0x8259c868
	if ctx.cr[6].eq {
	pc = 0x8259C868; continue 'dispatch;
	}
	// 8259C864: 4BD2402D  bl 0x822c0890
	ctx.lr = 0x8259C868;
	sub_822C0890(ctx, base);
	// 8259C868: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259C86C: 48C0B950  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259C870 size=96
    let mut pc: u32 = 0x8259C870;
    'dispatch: loop {
        match pc {
            0x8259C870 => {
    //   block [0x8259C870..0x8259C8D0)
	// 8259C870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259C878: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259C87C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259C880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C884: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259C888: 48BB7D79  bl 0x83154600
	ctx.lr = 0x8259C88C;
	sub_83154600(ctx, base);
	// 8259C88C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8259C890: 93E30150  stw r31, 0x150(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), ctx.r[31].u32 ) };
	// 8259C894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C898: 48BB7D69  bl 0x83154600
	ctx.lr = 0x8259C89C;
	sub_83154600(ctx, base);
	// 8259C89C: 9BE30154  stb r31, 0x154(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), ctx.r[31].u8 ) };
	// 8259C8A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C8A4: 48BB7D5D  bl 0x83154600
	ctx.lr = 0x8259C8A8;
	sub_83154600(ctx, base);
	// 8259C8A8: 4BFFF051  bl 0x8259b8f8
	ctx.lr = 0x8259C8AC;
	sub_8259B8F8(ctx, base);
	// 8259C8AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C8B0: 48BB7D51  bl 0x83154600
	ctx.lr = 0x8259C8B4;
	sub_83154600(ctx, base);
	// 8259C8B4: 4BFFFEA5  bl 0x8259c758
	ctx.lr = 0x8259C8B8;
	sub_8259C758(ctx, base);
	// 8259C8B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259C8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259C8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259C8C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259C8C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259C8CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259C8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259C8D0 size=668
    let mut pc: u32 = 0x8259C8D0;
    'dispatch: loop {
        match pc {
            0x8259C8D0 => {
    //   block [0x8259C8D0..0x8259CB6C)
	// 8259C8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259C8D4: 48C0B891  bl 0x831a8164
	ctx.lr = 0x8259C8D8;
	sub_831A8130(ctx, base);
	// 8259C8D8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8259C8DC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259C8E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8259C8E4: 48BB7D1D  bl 0x83154600
	ctx.lr = 0x8259C8E8;
	sub_83154600(ctx, base);
	// 8259C8E8: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 8259C8EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259C8F0: 4BFFEF99  bl 0x8259b888
	ctx.lr = 0x8259C8F4;
	sub_8259B888(ctx, base);
	// 8259C8F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259C8F8: 41820038  beq 0x8259c930
	if ctx.cr[0].eq {
	pc = 0x8259C930; continue 'dispatch;
	}
	// 8259C8FC: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 8259C900: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 8259C904: 915F0194  stw r10, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 8259C908: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 8259C90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C910: 419A0010  beq cr6, 0x8259c920
	if ctx.cr[6].eq {
	pc = 0x8259C920; continue 'dispatch;
	}
	// 8259C914: 813F018C  lwz r9, 0x18c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8259C918: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 8259C91C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 8259C920: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8259C924: 41980050  blt cr6, 0x8259c974
	if ctx.cr[6].lt {
	pc = 0x8259C974; continue 'dispatch;
	}
	// 8259C928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259C92C: 48000044  b 0x8259c970
	pc = 0x8259C970; continue 'dispatch;
	// 8259C930: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 8259C934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C938: 4BFFEF51  bl 0x8259b888
	ctx.lr = 0x8259C93C;
	sub_8259B888(ctx, base);
	// 8259C93C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259C940: 41820034  beq 0x8259c974
	if ctx.cr[0].eq {
	pc = 0x8259C974; continue 'dispatch;
	}
	// 8259C944: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 8259C948: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259C94C: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 8259C950: 40800024  bge 0x8259c974
	if !ctx.cr[0].lt {
	pc = 0x8259C974; continue 'dispatch;
	}
	// 8259C954: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 8259C958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C95C: 419A0010  beq cr6, 0x8259c96c
	if ctx.cr[6].eq {
	pc = 0x8259C96C; continue 'dispatch;
	}
	// 8259C960: 815F018C  lwz r10, 0x18c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8259C964: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8259C968: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 8259C96C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259C970: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 8259C974: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259C978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259C97C: 4BFFEF0D  bl 0x8259b888
	ctx.lr = 0x8259C980;
	sub_8259B888(ctx, base);
	// 8259C980: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259C984: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8259C988: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259C98C: 418201B0  beq 0x8259cb3c
	if ctx.cr[0].eq {
	pc = 0x8259CB3C; continue 'dispatch;
	}
	// 8259C990: 3B9F0194  addi r28, r31, 0x194
	ctx.r[28].s64 = ctx.r[31].s64 + 404;
	// 8259C994: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259C998: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259C99C: 4BFFF505  bl 0x8259bea0
	ctx.lr = 0x8259C9A0;
	sub_8259BEA0(ctx, base);
	// 8259C9A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259C9A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259C9A8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259C9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259C9B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8259C9B4: 419A0024  beq cr6, 0x8259c9d8
	if ctx.cr[6].eq {
	pc = 0x8259C9D8; continue 'dispatch;
	}
	// 8259C9B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259C9BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259C9C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C9C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259C9C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259C9CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259C9D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259C9D4: 4082FFE8  bne 0x8259c9bc
	if !ctx.cr[0].eq {
	pc = 0x8259C9BC; continue 'dispatch;
	}
	// 8259C9D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259C9DC: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259C9E0: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 8259C9E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259C9E8: 3BABA8A0  addi r29, r11, -0x5760
	ctx.r[29].s64 = ctx.r[11].s64 + -22368;
	// 8259C9EC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8259C9F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259C9F4: 38A004F4  li r5, 0x4f4
	ctx.r[5].s64 = 1268;
	// 8259C9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259C9FC: 488BC045  bl 0x82e58a40
	ctx.lr = 0x8259CA00;
	sub_82E58A40(ctx, base);
	// 8259CA00: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259CA04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CA08: 419A0008  beq cr6, 0x8259ca10
	if ctx.cr[6].eq {
	pc = 0x8259CA10; continue 'dispatch;
	}
	// 8259CA0C: 4BD23E85  bl 0x822c0890
	ctx.lr = 0x8259CA10;
	sub_822C0890(ctx, base);
	// 8259CA10: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259CA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CA18: 419A0008  beq cr6, 0x8259ca20
	if ctx.cr[6].eq {
	pc = 0x8259CA20; continue 'dispatch;
	}
	// 8259CA1C: 4BD23E75  bl 0x822c0890
	ctx.lr = 0x8259CA20;
	sub_822C0890(ctx, base);
	// 8259CA20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259CA24: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259CA28: 4BFFF4F1  bl 0x8259bf18
	ctx.lr = 0x8259CA2C;
	sub_8259BF18(ctx, base);
	// 8259CA2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CA30: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8259CA34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CA3C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8259CA40: 419A0024  beq cr6, 0x8259ca64
	if ctx.cr[6].eq {
	pc = 0x8259CA64; continue 'dispatch;
	}
	// 8259CA44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CA48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CA4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CA50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CA54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CA58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CA5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CA60: 4082FFE8  bne 0x8259ca48
	if !ctx.cr[0].eq {
	pc = 0x8259CA48; continue 'dispatch;
	}
	// 8259CA64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259CA68: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259CA6C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8259CA70: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259CA74: 38A004F5  li r5, 0x4f5
	ctx.r[5].s64 = 1269;
	// 8259CA78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259CA7C: 488BBFC5  bl 0x82e58a40
	ctx.lr = 0x8259CA80;
	sub_82E58A40(ctx, base);
	// 8259CA80: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259CA84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CA88: 419A0008  beq cr6, 0x8259ca90
	if ctx.cr[6].eq {
	pc = 0x8259CA90; continue 'dispatch;
	}
	// 8259CA8C: 4BD23E05  bl 0x822c0890
	ctx.lr = 0x8259CA90;
	sub_822C0890(ctx, base);
	// 8259CA90: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8259CA94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CA98: 419A0008  beq cr6, 0x8259caa0
	if ctx.cr[6].eq {
	pc = 0x8259CAA0; continue 'dispatch;
	}
	// 8259CA9C: 4BD23DF5  bl 0x822c0890
	ctx.lr = 0x8259CAA0;
	sub_822C0890(ctx, base);
	// 8259CAA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CAA4: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8259CAA8: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8259CAAC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8259CAB0: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 8259CAB4: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 8259CAB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259CABC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8259CAC0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259CAC4: 4BF97D6D  bl 0x82534830
	ctx.lr = 0x8259CAC8;
	sub_82534830(ctx, base);
	// 8259CAC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CACC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8259CAD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CAD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CAD8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8259CADC: 419A0024  beq cr6, 0x8259cb00
	if ctx.cr[6].eq {
	pc = 0x8259CB00; continue 'dispatch;
	}
	// 8259CAE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CAE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CAE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CAEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CAF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CAF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CAF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CAFC: 4082FFE8  bne 0x8259cae4
	if !ctx.cr[0].eq {
	pc = 0x8259CAE4; continue 'dispatch;
	}
	// 8259CB00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259CB04: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259CB08: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 8259CB0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259CB10: 38A004F6  li r5, 0x4f6
	ctx.r[5].s64 = 1270;
	// 8259CB14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259CB18: 488BBF29  bl 0x82e58a40
	ctx.lr = 0x8259CB1C;
	sub_82E58A40(ctx, base);
	// 8259CB1C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8259CB20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CB24: 419A0008  beq cr6, 0x8259cb2c
	if ctx.cr[6].eq {
	pc = 0x8259CB2C; continue 'dispatch;
	}
	// 8259CB28: 4BD23D69  bl 0x822c0890
	ctx.lr = 0x8259CB2C;
	sub_822C0890(ctx, base);
	// 8259CB2C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8259CB30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CB34: 419A0008  beq cr6, 0x8259cb3c
	if ctx.cr[6].eq {
	pc = 0x8259CB3C; continue 'dispatch;
	}
	// 8259CB38: 4BD23D59  bl 0x822c0890
	ctx.lr = 0x8259CB3C;
	sub_822C0890(ctx, base);
	// 8259CB3C: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8259CB40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259CB44: 4BFFED45  bl 0x8259b888
	ctx.lr = 0x8259CB48;
	sub_8259B888(ctx, base);
	// 8259CB48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259CB4C: 41820014  beq 0x8259cb60
	if ctx.cr[0].eq {
	pc = 0x8259CB60; continue 'dispatch;
	}
	// 8259CB50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259CB54: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259CB58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259CB5C: 488BFEDD  bl 0x82e5ca38
	ctx.lr = 0x8259CB60;
	sub_82E5CA38(ctx, base);
	// 8259CB60: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8259CB64: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8259CB68: 48C0B64C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CB70 size=112
    let mut pc: u32 = 0x8259CB70;
    'dispatch: loop {
        match pc {
            0x8259CB70 => {
    //   block [0x8259CB70..0x8259CBE0)
	// 8259CB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CB74: 48C0B5F5  bl 0x831a8168
	ctx.lr = 0x8259CB78;
	sub_831A8130(ctx, base);
	// 8259CB78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CB7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259CB80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259CB84: 3B9D0184  addi r28, r29, 0x184
	ctx.r[28].s64 = ctx.r[29].s64 + 388;
	// 8259CB88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259CB8C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CB94: 419A0044  beq cr6, 0x8259cbd8
	if ctx.cr[6].eq {
	pc = 0x8259CBD8; continue 'dispatch;
	}
	// 8259CB98: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259CB9C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8259CBA0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 8259CBA4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259CBA8: 40980030  bge cr6, 0x8259cbd8
	if !ctx.cr[6].lt {
	pc = 0x8259CBD8; continue 'dispatch;
	}
	// 8259CBAC: 817D0188  lwz r11, 0x188(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(392 as u32) ) } as u64;
	// 8259CBB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259CBB4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8259CBB8: 4885CBD1  bl 0x82df9788
	ctx.lr = 0x8259CBBC;
	sub_82DF9788(ctx, base);
	// 8259CBBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259CBC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259CBC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259CBC8: 4BD2C269  bl 0x822c8e30
	ctx.lr = 0x8259CBCC;
	sub_822C8E30(ctx, base);
	// 8259CBCC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8259CBD0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8259CBD4: 4BFFFFB8  b 0x8259cb8c
	pc = 0x8259CB8C; continue 'dispatch;
	// 8259CBD8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259CBDC: 48C0B5DC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CBE0 size=180
    let mut pc: u32 = 0x8259CBE0;
    'dispatch: loop {
        match pc {
            0x8259CBE0 => {
    //   block [0x8259CBE0..0x8259CC94)
	// 8259CBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CBE4: 48C0B589  bl 0x831a816c
	ctx.lr = 0x8259CBE8;
	sub_831A8130(ctx, base);
	// 8259CBE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CBEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259CBF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259CBF4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8259CBF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259CBFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259CC00: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259CC04: 4BD805CD  bl 0x8231d1d0
	ctx.lr = 0x8259CC08;
	sub_8231D1D0(ctx, base);
	// 8259CC08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CC0C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259CC10: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CC14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CC18: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8259CC1C: 419A0024  beq cr6, 0x8259cc40
	if ctx.cr[6].eq {
	pc = 0x8259CC40; continue 'dispatch;
	}
	// 8259CC20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CC24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CC28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CC2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CC30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CC34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CC38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CC3C: 4082FFE8  bne 0x8259cc24
	if !ctx.cr[0].eq {
	pc = 0x8259CC24; continue 'dispatch;
	}
	// 8259CC40: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259CC44: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8259CC48: 48A6C371  bl 0x83008fb8
	ctx.lr = 0x8259CC4C;
	sub_83008FB8(ctx, base);
	// 8259CC4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259CC50: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259CC54: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259CC58: 38A00533  li r5, 0x533
	ctx.r[5].s64 = 1331;
	// 8259CC5C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259CC60: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259CC64: 488BA385  bl 0x82e56fe8
	ctx.lr = 0x8259CC68;
	sub_82E56FE8(ctx, base);
	// 8259CC68: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259CC6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CC70: 419A0008  beq cr6, 0x8259cc78
	if ctx.cr[6].eq {
	pc = 0x8259CC78; continue 'dispatch;
	}
	// 8259CC74: 4BD23C1D  bl 0x822c0890
	ctx.lr = 0x8259CC78;
	sub_822C0890(ctx, base);
	// 8259CC78: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259CC7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CC80: 419A0008  beq cr6, 0x8259cc88
	if ctx.cr[6].eq {
	pc = 0x8259CC88; continue 'dispatch;
	}
	// 8259CC84: 4BD23C0D  bl 0x822c0890
	ctx.lr = 0x8259CC88;
	sub_822C0890(ctx, base);
	// 8259CC88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259CC8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259CC90: 48C0B52C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CC98 size=180
    let mut pc: u32 = 0x8259CC98;
    'dispatch: loop {
        match pc {
            0x8259CC98 => {
    //   block [0x8259CC98..0x8259CD4C)
	// 8259CC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CC9C: 48C0B4D1  bl 0x831a816c
	ctx.lr = 0x8259CCA0;
	sub_831A8130(ctx, base);
	// 8259CCA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CCA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259CCA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259CCAC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8259CCB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259CCB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259CCB8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259CCBC: 4BE76005  bl 0x82412cc0
	ctx.lr = 0x8259CCC0;
	sub_82412CC0(ctx, base);
	// 8259CCC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CCC4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259CCC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CCCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CCD0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8259CCD4: 419A0024  beq cr6, 0x8259ccf8
	if ctx.cr[6].eq {
	pc = 0x8259CCF8; continue 'dispatch;
	}
	// 8259CCD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CCDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CCE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CCE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CCE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CCEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CCF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CCF4: 4082FFE8  bne 0x8259ccdc
	if !ctx.cr[0].eq {
	pc = 0x8259CCDC; continue 'dispatch;
	}
	// 8259CCF8: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259CCFC: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8259CD00: 48A6C2B9  bl 0x83008fb8
	ctx.lr = 0x8259CD04;
	sub_83008FB8(ctx, base);
	// 8259CD04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259CD08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259CD0C: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259CD10: 38A00542  li r5, 0x542
	ctx.r[5].s64 = 1346;
	// 8259CD14: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259CD18: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259CD1C: 488BA2CD  bl 0x82e56fe8
	ctx.lr = 0x8259CD20;
	sub_82E56FE8(ctx, base);
	// 8259CD20: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259CD24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CD28: 419A0008  beq cr6, 0x8259cd30
	if ctx.cr[6].eq {
	pc = 0x8259CD30; continue 'dispatch;
	}
	// 8259CD2C: 4BD23B65  bl 0x822c0890
	ctx.lr = 0x8259CD30;
	sub_822C0890(ctx, base);
	// 8259CD30: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259CD34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CD38: 419A0008  beq cr6, 0x8259cd40
	if ctx.cr[6].eq {
	pc = 0x8259CD40; continue 'dispatch;
	}
	// 8259CD3C: 4BD23B55  bl 0x822c0890
	ctx.lr = 0x8259CD40;
	sub_822C0890(ctx, base);
	// 8259CD40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259CD44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259CD48: 48C0B474  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CD50 size=192
    let mut pc: u32 = 0x8259CD50;
    'dispatch: loop {
        match pc {
            0x8259CD50 => {
    //   block [0x8259CD50..0x8259CE10)
	// 8259CD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CD58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259CD5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259CD60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CD64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CD68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259CD6C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259CD70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259CD74: 4BDD7D65  bl 0x82374ad8
	ctx.lr = 0x8259CD78;
	sub_82374AD8(ctx, base);
	// 8259CD78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CD7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259CD80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CD88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259CD8C: 419A0024  beq cr6, 0x8259cdb0
	if ctx.cr[6].eq {
	pc = 0x8259CDB0; continue 'dispatch;
	}
	// 8259CD90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CD94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CD98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CD9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CDA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CDA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CDA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CDAC: 4082FFE8  bne 0x8259cd94
	if !ctx.cr[0].eq {
	pc = 0x8259CD94; continue 'dispatch;
	}
	// 8259CDB0: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259CDB4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259CDB8: 48A6C201  bl 0x83008fb8
	ctx.lr = 0x8259CDBC;
	sub_83008FB8(ctx, base);
	// 8259CDBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259CDC0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259CDC4: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259CDC8: 38A00550  li r5, 0x550
	ctx.r[5].s64 = 1360;
	// 8259CDCC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259CDD0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259CDD4: 488BA215  bl 0x82e56fe8
	ctx.lr = 0x8259CDD8;
	sub_82E56FE8(ctx, base);
	// 8259CDD8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259CDDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CDE0: 419A0008  beq cr6, 0x8259cde8
	if ctx.cr[6].eq {
	pc = 0x8259CDE8; continue 'dispatch;
	}
	// 8259CDE4: 4BD23AAD  bl 0x822c0890
	ctx.lr = 0x8259CDE8;
	sub_822C0890(ctx, base);
	// 8259CDE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259CDEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CDF0: 419A0008  beq cr6, 0x8259cdf8
	if ctx.cr[6].eq {
	pc = 0x8259CDF8; continue 'dispatch;
	}
	// 8259CDF4: 4BD23A9D  bl 0x822c0890
	ctx.lr = 0x8259CDF8;
	sub_822C0890(ctx, base);
	// 8259CDF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259CDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CE04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259CE08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259CE0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CE10 size=192
    let mut pc: u32 = 0x8259CE10;
    'dispatch: loop {
        match pc {
            0x8259CE10 => {
    //   block [0x8259CE10..0x8259CED0)
	// 8259CE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CE18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259CE1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259CE20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CE24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CE28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259CE2C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259CE30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259CE34: 4BEC35F5  bl 0x82460428
	ctx.lr = 0x8259CE38;
	sub_82460428(ctx, base);
	// 8259CE38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CE3C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259CE40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CE48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259CE4C: 419A0024  beq cr6, 0x8259ce70
	if ctx.cr[6].eq {
	pc = 0x8259CE70; continue 'dispatch;
	}
	// 8259CE50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CE54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CE58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CE5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CE60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CE64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CE68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CE6C: 4082FFE8  bne 0x8259ce54
	if !ctx.cr[0].eq {
	pc = 0x8259CE54; continue 'dispatch;
	}
	// 8259CE70: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259CE74: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259CE78: 48A6C141  bl 0x83008fb8
	ctx.lr = 0x8259CE7C;
	sub_83008FB8(ctx, base);
	// 8259CE7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259CE80: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259CE84: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259CE88: 38A0055C  li r5, 0x55c
	ctx.r[5].s64 = 1372;
	// 8259CE8C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259CE90: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259CE94: 488BA155  bl 0x82e56fe8
	ctx.lr = 0x8259CE98;
	sub_82E56FE8(ctx, base);
	// 8259CE98: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259CE9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CEA0: 419A0008  beq cr6, 0x8259cea8
	if ctx.cr[6].eq {
	pc = 0x8259CEA8; continue 'dispatch;
	}
	// 8259CEA4: 4BD239ED  bl 0x822c0890
	ctx.lr = 0x8259CEA8;
	sub_822C0890(ctx, base);
	// 8259CEA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259CEAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CEB0: 419A0008  beq cr6, 0x8259ceb8
	if ctx.cr[6].eq {
	pc = 0x8259CEB8; continue 'dispatch;
	}
	// 8259CEB4: 4BD239DD  bl 0x822c0890
	ctx.lr = 0x8259CEB8;
	sub_822C0890(ctx, base);
	// 8259CEB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259CEBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CEC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CEC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259CEC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259CECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CED0 size=200
    let mut pc: u32 = 0x8259CED0;
    'dispatch: loop {
        match pc {
            0x8259CED0 => {
    //   block [0x8259CED0..0x8259CF98)
	// 8259CED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259CEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259CEE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CEE4: 90C100AC  stw r6, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 8259CEE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259CEEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CEF0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259CEF4: 38A100AC  addi r5, r1, 0xac
	ctx.r[5].s64 = ctx.r[1].s64 + 172;
	// 8259CEF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259CEFC: 4BFFF095  bl 0x8259bf90
	ctx.lr = 0x8259CF00;
	sub_8259BF90(ctx, base);
	// 8259CF00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CF04: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259CF08: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CF10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259CF14: 419A0024  beq cr6, 0x8259cf38
	if ctx.cr[6].eq {
	pc = 0x8259CF38; continue 'dispatch;
	}
	// 8259CF18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CF1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CF20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CF24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CF28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259CF2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259CF30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CF34: 4082FFE8  bne 0x8259cf1c
	if !ctx.cr[0].eq {
	pc = 0x8259CF1C; continue 'dispatch;
	}
	// 8259CF38: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259CF3C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259CF40: 48A6C079  bl 0x83008fb8
	ctx.lr = 0x8259CF44;
	sub_83008FB8(ctx, base);
	// 8259CF44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259CF48: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259CF4C: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259CF50: 38A00568  li r5, 0x568
	ctx.r[5].s64 = 1384;
	// 8259CF54: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259CF58: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259CF5C: 488BA08D  bl 0x82e56fe8
	ctx.lr = 0x8259CF60;
	sub_82E56FE8(ctx, base);
	// 8259CF60: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259CF64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CF68: 419A0008  beq cr6, 0x8259cf70
	if ctx.cr[6].eq {
	pc = 0x8259CF70; continue 'dispatch;
	}
	// 8259CF6C: 4BD23925  bl 0x822c0890
	ctx.lr = 0x8259CF70;
	sub_822C0890(ctx, base);
	// 8259CF70: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259CF74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259CF78: 419A0008  beq cr6, 0x8259cf80
	if ctx.cr[6].eq {
	pc = 0x8259CF80; continue 'dispatch;
	}
	// 8259CF7C: 4BD23915  bl 0x822c0890
	ctx.lr = 0x8259CF80;
	sub_822C0890(ctx, base);
	// 8259CF80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259CF84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CF88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CF8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259CF90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259CF94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259CF98 size=216
    let mut pc: u32 = 0x8259CF98;
    'dispatch: loop {
        match pc {
            0x8259CF98 => {
    //   block [0x8259CF98..0x8259D070)
	// 8259CF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CF9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CFA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259CFA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259CFA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CFAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259CFB0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8259CFB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CFB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259CFBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259CFC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8259CFC4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259CFC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259CFCC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8259CFD0: 4BFFF041  bl 0x8259c010
	ctx.lr = 0x8259CFD4;
	sub_8259C010(ctx, base);
	// 8259CFD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CFD8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259CFDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CFE4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8259CFE8: 419A0024  beq cr6, 0x8259d00c
	if ctx.cr[6].eq {
	pc = 0x8259D00C; continue 'dispatch;
	}
	// 8259CFEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259CFF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259CFF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259CFF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259CFFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259D000: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259D004: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D008: 4082FFE8  bne 0x8259cff0
	if !ctx.cr[0].eq {
	pc = 0x8259CFF0; continue 'dispatch;
	}
	// 8259D00C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259D010: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8259D014: 48A6BFA5  bl 0x83008fb8
	ctx.lr = 0x8259D018;
	sub_83008FB8(ctx, base);
	// 8259D018: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259D01C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259D020: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259D024: 38A00583  li r5, 0x583
	ctx.r[5].s64 = 1411;
	// 8259D028: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259D02C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259D030: 488B9FB9  bl 0x82e56fe8
	ctx.lr = 0x8259D034;
	sub_82E56FE8(ctx, base);
	// 8259D034: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259D038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D03C: 419A0008  beq cr6, 0x8259d044
	if ctx.cr[6].eq {
	pc = 0x8259D044; continue 'dispatch;
	}
	// 8259D040: 4BD23851  bl 0x822c0890
	ctx.lr = 0x8259D044;
	sub_822C0890(ctx, base);
	// 8259D044: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259D048: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D04C: 419A0008  beq cr6, 0x8259d054
	if ctx.cr[6].eq {
	pc = 0x8259D054; continue 'dispatch;
	}
	// 8259D050: 4BD23841  bl 0x822c0890
	ctx.lr = 0x8259D054;
	sub_822C0890(ctx, base);
	// 8259D054: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259D058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259D05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D06C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259D070 size=196
    let mut pc: u32 = 0x8259D070;
    'dispatch: loop {
        match pc {
            0x8259D070 => {
    //   block [0x8259D070..0x8259D134)
	// 8259D070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259D07C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D084: D02100A4  stfs f1, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8259D088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D08C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259D090: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 8259D094: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D098: 4BFFEFF1  bl 0x8259c088
	ctx.lr = 0x8259D09C;
	sub_8259C088(ctx, base);
	// 8259D09C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D0A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259D0A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D0A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D0AC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259D0B0: 419A0024  beq cr6, 0x8259d0d4
	if ctx.cr[6].eq {
	pc = 0x8259D0D4; continue 'dispatch;
	}
	// 8259D0B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259D0B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259D0BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D0C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259D0C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259D0C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259D0CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D0D0: 4082FFE8  bne 0x8259d0b8
	if !ctx.cr[0].eq {
	pc = 0x8259D0B8; continue 'dispatch;
	}
	// 8259D0D4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259D0D8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259D0DC: 48A6BEDD  bl 0x83008fb8
	ctx.lr = 0x8259D0E0;
	sub_83008FB8(ctx, base);
	// 8259D0E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259D0E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259D0E8: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259D0EC: 38A00590  li r5, 0x590
	ctx.r[5].s64 = 1424;
	// 8259D0F0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259D0F4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259D0F8: 488B9EF1  bl 0x82e56fe8
	ctx.lr = 0x8259D0FC;
	sub_82E56FE8(ctx, base);
	// 8259D0FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D100: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D104: 419A0008  beq cr6, 0x8259d10c
	if ctx.cr[6].eq {
	pc = 0x8259D10C; continue 'dispatch;
	}
	// 8259D108: 4BD23789  bl 0x822c0890
	ctx.lr = 0x8259D10C;
	sub_822C0890(ctx, base);
	// 8259D10C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259D110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D114: 419A0008  beq cr6, 0x8259d11c
	if ctx.cr[6].eq {
	pc = 0x8259D11C; continue 'dispatch;
	}
	// 8259D118: 4BD23779  bl 0x822c0890
	ctx.lr = 0x8259D11C;
	sub_822C0890(ctx, base);
	// 8259D11C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259D120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D12C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259D138 size=196
    let mut pc: u32 = 0x8259D138;
    'dispatch: loop {
        match pc {
            0x8259D138 => {
    //   block [0x8259D138..0x8259D1FC)
	// 8259D138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259D144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D148: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D14C: D02100A4  stfs f1, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8259D150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D154: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259D158: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 8259D15C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D160: 4BFFEFA1  bl 0x8259c100
	ctx.lr = 0x8259D164;
	sub_8259C100(ctx, base);
	// 8259D164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D168: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259D16C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D174: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259D178: 419A0024  beq cr6, 0x8259d19c
	if ctx.cr[6].eq {
	pc = 0x8259D19C; continue 'dispatch;
	}
	// 8259D17C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259D180: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259D184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D188: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259D18C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259D190: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259D194: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D198: 4082FFE8  bne 0x8259d180
	if !ctx.cr[0].eq {
	pc = 0x8259D180; continue 'dispatch;
	}
	// 8259D19C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259D1A0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259D1A4: 48A6BE15  bl 0x83008fb8
	ctx.lr = 0x8259D1A8;
	sub_83008FB8(ctx, base);
	// 8259D1A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259D1AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259D1B0: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259D1B4: 38A0059C  li r5, 0x59c
	ctx.r[5].s64 = 1436;
	// 8259D1B8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259D1BC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259D1C0: 488B9E29  bl 0x82e56fe8
	ctx.lr = 0x8259D1C4;
	sub_82E56FE8(ctx, base);
	// 8259D1C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D1C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D1CC: 419A0008  beq cr6, 0x8259d1d4
	if ctx.cr[6].eq {
	pc = 0x8259D1D4; continue 'dispatch;
	}
	// 8259D1D0: 4BD236C1  bl 0x822c0890
	ctx.lr = 0x8259D1D4;
	sub_822C0890(ctx, base);
	// 8259D1D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259D1D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D1DC: 419A0008  beq cr6, 0x8259d1e4
	if ctx.cr[6].eq {
	pc = 0x8259D1E4; continue 'dispatch;
	}
	// 8259D1E0: 4BD236B1  bl 0x822c0890
	ctx.lr = 0x8259D1E4;
	sub_822C0890(ctx, base);
	// 8259D1E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259D1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D1F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259D200 size=216
    let mut pc: u32 = 0x8259D200;
    'dispatch: loop {
        match pc {
            0x8259D200 => {
    //   block [0x8259D200..0x8259D2D8)
	// 8259D200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D20C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D214: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259D218: 48002441  bl 0x8259f658
	ctx.lr = 0x8259D21C;
	sub_8259F658(ctx, base);
	// 8259D21C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D220: 418200A4  beq 0x8259d2c4
	if ctx.cr[0].eq {
	pc = 0x8259D2C4; continue 'dispatch;
	}
	// 8259D224: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259D228: 806B00F0  lwz r3, 0xf0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 8259D22C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D230: 419A0094  beq cr6, 0x8259d2c4
	if ctx.cr[6].eq {
	pc = 0x8259D2C4; continue 'dispatch;
	}
	// 8259D234: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8259D238: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8259D23C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8259D240: 4801CCB9  bl 0x825b9ef8
	ctx.lr = 0x8259D244;
	sub_825B9EF8(ctx, base);
	// 8259D244: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8259D248: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8259D24C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259D2D8 size=212
    let mut pc: u32 = 0x8259D2D8;
    'dispatch: loop {
        match pc {
            0x8259D2D8 => {
    //   block [0x8259D2D8..0x8259D3AC)
	// 8259D2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D2DC: 48C0AE91  bl 0x831a816c
	ctx.lr = 0x8259D2E0;
	sub_831A8130(ctx, base);
	// 8259D2E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D2E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D2E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259D2EC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8259D2F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259D2F4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8259D2F8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8259D2FC: 409A0008  bne cr6, 0x8259d304
	if !ctx.cr[6].eq {
	pc = 0x8259D304; continue 'dispatch;
	}
	// 8259D300: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D308: 4BF6B499  bl 0x825087a0
	ctx.lr = 0x8259D30C;
	sub_825087A0(ctx, base);
	// 8259D30C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259D310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D314: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 8259D318: 488566F1  bl 0x82df3a08
	ctx.lr = 0x8259D31C;
	sub_82DF3A08(ctx, base);
	// 8259D31C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259D320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259D324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D328: 4BF6B459  bl 0x82508780
	ctx.lr = 0x8259D32C;
	sub_82508780(ctx, base);
	// 8259D32C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D330: 488560F9  bl 0x82df3428
	ctx.lr = 0x8259D334;
	sub_82DF3428(ctx, base);
	// 8259D334: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259D338: 93BF0158  stw r29, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[29].u32 ) };
	// 8259D33C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8259D340: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259D344: 388AA8A0  addi r4, r10, -0x5760
	ctx.r[4].s64 = ctx.r[10].s64 + -22368;
	// 8259D348: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 8259D34C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259D350: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8259D354: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8259D358: 4BD23081  bl 0x822c03d8
	ctx.lr = 0x8259D35C;
	sub_822C03D8(ctx, base);
	// 8259D35C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8259D360: 41820028  beq 0x8259d388
	if ctx.cr[0].eq {
	pc = 0x8259D388; continue 'dispatch;
	}
	// 8259D364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259D368: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D36C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8259D370: 4BF721A9  bl 0x8250f518
	ctx.lr = 0x8259D374;
	sub_8250F518(ctx, base);
	// 8259D374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D37C: 4BEF3D75  bl 0x824910f0
	ctx.lr = 0x8259D380;
	sub_824910F0(ctx, base);
	// 8259D380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D384: 48000008  b 0x8259d38c
	pc = 0x8259D38C; continue 'dispatch;
	// 8259D388: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D38C: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 8259D390: 4BD6D351  bl 0x8230a6e0
	ctx.lr = 0x8259D394;
	sub_8230A6E0(ctx, base);
	// 8259D394: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D398: 4182000C  beq 0x8259d3a4
	if ctx.cr[0].eq {
	pc = 0x8259D3A4; continue 'dispatch;
	}
	// 8259D39C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D3A0: 488548F1  bl 0x82df1c90
	ctx.lr = 0x8259D3A4;
	sub_82DF1C90(ctx, base);
	// 8259D3A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259D3A8: 48C0AE14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D3B0 size=580
    let mut pc: u32 = 0x8259D3B0;
    'dispatch: loop {
        match pc {
            0x8259D3B0 => {
    //   block [0x8259D3B0..0x8259D5F4)
	// 8259D3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D3B4: 48C0ADB1  bl 0x831a8164
	ctx.lr = 0x8259D3B8;
	sub_831A8130(ctx, base);
	// 8259D3B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D3BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8259D3C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D3C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259D3C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259D3CC: 48231E0D  bl 0x827cf1d8
	ctx.lr = 0x8259D3D0;
	sub_827CF1D8(ctx, base);
	// 8259D3D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D3D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D3D8: 48856631  bl 0x82df3a08
	ctx.lr = 0x8259D3DC;
	sub_82DF3A08(ctx, base);
	// 8259D3DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8259D3E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259D3E4: 809E015C  lwz r4, 0x15c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259D3E8: 481FF581  bl 0x8279c968
	ctx.lr = 0x8259D3EC;
	sub_8279C968(ctx, base);
	// 8259D3EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D3F0: 48856039  bl 0x82df3428
	ctx.lr = 0x8259D3F4;
	sub_82DF3428(ctx, base);
	// 8259D3F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259D3F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259D3FC: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259D400: 38A0028A  li r5, 0x28a
	ctx.r[5].s64 = 650;
	// 8259D404: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 8259D408: 48854FE1  bl 0x82df23e8
	ctx.lr = 0x8259D40C;
	sub_82DF23E8(ctx, base);
	// 8259D40C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259D410: 41820010  beq 0x8259d420
	if ctx.cr[0].eq {
	pc = 0x8259D420; continue 'dispatch;
	}
	// 8259D414: 481FE395  bl 0x8279b7a8
	ctx.lr = 0x8259D418;
	sub_8279B7A8(ctx, base);
	// 8259D418: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259D41C: 48000008  b 0x8259d424
	pc = 0x8259D424; continue 'dispatch;
	// 8259D420: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259D424: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8259D428: 3B7F0004  addi r27, r31, 4
	ctx.r[27].s64 = ctx.r[31].s64 + 4;
	// 8259D42C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D430: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259D434: 4BFFD4E5  bl 0x8259a918
	ctx.lr = 0x8259D438;
	sub_8259A918(ctx, base);
	// 8259D438: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259D43C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D440: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259D444: 4BD22BBD  bl 0x822c0000
	ctx.lr = 0x8259D448;
	sub_822C0000(ctx, base);
	// 8259D448: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8259D44C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D450: 481FE479  bl 0x8279b8c8
	ctx.lr = 0x8259D454;
	sub_8279B8C8(ctx, base);
	// 8259D454: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D458: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8259D45C: 4BF7206D  bl 0x8250f4c8
	ctx.lr = 0x8259D460;
	sub_8250F4C8(ctx, base);
	// 8259D460: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D468: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8259D46C: 409A0008  bne cr6, 0x8259d474
	if !ctx.cr[6].eq {
	pc = 0x8259D474; continue 'dispatch;
	}
	// 8259D470: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259D474: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D478: 481FC721  bl 0x82799b98
	ctx.lr = 0x8259D47C;
	sub_82799B98(ctx, base);
	// 8259D47C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8259D480: 48854811  bl 0x82df1c90
	ctx.lr = 0x8259D484;
	sub_82DF1C90(ctx, base);
	// 8259D484: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8259D488: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D490: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D494: 4BFFF74D  bl 0x8259cbe0
	ctx.lr = 0x8259D498;
	sub_8259CBE0(ctx, base);
	// 8259D498: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259D49C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D4A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D4A4: 4BFFF8AD  bl 0x8259cd50
	ctx.lr = 0x8259D4A8;
	sub_8259CD50(ctx, base);
	// 8259D4A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8259D4AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D4B4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D4B8: 4BFFF7E1  bl 0x8259cc98
	ctx.lr = 0x8259D4BC;
	sub_8259CC98(ctx, base);
	// 8259D4BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259D4C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D4C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D4C8: 4BFFF949  bl 0x8259ce10
	ctx.lr = 0x8259D4CC;
	sub_8259CE10(ctx, base);
	// 8259D4CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259D4D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D4D4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D4D8: 4BFFFAC1  bl 0x8259cf98
	ctx.lr = 0x8259D4DC;
	sub_8259CF98(ctx, base);
	// 8259D4DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259D4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D4E4: 4BFFFC55  bl 0x8259d138
	ctx.lr = 0x8259D4E8;
	sub_8259D138(ctx, base);
	// 8259D4E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D4EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259D4F0: 4BF71FD9  bl 0x8250f4c8
	ctx.lr = 0x8259D4F4;
	sub_8250F4C8(ctx, base);
	// 8259D4F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D4FC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8259D500: 409A0008  bne cr6, 0x8259d508
	if !ctx.cr[6].eq {
	pc = 0x8259D508; continue 'dispatch;
	}
	// 8259D504: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259D508: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D50C: 481FC705  bl 0x82799c10
	ctx.lr = 0x8259D510;
	sub_82799C10(ctx, base);
	// 8259D510: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259D514: 4885477D  bl 0x82df1c90
	ctx.lr = 0x8259D518;
	sub_82DF1C90(ctx, base);
	// 8259D518: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259D51C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D520: 481FCB49  bl 0x8279a068
	ctx.lr = 0x8259D524;
	sub_8279A068(ctx, base);
	// 8259D524: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D528: 481FBF11  bl 0x82799438
	ctx.lr = 0x8259D52C;
	sub_82799438(ctx, base);
	// 8259D52C: 48003E4D  bl 0x825a1378
	ctx.lr = 0x8259D530;
	sub_825A1378(ctx, base);
	// 8259D530: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259D534: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D538: 481FB761  bl 0x82798c98
	ctx.lr = 0x8259D53C;
	sub_82798C98(ctx, base);
	// 8259D53C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D540: 481FC161  bl 0x827996a0
	ctx.lr = 0x8259D544;
	sub_827996A0(ctx, base);
	// 8259D544: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D548: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D550: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259D554: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259D558: 419A0024  beq cr6, 0x8259d57c
	if ctx.cr[6].eq {
	pc = 0x8259D57C; continue 'dispatch;
	}
	// 8259D55C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259D560: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259D564: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D568: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259D56C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259D570: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259D574: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D578: 4082FFE8  bne 0x8259d560
	if !ctx.cr[0].eq {
	pc = 0x8259D560; continue 'dispatch;
	}
	// 8259D57C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D580: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259D584: 4BF71F45  bl 0x8250f4c8
	ctx.lr = 0x8259D588;
	sub_8250F4C8(ctx, base);
	// 8259D588: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D58C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D590: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 8259D594: 409A0008  bne cr6, 0x8259d59c
	if !ctx.cr[6].eq {
	pc = 0x8259D59C; continue 'dispatch;
	}
	// 8259D598: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259D59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D5A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259D5A4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259D5A8: 4BF71F71  bl 0x8250f518
	ctx.lr = 0x8259D5AC;
	sub_8250F518(ctx, base);
	// 8259D5AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D5B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259D5B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259D5B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259D5BC: 4BF6FF4D  bl 0x8250d508
	ctx.lr = 0x8259D5C0;
	sub_8250D508(ctx, base);
	// 8259D5C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259D5C4: 488546CD  bl 0x82df1c90
	ctx.lr = 0x8259D5C8;
	sub_82DF1C90(ctx, base);
	// 8259D5C8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259D5CC: 488546C5  bl 0x82df1c90
	ctx.lr = 0x8259D5D0;
	sub_82DF1C90(ctx, base);
	// 8259D5D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D5D4: 481FC05D  bl 0x82799630
	ctx.lr = 0x8259D5D8;
	sub_82799630(ctx, base);
	// 8259D5D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259D5DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D5E0: 419A0008  beq cr6, 0x8259d5e8
	if ctx.cr[6].eq {
	pc = 0x8259D5E8; continue 'dispatch;
	}
	// 8259D5E4: 4BD232AD  bl 0x822c0890
	ctx.lr = 0x8259D5E8;
	sub_822C0890(ctx, base);
	// 8259D5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D5EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8259D5F0: 48C0ABC4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259D5F8 size=608
    let mut pc: u32 = 0x8259D5F8;
    'dispatch: loop {
        match pc {
            0x8259D5F8 => {
    //   block [0x8259D5F8..0x8259D858)
	// 8259D5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D604: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 8259D608: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8259D60C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259D610: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D618: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8259D61C: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259D620: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D624: 419A0214  beq cr6, 0x8259d838
	if ctx.cr[6].eq {
	pc = 0x8259D838; continue 'dispatch;
	}
	// 8259D628: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259D62C: 38802000  li r4, 0x2000
	ctx.r[4].s64 = 8192;
	// 8259D630: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8259D634: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 8259D638: 4BEE38E9  bl 0x82480f20
	ctx.lr = 0x8259D63C;
	sub_82480F20(ctx, base);
	// 8259D63C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D640: 4182000C  beq 0x8259d64c
	if ctx.cr[0].eq {
	pc = 0x8259D64C; continue 'dispatch;
	}
	// 8259D644: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259D648: C3EBD7BC  lfs f31, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259D64C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259D650: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259D654: 4BF71EC5  bl 0x8250f518
	ctx.lr = 0x8259D658;
	sub_8250F518(ctx, base);
	// 8259D658: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D65C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D660: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 8259D664: 409A0008  bne cr6, 0x8259d66c
	if !ctx.cr[6].eq {
	pc = 0x8259D66C; continue 'dispatch;
	}
	// 8259D668: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259D66C: 4BF8A965  bl 0x82527fd0
	ctx.lr = 0x8259D670;
	sub_82527FD0(ctx, base);
	// 8259D670: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D674: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259D678: 488DEB59  bl 0x82e7c1d0
	ctx.lr = 0x8259D67C;
	sub_82E7C1D0(ctx, base);
	// 8259D67C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8259D680: 48854611  bl 0x82df1c90
	ctx.lr = 0x8259D684;
	sub_82DF1C90(ctx, base);
	// 8259D684: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 8259D688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D68C: 4BEE3895  bl 0x82480f20
	ctx.lr = 0x8259D690;
	sub_82480F20(ctx, base);
	// 8259D690: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D694: 41820124  beq 0x8259d7b8
	if ctx.cr[0].eq {
	pc = 0x8259D7B8; continue 'dispatch;
	}
	// 8259D698: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259D69C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259D6A0: 4BF71E79  bl 0x8250f518
	ctx.lr = 0x8259D6A4;
	sub_8250F518(ctx, base);
	// 8259D6A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D6AC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 8259D6B0: 409A0008  bne cr6, 0x8259d6b8
	if !ctx.cr[6].eq {
	pc = 0x8259D6B8; continue 'dispatch;
	}
	// 8259D6B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259D6B8: 4BF8A919  bl 0x82527fd0
	ctx.lr = 0x8259D6BC;
	sub_82527FD0(ctx, base);
	// 8259D6BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D6C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259D6C4: 488DEAD5  bl 0x82e7c198
	ctx.lr = 0x8259D6C8;
	sub_82E7C198(ctx, base);
	// 8259D6C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259D6CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259D6D0: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259D6D4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259D6D8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8259D6DC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8259D6E0: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8259D6E4: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8259D6E8: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8259D6EC: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8259D6F0: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8259D6F4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8259D6F8: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8259D6FC: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8259D700: 48854591  bl 0x82df1c90
	ctx.lr = 0x8259D704;
	sub_82DF1C90(ctx, base);
	// 8259D704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D708: 48015739  bl 0x825b2e40
	ctx.lr = 0x8259D70C;
	sub_825B2E40(ctx, base);
	// 8259D70C: EC0107F2  fmuls f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 8259D710: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259D714: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8259D718: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8259D71C: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8259D720: 488DF521  bl 0x82e7cc40
	ctx.lr = 0x8259D724;
	sub_82E7CC40(ctx, base);
	// 8259D724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D728: 48015769  bl 0x825b2e90
	ctx.lr = 0x8259D72C;
	sub_825B2E90(ctx, base);
	// 8259D72C: EC0107F2  fmuls f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 8259D730: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8259D734: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8259D738: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8259D73C: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8259D740: 488DF501  bl 0x82e7cc40
	ctx.lr = 0x8259D744;
	sub_82E7CC40(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259D858 size=212
    let mut pc: u32 = 0x8259D858;
    'dispatch: loop {
        match pc {
            0x8259D858 => {
    //   block [0x8259D858..0x8259D92C)
	// 8259D858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D860: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D864: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D868: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259D86C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D870: 4BEE36B1  bl 0x82480f20
	ctx.lr = 0x8259D874;
	sub_82480F20(ctx, base);
	// 8259D874: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259D878: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D87C: 41820090  beq 0x8259d90c
	if ctx.cr[0].eq {
	pc = 0x8259D90C; continue 'dispatch;
	}
	// 8259D880: 39600140  li r11, 0x140
	ctx.r[11].s64 = 320;
	// 8259D884: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8259D888: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8259D88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D890: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D930 size=212
    let mut pc: u32 = 0x8259D930;
    'dispatch: loop {
        match pc {
            0x8259D930 => {
    //   block [0x8259D930..0x8259DA04)
	// 8259D930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259D93C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D940: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D948: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259D94C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259D950: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259D954: 482184FD  bl 0x827b5e50
	ctx.lr = 0x8259D958;
	sub_827B5E50(ctx, base);
	// 8259D958: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259D95C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D960: 4BEC2AC9  bl 0x82460428
	ctx.lr = 0x8259D964;
	sub_82460428(ctx, base);
	// 8259D964: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D968: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259D96C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D974: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259D978: 419A0024  beq cr6, 0x8259d99c
	if ctx.cr[6].eq {
	pc = 0x8259D99C; continue 'dispatch;
	}
	// 8259D97C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259D980: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259D984: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D988: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259D98C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259D990: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259D994: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259D998: 4082FFE8  bne 0x8259d980
	if !ctx.cr[0].eq {
	pc = 0x8259D980; continue 'dispatch;
	}
	// 8259D99C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259D9A0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8259D9A4: 48A6B615  bl 0x83008fb8
	ctx.lr = 0x8259D9A8;
	sub_83008FB8(ctx, base);
	// 8259D9A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259D9AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8259D9B0: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259D9B4: 38A00575  li r5, 0x575
	ctx.r[5].s64 = 1397;
	// 8259D9B8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259D9BC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259D9C0: 488B9629  bl 0x82e56fe8
	ctx.lr = 0x8259D9C4;
	sub_82E56FE8(ctx, base);
	// 8259D9C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D9C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D9CC: 419A0008  beq cr6, 0x8259d9d4
	if ctx.cr[6].eq {
	pc = 0x8259D9D4; continue 'dispatch;
	}
	// 8259D9D0: 4BD22EC1  bl 0x822c0890
	ctx.lr = 0x8259D9D4;
	sub_822C0890(ctx, base);
	// 8259D9D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259D9D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259D9DC: 419A0008  beq cr6, 0x8259d9e4
	if ctx.cr[6].eq {
	pc = 0x8259D9E4; continue 'dispatch;
	}
	// 8259D9E0: 4BD22EB1  bl 0x822c0890
	ctx.lr = 0x8259D9E4;
	sub_822C0890(ctx, base);
	// 8259D9E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D9E8: 4BFFF819  bl 0x8259d200
	ctx.lr = 0x8259D9EC;
	sub_8259D200(ctx, base);
	// 8259D9EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259D9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259DA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259DA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259DA08 size=352
    let mut pc: u32 = 0x8259DA08;
    'dispatch: loop {
        match pc {
            0x8259DA08 => {
    //   block [0x8259DA08..0x8259DB68)
	// 8259DA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259DA0C: 48C0A75D  bl 0x831a8168
	ctx.lr = 0x8259DA10;
	sub_831A8130(ctx, base);
	// 8259DA10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259DA14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259DA18: 4BFFDEE1  bl 0x8259b8f8
	ctx.lr = 0x8259DA1C;
	sub_8259B8F8(ctx, base);
	// 8259DA1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259DA20: 809E015C  lwz r4, 0x15c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259DA24: 481FEEBD  bl 0x8279c8e0
	ctx.lr = 0x8259DA28;
	sub_8279C8E0(ctx, base);
	// 8259DA28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259DA2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259DA30: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259DA34: 38A00226  li r5, 0x226
	ctx.r[5].s64 = 550;
	// 8259DA38: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 8259DA3C: 488549AD  bl 0x82df23e8
	ctx.lr = 0x8259DA40;
	sub_82DF23E8(ctx, base);
	// 8259DA40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259DA44: 41820010  beq 0x8259da54
	if ctx.cr[0].eq {
	pc = 0x8259DA54; continue 'dispatch;
	}
	// 8259DA48: 481FDD61  bl 0x8279b7a8
	ctx.lr = 0x8259DA4C;
	sub_8279B7A8(ctx, base);
	// 8259DA4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259DA50: 48000008  b 0x8259da58
	pc = 0x8259DA58; continue 'dispatch;
	// 8259DA54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259DA58: 3BFE0164  addi r31, r30, 0x164
	ctx.r[31].s64 = ctx.r[30].s64 + 356;
	// 8259DA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DA60: 4BFFE1E1  bl 0x8259bc40
	ctx.lr = 0x8259DA64;
	sub_8259BC40(ctx, base);
	// 8259DA64: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259DA68: 807E0164  lwz r3, 0x164(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DA6C: 481FDE5D  bl 0x8279b8c8
	ctx.lr = 0x8259DA70;
	sub_8279B8C8(ctx, base);
	// 8259DA70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259DA74: 807E0164  lwz r3, 0x164(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DA78: 481FB221  bl 0x82798c98
	ctx.lr = 0x8259DA7C;
	sub_82798C98(ctx, base);
	// 8259DA7C: 807E0164  lwz r3, 0x164(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DA80: 481FBC21  bl 0x827996a0
	ctx.lr = 0x8259DA84;
	sub_827996A0(ctx, base);
	// 8259DA84: 817E0168  lwz r11, 0x168(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 8259DA88: 815E0164  lwz r10, 0x164(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DA8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DA90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259DA94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259DA98: 419A0024  beq cr6, 0x8259dabc
	if ctx.cr[6].eq {
	pc = 0x8259DABC; continue 'dispatch;
	}
	// 8259DA9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259DAA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259DAA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DAA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259DAAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259DAB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DAB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DAB8: 4082FFE8  bne 0x8259daa0
	if !ctx.cr[0].eq {
	pc = 0x8259DAA0; continue 'dispatch;
	}
	// 8259DABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259DAC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259DAC4: 4BF71A05  bl 0x8250f4c8
	ctx.lr = 0x8259DAC8;
	sub_8250F4C8(ctx, base);
	// 8259DAC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DAD0: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 8259DAD4: 409A0008  bne cr6, 0x8259dadc
	if !ctx.cr[6].eq {
	pc = 0x8259DADC; continue 'dispatch;
	}
	// 8259DAD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259DADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259DAE0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8259DAE4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 8259DAE8: 4BF71A31  bl 0x8250f518
	ctx.lr = 0x8259DAEC;
	sub_8250F518(ctx, base);
	// 8259DAEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259DAF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259DAF4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8259DAF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259DAFC: 4BF6FA0D  bl 0x8250d508
	ctx.lr = 0x8259DB00;
	sub_8250D508(ctx, base);
	// 8259DB00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259DB04: 4885418D  bl 0x82df1c90
	ctx.lr = 0x8259DB08;
	sub_82DF1C90(ctx, base);
	// 8259DB08: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8259DB0C: 48854185  bl 0x82df1c90
	ctx.lr = 0x8259DB10;
	sub_82DF1C90(ctx, base);
	// 8259DB10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DB14: 481FBE75  bl 0x82799988
	ctx.lr = 0x8259DB18;
	sub_82799988(ctx, base);
	// 8259DB18: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DB1C: 481FBB15  bl 0x82799630
	ctx.lr = 0x8259DB20;
	sub_82799630(ctx, base);
	// 8259DB20: 38BE0140  addi r5, r30, 0x140
	ctx.r[5].s64 = ctx.r[30].s64 + 320;
	// 8259DB24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DB28: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DB2C: 4BFFF225  bl 0x8259cd50
	ctx.lr = 0x8259DB30;
	sub_8259CD50(ctx, base);
	// 8259DB30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DB34: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DB38: 4BFFFDF9  bl 0x8259d930
	ctx.lr = 0x8259DB3C;
	sub_8259D930(ctx, base);
	// 8259DB3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259DB40: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DB44: 481FC5A5  bl 0x8279a0e8
	ctx.lr = 0x8259DB48;
	sub_8279A0E8(ctx, base);
	// 8259DB48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DB4C: 4BFFCA55  bl 0x8259a5a0
	ctx.lr = 0x8259DB50;
	sub_8259A5A0(ctx, base);
	// 8259DB50: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259DB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DB58: 419A0008  beq cr6, 0x8259db60
	if ctx.cr[6].eq {
	pc = 0x8259DB60; continue 'dispatch;
	}
	// 8259DB5C: 4BD22D35  bl 0x822c0890
	ctx.lr = 0x8259DB60;
	sub_822C0890(ctx, base);
	// 8259DB60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259DB64: 48C0A654  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259DB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259DB68 size=860
    let mut pc: u32 = 0x8259DB68;
    'dispatch: loop {
        match pc {
            0x8259DB68 => {
    //   block [0x8259DB68..0x8259DEC4)
	// 8259DB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259DB6C: 48C0A5F1  bl 0x831a815c
	ctx.lr = 0x8259DB70;
	sub_831A8130(ctx, base);
	// 8259DB70: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8259DB74: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259DB78: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8259DB7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259DB80: 4BFFDD09  bl 0x8259b888
	ctx.lr = 0x8259DB84;
	sub_8259B888(ctx, base);
	// 8259DB84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259DB88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259DB8C: 5469063F  clrlwi. r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8259DB90: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259DB94: 3B2BA8A0  addi r25, r11, -0x5760
	ctx.r[25].s64 = ctx.r[11].s64 + -22368;
	// 8259DB98: 418200B4  beq 0x8259dc4c
	if ctx.cr[0].eq {
	pc = 0x8259DC4C; continue 'dispatch;
	}
	// 8259DB9C: 80BF0164  lwz r5, 0x164(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DBA0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8259DBA4: 419A00A8  beq cr6, 0x8259dc4c
	if ctx.cr[6].eq {
	pc = 0x8259DC4C; continue 'dispatch;
	}
	// 8259DBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259DBAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259DBB0: 4BFFF801  bl 0x8259d3b0
	ctx.lr = 0x8259DBB4;
	sub_8259D3B0(ctx, base);
	// 8259DBB4: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DBB8: 481FBEB1  bl 0x82799a68
	ctx.lr = 0x8259DBBC;
	sub_82799A68(ctx, base);
	// 8259DBBC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8259DBC0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259DBC4: 4BFFE0ED  bl 0x8259bcb0
	ctx.lr = 0x8259DBC8;
	sub_8259BCB0(ctx, base);
	// 8259DBC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DBCC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259DBD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DBD8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8259DBDC: 419A0024  beq cr6, 0x8259dc00
	if ctx.cr[6].eq {
	pc = 0x8259DC00; continue 'dispatch;
	}
	// 8259DBE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259DBE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259DBE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DBEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259DBF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259DBF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DBF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DBFC: 4082FFE8  bne 0x8259dbe4
	if !ctx.cr[0].eq {
	pc = 0x8259DBE4; continue 'dispatch;
	}
	// 8259DC00: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8259DC04: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259DC08: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8259DC0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259DC10: 38A00261  li r5, 0x261
	ctx.r[5].s64 = 609;
	// 8259DC14: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8259DC18: 488BAE29  bl 0x82e58a40
	ctx.lr = 0x8259DC1C;
	sub_82E58A40(ctx, base);
	// 8259DC1C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259DC20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DC24: 419A0008  beq cr6, 0x8259dc2c
	if ctx.cr[6].eq {
	pc = 0x8259DC2C; continue 'dispatch;
	}
	// 8259DC28: 4BD22C69  bl 0x822c0890
	ctx.lr = 0x8259DC2C;
	sub_822C0890(ctx, base);
	// 8259DC2C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8259DC30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DC34: 419A0008  beq cr6, 0x8259dc3c
	if ctx.cr[6].eq {
	pc = 0x8259DC3C; continue 'dispatch;
	}
	// 8259DC38: 4BD22C59  bl 0x822c0890
	ctx.lr = 0x8259DC3C;
	sub_822C0890(ctx, base);
	// 8259DC3C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259DC40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DC44: 419A0008  beq cr6, 0x8259dc4c
	if ctx.cr[6].eq {
	pc = 0x8259DC4C; continue 'dispatch;
	}
	// 8259DC48: 4BD22C49  bl 0x822c0890
	ctx.lr = 0x8259DC4C;
	sub_822C0890(ctx, base);
	// 8259DC4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259DC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DC54: 4BFFDC35  bl 0x8259b888
	ctx.lr = 0x8259DC58;
	sub_8259B888(ctx, base);
	// 8259DC58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259DC5C: 4182025C  beq 0x8259deb8
	if ctx.cr[0].eq {
	pc = 0x8259DEB8; continue 'dispatch;
	}
	// 8259DC60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259DC64: 3B7F0140  addi r27, r31, 0x140
	ctx.r[27].s64 = ctx.r[31].s64 + 320;
	// 8259DC68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259DC6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8259DC70: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8259DC74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259DC78: 4BFFE0B1  bl 0x8259bd28
	ctx.lr = 0x8259DC7C;
	sub_8259BD28(ctx, base);
	// 8259DC7C: 83410084  lwz r26, 0x84(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8259DC80: 83C10080  lwz r30, 0x80(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 8259DC84: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8259DC88: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 8259DC8C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8259DC90: 419A0024  beq cr6, 0x8259dcb4
	if ctx.cr[6].eq {
	pc = 0x8259DCB4; continue 'dispatch;
	}
	// 8259DC94: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 8259DC98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259DC9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DCA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259DCA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259DCA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DCAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DCB0: 4082FFE8  bne 0x8259dc98
	if !ctx.cr[0].eq {
	pc = 0x8259DC98; continue 'dispatch;
	}
	// 8259DCB4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259DCB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DCBC: 808BD054  lwz r4, -0x2fac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12204 as u32) ) } as u64;
	// 8259DCC0: 48855D49  bl 0x82df3a08
	ctx.lr = 0x8259DCC4;
	sub_82DF3A08(ctx, base);
	// 8259DCC4: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 8259DCC8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8259DCCC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8259DCD0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8259DCD4: 38A00268  li r5, 0x268
	ctx.r[5].s64 = 616;
	// 8259DCD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259DCDC: 488BB445  bl 0x82e59120
	ctx.lr = 0x8259DCE0;
	sub_82E59120(ctx, base);
	// 8259DCE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DCE4: 48855745  bl 0x82df3428
	ctx.lr = 0x8259DCE8;
	sub_82DF3428(ctx, base);
	// 8259DCE8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259DCEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DCF0: 419A0008  beq cr6, 0x8259dcf8
	if ctx.cr[6].eq {
	pc = 0x8259DCF8; continue 'dispatch;
	}
	// 8259DCF4: 4BD22B9D  bl 0x822c0890
	ctx.lr = 0x8259DCF8;
	sub_822C0890(ctx, base);
	// 8259DCF8: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8259DCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DD00: 419A01A8  beq cr6, 0x8259dea8
	if ctx.cr[6].eq {
	pc = 0x8259DEA8; continue 'dispatch;
	}
	// 8259DD04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259DD08: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8259DD0C: 488B8D55  bl 0x82e56a60
	ctx.lr = 0x8259DD10;
	sub_82E56A60(ctx, base);
	// 8259DD10: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259DD14: 3D408325  lis r10, -0x7cdb
	ctx.r[10].s64 = -2094727168;
	// 8259DD18: 809E0030  lwz r4, 0x30(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8259DD1C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DD20: 3BCB773C  addi r30, r11, 0x773c
	ctx.r[30].s64 = ctx.r[11].s64 + 30524;
	// 8259DD24: 3BAA2258  addi r29, r10, 0x2258
	ctx.r[29].s64 = ctx.r[10].s64 + 8792;
	// 8259DD28: 488C3639  bl 0x82e61360
	ctx.lr = 0x8259DD2C;
	sub_82E61360(ctx, base);
	// 8259DD2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259DD30: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259DD34: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8259DD38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259DD3C: 48C0C20D  bl 0x831a9f48
	ctx.lr = 0x8259DD40;
	sub_831A9F48(ctx, base);
	// 8259DD40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259DD44: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8259DD48: 48853F49  bl 0x82df1c90
	ctx.lr = 0x8259DD4C;
	sub_82DF1C90(ctx, base);
	// 8259DD4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259DD50: 419A0158  beq cr6, 0x8259dea8
	if ctx.cr[6].eq {
	pc = 0x8259DEA8; continue 'dispatch;
	}
	// 8259DD54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DD58: 4BFFDBA1  bl 0x8259b8f8
	ctx.lr = 0x8259DD5C;
	sub_8259B8F8(ctx, base);
	// 8259DD5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259DD60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259DD64: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259DD68: 4BFFF649  bl 0x8259d3b0
	ctx.lr = 0x8259DD6C;
	sub_8259D3B0(ctx, base);
	// 8259DD6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259DD70: 3BDF0164  addi r30, r31, 0x164
	ctx.r[30].s64 = ctx.r[31].s64 + 356;
	// 8259DD74: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8259DD78: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8259DD7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DD80: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 8259DD84: 4BD266DD  bl 0x822c4460
	ctx.lr = 0x8259DD88;
	sub_822C4460(ctx, base);
	// 8259DD88: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8259DD8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DD90: 419A0008  beq cr6, 0x8259dd98
	if ctx.cr[6].eq {
	pc = 0x8259DD98; continue 'dispatch;
	}
	// 8259DD94: 4BD22AFD  bl 0x822c0890
	ctx.lr = 0x8259DD98;
	sub_822C0890(ctx, base);
	// 8259DD98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259DD9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DDA0: 481FC349  bl 0x8279a0e8
	ctx.lr = 0x8259DDA4;
	sub_8279A0E8(ctx, base);
	// 8259DDA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DDA8: 48231431  bl 0x827cf1d8
	ctx.lr = 0x8259DDAC;
	sub_827CF1D8(ctx, base);
	// 8259DDAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259DDB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DDB4: 48855C55  bl 0x82df3a08
	ctx.lr = 0x8259DDB8;
	sub_82DF3A08(ctx, base);
	// 8259DDB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259DDBC: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259DDC0: 481FEB59  bl 0x8279c918
	ctx.lr = 0x8259DDC4;
	sub_8279C918(ctx, base);
	// 8259DDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DDC8: 48855661  bl 0x82df3428
	ctx.lr = 0x8259DDCC;
	sub_82DF3428(ctx, base);
	// 8259DDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DDD0: 4BFFC7D1  bl 0x8259a5a0
	ctx.lr = 0x8259DDD4;
	sub_8259A5A0(ctx, base);
	// 8259DDD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259DDD8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259DDDC: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DDE0: 4BFFEE01  bl 0x8259cbe0
	ctx.lr = 0x8259DDE4;
	sub_8259CBE0(ctx, base);
	// 8259DDE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259DDE8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 8259DDEC: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259DDF0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8259DDF4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259DEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259DEC8 size=404
    let mut pc: u32 = 0x8259DEC8;
    'dispatch: loop {
        match pc {
            0x8259DEC8 => {
    //   block [0x8259DEC8..0x8259E05C)
	// 8259DEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259DECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259DED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259DED4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259DED8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259DEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259DEE0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8259DEE4: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DEE8: 481FB551  bl 0x82799438
	ctx.lr = 0x8259DEEC;
	sub_82799438(ctx, base);
	// 8259DEEC: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 8259DEF0: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8259DEF4: 4198001C  blt cr6, 0x8259df10
	if ctx.cr[6].lt {
	pc = 0x8259DF10; continue 'dispatch;
	}
	// 8259DEF8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8259DEFC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259DF00: 48002DC1  bl 0x825a0cc0
	ctx.lr = 0x8259DF04;
	sub_825A0CC0(ctx, base);
	// 8259DF04: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DF08: 481FB631  bl 0x82799538
	ctx.lr = 0x8259DF0C;
	sub_82799538(ctx, base);
	// 8259DF0C: 48000138  b 0x8259e044
	pc = 0x8259E044; continue 'dispatch;
	// 8259DF10: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8259DF14: 409A0014  bne cr6, 0x8259df28
	if !ctx.cr[6].eq {
	pc = 0x8259DF28; continue 'dispatch;
	}
	// 8259DF18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DF1C: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DF20: 4BFFFA11  bl 0x8259d930
	ctx.lr = 0x8259DF24;
	sub_8259D930(ctx, base);
	// 8259DF24: 48000120  b 0x8259e044
	pc = 0x8259E044; continue 'dispatch;
	// 8259DF28: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8259DF2C: 409A002C  bne cr6, 0x8259df58
	if !ctx.cr[6].eq {
	pc = 0x8259DF58; continue 'dispatch;
	}
	// 8259DF30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259DF34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259DF38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259DF3C: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259DF40: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259DF44: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8259DF48: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8259DF4C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8259DF50: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8259DF54: 48000060  b 0x8259dfb4
	pc = 0x8259DFB4; continue 'dispatch;
	// 8259DF58: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8259DF5C: 409A002C  bne cr6, 0x8259df88
	if !ctx.cr[6].eq {
	pc = 0x8259DF88; continue 'dispatch;
	}
	// 8259DF60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259DF64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259DF68: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259DF6C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259DF70: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259DF74: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8259DF78: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8259DF7C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8259DF80: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8259DF84: 48000030  b 0x8259dfb4
	pc = 0x8259DFB4; continue 'dispatch;
	// 8259DF88: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8259DF8C: 409A0050  bne cr6, 0x8259dfdc
	if !ctx.cr[6].eq {
	pc = 0x8259DFDC; continue 'dispatch;
	}
	// 8259DF90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259DF94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259DF98: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8259DF9C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259DFA0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259DFA4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8259DFA8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8259DFAC: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8259DFB0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8259DFB4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8259DFB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259DFBC: C029D96C  lfs f1, -0x2694(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-9876 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259DFC0: 488DEC81  bl 0x82e7cc40
	ctx.lr = 0x8259DFC4;
	sub_82E7CC40(ctx, base);
	// 8259DFC4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8259DFC8: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DFCC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8259DFD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DFD4: 4BFFEEFD  bl 0x8259ced0
	ctx.lr = 0x8259DFD8;
	sub_8259CED0(ctx, base);
	// 8259DFD8: 4800006C  b 0x8259e044
	pc = 0x8259E044; continue 'dispatch;
	// 8259DFDC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8259DFE0: 409A0020  bne cr6, 0x8259e000
	if !ctx.cr[6].eq {
	pc = 0x8259E000; continue 'dispatch;
	}
	// 8259DFE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259DFE8: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259DFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DFF0: C00B964C  lfs f0, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259DFF4: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 8259DFF8: 4BFFF079  bl 0x8259d070
	ctx.lr = 0x8259DFFC;
	sub_8259D070(ctx, base);
	// 8259DFFC: 48000048  b 0x8259e044
	pc = 0x8259E044; continue 'dispatch;
	// 8259E000: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8259E004: 409A0028  bne cr6, 0x8259e02c
	if !ctx.cr[6].eq {
	pc = 0x8259E02C; continue 'dispatch;
	}
	// 8259E008: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E00C: 481FB42D  bl 0x82799438
	ctx.lr = 0x8259E010;
	sub_82799438(ctx, base);
	// 8259E010: 48003309  bl 0x825a1318
	ctx.lr = 0x8259E014;
	sub_825A1318(ctx, base);
	// 8259E014: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E01C: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E020: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259E024: 4BFFF115  bl 0x8259d138
	ctx.lr = 0x8259E028;
	sub_8259D138(ctx, base);
	// 8259E028: 4800001C  b 0x8259e044
	pc = 0x8259E044; continue 'dispatch;
	// 8259E02C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E030: 409A0014  bne cr6, 0x8259e044
	if !ctx.cr[6].eq {
	pc = 0x8259E044; continue 'dispatch;
	}
	// 8259E034: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259E038: 481FDC79  bl 0x8279bcb0
	ctx.lr = 0x8259E03C;
	sub_8279BCB0(ctx, base);
	// 8259E03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E040: 4BFFF9C9  bl 0x8259da08
	ctx.lr = 0x8259E044;
	sub_8259DA08(ctx, base);
	// 8259E044: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8259E048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E04C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E050: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259E054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259E058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259E060 size=360
    let mut pc: u32 = 0x8259E060;
    'dispatch: loop {
        match pc {
            0x8259E060 => {
    //   block [0x8259E060..0x8259E1C8)
	// 8259E060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E06C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259E070: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E078: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8259E07C: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E080: 481FB3B9  bl 0x82799438
	ctx.lr = 0x8259E084;
	sub_82799438(ctx, base);
	// 8259E084: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 8259E088: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8259E08C: 4198001C  blt cr6, 0x8259e0a8
	if ctx.cr[6].lt {
	pc = 0x8259E0A8; continue 'dispatch;
	}
	// 8259E090: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8259E094: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E098: 48004671  bl 0x825a2708
	ctx.lr = 0x8259E09C;
	sub_825A2708(ctx, base);
	// 8259E09C: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E0A0: 481FB499  bl 0x82799538
	ctx.lr = 0x8259E0A4;
	sub_82799538(ctx, base);
	// 8259E0A4: 4800010C  b 0x8259e1b0
	pc = 0x8259E1B0; continue 'dispatch;
	// 8259E0A8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8259E0AC: 409A0014  bne cr6, 0x8259e0c0
	if !ctx.cr[6].eq {
	pc = 0x8259E0C0; continue 'dispatch;
	}
	// 8259E0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E0B4: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E0B8: 4BFFF879  bl 0x8259d930
	ctx.lr = 0x8259E0BC;
	sub_8259D930(ctx, base);
	// 8259E0BC: 480000F4  b 0x8259e1b0
	pc = 0x8259E1B0; continue 'dispatch;
	// 8259E0C0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8259E0C4: 409A002C  bne cr6, 0x8259e0f0
	if !ctx.cr[6].eq {
	pc = 0x8259E0F0; continue 'dispatch;
	}
	// 8259E0C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E0CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259E0D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259E0D4: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259E0D8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E0DC: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8259E0E0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8259E0E4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8259E0E8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8259E0EC: 48000060  b 0x8259e14c
	pc = 0x8259E14C; continue 'dispatch;
	// 8259E0F0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8259E0F4: 409A002C  bne cr6, 0x8259e120
	if !ctx.cr[6].eq {
	pc = 0x8259E120; continue 'dispatch;
	}
	// 8259E0F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E0FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259E100: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259E104: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E108: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259E10C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8259E110: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8259E114: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8259E118: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8259E11C: 48000030  b 0x8259e14c
	pc = 0x8259E14C; continue 'dispatch;
	// 8259E120: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8259E124: 409A0050  bne cr6, 0x8259e174
	if !ctx.cr[6].eq {
	pc = 0x8259E174; continue 'dispatch;
	}
	// 8259E128: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E12C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259E130: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8259E134: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E138: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259E13C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8259E140: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8259E144: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8259E148: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8259E14C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8259E150: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259E154: C0291A38  lfs f1, 0x1a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259E158: 488DEAE9  bl 0x82e7cc40
	ctx.lr = 0x8259E15C;
	sub_82E7CC40(ctx, base);
	// 8259E15C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8259E160: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E164: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8259E168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E16C: 4BFFED65  bl 0x8259ced0
	ctx.lr = 0x8259E170;
	sub_8259CED0(ctx, base);
	// 8259E170: 48000040  b 0x8259e1b0
	pc = 0x8259E1B0; continue 'dispatch;
	// 8259E174: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8259E178: 409A0020  bne cr6, 0x8259e198
	if !ctx.cr[6].eq {
	pc = 0x8259E198; continue 'dispatch;
	}
	// 8259E17C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259E180: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E188: C00B0B54  lfs f0, 0xb54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E18C: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 8259E190: 4BFFEEE1  bl 0x8259d070
	ctx.lr = 0x8259E194;
	sub_8259D070(ctx, base);
	// 8259E194: 4800001C  b 0x8259e1b0
	pc = 0x8259E1B0; continue 'dispatch;
	// 8259E198: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E19C: 409A0014  bne cr6, 0x8259e1b0
	if !ctx.cr[6].eq {
	pc = 0x8259E1B0; continue 'dispatch;
	}
	// 8259E1A0: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259E1A4: 481FDB4D  bl 0x8279bcf0
	ctx.lr = 0x8259E1A8;
	sub_8279BCF0(ctx, base);
	// 8259E1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E1AC: 4BFFF85D  bl 0x8259da08
	ctx.lr = 0x8259E1B0;
	sub_8259DA08(ctx, base);
	// 8259E1B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8259E1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E1BC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259E1C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259E1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259E1C8 size=224
    let mut pc: u32 = 0x8259E1C8;
    'dispatch: loop {
        match pc {
            0x8259E1C8 => {
    //   block [0x8259E1C8..0x8259E2A8)
	// 8259E1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E1D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259E1D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E1D8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259E2A8 size=324
    let mut pc: u32 = 0x8259E2A8;
    'dispatch: loop {
        match pc {
            0x8259E2A8 => {
    //   block [0x8259E2A8..0x8259E3EC)
	// 8259E2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E2B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E2B4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8259E2B8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259E2BC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E2C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259E2C8: 38DF0140  addi r6, r31, 0x140
	ctx.r[6].s64 = ctx.r[31].s64 + 320;
	// 8259E2CC: 396BC5E0  addi r11, r11, -0x3a20
	ctx.r[11].s64 = ctx.r[11].s64 + -14880;
	// 8259E2D0: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8259E2D4: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8259E2D8: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 8259E2DC: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8259E2E0: 13E030C7  vcmpequd (lvx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8259E2E4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8259E2E8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8259E2EC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E3F0 size=100
    let mut pc: u32 = 0x8259E3F0;
    'dispatch: loop {
        match pc {
            0x8259E3F0 => {
    //   block [0x8259E3F0..0x8259E454)
	// 8259E3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E3F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E3FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E404: 48BB61FD  bl 0x83154600
	ctx.lr = 0x8259E408;
	sub_83154600(ctx, base);
	// 8259E408: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E40C: 91630150  stw r11, 0x150(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 8259E410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E414: 48BB61ED  bl 0x83154600
	ctx.lr = 0x8259E418;
	sub_83154600(ctx, base);
	// 8259E418: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E41C: 99630154  stb r11, 0x154(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), ctx.r[11].u8 ) };
	// 8259E420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E424: 48BB61DD  bl 0x83154600
	ctx.lr = 0x8259E428;
	sub_83154600(ctx, base);
	// 8259E428: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259E42C: 8063015C  lwz r3, 0x15c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259E430: 48617F29  bl 0x82bb6358
	ctx.lr = 0x8259E434;
	sub_82BB6358(ctx, base);
	// 8259E434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E438: 48BB61C9  bl 0x83154600
	ctx.lr = 0x8259E43C;
	sub_83154600(ctx, base);
	// 8259E43C: 4BFFF5CD  bl 0x8259da08
	ctx.lr = 0x8259E440;
	sub_8259DA08(ctx, base);
	// 8259E440: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259E444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E44C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259E450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259E458 size=364
    let mut pc: u32 = 0x8259E458;
    'dispatch: loop {
        match pc {
            0x8259E458 => {
    //   block [0x8259E458..0x8259E5C4)
	// 8259E458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E464: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8259E468: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259E46C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E474: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8259E478: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259E47C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E480: 419A0128  beq cr6, 0x8259e5a8
	if ctx.cr[6].eq {
	pc = 0x8259E5A8; continue 'dispatch;
	}
	// 8259E484: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E488: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8259E48C: C3EB08A8  lfs f31, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259E490: 4BEE2A91  bl 0x82480f20
	ctx.lr = 0x8259E494;
	sub_82480F20(ctx, base);
	// 8259E494: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E498: 4182000C  beq 0x8259e4a4
	if ctx.cr[0].eq {
	pc = 0x8259E4A4; continue 'dispatch;
	}
	// 8259E49C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8259E4A0: C3EB89AC  lfs f31, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259E4A4: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 8259E4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E4AC: 4BFFD3DD  bl 0x8259b888
	ctx.lr = 0x8259E4B0;
	sub_8259B888(ctx, base);
	// 8259E4B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E4B8: 4182000C  beq 0x8259e4c4
	if ctx.cr[0].eq {
	pc = 0x8259E4C4; continue 'dispatch;
	}
	// 8259E4BC: 4BFFC135  bl 0x8259a5f0
	ctx.lr = 0x8259E4C0;
	sub_8259A5F0(ctx, base);
	// 8259E4C0: 4800005C  b 0x8259e51c
	pc = 0x8259E51C; continue 'dispatch;
	// 8259E4C4: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 8259E4C8: 4BFFD3C1  bl 0x8259b888
	ctx.lr = 0x8259E4CC;
	sub_8259B888(ctx, base);
	// 8259E4CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E4D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E4D4: 4182000C  beq 0x8259e4e0
	if ctx.cr[0].eq {
	pc = 0x8259E4E0; continue 'dispatch;
	}
	// 8259E4D8: 4BFFC171  bl 0x8259a648
	ctx.lr = 0x8259E4DC;
	sub_8259A648(ctx, base);
	// 8259E4DC: 48000040  b 0x8259e51c
	pc = 0x8259E51C; continue 'dispatch;
	// 8259E4E0: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 8259E4E4: 4BFFD3A5  bl 0x8259b888
	ctx.lr = 0x8259E4E8;
	sub_8259B888(ctx, base);
	// 8259E4E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E4F0: 41820010  beq 0x8259e500
	if ctx.cr[0].eq {
	pc = 0x8259E500; continue 'dispatch;
	}
	// 8259E4F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E4F8: 4BFFF9D1  bl 0x8259dec8
	ctx.lr = 0x8259E4FC;
	sub_8259DEC8(ctx, base);
	// 8259E4FC: 48000020  b 0x8259e51c
	pc = 0x8259E51C; continue 'dispatch;
	// 8259E500: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 8259E504: 4BFFD385  bl 0x8259b888
	ctx.lr = 0x8259E508;
	sub_8259B888(ctx, base);
	// 8259E508: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E50C: 41820010  beq 0x8259e51c
	if ctx.cr[0].eq {
	pc = 0x8259E51C; continue 'dispatch;
	}
	// 8259E510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E514: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E518: 4BFFFB49  bl 0x8259e060
	ctx.lr = 0x8259E51C;
	sub_8259E060(ctx, base);
	// 8259E51C: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 8259E520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E524: 4BEE29FD  bl 0x82480f20
	ctx.lr = 0x8259E528;
	sub_82480F20(ctx, base);
	// 8259E528: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E52C: 41820030  beq 0x8259e55c
	if ctx.cr[0].eq {
	pc = 0x8259E55C; continue 'dispatch;
	}
	// 8259E530: C01F016C  lfs f0, 0x16c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E534: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259E538: EDBE002A  fadds f13, f30, f0
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 8259E53C: D1BF016C  stfs f13, 0x16c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8259E540: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E544: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8259E548: 40990060  ble cr6, 0x8259e5a8
	if !ctx.cr[6].gt {
	pc = 0x8259E5A8; continue 'dispatch;
	}
	// 8259E54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E550: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E554: 4BFFF975  bl 0x8259dec8
	ctx.lr = 0x8259E558;
	sub_8259DEC8(ctx, base);
	// 8259E558: 48000050  b 0x8259e5a8
	pc = 0x8259E5A8; continue 'dispatch;
	// 8259E55C: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 8259E560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E564: 4BEE29BD  bl 0x82480f20
	ctx.lr = 0x8259E568;
	sub_82480F20(ctx, base);
	// 8259E568: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E56C: 41820030  beq 0x8259e59c
	if ctx.cr[0].eq {
	pc = 0x8259E59C; continue 'dispatch;
	}
	// 8259E570: C01F016C  lfs f0, 0x16c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E574: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259E578: EDBE002A  fadds f13, f30, f0
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 8259E57C: D1BF016C  stfs f13, 0x16c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8259E580: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E584: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8259E588: 40990020  ble cr6, 0x8259e5a8
	if !ctx.cr[6].gt {
	pc = 0x8259E5A8; continue 'dispatch;
	}
	// 8259E58C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E590: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E594: 4BFFFACD  bl 0x8259e060
	ctx.lr = 0x8259E598;
	sub_8259E060(ctx, base);
	// 8259E598: 48000010  b 0x8259e5a8
	pc = 0x8259E5A8; continue 'dispatch;
	// 8259E59C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E5A0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E5A4: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8259E5A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259E5AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E5B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E5B4: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8259E5B8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259E5BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259E5C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E5C8 size=176
    let mut pc: u32 = 0x8259E5C8;
    'dispatch: loop {
        match pc {
            0x8259E5C8 => {
    //   block [0x8259E5C8..0x8259E678)
	// 8259E5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E5CC: 48C09BA1  bl 0x831a816c
	ctx.lr = 0x8259E5D0;
	sub_831A8130(ctx, base);
	// 8259E5D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E5D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259E5DC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 8259E5E0: 396BA918  addi r11, r11, -0x56e8
	ctx.r[11].s64 = ctx.r[11].s64 + -22248;
	// 8259E5E4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8259E5E8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 8259E5EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259E5F0: 394AA8F4  addi r10, r10, -0x570c
	ctx.r[10].s64 = ctx.r[10].s64 + -22284;
	// 8259E5F4: 3929A8E4  addi r9, r9, -0x571c
	ctx.r[9].s64 = ctx.r[9].s64 + -22300;
	// 8259E5F8: 3968A908  addi r11, r8, -0x56f8
	ctx.r[11].s64 = ctx.r[8].s64 + -22264;
	// 8259E5FC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8259E600: 913F00C4  stw r9, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 8259E604: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 8259E608: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 8259E60C: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 8259E610: 3BBF00CC  addi r29, r31, 0xcc
	ctx.r[29].s64 = ctx.r[31].s64 + 204;
	// 8259E614: 4BE33DD5  bl 0x823d23e8
	ctx.lr = 0x8259E618;
	sub_823D23E8(ctx, base);
	// 8259E618: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 8259E61C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E620: 419A0008  beq cr6, 0x8259e628
	if ctx.cr[6].eq {
	pc = 0x8259E628; continue 'dispatch;
	}
	// 8259E624: 4BD2226D  bl 0x822c0890
	ctx.lr = 0x8259E628;
	sub_822C0890(ctx, base);
	// 8259E628: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 8259E62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E630: 419A0008  beq cr6, 0x8259e638
	if ctx.cr[6].eq {
	pc = 0x8259E638; continue 'dispatch;
	}
	// 8259E634: 4BD2225D  bl 0x822c0890
	ctx.lr = 0x8259E638;
	sub_822C0890(ctx, base);
	// 8259E638: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 8259E63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E640: 419A0008  beq cr6, 0x8259e648
	if ctx.cr[6].eq {
	pc = 0x8259E648; continue 'dispatch;
	}
	// 8259E644: 4BD2224D  bl 0x822c0890
	ctx.lr = 0x8259E648;
	sub_822C0890(ctx, base);
	// 8259E648: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 8259E64C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E650: 419A0008  beq cr6, 0x8259e658
	if ctx.cr[6].eq {
	pc = 0x8259E658; continue 'dispatch;
	}
	// 8259E654: 4BD2223D  bl 0x822c0890
	ctx.lr = 0x8259E658;
	sub_822C0890(ctx, base);
	// 8259E658: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259E65C: 488BF1ED  bl 0x82e5d848
	ctx.lr = 0x8259E660;
	sub_82E5D848(ctx, base);
	// 8259E660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E664: 4887388D  bl 0x82e11ef0
	ctx.lr = 0x8259E668;
	sub_82E11EF0(ctx, base);
	// 8259E668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E66C: 4BF72B2D  bl 0x82511198
	ctx.lr = 0x8259E670;
	sub_82511198(ctx, base);
	// 8259E670: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259E674: 48C09B48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259E678 size=8
    let mut pc: u32 = 0x8259E678;
    'dispatch: loop {
        match pc {
            0x8259E678 => {
    //   block [0x8259E678..0x8259E680)
	// 8259E678: 3863FF34  addi r3, r3, -0xcc
	ctx.r[3].s64 = ctx.r[3].s64 + -204;
	// 8259E67C: 48000874  b 0x8259eef0
	sub_8259EEF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259E680 size=8
    let mut pc: u32 = 0x8259E680;
    'dispatch: loop {
        match pc {
            0x8259E680 => {
    //   block [0x8259E680..0x8259E688)
	// 8259E680: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8259E684: 4800086C  b 0x8259eef0
	sub_8259EEF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259E688 size=8
    let mut pc: u32 = 0x8259E688;
    'dispatch: loop {
        match pc {
            0x8259E688 => {
    //   block [0x8259E688..0x8259E690)
	// 8259E688: 3863FF3C  addi r3, r3, -0xc4
	ctx.r[3].s64 = ctx.r[3].s64 + -196;
	// 8259E68C: 48000864  b 0x8259eef0
	sub_8259EEF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259E690 size=1472
    let mut pc: u32 = 0x8259E690;
    'dispatch: loop {
        match pc {
            0x8259E690 => {
    //   block [0x8259E690..0x8259EC50)
	// 8259E690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E694: 48C09AD5  bl 0x831a8168
	ctx.lr = 0x8259E698;
	sub_831A8130(ctx, base);
	// 8259E698: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8259E69C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E6A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259E6A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8259E6A8: 4BFFFB21  bl 0x8259e1c8
	ctx.lr = 0x8259E6AC;
	sub_8259E1C8(ctx, base);
	// 8259E6AC: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 8259E6B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E6B4: 4BEE286D  bl 0x82480f20
	ctx.lr = 0x8259E6B8;
	sub_82480F20(ctx, base);
	// 8259E6B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E6BC: 41820018  beq 0x8259e6d4
	if ctx.cr[0].eq {
	pc = 0x8259E6D4; continue 'dispatch;
	}
	// 8259E6C0: 38800400  li r4, 0x400
	ctx.r[4].s64 = 1024;
	// 8259E6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E6C8: 4BFFD1C1  bl 0x8259b888
	ctx.lr = 0x8259E6CC;
	sub_8259B888(ctx, base);
	// 8259E6CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E6D0: 4082002C  bne 0x8259e6fc
	if !ctx.cr[0].eq {
	pc = 0x8259E6FC; continue 'dispatch;
	}
	// 8259E6D4: 38800400  li r4, 0x400
	ctx.r[4].s64 = 1024;
	// 8259E6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E6DC: 4BEE2845  bl 0x82480f20
	ctx.lr = 0x8259E6E0;
	sub_82480F20(ctx, base);
	// 8259E6E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E6E4: 41820100  beq 0x8259e7e4
	if ctx.cr[0].eq {
	pc = 0x8259E7E4; continue 'dispatch;
	}
	// 8259E6E8: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 8259E6EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E6F0: 4BFFD199  bl 0x8259b888
	ctx.lr = 0x8259E6F4;
	sub_8259B888(ctx, base);
	// 8259E6F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E6F8: 418200EC  beq 0x8259e7e4
	if ctx.cr[0].eq {
	pc = 0x8259E7E4; continue 'dispatch;
	}
	// 8259E6FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259E700: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259E704: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259E708: 38A00134  li r5, 0x134
	ctx.r[5].s64 = 308;
	// 8259E70C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8259E710: 48853CD9  bl 0x82df23e8
	ctx.lr = 0x8259E714;
	sub_82DF23E8(ctx, base);
	// 8259E714: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259E718: 4182001C  beq 0x8259e734
	if ctx.cr[0].eq {
	pc = 0x8259E734; continue 'dispatch;
	}
	// 8259E71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E720: 488BE209  bl 0x82e5c928
	ctx.lr = 0x8259E724;
	sub_82E5C928(ctx, base);
	// 8259E724: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259E728: 396BA7D4  addi r11, r11, -0x582c
	ctx.r[11].s64 = ctx.r[11].s64 + -22572;
	// 8259E72C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259E730: 48000008  b 0x8259e738
	pc = 0x8259E738; continue 'dispatch;
	// 8259E734: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259E738: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8259E73C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259E740: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259E744: 4BFFC045  bl 0x8259a788
	ctx.lr = 0x8259E748;
	sub_8259A788(ctx, base);
	// 8259E748: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259E74C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259E750: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259E754: 4BD218AD  bl 0x822c0000
	ctx.lr = 0x8259E758;
	sub_822C0000(ctx, base);
	// 8259E758: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259E75C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259E760: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259E764: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8259E768: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259E76C: 419A0024  beq cr6, 0x8259e790
	if ctx.cr[6].eq {
	pc = 0x8259E790; continue 'dispatch;
	}
	// 8259E770: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8259E774: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259E778: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E77C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259E780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259E784: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259E788: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E78C: 4082FFE8  bne 0x8259e774
	if !ctx.cr[0].eq {
	pc = 0x8259E774; continue 'dispatch;
	}
	// 8259E790: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E794: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8259E798: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259E79C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8259E7A0: 389E00CC  addi r4, r30, 0xcc
	ctx.r[4].s64 = ctx.r[30].s64 + 204;
	// 8259E7A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259E7A8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259E7AC: 488BFFD5  bl 0x82e5e780
	ctx.lr = 0x8259E7B0;
	sub_82E5E780(ctx, base);
	// 8259E7B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8259E7B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E7B8: 419A0008  beq cr6, 0x8259e7c0
	if ctx.cr[6].eq {
	pc = 0x8259E7C0; continue 'dispatch;
	}
	// 8259E7BC: 4BD220D5  bl 0x822c0890
	ctx.lr = 0x8259E7C0;
	sub_822C0890(ctx, base);
	// 8259E7C0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259E7C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E7C8: 419A0008  beq cr6, 0x8259e7d0
	if ctx.cr[6].eq {
	pc = 0x8259E7D0; continue 'dispatch;
	}
	// 8259E7CC: 4BD220C5  bl 0x822c0890
	ctx.lr = 0x8259E7D0;
	sub_822C0890(ctx, base);
	// 8259E7D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259E7D4: 419A0470  beq cr6, 0x8259ec44
	if ctx.cr[6].eq {
	pc = 0x8259EC44; continue 'dispatch;
	}
	// 8259E7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E7DC: 4BD220B5  bl 0x822c0890
	ctx.lr = 0x8259E7E0;
	sub_822C0890(ctx, base);
	// 8259E7E0: 48000464  b 0x8259ec44
	pc = 0x8259EC44; continue 'dispatch;
	// 8259E7E4: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 8259E7E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E7EC: 4BEE2735  bl 0x82480f20
	ctx.lr = 0x8259E7F0;
	sub_82480F20(ctx, base);
	// 8259E7F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E7F4: 4182004C  beq 0x8259e840
	if ctx.cr[0].eq {
	pc = 0x8259E840; continue 'dispatch;
	}
	// 8259E7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E7FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E800: 4BFFEDF9  bl 0x8259d5f8
	ctx.lr = 0x8259E804;
	sub_8259D5F8(ctx, base);
	// 8259E804: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 8259E808: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8259E80C: 419A0014  beq cr6, 0x8259e820
	if ctx.cr[6].eq {
	pc = 0x8259E820; continue 'dispatch;
	}
	// 8259E810: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E814: 409A000C  bne cr6, 0x8259e820
	if !ctx.cr[6].eq {
	pc = 0x8259E820; continue 'dispatch;
	}
	// 8259E818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E81C: 4BFFF34D  bl 0x8259db68
	ctx.lr = 0x8259E820;
	sub_8259DB68(ctx, base);
	// 8259E820: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8259E824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E828: 4BFFD061  bl 0x8259b888
	ctx.lr = 0x8259E82C;
	sub_8259B888(ctx, base);
	// 8259E82C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E830: 41820414  beq 0x8259ec44
	if ctx.cr[0].eq {
	pc = 0x8259EC44; continue 'dispatch;
	}
	// 8259E834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E838: 4BFFFA71  bl 0x8259e2a8
	ctx.lr = 0x8259E83C;
	sub_8259E2A8(ctx, base);
	// 8259E83C: 48000408  b 0x8259ec44
	pc = 0x8259EC44; continue 'dispatch;
	// 8259E840: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 8259E844: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8259E848: 409A00F8  bne cr6, 0x8259e940
	if !ctx.cr[6].eq {
	pc = 0x8259E940; continue 'dispatch;
	}
	// 8259E84C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259E850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E854: 4BEE26CD  bl 0x82480f20
	ctx.lr = 0x8259E858;
	sub_82480F20(ctx, base);
	// 8259E858: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E85C: 41820398  beq 0x8259ebf4
	if ctx.cr[0].eq {
	pc = 0x8259EBF4; continue 'dispatch;
	}
	// 8259E860: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8259E864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E868: 4BFFD021  bl 0x8259b888
	ctx.lr = 0x8259E86C;
	sub_8259B888(ctx, base);
	// 8259E86C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E870: 41820384  beq 0x8259ebf4
	if ctx.cr[0].eq {
	pc = 0x8259EBF4; continue 'dispatch;
	}
	// 8259E874: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259E878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259E87C: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259E880: 38A0014C  li r5, 0x14c
	ctx.r[5].s64 = 332;
	// 8259E884: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8259E888: 48853B61  bl 0x82df23e8
	ctx.lr = 0x8259E88C;
	sub_82DF23E8(ctx, base);
	// 8259E88C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259E890: 4182001C  beq 0x8259e8ac
	if ctx.cr[0].eq {
	pc = 0x8259E8AC; continue 'dispatch;
	}
	// 8259E894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E898: 488BE091  bl 0x82e5c928
	ctx.lr = 0x8259E89C;
	sub_82E5C928(ctx, base);
	// 8259E89C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259E8A0: 396BA7FC  addi r11, r11, -0x5804
	ctx.r[11].s64 = ctx.r[11].s64 + -22532;
	// 8259E8A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259E8A8: 48000008  b 0x8259e8b0
	pc = 0x8259E8B0; continue 'dispatch;
	// 8259E8AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259E8B0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8259E8B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259E8B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259E8BC: 4BFFBF95  bl 0x8259a850
	ctx.lr = 0x8259E8C0;
	sub_8259A850(ctx, base);
	// 8259E8C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259E8C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259E8C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259E8CC: 4BD21735  bl 0x822c0000
	ctx.lr = 0x8259E8D0;
	sub_822C0000(ctx, base);
	// 8259E8D0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259E8D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259E8D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259E8DC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8259E8E0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8259E8E4: 419A0024  beq cr6, 0x8259e908
	if ctx.cr[6].eq {
	pc = 0x8259E908; continue 'dispatch;
	}
	// 8259E8E8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8259E8EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259E8F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E8F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259E8F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259E8FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259E900: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E904: 4082FFE8  bne 0x8259e8ec
	if !ctx.cr[0].eq {
	pc = 0x8259E8EC; continue 'dispatch;
	}
	// 8259E908: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259E90C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8259E910: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259E914: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8259E918: 389E00CC  addi r4, r30, 0xcc
	ctx.r[4].s64 = ctx.r[30].s64 + 204;
	// 8259E91C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8259E920: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259E924: 488BFD85  bl 0x82e5e6a8
	ctx.lr = 0x8259E928;
	sub_82E5E6A8(ctx, base);
	// 8259E928: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259E92C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E930: 419A0008  beq cr6, 0x8259e938
	if ctx.cr[6].eq {
	pc = 0x8259E938; continue 'dispatch;
	}
	// 8259E934: 4BD21F5D  bl 0x822c0890
	ctx.lr = 0x8259E938;
	sub_822C0890(ctx, base);
	// 8259E938: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259E93C: 4800029C  b 0x8259ebd8
	pc = 0x8259EBD8; continue 'dispatch;
	// 8259E940: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E944: 409A02B0  bne cr6, 0x8259ebf4
	if !ctx.cr[6].eq {
	pc = 0x8259EBF4; continue 'dispatch;
	}
	// 8259E948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E94C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E950: 4BFFFB09  bl 0x8259e458
	ctx.lr = 0x8259E954;
	sub_8259E458(ctx, base);
	// 8259E954: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259E958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E95C: 4BEE25C5  bl 0x82480f20
	ctx.lr = 0x8259E960;
	sub_82480F20(ctx, base);
	// 8259E960: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8259E964: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259E968: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8259E96C: 5468063F  clrlwi. r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8259E970: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259E974: 3B8BA844  addi r28, r11, -0x57bc
	ctx.r[28].s64 = ctx.r[11].s64 + -22460;
	// 8259E978: 3BAAA8A0  addi r29, r10, -0x5760
	ctx.r[29].s64 = ctx.r[10].s64 + -22368;
	// 8259E97C: 418200EC  beq 0x8259ea68
	if ctx.cr[0].eq {
	pc = 0x8259EA68; continue 'dispatch;
	}
	// 8259E980: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8259E984: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E988: 4BFFCF01  bl 0x8259b888
	ctx.lr = 0x8259E98C;
	sub_8259B888(ctx, base);
	// 8259E98C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E990: 418200D8  beq 0x8259ea68
	if ctx.cr[0].eq {
	pc = 0x8259EA68; continue 'dispatch;
	}
	// 8259E994: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259E998: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259E99C: 38A00157  li r5, 0x157
	ctx.r[5].s64 = 343;
	// 8259E9A0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8259E9A4: 48853A45  bl 0x82df23e8
	ctx.lr = 0x8259E9A8;
	sub_82DF23E8(ctx, base);
	// 8259E9A8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259E9AC: 41820014  beq 0x8259e9c0
	if ctx.cr[0].eq {
	pc = 0x8259E9C0; continue 'dispatch;
	}
	// 8259E9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E9B4: 488BDF75  bl 0x82e5c928
	ctx.lr = 0x8259E9B8;
	sub_82E5C928(ctx, base);
	// 8259E9B8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8259E9BC: 48000008  b 0x8259e9c4
	pc = 0x8259E9C4; continue 'dispatch;
	// 8259E9C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259E9C4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8259E9C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259E9CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259E9D0: 4BFFBCF1  bl 0x8259a6c0
	ctx.lr = 0x8259E9D4;
	sub_8259A6C0(ctx, base);
	// 8259E9D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259E9D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259E9DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259E9E0: 4BD21621  bl 0x822c0000
	ctx.lr = 0x8259E9E4;
	sub_822C0000(ctx, base);
	// 8259E9E4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259E9E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259E9EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259E9F0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 8259E9F4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8259E9F8: 419A0024  beq cr6, 0x8259ea1c
	if ctx.cr[6].eq {
	pc = 0x8259EA1C; continue 'dispatch;
	}
	// 8259E9FC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8259EA00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259EA04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EA08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259EA0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259EA10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259EA14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EA18: 4082FFE8  bne 0x8259ea00
	if !ctx.cr[0].eq {
	pc = 0x8259EA00; continue 'dispatch;
	}
	// 8259EA1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8259EA20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259EA24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259EA28: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 8259EA2C: 389E00CC  addi r4, r30, 0xcc
	ctx.r[4].s64 = ctx.r[30].s64 + 204;
	// 8259EA30: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259EA34: 488BFC75  bl 0x82e5e6a8
	ctx.lr = 0x8259EA38;
	sub_82E5E6A8(ctx, base);
	// 8259EA38: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8259EA3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EA40: 419A0008  beq cr6, 0x8259ea48
	if ctx.cr[6].eq {
	pc = 0x8259EA48; continue 'dispatch;
	}
	// 8259EA44: 4BD21E4D  bl 0x822c0890
	ctx.lr = 0x8259EA48;
	sub_822C0890(ctx, base);
	// 8259EA48: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8259EA4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EA50: 419A0008  beq cr6, 0x8259ea58
	if ctx.cr[6].eq {
	pc = 0x8259EA58; continue 'dispatch;
	}
	// 8259EA54: 4BD21E3D  bl 0x822c0890
	ctx.lr = 0x8259EA58;
	sub_822C0890(ctx, base);
	// 8259EA58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259EA5C: 419A000C  beq cr6, 0x8259ea68
	if ctx.cr[6].eq {
	pc = 0x8259EA68; continue 'dispatch;
	}
	// 8259EA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EA64: 4BD21E2D  bl 0x822c0890
	ctx.lr = 0x8259EA68;
	sub_822C0890(ctx, base);
	// 8259EA68: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8259EA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EA70: 4BEE24B1  bl 0x82480f20
	ctx.lr = 0x8259EA74;
	sub_82480F20(ctx, base);
	// 8259EA74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EA78: 4182017C  beq 0x8259ebf4
	if ctx.cr[0].eq {
	pc = 0x8259EBF4; continue 'dispatch;
	}
	// 8259EA7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259EA80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EA84: 4BFFCE05  bl 0x8259b888
	ctx.lr = 0x8259EA88;
	sub_8259B888(ctx, base);
	// 8259EA88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EA8C: 41820168  beq 0x8259ebf4
	if ctx.cr[0].eq {
	pc = 0x8259EBF4; continue 'dispatch;
	}
	// 8259EA90: 3BFE0140  addi r31, r30, 0x140
	ctx.r[31].s64 = ctx.r[30].s64 + 320;
	// 8259EA94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259EA98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8259EA9C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8259EAA0: 4BEBA871  bl 0x82459310
	ctx.lr = 0x8259EAA4;
	sub_82459310(ctx, base);
	// 8259EAA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EAA8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8259EAAC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EAB4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8259EAB8: 419A0024  beq cr6, 0x8259eadc
	if ctx.cr[6].eq {
	pc = 0x8259EADC; continue 'dispatch;
	}
	// 8259EABC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259EAC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259EAC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EAC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259EACC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259EAD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259EAD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EAD8: 4082FFE8  bne 0x8259eac0
	if !ctx.cr[0].eq {
	pc = 0x8259EAC0; continue 'dispatch;
	}
	// 8259EADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EAE0: 80DE0134  lwz r6, 0x134(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(308 as u32) ) } as u64;
	// 8259EAE4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8259EAE8: 38A0015C  li r5, 0x15c
	ctx.r[5].s64 = 348;
	// 8259EAEC: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8259EAF0: 488B84F9  bl 0x82e56fe8
	ctx.lr = 0x8259EAF4;
	sub_82E56FE8(ctx, base);
	// 8259EAF4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259EAF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EAFC: 419A0008  beq cr6, 0x8259eb04
	if ctx.cr[6].eq {
	pc = 0x8259EB04; continue 'dispatch;
	}
	// 8259EB00: 4BD21D91  bl 0x822c0890
	ctx.lr = 0x8259EB04;
	sub_822C0890(ctx, base);
	// 8259EB04: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8259EB08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EB0C: 419A0008  beq cr6, 0x8259eb14
	if ctx.cr[6].eq {
	pc = 0x8259EB14; continue 'dispatch;
	}
	// 8259EB10: 4BD21D81  bl 0x822c0890
	ctx.lr = 0x8259EB14;
	sub_822C0890(ctx, base);
	// 8259EB14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259EB18: 807E012C  lwz r3, 0x12c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259EB1C: 48013FF5  bl 0x825b2b10
	ctx.lr = 0x8259EB20;
	sub_825B2B10(ctx, base);
	// 8259EB20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EB24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259EB28: 38A0015E  li r5, 0x15e
	ctx.r[5].s64 = 350;
	// 8259EB2C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8259EB30: 488538B9  bl 0x82df23e8
	ctx.lr = 0x8259EB34;
	sub_82DF23E8(ctx, base);
	// 8259EB34: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8259EB38: 41820014  beq 0x8259eb4c
	if ctx.cr[0].eq {
	pc = 0x8259EB4C; continue 'dispatch;
	}
	// 8259EB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EB40: 488BDDE9  bl 0x82e5c928
	ctx.lr = 0x8259EB44;
	sub_82E5C928(ctx, base);
	// 8259EB44: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8259EB48: 48000008  b 0x8259eb50
	pc = 0x8259EB50; continue 'dispatch;
	// 8259EB4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259EB50: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8259EB54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259EB58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259EB5C: 4BFFBB65  bl 0x8259a6c0
	ctx.lr = 0x8259EB60;
	sub_8259A6C0(ctx, base);
	// 8259EB60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259EB64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259EB68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259EB6C: 4BD21495  bl 0x822c0000
	ctx.lr = 0x8259EB70;
	sub_822C0000(ctx, base);
	// 8259EB70: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259EB74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259EB78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259EB7C: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 8259EB80: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8259EB84: 419A0024  beq cr6, 0x8259eba8
	if ctx.cr[6].eq {
	pc = 0x8259EBA8; continue 'dispatch;
	}
	// 8259EB88: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8259EB8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259EB90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EB94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259EB98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259EB9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259EBA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EBA4: 4082FFE8  bne 0x8259eb8c
	if !ctx.cr[0].eq {
	pc = 0x8259EB8C; continue 'dispatch;
	}
	// 8259EBA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8259EBAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259EBB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259EBB4: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 8259EBB8: 389E00CC  addi r4, r30, 0xcc
	ctx.r[4].s64 = ctx.r[30].s64 + 204;
	// 8259EBBC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259EBC0: 488BFAE9  bl 0x82e5e6a8
	ctx.lr = 0x8259EBC4;
	sub_82E5E6A8(ctx, base);
	// 8259EBC4: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8259EBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EBCC: 419A0008  beq cr6, 0x8259ebd4
	if ctx.cr[6].eq {
	pc = 0x8259EBD4; continue 'dispatch;
	}
	// 8259EBD0: 4BD21CC1  bl 0x822c0890
	ctx.lr = 0x8259EBD4;
	sub_822C0890(ctx, base);
	// 8259EBD4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8259EBD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EBDC: 419A0008  beq cr6, 0x8259ebe4
	if ctx.cr[6].eq {
	pc = 0x8259EBE4; continue 'dispatch;
	}
	// 8259EBE0: 4BD21CB1  bl 0x822c0890
	ctx.lr = 0x8259EBE4;
	sub_822C0890(ctx, base);
	// 8259EBE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259EBE8: 419A000C  beq cr6, 0x8259ebf4
	if ctx.cr[6].eq {
	pc = 0x8259EBF4; continue 'dispatch;
	}
	// 8259EBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EBF0: 4BD21CA1  bl 0x822c0890
	ctx.lr = 0x8259EBF4;
	sub_822C0890(ctx, base);
	// 8259EBF4: 3C800001  lis r4, 1
	ctx.r[4].s64 = 65536;
	// 8259EBF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EBFC: 4BFFCC8D  bl 0x8259b888
	ctx.lr = 0x8259EC00;
	sub_8259B888(ctx, base);
	// 8259EC00: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 8259EC04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EC08: 4BEE2319  bl 0x82480f20
	ctx.lr = 0x8259EC0C;
	sub_82480F20(ctx, base);
	// 8259EC0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EC10: 40820034  bne 0x8259ec44
	if !ctx.cr[0].eq {
	pc = 0x8259EC44; continue 'dispatch;
	}
	// 8259EC14: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8259EC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EC1C: 4BFFCC6D  bl 0x8259b888
	ctx.lr = 0x8259EC20;
	sub_8259B888(ctx, base);
	// 8259EC20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EC24: 41820020  beq 0x8259ec44
	if ctx.cr[0].eq {
	pc = 0x8259EC44; continue 'dispatch;
	}
	// 8259EC28: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 8259EC2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8259EC30: 917E0178  stw r11, 0x178(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 8259EC34: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8259EC38: 4198000C  blt cr6, 0x8259ec44
	if ctx.cr[6].lt {
	pc = 0x8259EC44; continue 'dispatch;
	}
	// 8259EC3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259EC40: 917E0178  stw r11, 0x178(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 8259EC44: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8259EC48: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8259EC4C: 48C0956C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259EC50 size=600
    let mut pc: u32 = 0x8259EC50;
    'dispatch: loop {
        match pc {
            0x8259EC50 => {
    //   block [0x8259EC50..0x8259EEA8)
	// 8259EC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EC54: 48C09511  bl 0x831a8164
	ctx.lr = 0x8259EC58;
	sub_831A8130(ctx, base);
	// 8259EC58: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EC5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259EC60: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259EC64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EC68: 409A0054  bne cr6, 0x8259ecbc
	if !ctx.cr[6].eq {
	pc = 0x8259ECBC; continue 'dispatch;
	}
	// 8259EC6C: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259EC70: 480009E9  bl 0x8259f658
	ctx.lr = 0x8259EC74;
	sub_8259F658(ctx, base);
	// 8259EC74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EC78: 41820150  beq 0x8259edc8
	if ctx.cr[0].eq {
	pc = 0x8259EDC8; continue 'dispatch;
	}
	// 8259EC7C: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259EC80: 83CB00F0  lwz r30, 0xf0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 8259EC84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8259EC88: 419A0140  beq cr6, 0x8259edc8
	if ctx.cr[6].eq {
	pc = 0x8259EDC8; continue 'dispatch;
	}
	// 8259EC8C: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 8259EC90: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8259EC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EC98: 48001981  bl 0x825a0618
	ctx.lr = 0x8259EC9C;
	sub_825A0618(ctx, base);
	// 8259EC9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259ECA0: 480019B1  bl 0x825a0650
	ctx.lr = 0x8259ECA4;
	sub_825A0650(ctx, base);
	// 8259ECA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259ECA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ECAC: 48854D5D  bl 0x82df3a08
	ctx.lr = 0x8259ECB0;
	sub_82DF3A08(ctx, base);
	// 8259ECB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ECB4: 48854775  bl 0x82df3428
	ctx.lr = 0x8259ECB8;
	sub_82DF3428(ctx, base);
	// 8259ECB8: 48000110  b 0x8259edc8
	pc = 0x8259EDC8; continue 'dispatch;
	// 8259ECBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ECC0: 809F015C  lwz r4, 0x15c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259ECC4: 481FD065  bl 0x8279bd28
	ctx.lr = 0x8259ECC8;
	sub_8279BD28(ctx, base);
	// 8259ECC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259ECCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259ECD0: 4885AAB9  bl 0x82df9788
	ctx.lr = 0x8259ECD4;
	sub_82DF9788(ctx, base);
	// 8259ECD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ECD8: 48854751  bl 0x82df3428
	ctx.lr = 0x8259ECDC;
	sub_82DF3428(ctx, base);
	// 8259ECDC: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259ECE0: 481FD089  bl 0x8279bd68
	ctx.lr = 0x8259ECE4;
	sub_8279BD68(ctx, base);
	// 8259ECE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259ECE8: 41820024  beq 0x8259ed0c
	if ctx.cr[0].eq {
	pc = 0x8259ED0C; continue 'dispatch;
	}
	// 8259ECEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259ECF0: 3BCBA948  addi r30, r11, -0x56b8
	ctx.r[30].s64 = ctx.r[11].s64 + -22200;
	// 8259ECF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259ECF8: 48C0A3D1  bl 0x831a90c8
	ctx.lr = 0x8259ECFC;
	sub_831A90C8(ctx, base);
	// 8259ECFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259ED00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259ED04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259ED08: 4BD2AF81  bl 0x822c9c88
	ctx.lr = 0x8259ED0C;
	sub_822C9C88(ctx, base);
	// 8259ED0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259ED10: 80BF0164  lwz r5, 0x164(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259ED14: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8259ED18: 4BFFDEC9  bl 0x8259cbe0
	ctx.lr = 0x8259ED1C;
	sub_8259CBE0(ctx, base);
	// 8259ED1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259ED20: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259ED24: 4BFFE275  bl 0x8259cf98
	ctx.lr = 0x8259ED28;
	sub_8259CF98(ctx, base);
	// 8259ED28: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 8259ED2C: 481FA70D  bl 0x82799438
	ctx.lr = 0x8259ED30;
	sub_82799438(ctx, base);
	// 8259ED30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259ED34: 48001DB5  bl 0x825a0ae8
	ctx.lr = 0x8259ED38;
	sub_825A0AE8(ctx, base);
	// 8259ED38: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8259ED3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259ED40: 41820078  beq 0x8259edb8
	if ctx.cr[0].eq {
	pc = 0x8259EDB8; continue 'dispatch;
	}
	// 8259ED44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259ED48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259ED4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ED50: 48001EE1  bl 0x825a0c30
	ctx.lr = 0x8259ED54;
	sub_825A0C30(ctx, base);
	// 8259ED54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259ED58: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259ED5C: 4885AA2D  bl 0x82df9788
	ctx.lr = 0x8259ED60;
	sub_82DF9788(ctx, base);
	// 8259ED60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259ED64: 488546C5  bl 0x82df3428
	ctx.lr = 0x8259ED68;
	sub_82DF3428(ctx, base);
	// 8259ED68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259ED6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259ED70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259ED74: 48001F05  bl 0x825a0c78
	ctx.lr = 0x8259ED78;
	sub_825A0C78(ctx, base);
	// 8259ED78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259ED7C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8259ED80: 4885AA09  bl 0x82df9788
	ctx.lr = 0x8259ED84;
	sub_82DF9788(ctx, base);
	// 8259ED84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259ED88: 488546A1  bl 0x82df3428
	ctx.lr = 0x8259ED8C;
	sub_82DF3428(ctx, base);
	// 8259ED8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259ED90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259ED94: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8259ED98: 4BD2A099  bl 0x822c8e30
	ctx.lr = 0x8259ED9C;
	sub_822C8E30(ctx, base);
	// 8259ED9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259EDA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259EDA4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259EDA8: 4BD2A089  bl 0x822c8e30
	ctx.lr = 0x8259EDAC;
	sub_822C8E30(ctx, base);
	// 8259EDAC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8259EDB0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8259EDB4: 4198FF90  blt cr6, 0x8259ed44
	if ctx.cr[6].lt {
	pc = 0x8259ED44; continue 'dispatch;
	}
	// 8259EDB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259EDBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259EDC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259EDC4: 4BD2A06D  bl 0x822c8e30
	ctx.lr = 0x8259EDC8;
	sub_822C8E30(ctx, base);
	// 8259EDC8: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8259EDCC: 4800088D  bl 0x8259f658
	ctx.lr = 0x8259EDD0;
	sub_8259F658(ctx, base);
	// 8259EDD0: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 8259EDD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EDD8: 409A00C8  bne cr6, 0x8259eea0
	if !ctx.cr[6].eq {
	pc = 0x8259EEA0; continue 'dispatch;
	}
	// 8259EDDC: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259EDE0: 481FCFF9  bl 0x8279bdd8
	ctx.lr = 0x8259EDE4;
	sub_8279BDD8(ctx, base);
	// 8259EDE4: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259EDE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259EDEC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259EDF0: 4824B479  bl 0x827ea268
	ctx.lr = 0x8259EDF4;
	sub_827EA268(ctx, base);
	// 8259EDF4: 3563FFF6  addic. r11, r3, -0xa
	ctx.xer.ca = (ctx.r[3].u32 > (!(-10 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -10;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EDF8: 4080000C  bge 0x8259ee04
	if !ctx.cr[0].lt {
	pc = 0x8259EE04; continue 'dispatch;
	}
	// 8259EDFC: 7D6BE215  add. r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EE00: 4180FFFC  blt 0x8259edfc
	if ctx.cr[0].lt {
	pc = 0x8259EDFC; continue 'dispatch;
	}
	// 8259EE04: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8259EE08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259EE0C: 3BA00015  li r29, 0x15
	ctx.r[29].s64 = 21;
	// 8259EE10: 3B6BA940  addi r27, r11, -0x56c0
	ctx.r[27].s64 = ctx.r[11].s64 + -22208;
	// 8259EE14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259EE18: 809F015C  lwz r4, 0x15c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259EE1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259EE20: 481FCF61  bl 0x8279bd80
	ctx.lr = 0x8259EE24;
	sub_8279BD80(ctx, base);
	// 8259EE24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259EE28: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259EE2C: 4885A95D  bl 0x82df9788
	ctx.lr = 0x8259EE30;
	sub_82DF9788(ctx, base);
	// 8259EE30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259EE34: 488545F5  bl 0x82df3428
	ctx.lr = 0x8259EE38;
	sub_82DF3428(ctx, base);
	// 8259EE38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259EE3C: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 8259EE40: 481FCF81  bl 0x8279bdc0
	ctx.lr = 0x8259EE44;
	sub_8279BDC0(ctx, base);
	// 8259EE44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EE48: 4182001C  beq 0x8259ee64
	if ctx.cr[0].eq {
	pc = 0x8259EE64; continue 'dispatch;
	}
	// 8259EE4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259EE50: 48C0A279  bl 0x831a90c8
	ctx.lr = 0x8259EE54;
	sub_831A90C8(ctx, base);
	// 8259EE54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259EE58: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8259EE5C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259EE60: 4BD2AE29  bl 0x822c9c88
	ctx.lr = 0x8259EE64;
	sub_822C9C88(ctx, base);
	// 8259EE64: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 8259EE68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259EE6C: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 8259EE70: 7D2AE3D6  divw r9, r10, r28
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[28].s32;
	// 8259EE74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259EE78: 7D29E1D6  mullw r9, r9, r28
	ctx.r[9].s64 = (ctx.r[9].s32 as i64) * (ctx.r[28].s32 as i64);
	// 8259EE7C: 7F8B5878  andc r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 & !ctx.r[11].u64;
	// 8259EE80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259EE84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8259EE88: 0CDC0000  twi 6, r28, 0
	// 8259EE8C: 0CABFFFF  twi 5, r11, -1
	// 8259EE90: 7FC95050  subf r30, r9, r10
	ctx.r[30].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8259EE94: 4BD29F9D  bl 0x822c8e30
	ctx.lr = 0x8259EE98;
	sub_822C8E30(ctx, base);
	// 8259EE98: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8259EE9C: 4082FF78  bne 0x8259ee14
	if !ctx.cr[0].eq {
	pc = 0x8259EE14; continue 'dispatch;
	}
	// 8259EEA0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 8259EEA4: 48C09310  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259EEA8 size=72
    let mut pc: u32 = 0x8259EEA8;
    'dispatch: loop {
        match pc {
            0x8259EEA8 => {
    //   block [0x8259EEA8..0x8259EEF0)
	// 8259EEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259EEB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259EEB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259EEB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EEBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259EEC0: 48BB5741  bl 0x83154600
	ctx.lr = 0x8259EEC4;
	sub_83154600(ctx, base);
	// 8259EEC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259EEC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EECC: 488BA8AD  bl 0x82e59778
	ctx.lr = 0x8259EED0;
	sub_82E59778(ctx, base);
	// 8259EED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EED4: 4BFFF7BD  bl 0x8259e690
	ctx.lr = 0x8259EED8;
	sub_8259E690(ctx, base);
	// 8259EED8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259EEDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259EEE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259EEE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259EEE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259EEEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259EEF0 size=76
    let mut pc: u32 = 0x8259EEF0;
    'dispatch: loop {
        match pc {
            0x8259EEF0 => {
    //   block [0x8259EEF0..0x8259EF3C)
	// 8259EEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259EEF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259EEFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259EF00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259EF08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259EF0C: 4BFFF6BD  bl 0x8259e5c8
	ctx.lr = 0x8259EF10;
	sub_8259E5C8(ctx, base);
	// 8259EF10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259EF14: 4182000C  beq 0x8259ef20
	if ctx.cr[0].eq {
	pc = 0x8259EF20; continue 'dispatch;
	}
	// 8259EF18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EF1C: 488534BD  bl 0x82df23d8
	ctx.lr = 0x8259EF20;
	sub_82DF23D8(ctx, base);
	// 8259EF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EF24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259EF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259EF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259EF30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259EF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259EF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259EF40 size=1188
    let mut pc: u32 = 0x8259EF40;
    'dispatch: loop {
        match pc {
            0x8259EF40 => {
    //   block [0x8259EF40..0x8259F3E4)
	// 8259EF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EF44: 48C0921D  bl 0x831a8160
	ctx.lr = 0x8259EF48;
	sub_831A8130(ctx, base);
	// 8259EF48: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EF4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259EF50: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8259EF54: 3B7C0138  addi r27, r28, 0x138
	ctx.r[27].s64 = ctx.r[28].s64 + 312;
	// 8259EF58: C1BC017C  lfs f13, 0x17c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(380 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259EF5C: 817C0138  lwz r11, 0x138(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(312 as u32) ) } as u64;
	// 8259EF60: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259EF64: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8259EF68: D01C017C  stfs f0, 0x17c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 8259EF6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EF70: 409A025C  bne cr6, 0x8259f1cc
	if !ctx.cr[6].eq {
	pc = 0x8259F1CC; continue 'dispatch;
	}
	// 8259EF74: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 8259EF78: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259EF7C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8259EF80: 4BFFC9D9  bl 0x8259b958
	ctx.lr = 0x8259EF84;
	sub_8259B958(ctx, base);
	// 8259EF84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EF88: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8259EF8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EF90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EF94: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 8259EF98: 419A0024  beq cr6, 0x8259efbc
	if ctx.cr[6].eq {
	pc = 0x8259EFBC; continue 'dispatch;
	}
	// 8259EF9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259EFA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259EFA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EFA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259EFAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259EFB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259EFB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259EFB8: 4082FFE8  bne 0x8259efa0
	if !ctx.cr[0].eq {
	pc = 0x8259EFA0; continue 'dispatch;
	}
	// 8259EFBC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259EFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259EFC4: 808BD050  lwz r4, -0x2fb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12208 as u32) ) } as u64;
	// 8259EFC8: 48854A41  bl 0x82df3a08
	ctx.lr = 0x8259EFCC;
	sub_82DF3A08(ctx, base);
	// 8259EFCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259EFD0: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	// 8259EFD4: 3BABA8A0  addi r29, r11, -0x5760
	ctx.r[29].s64 = ctx.r[11].s64 + -22368;
	// 8259EFD8: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 8259EFDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EFE0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8259EFE4: 38A00088  li r5, 0x88
	ctx.r[5].s64 = 136;
	// 8259EFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EFEC: 488BA135  bl 0x82e59120
	ctx.lr = 0x8259EFF0;
	sub_82E59120(ctx, base);
	// 8259EFF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259EFF4: 48854435  bl 0x82df3428
	ctx.lr = 0x8259EFF8;
	sub_82DF3428(ctx, base);
	// 8259EFF8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8259EFFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F000: 419A0008  beq cr6, 0x8259f008
	if ctx.cr[6].eq {
	pc = 0x8259F008; continue 'dispatch;
	}
	// 8259F004: 4BD2188D  bl 0x822c0890
	ctx.lr = 0x8259F008;
	sub_822C0890(ctx, base);
	// 8259F008: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8259F00C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F010: 419A0008  beq cr6, 0x8259f018
	if ctx.cr[6].eq {
	pc = 0x8259F018; continue 'dispatch;
	}
	// 8259F014: 4BD2187D  bl 0x822c0890
	ctx.lr = 0x8259F018;
	sub_822C0890(ctx, base);
	// 8259F018: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8259F01C: 4BFFC9B5  bl 0x8259b9d0
	ctx.lr = 0x8259F020;
	sub_8259B9D0(ctx, base);
	// 8259F020: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F024: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8259F028: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F030: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8259F034: 419A0024  beq cr6, 0x8259f058
	if ctx.cr[6].eq {
	pc = 0x8259F058; continue 'dispatch;
	}
	// 8259F038: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259F03C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259F040: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259F044: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259F048: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259F04C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259F050: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259F054: 4082FFE8  bne 0x8259f03c
	if !ctx.cr[0].eq {
	pc = 0x8259F03C; continue 'dispatch;
	}
	// 8259F058: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259F05C: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F060: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 8259F064: 38A0008B  li r5, 0x8b
	ctx.r[5].s64 = 139;
	// 8259F068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F06C: 488B7F7D  bl 0x82e56fe8
	ctx.lr = 0x8259F070;
	sub_82E56FE8(ctx, base);
	// 8259F070: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259F074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F078: 419A0008  beq cr6, 0x8259f080
	if ctx.cr[6].eq {
	pc = 0x8259F080; continue 'dispatch;
	}
	// 8259F07C: 4BD21815  bl 0x822c0890
	ctx.lr = 0x8259F080;
	sub_822C0890(ctx, base);
	// 8259F080: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8259F084: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F088: 419A0008  beq cr6, 0x8259f090
	if ctx.cr[6].eq {
	pc = 0x8259F090; continue 'dispatch;
	}
	// 8259F08C: 4BD21805  bl 0x822c0890
	ctx.lr = 0x8259F090;
	sub_822C0890(ctx, base);
	// 8259F090: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F094: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8259F098: 99610055  stb r11, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[11].u8 ) };
	// 8259F09C: 38C10055  addi r6, r1, 0x55
	ctx.r[6].s64 = ctx.r[1].s64 + 85;
	// 8259F0A0: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 8259F0A4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8259F0A8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8259F0AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259F0B0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8259F0B4: 4BF9577D  bl 0x82534830
	ctx.lr = 0x8259F0B8;
	sub_82534830(ctx, base);
	// 8259F0B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F0BC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8259F0C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F0C8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8259F0CC: 419A0024  beq cr6, 0x8259f0f0
	if ctx.cr[6].eq {
	pc = 0x8259F0F0; continue 'dispatch;
	}
	// 8259F0D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8259F0D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259F0D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259F0DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259F0E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259F0E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259F0E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259F0EC: 4082FFE8  bne 0x8259f0d4
	if !ctx.cr[0].eq {
	pc = 0x8259F0D4; continue 'dispatch;
	}
	// 8259F0F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259F0F4: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F0F8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8259F0FC: 38A0008D  li r5, 0x8d
	ctx.r[5].s64 = 141;
	// 8259F100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F104: 488B7EE5  bl 0x82e56fe8
	ctx.lr = 0x8259F108;
	sub_82E56FE8(ctx, base);
	// 8259F108: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259F10C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F110: 419A0008  beq cr6, 0x8259f118
	if ctx.cr[6].eq {
	pc = 0x8259F118; continue 'dispatch;
	}
	// 8259F114: 4BD2177D  bl 0x822c0890
	ctx.lr = 0x8259F118;
	sub_822C0890(ctx, base);
	// 8259F118: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8259F11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F120: 419A0008  beq cr6, 0x8259f128
	if ctx.cr[6].eq {
	pc = 0x8259F128; continue 'dispatch;
	}
	// 8259F124: 4BD2176D  bl 0x822c0890
	ctx.lr = 0x8259F128;
	sub_822C0890(ctx, base);
	// 8259F128: 3BFC0184  addi r31, r28, 0x184
	ctx.r[31].s64 = ctx.r[28].s64 + 388;
	// 8259F12C: 80DC018C  lwz r6, 0x18c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(396 as u32) ) } as u64;
	// 8259F130: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F134: 80BC0188  lwz r5, 0x188(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(392 as u32) ) } as u64;
	// 8259F138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259F13C: 4BE33225  bl 0x823d2360
	ctx.lr = 0x8259F140;
	sub_823D2360(ctx, base);
	// 8259F140: 397C0194  addi r11, r28, 0x194
	ctx.r[11].s64 = ctx.r[28].s64 + 404;
	// 8259F144: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8259F148: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8259F14C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8259F150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259F154: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8259F158: 4BFFC8F9  bl 0x8259ba50
	ctx.lr = 0x8259F15C;
	sub_8259BA50(ctx, base);
	// 8259F15C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259F160: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8259F164: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8259F168: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F16C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 8259F170: 419A0024  beq cr6, 0x8259f194
	if ctx.cr[6].eq {
	pc = 0x8259F194; continue 'dispatch;
	}
	// 8259F174: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8259F178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8259F17C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259F180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8259F184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8259F188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259F18C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259F190: 4082FFE8  bne 0x8259f178
	if !ctx.cr[0].eq {
	pc = 0x8259F178; continue 'dispatch;
	}
	// 8259F194: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259F198: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F19C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8259F1A0: 38A00092  li r5, 0x92
	ctx.r[5].s64 = 146;
	// 8259F1A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F1A8: 488B7E41  bl 0x82e56fe8
	ctx.lr = 0x8259F1AC;
	sub_82E56FE8(ctx, base);
	// 8259F1AC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8259F1B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F1B4: 419A0008  beq cr6, 0x8259f1bc
	if ctx.cr[6].eq {
	pc = 0x8259F1BC; continue 'dispatch;
	}
	// 8259F1B8: 4BD216D9  bl 0x822c0890
	ctx.lr = 0x8259F1BC;
	sub_822C0890(ctx, base);
	// 8259F1BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F1C0: 419A000C  beq cr6, 0x8259f1cc
	if ctx.cr[6].eq {
	pc = 0x8259F1CC; continue 'dispatch;
	}
	// 8259F1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F1C8: 4BD216C9  bl 0x822c0890
	ctx.lr = 0x8259F1CC;
	sub_822C0890(ctx, base);
	// 8259F1CC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8259F1D0: 387C00CC  addi r3, r28, 0xcc
	ctx.r[3].s64 = ctx.r[28].s64 + 204;
	// 8259F1D4: 488BDEBD  bl 0x82e5d090
	ctx.lr = 0x8259F1D8;
	sub_82E5D090(ctx, base);
	// 8259F1D8: 817C0150  lwz r11, 0x150(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(336 as u32) ) } as u64;
	// 8259F1DC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8259F1E0: 409A0010  bne cr6, 0x8259f1f0
	if !ctx.cr[6].eq {
	pc = 0x8259F1F0; continue 'dispatch;
	}
	// 8259F1E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259F1E8: 4BFFD989  bl 0x8259cb70
	ctx.lr = 0x8259F1EC;
	sub_8259CB70(ctx, base);
	// 8259F1EC: 48000018  b 0x8259f204
	pc = 0x8259F204; continue 'dispatch;
	// 8259F1F0: 897C0154  lbz r11, 0x154(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(340 as u32) ) } as u64;
	// 8259F1F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259F1F8: 4182000C  beq 0x8259f204
	if ctx.cr[0].eq {
	pc = 0x8259F204; continue 'dispatch;
	}
	// 8259F1FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259F200: 4BFFFA51  bl 0x8259ec50
	ctx.lr = 0x8259F204;
	sub_8259EC50(ctx, base);
	// 8259F204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259F208: C1BC017C  lfs f13, 0x17c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(380 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259F20C: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259F210: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8259F214: 40980038  bge cr6, 0x8259f24c
	if !ctx.cr[6].lt {
	pc = 0x8259F24C; continue 'dispatch;
	}
	// 8259F218: 897C0180  lbz r11, 0x180(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(384 as u32) ) } as u64;
	// 8259F21C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259F220: 4082002C  bne 0x8259f24c
	if !ctx.cr[0].eq {
	pc = 0x8259F24C; continue 'dispatch;
	}
	// 8259F224: 815C0194  lwz r10, 0x194(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(404 as u32) ) } as u64;
	// 8259F228: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8259F22C: 817C0188  lwz r11, 0x188(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(392 as u32) ) } as u64;
	// 8259F230: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8259F234: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259F238: 4885A551  bl 0x82df9788
	ctx.lr = 0x8259F23C;
	sub_82DF9788(ctx, base);
	// 8259F23C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259F240: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259F244: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8259F248: 4BD29BE9  bl 0x822c8e30
	ctx.lr = 0x8259F24C;
	sub_822C8E30(ctx, base);
	// 8259F24C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259F250: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8259F254: 4BF70275  bl 0x8250f4c8
	ctx.lr = 0x8259F258;
	sub_8250F4C8(ctx, base);
	// 8259F258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F25C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259F260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F264: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8259F268: 409A0008  bne cr6, 0x8259f270
	if !ctx.cr[6].eq {
	pc = 0x8259F270; continue 'dispatch;
	}
	// 8259F26C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259F270: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8259F274: 4BF6973D  bl 0x825089b0
	ctx.lr = 0x8259F278;
	sub_825089B0(ctx, base);
	// 8259F278: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8259F27C: 48852A15  bl 0x82df1c90
	ctx.lr = 0x8259F280;
	sub_82DF1C90(ctx, base);
	// 8259F280: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259F284: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8259F288: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8259F28C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8259F290: 9BA10066  stb r29, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[29].u8 ) };
	// 8259F294: 3BDC0140  addi r30, r28, 0x140
	ctx.r[30].s64 = ctx.r[28].s64 + 320;
	// 8259F298: 9BA10067  stb r29, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[29].u8 ) };
	// 8259F29C: 3908C4C0  addi r8, r8, -0x3b40
	ctx.r[8].s64 = ctx.r[8].s64 + -15168;
	// 8259F2A0: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259F2A4: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 8259F2A8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8259F2AC: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 8259F2B0: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F3E8 size=96
    let mut pc: u32 = 0x8259F3E8;
    'dispatch: loop {
        match pc {
            0x8259F3E8 => {
    //   block [0x8259F3E8..0x8259F448)
	// 8259F3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259F3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259F404: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 8259F408: 4BD5C8A1  bl 0x822fbca8
	ctx.lr = 0x8259F40C;
	sub_822FBCA8(ctx, base);
	// 8259F40C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8259F410: 4BECABF1  bl 0x8246a000
	ctx.lr = 0x8259F414;
	sub_8246A000(ctx, base);
	// 8259F414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F418: 4820DD79  bl 0x827ad190
	ctx.lr = 0x8259F41C;
	sub_827AD190(ctx, base);
	// 8259F41C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259F420: 4182000C  beq 0x8259f42c
	if ctx.cr[0].eq {
	pc = 0x8259F42C; continue 'dispatch;
	}
	// 8259F424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F428: 4BD20E41  bl 0x822c0268
	ctx.lr = 0x8259F42C;
	sub_822C0268(ctx, base);
	// 8259F42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F43C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259F440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F448 size=184
    let mut pc: u32 = 0x8259F448;
    'dispatch: loop {
        match pc {
            0x8259F448 => {
    //   block [0x8259F448..0x8259F500)
	// 8259F448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F44C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259F454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F45C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259F460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F464: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259F468: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259F46C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F470: 4BD214C9  bl 0x822c0938
	ctx.lr = 0x8259F474;
	sub_822C0938(ctx, base);
	// 8259F474: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259F478: 41820028  beq 0x8259f4a0
	if ctx.cr[0].eq {
	pc = 0x8259F4A0; continue 'dispatch;
	}
	// 8259F47C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259F480: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259F484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259F488: 392BA630  addi r9, r11, -0x59d0
	ctx.r[9].s64 = ctx.r[11].s64 + -22992;
	// 8259F48C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259F490: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259F494: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259F498: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259F49C: 48000008  b 0x8259f4a4
	pc = 0x8259F4A4; continue 'dispatch;
	// 8259F4A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F4A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F4A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F4AC: 409A0038  bne cr6, 0x8259f4e4
	if !ctx.cr[6].eq {
	pc = 0x8259F4E4; continue 'dispatch;
	}
	// 8259F4B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F4B4: 419A0010  beq cr6, 0x8259f4c4
	if ctx.cr[6].eq {
	pc = 0x8259F4C4; continue 'dispatch;
	}
	// 8259F4B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259F4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F4C0: 4BFFFF29  bl 0x8259f3e8
	ctx.lr = 0x8259F4C4;
	sub_8259F3E8(ctx, base);
	// 8259F4C4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259F4C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259F4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F4D0: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259F4D4: 816B6E8C  lwz r11, 0x6e8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28300 as u32) ) } as u64;
	// 8259F4D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259F4DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259F4E0: 4BD20B21  bl 0x822c0000
	ctx.lr = 0x8259F4E4;
	sub_822C0000(ctx, base);
	// 8259F4E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F4E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F4EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F4F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F4F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259F4F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259F500 size=12
    let mut pc: u32 = 0x8259F500;
    'dispatch: loop {
        match pc {
            0x8259F500 => {
    //   block [0x8259F500..0x8259F50C)
	// 8259F500: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259F504: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F508: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F50C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259F50C size=8
    let mut pc: u32 = 0x8259F50C;
    'dispatch: loop {
        match pc {
            0x8259F50C => {
    //   block [0x8259F50C..0x8259F514)
	// 8259F50C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259F510: 4BFFFED8  b 0x8259f3e8
	sub_8259F3E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F514(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259F514 size=4
    let mut pc: u32 = 0x8259F514;
    'dispatch: loop {
        match pc {
            0x8259F514 => {
    //   block [0x8259F514..0x8259F518)
	// 8259F514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259F518 size=316
    let mut pc: u32 = 0x8259F518;
    'dispatch: loop {
        match pc {
            0x8259F518 => {
    //   block [0x8259F518..0x8259F654)
	// 8259F518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F51C: 48C08C3D  bl 0x831a8158
	ctx.lr = 0x8259F520;
	sub_831A8130(ctx, base);
	// 8259F520: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F528: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8259F52C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 8259F530: 4BF71BC1  bl 0x825110f0
	ctx.lr = 0x8259F534;
	sub_825110F0(ctx, base);
	// 8259F534: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 8259F538: 488729A1  bl 0x82e11ed8
	ctx.lr = 0x8259F53C;
	sub_82E11ED8(ctx, base);
	// 8259F53C: 3B9F00CC  addi r28, r31, 0xcc
	ctx.r[28].s64 = ctx.r[31].s64 + 204;
	// 8259F540: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259F544: 488BE38D  bl 0x82e5d8d0
	ctx.lr = 0x8259F548;
	sub_82E5D8D0(ctx, base);
	// 8259F548: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259F54C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8259F550: 396BA620  addi r11, r11, -0x59e0
	ctx.r[11].s64 = ctx.r[11].s64 + -23008;
	// 8259F554: 394AA918  addi r10, r10, -0x56e8
	ctx.r[10].s64 = ctx.r[10].s64 + -22248;
	// 8259F558: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 8259F55C: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 8259F560: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 8259F564: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8259F568: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 8259F56C: 3968A8E4  addi r11, r8, -0x571c
	ctx.r[11].s64 = ctx.r[8].s64 + -22300;
	// 8259F570: 3929A8F4  addi r9, r9, -0x570c
	ctx.r[9].s64 = ctx.r[9].s64 + -22284;
	// 8259F574: 3947A908  addi r10, r7, -0x56f8
	ctx.r[10].s64 = ctx.r[7].s64 + -22264;
	// 8259F578: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8259F57C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259F580: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8259F584: 915F00CC  stw r10, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 8259F588: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259F58C: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 8259F590: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259F594: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 8259F598: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 8259F59C: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 8259F5A0: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 8259F5A4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8259F5A8: 4BD20E31  bl 0x822c03d8
	ctx.lr = 0x8259F5AC;
	sub_822C03D8(ctx, base);
	// 8259F5AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259F5B0: 41820010  beq 0x8259f5c0
	if ctx.cr[0].eq {
	pc = 0x8259F5C0; continue 'dispatch;
	}
	// 8259F5B4: 48207FD5  bl 0x827a7588
	ctx.lr = 0x8259F5B8;
	sub_827A7588(ctx, base);
	// 8259F5B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259F5BC: 48000008  b 0x8259f5c4
	pc = 0x8259F5C4; continue 'dispatch;
	// 8259F5C0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 8259F5C4: 93BF015C  stw r29, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[29].u32 ) };
	// 8259F5C8: 3B7F015C  addi r27, r31, 0x15c
	ctx.r[27].s64 = ctx.r[31].s64 + 348;
	// 8259F5CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259F5D0: 3B5B0004  addi r26, r27, 4
	ctx.r[26].s64 = ctx.r[27].s64 + 4;
	// 8259F5D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259F5D8: 4BFFFE71  bl 0x8259f448
	ctx.lr = 0x8259F5DC;
	sub_8259F448(ctx, base);
	// 8259F5DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259F5E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259F5E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259F5E8: 4BD20A19  bl 0x822c0000
	ctx.lr = 0x8259F5EC;
	sub_822C0000(ctx, base);
	// 8259F5EC: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 8259F5F0: 93DF0168  stw r30, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 8259F5F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8259F5F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259F5FC: 93DF0170  stw r30, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[30].u32 ) };
	// 8259F600: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 8259F604: 5729063F  clrlwi. r9, r25, 0x18
	ctx.r[9].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8259F608: C00B9A8C  lfs f0, -0x6574(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259F60C: 915F0178  stw r10, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[10].u32 ) };
	// 8259F610: D01F017C  stfs f0, 0x17c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 8259F614: 93DF0188  stw r30, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[30].u32 ) };
	// 8259F618: 93DF018C  stw r30, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u32 ) };
	// 8259F61C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 8259F620: 93DF0190  stw r30, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[30].u32 ) };
	// 8259F624: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259F628: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F62C: 9BDF0198  stb r30, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[30].u8 ) };
	// 8259F630: 40820008  bne 0x8259f638
	if !ctx.cr[0].eq {
	pc = 0x8259F638; continue 'dispatch;
	}
	// 8259F634: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8259F638: 48207FA1  bl 0x827a75d8
	ctx.lr = 0x8259F63C;
	sub_827A75D8(ctx, base);
	// 8259F63C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259F640: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259F644: 48AB3CCD  bl 0x83053310
	ctx.lr = 0x8259F648;
	sub_83053310(ctx, base);
	// 8259F648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F64C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259F650: 48C08B58  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259F658 size=8
    let mut pc: u32 = 0x8259F658;
    'dispatch: loop {
        match pc {
            0x8259F658 => {
    //   block [0x8259F658..0x8259F660)
	// 8259F658: 886300F8  lbz r3, 0xf8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) } as u64;
	// 8259F65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259F660 size=220
    let mut pc: u32 = 0x8259F660;
    'dispatch: loop {
        match pc {
            0x8259F660 => {
    //   block [0x8259F660..0x8259F73C)
	// 8259F660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F668: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F66C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 8259F670: 48C09401  bl 0x831a8a70
	ctx.lr = 0x8259F674;
	sub_831A8A40(ctx, base);
	// 8259F674: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F678: FF801890  fmr f28, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[3].f64;
	// 8259F67C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F680: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8259F684: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 8259F688: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8259F68C: 48C0981D  bl 0x831a8ea8
	ctx.lr = 0x8259F690;
	sub_831A8EA8(ctx, base);
	// 8259F690: FF600818  frsp f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F694: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8259F698: 48C09731  bl 0x831a8dc8
	ctx.lr = 0x8259F69C;
	sub_831A8DC8(ctx, base);
	// 8259F69C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F6A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259F6A4: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8259F6A8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259F6AC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8259F6B0: EF7B0778  fmsubs f27, f27, f29, f0
	ctx.f[27].f64 = (((ctx.f[27].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 8259F6B4: 48C09715  bl 0x831a8dc8
	ctx.lr = 0x8259F6B8;
	sub_831A8DC8(ctx, base);
	// 8259F6B8: FF400818  frsp f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F6BC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8259F6C0: 48C097E9  bl 0x831a8ea8
	ctx.lr = 0x8259F6C4;
	sub_831A8EA8(ctx, base);
	// 8259F6C4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F6C8: EDBA0772  fmuls f13, f26, f29
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[29].f64) as f32) as f64);
	// 8259F6CC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8259F6D0: EFA06FFA  fmadds f29, f0, f31, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 8259F6D4: 48C097D5  bl 0x831a8ea8
	ctx.lr = 0x8259F6D8;
	sub_831A8EA8(ctx, base);
	// 8259F6D8: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F6DC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8259F6E0: 48C096E9  bl 0x831a8dc8
	ctx.lr = 0x8259F6E4;
	sub_831A8DC8(ctx, base);
	// 8259F6E4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F6E8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8259F6EC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8259F6F0: EC1C06F8  fmsubs f0, f28, f27, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 8259F6F4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8259F6F8: 48C096D1  bl 0x831a8dc8
	ctx.lr = 0x8259F6FC;
	sub_831A8DC8(ctx, base);
	// 8259F6FC: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F700: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8259F704: 48C097A5  bl 0x831a8ea8
	ctx.lr = 0x8259F708;
	sub_831A8EA8(ctx, base);
	// 8259F708: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259F70C: D3BF0004  stfs f29, 4(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8259F710: EDBC06F2  fmuls f13, f28, f27
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[27].f64) as f32) as f64);
	// 8259F714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F718: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 8259F71C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8259F720: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259F724: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 8259F728: 48C09395  bl 0x831a8abc
	ctx.lr = 0x8259F72C;
	sub_831A8A8C(ctx, base);
	// 8259F72C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F734: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F740 size=68
    let mut pc: u32 = 0x8259F740;
    'dispatch: loop {
        match pc {
            0x8259F740 => {
    //   block [0x8259F740..0x8259F784)
	// 8259F740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F74C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F754: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259F758: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8259F75C: 396BA964  addi r11, r11, -0x569c
	ctx.r[11].s64 = ctx.r[11].s64 + -22172;
	// 8259F760: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F764: 41820008  beq 0x8259f76c
	if ctx.cr[0].eq {
	pc = 0x8259F76C; continue 'dispatch;
	}
	// 8259F768: 4BD20B01  bl 0x822c0268
	ctx.lr = 0x8259F76C;
	sub_822C0268(ctx, base);
	// 8259F76C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259F774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F77C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8259F788 size=20
    let mut pc: u32 = 0x8259F788;
    'dispatch: loop {
        match pc {
            0x8259F788 => {
    //   block [0x8259F788..0x8259F79C)
	// 8259F788: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8259F78C: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 8259F790: 13E458C7  vcmpequd (lvx128) v31, v4, v11
	tmp.u32 = ctx.r[4].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F7A0 size=204
    let mut pc: u32 = 0x8259F7A0;
    'dispatch: loop {
        match pc {
            0x8259F7A0 => {
    //   block [0x8259F7A0..0x8259F86C)
	// 8259F7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F7A4: 48C089C9  bl 0x831a816c
	ctx.lr = 0x8259F7A8;
	sub_831A8130(ctx, base);
	// 8259F7A8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8259F7AC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8259F7B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F7B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259F7BC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8259F7C0: 48BB4E41  bl 0x83154600
	ctx.lr = 0x8259F7C4;
	sub_83154600(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F870 size=196
    let mut pc: u32 = 0x8259F870;
    'dispatch: loop {
        match pc {
            0x8259F870 => {
    //   block [0x8259F870..0x8259F934)
	// 8259F870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F878: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259F87C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F884: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259F888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F88C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259F890: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259F894: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F898: 4BD210A1  bl 0x822c0938
	ctx.lr = 0x8259F89C;
	sub_822C0938(ctx, base);
	// 8259F89C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259F8A0: 41820028  beq 0x8259f8c8
	if ctx.cr[0].eq {
	pc = 0x8259F8C8; continue 'dispatch;
	}
	// 8259F8A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259F8A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259F8AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259F8B0: 392BA98C  addi r9, r11, -0x5674
	ctx.r[9].s64 = ctx.r[11].s64 + -22132;
	// 8259F8B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259F8B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259F8BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259F8C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259F8C4: 48000008  b 0x8259f8cc
	pc = 0x8259F8CC; continue 'dispatch;
	// 8259F8C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F8CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F8D4: 409A0044  bne cr6, 0x8259f918
	if !ctx.cr[6].eq {
	pc = 0x8259F918; continue 'dispatch;
	}
	// 8259F8D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F8DC: 419A001C  beq cr6, 0x8259f8f8
	if ctx.cr[6].eq {
	pc = 0x8259F8F8; continue 'dispatch;
	}
	// 8259F8E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F8E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259F8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F8EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F8F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259F8F4: 4E800421  bctrl
	ctx.lr = 0x8259F8F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259F8F8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259F8FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259F900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F904: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259F908: 816B777C  lwz r11, 0x777c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30588 as u32) ) } as u64;
	// 8259F90C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259F910: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259F914: 4BD206ED  bl 0x822c0000
	ctx.lr = 0x8259F918;
	sub_822C0000(ctx, base);
	// 8259F918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F91C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259F92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F938 size=196
    let mut pc: u32 = 0x8259F938;
    'dispatch: loop {
        match pc {
            0x8259F938 => {
    //   block [0x8259F938..0x8259F9FC)
	// 8259F938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259F944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F94C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259F950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F954: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259F958: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259F95C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F960: 4BD20FD9  bl 0x822c0938
	ctx.lr = 0x8259F964;
	sub_822C0938(ctx, base);
	// 8259F964: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259F968: 41820028  beq 0x8259f990
	if ctx.cr[0].eq {
	pc = 0x8259F990; continue 'dispatch;
	}
	// 8259F96C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259F970: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259F974: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259F978: 392BA9A0  addi r9, r11, -0x5660
	ctx.r[9].s64 = ctx.r[11].s64 + -22112;
	// 8259F97C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259F980: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259F984: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259F988: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259F98C: 48000008  b 0x8259f994
	pc = 0x8259F994; continue 'dispatch;
	// 8259F990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F994: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259F998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F99C: 409A0044  bne cr6, 0x8259f9e0
	if !ctx.cr[6].eq {
	pc = 0x8259F9E0; continue 'dispatch;
	}
	// 8259F9A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F9A4: 419A001C  beq cr6, 0x8259f9c0
	if ctx.cr[6].eq {
	pc = 0x8259F9C0; continue 'dispatch;
	}
	// 8259F9A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F9AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259F9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F9B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F9B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259F9BC: 4E800421  bctrl
	ctx.lr = 0x8259F9C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259F9C0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259F9C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259F9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F9CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259F9D0: 816B777C  lwz r11, 0x777c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30588 as u32) ) } as u64;
	// 8259F9D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259F9D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259F9DC: 4BD20625  bl 0x822c0000
	ctx.lr = 0x8259F9E0;
	sub_822C0000(ctx, base);
	// 8259F9E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F9E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F9E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F9EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F9F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259F9F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F9F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259FA00 size=196
    let mut pc: u32 = 0x8259FA00;
    'dispatch: loop {
        match pc {
            0x8259FA00 => {
    //   block [0x8259FA00..0x8259FAC4)
	// 8259FA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FA08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259FA0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FA10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FA14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259FA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259FA1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259FA20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259FA24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259FA28: 4BD20F11  bl 0x822c0938
	ctx.lr = 0x8259FA2C;
	sub_822C0938(ctx, base);
	// 8259FA2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259FA30: 41820028  beq 0x8259fa58
	if ctx.cr[0].eq {
	pc = 0x8259FA58; continue 'dispatch;
	}
	// 8259FA34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259FA38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259FA3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FA40: 392BA9B4  addi r9, r11, -0x564c
	ctx.r[9].s64 = ctx.r[11].s64 + -22092;
	// 8259FA44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259FA48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259FA4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259FA50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259FA54: 48000008  b 0x8259fa5c
	pc = 0x8259FA5C; continue 'dispatch;
	// 8259FA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259FA5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259FA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FA64: 409A0044  bne cr6, 0x8259faa8
	if !ctx.cr[6].eq {
	pc = 0x8259FAA8; continue 'dispatch;
	}
	// 8259FA68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259FA6C: 419A001C  beq cr6, 0x8259fa88
	if ctx.cr[6].eq {
	pc = 0x8259FA88; continue 'dispatch;
	}
	// 8259FA70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FA74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259FA78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FA7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FA80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259FA84: 4E800421  bctrl
	ctx.lr = 0x8259FA88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259FA88: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259FA8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259FA90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259FA94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259FA98: 816B777C  lwz r11, 0x777c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30588 as u32) ) } as u64;
	// 8259FA9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259FAA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259FAA4: 4BD2055D  bl 0x822c0000
	ctx.lr = 0x8259FAA8;
	sub_822C0000(ctx, base);
	// 8259FAA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259FAAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259FAB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FAB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FAB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259FABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FAC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259FAC8 size=196
    let mut pc: u32 = 0x8259FAC8;
    'dispatch: loop {
        match pc {
            0x8259FAC8 => {
    //   block [0x8259FAC8..0x8259FB8C)
	// 8259FAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FAD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259FAD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FAD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FADC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259FAE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259FAE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8259FAE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259FAEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259FAF0: 4BD20E49  bl 0x822c0938
	ctx.lr = 0x8259FAF4;
	sub_822C0938(ctx, base);
	// 8259FAF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8259FAF8: 41820028  beq 0x8259fb20
	if ctx.cr[0].eq {
	pc = 0x8259FB20; continue 'dispatch;
	}
	// 8259FAFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8259FB00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8259FB04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FB08: 392BA9C8  addi r9, r11, -0x5638
	ctx.r[9].s64 = ctx.r[11].s64 + -22072;
	// 8259FB0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8259FB10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259FB14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259FB18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259FB1C: 48000008  b 0x8259fb24
	pc = 0x8259FB24; continue 'dispatch;
	// 8259FB20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259FB24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8259FB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FB2C: 409A0044  bne cr6, 0x8259fb70
	if !ctx.cr[6].eq {
	pc = 0x8259FB70; continue 'dispatch;
	}
	// 8259FB30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259FB34: 419A001C  beq cr6, 0x8259fb50
	if ctx.cr[6].eq {
	pc = 0x8259FB50; continue 'dispatch;
	}
	// 8259FB38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FB3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259FB40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FB44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FB48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259FB4C: 4E800421  bctrl
	ctx.lr = 0x8259FB50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259FB50: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8259FB54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8259FB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259FB5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8259FB60: 816B777C  lwz r11, 0x777c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30588 as u32) ) } as u64;
	// 8259FB64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259FB68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259FB6C: 4BD20495  bl 0x822c0000
	ctx.lr = 0x8259FB70;
	sub_822C0000(ctx, base);
	// 8259FB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259FB74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259FB78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FB7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FB80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259FB84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FB88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259FB90 size=84
    let mut pc: u32 = 0x8259FB90;
    'dispatch: loop {
        match pc {
            0x8259FB90 => {
    //   block [0x8259FB90..0x8259FBE4)
	// 8259FB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FB98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FB9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FBA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FBA4: 4BEC9BB5  bl 0x82469758
	ctx.lr = 0x8259FBA8;
	sub_82469758(ctx, base);
	// 8259FBA8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8259FBAC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 8259FBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259FBB4: 3929A9DC  addi r9, r9, -0x5624
	ctx.r[9].s64 = ctx.r[9].s64 + -22052;
	// 8259FBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FBBC: C00A89AC  lfs f0, -0x7654(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259FBC0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259FBC4: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8259FBC8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8259FBCC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8259FBD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259FBD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FBD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FBDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259FBE8 size=100
    let mut pc: u32 = 0x8259FBE8;
    'dispatch: loop {
        match pc {
            0x8259FBE8 => {
    //   block [0x8259FBE8..0x8259FC4C)
	// 8259FBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FBF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FBF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FBF8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8259FBFC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8259FC00: 3BEB7B64  addi r31, r11, 0x7b64
	ctx.r[31].s64 = ctx.r[11].s64 + 31588;
	// 8259FC04: 816A7B68  lwz r11, 0x7b68(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31592 as u32) ) } as u64;
	// 8259FC08: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8259FC0C: 40820028  bne 0x8259fc34
	if !ctx.cr[0].eq {
	pc = 0x8259FC34; continue 'dispatch;
	}
	// 8259FC10: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8259FC14: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 8259FC18: 916A7B68  stw r11, 0x7b68(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(31592 as u32), ctx.r[11].u32 ) };
	// 8259FC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FC20: 3889AA0C  addi r4, r9, -0x55f4
	ctx.r[4].s64 = ctx.r[9].s64 + -22004;
	// 8259FC24: 48853DE5  bl 0x82df3a08
	ctx.lr = 0x8259FC28;
	sub_82DF3A08(ctx, base);
	// 8259FC28: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 8259FC2C: 386BF740  addi r3, r11, -0x8c0
	ctx.r[3].s64 = ctx.r[11].s64 + -2240;
	// 8259FC30: 48C088A9  bl 0x831a84d8
	ctx.lr = 0x8259FC34;
	sub_831A84D8(ctx, base);
	// 8259FC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FC38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259FC3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FC40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FC44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259FC50 size=76
    let mut pc: u32 = 0x8259FC50;
    'dispatch: loop {
        match pc {
            0x8259FC50 => {
    //   block [0x8259FC50..0x8259FC9C)
	// 8259FC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FC58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259FC5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FC60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FC64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FC68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259FC6C: 4BEE0E3D  bl 0x82480aa8
	ctx.lr = 0x8259FC70;
	sub_82480AA8(ctx, base);
	// 8259FC70: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FC74: 4182000C  beq 0x8259fc80
	if ctx.cr[0].eq {
	pc = 0x8259FC80; continue 'dispatch;
	}
	// 8259FC78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FC7C: 4885275D  bl 0x82df23d8
	ctx.lr = 0x8259FC80;
	sub_82DF23D8(ctx, base);
	// 8259FC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FC84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259FC88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FC8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FC90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259FC94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FC98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259FCA0 size=80
    let mut pc: u32 = 0x8259FCA0;
    'dispatch: loop {
        match pc {
            0x8259FCA0 => {
    //   block [0x8259FCA0..0x8259FCF0)
	// 8259FCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FCA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FCA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FCAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FCB0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8259FCB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259FCB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259FCBC: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 8259FCC0: 48851F39  bl 0x82df1bf8
	ctx.lr = 0x8259FCC4;
	sub_82DF1BF8(ctx, base);
	// 8259FCC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259FCC8: 485A7579  bl 0x82b47240
	ctx.lr = 0x8259FCCC;
	sub_82B47240(ctx, base);
	// 8259FCCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FCD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259FCD4: 48851FBD  bl 0x82df1c90
	ctx.lr = 0x8259FCD8;
	sub_82DF1C90(ctx, base);
	// 8259FCD8: C03F0010  lfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259FCDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259FCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FCE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FCEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259FCF0 size=32
    let mut pc: u32 = 0x8259FCF0;
    'dispatch: loop {
        match pc {
            0x8259FCF0 => {
    //   block [0x8259FCF0..0x8259FD10)
	// 8259FCF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259FCF4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259FCF8: 394B00F0  addi r10, r11, 0xf0
	ctx.r[10].s64 = ctx.r[11].s64 + 240;
	// 8259FCFC: 912B00F0  stw r9, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[9].u32 ) };
	// 8259FD00: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 8259FD04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259FD08: 912B00F4  stw r9, 0xf4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 8259FD0C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259FD10 size=8
    let mut pc: u32 = 0x8259FD10;
    'dispatch: loop {
        match pc {
            0x8259FD10 => {
    //   block [0x8259FD10..0x8259FD18)
	// 8259FD10: 4BD20B80  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 8259FD14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259FD18 size=252
    let mut pc: u32 = 0x8259FD18;
    'dispatch: loop {
        match pc {
            0x8259FD18 => {
    //   block [0x8259FD18..0x8259FE14)
	// 8259FD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FD1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FD20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259FD24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FD28: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8259FD2C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8259FD30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FD38: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FD3C: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 8259FD40: 41820038  beq 0x8259fd78
	if ctx.cr[0].eq {
	pc = 0x8259FD78; continue 'dispatch;
	}
	// 8259FD44: 480130FD  bl 0x825b2e40
	ctx.lr = 0x8259FD48;
	sub_825B2E40(ctx, base);
	// 8259FD48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FD4C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8259FD50: 488B9A29  bl 0x82e59778
	ctx.lr = 0x8259FD54;
	sub_82E59778(ctx, base);
	// 8259FD54: EC1F0072  fmuls f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[1].f64) as f32) as f64);
	// 8259FD58: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8259FD5C: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FD64: C3EB7BC4  lfs f31, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259FD68: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 8259FD6C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8259FD70: 48013121  bl 0x825b2e90
	ctx.lr = 0x8259FD74;
	sub_825B2E90(ctx, base);
	// 8259FD74: 48000034  b 0x8259fda8
	pc = 0x8259FDA8; continue 'dispatch;
	// 8259FD78: 4BFFFF29  bl 0x8259fca0
	ctx.lr = 0x8259FD7C;
	sub_8259FCA0(ctx, base);
	// 8259FD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FD80: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8259FD84: 488B99F5  bl 0x82e59778
	ctx.lr = 0x8259FD88;
	sub_82E59778(ctx, base);
	// 8259FD88: EC1F0072  fmuls f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[1].f64) as f32) as f64);
	// 8259FD8C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8259FD90: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FD98: C3EB7BC4  lfs f31, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259FD9C: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 8259FDA0: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8259FDA4: 4BEE11ED  bl 0x82480f90
	ctx.lr = 0x8259FDA8;
	sub_82480F90(ctx, base);
	// 8259FDA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FDAC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8259FDB0: 488B99C9  bl 0x82e59778
	ctx.lr = 0x8259FDB4;
	sub_82E59778(ctx, base);
	// 8259FDB4: EC1E0072  fmuls f0, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[1].f64) as f32) as f64);
	// 8259FDB8: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FDBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259FDC0: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 8259FDC4: C1AB9584  lfs f13, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FDC8: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8259FDCC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8259FDD0: 41990014  bgt cr6, 0x8259fde4
	if ctx.cr[6].gt {
	pc = 0x8259FDE4; continue 'dispatch;
	}
	// 8259FDD4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8259FDD8: C1AB78A8  lfs f13, 0x78a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30888 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FDDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8259FDE0: 40980008  bge cr6, 0x8259fde8
	if !ctx.cr[6].lt {
	pc = 0x8259FDE8; continue 'dispatch;
	}
	// 8259FDE4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 8259FDE8: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8259FDEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259FDF0: 4BEF8029  bl 0x82497e18
	ctx.lr = 0x8259FDF4;
	sub_82497E18(ctx, base);
	// 8259FDF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259FDF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FDFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FE00: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8259FE04: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8259FE08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259FE0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259FE18 size=172
    let mut pc: u32 = 0x8259FE18;
    'dispatch: loop {
        match pc {
            0x8259FE18 => {
    //   block [0x8259FE18..0x8259FEC4)
	// 8259FE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FE20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FE24: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259FE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FE2C: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 8259FE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FE34: 4BEE10ED  bl 0x82480f20
	ctx.lr = 0x8259FE38;
	sub_82480F20(ctx, base);
	// 8259FE38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259FE3C: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8259FE40: C3EB9524  lfs f31, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8259FE44: 41820020  beq 0x8259fe64
	if ctx.cr[0].eq {
	pc = 0x8259FE64; continue 'dispatch;
	}
	// 8259FE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FE4C: 488B992D  bl 0x82e59778
	ctx.lr = 0x8259FE50;
	sub_82E59778(ctx, base);
	// 8259FE50: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259FE54: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8259FE58: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FE5C: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 8259FE60: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8259FE64: 38802000  li r4, 0x2000
	ctx.r[4].s64 = 8192;
	// 8259FE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FE6C: 4BEE10B5  bl 0x82480f20
	ctx.lr = 0x8259FE70;
	sub_82480F20(ctx, base);
	// 8259FE70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FE74: 41820020  beq 0x8259fe94
	if ctx.cr[0].eq {
	pc = 0x8259FE94; continue 'dispatch;
	}
	// 8259FE78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FE7C: 488B98FD  bl 0x82e59778
	ctx.lr = 0x8259FE80;
	sub_82E59778(ctx, base);
	// 8259FE80: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259FE84: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8259FE88: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FE8C: EC006FFC  fnmsubs f0, f0, f31, f13
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 8259FE90: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8259FE94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8259FE98: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8259FE9C: C00B9528  lfs f0, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259FEA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8259FEA4: 40980008  bge cr6, 0x8259feac
	if !ctx.cr[6].lt {
	pc = 0x8259FEAC; continue 'dispatch;
	}
	// 8259FEA8: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8259FEAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259FEB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FEB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259FEB8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259FEBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259FEC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259FEC8 size=404
    let mut pc: u32 = 0x8259FEC8;
    'dispatch: loop {
        match pc {
            0x8259FEC8 => {
    //   block [0x8259FEC8..0x825A005C)
	// 8259FEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FECC: 48C082A1  bl 0x831a816c
	ctx.lr = 0x8259FED0;
	sub_831A8130(ctx, base);
	// 8259FED0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8259FED4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FED8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8259FEDC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8259FEE0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8259FEE4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8259FEE8: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 8259FEEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FEF0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0060 size=112
    let mut pc: u32 = 0x825A0060;
    'dispatch: loop {
        match pc {
            0x825A0060 => {
    //   block [0x825A0060..0x825A00D0)
	// 825A0060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0064: 48C08109  bl 0x831a816c
	ctx.lr = 0x825A0068;
	sub_831A8130(ctx, base);
	// 825A0068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A006C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825A0070: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0074: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A0078: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825A007C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825A0080: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825A0084: 48852365  bl 0x82df23e8
	ctx.lr = 0x825A0088;
	sub_82DF23E8(ctx, base);
	// 825A0088: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A008C: 41820010  beq 0x825a009c
	if ctx.cr[0].eq {
	pc = 0x825A009C; continue 'dispatch;
	}
	// 825A0090: 485B86B1  bl 0x82b58740
	ctx.lr = 0x825A0094;
	sub_82B58740(ctx, base);
	// 825A0094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0098: 48000008  b 0x825a00a0
	pc = 0x825A00A0; continue 'dispatch;
	// 825A009C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A00A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825A00A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825A00A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A00AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A00B0: 4BFFF889  bl 0x8259f938
	ctx.lr = 0x825A00B4;
	sub_8259F938(ctx, base);
	// 825A00B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A00B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A00BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A00C0: 4BD1FF41  bl 0x822c0000
	ctx.lr = 0x825A00C4;
	sub_822C0000(ctx, base);
	// 825A00C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A00C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A00CC: 48C080F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A00D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A00D0 size=112
    let mut pc: u32 = 0x825A00D0;
    'dispatch: loop {
        match pc {
            0x825A00D0 => {
    //   block [0x825A00D0..0x825A0140)
	// 825A00D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A00D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A00D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A00DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A00E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A00E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A00E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A00EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825A00F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A00F4: 4BFFF90D  bl 0x8259fa00
	ctx.lr = 0x825A00F8;
	sub_8259FA00(ctx, base);
	// 825A00F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A00FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A0100: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A0104: 4BD1FEFD  bl 0x822c0000
	ctx.lr = 0x825A0108;
	sub_822C0000(ctx, base);
	// 825A0108: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A010C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A0110: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0114: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A011C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A0120: 419A0008  beq cr6, 0x825a0128
	if ctx.cr[6].eq {
	pc = 0x825A0128; continue 'dispatch;
	}
	// 825A0124: 4BD2076D  bl 0x822c0890
	ctx.lr = 0x825A0128;
	sub_822C0890(ctx, base);
	// 825A0128: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A012C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0130: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0134: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A0138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A013C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0140 size=112
    let mut pc: u32 = 0x825A0140;
    'dispatch: loop {
        match pc {
            0x825A0140 => {
    //   block [0x825A0140..0x825A01B0)
	// 825A0140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A014C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0154: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A0158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A015C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825A0160: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A0164: 4BFFF965  bl 0x8259fac8
	ctx.lr = 0x825A0168;
	sub_8259FAC8(ctx, base);
	// 825A0168: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A016C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A0170: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A0174: 4BD1FE8D  bl 0x822c0000
	ctx.lr = 0x825A0178;
	sub_822C0000(ctx, base);
	// 825A0178: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A017C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A0180: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0184: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A018C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A0190: 419A0008  beq cr6, 0x825a0198
	if ctx.cr[6].eq {
	pc = 0x825A0198; continue 'dispatch;
	}
	// 825A0194: 4BD206FD  bl 0x822c0890
	ctx.lr = 0x825A0198;
	sub_822C0890(ctx, base);
	// 825A0198: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A019C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A01A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A01A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A01A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A01AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A01B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A01B0 size=112
    let mut pc: u32 = 0x825A01B0;
    'dispatch: loop {
        match pc {
            0x825A01B0 => {
    //   block [0x825A01B0..0x825A0220)
	// 825A01B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A01B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A01B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A01BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A01C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A01C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A01C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A01CC: 388BAA20  addi r4, r11, -0x55e0
	ctx.r[4].s64 = ctx.r[11].s64 + -21984;
	// 825A01D0: 38A0017B  li r5, 0x17b
	ctx.r[5].s64 = 379;
	// 825A01D4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825A01D8: 4BD20201  bl 0x822c03d8
	ctx.lr = 0x825A01DC;
	sub_822C03D8(ctx, base);
	// 825A01DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A01E0: 41820018  beq 0x825a01f8
	if ctx.cr[0].eq {
	pc = 0x825A01F8; continue 'dispatch;
	}
	// 825A01E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A01E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A01EC: 396BA978  addi r11, r11, -0x5688
	ctx.r[11].s64 = ctx.r[11].s64 + -22152;
	// 825A01F0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A01F4: 48000008  b 0x825a01fc
	pc = 0x825A01FC; continue 'dispatch;
	// 825A01F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A01FC: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 825A0200: 4BFFFF41  bl 0x825a0140
	ctx.lr = 0x825A0204;
	sub_825A0140(ctx, base);
	// 825A0204: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0208: 997F00F8  stb r11, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u8 ) };
	// 825A020C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A0210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A021C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A0220 size=372
    let mut pc: u32 = 0x825A0220;
    'dispatch: loop {
        match pc {
            0x825A0220 => {
    //   block [0x825A0220..0x825A0394)
	// 825A0220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0224: 48C07F3D  bl 0x831a8160
	ctx.lr = 0x825A0228;
	sub_831A8130(ctx, base);
	// 825A0228: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A022C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A0230: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A0234: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825A0238: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A023C: 3B8BAA20  addi r28, r11, -0x55e0
	ctx.r[28].s64 = ctx.r[11].s64 + -21984;
	// 825A0240: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A0244: 38A00168  li r5, 0x168
	ctx.r[5].s64 = 360;
	// 825A0248: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A024C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825A0250: 48852199  bl 0x82df23e8
	ctx.lr = 0x825A0254;
	sub_82DF23E8(ctx, base);
	// 825A0254: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825A0258: 41820054  beq 0x825a02ac
	if ctx.cr[0].eq {
	pc = 0x825A02AC; continue 'dispatch;
	}
	// 825A025C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A0260: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 825A0264: 48BB439D  bl 0x83154600
	ctx.lr = 0x825A0268;
	sub_83154600(ctx, base);
	// 825A0268: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A026C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A0270: 48BB4391  bl 0x83154600
	ctx.lr = 0x825A0274;
	sub_83154600(ctx, base);
	// 825A0274: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825A0278: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A027C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0280: 4BF6F249  bl 0x8250f4c8
	ctx.lr = 0x825A0284;
	sub_8250F4C8(ctx, base);
	// 825A0284: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A0288: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A028C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A0290: 4BF6F289  bl 0x8250f518
	ctx.lr = 0x825A0294;
	sub_8250F518(ctx, base);
	// 825A0294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A0298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A029C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825A02A0: 4BD44D01  bl 0x822e4fa0
	ctx.lr = 0x825A02A4;
	sub_822E4FA0(ctx, base);
	// 825A02A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A02A8: 48000008  b 0x825a02b0
	pc = 0x825A02B0; continue 'dispatch;
	// 825A02AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A02B0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A02B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A02B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A02BC: 4BFFF5B5  bl 0x8259f870
	ctx.lr = 0x825A02C0;
	sub_8259F870(ctx, base);
	// 825A02C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A02C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A02C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A02CC: 4BD1FD35  bl 0x822c0000
	ctx.lr = 0x825A02D0;
	sub_822C0000(ctx, base);
	// 825A02D0: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A02D4: 41820010  beq 0x825a02e4
	if ctx.cr[0].eq {
	pc = 0x825A02E4; continue 'dispatch;
	}
	// 825A02D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A02DC: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 825A02E0: 488519B1  bl 0x82df1c90
	ctx.lr = 0x825A02E4;
	sub_82DF1C90(ctx, base);
	// 825A02E4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A02E8: 4182000C  beq 0x825a02f4
	if ctx.cr[0].eq {
	pc = 0x825A02F4; continue 'dispatch;
	}
	// 825A02EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A02F0: 488519A1  bl 0x82df1c90
	ctx.lr = 0x825A02F4;
	sub_82DF1C90(ctx, base);
	// 825A02F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A02F8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A02FC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825A0300: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A0304: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825A0308: 389D00D0  addi r4, r29, 0xd0
	ctx.r[4].s64 = ctx.r[29].s64 + 208;
	// 825A030C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A0310: C1AA8494  lfs f13, -0x7b6c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31596 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A0314: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A0318: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A031C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825A0320: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825A0324: 4BD445AD  bl 0x822e48d0
	ctx.lr = 0x825A0328;
	sub_822E48D0(ctx, base);
	// 825A0328: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A032C: 41820048  beq 0x825a0374
	if ctx.cr[0].eq {
	pc = 0x825A0374; continue 'dispatch;
	}
	// 825A0330: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A0334: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A0338: 38A0016A  li r5, 0x16a
	ctx.r[5].s64 = 362;
	// 825A033C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825A0340: 4BD20099  bl 0x822c03d8
	ctx.lr = 0x825A0344;
	sub_822C03D8(ctx, base);
	// 825A0344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A0348: 41820014  beq 0x825a035c
	if ctx.cr[0].eq {
	pc = 0x825A035C; continue 'dispatch;
	}
	// 825A034C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A0350: 48000679  bl 0x825a09c8
	ctx.lr = 0x825A0354;
	sub_825A09C8(ctx, base);
	// 825A0354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A0358: 48000008  b 0x825a0360
	pc = 0x825A0360; continue 'dispatch;
	// 825A035C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A0360: 387D00F0  addi r3, r29, 0xf0
	ctx.r[3].s64 = ctx.r[29].s64 + 240;
	// 825A0364: 4BFFFD6D  bl 0x825a00d0
	ctx.lr = 0x825A0368;
	sub_825A00D0(ctx, base);
	// 825A0368: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A036C: 997D00F8  stb r11, 0xf8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(248 as u32), ctx.r[11].u8 ) };
	// 825A0370: 4800000C  b 0x825a037c
	pc = 0x825A037C; continue 'dispatch;
	// 825A0374: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A0378: 4BFFFE39  bl 0x825a01b0
	ctx.lr = 0x825A037C;
	sub_825A01B0(ctx, base);
	// 825A037C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A0380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A0384: 419A0008  beq cr6, 0x825a038c
	if ctx.cr[6].eq {
	pc = 0x825A038C; continue 'dispatch;
	}
	// 825A0388: 4BD20509  bl 0x822c0890
	ctx.lr = 0x825A038C;
	sub_822C0890(ctx, base);
	// 825A038C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825A0390: 48C07E20  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0398 size=268
    let mut pc: u32 = 0x825A0398;
    'dispatch: loop {
        match pc {
            0x825A0398 => {
    //   block [0x825A0398..0x825A04A4)
	// 825A0398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A039C: 48C07DC9  bl 0x831a8164
	ctx.lr = 0x825A03A0;
	sub_831A8130(ctx, base);
	// 825A03A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A03A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A03A8: 48BB4259  bl 0x83154600
	ctx.lr = 0x825A03AC;
	sub_83154600(ctx, base);
	// 825A03AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A03B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825A03B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A03B8: 4BEC49D1  bl 0x82464d88
	ctx.lr = 0x825A03BC;
	sub_82464D88(ctx, base);
	// 825A03BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A03C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A03C4: 4BEC49D5  bl 0x82464d98
	ctx.lr = 0x825A03C8;
	sub_82464D98(ctx, base);
	// 825A03C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A03CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A03D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825A03D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A03D8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825A03DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A03E0: 4E800421  bctrl
	ctx.lr = 0x825A03E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A03E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A03E8: 4BFFFC79  bl 0x825a0060
	ctx.lr = 0x825A03EC;
	sub_825A0060(ctx, base);
	// 825A03EC: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825A03F0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A03F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A03F8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825A03FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825A0400: 419A0024  beq cr6, 0x825a0424
	if ctx.cr[6].eq {
	pc = 0x825A0424; continue 'dispatch;
	}
	// 825A0404: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825A0408: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A040C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0410: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A0414: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A0418: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A041C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0420: 4082FFE8  bne 0x825a0408
	if !ctx.cr[0].eq {
	pc = 0x825A0408; continue 'dispatch;
	}
	// 825A0424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0428: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 825A042C: 4BEC46ED  bl 0x82464b18
	ctx.lr = 0x825A0430;
	sub_82464B18(ctx, base);
	// 825A0430: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A0434: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825A0438: 388BAA20  addi r4, r11, -0x55e0
	ctx.r[4].s64 = ctx.r[11].s64 + -21984;
	// 825A043C: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 825A0440: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825A0444: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825A0448: 488B6BA1  bl 0x82e56fe8
	ctx.lr = 0x825A044C;
	sub_82E56FE8(ctx, base);
	// 825A044C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A0450: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0458: 419A000C  beq cr6, 0x825a0464
	if ctx.cr[6].eq {
	pc = 0x825A0464; continue 'dispatch;
	}
	// 825A045C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825A0460: 4BD20431  bl 0x822c0890
	ctx.lr = 0x825A0464;
	sub_822C0890(ctx, base);
	// 825A0464: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A0468: 4182001C  beq 0x825a0484
	if ctx.cr[0].eq {
	pc = 0x825A0484; continue 'dispatch;
	}
	// 825A046C: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 825A0470: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A0474: 41820010  beq 0x825a0484
	if ctx.cr[0].eq {
	pc = 0x825A0484; continue 'dispatch;
	}
	// 825A0478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A047C: 4BFFFDA5  bl 0x825a0220
	ctx.lr = 0x825A0480;
	sub_825A0220(ctx, base);
	// 825A0480: 4800000C  b 0x825a048c
	pc = 0x825A048C; continue 'dispatch;
	// 825A0484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0488: 4BFFFD29  bl 0x825a01b0
	ctx.lr = 0x825A048C;
	sub_825A01B0(ctx, base);
	// 825A048C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A0490: 419A000C  beq cr6, 0x825a049c
	if ctx.cr[6].eq {
	pc = 0x825A049C; continue 'dispatch;
	}
	// 825A0494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A0498: 4BD203F9  bl 0x822c0890
	ctx.lr = 0x825A049C;
	sub_822C0890(ctx, base);
	// 825A049C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825A04A0: 48C07D14  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A04A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A04A8 size=364
    let mut pc: u32 = 0x825A04A8;
    'dispatch: loop {
        match pc {
            0x825A04A8 => {
    //   block [0x825A04A8..0x825A0614)
	// 825A04A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A04AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A04B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A04B4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825A04B8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825A04BC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A04C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A04C4: 48BB413D  bl 0x83154600
	ctx.lr = 0x825A04C8;
	sub_83154600(ctx, base);
	// 825A04C8: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 825A04CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A04D0: 4BEE0A51  bl 0x82480f20
	ctx.lr = 0x825A04D4;
	sub_82480F20(ctx, base);
	// 825A04D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A04D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A04DC: 40820034  bne 0x825a0510
	if !ctx.cr[0].eq {
	pc = 0x825A0510; continue 'dispatch;
	}
	// 825A04E0: 38800400  li r4, 0x400
	ctx.r[4].s64 = 1024;
	// 825A04E4: 4BEE0A3D  bl 0x82480f20
	ctx.lr = 0x825A04E8;
	sub_82480F20(ctx, base);
	// 825A04E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A04EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A04F0: 41820018  beq 0x825a0508
	if ctx.cr[0].eq {
	pc = 0x825A0508; continue 'dispatch;
	}
	// 825A04F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A04F8: 4BFFF821  bl 0x8259fd18
	ctx.lr = 0x825A04FC;
	sub_8259FD18(ctx, base);
	// 825A04FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0500: 4BFFF919  bl 0x8259fe18
	ctx.lr = 0x825A0504;
	sub_8259FE18(ctx, base);
	// 825A0504: 48000038  b 0x825a053c
	pc = 0x825A053C; continue 'dispatch;
	// 825A0508: 4BFFF9C1  bl 0x8259fec8
	ctx.lr = 0x825A050C;
	sub_8259FEC8(ctx, base);
	// 825A050C: 48000030  b 0x825a053c
	pc = 0x825A053C; continue 'dispatch;
	// 825A0510: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825A0514: 4BFFB375  bl 0x8259b888
	ctx.lr = 0x825A0518;
	sub_8259B888(ctx, base);
	// 825A0518: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A051C: 41820020  beq 0x825a053c
	if ctx.cr[0].eq {
	pc = 0x825A053C; continue 'dispatch;
	}
	// 825A0520: 897F00F8  lbz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825A0524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0528: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A052C: 4182000C  beq 0x825a0538
	if ctx.cr[0].eq {
	pc = 0x825A0538; continue 'dispatch;
	}
	// 825A0530: 4BFFFC81  bl 0x825a01b0
	ctx.lr = 0x825A0534;
	sub_825A01B0(ctx, base);
	// 825A0534: 48000008  b 0x825a053c
	pc = 0x825A053C; continue 'dispatch;
	// 825A0538: 4BFFFCE9  bl 0x825a0220
	ctx.lr = 0x825A053C;
	sub_825A0220(ctx, base);
	// 825A053C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825A0540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0544: 4BEE09DD  bl 0x82480f20
	ctx.lr = 0x825A0548;
	sub_82480F20(ctx, base);
	// 825A0548: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A054C: 41820010  beq 0x825a055c
	if ctx.cr[0].eq {
	pc = 0x825A055C; continue 'dispatch;
	}
	// 825A0550: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A0554: C00B08AC  lfs f0, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A0558: 4800000C  b 0x825a0564
	pc = 0x825A0564; continue 'dispatch;
	// 825A055C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825A0560: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A0564: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 825A0568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A056C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825A0570: C07F00E4  lfs f3, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825A0574: C05F00E8  lfs f2, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825A0578: C03F00EC  lfs f1, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A057C: 4BFFF0E5  bl 0x8259f660
	ctx.lr = 0x825A0580;
	sub_8259F660(ctx, base);
	// 825A0580: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 825A0584: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825A0588: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A058C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825A0590: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825A0594: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825A0598: 13DF58C7  vcmpequd (lvx128) v30, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825A059C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A0618 size=56
    let mut pc: u32 = 0x825A0618;
    'dispatch: loop {
        match pc {
            0x825A0618 => {
    //   block [0x825A0618..0x825A0650)
	// 825A0618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A061C: 48C07B51  bl 0x831a816c
	ctx.lr = 0x825A0620;
	sub_831A8130(ctx, base);
	// 825A0620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A062C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825A0630: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0634: 4BD43BBD  bl 0x822e41f0
	ctx.lr = 0x825A0638;
	sub_822E41F0(ctx, base);
	// 825A0638: D03E0000  stfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A063C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A0640: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0644: 4BD43DF5  bl 0x822e4438
	ctx.lr = 0x825A0648;
	sub_822E4438(ctx, base);
	// 825A0648: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A064C: 48C07B70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0650 size=8
    let mut pc: u32 = 0x825A0650;
    'dispatch: loop {
        match pc {
            0x825A0650 => {
    //   block [0x825A0650..0x825A0658)
	// 825A0650: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0654: 4BD43B8C  b 0x822e41e0
	sub_822E41E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0658 size=80
    let mut pc: u32 = 0x825A0658;
    'dispatch: loop {
        match pc {
            0x825A0658 => {
    //   block [0x825A0658..0x825A06A8)
	// 825A0658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A065C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0660: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0664: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A066C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A0670: 396BAA6C  addi r11, r11, -0x5594
	ctx.r[11].s64 = ctx.r[11].s64 + -21908;
	// 825A0674: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0678: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A067C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A0680: 419A0008  beq cr6, 0x825a0688
	if ctx.cr[6].eq {
	pc = 0x825A0688; continue 'dispatch;
	}
	// 825A0684: 4BD2020D  bl 0x822c0890
	ctx.lr = 0x825A0688;
	sub_822C0890(ctx, base);
	// 825A0688: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A068C: 396BA964  addi r11, r11, -0x569c
	ctx.r[11].s64 = ctx.r[11].s64 + -22172;
	// 825A0690: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0694: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A0698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A069C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A06A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A06A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A06A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A06A8 size=476
    let mut pc: u32 = 0x825A06A8;
    'dispatch: loop {
        match pc {
            0x825A06A8 => {
    //   block [0x825A06A8..0x825A0884)
	// 825A06A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A06AC: 48C07ABD  bl 0x831a8168
	ctx.lr = 0x825A06B0;
	sub_831A8130(ctx, base);
	// 825A06B0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 825A06B4: 48C083C5  bl 0x831a8a78
	ctx.lr = 0x825A06B8;
	sub_831A8A40(ctx, base);
	// 825A06B8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A06BC: C0070000  lfs f0, 0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A06C0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825A06C4: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A06C8: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825A06CC: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825A06D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A06D4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825A06D8: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 825A06DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825A06E0: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A06E4: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A06E8: EF80682A  fadds f28, f0, f13
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825A06EC: 40990010  ble cr6, 0x825a06fc
	if !ctx.cr[6].gt {
	pc = 0x825A06FC; continue 'dispatch;
	}
	// 825A06F0: 13E038C7  vcmpequd (lvx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825A06F4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 825A06F8: 4800000C  b 0x825a0704
	pc = 0x825A0704; continue 'dispatch;
	// 825A06FC: 13E030C7  vcmpequd (lvx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825A0700: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A0704: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A0888 size=316
    let mut pc: u32 = 0x825A0888;
    'dispatch: loop {
        match pc {
            0x825A0888 => {
    //   block [0x825A0888..0x825A09C4)
	// 825A0888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A088C: 48C078E1  bl 0x831a816c
	ctx.lr = 0x825A0890;
	sub_831A8130(ctx, base);
	// 825A0890: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 825A0894: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825A0898: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A089C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A08A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A08A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A08A8: 48239751  bl 0x827d9ff8
	ctx.lr = 0x825A08AC;
	sub_827D9FF8(ctx, base);
	// 825A08AC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825A08B0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A08B4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825A08B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A08BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A08C0: 4BD43B89  bl 0x822e4448
	ctx.lr = 0x825A08C4;
	sub_822E4448(ctx, base);
	// 825A08C4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825A08C8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825A08CC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 825A08D0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825A08D4: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 825A08D8: C00B7BC8  lfs f0, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A08DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A08E0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825A08E4: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825A08E8: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A09C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A09C8 size=40
    let mut pc: u32 = 0x825A09C8;
    'dispatch: loop {
        match pc {
            0x825A09C8 => {
    //   block [0x825A09C8..0x825A09F0)
	// 825A09C8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825A09CC: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825A09D0: 396AAA6C  addi r11, r10, -0x5594
	ctx.r[11].s64 = ctx.r[10].s64 + -21908;
	// 825A09D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A09D8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A09DC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A09E0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A09E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A09E8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825A09EC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A09F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A09F0 size=36
    let mut pc: u32 = 0x825A09F0;
    'dispatch: loop {
        match pc {
            0x825A09F0 => {
    //   block [0x825A09F0..0x825A0A14)
	// 825A09F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825A09F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A09F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A09FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A0A00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A0A04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A0A08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0A0C: 4082FFE8  bne 0x825a09f4
	if !ctx.cr[0].eq {
	pc = 0x825A09F4; continue 'dispatch;
	}
	// 825A0A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0A18 size=76
    let mut pc: u32 = 0x825A0A18;
    'dispatch: loop {
        match pc {
            0x825A0A18 => {
    //   block [0x825A0A18..0x825A0A64)
	// 825A0A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A0A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0A30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A0A34: 4BFFFC25  bl 0x825a0658
	ctx.lr = 0x825A0A38;
	sub_825A0658(ctx, base);
	// 825A0A38: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A0A3C: 4182000C  beq 0x825a0a48
	if ctx.cr[0].eq {
	pc = 0x825A0A48; continue 'dispatch;
	}
	// 825A0A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0A44: 4BD1F825  bl 0x822c0268
	ctx.lr = 0x825A0A48;
	sub_822C0268(ctx, base);
	// 825A0A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0A4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A0A50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0A54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0A58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A0A5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0A68 size=32
    let mut pc: u32 = 0x825A0A68;
    'dispatch: loop {
        match pc {
            0x825A0A68 => {
    //   block [0x825A0A68..0x825A0A88)
	// 825A0A68: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0A6C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0A70: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A0A74: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0A78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0A7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0A84: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0A88 size=32
    let mut pc: u32 = 0x825A0A88;
    'dispatch: loop {
        match pc {
            0x825A0A88 => {
    //   block [0x825A0A88..0x825A0AA8)
	// 825A0A88: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0A8C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0A90: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A0A94: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0A98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0A9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0AA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0AA4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0AA8 size=32
    let mut pc: u32 = 0x825A0AA8;
    'dispatch: loop {
        match pc {
            0x825A0AA8 => {
    //   block [0x825A0AA8..0x825A0AC8)
	// 825A0AA8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0AAC: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0AB0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A0AB4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0AB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0ABC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0AC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0AC4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0AC8 size=28
    let mut pc: u32 = 0x825A0AC8;
    'dispatch: loop {
        match pc {
            0x825A0AC8 => {
    //   block [0x825A0AC8..0x825A0AE4)
	// 825A0AC8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0ACC: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0AD0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0AD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0AD8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A0ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0AE0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0AE8 size=20
    let mut pc: u32 = 0x825A0AE8;
    'dispatch: loop {
        match pc {
            0x825A0AE8 => {
    //   block [0x825A0AE8..0x825A0AFC)
	// 825A0AE8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0AF0: 409A000C  bne cr6, 0x825a0afc
	if !ctx.cr[6].eq {
		sub_825A0AFC(ctx, base);
		return;
	}
	// 825A0AF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A0AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0AFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0AFC size=16
    let mut pc: u32 = 0x825A0AFC;
    'dispatch: loop {
        match pc {
            0x825A0AFC => {
    //   block [0x825A0AFC..0x825A0B0C)
	// 825A0AFC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0B00: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0B04: 7D631E70  srawi r3, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A0B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0B10 size=116
    let mut pc: u32 = 0x825A0B10;
    'dispatch: loop {
        match pc {
            0x825A0B10 => {
    //   block [0x825A0B10..0x825A0B84)
	// 825A0B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0B14: 48C07651  bl 0x831a8164
	ctx.lr = 0x825A0B18;
	sub_831A8130(ctx, base);
	// 825A0B18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0B1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0B20: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825A0B24: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 825A0B28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A0B2C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A0B30: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0B38: 419A0044  beq cr6, 0x825a0b7c
	if ctx.cr[6].eq {
	pc = 0x825A0B7C; continue 'dispatch;
	}
	// 825A0B3C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0B40: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0B44: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A0B48: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A0B4C: 40980030  bge cr6, 0x825a0b7c
	if !ctx.cr[6].lt {
	pc = 0x825A0B7C; continue 'dispatch;
	}
	// 825A0B50: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0B54: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0B58: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A0B5C: 7C8AF02E  lwzx r4, r10, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A0B60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0B64: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825A0B68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0B6C: 4E800421  bctrl
	ctx.lr = 0x825A0B70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0B70: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A0B74: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A0B78: 4BFFFFB8  b 0x825a0b30
	pc = 0x825A0B30; continue 'dispatch;
	// 825A0B7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A0B80: 48C07634  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0B88 size=164
    let mut pc: u32 = 0x825A0B88;
    'dispatch: loop {
        match pc {
            0x825A0B88 => {
    //   block [0x825A0B88..0x825A0C2C)
	// 825A0B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0B8C: 48C075D1  bl 0x831a815c
	ctx.lr = 0x825A0B90;
	sub_831A8130(ctx, base);
	// 825A0B90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0B94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A0B98: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825A0B9C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825A0BA0: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 825A0BA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A0BA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A0BAC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0BB4: 419A0070  beq cr6, 0x825a0c24
	if ctx.cr[6].eq {
	pc = 0x825A0C24; continue 'dispatch;
	}
	// 825A0BB8: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0BBC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0BC0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A0BC4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A0BC8: 4098005C  bge cr6, 0x825a0c24
	if !ctx.cr[6].lt {
	pc = 0x825A0C24; continue 'dispatch;
	}
	// 825A0BCC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0BD4: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825A0BD8: 480058B1  bl 0x825a6488
	ctx.lr = 0x825A0BDC;
	sub_825A6488(ctx, base);
	// 825A0BDC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A0BE0: 48852729  bl 0x82df3308
	ctx.lr = 0x825A0BE4;
	sub_82DF3308(ctx, base);
	// 825A0BE4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825A0BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0BEC: 4885283D  bl 0x82df3428
	ctx.lr = 0x825A0BF0;
	sub_82DF3428(ctx, base);
	// 825A0BF0: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A0BF4: 40820010  bne 0x825a0c04
	if !ctx.cr[0].eq {
	pc = 0x825A0C04; continue 'dispatch;
	}
	// 825A0BF8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A0BFC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825A0C00: 4BFFFFAC  b 0x825a0bac
	pc = 0x825A0BAC; continue 'dispatch;
	// 825A0C04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0C08: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0C0C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A0C10: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0C14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0C18: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825A0C1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0C20: 4E800421  bctrl
	ctx.lr = 0x825A0C24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0C24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A0C28: 48C07584  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0C30 size=72
    let mut pc: u32 = 0x825A0C30;
    'dispatch: loop {
        match pc {
            0x825A0C30 => {
    //   block [0x825A0C30..0x825A0C78)
	// 825A0C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0C3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0C40: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0C44: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0C4C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0C50: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0C54: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825A0C58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0C5C: 4E800421  bctrl
	ctx.lr = 0x825A0C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A0C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0C78 size=72
    let mut pc: u32 = 0x825A0C78;
    'dispatch: loop {
        match pc {
            0x825A0C78 => {
    //   block [0x825A0C78..0x825A0CC0)
	// 825A0C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0C84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0C88: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0C8C: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0C90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0C94: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0C98: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0C9C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825A0CA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0CA4: 4E800421  bctrl
	ctx.lr = 0x825A0CA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0CAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A0CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0CC0 size=28
    let mut pc: u32 = 0x825A0CC0;
    'dispatch: loop {
        match pc {
            0x825A0CC0 => {
    //   block [0x825A0CC0..0x825A0CDC)
	// 825A0CC0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0CC4: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0CC8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0CCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0CD0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825A0CD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0CD8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0CE0 size=60
    let mut pc: u32 = 0x825A0CE0;
    'dispatch: loop {
        match pc {
            0x825A0CE0 => {
    //   block [0x825A0CE0..0x825A0D1C)
	// 825A0CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0CE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0CEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0CF0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0CF4: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0CFC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A0D00: 48005789  bl 0x825a6488
	ctx.lr = 0x825A0D04;
	sub_825A6488(ctx, base);
	// 825A0D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0D08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A0D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0D20 size=104
    let mut pc: u32 = 0x825A0D20;
    'dispatch: loop {
        match pc {
            0x825A0D20 => {
    //   block [0x825A0D20..0x825A0D88)
	// 825A0D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0D24: 48C07445  bl 0x831a8168
	ctx.lr = 0x825A0D28;
	sub_831A8130(ctx, base);
	// 825A0D28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0D2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A0D30: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A0D34: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 825A0D38: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A0D3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0D44: 419A003C  beq cr6, 0x825a0d80
	if ctx.cr[6].eq {
	pc = 0x825A0D80; continue 'dispatch;
	}
	// 825A0D48: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0D4C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0D50: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A0D54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A0D58: 40980028  bge cr6, 0x825a0d80
	if !ctx.cr[6].lt {
	pc = 0x825A0D80; continue 'dispatch;
	}
	// 825A0D5C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0D60: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A0D64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0D68: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A0D6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0D70: 4E800421  bctrl
	ctx.lr = 0x825A0D74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0D74: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A0D78: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A0D7C: 4BFFFFC0  b 0x825a0d3c
	pc = 0x825A0D3C; continue 'dispatch;
	// 825A0D80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A0D84: 48C07434  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0D88 size=104
    let mut pc: u32 = 0x825A0D88;
    'dispatch: loop {
        match pc {
            0x825A0D88 => {
    //   block [0x825A0D88..0x825A0DF0)
	// 825A0D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0D8C: 48C073DD  bl 0x831a8168
	ctx.lr = 0x825A0D90;
	sub_831A8130(ctx, base);
	// 825A0D90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0D94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A0D98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A0D9C: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 825A0DA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A0DA4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0DAC: 419A003C  beq cr6, 0x825a0de8
	if ctx.cr[6].eq {
	pc = 0x825A0DE8; continue 'dispatch;
	}
	// 825A0DB0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0DB4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0DB8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A0DBC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A0DC0: 40980028  bge cr6, 0x825a0de8
	if !ctx.cr[6].lt {
	pc = 0x825A0DE8; continue 'dispatch;
	}
	// 825A0DC4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0DC8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A0DCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0DD0: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A0DD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0DD8: 4E800421  bctrl
	ctx.lr = 0x825A0DDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0DDC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A0DE0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A0DE4: 4BFFFFC0  b 0x825a0da4
	pc = 0x825A0DA4; continue 'dispatch;
	// 825A0DE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A0DEC: 48C073CC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0DF0 size=120
    let mut pc: u32 = 0x825A0DF0;
    'dispatch: loop {
        match pc {
            0x825A0DF0 => {
    //   block [0x825A0DF0..0x825A0E68)
	// 825A0DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0DF4: 48C0736D  bl 0x831a8160
	ctx.lr = 0x825A0DF8;
	sub_831A8130(ctx, base);
	// 825A0DF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0DFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0E00: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825A0E04: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825A0E08: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 825A0E0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A0E10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A0E14: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0E1C: 419A0044  beq cr6, 0x825a0e60
	if ctx.cr[6].eq {
	pc = 0x825A0E60; continue 'dispatch;
	}
	// 825A0E20: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0E24: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0E28: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A0E2C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A0E30: 40980030  bge cr6, 0x825a0e60
	if !ctx.cr[6].lt {
	pc = 0x825A0E60; continue 'dispatch;
	}
	// 825A0E34: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0E38: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825A0E3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A0E40: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A0E44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0E48: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A0E4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0E50: 4E800421  bctrl
	ctx.lr = 0x825A0E54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0E54: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A0E58: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A0E5C: 4BFFFFB8  b 0x825a0e14
	pc = 0x825A0E14; continue 'dispatch;
	// 825A0E60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A0E64: 48C0734C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0E68 size=196
    let mut pc: u32 = 0x825A0E68;
    'dispatch: loop {
        match pc {
            0x825A0E68 => {
    //   block [0x825A0E68..0x825A0F2C)
	// 825A0E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A0E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A0E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0E84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A0E88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A0E8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0E90: 4BD1FAA9  bl 0x822c0938
	ctx.lr = 0x825A0E94;
	sub_822C0938(ctx, base);
	// 825A0E94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A0E98: 41820028  beq 0x825a0ec0
	if ctx.cr[0].eq {
	pc = 0x825A0EC0; continue 'dispatch;
	}
	// 825A0E9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A0EA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A0EA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0EA8: 392BAA94  addi r9, r11, -0x556c
	ctx.r[9].s64 = ctx.r[11].s64 + -21868;
	// 825A0EAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A0EB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A0EB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A0EB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A0EBC: 48000008  b 0x825a0ec4
	pc = 0x825A0EC4; continue 'dispatch;
	// 825A0EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0EC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0ECC: 409A0044  bne cr6, 0x825a0f10
	if !ctx.cr[6].eq {
	pc = 0x825A0F10; continue 'dispatch;
	}
	// 825A0ED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A0ED4: 419A001C  beq cr6, 0x825a0ef0
	if ctx.cr[6].eq {
	pc = 0x825A0EF0; continue 'dispatch;
	}
	// 825A0ED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0EDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A0EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0EE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0EEC: 4E800421  bctrl
	ctx.lr = 0x825A0EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0EF0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A0EF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A0EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0EFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A0F00: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A0F04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A0F08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A0F0C: 4BD1F0F5  bl 0x822c0000
	ctx.lr = 0x825A0F10;
	sub_822C0000(ctx, base);
	// 825A0F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0F14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A0F18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0F1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0F20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A0F24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0F28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0F30 size=196
    let mut pc: u32 = 0x825A0F30;
    'dispatch: loop {
        match pc {
            0x825A0F30 => {
    //   block [0x825A0F30..0x825A0FF4)
	// 825A0F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A0F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0F44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A0F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0F4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A0F50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A0F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0F58: 4BD1F9E1  bl 0x822c0938
	ctx.lr = 0x825A0F5C;
	sub_822C0938(ctx, base);
	// 825A0F5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A0F60: 41820028  beq 0x825a0f88
	if ctx.cr[0].eq {
	pc = 0x825A0F88; continue 'dispatch;
	}
	// 825A0F64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A0F68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A0F6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0F70: 392BAAA8  addi r9, r11, -0x5558
	ctx.r[9].s64 = ctx.r[11].s64 + -21848;
	// 825A0F74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A0F78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A0F7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A0F80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A0F84: 48000008  b 0x825a0f8c
	pc = 0x825A0F8C; continue 'dispatch;
	// 825A0F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0F8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0F94: 409A0044  bne cr6, 0x825a0fd8
	if !ctx.cr[6].eq {
	pc = 0x825A0FD8; continue 'dispatch;
	}
	// 825A0F98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A0F9C: 419A001C  beq cr6, 0x825a0fb8
	if ctx.cr[6].eq {
	pc = 0x825A0FB8; continue 'dispatch;
	}
	// 825A0FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0FA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A0FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0FAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0FB4: 4E800421  bctrl
	ctx.lr = 0x825A0FB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0FB8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A0FBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A0FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0FC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A0FC8: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A0FCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A0FD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A0FD4: 4BD1F02D  bl 0x822c0000
	ctx.lr = 0x825A0FD8;
	sub_822C0000(ctx, base);
	// 825A0FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A0FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0FE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A0FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0FF8 size=196
    let mut pc: u32 = 0x825A0FF8;
    'dispatch: loop {
        match pc {
            0x825A0FF8 => {
    //   block [0x825A0FF8..0x825A10BC)
	// 825A0FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A1004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A100C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A1010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A1014: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A1018: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A101C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A1020: 4BD1F919  bl 0x822c0938
	ctx.lr = 0x825A1024;
	sub_822C0938(ctx, base);
	// 825A1024: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1028: 41820028  beq 0x825a1050
	if ctx.cr[0].eq {
	pc = 0x825A1050; continue 'dispatch;
	}
	// 825A102C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1030: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A1034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A1038: 392BAABC  addi r9, r11, -0x5544
	ctx.r[9].s64 = ctx.r[11].s64 + -21828;
	// 825A103C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A1040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A1044: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A1048: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A104C: 48000008  b 0x825a1054
	pc = 0x825A1054; continue 'dispatch;
	// 825A1050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A1054: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A1058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A105C: 409A0044  bne cr6, 0x825a10a0
	if !ctx.cr[6].eq {
	pc = 0x825A10A0; continue 'dispatch;
	}
	// 825A1060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A1064: 419A001C  beq cr6, 0x825a1080
	if ctx.cr[6].eq {
	pc = 0x825A1080; continue 'dispatch;
	}
	// 825A1068: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A106C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A1070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1074: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A107C: 4E800421  bctrl
	ctx.lr = 0x825A1080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1080: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A1084: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A1088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A108C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A1090: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A1094: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A1098: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A109C: 4BD1EF65  bl 0x822c0000
	ctx.lr = 0x825A10A0;
	sub_822C0000(ctx, base);
	// 825A10A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A10A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A10A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A10AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A10B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A10B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A10B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A10C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A10C0 size=196
    let mut pc: u32 = 0x825A10C0;
    'dispatch: loop {
        match pc {
            0x825A10C0 => {
    //   block [0x825A10C0..0x825A1184)
	// 825A10C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A10C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A10C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A10CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A10D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A10D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A10D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A10DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A10E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A10E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A10E8: 4BD1F851  bl 0x822c0938
	ctx.lr = 0x825A10EC;
	sub_822C0938(ctx, base);
	// 825A10EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A10F0: 41820028  beq 0x825a1118
	if ctx.cr[0].eq {
	pc = 0x825A1118; continue 'dispatch;
	}
	// 825A10F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A10F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A10FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A1100: 392BAAD0  addi r9, r11, -0x5530
	ctx.r[9].s64 = ctx.r[11].s64 + -21808;
	// 825A1104: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A1108: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A110C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A1110: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1114: 48000008  b 0x825a111c
	pc = 0x825A111C; continue 'dispatch;
	// 825A1118: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A111C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A1120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1124: 409A0044  bne cr6, 0x825a1168
	if !ctx.cr[6].eq {
	pc = 0x825A1168; continue 'dispatch;
	}
	// 825A1128: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A112C: 419A001C  beq cr6, 0x825a1148
	if ctx.cr[6].eq {
	pc = 0x825A1148; continue 'dispatch;
	}
	// 825A1130: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1134: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A1138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A113C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1144: 4E800421  bctrl
	ctx.lr = 0x825A1148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1148: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A114C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A1150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A1154: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A1158: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A115C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A1160: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A1164: 4BD1EE9D  bl 0x822c0000
	ctx.lr = 0x825A1168;
	sub_822C0000(ctx, base);
	// 825A1168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A116C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A117C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1188 size=196
    let mut pc: u32 = 0x825A1188;
    'dispatch: loop {
        match pc {
            0x825A1188 => {
    //   block [0x825A1188..0x825A124C)
	// 825A1188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A118C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A1194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A119C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A11A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A11A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A11A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A11AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A11B0: 4BD1F789  bl 0x822c0938
	ctx.lr = 0x825A11B4;
	sub_822C0938(ctx, base);
	// 825A11B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A11B8: 41820028  beq 0x825a11e0
	if ctx.cr[0].eq {
	pc = 0x825A11E0; continue 'dispatch;
	}
	// 825A11BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A11C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A11C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A11C8: 392BAAE4  addi r9, r11, -0x551c
	ctx.r[9].s64 = ctx.r[11].s64 + -21788;
	// 825A11CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A11D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A11D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A11D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A11DC: 48000008  b 0x825a11e4
	pc = 0x825A11E4; continue 'dispatch;
	// 825A11E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A11E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A11E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A11EC: 409A0044  bne cr6, 0x825a1230
	if !ctx.cr[6].eq {
	pc = 0x825A1230; continue 'dispatch;
	}
	// 825A11F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A11F4: 419A001C  beq cr6, 0x825a1210
	if ctx.cr[6].eq {
	pc = 0x825A1210; continue 'dispatch;
	}
	// 825A11F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A11FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A1200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1204: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1208: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A120C: 4E800421  bctrl
	ctx.lr = 0x825A1210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1210: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A1214: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A1218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A121C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A1220: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A1224: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A1228: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A122C: 4BD1EDD5  bl 0x822c0000
	ctx.lr = 0x825A1230;
	sub_822C0000(ctx, base);
	// 825A1230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1234: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A123C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1240: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A1244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1250 size=196
    let mut pc: u32 = 0x825A1250;
    'dispatch: loop {
        match pc {
            0x825A1250 => {
    //   block [0x825A1250..0x825A1314)
	// 825A1250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A125C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A1268: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A126C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A1270: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A1274: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A1278: 4BD1F6C1  bl 0x822c0938
	ctx.lr = 0x825A127C;
	sub_822C0938(ctx, base);
	// 825A127C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1280: 41820028  beq 0x825a12a8
	if ctx.cr[0].eq {
	pc = 0x825A12A8; continue 'dispatch;
	}
	// 825A1284: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1288: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A128C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A1290: 392BAAF8  addi r9, r11, -0x5508
	ctx.r[9].s64 = ctx.r[11].s64 + -21768;
	// 825A1294: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A1298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A129C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A12A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A12A4: 48000008  b 0x825a12ac
	pc = 0x825A12AC; continue 'dispatch;
	// 825A12A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A12AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A12B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A12B4: 409A0044  bne cr6, 0x825a12f8
	if !ctx.cr[6].eq {
	pc = 0x825A12F8; continue 'dispatch;
	}
	// 825A12B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A12BC: 419A001C  beq cr6, 0x825a12d8
	if ctx.cr[6].eq {
	pc = 0x825A12D8; continue 'dispatch;
	}
	// 825A12C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A12C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A12C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A12CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A12D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A12D4: 4E800421  bctrl
	ctx.lr = 0x825A12D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A12D8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A12DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A12E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A12E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A12E8: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A12EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A12F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A12F4: 4BD1ED0D  bl 0x822c0000
	ctx.lr = 0x825A12F8;
	sub_822C0000(ctx, base);
	// 825A12F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A12FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1308: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A130C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1318 size=92
    let mut pc: u32 = 0x825A1318;
    'dispatch: loop {
        match pc {
            0x825A1318 => {
    //   block [0x825A1318..0x825A1374)
	// 825A1318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A131C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A1324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A132C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A1330: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1334: 4800001C  b 0x825a1350
	pc = 0x825A1350; continue 'dispatch;
	// 825A1338: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A133C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1340: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A1344: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1348: 4E800421  bctrl
	ctx.lr = 0x825A134C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A134C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825A1350: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1354: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A1358: 409AFFE0  bne cr6, 0x825a1338
	if !ctx.cr[6].eq {
	pc = 0x825A1338; continue 'dispatch;
	}
	// 825A135C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1360: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1364: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1368: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A136C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1378 size=92
    let mut pc: u32 = 0x825A1378;
    'dispatch: loop {
        match pc {
            0x825A1378 => {
    //   block [0x825A1378..0x825A13D4)
	// 825A1378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A137C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A1384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A138C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A1390: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1394: 4800001C  b 0x825a13b0
	pc = 0x825A13B0; continue 'dispatch;
	// 825A1398: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A139C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A13A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825A13A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A13A8: 4E800421  bctrl
	ctx.lr = 0x825A13AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A13AC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825A13B0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A13B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A13B8: 409AFFE0  bne cr6, 0x825a1398
	if !ctx.cr[6].eq {
	pc = 0x825A1398; continue 'dispatch;
	}
	// 825A13BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A13C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A13C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A13C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A13CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A13D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A13D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A13D8 size=76
    let mut pc: u32 = 0x825A13D8;
    'dispatch: loop {
        match pc {
            0x825A13D8 => {
    //   block [0x825A13D8..0x825A1424)
	// 825A13D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A13DC: 48C06D91  bl 0x831a816c
	ctx.lr = 0x825A13E0;
	sub_831A8130(ctx, base);
	// 825A13E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A13E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A13E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825A13EC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A13F0: 48000020  b 0x825a1410
	pc = 0x825A1410; continue 'dispatch;
	// 825A13F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A13F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A13FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1400: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825A1404: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1408: 4E800421  bctrl
	ctx.lr = 0x825A140C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A140C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825A1410: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1414: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A1418: 409AFFDC  bne cr6, 0x825a13f4
	if !ctx.cr[6].eq {
	pc = 0x825A13F4; continue 'dispatch;
	}
	// 825A141C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1420: 48C06D9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1428 size=76
    let mut pc: u32 = 0x825A1428;
    'dispatch: loop {
        match pc {
            0x825A1428 => {
    //   block [0x825A1428..0x825A1474)
	// 825A1428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A142C: 48C06D41  bl 0x831a816c
	ctx.lr = 0x825A1430;
	sub_831A8130(ctx, base);
	// 825A1430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A1438: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825A143C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1440: 48000020  b 0x825a1460
	pc = 0x825A1460; continue 'dispatch;
	// 825A1444: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A144C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1450: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825A1454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1458: 4E800421  bctrl
	ctx.lr = 0x825A145C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A145C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825A1460: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1464: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A1468: 409AFFDC  bne cr6, 0x825a1444
	if !ctx.cr[6].eq {
	pc = 0x825A1444; continue 'dispatch;
	}
	// 825A146C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1470: 48C06D4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1478 size=88
    let mut pc: u32 = 0x825A1478;
    'dispatch: loop {
        match pc {
            0x825A1478 => {
    //   block [0x825A1478..0x825A14D0)
	// 825A1478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A147C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1484: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1488: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 825A148C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1490: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 825A1494: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 825A1498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A149C: 4BF7AD0D  bl 0x8251c1a8
	ctx.lr = 0x825A14A0;
	sub_8251C1A8(ctx, base);
	// 825A14A0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825A14A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A14A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A14AC: 419A000C  beq cr6, 0x825a14b8
	if ctx.cr[6].eq {
	pc = 0x825A14B8; continue 'dispatch;
	}
	// 825A14B0: 886B0010  lbz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A14B4: 48000008  b 0x825a14bc
	pc = 0x825A14BC; continue 'dispatch;
	// 825A14B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825A14BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A14C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A14C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A14C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A14CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A14D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A14D0 size=100
    let mut pc: u32 = 0x825A14D0;
    'dispatch: loop {
        match pc {
            0x825A14D0 => {
    //   block [0x825A14D0..0x825A1534)
	// 825A14D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A14D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A14D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A14DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A14E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A14E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A14E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A14EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A14F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A14F4: 419A0018  beq cr6, 0x825a150c
	if ctx.cr[6].eq {
	pc = 0x825A150C; continue 'dispatch;
	}
	// 825A14F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A14FC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1500: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A1504: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825A1508: 41990008  bgt cr6, 0x825a1510
	if ctx.cr[6].gt {
	pc = 0x825A1510; continue 'dispatch;
	}
	// 825A150C: 4BEE936D  bl 0x8248a878
	ctx.lr = 0x825A1510;
	sub_8248A878(ctx, base);
	// 825A1510: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1514: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A1518: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825A151C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1528: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A152C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1538 size=76
    let mut pc: u32 = 0x825A1538;
    'dispatch: loop {
        match pc {
            0x825A1538 => {
    //   block [0x825A1538..0x825A1584)
	// 825A1538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A153C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1548: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A154C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A1550: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 825A1554: 4BFFFF7D  bl 0x825a14d0
	ctx.lr = 0x825A1558;
	sub_825A14D0(ctx, base);
	// 825A1558: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A155C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1564: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825A1568: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A156C: 4E800421  bctrl
	ctx.lr = 0x825A1570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1570: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A1574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A157C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1588 size=200
    let mut pc: u32 = 0x825A1588;
    'dispatch: loop {
        match pc {
            0x825A1588 => {
    //   block [0x825A1588..0x825A1650)
	// 825A1588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A158C: 48C06BD5  bl 0x831a8160
	ctx.lr = 0x825A1590;
	sub_831A8130(ctx, base);
	// 825A1590: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1594: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1598: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825A159C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825A15A0: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 825A15A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A15A8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A15AC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A15B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A15B4: 419A0094  beq cr6, 0x825a1648
	if ctx.cr[6].eq {
	pc = 0x825A1648; continue 'dispatch;
	}
	// 825A15B8: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A15BC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A15C0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A15C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A15C8: 40980080  bge cr6, 0x825a1648
	if !ctx.cr[6].lt {
	pc = 0x825A1648; continue 'dispatch;
	}
	// 825A15CC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A15D0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A15D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A15D8: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A15DC: 48004EAD  bl 0x825a6488
	ctx.lr = 0x825A15E0;
	sub_825A6488(ctx, base);
	// 825A15E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A15E4: 48851D25  bl 0x82df3308
	ctx.lr = 0x825A15E8;
	sub_82DF3308(ctx, base);
	// 825A15E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A15EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A15F0: 48851E39  bl 0x82df3428
	ctx.lr = 0x825A15F4;
	sub_82DF3428(ctx, base);
	// 825A15F4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A15F8: 41820048  beq 0x825a1640
	if ctx.cr[0].eq {
	pc = 0x825A1640; continue 'dispatch;
	}
	// 825A15FC: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 825A1600: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A1604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1608: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A160C: 4BF7AB9D  bl 0x8251c1a8
	ctx.lr = 0x825A1610;
	sub_8251C1A8(ctx, base);
	// 825A1610: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 825A1614: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A1618: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A161C: 419A000C  beq cr6, 0x825a1628
	if ctx.cr[6].eq {
	pc = 0x825A1628; continue 'dispatch;
	}
	// 825A1620: 9B6B0010  stb r27, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[27].u8 ) };
	// 825A1624: 4800001C  b 0x825a1640
	pc = 0x825A1640; continue 'dispatch;
	// 825A1628: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825A162C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A1630: 9B610064  stb r27, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u8 ) };
	// 825A1634: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1638: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825A163C: 4BF7B54D  bl 0x8251cb88
	ctx.lr = 0x825A1640;
	sub_8251CB88(ctx, base);
	// 825A1640: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A1644: 4BFFFF64  b 0x825a15a8
	pc = 0x825A15A8; continue 'dispatch;
	// 825A1648: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825A164C: 48C06B64  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1650 size=284
    let mut pc: u32 = 0x825A1650;
    'dispatch: loop {
        match pc {
            0x825A1650 => {
    //   block [0x825A1650..0x825A176C)
	// 825A1650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1654: 48C06B19  bl 0x831a816c
	ctx.lr = 0x825A1658;
	sub_831A8130(ctx, base);
	// 825A1658: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A165C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1660: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1664: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1668: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A166C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A1670: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A1674: 38A00121  li r5, 0x121
	ctx.r[5].s64 = 289;
	// 825A1678: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A167C: 4BD1ED5D  bl 0x822c03d8
	ctx.lr = 0x825A1680;
	sub_822C03D8(ctx, base);
	// 825A1680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1684: 41820014  beq 0x825a1698
	if ctx.cr[0].eq {
	pc = 0x825A1698; continue 'dispatch;
	}
	// 825A1688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A168C: 4800C6AD  bl 0x825add38
	ctx.lr = 0x825A1690;
	sub_825ADD38(ctx, base);
	// 825A1690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1694: 48000008  b 0x825a169c
	pc = 0x825A169C; continue 'dispatch;
	// 825A1698: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A169C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A16A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A16A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A16A8: 4BFFF889  bl 0x825a0f30
	ctx.lr = 0x825A16AC;
	sub_825A0F30(ctx, base);
	// 825A16AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A16B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A16B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A16B8: 4BD1E949  bl 0x822c0000
	ctx.lr = 0x825A16BC;
	sub_822C0000(ctx, base);
	// 825A16BC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A16C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A16C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A16C8: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A16CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A16D0: 4E800421  bctrl
	ctx.lr = 0x825A16D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A16D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A16D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A16DC: 4823438D  bl 0x827d5a68
	ctx.lr = 0x825A16E0;
	sub_827D5A68(ctx, base);
	// 825A16E0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A16E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A16E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A16EC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A16F0: 419A0024  beq cr6, 0x825a1714
	if ctx.cr[6].eq {
	pc = 0x825A1714; continue 'dispatch;
	}
	// 825A16F4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A16F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A16FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1700: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1704: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1708: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A170C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1710: 4082FFE8  bne 0x825a16f8
	if !ctx.cr[0].eq {
	pc = 0x825A16F8; continue 'dispatch;
	}
	// 825A1714: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A171C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1720: 486119E9  bl 0x82bb3108
	ctx.lr = 0x825A1724;
	sub_82BB3108(ctx, base);
	// 825A1724: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1728: 419A000C  beq cr6, 0x825a1734
	if ctx.cr[6].eq {
	pc = 0x825A1734; continue 'dispatch;
	}
	// 825A172C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1730: 4BD1F161  bl 0x822c0890
	ctx.lr = 0x825A1734;
	sub_822C0890(ctx, base);
	// 825A1734: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A173C: 419A0010  beq cr6, 0x825a174c
	if ctx.cr[6].eq {
	pc = 0x825A174C; continue 'dispatch;
	}
	// 825A1740: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1744: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1748: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A174C: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A1750: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1754: 419A000C  beq cr6, 0x825a1760
	if ctx.cr[6].eq {
	pc = 0x825A1760; continue 'dispatch;
	}
	// 825A1758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A175C: 4BD1F135  bl 0x822c0890
	ctx.lr = 0x825A1760;
	sub_822C0890(ctx, base);
	// 825A1760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1764: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A1768: 48C06A54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A1770 size=344
    let mut pc: u32 = 0x825A1770;
    'dispatch: loop {
        match pc {
            0x825A1770 => {
    //   block [0x825A1770..0x825A18C8)
	// 825A1770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1774: 48C069F9  bl 0x831a816c
	ctx.lr = 0x825A1778;
	sub_831A8130(ctx, base);
	// 825A1778: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A177C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A1780: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1784: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1788: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825A178C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A1790: 4BFEA781  bl 0x8258bf10
	ctx.lr = 0x825A1794;
	sub_8258BF10(ctx, base);
	// 825A1794: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825A1798: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 825A179C: C07F0010  lfs f3, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825A17A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825A17A4: C05F000C  lfs f2, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825A17A8: C03F0008  lfs f1, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A17AC: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A17B0: 4800C299  bl 0x825ada48
	ctx.lr = 0x825A17B4;
	sub_825ADA48(ctx, base);
	// 825A17B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A17B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A17BC: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A17C0: 38A00133  li r5, 0x133
	ctx.r[5].s64 = 307;
	// 825A17C4: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A17C8: 4BD1EC11  bl 0x822c03d8
	ctx.lr = 0x825A17CC;
	sub_822C03D8(ctx, base);
	// 825A17CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A17D0: 41820014  beq 0x825a17e4
	if ctx.cr[0].eq {
	pc = 0x825A17E4; continue 'dispatch;
	}
	// 825A17D4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825A17D8: 4800C561  bl 0x825add38
	ctx.lr = 0x825A17DC;
	sub_825ADD38(ctx, base);
	// 825A17DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A17E0: 48000008  b 0x825a17e8
	pc = 0x825A17E8; continue 'dispatch;
	// 825A17E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A17E8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A17EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A17F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A17F4: 4BFFF73D  bl 0x825a0f30
	ctx.lr = 0x825A17F8;
	sub_825A0F30(ctx, base);
	// 825A17F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A17FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1800: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1804: 4BD1E7FD  bl 0x822c0000
	ctx.lr = 0x825A1808;
	sub_822C0000(ctx, base);
	// 825A1808: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A180C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1810: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1814: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A181C: 4E800421  bctrl
	ctx.lr = 0x825A1820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1828: 48234241  bl 0x827d5a68
	ctx.lr = 0x825A182C;
	sub_827D5A68(ctx, base);
	// 825A182C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1830: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1834: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1838: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A183C: 419A0024  beq cr6, 0x825a1860
	if ctx.cr[6].eq {
	pc = 0x825A1860; continue 'dispatch;
	}
	// 825A1840: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1844: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1848: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A184C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1850: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1854: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1858: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A185C: 4082FFE8  bne 0x825a1844
	if !ctx.cr[0].eq {
	pc = 0x825A1844; continue 'dispatch;
	}
	// 825A1860: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1864: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A186C: 4861189D  bl 0x82bb3108
	ctx.lr = 0x825A1870;
	sub_82BB3108(ctx, base);
	// 825A1870: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1874: 419A000C  beq cr6, 0x825a1880
	if ctx.cr[6].eq {
	pc = 0x825A1880; continue 'dispatch;
	}
	// 825A1878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A187C: 4BD1F015  bl 0x822c0890
	ctx.lr = 0x825A1880;
	sub_822C0890(ctx, base);
	// 825A1880: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1888: 419A0010  beq cr6, 0x825a1898
	if ctx.cr[6].eq {
	pc = 0x825A1898; continue 'dispatch;
	}
	// 825A188C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1890: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1894: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A1898: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A189C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A18A0: 419A000C  beq cr6, 0x825a18ac
	if ctx.cr[6].eq {
	pc = 0x825A18AC; continue 'dispatch;
	}
	// 825A18A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A18A8: 4BD1EFE9  bl 0x822c0890
	ctx.lr = 0x825A18AC;
	sub_822C0890(ctx, base);
	// 825A18AC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825A18B0: 48851B79  bl 0x82df3428
	ctx.lr = 0x825A18B4;
	sub_82DF3428(ctx, base);
	// 825A18B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825A18B8: 4BD27401  bl 0x822c8cb8
	ctx.lr = 0x825A18BC;
	sub_822C8CB8(ctx, base);
	// 825A18BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A18C0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825A18C4: 48C068F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A18C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A18C8 size=284
    let mut pc: u32 = 0x825A18C8;
    'dispatch: loop {
        match pc {
            0x825A18C8 => {
    //   block [0x825A18C8..0x825A19E4)
	// 825A18C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A18CC: 48C068A1  bl 0x831a816c
	ctx.lr = 0x825A18D0;
	sub_831A8130(ctx, base);
	// 825A18D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A18D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A18D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A18DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A18E0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A18E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A18E8: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A18EC: 38A00121  li r5, 0x121
	ctx.r[5].s64 = 289;
	// 825A18F0: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A18F4: 4BD1EAE5  bl 0x822c03d8
	ctx.lr = 0x825A18F8;
	sub_822C03D8(ctx, base);
	// 825A18F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A18FC: 41820014  beq 0x825a1910
	if ctx.cr[0].eq {
	pc = 0x825A1910; continue 'dispatch;
	}
	// 825A1900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1904: 4800C855  bl 0x825ae158
	ctx.lr = 0x825A1908;
	sub_825AE158(ctx, base);
	// 825A1908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A190C: 48000008  b 0x825a1914
	pc = 0x825A1914; continue 'dispatch;
	// 825A1910: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A1914: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A191C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1920: 4BFFF6D9  bl 0x825a0ff8
	ctx.lr = 0x825A1924;
	sub_825A0FF8(ctx, base);
	// 825A1924: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A192C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1930: 4BD1E6D1  bl 0x822c0000
	ctx.lr = 0x825A1934;
	sub_822C0000(ctx, base);
	// 825A1934: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A193C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1940: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1944: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1948: 4E800421  bctrl
	ctx.lr = 0x825A194C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A194C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1954: 48234115  bl 0x827d5a68
	ctx.lr = 0x825A1958;
	sub_827D5A68(ctx, base);
	// 825A1958: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A195C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1960: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1964: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A1968: 419A0024  beq cr6, 0x825a198c
	if ctx.cr[6].eq {
	pc = 0x825A198C; continue 'dispatch;
	}
	// 825A196C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1970: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1978: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A197C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1980: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1984: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1988: 4082FFE8  bne 0x825a1970
	if !ctx.cr[0].eq {
	pc = 0x825A1970; continue 'dispatch;
	}
	// 825A198C: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1998: 48611771  bl 0x82bb3108
	ctx.lr = 0x825A199C;
	sub_82BB3108(ctx, base);
	// 825A199C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A19A0: 419A000C  beq cr6, 0x825a19ac
	if ctx.cr[6].eq {
	pc = 0x825A19AC; continue 'dispatch;
	}
	// 825A19A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A19A8: 4BD1EEE9  bl 0x822c0890
	ctx.lr = 0x825A19AC;
	sub_822C0890(ctx, base);
	// 825A19AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A19B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A19B4: 419A0010  beq cr6, 0x825a19c4
	if ctx.cr[6].eq {
	pc = 0x825A19C4; continue 'dispatch;
	}
	// 825A19B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A19BC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A19C0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A19C4: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A19C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A19CC: 419A000C  beq cr6, 0x825a19d8
	if ctx.cr[6].eq {
	pc = 0x825A19D8; continue 'dispatch;
	}
	// 825A19D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A19D4: 4BD1EEBD  bl 0x822c0890
	ctx.lr = 0x825A19D8;
	sub_822C0890(ctx, base);
	// 825A19D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A19DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A19E0: 48C067DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A19E8 size=344
    let mut pc: u32 = 0x825A19E8;
    'dispatch: loop {
        match pc {
            0x825A19E8 => {
    //   block [0x825A19E8..0x825A1B40)
	// 825A19E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A19EC: 48C06781  bl 0x831a816c
	ctx.lr = 0x825A19F0;
	sub_831A8130(ctx, base);
	// 825A19F0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A19F4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A19F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A19FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1A00: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825A1A04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A1A08: 4BFEA509  bl 0x8258bf10
	ctx.lr = 0x825A1A0C;
	sub_8258BF10(ctx, base);
	// 825A1A0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825A1A10: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 825A1A14: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A1A18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825A1A1C: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1A20: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1A24: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1A28: 4800C0F9  bl 0x825adb20
	ctx.lr = 0x825A1A2C;
	sub_825ADB20(ctx, base);
	// 825A1A2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1A30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A1A34: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A1A38: 38A00133  li r5, 0x133
	ctx.r[5].s64 = 307;
	// 825A1A3C: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A1A40: 4BD1E999  bl 0x822c03d8
	ctx.lr = 0x825A1A44;
	sub_822C03D8(ctx, base);
	// 825A1A44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1A48: 41820014  beq 0x825a1a5c
	if ctx.cr[0].eq {
	pc = 0x825A1A5C; continue 'dispatch;
	}
	// 825A1A4C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825A1A50: 4800C709  bl 0x825ae158
	ctx.lr = 0x825A1A54;
	sub_825AE158(ctx, base);
	// 825A1A54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1A58: 48000008  b 0x825a1a60
	pc = 0x825A1A60; continue 'dispatch;
	// 825A1A5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A1A60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1A64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1A68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1A6C: 4BFFF58D  bl 0x825a0ff8
	ctx.lr = 0x825A1A70;
	sub_825A0FF8(ctx, base);
	// 825A1A70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1A74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1A78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1A7C: 4BD1E585  bl 0x822c0000
	ctx.lr = 0x825A1A80;
	sub_822C0000(ctx, base);
	// 825A1A80: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1A88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1A8C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1A94: 4E800421  bctrl
	ctx.lr = 0x825A1A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1AA0: 48233FC9  bl 0x827d5a68
	ctx.lr = 0x825A1AA4;
	sub_827D5A68(ctx, base);
	// 825A1AA4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1AA8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1AAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1AB0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A1AB4: 419A0024  beq cr6, 0x825a1ad8
	if ctx.cr[6].eq {
	pc = 0x825A1AD8; continue 'dispatch;
	}
	// 825A1AB8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1ABC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1AC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1AC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1AC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1ACC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1AD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1AD4: 4082FFE8  bne 0x825a1abc
	if !ctx.cr[0].eq {
	pc = 0x825A1ABC; continue 'dispatch;
	}
	// 825A1AD8: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1ADC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1AE4: 48611625  bl 0x82bb3108
	ctx.lr = 0x825A1AE8;
	sub_82BB3108(ctx, base);
	// 825A1AE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1AEC: 419A000C  beq cr6, 0x825a1af8
	if ctx.cr[6].eq {
	pc = 0x825A1AF8; continue 'dispatch;
	}
	// 825A1AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1AF4: 4BD1ED9D  bl 0x822c0890
	ctx.lr = 0x825A1AF8;
	sub_822C0890(ctx, base);
	// 825A1AF8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1B00: 419A0010  beq cr6, 0x825a1b10
	if ctx.cr[6].eq {
	pc = 0x825A1B10; continue 'dispatch;
	}
	// 825A1B04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1B08: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1B0C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A1B10: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A1B14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1B18: 419A000C  beq cr6, 0x825a1b24
	if ctx.cr[6].eq {
	pc = 0x825A1B24; continue 'dispatch;
	}
	// 825A1B1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1B20: 4BD1ED71  bl 0x822c0890
	ctx.lr = 0x825A1B24;
	sub_822C0890(ctx, base);
	// 825A1B24: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825A1B28: 48851901  bl 0x82df3428
	ctx.lr = 0x825A1B2C;
	sub_82DF3428(ctx, base);
	// 825A1B2C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825A1B30: 4BD27189  bl 0x822c8cb8
	ctx.lr = 0x825A1B34;
	sub_822C8CB8(ctx, base);
	// 825A1B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1B38: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825A1B3C: 48C06680  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1B40 size=284
    let mut pc: u32 = 0x825A1B40;
    'dispatch: loop {
        match pc {
            0x825A1B40 => {
    //   block [0x825A1B40..0x825A1C5C)
	// 825A1B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1B44: 48C06629  bl 0x831a816c
	ctx.lr = 0x825A1B48;
	sub_831A8130(ctx, base);
	// 825A1B48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1B4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1B50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1B54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1B58: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A1B5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A1B60: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A1B64: 38A00121  li r5, 0x121
	ctx.r[5].s64 = 289;
	// 825A1B68: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A1B6C: 4BD1E86D  bl 0x822c03d8
	ctx.lr = 0x825A1B70;
	sub_822C03D8(ctx, base);
	// 825A1B70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1B74: 41820014  beq 0x825a1b88
	if ctx.cr[0].eq {
	pc = 0x825A1B88; continue 'dispatch;
	}
	// 825A1B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1B7C: 4800C47D  bl 0x825adff8
	ctx.lr = 0x825A1B80;
	sub_825ADFF8(ctx, base);
	// 825A1B80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1B84: 48000008  b 0x825a1b8c
	pc = 0x825A1B8C; continue 'dispatch;
	// 825A1B88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A1B8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1B90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1B94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1B98: 4BFFF529  bl 0x825a10c0
	ctx.lr = 0x825A1B9C;
	sub_825A10C0(ctx, base);
	// 825A1B9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1BA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1BA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1BA8: 4BD1E459  bl 0x822c0000
	ctx.lr = 0x825A1BAC;
	sub_822C0000(ctx, base);
	// 825A1BAC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1BB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1BB8: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1BBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1BC0: 4E800421  bctrl
	ctx.lr = 0x825A1BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1BC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1BCC: 48233E9D  bl 0x827d5a68
	ctx.lr = 0x825A1BD0;
	sub_827D5A68(ctx, base);
	// 825A1BD0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1BD4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1BD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1BDC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A1BE0: 419A0024  beq cr6, 0x825a1c04
	if ctx.cr[6].eq {
	pc = 0x825A1C04; continue 'dispatch;
	}
	// 825A1BE4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1BE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1BEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1BF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1BF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1BF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1BFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1C00: 4082FFE8  bne 0x825a1be8
	if !ctx.cr[0].eq {
	pc = 0x825A1BE8; continue 'dispatch;
	}
	// 825A1C04: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1C08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1C10: 486114F9  bl 0x82bb3108
	ctx.lr = 0x825A1C14;
	sub_82BB3108(ctx, base);
	// 825A1C14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1C18: 419A000C  beq cr6, 0x825a1c24
	if ctx.cr[6].eq {
	pc = 0x825A1C24; continue 'dispatch;
	}
	// 825A1C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1C20: 4BD1EC71  bl 0x822c0890
	ctx.lr = 0x825A1C24;
	sub_822C0890(ctx, base);
	// 825A1C24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1C2C: 419A0010  beq cr6, 0x825a1c3c
	if ctx.cr[6].eq {
	pc = 0x825A1C3C; continue 'dispatch;
	}
	// 825A1C30: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1C34: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1C38: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A1C3C: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A1C40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1C44: 419A000C  beq cr6, 0x825a1c50
	if ctx.cr[6].eq {
	pc = 0x825A1C50; continue 'dispatch;
	}
	// 825A1C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1C4C: 4BD1EC45  bl 0x822c0890
	ctx.lr = 0x825A1C50;
	sub_822C0890(ctx, base);
	// 825A1C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1C54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A1C58: 48C06564  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1C60 size=344
    let mut pc: u32 = 0x825A1C60;
    'dispatch: loop {
        match pc {
            0x825A1C60 => {
    //   block [0x825A1C60..0x825A1DB8)
	// 825A1C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1C64: 48C06509  bl 0x831a816c
	ctx.lr = 0x825A1C68;
	sub_831A8130(ctx, base);
	// 825A1C68: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1C6C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A1C70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1C74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1C78: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825A1C7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A1C80: 4BFEA291  bl 0x8258bf10
	ctx.lr = 0x825A1C84;
	sub_8258BF10(ctx, base);
	// 825A1C84: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825A1C88: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 825A1C8C: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A1C90: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825A1C94: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1C98: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1C9C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1CA0: 4800BE81  bl 0x825adb20
	ctx.lr = 0x825A1CA4;
	sub_825ADB20(ctx, base);
	// 825A1CA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1CA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A1CAC: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A1CB0: 38A00133  li r5, 0x133
	ctx.r[5].s64 = 307;
	// 825A1CB4: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A1CB8: 4BD1E721  bl 0x822c03d8
	ctx.lr = 0x825A1CBC;
	sub_822C03D8(ctx, base);
	// 825A1CBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1CC0: 41820014  beq 0x825a1cd4
	if ctx.cr[0].eq {
	pc = 0x825A1CD4; continue 'dispatch;
	}
	// 825A1CC4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825A1CC8: 4800C331  bl 0x825adff8
	ctx.lr = 0x825A1CCC;
	sub_825ADFF8(ctx, base);
	// 825A1CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1CD0: 48000008  b 0x825a1cd8
	pc = 0x825A1CD8; continue 'dispatch;
	// 825A1CD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A1CD8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1CE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1CE4: 4BFFF3DD  bl 0x825a10c0
	ctx.lr = 0x825A1CE8;
	sub_825A10C0(ctx, base);
	// 825A1CE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1CF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1CF4: 4BD1E30D  bl 0x822c0000
	ctx.lr = 0x825A1CF8;
	sub_822C0000(ctx, base);
	// 825A1CF8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1D00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1D04: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1D08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1D0C: 4E800421  bctrl
	ctx.lr = 0x825A1D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1D18: 48233D51  bl 0x827d5a68
	ctx.lr = 0x825A1D1C;
	sub_827D5A68(ctx, base);
	// 825A1D1C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1D20: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1D24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1D28: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A1D2C: 419A0024  beq cr6, 0x825a1d50
	if ctx.cr[6].eq {
	pc = 0x825A1D50; continue 'dispatch;
	}
	// 825A1D30: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1D34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1D38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1D3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1D40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1D44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1D48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1D4C: 4082FFE8  bne 0x825a1d34
	if !ctx.cr[0].eq {
	pc = 0x825A1D34; continue 'dispatch;
	}
	// 825A1D50: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1D54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1D5C: 486113AD  bl 0x82bb3108
	ctx.lr = 0x825A1D60;
	sub_82BB3108(ctx, base);
	// 825A1D60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1D64: 419A000C  beq cr6, 0x825a1d70
	if ctx.cr[6].eq {
	pc = 0x825A1D70; continue 'dispatch;
	}
	// 825A1D68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1D6C: 4BD1EB25  bl 0x822c0890
	ctx.lr = 0x825A1D70;
	sub_822C0890(ctx, base);
	// 825A1D70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1D78: 419A0010  beq cr6, 0x825a1d88
	if ctx.cr[6].eq {
	pc = 0x825A1D88; continue 'dispatch;
	}
	// 825A1D7C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1D80: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1D84: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A1D88: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A1D8C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1D90: 419A000C  beq cr6, 0x825a1d9c
	if ctx.cr[6].eq {
	pc = 0x825A1D9C; continue 'dispatch;
	}
	// 825A1D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1D98: 4BD1EAF9  bl 0x822c0890
	ctx.lr = 0x825A1D9C;
	sub_822C0890(ctx, base);
	// 825A1D9C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825A1DA0: 48851689  bl 0x82df3428
	ctx.lr = 0x825A1DA4;
	sub_82DF3428(ctx, base);
	// 825A1DA4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825A1DA8: 4BD26F11  bl 0x822c8cb8
	ctx.lr = 0x825A1DAC;
	sub_822C8CB8(ctx, base);
	// 825A1DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1DB0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825A1DB4: 48C06408  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1DB8 size=284
    let mut pc: u32 = 0x825A1DB8;
    'dispatch: loop {
        match pc {
            0x825A1DB8 => {
    //   block [0x825A1DB8..0x825A1ED4)
	// 825A1DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1DBC: 48C063B1  bl 0x831a816c
	ctx.lr = 0x825A1DC0;
	sub_831A8130(ctx, base);
	// 825A1DC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1DC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1DC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1DCC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1DD0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A1DD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A1DD8: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A1DDC: 38A00121  li r5, 0x121
	ctx.r[5].s64 = 289;
	// 825A1DE0: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A1DE4: 4BD1E5F5  bl 0x822c03d8
	ctx.lr = 0x825A1DE8;
	sub_822C03D8(ctx, base);
	// 825A1DE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1DEC: 41820014  beq 0x825a1e00
	if ctx.cr[0].eq {
	pc = 0x825A1E00; continue 'dispatch;
	}
	// 825A1DF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1DF4: 4800C0A5  bl 0x825ade98
	ctx.lr = 0x825A1DF8;
	sub_825ADE98(ctx, base);
	// 825A1DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1DFC: 48000008  b 0x825a1e04
	pc = 0x825A1E04; continue 'dispatch;
	// 825A1E00: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A1E04: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1E08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1E0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1E10: 4BFFF379  bl 0x825a1188
	ctx.lr = 0x825A1E14;
	sub_825A1188(ctx, base);
	// 825A1E14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1E18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1E1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1E20: 4BD1E1E1  bl 0x822c0000
	ctx.lr = 0x825A1E24;
	sub_822C0000(ctx, base);
	// 825A1E24: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1E2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1E30: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1E38: 4E800421  bctrl
	ctx.lr = 0x825A1E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1E3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1E44: 48233C25  bl 0x827d5a68
	ctx.lr = 0x825A1E48;
	sub_827D5A68(ctx, base);
	// 825A1E48: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1E4C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1E50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1E54: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A1E58: 419A0024  beq cr6, 0x825a1e7c
	if ctx.cr[6].eq {
	pc = 0x825A1E7C; continue 'dispatch;
	}
	// 825A1E5C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1E60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1E64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1E68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1E6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1E70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1E74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1E78: 4082FFE8  bne 0x825a1e60
	if !ctx.cr[0].eq {
	pc = 0x825A1E60; continue 'dispatch;
	}
	// 825A1E7C: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1E80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1E88: 48611281  bl 0x82bb3108
	ctx.lr = 0x825A1E8C;
	sub_82BB3108(ctx, base);
	// 825A1E8C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1E90: 419A000C  beq cr6, 0x825a1e9c
	if ctx.cr[6].eq {
	pc = 0x825A1E9C; continue 'dispatch;
	}
	// 825A1E94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1E98: 4BD1E9F9  bl 0x822c0890
	ctx.lr = 0x825A1E9C;
	sub_822C0890(ctx, base);
	// 825A1E9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1EA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1EA4: 419A0010  beq cr6, 0x825a1eb4
	if ctx.cr[6].eq {
	pc = 0x825A1EB4; continue 'dispatch;
	}
	// 825A1EA8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1EAC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1EB0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A1EB4: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A1EB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1EBC: 419A000C  beq cr6, 0x825a1ec8
	if ctx.cr[6].eq {
	pc = 0x825A1EC8; continue 'dispatch;
	}
	// 825A1EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1EC4: 4BD1E9CD  bl 0x822c0890
	ctx.lr = 0x825A1EC8;
	sub_822C0890(ctx, base);
	// 825A1EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A1ED0: 48C062EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1ED8 size=344
    let mut pc: u32 = 0x825A1ED8;
    'dispatch: loop {
        match pc {
            0x825A1ED8 => {
    //   block [0x825A1ED8..0x825A2030)
	// 825A1ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1EDC: 48C06291  bl 0x831a816c
	ctx.lr = 0x825A1EE0;
	sub_831A8130(ctx, base);
	// 825A1EE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1EE4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A1EE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1EEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1EF0: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825A1EF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A1EF8: 4BFEA019  bl 0x8258bf10
	ctx.lr = 0x825A1EFC;
	sub_8258BF10(ctx, base);
	// 825A1EFC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825A1F00: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 825A1F04: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A1F08: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825A1F0C: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1F10: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1F14: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1F18: 4800BC09  bl 0x825adb20
	ctx.lr = 0x825A1F1C;
	sub_825ADB20(ctx, base);
	// 825A1F1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A1F20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A1F24: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A1F28: 38A00133  li r5, 0x133
	ctx.r[5].s64 = 307;
	// 825A1F2C: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 825A1F30: 4BD1E4A9  bl 0x822c03d8
	ctx.lr = 0x825A1F34;
	sub_822C03D8(ctx, base);
	// 825A1F34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A1F38: 41820014  beq 0x825a1f4c
	if ctx.cr[0].eq {
	pc = 0x825A1F4C; continue 'dispatch;
	}
	// 825A1F3C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825A1F40: 4800BF59  bl 0x825ade98
	ctx.lr = 0x825A1F44;
	sub_825ADE98(ctx, base);
	// 825A1F44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1F48: 48000008  b 0x825a1f50
	pc = 0x825A1F50; continue 'dispatch;
	// 825A1F4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A1F50: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1F54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1F58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1F5C: 4BFFF22D  bl 0x825a1188
	ctx.lr = 0x825A1F60;
	sub_825A1188(ctx, base);
	// 825A1F60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1F64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A1F68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1F6C: 4BD1E095  bl 0x822c0000
	ctx.lr = 0x825A1F70;
	sub_822C0000(ctx, base);
	// 825A1F70: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1F78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1F7C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A1F80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1F84: 4E800421  bctrl
	ctx.lr = 0x825A1F88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1F88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A1F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1F90: 48233AD9  bl 0x827d5a68
	ctx.lr = 0x825A1F94;
	sub_827D5A68(ctx, base);
	// 825A1F94: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1F98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A1F9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1FA0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A1FA4: 419A0024  beq cr6, 0x825a1fc8
	if ctx.cr[6].eq {
	pc = 0x825A1FC8; continue 'dispatch;
	}
	// 825A1FA8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A1FAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A1FB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1FB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A1FB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A1FBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A1FC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A1FC4: 4082FFE8  bne 0x825a1fac
	if !ctx.cr[0].eq {
	pc = 0x825A1FAC; continue 'dispatch;
	}
	// 825A1FC8: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A1FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1FD4: 48611135  bl 0x82bb3108
	ctx.lr = 0x825A1FD8;
	sub_82BB3108(ctx, base);
	// 825A1FD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A1FDC: 419A000C  beq cr6, 0x825a1fe8
	if ctx.cr[6].eq {
	pc = 0x825A1FE8; continue 'dispatch;
	}
	// 825A1FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A1FE4: 4BD1E8AD  bl 0x822c0890
	ctx.lr = 0x825A1FE8;
	sub_822C0890(ctx, base);
	// 825A1FE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1FF0: 419A0010  beq cr6, 0x825a2000
	if ctx.cr[6].eq {
	pc = 0x825A2000; continue 'dispatch;
	}
	// 825A1FF4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1FF8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A1FFC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A2000: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A2004: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A2008: 419A000C  beq cr6, 0x825a2014
	if ctx.cr[6].eq {
	pc = 0x825A2014; continue 'dispatch;
	}
	// 825A200C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2010: 4BD1E881  bl 0x822c0890
	ctx.lr = 0x825A2014;
	sub_822C0890(ctx, base);
	// 825A2014: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825A2018: 48851411  bl 0x82df3428
	ctx.lr = 0x825A201C;
	sub_82DF3428(ctx, base);
	// 825A201C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825A2020: 4BD26C99  bl 0x822c8cb8
	ctx.lr = 0x825A2024;
	sub_822C8CB8(ctx, base);
	// 825A2024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2028: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825A202C: 48C06190  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2030 size=224
    let mut pc: u32 = 0x825A2030;
    'dispatch: loop {
        match pc {
            0x825A2030 => {
    //   block [0x825A2030..0x825A2110)
	// 825A2030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2034: 48C06139  bl 0x831a816c
	ctx.lr = 0x825A2038;
	sub_831A8130(ctx, base);
	// 825A2038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A203C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2040: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2044: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825A2048: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A204C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A2050: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A2054: 38A00169  li r5, 0x169
	ctx.r[5].s64 = 361;
	// 825A2058: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825A205C: 4BD1E37D  bl 0x822c03d8
	ctx.lr = 0x825A2060;
	sub_822C03D8(ctx, base);
	// 825A2060: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2064: 4182001C  beq 0x825a2080
	if ctx.cr[0].eq {
	pc = 0x825A2080; continue 'dispatch;
	}
	// 825A2068: 38DF0008  addi r6, r31, 8
	ctx.r[6].s64 = ctx.r[31].s64 + 8;
	// 825A206C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2074: 4800617D  bl 0x825a81f0
	ctx.lr = 0x825A2078;
	sub_825A81F0(ctx, base);
	// 825A2078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A207C: 48000008  b 0x825a2084
	pc = 0x825A2084; continue 'dispatch;
	// 825A2080: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2084: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A208C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2090: 4BFFF1C1  bl 0x825a1250
	ctx.lr = 0x825A2094;
	sub_825A1250(ctx, base);
	// 825A2094: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A2098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A209C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A20A0: 4BD1DF61  bl 0x822c0000
	ctx.lr = 0x825A20A4;
	sub_822C0000(ctx, base);
	// 825A20A4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A20A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A20AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A20B0: 482339B9  bl 0x827d5a68
	ctx.lr = 0x825A20B4;
	sub_827D5A68(ctx, base);
	// 825A20B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A20B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A20BC: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A20C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A20C4: 4E800421  bctrl
	ctx.lr = 0x825A20C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A20C8: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 825A20CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A20D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A20D4: 48611035  bl 0x82bb3108
	ctx.lr = 0x825A20D8;
	sub_82BB3108(ctx, base);
	// 825A20D8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A20DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A20E0: 419A0010  beq cr6, 0x825a20f0
	if ctx.cr[6].eq {
	pc = 0x825A20F0; continue 'dispatch;
	}
	// 825A20E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A20E8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A20EC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A20F0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A20F4: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A20F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A20FC: 419A0008  beq cr6, 0x825a2104
	if ctx.cr[6].eq {
	pc = 0x825A2104; continue 'dispatch;
	}
	// 825A2100: 4BD1E791  bl 0x822c0890
	ctx.lr = 0x825A2104;
	sub_822C0890(ctx, base);
	// 825A2104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2108: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A210C: 48C060B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2110 size=120
    let mut pc: u32 = 0x825A2110;
    'dispatch: loop {
        match pc {
            0x825A2110 => {
    //   block [0x825A2110..0x825A2188)
	// 825A2110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2114: 48C06059  bl 0x831a816c
	ctx.lr = 0x825A2118;
	sub_831A8130(ctx, base);
	// 825A2118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A211C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A2120: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2124: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2128: 48233941  bl 0x827d5a68
	ctx.lr = 0x825A212C;
	sub_827D5A68(ctx, base);
	// 825A212C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2134: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A2138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A213C: 4E800421  bctrl
	ctx.lr = 0x825A2140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2140: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 825A2144: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2148: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A214C: 48610FBD  bl 0x82bb3108
	ctx.lr = 0x825A2150;
	sub_82BB3108(ctx, base);
	// 825A2150: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2158: 419A0010  beq cr6, 0x825a2168
	if ctx.cr[6].eq {
	pc = 0x825A2168; continue 'dispatch;
	}
	// 825A215C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2160: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A2164: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A2168: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A216C: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A2170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2174: 419A0008  beq cr6, 0x825a217c
	if ctx.cr[6].eq {
	pc = 0x825A217C; continue 'dispatch;
	}
	// 825A2178: 4BD1E719  bl 0x822c0890
	ctx.lr = 0x825A217C;
	sub_822C0890(ctx, base);
	// 825A217C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2184: 48C06038  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2188 size=292
    let mut pc: u32 = 0x825A2188;
    'dispatch: loop {
        match pc {
            0x825A2188 => {
    //   block [0x825A2188..0x825A22AC)
	// 825A2188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A218C: 48C05FE1  bl 0x831a816c
	ctx.lr = 0x825A2190;
	sub_831A8130(ctx, base);
	// 825A2190: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2194: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2198: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A219C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A21A0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825A21A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A21A8: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A21AC: 38A00144  li r5, 0x144
	ctx.r[5].s64 = 324;
	// 825A21B0: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 825A21B4: 4BD1E225  bl 0x822c03d8
	ctx.lr = 0x825A21B8;
	sub_822C03D8(ctx, base);
	// 825A21B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A21BC: 4182001C  beq 0x825a21d8
	if ctx.cr[0].eq {
	pc = 0x825A21D8; continue 'dispatch;
	}
	// 825A21C0: 38DF0008  addi r6, r31, 8
	ctx.r[6].s64 = ctx.r[31].s64 + 8;
	// 825A21C4: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A21C8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825A21CC: 480046C5  bl 0x825a6890
	ctx.lr = 0x825A21D0;
	sub_825A6890(ctx, base);
	// 825A21D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A21D4: 48000008  b 0x825a21dc
	pc = 0x825A21DC; continue 'dispatch;
	// 825A21D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A21DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A21E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A21E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A21E8: 4BFFEC81  bl 0x825a0e68
	ctx.lr = 0x825A21EC;
	sub_825A0E68(ctx, base);
	// 825A21EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A21F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A21F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A21F8: 4BD1DE09  bl 0x822c0000
	ctx.lr = 0x825A21FC;
	sub_822C0000(ctx, base);
	// 825A21FC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A2200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A2204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2208: 48233861  bl 0x827d5a68
	ctx.lr = 0x825A220C;
	sub_827D5A68(ctx, base);
	// 825A220C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2214: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A2218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A221C: 4E800421  bctrl
	ctx.lr = 0x825A2220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2220: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2224: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2228: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A222C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A2230: 419A0024  beq cr6, 0x825a2254
	if ctx.cr[6].eq {
	pc = 0x825A2254; continue 'dispatch;
	}
	// 825A2234: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825A2238: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A223C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A2240: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A2244: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A2248: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A224C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A2250: 4082FFE8  bne 0x825a2238
	if !ctx.cr[0].eq {
	pc = 0x825A2238; continue 'dispatch;
	}
	// 825A2254: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 825A2258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A225C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2260: 48610EA9  bl 0x82bb3108
	ctx.lr = 0x825A2264;
	sub_82BB3108(ctx, base);
	// 825A2264: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A2268: 419A000C  beq cr6, 0x825a2274
	if ctx.cr[6].eq {
	pc = 0x825A2274; continue 'dispatch;
	}
	// 825A226C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2270: 4BD1E621  bl 0x822c0890
	ctx.lr = 0x825A2274;
	sub_822C0890(ctx, base);
	// 825A2274: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A227C: 419A0010  beq cr6, 0x825a228c
	if ctx.cr[6].eq {
	pc = 0x825A228C; continue 'dispatch;
	}
	// 825A2280: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2284: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A2288: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A228C: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825A2290: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A2294: 419A000C  beq cr6, 0x825a22a0
	if ctx.cr[6].eq {
	pc = 0x825A22A0; continue 'dispatch;
	}
	// 825A2298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A229C: 4BD1E5F5  bl 0x822c0890
	ctx.lr = 0x825A22A0;
	sub_822C0890(ctx, base);
	// 825A22A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A22A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A22A8: 48C05F14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A22B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A22B0 size=80
    let mut pc: u32 = 0x825A22B0;
    'dispatch: loop {
        match pc {
            0x825A22B0 => {
    //   block [0x825A22B0..0x825A2300)
	// 825A22B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A22B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A22B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A22BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A22C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A22C4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825A22C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A22CC: 394AAB4C  addi r10, r10, -0x54b4
	ctx.r[10].s64 = ctx.r[10].s64 + -21684;
	// 825A22D0: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 825A22D4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A22D8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825A22DC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825A22E0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825A22E4: 4BD67145  bl 0x82309428
	ctx.lr = 0x825A22E8;
	sub_82309428(ctx, base);
	// 825A22E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A22EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A22F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A22F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A22F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A22FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2300 size=196
    let mut pc: u32 = 0x825A2300;
    'dispatch: loop {
        match pc {
            0x825A2300 => {
    //   block [0x825A2300..0x825A23C4)
	// 825A2300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A230C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A231C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A2320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2328: 4BD1E611  bl 0x822c0938
	ctx.lr = 0x825A232C;
	sub_822C0938(ctx, base);
	// 825A232C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2330: 41820028  beq 0x825a2358
	if ctx.cr[0].eq {
	pc = 0x825A2358; continue 'dispatch;
	}
	// 825A2334: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2338: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A233C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A2340: 392BAA80  addi r9, r11, -0x5580
	ctx.r[9].s64 = ctx.r[11].s64 + -21888;
	// 825A2344: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A2348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A234C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A2350: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A2354: 48000008  b 0x825a235c
	pc = 0x825A235C; continue 'dispatch;
	// 825A2358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A235C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2364: 409A0044  bne cr6, 0x825a23a8
	if !ctx.cr[6].eq {
	pc = 0x825A23A8; continue 'dispatch;
	}
	// 825A2368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A236C: 419A001C  beq cr6, 0x825a2388
	if ctx.cr[6].eq {
	pc = 0x825A2388; continue 'dispatch;
	}
	// 825A2370: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 825A2374: 4820AE75  bl 0x827ad1e8
	ctx.lr = 0x825A2378;
	sub_827AD1E8(ctx, base);
	// 825A2378: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825A237C: 4BF0EF25  bl 0x824b12a0
	ctx.lr = 0x825A2380;
	sub_824B12A0(ctx, base);
	// 825A2380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2384: 4BD1DEE5  bl 0x822c0268
	ctx.lr = 0x825A2388;
	sub_822C0268(ctx, base);
	// 825A2388: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A238C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A2390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2394: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A2398: 816B7944  lwz r11, 0x7944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31044 as u32) ) } as u64;
	// 825A239C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A23A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A23A4: 4BD1DC5D  bl 0x822c0000
	ctx.lr = 0x825A23A8;
	sub_822C0000(ctx, base);
	// 825A23A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A23AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A23B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A23B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A23B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A23BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A23C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A23C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A23C8 size=72
    let mut pc: u32 = 0x825A23C8;
    'dispatch: loop {
        match pc {
            0x825A23C8 => {
    //   block [0x825A23C8..0x825A2410)
	// 825A23C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A23CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A23D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A23D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A23D8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A23DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A23E0: 419A001C  beq cr6, 0x825a23fc
	if ctx.cr[6].eq {
	pc = 0x825A23FC; continue 'dispatch;
	}
	// 825A23E4: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 825A23E8: 4820AE01  bl 0x827ad1e8
	ctx.lr = 0x825A23EC;
	sub_827AD1E8(ctx, base);
	// 825A23EC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825A23F0: 4BF0EEB1  bl 0x824b12a0
	ctx.lr = 0x825A23F4;
	sub_824B12A0(ctx, base);
	// 825A23F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A23F8: 4BD1DE71  bl 0x822c0268
	ctx.lr = 0x825A23FC;
	sub_822C0268(ctx, base);
	// 825A23FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A2400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A240C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2410 size=232
    let mut pc: u32 = 0x825A2410;
    'dispatch: loop {
        match pc {
            0x825A2410 => {
    //   block [0x825A2410..0x825A24F8)
	// 825A2410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2414: 48C05D4D  bl 0x831a8160
	ctx.lr = 0x825A2418;
	sub_831A8130(ctx, base);
	// 825A2418: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A241C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2420: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A2424: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825A2428: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A242C: 388BAB08  addi r4, r11, -0x54f8
	ctx.r[4].s64 = ctx.r[11].s64 + -21752;
	// 825A2430: 38A000A3  li r5, 0xa3
	ctx.r[5].s64 = 163;
	// 825A2434: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825A2438: 4BD1DFA1  bl 0x822c03d8
	ctx.lr = 0x825A243C;
	sub_822C03D8(ctx, base);
	// 825A243C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2440: 41820010  beq 0x825a2450
	if ctx.cr[0].eq {
	pc = 0x825A2450; continue 'dispatch;
	}
	// 825A2444: 4BFFFE6D  bl 0x825a22b0
	ctx.lr = 0x825A2448;
	sub_825A22B0(ctx, base);
	// 825A2448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A244C: 48000008  b 0x825a2454
	pc = 0x825A2454; continue 'dispatch;
	// 825A2450: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2454: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825A2458: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825A245C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2464: 4BFFFE9D  bl 0x825a2300
	ctx.lr = 0x825A2468;
	sub_825A2300(ctx, base);
	// 825A2468: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A246C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2474: 4BD1DB8D  bl 0x822c0000
	ctx.lr = 0x825A2478;
	sub_822C0000(ctx, base);
	// 825A2478: 3B7A0004  addi r27, r26, 4
	ctx.r[27].s64 = ctx.r[26].s64 + 4;
	// 825A247C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A2480: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2484: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A248C: 419A0060  beq cr6, 0x825a24ec
	if ctx.cr[6].eq {
	pc = 0x825A24EC; continue 'dispatch;
	}
	// 825A2490: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2494: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A2498: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A249C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A24A0: 4098004C  bge cr6, 0x825a24ec
	if !ctx.cr[6].lt {
	pc = 0x825A24EC; continue 'dispatch;
	}
	// 825A24A4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A24A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A24AC: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A24B0: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825A24B4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A24B8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825A24BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A24C0: 4E800421  bctrl
	ctx.lr = 0x825A24C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A24C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A24C8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825A24CC: 48610C3D  bl 0x82bb3108
	ctx.lr = 0x825A24D0;
	sub_82BB3108(ctx, base);
	// 825A24D0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A24D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A24D8: 419A0008  beq cr6, 0x825a24e0
	if ctx.cr[6].eq {
	pc = 0x825A24E0; continue 'dispatch;
	}
	// 825A24DC: 4BD1E3B5  bl 0x822c0890
	ctx.lr = 0x825A24E0;
	sub_822C0890(ctx, base);
	// 825A24E0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825A24E4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825A24E8: 4BFFFF9C  b 0x825a2484
	pc = 0x825A2484; continue 'dispatch;
	// 825A24EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A24F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A24F4: 48C05CBC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A24F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A24F8 size=28
    let mut pc: u32 = 0x825A24F8;
    'dispatch: loop {
        match pc {
            0x825A24F8 => {
    //   block [0x825A24F8..0x825A2514)
	// 825A24F8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A24FC: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A2500: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A2504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2508: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A250C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2510: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2518 size=28
    let mut pc: u32 = 0x825A2518;
    'dispatch: loop {
        match pc {
            0x825A2518 => {
    //   block [0x825A2518..0x825A2534)
	// 825A2518: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A251C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A2520: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A2524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2528: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A252C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2530: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2538 size=72
    let mut pc: u32 = 0x825A2538;
    'dispatch: loop {
        match pc {
            0x825A2538 => {
    //   block [0x825A2538..0x825A2580)
	// 825A2538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A253C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2548: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A254C: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A2550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2554: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A2558: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A255C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825A2560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2564: 4E800421  bctrl
	ctx.lr = 0x825A2568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A256C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A2570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2578: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A257C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2580 size=72
    let mut pc: u32 = 0x825A2580;
    'dispatch: loop {
        match pc {
            0x825A2580 => {
    //   block [0x825A2580..0x825A25C8)
	// 825A2580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2588: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A258C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2590: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2594: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A2598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A259C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A25A0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A25A4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825A25A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A25AC: 4E800421  bctrl
	ctx.lr = 0x825A25B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A25B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A25B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A25B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A25BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A25C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A25C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A25C8 size=112
    let mut pc: u32 = 0x825A25C8;
    'dispatch: loop {
        match pc {
            0x825A25C8 => {
    //   block [0x825A25C8..0x825A2638)
	// 825A25C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A25CC: 48C05B99  bl 0x831a8164
	ctx.lr = 0x825A25D0;
	sub_831A8130(ctx, base);
	// 825A25D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A25D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A25D8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825A25DC: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 825A25E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A25E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A25E8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A25EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A25F0: 419A0040  beq cr6, 0x825a2630
	if ctx.cr[6].eq {
	pc = 0x825A2630; continue 'dispatch;
	}
	// 825A25F4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A25F8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A25FC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A2600: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A2604: 4098002C  bge cr6, 0x825a2630
	if !ctx.cr[6].lt {
	pc = 0x825A2630; continue 'dispatch;
	}
	// 825A2608: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A260C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A2610: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A2614: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2618: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825A261C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2620: 4E800421  bctrl
	ctx.lr = 0x825A2624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2624: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A2628: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A262C: 4BFFFFBC  b 0x825a25e8
	pc = 0x825A25E8; continue 'dispatch;
	// 825A2630: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2634: 48C05B80  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2638 size=104
    let mut pc: u32 = 0x825A2638;
    'dispatch: loop {
        match pc {
            0x825A2638 => {
    //   block [0x825A2638..0x825A26A0)
	// 825A2638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A263C: 48C05B2D  bl 0x831a8168
	ctx.lr = 0x825A2640;
	sub_831A8130(ctx, base);
	// 825A2640: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2644: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A2648: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A264C: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 825A2650: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A2654: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A265C: 419A003C  beq cr6, 0x825a2698
	if ctx.cr[6].eq {
	pc = 0x825A2698; continue 'dispatch;
	}
	// 825A2660: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2664: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A2668: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A266C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A2670: 40980028  bge cr6, 0x825a2698
	if !ctx.cr[6].lt {
	pc = 0x825A2698; continue 'dispatch;
	}
	// 825A2674: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2678: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A267C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2680: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A2684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2688: 4E800421  bctrl
	ctx.lr = 0x825A268C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A268C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A2690: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A2694: 4BFFFFC0  b 0x825a2654
	pc = 0x825A2654; continue 'dispatch;
	// 825A2698: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A269C: 48C05B1C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A26A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A26A0 size=104
    let mut pc: u32 = 0x825A26A0;
    'dispatch: loop {
        match pc {
            0x825A26A0 => {
    //   block [0x825A26A0..0x825A2708)
	// 825A26A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A26A4: 48C05AC5  bl 0x831a8168
	ctx.lr = 0x825A26A8;
	sub_831A8130(ctx, base);
	// 825A26A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A26AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A26B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A26B4: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 825A26B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A26BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A26C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A26C4: 419A003C  beq cr6, 0x825a2700
	if ctx.cr[6].eq {
	pc = 0x825A2700; continue 'dispatch;
	}
	// 825A26C8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A26CC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A26D0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825A26D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A26D8: 40980028  bge cr6, 0x825a2700
	if !ctx.cr[6].lt {
	pc = 0x825A2700; continue 'dispatch;
	}
	// 825A26DC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A26E0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A26E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A26E8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825A26EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A26F0: 4E800421  bctrl
	ctx.lr = 0x825A26F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A26F4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A26F8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825A26FC: 4BFFFFC0  b 0x825a26bc
	pc = 0x825A26BC; continue 'dispatch;
	// 825A2700: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2704: 48C05AB4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2708 size=28
    let mut pc: u32 = 0x825A2708;
    'dispatch: loop {
        match pc {
            0x825A2708 => {
    //   block [0x825A2708..0x825A2724)
	// 825A2708: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A270C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A2710: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A2714: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2718: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825A271C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2720: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2728 size=28
    let mut pc: u32 = 0x825A2728;
    'dispatch: loop {
        match pc {
            0x825A2728 => {
    //   block [0x825A2728..0x825A2744)
	// 825A2728: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A272C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A2730: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825A2734: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2738: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825A273C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2740: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2748 size=196
    let mut pc: u32 = 0x825A2748;
    'dispatch: loop {
        match pc {
            0x825A2748 => {
    //   block [0x825A2748..0x825A280C)
	// 825A2748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A274C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A2754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A275C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2764: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A2768: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A276C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2770: 4BD1E1C9  bl 0x822c0938
	ctx.lr = 0x825A2774;
	sub_822C0938(ctx, base);
	// 825A2774: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2778: 41820028  beq 0x825a27a0
	if ctx.cr[0].eq {
	pc = 0x825A27A0; continue 'dispatch;
	}
	// 825A277C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2780: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A2784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A2788: 392BAB58  addi r9, r11, -0x54a8
	ctx.r[9].s64 = ctx.r[11].s64 + -21672;
	// 825A278C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A2790: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A2794: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A2798: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A279C: 48000008  b 0x825a27a4
	pc = 0x825A27A4; continue 'dispatch;
	// 825A27A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A27A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A27A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A27AC: 409A0044  bne cr6, 0x825a27f0
	if !ctx.cr[6].eq {
	pc = 0x825A27F0; continue 'dispatch;
	}
	// 825A27B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A27B4: 419A001C  beq cr6, 0x825a27d0
	if ctx.cr[6].eq {
	pc = 0x825A27D0; continue 'dispatch;
	}
	// 825A27B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A27BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A27C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A27C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A27C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A27CC: 4E800421  bctrl
	ctx.lr = 0x825A27D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A27D0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A27D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A27D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A27DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A27E0: 816B7C2C  lwz r11, 0x7c2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31788 as u32) ) } as u64;
	// 825A27E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A27E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A27EC: 4BD1D815  bl 0x822c0000
	ctx.lr = 0x825A27F0;
	sub_822C0000(ctx, base);
	// 825A27F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A27F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A27F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A27FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2800: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2810 size=196
    let mut pc: u32 = 0x825A2810;
    'dispatch: loop {
        match pc {
            0x825A2810 => {
    //   block [0x825A2810..0x825A28D4)
	// 825A2810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A281C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A282C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A2830: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2834: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2838: 4BD1E101  bl 0x822c0938
	ctx.lr = 0x825A283C;
	sub_822C0938(ctx, base);
	// 825A283C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2840: 41820028  beq 0x825a2868
	if ctx.cr[0].eq {
	pc = 0x825A2868; continue 'dispatch;
	}
	// 825A2844: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2848: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A284C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A2850: 392BAB6C  addi r9, r11, -0x5494
	ctx.r[9].s64 = ctx.r[11].s64 + -21652;
	// 825A2854: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A2858: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A285C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A2860: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A2864: 48000008  b 0x825a286c
	pc = 0x825A286C; continue 'dispatch;
	// 825A2868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A286C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2874: 409A0044  bne cr6, 0x825a28b8
	if !ctx.cr[6].eq {
	pc = 0x825A28B8; continue 'dispatch;
	}
	// 825A2878: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A287C: 419A001C  beq cr6, 0x825a2898
	if ctx.cr[6].eq {
	pc = 0x825A2898; continue 'dispatch;
	}
	// 825A2880: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A2888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A288C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2894: 4E800421  bctrl
	ctx.lr = 0x825A2898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2898: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A289C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A28A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A28A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A28A8: 816B7C2C  lwz r11, 0x7c2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31788 as u32) ) } as u64;
	// 825A28AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A28B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A28B4: 4BD1D74D  bl 0x822c0000
	ctx.lr = 0x825A28B8;
	sub_822C0000(ctx, base);
	// 825A28B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A28BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A28C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A28C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A28C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A28CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A28D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A28D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A28D8 size=196
    let mut pc: u32 = 0x825A28D8;
    'dispatch: loop {
        match pc {
            0x825A28D8 => {
    //   block [0x825A28D8..0x825A299C)
	// 825A28D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A28DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A28E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A28E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A28E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A28EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A28F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A28F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A28F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A28FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2900: 4BD1E039  bl 0x822c0938
	ctx.lr = 0x825A2904;
	sub_822C0938(ctx, base);
	// 825A2904: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2908: 41820028  beq 0x825a2930
	if ctx.cr[0].eq {
	pc = 0x825A2930; continue 'dispatch;
	}
	// 825A290C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2910: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A2914: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A2918: 392BAB80  addi r9, r11, -0x5480
	ctx.r[9].s64 = ctx.r[11].s64 + -21632;
	// 825A291C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A2920: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A2924: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A2928: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A292C: 48000008  b 0x825a2934
	pc = 0x825A2934; continue 'dispatch;
	// 825A2930: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2934: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A293C: 409A0044  bne cr6, 0x825a2980
	if !ctx.cr[6].eq {
	pc = 0x825A2980; continue 'dispatch;
	}
	// 825A2940: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A2944: 419A001C  beq cr6, 0x825a2960
	if ctx.cr[6].eq {
	pc = 0x825A2960; continue 'dispatch;
	}
	// 825A2948: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A294C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A2950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2954: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2958: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A295C: 4E800421  bctrl
	ctx.lr = 0x825A2960;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2960: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A2964: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A2968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A296C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A2970: 816B7C2C  lwz r11, 0x7c2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31788 as u32) ) } as u64;
	// 825A2974: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A2978: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A297C: 4BD1D685  bl 0x822c0000
	ctx.lr = 0x825A2980;
	sub_822C0000(ctx, base);
	// 825A2980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A298C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A29A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A29A0 size=196
    let mut pc: u32 = 0x825A29A0;
    'dispatch: loop {
        match pc {
            0x825A29A0 => {
    //   block [0x825A29A0..0x825A2A64)
	// 825A29A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A29A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A29A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A29AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A29B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A29B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A29B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A29BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A29C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A29C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A29C8: 4BD1DF71  bl 0x822c0938
	ctx.lr = 0x825A29CC;
	sub_822C0938(ctx, base);
	// 825A29CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A29D0: 41820028  beq 0x825a29f8
	if ctx.cr[0].eq {
	pc = 0x825A29F8; continue 'dispatch;
	}
	// 825A29D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A29D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A29DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A29E0: 392BAB94  addi r9, r11, -0x546c
	ctx.r[9].s64 = ctx.r[11].s64 + -21612;
	// 825A29E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A29E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A29EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A29F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A29F4: 48000008  b 0x825a29fc
	pc = 0x825A29FC; continue 'dispatch;
	// 825A29F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A29FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2A00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2A04: 409A0044  bne cr6, 0x825a2a48
	if !ctx.cr[6].eq {
	pc = 0x825A2A48; continue 'dispatch;
	}
	// 825A2A08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A2A0C: 419A001C  beq cr6, 0x825a2a28
	if ctx.cr[6].eq {
	pc = 0x825A2A28; continue 'dispatch;
	}
	// 825A2A10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2A14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A2A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2A1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2A20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2A24: 4E800421  bctrl
	ctx.lr = 0x825A2A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2A28: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A2A2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A2A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2A34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A2A38: 816B7C2C  lwz r11, 0x7c2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31788 as u32) ) } as u64;
	// 825A2A3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A2A40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A2A44: 4BD1D5BD  bl 0x822c0000
	ctx.lr = 0x825A2A48;
	sub_822C0000(ctx, base);
	// 825A2A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2A4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2A50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2A54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2A58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2A5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2A68 size=196
    let mut pc: u32 = 0x825A2A68;
    'dispatch: loop {
        match pc {
            0x825A2A68 => {
    //   block [0x825A2A68..0x825A2B2C)
	// 825A2A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2A70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A2A74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2A78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2A7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2A80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2A84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A2A88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2A8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2A90: 4BD1DEA9  bl 0x822c0938
	ctx.lr = 0x825A2A94;
	sub_822C0938(ctx, base);
	// 825A2A94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2A98: 41820028  beq 0x825a2ac0
	if ctx.cr[0].eq {
	pc = 0x825A2AC0; continue 'dispatch;
	}
	// 825A2A9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2AA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A2AA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A2AA8: 392BABA8  addi r9, r11, -0x5458
	ctx.r[9].s64 = ctx.r[11].s64 + -21592;
	// 825A2AAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A2AB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A2AB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A2AB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A2ABC: 48000008  b 0x825a2ac4
	pc = 0x825A2AC4; continue 'dispatch;
	// 825A2AC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2AC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2ACC: 409A0044  bne cr6, 0x825a2b10
	if !ctx.cr[6].eq {
	pc = 0x825A2B10; continue 'dispatch;
	}
	// 825A2AD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A2AD4: 419A001C  beq cr6, 0x825a2af0
	if ctx.cr[6].eq {
	pc = 0x825A2AF0; continue 'dispatch;
	}
	// 825A2AD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2ADC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A2AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2AE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2AE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2AEC: 4E800421  bctrl
	ctx.lr = 0x825A2AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2AF0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A2AF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A2AF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2AFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A2B00: 816B7C2C  lwz r11, 0x7c2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31788 as u32) ) } as u64;
	// 825A2B04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A2B08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A2B0C: 4BD1D4F5  bl 0x822c0000
	ctx.lr = 0x825A2B10;
	sub_822C0000(ctx, base);
	// 825A2B10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2B14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2B18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2B1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2B20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2B24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2B30 size=196
    let mut pc: u32 = 0x825A2B30;
    'dispatch: loop {
        match pc {
            0x825A2B30 => {
    //   block [0x825A2B30..0x825A2BF4)
	// 825A2B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2B38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A2B3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2B44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2B4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A2B50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2B54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2B58: 4BD1DDE1  bl 0x822c0938
	ctx.lr = 0x825A2B5C;
	sub_822C0938(ctx, base);
	// 825A2B5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2B60: 41820028  beq 0x825a2b88
	if ctx.cr[0].eq {
	pc = 0x825A2B88; continue 'dispatch;
	}
	// 825A2B64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2B68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825A2B6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A2B70: 392BABBC  addi r9, r11, -0x5444
	ctx.r[9].s64 = ctx.r[11].s64 + -21572;
	// 825A2B74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A2B78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A2B7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A2B80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A2B84: 48000008  b 0x825a2b8c
	pc = 0x825A2B8C; continue 'dispatch;
	// 825A2B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2B8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2B94: 409A0044  bne cr6, 0x825a2bd8
	if !ctx.cr[6].eq {
	pc = 0x825A2BD8; continue 'dispatch;
	}
	// 825A2B98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A2B9C: 419A001C  beq cr6, 0x825a2bb8
	if ctx.cr[6].eq {
	pc = 0x825A2BB8; continue 'dispatch;
	}
	// 825A2BA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2BA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A2BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2BAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A2BB4: 4E800421  bctrl
	ctx.lr = 0x825A2BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A2BB8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825A2BBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A2BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2BC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825A2BC8: 816B7C2C  lwz r11, 0x7c2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31788 as u32) ) } as u64;
	// 825A2BCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A2BD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A2BD4: 4BD1D42D  bl 0x822c0000
	ctx.lr = 0x825A2BD8;
	sub_822C0000(ctx, base);
	// 825A2BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2BDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2BE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2BE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2BE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2BF8 size=92
    let mut pc: u32 = 0x825A2BF8;
    'dispatch: loop {
        match pc {
            0x825A2BF8 => {
    //   block [0x825A2BF8..0x825A2C54)
	// 825A2BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2C00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A2C04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2C08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2C10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2C14: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825A2C18: 396BABD0  addi r11, r11, -0x5430
	ctx.r[11].s64 = ctx.r[11].s64 + -21552;
	// 825A2C1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A2C20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A2C24: 4BF0E67D  bl 0x824b12a0
	ctx.lr = 0x825A2C28;
	sub_824B12A0(ctx, base);
	// 825A2C28: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A2C2C: 4182000C  beq 0x825a2c38
	if ctx.cr[0].eq {
	pc = 0x825A2C38; continue 'dispatch;
	}
	// 825A2C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2C34: 4BD1D635  bl 0x822c0268
	ctx.lr = 0x825A2C38;
	sub_822C0268(ctx, base);
	// 825A2C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2C48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2C4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2C58 size=32
    let mut pc: u32 = 0x825A2C58;
    'dispatch: loop {
        match pc {
            0x825A2C58 => {
    //   block [0x825A2C58..0x825A2C78)
	// 825A2C58: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825A2C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A2C60: 394AABD0  addi r10, r10, -0x5430
	ctx.r[10].s64 = ctx.r[10].s64 + -21552;
	// 825A2C64: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A2C68: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825A2C6C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825A2C70: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825A2C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2C78 size=148
    let mut pc: u32 = 0x825A2C78;
    'dispatch: loop {
        match pc {
            0x825A2C78 => {
    //   block [0x825A2C78..0x825A2D0C)
	// 825A2C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2C7C: 48C054F1  bl 0x831a816c
	ctx.lr = 0x825A2C80;
	sub_831A8130(ctx, base);
	// 825A2C80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2C84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2C88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A2C8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2C90: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A2C94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A2C98: 388BABD8  addi r4, r11, -0x5428
	ctx.r[4].s64 = ctx.r[11].s64 + -21544;
	// 825A2C9C: 38A00129  li r5, 0x129
	ctx.r[5].s64 = 297;
	// 825A2CA0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825A2CA4: 4BD1D735  bl 0x822c03d8
	ctx.lr = 0x825A2CA8;
	sub_822C03D8(ctx, base);
	// 825A2CA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2CAC: 41820018  beq 0x825a2cc4
	if ctx.cr[0].eq {
	pc = 0x825A2CC4; continue 'dispatch;
	}
	// 825A2CB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A2CB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2CB8: 480017B9  bl 0x825a4470
	ctx.lr = 0x825A2CBC;
	sub_825A4470(ctx, base);
	// 825A2CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2CC0: 48000008  b 0x825a2cc8
	pc = 0x825A2CC8; continue 'dispatch;
	// 825A2CC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2CC8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2CD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2CD4: 4BFFFCCD  bl 0x825a29a0
	ctx.lr = 0x825A2CD8;
	sub_825A29A0(ctx, base);
	// 825A2CD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A2CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2CE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2CE4: 4BD1D31D  bl 0x822c0000
	ctx.lr = 0x825A2CE8;
	sub_822C0000(ctx, base);
	// 825A2CE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2CEC: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825A2CF0: 48610419  bl 0x82bb3108
	ctx.lr = 0x825A2CF4;
	sub_82BB3108(ctx, base);
	// 825A2CF4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2CF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2CFC: 419A0008  beq cr6, 0x825a2d04
	if ctx.cr[6].eq {
	pc = 0x825A2D04; continue 'dispatch;
	}
	// 825A2D00: 4BD1DB91  bl 0x822c0890
	ctx.lr = 0x825A2D04;
	sub_822C0890(ctx, base);
	// 825A2D04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2D08: 48C054B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2D10 size=148
    let mut pc: u32 = 0x825A2D10;
    'dispatch: loop {
        match pc {
            0x825A2D10 => {
    //   block [0x825A2D10..0x825A2DA4)
	// 825A2D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2D14: 48C05459  bl 0x831a816c
	ctx.lr = 0x825A2D18;
	sub_831A8130(ctx, base);
	// 825A2D18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2D1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2D20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A2D24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2D28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A2D2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A2D30: 388BABD8  addi r4, r11, -0x5428
	ctx.r[4].s64 = ctx.r[11].s64 + -21544;
	// 825A2D34: 38A00129  li r5, 0x129
	ctx.r[5].s64 = 297;
	// 825A2D38: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825A2D3C: 4BD1D69D  bl 0x822c03d8
	ctx.lr = 0x825A2D40;
	sub_822C03D8(ctx, base);
	// 825A2D40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2D44: 41820018  beq 0x825a2d5c
	if ctx.cr[0].eq {
	pc = 0x825A2D5C; continue 'dispatch;
	}
	// 825A2D48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A2D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2D50: 48001891  bl 0x825a45e0
	ctx.lr = 0x825A2D54;
	sub_825A45E0(ctx, base);
	// 825A2D54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2D58: 48000008  b 0x825a2d60
	pc = 0x825A2D60; continue 'dispatch;
	// 825A2D5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2D60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2D64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2D68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2D6C: 4BFFFCFD  bl 0x825a2a68
	ctx.lr = 0x825A2D70;
	sub_825A2A68(ctx, base);
	// 825A2D70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A2D74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2D78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2D7C: 4BD1D285  bl 0x822c0000
	ctx.lr = 0x825A2D80;
	sub_822C0000(ctx, base);
	// 825A2D80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2D84: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825A2D88: 48610381  bl 0x82bb3108
	ctx.lr = 0x825A2D8C;
	sub_82BB3108(ctx, base);
	// 825A2D8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2D90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2D94: 419A0008  beq cr6, 0x825a2d9c
	if ctx.cr[6].eq {
	pc = 0x825A2D9C; continue 'dispatch;
	}
	// 825A2D98: 4BD1DAF9  bl 0x822c0890
	ctx.lr = 0x825A2D9C;
	sub_822C0890(ctx, base);
	// 825A2D9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2DA0: 48C0541C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2DA8 size=148
    let mut pc: u32 = 0x825A2DA8;
    'dispatch: loop {
        match pc {
            0x825A2DA8 => {
    //   block [0x825A2DA8..0x825A2E3C)
	// 825A2DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2DAC: 48C053C1  bl 0x831a816c
	ctx.lr = 0x825A2DB0;
	sub_831A8130(ctx, base);
	// 825A2DB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2DB4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2DB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A2DBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2DC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A2DC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A2DC8: 388BABD8  addi r4, r11, -0x5428
	ctx.r[4].s64 = ctx.r[11].s64 + -21544;
	// 825A2DCC: 38A00129  li r5, 0x129
	ctx.r[5].s64 = 297;
	// 825A2DD0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825A2DD4: 4BD1D605  bl 0x822c03d8
	ctx.lr = 0x825A2DD8;
	sub_822C03D8(ctx, base);
	// 825A2DD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2DDC: 41820018  beq 0x825a2df4
	if ctx.cr[0].eq {
	pc = 0x825A2DF4; continue 'dispatch;
	}
	// 825A2DE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A2DE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2DE8: 48001969  bl 0x825a4750
	ctx.lr = 0x825A2DEC;
	sub_825A4750(ctx, base);
	// 825A2DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2DF0: 48000008  b 0x825a2df8
	pc = 0x825A2DF8; continue 'dispatch;
	// 825A2DF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2DF8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2DFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2E00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2E04: 4BFFFD2D  bl 0x825a2b30
	ctx.lr = 0x825A2E08;
	sub_825A2B30(ctx, base);
	// 825A2E08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A2E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2E10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2E14: 4BD1D1ED  bl 0x822c0000
	ctx.lr = 0x825A2E18;
	sub_822C0000(ctx, base);
	// 825A2E18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2E1C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825A2E20: 486102E9  bl 0x82bb3108
	ctx.lr = 0x825A2E24;
	sub_82BB3108(ctx, base);
	// 825A2E24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2E2C: 419A0008  beq cr6, 0x825a2e34
	if ctx.cr[6].eq {
	pc = 0x825A2E34; continue 'dispatch;
	}
	// 825A2E30: 4BD1DA61  bl 0x822c0890
	ctx.lr = 0x825A2E34;
	sub_822C0890(ctx, base);
	// 825A2E34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2E38: 48C05384  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2E40 size=148
    let mut pc: u32 = 0x825A2E40;
    'dispatch: loop {
        match pc {
            0x825A2E40 => {
    //   block [0x825A2E40..0x825A2ED4)
	// 825A2E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2E44: 48C05329  bl 0x831a816c
	ctx.lr = 0x825A2E48;
	sub_831A8130(ctx, base);
	// 825A2E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2E4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2E50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A2E54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2E58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A2E5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A2E60: 388BABD8  addi r4, r11, -0x5428
	ctx.r[4].s64 = ctx.r[11].s64 + -21544;
	// 825A2E64: 38A00129  li r5, 0x129
	ctx.r[5].s64 = 297;
	// 825A2E68: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825A2E6C: 4BD1D56D  bl 0x822c03d8
	ctx.lr = 0x825A2E70;
	sub_822C03D8(ctx, base);
	// 825A2E70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2E74: 41820018  beq 0x825a2e8c
	if ctx.cr[0].eq {
	pc = 0x825A2E8C; continue 'dispatch;
	}
	// 825A2E78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A2E7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2E80: 48001A41  bl 0x825a48c0
	ctx.lr = 0x825A2E84;
	sub_825A48C0(ctx, base);
	// 825A2E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2E88: 48000008  b 0x825a2e90
	pc = 0x825A2E90; continue 'dispatch;
	// 825A2E8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2E90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2E94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2E98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2E9C: 4BFFF8AD  bl 0x825a2748
	ctx.lr = 0x825A2EA0;
	sub_825A2748(ctx, base);
	// 825A2EA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A2EA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2EA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2EAC: 4BD1D155  bl 0x822c0000
	ctx.lr = 0x825A2EB0;
	sub_822C0000(ctx, base);
	// 825A2EB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2EB4: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825A2EB8: 48610251  bl 0x82bb3108
	ctx.lr = 0x825A2EBC;
	sub_82BB3108(ctx, base);
	// 825A2EBC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2EC4: 419A0008  beq cr6, 0x825a2ecc
	if ctx.cr[6].eq {
	pc = 0x825A2ECC; continue 'dispatch;
	}
	// 825A2EC8: 4BD1D9C9  bl 0x822c0890
	ctx.lr = 0x825A2ECC;
	sub_822C0890(ctx, base);
	// 825A2ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2ED0: 48C052EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2ED8 size=148
    let mut pc: u32 = 0x825A2ED8;
    'dispatch: loop {
        match pc {
            0x825A2ED8 => {
    //   block [0x825A2ED8..0x825A2F6C)
	// 825A2ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2EDC: 48C05291  bl 0x831a816c
	ctx.lr = 0x825A2EE0;
	sub_831A8130(ctx, base);
	// 825A2EE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2EE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825A2EE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A2EEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A2EF0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A2EF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825A2EF8: 388BABD8  addi r4, r11, -0x5428
	ctx.r[4].s64 = ctx.r[11].s64 + -21544;
	// 825A2EFC: 38A00129  li r5, 0x129
	ctx.r[5].s64 = 297;
	// 825A2F00: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825A2F04: 4BD1D4D5  bl 0x822c03d8
	ctx.lr = 0x825A2F08;
	sub_822C03D8(ctx, base);
	// 825A2F08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825A2F0C: 41820018  beq 0x825a2f24
	if ctx.cr[0].eq {
	pc = 0x825A2F24; continue 'dispatch;
	}
	// 825A2F10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A2F14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2F18: 48001AE9  bl 0x825a4a00
	ctx.lr = 0x825A2F1C;
	sub_825A4A00(ctx, base);
	// 825A2F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2F20: 48000008  b 0x825a2f28
	pc = 0x825A2F28; continue 'dispatch;
	// 825A2F24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A2F28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A2F2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2F30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2F34: 4BFFF8DD  bl 0x825a2810
	ctx.lr = 0x825A2F38;
	sub_825A2810(ctx, base);
	// 825A2F38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A2F3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A2F40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A2F44: 4BD1D0BD  bl 0x822c0000
	ctx.lr = 0x825A2F48;
	sub_822C0000(ctx, base);
	// 825A2F48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2F4C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825A2F50: 486101B9  bl 0x82bb3108
	ctx.lr = 0x825A2F54;
	sub_82BB3108(ctx, base);
	// 825A2F54: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2F58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2F5C: 419A0008  beq cr6, 0x825a2f64
	if ctx.cr[6].eq {
	pc = 0x825A2F64; continue 'dispatch;
	}
	// 825A2F60: 4BD1D931  bl 0x822c0890
	ctx.lr = 0x825A2F64;
	sub_822C0890(ctx, base);
	// 825A2F64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2F68: 48C05254  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2F70 size=100
    let mut pc: u32 = 0x825A2F70;
    'dispatch: loop {
        match pc {
            0x825A2F70 => {
    //   block [0x825A2F70..0x825A2FD4)
	// 825A2F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A2F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2F88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A2F8C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825A2F90: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825A2F94: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825A2F98: 48850159  bl 0x82df30f0
	ctx.lr = 0x825A2F9C;
	sub_82DF30F0(ctx, base);
	// 825A2F9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2FA4: 419A0010  beq cr6, 0x825a2fb4
	if ctx.cr[6].eq {
	pc = 0x825A2FB4; continue 'dispatch;
	}
	// 825A2FA8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2FAC: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825A2FB0: 48000008  b 0x825a2fb8
	pc = 0x825A2FB8; continue 'dispatch;
	// 825A2FB4: 9BDF0004  stb r30, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 825A2FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2FBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2FC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2FD8 size=116
    let mut pc: u32 = 0x825A2FD8;
    'dispatch: loop {
        match pc {
            0x825A2FD8 => {
    //   block [0x825A2FD8..0x825A304C)
	// 825A2FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2FE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A2FE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2FE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2FEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2FF0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A2FF4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825A2FF8: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825A2FFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A3000: 4BFE8F11  bl 0x8258bf10
	ctx.lr = 0x825A3004;
	sub_8258BF10(ctx, base);
	// 825A3004: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825A3008: 488500E9  bl 0x82df30f0
	ctx.lr = 0x825A300C;
	sub_82DF30F0(ctx, base);
	// 825A300C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3014: 419A000C  beq cr6, 0x825a3020
	if ctx.cr[6].eq {
	pc = 0x825A3020; continue 'dispatch;
	}
	// 825A3018: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A301C: 48000008  b 0x825a3024
	pc = 0x825A3024; continue 'dispatch;
	// 825A3020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A3024: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825A3028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A302C: 4BD25C8D  bl 0x822c8cb8
	ctx.lr = 0x825A3030;
	sub_822C8CB8(ctx, base);
	// 825A3030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A3038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A303C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A3040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A3044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A3048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A3050 size=100
    let mut pc: u32 = 0x825A3050;
    'dispatch: loop {
        match pc {
            0x825A3050 => {
    //   block [0x825A3050..0x825A30B4)
	// 825A3050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A3054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A3058: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A305C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A3060: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A3064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A3068: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A306C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825A3070: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825A3074: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825A3078: 48850B89  bl 0x82df3c00
	ctx.lr = 0x825A307C;
	sub_82DF3C00(ctx, base);
	// 825A307C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3084: 419A0010  beq cr6, 0x825a3094
	if ctx.cr[6].eq {
	pc = 0x825A3094; continue 'dispatch;
	}
	// 825A3088: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A308C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825A3090: 48000008  b 0x825a3098
	pc = 0x825A3098; continue 'dispatch;
	// 825A3094: 9BDF0004  stb r30, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 825A3098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A309C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A30A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A30A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A30A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A30AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A30B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A30B8 size=100
    let mut pc: u32 = 0x825A30B8;
    'dispatch: loop {
        match pc {
            0x825A30B8 => {
    //   block [0x825A30B8..0x825A311C)
	// 825A30B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A30BC: 48C050B1  bl 0x831a816c
	ctx.lr = 0x825A30C0;
	sub_831A8130(ctx, base);
	// 825A30C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A30C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A30C8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825A30CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825A30D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A30D4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825A30D8: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825A30DC: 4BFE8E35  bl 0x8258bf10
	ctx.lr = 0x825A30E0;
	sub_8258BF10(ctx, base);
	// 825A30E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A30E4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825A30E8: 48850B19  bl 0x82df3c00
	ctx.lr = 0x825A30EC;
	sub_82DF3C00(ctx, base);
	// 825A30EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A30F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A30F4: 419A000C  beq cr6, 0x825a3100
	if ctx.cr[6].eq {
	pc = 0x825A3100; continue 'dispatch;
	}
	// 825A30F8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A30FC: 48000008  b 0x825a3104
	pc = 0x825A3104; continue 'dispatch;
	// 825A3100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A3104: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825A3108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A310C: 4BD25BAD  bl 0x822c8cb8
	ctx.lr = 0x825A3110;
	sub_822C8CB8(ctx, base);
	// 825A3110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A3118: 48C050A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A3120 size=140
    let mut pc: u32 = 0x825A3120;
    'dispatch: loop {
        match pc {
            0x825A3120 => {
    //   block [0x825A3120..0x825A31AC)
	// 825A3120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A3124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A3128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A312C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A3130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A3134: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A3138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A313C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 825A3140: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825A3144: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A3148: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825A314C: D05F000C  stfs f2, 0xc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825A3150: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825A3154: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A3158: D03F0008  stfs f1, 8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825A315C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825A3160: 4BFE8DB1  bl 0x8258bf10
	ctx.lr = 0x825A3164;
	sub_8258BF10(ctx, base);
	// 825A3164: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825A3168: 4884FF89  bl 0x82df30f0
	ctx.lr = 0x825A316C;
	sub_82DF30F0(ctx, base);
	// 825A316C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3174: 419A000C  beq cr6, 0x825a3180
	if ctx.cr[6].eq {
	pc = 0x825A3180; continue 'dispatch;
	}
	// 825A3178: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A317C: 48000008  b 0x825a3184
	pc = 0x825A3184; continue 'dispatch;
	// 825A3180: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A3184: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825A3188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A318C: 4BD25B2D  bl 0x822c8cb8
	ctx.lr = 0x825A3190;
	sub_822C8CB8(ctx, base);
	// 825A3190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A3198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A319C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A31A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A31A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A31A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A31B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A31B0 size=116
    let mut pc: u32 = 0x825A31B0;
    'dispatch: loop {
        match pc {
            0x825A31B0 => {
    //   block [0x825A31B0..0x825A3224)
	// 825A31B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A31B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A31B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A31BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A31C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A31C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A31C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A31CC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825A31D0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A31D4: D05F000C  stfs f2, 0xc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825A31D8: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825A31DC: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825A31E0: D03F0008  stfs f1, 8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825A31E4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825A31E8: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 825A31EC: 4884FF05  bl 0x82df30f0
	ctx.lr = 0x825A31F0;
	sub_82DF30F0(ctx, base);
	// 825A31F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A31F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A31F8: 419A000C  beq cr6, 0x825a3204
	if ctx.cr[6].eq {
	pc = 0x825A3204; continue 'dispatch;
	}
	// 825A31FC: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A3200: 48000008  b 0x825a3208
	pc = 0x825A3208; continue 'dispatch;
	// 825A3204: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A3208: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825A320C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3210: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A3214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A3218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A321C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A3220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A3228 size=124
    let mut pc: u32 = 0x825A3228;
    'dispatch: loop {
        match pc {
            0x825A3228 => {
    //   block [0x825A3228..0x825A32A4)
	// 825A3228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A322C: 48C04F41  bl 0x831a816c
	ctx.lr = 0x825A3230;
	sub_831A8130(ctx, base);
	// 825A3230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A3234: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A3238: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A323C: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 825A3240: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825A3244: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A3248: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A324C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825A3250: D05F000C  stfs f2, 0xc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825A3254: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825A3258: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825A325C: D03F0008  stfs f1, 8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825A3260: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825A3264: 4BFE8CAD  bl 0x8258bf10
	ctx.lr = 0x825A3268;
	sub_8258BF10(ctx, base);
	// 825A3268: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A326C: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825A3270: 48850991  bl 0x82df3c00
	ctx.lr = 0x825A3274;
	sub_82DF3C00(ctx, base);
	// 825A3274: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A327C: 419A000C  beq cr6, 0x825a3288
	if ctx.cr[6].eq {
	pc = 0x825A3288; continue 'dispatch;
	}
	// 825A3280: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A3284: 48000008  b 0x825a328c
	pc = 0x825A328C; continue 'dispatch;
	// 825A3288: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A328C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825A3290: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A3294: 4BD25A25  bl 0x822c8cb8
	ctx.lr = 0x825A3298;
	sub_822C8CB8(ctx, base);
	// 825A3298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A329C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A32A0: 48C04F1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A32A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A32A8 size=116
    let mut pc: u32 = 0x825A32A8;
    'dispatch: loop {
        match pc {
            0x825A32A8 => {
    //   block [0x825A32A8..0x825A331C)
	// 825A32A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A32AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A32B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A32B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A32B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A32BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A32C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A32C4: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825A32C8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A32CC: D05F000C  stfs f2, 0xc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825A32D0: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825A32D4: D07F0010  stfs f3, 0x10(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825A32D8: D03F0008  stfs f1, 8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825A32DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825A32E0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 825A32E4: 4885091D  bl 0x82df3c00
	ctx.lr = 0x825A32E8;
	sub_82DF3C00(ctx, base);
	// 825A32E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A32EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A32F0: 419A000C  beq cr6, 0x825a32fc
	if ctx.cr[6].eq {
	pc = 0x825A32FC; continue 'dispatch;
	}
	// 825A32F4: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A32F8: 48000008  b 0x825a3300
	pc = 0x825A3300; continue 'dispatch;
	// 825A32FC: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A3300: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825A3304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3308: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A330C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A3310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A3314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A3318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


